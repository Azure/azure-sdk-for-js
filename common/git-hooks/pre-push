#!/usr/bin/env node

const { execSync } = require('child_process');

function getRemoteName() {
  try {
    const remoteName = execSync(`git rev-parse --abbrev-ref --symbolic-full-name @{u}`)
    .toString()
    .trim()
    .split('/');
    return remoteName[0];
  } catch (e) {
    return '';
  }
}

function getLocalCommitsNotMerged() {
  // Fetch updates from the remote repository
  execSync('git fetch');

  const remoteName = getRemoteName();
  if (remoteName == '') return [];

  // Get the list of commits not merged to the remote main branch
  const localCommitsNotMerged = execSync(`git log ${remoteName}/main..HEAD --oneline`)
    .toString()
    .trim()
    .split('\n');

  return localCommitsNotMerged.map((localCommit) => localCommit.split(' ')[0].trim());
}

function getListOfFilesForSingleCommit(commit) {
  const files = execSync(`git diff-tree --no-commit-id --name-only ${commit} -r`, {
    encoding: 'utf-8',
    stdio: 'pipe',
  }).trim();
  return files.split('\n');
}

function getListOfModifiedProjects(commits) {
  const fileSet = new Set();
  
  commits.map((commit) => {
    const files = getListOfFilesForSingleCommit(commit);
    files.forEach(file => {
      if (file.startsWith('sdk/')) {
        const extractedFilePath = extractPathPrefix(file);
        fileSet.add(extractedFilePath);
      }
    })
  });

  return Array.from(fileSet);
}

function extractPathPrefix(inputString) {
  const regex = /^(sdk\/[^\/]+\/[^\/]+)\/.*$/;
  const match = inputString.match(regex);

  if (match && match[1]) {
    return match[1];
  } else {
    return null;
  }
}

function executeScript(projectFolderPath, script) {
  const originalCwd = process.cwd();
  let err = '';
  try {
    // Change directory to the project folder
    process.chdir(projectFolderPath);

    const output = execSync(`${script} 2>&1`,  { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] });    
  } catch (error) {
    err =  error.stdout.toString();
  } finally {
    process.chdir(originalCwd);
  }
  return err;
}

async function execute(listOfModifiedProjects, check_script, fix_script) {
  const errors = [];
  listOfModifiedProjects.forEach((projectFolderPath) => {
    const error = executeScript(projectFolderPath, check_script);
    if (error !== '') {
      errors.push({
        project: projectFolderPath,
        err: error
      })
    }
  });

  if (errors.length != 0) {
    console.log(`You have the following errors in your code.`);
    console.log();
    errors.forEach(error => {
      console.log(`============================`);
      console.log(`Project: ${error.project}`);
      console.log(`Errors: ${error.err}`);
      console.log(`============================`);
    });

    console.log(`\nThis will cause a CI Failure. Fixing it now. Please commit the fixes before pushing the changes.........\n`);

    listOfModifiedProjects.forEach((projectFolderPath) => {
      executeScript(projectFolderPath, fix_script);
    });

    return true;
  }
  return false;
}

console.log("About to Push the code to Github\n");

async function main() {
  const localCommits = getLocalCommitsNotMerged();
  if (localCommits.length != 0 && localCommits[0].trim() == '') {
    console.log('No local commits to push');
    process.exit(0);
  }
  const listOfModifiedProjects  = getListOfModifiedProjects(localCommits);
  const abortStatus = await execute(listOfModifiedProjects, 'rushx check-format', 'rushx format');
  if (abortStatus) {
    process.exit(1);
  }
}

main();
