parameters:
  Artifacts: []
  ServiceDirectory: not-specified
  TestPipeline: false

steps:
  # - template: /eng/common/pipelines/templates/steps/check-spelling.yml

  - task: PowerShell@2
    inputs:
      targetType: 'filePath'
      filePath: eng/scripts/spell-check-public-api.ps1
      arguments: -ServiceDirectory ${{ parameters.ServiceDirectory }}
      pwsh: true
    displayName: Spell check public API

  - template: /eng/common/pipelines/templates/steps/set-test-pipeline-version.yml
    parameters:
      PackageName: "@azure/template"
      ServiceDirectory: "template"
      TestPipeline: ${{ parameters.TestPipeline }}

  - task: PublishPipelineArtifact@1
    condition: succeededOrFailed()
    displayName: "Publish Report Artifacts"
    inputs:
      artifactName: package-diffs
      path: $(Build.ArtifactStagingDirectory)

  # - template: /eng/common/pipelines/templates/steps/verify-readme.yml
  #   parameters:
  #     ScanPath: $(Build.SourcesDirectory)/sdk/${{ parameters.ServiceDirectory }}

  # - template: /eng/common/pipelines/templates/steps/verify-path-length.yml
  #   parameters:
  #     SourceDirectory: $(Build.SourcesDirectory)

  # - template: /eng/common/pipelines/templates/steps/verify-links.yml
  #   parameters:
  #     ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
  #       Directory: ""
  #       Urls: (eng/common/scripts/get-markdown-files-from-changed-files.ps1)
  #     ${{ if ne(variables['Build.Reason'], 'PullRequest') }}:
  #       Directory: sdk/${{ parameters.ServiceDirectory }}
  #     CheckLinkGuidance: $true
  
  - script: |
      echo "TEST INFO";
      echo "Build.ArtifactStagingDirectory = $(Build.ArtifactStagingDirectory)";
      echo "Build.SourcesDirectory = $(Build.SourcesDirectory)";
      echo "artifacts name = ${{parameters.artifacts[0].name}}";
      echo "workspace = $(Pipeline.Workspace)";
      echo "parameters.ServiceDirectory = ${{ parameters.ServiceDirectory }}"
      echo "ArtifactsDirectory = $(System.ArtifactsDirectory)"
      
      echo "TREE===========================";
      tree $(Pipeline.Workspace)

    displayName: "test script"


  # WRAP THIS INTO A LOOP FOR EACH ARTIFACT - NO NEED ANYMORE
  - ${{ each artifact in parameters.Artifacts }}:
    - script: echo "artifact name = ${{ artifact.name }}"
      displayName: "print artifact name"

    - script: |
        tree $(Pipeline.Workspace)
      displayName: "Show tree"

    # FIRST CONSUME ARTIFACTS ()
    - powershell: gci env:* | sort-object name | Format-Table -AutoSize | Out-File $env:BUILD_ARTIFACTSTAGINGDIRECTORY/environment-variables.txt
    
    - task: DownloadPipelineArtifact@2
      inputs:
        source: 'current' # Options: current, specific
        #project: # Required when source == Specific
        #pipeline: # Required when source == Specific
        #preferTriggeringPipeline: false # Optional
        #runVersion: 'latest' # Required when source == Specific# Options: latest, latestFromBranch, specific
        #runBranch: 'refs/heads/master' # Required when source == Specific && RunVersion == LatestFromBranch
        #runId: # Required when source == Specific && RunVersion == Specific
        #tags: # Optional
        artifact: 'packages' # Optional
        #patterns: '**' # Optional
        path: '$(Pipeline.Workspace)/downloaded-artifacts'
    - script: |
        tree $(Pipeline.Workspace)/downloaded-artifacts
      displayName: "Show tree"

    # Then I have tu extract the files and store them somewhere.
    # Extract a variety of archive and compression files such as .7z, .rar, .tar.gz, and .zip
    - task: ExtractFiles@1
      inputs:
        archiveFilePatterns: '$(Pipeline.Workspace)/downloaded-artifacts/**/*.zip' 
        destinationFolder: '$(Pipeline.Workspace)/html-docs/'
        #cleanDestinationFolder: true 
        #overwriteExistingFiles: false

    - script: |
        tree $(Pipeline.Workspace)/html-docs
      displayName: "Show tree"
 
    # NOW CALL VERIFY LINKS, again, with the artifact url
  
    - template: /eng/common/pipelines/templates/steps/verify-links.yml
      parameters:
        ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
          Directory: "$(Build.ArtifactStagingDirectory)/packages/${{ parameters.ServiceDirectory }}/documentation/*.zip"
          Urls: (eng/common/scripts/get-markdown-files-from-changed-files.ps1)
        ${{ if ne(variables['Build.Reason'], 'PullRequest') }}:
          Directory: sdk/${{ parameters.ServiceDirectory }}
        ${{ if ne(variables['Build.Reason'], 'PullRequest') }}:
          # HERE I NEED A PATH TO THE HTML FOLDER
          Urls: '(Get-ChildItem -Path $(Pipeline.Workspace)/html-docs/ -Recurse -Include *.html)'
        CheckLinkGuidance: $true
    

  - template: /eng/common/pipelines/templates/steps/verify-samples.yml
    parameters:
      ServiceDirectory: ${{ parameters.ServiceDirectory }}

  - script: |
      npm ci
    workingDirectory: $(System.DefaultWorkingDirectory)/eng/tools/analyze-deps
    displayName: "Install tool dependencies"

  - script: |
      node index.js --verbose --dump "$(Build.ArtifactStagingDirectory)/data.js" --out "$(Build.ArtifactStagingDirectory)/dependencies.html"
    workingDirectory: $(System.DefaultWorkingDirectory)/eng/tools/analyze-deps
    displayName: "Analyze library dependencies"

  - template: /eng/pipelines/templates/steps/run-eslint.yml
    parameters:
      ServiceDirectory: ${{ parameters.ServiceDirectory }}

  - template: /eng/pipelines/templates/steps/set-artifact-packages.yml
    parameters:
      Artifacts: ${{ parameters.Artifacts }}

  - pwsh: |
      node eng/tools/rush-runner.js check-format "${{parameters.ServiceDirectory}}" -packages "$(ArtifactPackageNames)" --verbose
    displayName: "Check Format in Libraries"

  - script: |
      node eng/tools/rush-runner.js audit "${{parameters.ServiceDirectory}}" -packages "$(ArtifactPackageNames)"
    condition: and(succeeded(), eq(variables['RunNpmAudit'], 'true'))
    displayName: "Audit libraries"

  - ${{ each artifact in parameters.Artifacts }}:
      - template: /eng/common/pipelines/templates/steps/verify-changelog.yml
        parameters:
          PackageName: ${{artifact.name}}
          ServiceName: ${{parameters.ServiceDirectory}}
          ForRelease: false

  - task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0
    # ComponentGovernance is currently unable to run on pull requests of public projects. Running on non-PR
    # builds should be sufficient.
    condition: and(succeededOrFailed(), ne(variables['Build.Reason'], 'PullRequest'))
    displayName: "Component Detection"

    # Unlink node_modules folders to significantly improve performance of subsequent tasks
    # which need to walk the directory tree (and are hardcoded to follow symlinks).
  - script: |
      node eng/tools/rush-runner.js unlink
    displayName: "Unlink dependencies"

    # It's important for performance to pass "sdk" as "sourceFolder" rather than as a prefix in "contents".
    # The task first enumerates all files under "sourceFolder", then matches them against the "contents" pattern.
  - task: CopyFiles@2
    inputs:
      sourceFolder: sdk
      contents: "**/**/*lintReport.html"
      targetFolder: $(Build.ArtifactStagingDirectory)
      flattenFolders: true
    displayName: "Copy lint reports"

  - template: /eng/common/pipelines/templates/steps/publish-artifact.yml
    parameters:
      ArtifactPath: '$(Build.ArtifactStagingDirectory)'
      ArtifactName: 'reports'

  - template: /eng/common/pipelines/templates/steps/eng-common-workflow-enforcer.yml
