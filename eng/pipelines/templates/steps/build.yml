parameters:
  Artifacts: []
  TestPipeline: false
  ServiceDirectory: not-specified
  IncludeRelease: true

steps:
  - template: /eng/common/pipelines/templates/steps/set-test-pipeline-version.yml
    parameters:
      PackageName: "@azure/template"
      ServiceDirectory: "template"
      TestPipeline: ${{ parameters.TestPipeline }}

  - pwsh: |
      $folder = "${{parameters.ServiceDirectory}}"
      if ($folder -eq "*" -or $folder -eq "auto") { $folder = "" }
      echo "##vso[task.setvariable variable=folder]$folder"
    displayName: "Set folder variable for readme links"

  # Create package info file with package version before it's updated to daily dev version
  - template: /eng/common/pipelines/templates/steps/save-package-properties.yml
    parameters:
      ServiceDirectory: ${{parameters.ServiceDirectory}}

  # we are not passing service directory, so we only ever set dev build to true
  - template: /eng/common/pipelines/templates/steps/daily-dev-build-variable.yml

  - script: |
      npm install -g pnpm
    displayName: "Install Pnpm"

  - script: |
      npm ci
    condition: and(succeeded(),eq(variables['SetDevVersion'],'true'))
    workingDirectory: ./eng/tools/eng-package-utils
    displayName: Install eng-package-utils dependencies

  - script: |
      npm ci
    condition: and(succeeded(),eq(variables['SetDevVersion'],'true'))
    workingDirectory: ./eng/tools/versioning
    displayName: Install versioning tool dependencies

  - script: |
      node eng/tools/versioning/set-dev.js --build-id "$(Build.BuildNumber)" --repo-root "$(Build.SourcesDirectory)" --service "$(folder)"
    condition: and(succeeded(),eq(variables['SetDevVersion'],'true'))
    displayName: "Update package versions for dev build"

  - script: |
      pnpm install --no-frozen-lockfile
    condition: and(succeeded(),eq(variables['SetDevVersion'],'true'))
    displayName: "Install library dependencies after setting dev version"

  # Update the package info file to include dev version
  - template: /eng/common/pipelines/templates/steps/save-package-properties.yml
    parameters:
      ServiceDirectory: ${{parameters.ServiceDirectory}}

  - script: |
      pnpm install
    condition: and(succeeded(),ne(variables['SetDevVersion'],'true'))
    displayName: "Install library dependencies"

  - ${{ if and(eq(variables['System.TeamProject'], 'internal'), in(variables['Build.Reason'], 'IndividualCI', 'BatchedCI', 'Manual')) }}:
      - pwsh: |
          echo "##vso[task.setvariable variable=turboCache;issecret=false;]local:,remote:w"
        displayName: "Set Turborepo Cache local:,remote:w"
  - ${{ else }}:
      - pwsh: |
          echo "##vso[task.setvariable variable=turboCache;issecret=false;]local:rw,remote:r"
        displayName: "Set Turborepo Cache local:rw remote:r"

  - template: /eng/pipelines/templates/steps/set-artifact-packages.yml
    parameters:
      PackageInfo: $(Build.ArtifactStagingDirectory)/PackageInfo
      Artifacts: ${{ parameters.Artifacts }}

  - pwsh: |
      node eng/tools/ci-runner/index.js build "$(ChangedServices)" -packages "$(ArtifactPackageNames)"
    env:
      TURBO_TEAM: azsdkjs
      TURBO_TEAMID: azsdkjs
      TURBO_TOKEN: $(js-turborepo-cache-token)
      TURBO_CACHE: $(turboCache)
    displayName: "Build libraries"

  - script: |
      node eng/tools/ci-runner/index.js build:samples "$(ChangedServices)" -packages "$(ArtifactPackageNames)"
    displayName: "Build samples for PR"

  - pwsh: |
      eng/tools/check-api-warning.ps1
    displayName: "Check api extractor output changes"

  - script: |
      node eng/tools/ci-runner/index.js pack "$(ChangedServices)" -packages "$(ArtifactPackageNames)"
    displayName: "Pack libraries"

  # Unlink node_modules folders to significantly improve performance of subsequent tasks
  # which need to walk the directory tree (and are hardcoded to follow symlinks).
  - script: |
      pnpm purge
    displayName: "Purge dependencies"

  - template: ../steps/generate-doc.yml
    parameters:
      ServiceDirectory: ${{parameters.ServiceDirectory}}

  - pwsh: |
      . ./eng/common/scripts/common.ps1

      $artifacts = "$(ArtifactPackageNames)".Split(",")

      foreach ($artifact in $artifacts)
      {
        $artifactDetails = Get-Content -Raw $(Build.ArtifactStagingDirectory)/PackageInfo/$artifact.json | ConvertFrom-Json
        $packageJson = Join-Path $(Build.SourcesDirectory) $artifactDetails.DirectoryPath "package.json"

        $stagingArtifactDirectory = "$(Build.ArtifactStagingDirectory)/$artifact"
        Write-Host "Copying $artifact artifacts to $stagingArtifactDirectory"
        New-Item -Type Directory $stagingArtifactDirectory -Force | Out-Null

        $packageFile = (dir sdk/$($artifactDetails.ServiceDirectory)/**/$artifact-[0-9]*.[0-9]*.[0-9]*.tgz)[0]
        Copy-Item $packageFile $stagingArtifactDirectory
        Copy-Item sdk/$($artifactDetails.ServiceDirectory)/**/browser/$artifact-[0-9]*.[0-9]*.[0-9]*.zip $stagingArtifactDirectory

        if ($env:SETDEVVERSION -eq 'true' -and $artifactDetails.ArtifactDetails.skipPublishDevFeed -ne $true)
        {
          $stagingDevArtifactDirectory = "$(Agent.TempDirectory)/packages-dev-publish/$artifact"
          New-Item -Type Directory $stagingDevArtifactDirectory -Force | Out-Null
          $hasSourceChanges = HasPackageSourceCodeChanges $packageFile $(Agent.TempDirectory)
          if ($hasSourceChanges) {
            Write-Host "There were source code changes for $artifact, so we need to publish"
            Write-Host "Copying $packageFile artifacts to $stagingDevArtifactDirectory"
            Copy-Item $packageFile $stagingDevArtifactDirectory
          }
          else {
            Write-Host "No source code changes for $artifact, skipping publish"
          }
          Get-ChildItem $stagingDevArtifactDirectory -Recurse -Name
        }

        if ($${{ parameters.IncludeRelease }} -eq $true -and (Get-Content $packageJson -Raw | ConvertFrom-Json).private -ne $true)
        {
          New-Item -Type Directory $stagingArtifactDirectory/documentation -Force | Out-Null
          Copy-Item $(Build.SourcesDirectory)/docGen/$artifact.zip $stagingArtifactDirectory/documentation
        }
        else {
          Write-Host "Skipping documentation for package $artifact."
        }

        Get-ChildItem $stagingArtifactDirectory -Recurse -Name
      }
    displayName: "Copy Packages"

  - pwsh: |
      eng/scripts/stage-api-review-file.ps1 -PackageInfoPath $(Build.ArtifactStagingDirectory)/PackageInfo -StagingDirectory $(Build.ArtifactStagingDirectory)
    displayName: "Copy API extracted files"

  - task: Powershell@2
    inputs:
      filePath: $(Build.SourcesDirectory)/eng/scripts/Generate-APIView-CodeFile.ps1
      arguments: >
        -ArtifactPath $(Build.ArtifactStagingDirectory)
      pwsh: true
      workingDirectory: $(Pipeline.Workspace)
    displayName: Create APIView code file

  - template: /eng/common/pipelines/templates/steps/publish-1es-artifact.yml
    parameters:
      ArtifactPath: "$(Build.ArtifactStagingDirectory)"
      ArtifactName: "packages"

  - template: /eng/common/pipelines/templates/steps/publish-1es-artifact.yml
    parameters:
      ArtifactPath: "$(Agent.TempDirectory)/packages-dev-publish"
      ArtifactName: "packages-dev-publish"
      CustomCondition: eq(variables['SetDevVersion'], 'true')

  - template: /eng/common/pipelines/templates/steps/create-apireview.yml
    parameters:
      Artifacts: ${{ parameters.Artifacts }}

  - template: /eng/common/pipelines/templates/steps/detect-api-changes.yml
    parameters:
      Artifacts: ${{ parameters.Artifacts }}

  - template: /eng/common/pipelines/templates/steps/validate-all-packages.yml
    parameters:
      Artifacts: ${{ parameters.Artifacts }}
