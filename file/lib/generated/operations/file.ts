/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "ms-rest-js";
import * as Models from "../models";
import * as Mappers from "../models/fileMappers";
import * as Parameters from "../models/parameters";
import { StorageClientContext } from "../storageClientContext";

/** Class representing a File. */
export class File {
  private readonly client: StorageClientContext;

  /**
   * Create a File.
   * @param {StorageClientContext} client Reference to the service client.
   */
  constructor(client: StorageClientContext) {
    this.client = client;
  }

  /**
   * Creates a new file or replaces a file. Note it only initializes the file with no content.
   *
   * @param {number} fileContentLength Specifies the maximum size for the file, up to 1 TB.
   *
   * @param {FileCreateOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  create(fileContentLength: number): Promise<Models.FileCreateResponse>;
  create(fileContentLength: number, options: Models.FileCreateOptionalParams): Promise<Models.FileCreateResponse>;
  create(fileContentLength: number, callback: msRest.ServiceCallback<void>): void;
  create(fileContentLength: number, options: Models.FileCreateOptionalParams, callback: msRest.ServiceCallback<void>): void;
  create(fileContentLength: number, options?: Models.FileCreateOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileCreateResponse> {
    return this.client.sendOperationRequest(
      {
        fileContentLength,
        options
      },
      createOperationSpec,
      callback) as Promise<Models.FileCreateResponse>;
  }

  /**
   * Reads or downloads a file from the system, including its metadata and properties.
   *
   * @param {FileDownloadOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  download(): Promise<Models.FileDownloadResponse>;
  download(options: Models.FileDownloadOptionalParams): Promise<Models.FileDownloadResponse>;
  download(callback: msRest.ServiceCallback<void>): void;
  download(options: Models.FileDownloadOptionalParams, callback: msRest.ServiceCallback<void>): void;
  download(options?: Models.FileDownloadOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileDownloadResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      downloadOperationSpec,
      callback) as Promise<Models.FileDownloadResponse>;
  }

  /**
   * Returns all user-defined metadata, standard HTTP properties, and system properties for the file.
   * It does not return the content of the file.
   *
   * @param {FileGetPropertiesOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  getProperties(): Promise<Models.FileGetPropertiesResponse>;
  getProperties(options: Models.FileGetPropertiesOptionalParams): Promise<Models.FileGetPropertiesResponse>;
  getProperties(callback: msRest.ServiceCallback<void>): void;
  getProperties(options: Models.FileGetPropertiesOptionalParams, callback: msRest.ServiceCallback<void>): void;
  getProperties(options?: Models.FileGetPropertiesOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileGetPropertiesResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      getPropertiesOperationSpec,
      callback) as Promise<Models.FileGetPropertiesResponse>;
  }

  /**
   * removes the file from the storage account.
   *
   * @param {FileDeleteMethodOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  deleteMethod(): Promise<Models.FileDeleteResponse>;
  deleteMethod(options: Models.FileDeleteMethodOptionalParams): Promise<Models.FileDeleteResponse>;
  deleteMethod(callback: msRest.ServiceCallback<void>): void;
  deleteMethod(options: Models.FileDeleteMethodOptionalParams, callback: msRest.ServiceCallback<void>): void;
  deleteMethod(options?: Models.FileDeleteMethodOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileDeleteResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      deleteMethodOperationSpec,
      callback) as Promise<Models.FileDeleteResponse>;
  }

  /**
   * Sets HTTP headers on the file.
   *
   * @param {FileSetHTTPHeadersOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  setHTTPHeaders(): Promise<Models.FileSetHTTPHeadersResponse>;
  setHTTPHeaders(options: Models.FileSetHTTPHeadersOptionalParams): Promise<Models.FileSetHTTPHeadersResponse>;
  setHTTPHeaders(callback: msRest.ServiceCallback<void>): void;
  setHTTPHeaders(options: Models.FileSetHTTPHeadersOptionalParams, callback: msRest.ServiceCallback<void>): void;
  setHTTPHeaders(options?: Models.FileSetHTTPHeadersOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileSetHTTPHeadersResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      setHTTPHeadersOperationSpec,
      callback) as Promise<Models.FileSetHTTPHeadersResponse>;
  }

  /**
   * Updates user-defined metadata for the specified file.
   *
   * @param {FileSetMetadataOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  setMetadata(): Promise<Models.FileSetMetadataResponse>;
  setMetadata(options: Models.FileSetMetadataOptionalParams): Promise<Models.FileSetMetadataResponse>;
  setMetadata(callback: msRest.ServiceCallback<void>): void;
  setMetadata(options: Models.FileSetMetadataOptionalParams, callback: msRest.ServiceCallback<void>): void;
  setMetadata(options?: Models.FileSetMetadataOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileSetMetadataResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      setMetadataOperationSpec,
      callback) as Promise<Models.FileSetMetadataResponse>;
  }

  /**
   * Upload a range of bytes to a file.
   *
   * @param {string} range Specifies the range of bytes to be written. Both the start and end of the
   * range must be specified. For an update operation, the range can be up to 4 MB in size. For a
   * clear operation, the range can be up to the value of the file's full size. The File service
   * accepts only a single byte range for the Range and 'x-ms-range' headers, and the byte range must
   * be specified in the following format: bytes=startByte-endByte.
   *
   * @param {FileRangeWriteType} fileRangeWrite Specify one of the following options: - Update:
   * Writes the bytes specified by the request body into the specified range. The Range and
   * Content-Length headers must match to perform the update. - Clear: Clears the specified range and
   * releases the space used in storage for that range. To clear a range, set the Content-Length
   * header to zero, and set the Range header to a value that indicates the range to clear, up to
   * maximum file size. Possible values include: 'update', 'clear'
   *
   * @param {number} contentLength Specifies the number of bytes being transmitted in the request
   * body. When the x-ms-write header is set to clear, the value of this header must be set to zero.
   *
   * @param {FileUploadRangeOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  uploadRange(range: string, fileRangeWrite: Models.FileRangeWriteType, contentLength: number): Promise<Models.FileUploadRangeResponse>;
  uploadRange(range: string, fileRangeWrite: Models.FileRangeWriteType, contentLength: number, options: Models.FileUploadRangeOptionalParams): Promise<Models.FileUploadRangeResponse>;
  uploadRange(range: string, fileRangeWrite: Models.FileRangeWriteType, contentLength: number, callback: msRest.ServiceCallback<void>): void;
  uploadRange(range: string, fileRangeWrite: Models.FileRangeWriteType, contentLength: number, options: Models.FileUploadRangeOptionalParams, callback: msRest.ServiceCallback<void>): void;
  uploadRange(range: string, fileRangeWrite: Models.FileRangeWriteType, contentLength: number, options?: Models.FileUploadRangeOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileUploadRangeResponse> {
    return this.client.sendOperationRequest(
      {
        range,
        fileRangeWrite,
        contentLength,
        options
      },
      uploadRangeOperationSpec,
      callback) as Promise<Models.FileUploadRangeResponse>;
  }

  /**
   * Returns the list of valid ranges for a file.
   *
   * @param {FileGetRangeListOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  getRangeList(): Promise<Models.FileGetRangeListResponse>;
  getRangeList(options: Models.FileGetRangeListOptionalParams): Promise<Models.FileGetRangeListResponse>;
  getRangeList(callback: msRest.ServiceCallback<Models.Range[]>): void;
  getRangeList(options: Models.FileGetRangeListOptionalParams, callback: msRest.ServiceCallback<Models.Range[]>): void;
  getRangeList(options?: Models.FileGetRangeListOptionalParams, callback?: msRest.ServiceCallback<Models.Range[]>): Promise<Models.FileGetRangeListResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      getRangeListOperationSpec,
      callback) as Promise<Models.FileGetRangeListResponse>;
  }

  /**
   * Copies a blob or file to a destination file within the storage account.
   *
   * @param {string} copySource Specifies the URL of the source file or blob, up to 2 KB in length.
   * To copy a file to another file within the same storage account, you may use Shared Key to
   * authenticate the source file. If you are copying a file from another storage account, or if you
   * are copying a blob from the same storage account or another storage account, then you must
   * authenticate the source file or blob using a shared access signature. If the source is a public
   * blob, no authentication is required to perform the copy operation. A file in a share snapshot
   * can also be specified as a copy source.
   *
   * @param {FileStartCopyOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  startCopy(copySource: string): Promise<Models.FileStartCopyResponse>;
  startCopy(copySource: string, options: Models.FileStartCopyOptionalParams): Promise<Models.FileStartCopyResponse>;
  startCopy(copySource: string, callback: msRest.ServiceCallback<void>): void;
  startCopy(copySource: string, options: Models.FileStartCopyOptionalParams, callback: msRest.ServiceCallback<void>): void;
  startCopy(copySource: string, options?: Models.FileStartCopyOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileStartCopyResponse> {
    return this.client.sendOperationRequest(
      {
        copySource,
        options
      },
      startCopyOperationSpec,
      callback) as Promise<Models.FileStartCopyResponse>;
  }

  /**
   * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
   * metadata.
   *
   * @param {string} copyId The copy identifier provided in the x-ms-copy-id header of the original
   * Copy File operation.
   *
   * @param {FileAbortCopyOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  abortCopy(copyId: string): Promise<Models.FileAbortCopyResponse>;
  abortCopy(copyId: string, options: Models.FileAbortCopyOptionalParams): Promise<Models.FileAbortCopyResponse>;
  abortCopy(copyId: string, callback: msRest.ServiceCallback<void>): void;
  abortCopy(copyId: string, options: Models.FileAbortCopyOptionalParams, callback: msRest.ServiceCallback<void>): void;
  abortCopy(copyId: string, options?: Models.FileAbortCopyOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.FileAbortCopyResponse> {
    return this.client.sendOperationRequest(
      {
        copyId,
        options
      },
      abortCopyOperationSpec,
      callback) as Promise<Models.FileAbortCopyResponse>;
  }

}

// Operation Specifications
const serializer = new msRest.Serializer(Mappers, true);
const createOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.version,
    Parameters.fileContentLength0,
    Parameters.fileTypeConstant,
    Parameters.fileContentType,
    Parameters.fileContentEncoding,
    Parameters.fileContentLanguage,
    Parameters.fileCacheControl,
    Parameters.fileContentMD5,
    Parameters.fileContentDisposition,
    Parameters.metadata
  ],
  responses: {
    201: {
      headersMapper: Mappers.FileCreateHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const downloadOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.version,
    Parameters.range0,
    Parameters.rangeGetContentMD5
  ],
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: Mappers.FileDownloadHeaders
    },
    206: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: Mappers.FileDownloadHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const getPropertiesOperationSpec: msRest.OperationSpec = {
  httpMethod: "HEAD",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.sharesnapshot,
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.version
  ],
  responses: {
    200: {
      headersMapper: Mappers.FileGetPropertiesHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const deleteMethodOperationSpec: msRest.OperationSpec = {
  httpMethod: "DELETE",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.version
  ],
  responses: {
    202: {
      headersMapper: Mappers.FileDeleteHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const setHTTPHeadersOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp0
  ],
  headerParameters: [
    Parameters.version,
    Parameters.fileContentLength1,
    Parameters.fileContentType,
    Parameters.fileContentEncoding,
    Parameters.fileContentLanguage,
    Parameters.fileCacheControl,
    Parameters.fileContentMD5,
    Parameters.fileContentDisposition
  ],
  responses: {
    200: {
      headersMapper: Mappers.FileSetHTTPHeadersHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const setMetadataOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp3
  ],
  headerParameters: [
    Parameters.metadata,
    Parameters.version
  ],
  responses: {
    200: {
      headersMapper: Mappers.FileSetMetadataHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const uploadRangeOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp6
  ],
  headerParameters: [
    Parameters.range1,
    Parameters.fileRangeWrite,
    Parameters.contentLength,
    Parameters.contentMD5,
    Parameters.version
  ],
  requestBody: {
    parameterPath: [
      "options",
      "optionalbody"
    ],
    mapper: {
      serializedName: "optionalbody",
      type: {
        name: "Stream"
      }
    }
  },
  contentType: "application/octet-stream",
  responses: {
    201: {
      headersMapper: Mappers.FileUploadRangeHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const getRangeListOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.sharesnapshot,
    Parameters.timeout,
    Parameters.comp7
  ],
  headerParameters: [
    Parameters.version,
    Parameters.range0
  ],
  responses: {
    200: {
      bodyMapper: {
        xmlElementName: "Range",
        serializedName: "parsedResponse",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Range"
            }
          }
        }
      },
      headersMapper: Mappers.FileGetRangeListHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const startCopyOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.version,
    Parameters.metadata,
    Parameters.copySource
  ],
  responses: {
    202: {
      headersMapper: Mappers.FileStartCopyHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const abortCopyOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{shareName}/{directory}/{fileName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.copyId,
    Parameters.timeout,
    Parameters.comp8
  ],
  headerParameters: [
    Parameters.copyActionAbortConstant,
    Parameters.version
  ],
  responses: {
    204: {
      headersMapper: Mappers.FileAbortCopyHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};
