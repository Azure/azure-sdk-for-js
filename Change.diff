diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist/index.js" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist/index.js"
index 1c05d53e9..38b11dbab 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist/index.js"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist/index.js"
@@ -4,11 +4,11 @@ Object.defineProperty(exports, '__esModule', { value: true });
 
 function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
 
+var tslib = require('tslib');
 var jwtDecode = _interopDefault(require('jwt-decode'));
 var coreHttp = require('@azure/core-http');
 var crypto = require('crypto');
 var coreAuth = require('@azure/core-auth');
-var tslib = require('tslib');
 
 // Copyright (c) Microsoft Corporation.
 const parseToken = (token) => {
@@ -20,7 +20,6 @@ const parseToken = (token) => {
 };
 
 // Copyright (c) Microsoft Corporation.
-// Licensed under the MIT license.
 /**
  * StaticTokenCredential
  */
@@ -28,8 +27,10 @@ class StaticTokenCredential {
     constructor(token) {
         this.token = token;
     }
-    async getToken() {
-        return this.token;
+    getToken() {
+        return tslib.__awaiter(this, void 0, void 0, function* () {
+            return this.token;
+        });
     }
     dispose() {
         /* intentionally empty */
@@ -54,15 +55,17 @@ class AutoRefreshTokenCredential {
             this.scheduleRefresh();
         }
     }
-    async getToken(options) {
-        if (!this.isCurrentTokenExpiringSoon) {
+    getToken(options) {
+        return tslib.__awaiter(this, void 0, void 0, function* () {
+            if (!this.isCurrentTokenExpiringSoon) {
+                return this.currentToken;
+            }
+            const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
+            if (!this.isCurrentTokenValid) {
+                yield updatePromise;
+            }
             return this.currentToken;
-        }
-        const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
-        if (!this.isCurrentTokenValid) {
-            await updatePromise;
-        }
-        return this.currentToken;
+        });
     }
     dispose() {
         this.disposed = true;
@@ -73,34 +76,40 @@ class AutoRefreshTokenCredential {
             clearTimeout(this.activeTimeout);
         }
     }
-    async updateTokenAndReschedule(abortSignal) {
-        if (this.activeTokenUpdating) {
-            return this.activeTokenUpdating;
-        }
-        this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
-        try {
-            await this.activeTokenUpdating;
-        }
-        finally {
-            this.activeTokenUpdating = null;
-        }
+    updateTokenAndReschedule(abortSignal) {
+        return tslib.__awaiter(this, void 0, void 0, function* () {
+            if (this.activeTokenUpdating) {
+                return this.activeTokenUpdating;
+            }
+            this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
+            try {
+                yield this.activeTokenUpdating;
+            }
+            finally {
+                this.activeTokenUpdating = null;
+            }
+        });
     }
-    async refreshTokenAndReschedule(abortSignal) {
-        this.currentToken = await this.refreshToken(abortSignal);
-        if (this.refreshProactively) {
-            this.scheduleRefresh();
-        }
+    refreshTokenAndReschedule(abortSignal) {
+        return tslib.__awaiter(this, void 0, void 0, function* () {
+            this.currentToken = yield this.refreshToken(abortSignal);
+            if (this.refreshProactively) {
+                this.scheduleRefresh();
+            }
+        });
     }
-    async refreshToken(abortSignal) {
-        try {
-            if (!this.activeTokenFetching) {
-                this.activeTokenFetching = this.refresh(abortSignal);
+    refreshToken(abortSignal) {
+        return tslib.__awaiter(this, void 0, void 0, function* () {
+            try {
+                if (!this.activeTokenFetching) {
+                    this.activeTokenFetching = this.refresh(abortSignal);
+                }
+                return parseToken(yield this.activeTokenFetching);
             }
-            return parseToken(await this.activeTokenFetching);
-        }
-        finally {
-            this.activeTokenFetching = null;
-        }
+            finally {
+                this.activeTokenFetching = null;
+            }
+        });
     }
     scheduleRefresh() {
         if (this.disposed) {
@@ -139,11 +148,13 @@ class AzureCommunicationTokenCredential {
      * Gets an `AccessToken` for the user. Throws if already disposed.
      * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
      */
-    async getToken(options) {
-        this.throwIfDisposed();
-        const token = await this.tokenCredential.getToken(options);
-        this.throwIfDisposed();
-        return token;
+    getToken(options) {
+        return tslib.__awaiter(this, void 0, void 0, function* () {
+            this.throwIfDisposed();
+            const token = yield this.tokenCredential.getToken(options);
+            this.throwIfDisposed();
+            return token;
+        });
     }
     /**
      * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
@@ -160,15 +171,17 @@ class AzureCommunicationTokenCredential {
 }
 
 // Copyright (c) Microsoft Corporation.
-const shaHash = async (content) => crypto.createHash("sha256")
-    .update(content)
-    .digest("base64");
-const shaHMAC = async (secret, content) => {
+const shaHash = (content) => tslib.__awaiter(void 0, void 0, void 0, function* () {
+    return crypto.createHash("sha256")
+        .update(content)
+        .digest("base64");
+});
+const shaHMAC = (secret, content) => tslib.__awaiter(void 0, void 0, void 0, function* () {
     const decodedSecret = Buffer.from(secret, "base64");
     return crypto.createHmac("sha256", decodedSecret)
         .update(content)
         .digest("base64");
-};
+});
 
 // Copyright (c) Microsoft Corporation.
 /**
@@ -203,35 +216,39 @@ class CommunicationAccessKeyCredentialPolicy extends coreHttp.BaseRequestPolicy
      *
      * @param webResource - The WebResource to be signed.
      */
-    async signRequest(webResource) {
-        const verb = webResource.method.toUpperCase();
-        const utcNow = new Date().toUTCString();
-        const contentHash = await shaHash(webResource.body || "");
-        const dateHeader = "x-ms-date";
-        const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
-        const url = coreHttp.URLBuilder.parse(webResource.url);
-        const query = url.getQuery();
-        const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
-        const port = url.getPort();
-        const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
-        const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
-        const signature = await shaHMAC(this.accessKey.key, stringToSign);
-        {
-            webResource.headers.set("Host", hostAndPort || "");
-        }
-        webResource.headers.set(dateHeader, utcNow);
-        webResource.headers.set("x-ms-content-sha256", contentHash);
-        webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
-        return webResource;
+    signRequest(webResource) {
+        return tslib.__awaiter(this, void 0, void 0, function* () {
+            const verb = webResource.method.toUpperCase();
+            const utcNow = new Date().toUTCString();
+            const contentHash = yield shaHash(webResource.body || "");
+            const dateHeader = "x-ms-date";
+            const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
+            const url = coreHttp.URLBuilder.parse(webResource.url);
+            const query = url.getQuery();
+            const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
+            const port = url.getPort();
+            const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
+            const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
+            const signature = yield shaHMAC(this.accessKey.key, stringToSign);
+            {
+                webResource.headers.set("Host", hostAndPort || "");
+            }
+            webResource.headers.set(dateHeader, utcNow);
+            webResource.headers.set("x-ms-content-sha256", contentHash);
+            webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
+            return webResource;
+        });
     }
     /**
      * Signs the request and calls the next policy in the factory.
      */
-    async sendRequest(webResource) {
-        if (!webResource) {
-            throw new Error("webResource cannot be null or undefined");
-        }
-        return this._nextPolicy.sendRequest(await this.signRequest(webResource));
+    sendRequest(webResource) {
+        return tslib.__awaiter(this, void 0, void 0, function* () {
+            if (!webResource) {
+                throw new Error("webResource cannot be null or undefined");
+            }
+            return this._nextPolicy.sendRequest(yield this.signRequest(webResource));
+        });
     }
 }
 
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist/index.js.map" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist/index.js.map"
index dedf55849..afd311081 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist/index.js.map"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist/index.js.map"
@@ -1 +1 @@
-{"version":3,"file":"index.js","sources":["../src/tokenParser.ts","../src/staticTokenCredential.ts","../src/autoRefreshTokenCredential.ts","../src/communicationTokenCredential.ts","../src/credential/cryptoUtils.ts","../src/credential/communicationAccessKeyCredentialPolicy.ts","../src/credential/communicationAuthPolicy.ts","../src/credential/connectionString.ts","../src/credential/clientArguments.ts","../src/identifierModels.ts","../src/identifierModelSerializer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport jwtDecode from \"jwt-decode\";\nimport { AccessToken } from \"@azure/core-http\";\n\ninterface JwtToken {\n  exp: number;\n}\n\nexport const parseToken = (token: string): AccessToken => {\n  const { exp } = jwtDecode<JwtToken>(token);\n  return {\n    token,\n    expiresOnTimestamp: exp * 1000\n  };\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-http\";\nimport { TokenCredential } from \"./communicationTokenCredential\";\n\n/**\n * StaticTokenCredential\n */\nexport class StaticTokenCredential implements TokenCredential {\n  constructor(private readonly token: AccessToken) {}\n\n  public async getToken(): Promise<AccessToken> {\n    return this.token;\n  }\n\n  public dispose(): void {\n    /* intentionally empty */\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { TokenCredential, CommunicationGetTokenOptions } from \"./communicationTokenCredential\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Function that returns a token acquired from the Communication configuration SDK.\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultRefreshingInterval = minutesToMs(10);\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly refreshingIntervalInMs: number = defaultRefreshingInterval;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isCurrentTokenExpiringSoon) {\n      return this.currentToken;\n    }\n\n    const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n\n    if (!this.isCurrentTokenValid) {\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    this.currentToken = await this.refreshToken(abortSignal);\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const timespanInMs =\n      this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private get isCurrentTokenValid(): boolean {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  private get isCurrentTokenExpiringSoon(): boolean {\n    return (\n      !this.currentToken ||\n      Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { StaticTokenCredential } from \"./staticTokenCredential\";\nimport {\n  AutoRefreshTokenCredential,\n  CommunicationTokenRefreshOptions\n} from \"./autoRefreshTokenCredential\";\n\nexport type TokenCredential = Pick<AzureCommunicationTokenCredential, \"getToken\" | \"dispose\">;\n\n/**\n * Options for `CommunicationTokenCredential`'s `getToken` function.\n */\nexport interface CommunicationGetTokenOptions {\n  /**\n   * An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The Azure Communication Services token credential.\n */\nexport interface CommunicationTokenCredential {\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param options - Additional options.\n   */\n  getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken>;\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  dispose(): void;\n}\n\n/**\n * The CommunicationTokenCredential implementation with support for proactive token refresh.\n */\nexport class AzureCommunicationTokenCredential implements CommunicationTokenCredential {\n  private readonly tokenCredential: TokenCredential;\n  private disposed = false;\n\n  /**\n   * Creates an instance of CommunicationTokenCredential with a static token and no proactive refreshing.\n   * @param token - A user access token issued by Communication Services.\n   */\n  constructor(token: string);\n  /**\n   * Creates an instance of CommunicationTokenCredential with a lambda to get a token and options\n   * to configure proactive refreshing.\n   * @param refreshOptions - Options to configure refresh and opt-in to proactive refreshing.\n   */\n  constructor(refreshOptions: CommunicationTokenRefreshOptions);\n  constructor(tokenOrRefreshOptions: string | CommunicationTokenRefreshOptions) {\n    if (typeof tokenOrRefreshOptions === \"string\") {\n      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));\n    } else {\n      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);\n    }\n  }\n\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    this.throwIfDisposed();\n    const token = await this.tokenCredential.getToken(options);\n    this.throwIfDisposed();\n    return token;\n  }\n\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  public dispose(): void {\n    this.disposed = true;\n    this.tokenCredential.dispose();\n  }\n\n  private throwIfDisposed(): void {\n    if (this.disposed) {\n      throw new Error(\"User credential is disposed\");\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createHash, createHmac } from \"crypto\";\n\nexport const shaHash = async (content: string): Promise<string> =>\n  createHash(\"sha256\")\n    .update(content)\n    .digest(\"base64\");\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const decodedSecret = Buffer.from(secret, \"base64\");\n\n  return createHmac(\"sha256\", decodedSecret)\n    .update(content)\n    .digest(\"base64\");\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  URLBuilder,\n  WebResource,\n  isNode,\n  RequestPolicy,\n  RequestPolicyOptionsLike,\n  RequestPolicyFactory,\n  WebResourceLike,\n  HttpOperationResponse,\n  BaseRequestPolicy\n} from \"@azure/core-http\";\nimport { shaHash, shaHMAC } from \"./cryptoUtils\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\nexport const createCommunicationAccessKeyCredentialPolicy = (\n  credential: KeyCredential\n): RequestPolicyFactory => {\n  return {\n    create: (nextpolicy: RequestPolicy, options: RequestPolicyOptionsLike) => {\n      return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);\n    }\n  };\n};\n\n/**\n * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nclass CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {\n  /**\n   * Initializes a new instance of the CommunicationAccessKeyCredential class\n   * using a base64 encoded key.\n   * @param accessKey - The base64 encoded key to be used for signing.\n   */\n  constructor(\n    private readonly accessKey: KeyCredential,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptionsLike\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Signs a request with the provided access key.\n   *\n   * @param webResource - The WebResource to be signed.\n   */\n  private async signRequest(webResource: WebResource): Promise<WebResource> {\n    const verb = webResource.method.toUpperCase();\n    const utcNow = new Date().toUTCString();\n    const contentHash = await shaHash(webResource.body || \"\");\n    const dateHeader = \"x-ms-date\";\n    const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n    const url = URLBuilder.parse(webResource.url);\n    const query = url.getQuery();\n    const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();\n    const port = url.getPort();\n    const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();\n\n    const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n    const signature = await shaHMAC(this.accessKey.key, stringToSign);\n\n    if (isNode) {\n      webResource.headers.set(\"Host\", hostAndPort || \"\");\n    }\n\n    webResource.headers.set(dateHeader, utcNow);\n    webResource.headers.set(\"x-ms-content-sha256\", contentHash);\n    webResource.headers.set(\n      \"Authorization\",\n      `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`\n    );\n\n    return webResource;\n  }\n\n  /**\n   * Signs the request and calls the next policy in the factory.\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource) {\n      throw new Error(\"webResource cannot be null or undefined\");\n    }\n\n    return this._nextPolicy.sendRequest(await this.signRequest(webResource));\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, KeyCredential, TokenCredential } from \"@azure/core-auth\";\nimport { bearerTokenAuthenticationPolicy, RequestPolicyFactory } from \"@azure/core-http\";\nimport { createCommunicationAccessKeyCredentialPolicy } from \"./communicationAccessKeyCredentialPolicy\";\n/**\n * Creates a pipeline policy to authenticate request based\n * on the credential passed in.\n * @hidden\n *\n * @param credential - The KeyCredential or TokenCredential.\n */\nexport const createCommunicationAuthPolicy = (\n  credential: KeyCredential | TokenCredential\n): RequestPolicyFactory => {\n  if (isTokenCredential(credential)) {\n    return bearerTokenAuthenticationPolicy(credential, \"https://communication.azure.com//.default\");\n  } else {\n    return createCommunicationAccessKeyCredentialPolicy(credential);\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AzureKeyCredential, KeyCredential } from \"@azure/core-auth\";\n/**\n * Represents different properties of connection string\n * using format \"/endpoint=(.*);accesskey=(.*)\".\n * @hidden\n */\nexport interface EndpointCredential {\n  /**\n   * The endpoint as string\n   */\n  endpoint: string;\n  /**\n   * The access key represented as a KeyCredential object\n   */\n  credential: KeyCredential;\n}\n\n// TODO: update when connection string format is finalized\nconst CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;\n\nconst tryParseConnectionString = (s: string): EndpointCredential | undefined => {\n  const match = s.match(CONNECTION_STRING_REGEX);\n  if (match?.[1] && match[2]) {\n    return { endpoint: match[1], credential: new AzureKeyCredential(match[2]) };\n  }\n  return undefined;\n};\n/**\n * Returns an EndpointCredential to easily access properties of the connection string.\n * @hidden\n *\n * @param connectionString - The connection string to parse\n * @returns Object to access the endpoint and the credenials\n */\nexport const parseConnectionString = (connectionString: string): EndpointCredential => {\n  const parsedConnectionString = tryParseConnectionString(connectionString);\n  if (parsedConnectionString) {\n    return parsedConnectionString;\n  } else {\n    throw new Error(`Invalid connection string ${connectionString}`);\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, KeyCredential, TokenCredential } from \"@azure/core-auth\";\nimport { URLBuilder } from \"@azure/core-http\";\nimport { parseConnectionString } from \"./connectionString\";\n\nconst isValidEndpoint = (host: string): boolean => {\n  const url = URLBuilder.parse(host);\n\n  return (\n    !!url.getScheme()?.match(/^http[s]?/) &&\n    url.getHost() !== undefined &&\n    url.getHost() !== \"\" &&\n    (url.getPath() === undefined || url.getPath() === \"\" || url.getPath() === \"/\")\n  );\n};\n\nconst assertValidEndpoint = (host: string): void => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\nexport const isKeyCredential = (credential: unknown): credential is KeyCredential => {\n  const castCredential = credential as {\n    key: unknown;\n    getToken: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.key === \"string\" &&\n    castCredential.getToken === undefined\n  );\n};\n\n/**\n * The URL and credential from parsing the arguments of a communication client.\n * @hidden\n */\nexport type UrlWithCredential = {\n  url: string;\n  credential: TokenCredential | KeyCredential;\n};\n\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\nexport const parseClientArguments = (\n  connectionStringOrUrl: string,\n  credentialOrOptions?: unknown\n): UrlWithCredential => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return { url: connectionStringOrUrl, credential: credentialOrOptions };\n  } else {\n    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return { url: host, credential };\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier =\n  | CommunicationUserIdentifier\n  | PhoneNumberIdentifier\n  | MicrosoftTeamsUserIdentifier\n  | UnknownIdentifier;\n\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n  /**\n   * Id of the CommunicationUser as returned from the Communication Service.\n   */\n  communicationUserId: string;\n}\n\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n  /**\n   * Optional raw id of the phone number.\n   */\n  rawId?: string;\n  /**\n   * The phone number in E.164 format.\n   */\n  phoneNumber: string;\n}\n\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams user.\n   */\n  rawId?: string;\n\n  /**\n   * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n   */\n  microsoftTeamsUserId: string;\n\n  /**\n   * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n   */\n  isAnonymous?: boolean;\n\n  /**\n   * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?: \"public\" | \"dod\" | \"gcch\";\n}\n\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n  /**\n   * Id of the UnknownIdentifier.\n   */\n  id: string;\n}\n\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is CommunicationUserIdentifier => {\n  return typeof (identifier as any).communicationUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is PhoneNumberIdentifier => {\n  return typeof (identifier as any).phoneNumber === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is MicrosoftTeamsUserIdentifier => {\n  return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is UnknownIdentifier => {\n  return typeof (identifier as any).id === \"string\";\n};\n\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind =\n  | CommunicationUserKind\n  | PhoneNumberKind\n  | MicrosoftTeamsUserKind\n  | UnknownIdentifierKind;\n\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"communicationUser\";\n}\n\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"phoneNumber\";\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"microsoftTeamsUser\";\n}\n\n/**\n * IdentifierKind for UnkownIdentifer.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"unknown\";\n}\n\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (\n  identifier: CommunicationIdentifier\n): CommunicationIdentifierKind => {\n  if (isCommunicationUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"communicationUser\" };\n  }\n  if (isPhoneNumberIdentifier(identifier)) {\n    return { ...identifier, kind: \"phoneNumber\" };\n  }\n  if (isMicrosoftTeamsUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsUser\" };\n  }\n  return { ...identifier, kind: \"unknown\" };\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CommunicationIdentifier,\n  CommunicationIdentifierKind,\n  getIdentifierKind\n} from \"./identifierModels\";\n\n/**\n * @hidden\n * Identifies a participant in Azure Communication services. A participant is, for example, a phone number or an Azure communication user. This model must be interpreted as a union: Apart from rawId, at most one further property may be set.\n */\nexport interface SerializedCommunicationIdentifier {\n  /**\n   * Raw Id of the identifier. Optional in requests, required in responses.\n   */\n  rawId?: string;\n  /**\n   * The communication user.\n   */\n  communicationUser?: SerializedCommunicationUserIdentifier;\n  /**\n   * The phone number.\n   */\n  phoneNumber?: SerializedPhoneNumberIdentifier;\n  /**\n   * The Microsoft Teams user.\n   */\n  microsoftTeamsUser?: SerializedMicrosoftTeamsUserIdentifier;\n}\n\n/**\n * @hidden\n * A user that got created with an Azure Communication Services resource.\n */\nexport interface SerializedCommunicationUserIdentifier {\n  /**\n   * The Id of the communication user.\n   */\n  id: string;\n}\n\n/**\n * @hidden\n * A phone number.\n */\nexport interface SerializedPhoneNumberIdentifier {\n  /**\n   * The phone number in E.164 format.\n   */\n  value: string;\n}\n\n/**\n * @hidden\n * A Microsoft Teams user.\n */\nexport interface SerializedMicrosoftTeamsUserIdentifier {\n  /**\n   * The Id of the Microsoft Teams user. If not anonymous, this is the AAD object Id of the user.\n   */\n  userId: string;\n  /**\n   * True if the Microsoft Teams user is anonymous. By default false if missing.\n   */\n  isAnonymous?: boolean;\n  /**\n   * The cloud that the Microsoft Teams user belongs to. By default 'public' if missing.\n   */\n  cloud?: SerializedCommunicationCloudEnvironment;\n}\n\n/**\n * @hidden\n * Defines values for CommunicationCloudEnvironmentModel.\n */\nexport type SerializedCommunicationCloudEnvironment = \"public\" | \"dod\" | \"gcch\";\n\nconst addRawIdIfExisting = <T>(\n  identifier: T,\n  rawId: string | undefined\n): T & { rawId?: string } => {\n  return rawId === undefined ? identifier : { ...identifier, rawId: rawId };\n};\n\nconst assertNotNullOrUndefined = <\n  T extends Record<string, unknown>,\n  P extends keyof T,\n  Q extends keyof T[P]\n>(\n  obj: T,\n  prop: Q\n): Required<Required<T>[P]>[Q] => {\n  const subObjName = Object.keys(obj)[0];\n  const subObj = (obj as any)[subObjName];\n  if (prop in subObj) {\n    return subObj[prop];\n  }\n  throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);\n};\n\nconst assertMaximumOneNestedModel = (identifier: SerializedCommunicationIdentifier): void => {\n  const { rawId: _rawId, ...props } = identifier;\n  const keys = Object.keys(props);\n  if (keys.length > 1) {\n    throw new Error(`Only one of the properties in ${JSON.stringify(keys)} should be present.`);\n  }\n};\n\n/**\n * @hidden\n * Translates a CommunicationIdentifier to its serialized format for sending a request.\n * @param identifier - The CommunicationIdentifier to be serialized.\n */\nexport const serializeCommunicationIdentifier = (\n  identifier: CommunicationIdentifier\n): SerializedCommunicationIdentifier => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return { communicationUser: { id: identifierKind.communicationUserId } };\n    case \"phoneNumber\":\n      return addRawIdIfExisting(\n        { phoneNumber: { value: identifierKind.phoneNumber } },\n        identifierKind.rawId\n      );\n    case \"microsoftTeamsUser\":\n      return addRawIdIfExisting(\n        {\n          microsoftTeamsUser: {\n            userId: identifierKind.microsoftTeamsUserId,\n            isAnonymous: identifierKind.isAnonymous ?? false,\n            cloud: identifierKind.cloud ?? \"public\"\n          }\n        },\n        identifierKind.rawId\n      );\n    case \"unknown\":\n      return { rawId: identifierKind.id };\n    default:\n      throw new Error(`Can't serialize an identifier with kind ${(identifierKind as any).kind}`);\n  }\n};\n\n/**\n * @hidden\n * Translates the serialized format of a communication identifier to CommunicationIdentifier.\n * @param serializedIdentifier - The SerializedCommunicationIdentifier to be deserialized.\n */\nexport const deserializeCommunicationIdentifier = (\n  serializedIdentifier: SerializedCommunicationIdentifier\n): CommunicationIdentifierKind => {\n  assertMaximumOneNestedModel(serializedIdentifier);\n\n  const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;\n  if (communicationUser) {\n    return {\n      kind: \"communicationUser\",\n      communicationUserId: assertNotNullOrUndefined({ communicationUser }, \"id\")\n    };\n  }\n  if (phoneNumber) {\n    return {\n      kind: \"phoneNumber\",\n      phoneNumber: assertNotNullOrUndefined({ phoneNumber }, \"value\"),\n      rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, \"rawId\")\n    };\n  }\n  if (microsoftTeamsUser) {\n    return {\n      kind: \"microsoftTeamsUser\",\n      microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, \"userId\"),\n      isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, \"isAnonymous\"),\n      cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, \"cloud\"),\n      rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, \"rawId\")\n    };\n  }\n  return {\n    kind: \"unknown\",\n    id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, \"rawId\")\n  };\n};\n"],"names":["createHash","createHmac","BaseRequestPolicy","URLBuilder","isTokenCredential","bearerTokenAuthenticationPolicy","AzureKeyCredential"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.js","sources":["../src/tokenParser.ts","../src/staticTokenCredential.ts","../src/autoRefreshTokenCredential.ts","../src/communicationTokenCredential.ts","../src/credential/cryptoUtils.ts","../src/credential/communicationAccessKeyCredentialPolicy.ts","../src/credential/communicationAuthPolicy.ts","../src/credential/connectionString.ts","../src/credential/clientArguments.ts","../src/identifierModels.ts","../src/identifierModelSerializer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport jwtDecode from \"jwt-decode\";\nimport { AccessToken } from \"@azure/core-http\";\n\ninterface JwtToken {\n  exp: number;\n}\n\nexport const parseToken = (token: string): AccessToken => {\n  const { exp } = jwtDecode<JwtToken>(token);\n  return {\n    token,\n    expiresOnTimestamp: exp * 1000\n  };\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-http\";\nimport { TokenCredential } from \"./communicationTokenCredential\";\n\n/**\n * StaticTokenCredential\n */\nexport class StaticTokenCredential implements TokenCredential {\n  constructor(private readonly token: AccessToken) {}\n\n  public async getToken(): Promise<AccessToken> {\n    return this.token;\n  }\n\n  public dispose(): void {\n    /* intentionally empty */\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { TokenCredential, CommunicationGetTokenOptions } from \"./communicationTokenCredential\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Function that returns a token acquired from the Communication configuration SDK.\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultRefreshingInterval = minutesToMs(10);\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly refreshingIntervalInMs: number = defaultRefreshingInterval;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isCurrentTokenExpiringSoon) {\n      return this.currentToken;\n    }\n\n    const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n\n    if (!this.isCurrentTokenValid) {\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    this.currentToken = await this.refreshToken(abortSignal);\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const timespanInMs =\n      this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private get isCurrentTokenValid(): boolean {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  private get isCurrentTokenExpiringSoon(): boolean {\n    return (\n      !this.currentToken ||\n      Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs\n    );\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { StaticTokenCredential } from \"./staticTokenCredential\";\nimport {\n  AutoRefreshTokenCredential,\n  CommunicationTokenRefreshOptions\n} from \"./autoRefreshTokenCredential\";\n\nexport type TokenCredential = Pick<AzureCommunicationTokenCredential, \"getToken\" | \"dispose\">;\n\n/**\n * Options for `CommunicationTokenCredential`'s `getToken` function.\n */\nexport interface CommunicationGetTokenOptions {\n  /**\n   * An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The Azure Communication Services token credential.\n */\nexport interface CommunicationTokenCredential {\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param options - Additional options.\n   */\n  getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken>;\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  dispose(): void;\n}\n\n/**\n * The CommunicationTokenCredential implementation with support for proactive token refresh.\n */\nexport class AzureCommunicationTokenCredential implements CommunicationTokenCredential {\n  private readonly tokenCredential: TokenCredential;\n  private disposed = false;\n\n  /**\n   * Creates an instance of CommunicationTokenCredential with a static token and no proactive refreshing.\n   * @param token - A user access token issued by Communication Services.\n   */\n  constructor(token: string);\n  /**\n   * Creates an instance of CommunicationTokenCredential with a lambda to get a token and options\n   * to configure proactive refreshing.\n   * @param refreshOptions - Options to configure refresh and opt-in to proactive refreshing.\n   */\n  constructor(refreshOptions: CommunicationTokenRefreshOptions);\n  constructor(tokenOrRefreshOptions: string | CommunicationTokenRefreshOptions) {\n    if (typeof tokenOrRefreshOptions === \"string\") {\n      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));\n    } else {\n      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);\n    }\n  }\n\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    this.throwIfDisposed();\n    const token = await this.tokenCredential.getToken(options);\n    this.throwIfDisposed();\n    return token;\n  }\n\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  public dispose(): void {\n    this.disposed = true;\n    this.tokenCredential.dispose();\n  }\n\n  private throwIfDisposed(): void {\n    if (this.disposed) {\n      throw new Error(\"User credential is disposed\");\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createHash, createHmac } from \"crypto\";\n\nexport const shaHash = async (content: string): Promise<string> =>\n  createHash(\"sha256\")\n    .update(content)\n    .digest(\"base64\");\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const decodedSecret = Buffer.from(secret, \"base64\");\n\n  return createHmac(\"sha256\", decodedSecret)\n    .update(content)\n    .digest(\"base64\");\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  URLBuilder,\n  WebResource,\n  isNode,\n  RequestPolicy,\n  RequestPolicyOptionsLike,\n  RequestPolicyFactory,\n  WebResourceLike,\n  HttpOperationResponse,\n  BaseRequestPolicy\n} from \"@azure/core-http\";\nimport { shaHash, shaHMAC } from \"./cryptoUtils\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\nexport const createCommunicationAccessKeyCredentialPolicy = (\n  credential: KeyCredential\n): RequestPolicyFactory => {\n  return {\n    create: (nextpolicy: RequestPolicy, options: RequestPolicyOptionsLike) => {\n      return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);\n    }\n  };\n};\n\n/**\n * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nclass CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {\n  /**\n   * Initializes a new instance of the CommunicationAccessKeyCredential class\n   * using a base64 encoded key.\n   * @param accessKey - The base64 encoded key to be used for signing.\n   */\n  constructor(\n    private readonly accessKey: KeyCredential,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptionsLike\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Signs a request with the provided access key.\n   *\n   * @param webResource - The WebResource to be signed.\n   */\n  private async signRequest(webResource: WebResource): Promise<WebResource> {\n    const verb = webResource.method.toUpperCase();\n    const utcNow = new Date().toUTCString();\n    const contentHash = await shaHash(webResource.body || \"\");\n    const dateHeader = \"x-ms-date\";\n    const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n    const url = URLBuilder.parse(webResource.url);\n    const query = url.getQuery();\n    const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();\n    const port = url.getPort();\n    const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();\n\n    const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n    const signature = await shaHMAC(this.accessKey.key, stringToSign);\n\n    if (isNode) {\n      webResource.headers.set(\"Host\", hostAndPort || \"\");\n    }\n\n    webResource.headers.set(dateHeader, utcNow);\n    webResource.headers.set(\"x-ms-content-sha256\", contentHash);\n    webResource.headers.set(\n      \"Authorization\",\n      `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`\n    );\n\n    return webResource;\n  }\n\n  /**\n   * Signs the request and calls the next policy in the factory.\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource) {\n      throw new Error(\"webResource cannot be null or undefined\");\n    }\n\n    return this._nextPolicy.sendRequest(await this.signRequest(webResource));\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, KeyCredential, TokenCredential } from \"@azure/core-auth\";\nimport { bearerTokenAuthenticationPolicy, RequestPolicyFactory } from \"@azure/core-http\";\nimport { createCommunicationAccessKeyCredentialPolicy } from \"./communicationAccessKeyCredentialPolicy\";\n/**\n * Creates a pipeline policy to authenticate request based\n * on the credential passed in.\n * @hidden\n *\n * @param credential - The KeyCredential or TokenCredential.\n */\nexport const createCommunicationAuthPolicy = (\n  credential: KeyCredential | TokenCredential\n): RequestPolicyFactory => {\n  if (isTokenCredential(credential)) {\n    return bearerTokenAuthenticationPolicy(credential, \"https://communication.azure.com//.default\");\n  } else {\n    return createCommunicationAccessKeyCredentialPolicy(credential);\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AzureKeyCredential, KeyCredential } from \"@azure/core-auth\";\n/**\n * Represents different properties of connection string\n * using format \"/endpoint=(.*);accesskey=(.*)\".\n * @hidden\n */\nexport interface EndpointCredential {\n  /**\n   * The endpoint as string\n   */\n  endpoint: string;\n  /**\n   * The access key represented as a KeyCredential object\n   */\n  credential: KeyCredential;\n}\n\n// TODO: update when connection string format is finalized\nconst CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;\n\nconst tryParseConnectionString = (s: string): EndpointCredential | undefined => {\n  const match = s.match(CONNECTION_STRING_REGEX);\n  if (match?.[1] && match[2]) {\n    return { endpoint: match[1], credential: new AzureKeyCredential(match[2]) };\n  }\n  return undefined;\n};\n/**\n * Returns an EndpointCredential to easily access properties of the connection string.\n * @hidden\n *\n * @param connectionString - The connection string to parse\n * @returns Object to access the endpoint and the credenials\n */\nexport const parseConnectionString = (connectionString: string): EndpointCredential => {\n  const parsedConnectionString = tryParseConnectionString(connectionString);\n  if (parsedConnectionString) {\n    return parsedConnectionString;\n  } else {\n    throw new Error(`Invalid connection string ${connectionString}`);\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, KeyCredential, TokenCredential } from \"@azure/core-auth\";\nimport { URLBuilder } from \"@azure/core-http\";\nimport { parseConnectionString } from \"./connectionString\";\n\nconst isValidEndpoint = (host: string): boolean => {\n  const url = URLBuilder.parse(host);\n\n  return (\n    !!url.getScheme()?.match(/^http[s]?/) &&\n    url.getHost() !== undefined &&\n    url.getHost() !== \"\" &&\n    (url.getPath() === undefined || url.getPath() === \"\" || url.getPath() === \"/\")\n  );\n};\n\nconst assertValidEndpoint = (host: string): void => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\nexport const isKeyCredential = (credential: unknown): credential is KeyCredential => {\n  const castCredential = credential as {\n    key: unknown;\n    getToken: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.key === \"string\" &&\n    castCredential.getToken === undefined\n  );\n};\n\n/**\n * The URL and credential from parsing the arguments of a communication client.\n * @hidden\n */\nexport type UrlWithCredential = {\n  url: string;\n  credential: TokenCredential | KeyCredential;\n};\n\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\nexport const parseClientArguments = (\n  connectionStringOrUrl: string,\n  credentialOrOptions?: unknown\n): UrlWithCredential => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return { url: connectionStringOrUrl, credential: credentialOrOptions };\n  } else {\n    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return { url: host, credential };\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier =\n  | CommunicationUserIdentifier\n  | PhoneNumberIdentifier\n  | MicrosoftTeamsUserIdentifier\n  | UnknownIdentifier;\n\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n  /**\n   * Id of the CommunicationUser as returned from the Communication Service.\n   */\n  communicationUserId: string;\n}\n\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n  /**\n   * Optional raw id of the phone number.\n   */\n  rawId?: string;\n  /**\n   * The phone number in E.164 format.\n   */\n  phoneNumber: string;\n}\n\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams user.\n   */\n  rawId?: string;\n\n  /**\n   * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n   */\n  microsoftTeamsUserId: string;\n\n  /**\n   * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n   */\n  isAnonymous?: boolean;\n\n  /**\n   * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?: \"public\" | \"dod\" | \"gcch\";\n}\n\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n  /**\n   * Id of the UnknownIdentifier.\n   */\n  id: string;\n}\n\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is CommunicationUserIdentifier => {\n  return typeof (identifier as any).communicationUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is PhoneNumberIdentifier => {\n  return typeof (identifier as any).phoneNumber === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is MicrosoftTeamsUserIdentifier => {\n  return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (\n  identifier: CommunicationIdentifier\n): identifier is UnknownIdentifier => {\n  return typeof (identifier as any).id === \"string\";\n};\n\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind =\n  | CommunicationUserKind\n  | PhoneNumberKind\n  | MicrosoftTeamsUserKind\n  | UnknownIdentifierKind;\n\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"communicationUser\";\n}\n\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"phoneNumber\";\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"microsoftTeamsUser\";\n}\n\n/**\n * IdentifierKind for UnkownIdentifer.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"unknown\";\n}\n\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (\n  identifier: CommunicationIdentifier\n): CommunicationIdentifierKind => {\n  if (isCommunicationUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"communicationUser\" };\n  }\n  if (isPhoneNumberIdentifier(identifier)) {\n    return { ...identifier, kind: \"phoneNumber\" };\n  }\n  if (isMicrosoftTeamsUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsUser\" };\n  }\n  return { ...identifier, kind: \"unknown\" };\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CommunicationIdentifier,\n  CommunicationIdentifierKind,\n  getIdentifierKind\n} from \"./identifierModels\";\n\n/**\n * @hidden\n * Identifies a participant in Azure Communication services. A participant is, for example, a phone number or an Azure communication user. This model must be interpreted as a union: Apart from rawId, at most one further property may be set.\n */\nexport interface SerializedCommunicationIdentifier {\n  /**\n   * Raw Id of the identifier. Optional in requests, required in responses.\n   */\n  rawId?: string;\n  /**\n   * The communication user.\n   */\n  communicationUser?: SerializedCommunicationUserIdentifier;\n  /**\n   * The phone number.\n   */\n  phoneNumber?: SerializedPhoneNumberIdentifier;\n  /**\n   * The Microsoft Teams user.\n   */\n  microsoftTeamsUser?: SerializedMicrosoftTeamsUserIdentifier;\n}\n\n/**\n * @hidden\n * A user that got created with an Azure Communication Services resource.\n */\nexport interface SerializedCommunicationUserIdentifier {\n  /**\n   * The Id of the communication user.\n   */\n  id: string;\n}\n\n/**\n * @hidden\n * A phone number.\n */\nexport interface SerializedPhoneNumberIdentifier {\n  /**\n   * The phone number in E.164 format.\n   */\n  value: string;\n}\n\n/**\n * @hidden\n * A Microsoft Teams user.\n */\nexport interface SerializedMicrosoftTeamsUserIdentifier {\n  /**\n   * The Id of the Microsoft Teams user. If not anonymous, this is the AAD object Id of the user.\n   */\n  userId: string;\n  /**\n   * True if the Microsoft Teams user is anonymous. By default false if missing.\n   */\n  isAnonymous?: boolean;\n  /**\n   * The cloud that the Microsoft Teams user belongs to. By default 'public' if missing.\n   */\n  cloud?: SerializedCommunicationCloudEnvironment;\n}\n\n/**\n * @hidden\n * Defines values for CommunicationCloudEnvironmentModel.\n */\nexport type SerializedCommunicationCloudEnvironment = \"public\" | \"dod\" | \"gcch\";\n\nconst addRawIdIfExisting = <T>(\n  identifier: T,\n  rawId: string | undefined\n): T & { rawId?: string } => {\n  return rawId === undefined ? identifier : { ...identifier, rawId: rawId };\n};\n\nconst assertNotNullOrUndefined = <\n  T extends Record<string, unknown>,\n  P extends keyof T,\n  Q extends keyof T[P]\n>(\n  obj: T,\n  prop: Q\n): Required<Required<T>[P]>[Q] => {\n  const subObjName = Object.keys(obj)[0];\n  const subObj = (obj as any)[subObjName];\n  if (prop in subObj) {\n    return subObj[prop];\n  }\n  throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);\n};\n\nconst assertMaximumOneNestedModel = (identifier: SerializedCommunicationIdentifier): void => {\n  const { rawId: _rawId, ...props } = identifier;\n  const keys = Object.keys(props);\n  if (keys.length > 1) {\n    throw new Error(`Only one of the properties in ${JSON.stringify(keys)} should be present.`);\n  }\n};\n\n/**\n * @hidden\n * Translates a CommunicationIdentifier to its serialized format for sending a request.\n * @param identifier - The CommunicationIdentifier to be serialized.\n */\nexport const serializeCommunicationIdentifier = (\n  identifier: CommunicationIdentifier\n): SerializedCommunicationIdentifier => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return { communicationUser: { id: identifierKind.communicationUserId } };\n    case \"phoneNumber\":\n      return addRawIdIfExisting(\n        { phoneNumber: { value: identifierKind.phoneNumber } },\n        identifierKind.rawId\n      );\n    case \"microsoftTeamsUser\":\n      return addRawIdIfExisting(\n        {\n          microsoftTeamsUser: {\n            userId: identifierKind.microsoftTeamsUserId,\n            isAnonymous: identifierKind.isAnonymous ?? false,\n            cloud: identifierKind.cloud ?? \"public\"\n          }\n        },\n        identifierKind.rawId\n      );\n    case \"unknown\":\n      return { rawId: identifierKind.id };\n    default:\n      throw new Error(`Can't serialize an identifier with kind ${(identifierKind as any).kind}`);\n  }\n};\n\n/**\n * @hidden\n * Translates the serialized format of a communication identifier to CommunicationIdentifier.\n * @param serializedIdentifier - The SerializedCommunicationIdentifier to be deserialized.\n */\nexport const deserializeCommunicationIdentifier = (\n  serializedIdentifier: SerializedCommunicationIdentifier\n): CommunicationIdentifierKind => {\n  assertMaximumOneNestedModel(serializedIdentifier);\n\n  const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;\n  if (communicationUser) {\n    return {\n      kind: \"communicationUser\",\n      communicationUserId: assertNotNullOrUndefined({ communicationUser }, \"id\")\n    };\n  }\n  if (phoneNumber) {\n    return {\n      kind: \"phoneNumber\",\n      phoneNumber: assertNotNullOrUndefined({ phoneNumber }, \"value\"),\n      rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, \"rawId\")\n    };\n  }\n  if (microsoftTeamsUser) {\n    return {\n      kind: \"microsoftTeamsUser\",\n      microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, \"userId\"),\n      isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, \"isAnonymous\"),\n      cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, \"cloud\"),\n      rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, \"rawId\")\n    };\n  }\n  return {\n    kind: \"unknown\",\n    id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, \"rawId\")\n  };\n};\n"],"names":["createHash","createHmac","BaseRequestPolicy","URLBuilder","isTokenCredential","bearerTokenAuthenticationPolicy","AzureKeyCredential"],"mappings":"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"}
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/autoRefreshTokenCredential.js" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/autoRefreshTokenCredential.js"
index 55c8fbc14..179f7c634 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/autoRefreshTokenCredential.js"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/autoRefreshTokenCredential.js"
@@ -1,5 +1,6 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT license.
+import { __awaiter } from "tslib";
 import { parseToken } from "./tokenParser";
 const expiredToken = { token: "", expiresOnTimestamp: -10 };
 const minutesToMs = (minutes) => minutes * 1000 * 60;
@@ -18,15 +19,17 @@ export class AutoRefreshTokenCredential {
             this.scheduleRefresh();
         }
     }
-    async getToken(options) {
-        if (!this.isCurrentTokenExpiringSoon) {
+    getToken(options) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!this.isCurrentTokenExpiringSoon) {
+                return this.currentToken;
+            }
+            const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
+            if (!this.isCurrentTokenValid) {
+                yield updatePromise;
+            }
             return this.currentToken;
-        }
-        const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
-        if (!this.isCurrentTokenValid) {
-            await updatePromise;
-        }
-        return this.currentToken;
+        });
     }
     dispose() {
         this.disposed = true;
@@ -37,34 +40,40 @@ export class AutoRefreshTokenCredential {
             clearTimeout(this.activeTimeout);
         }
     }
-    async updateTokenAndReschedule(abortSignal) {
-        if (this.activeTokenUpdating) {
-            return this.activeTokenUpdating;
-        }
-        this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
-        try {
-            await this.activeTokenUpdating;
-        }
-        finally {
-            this.activeTokenUpdating = null;
-        }
+    updateTokenAndReschedule(abortSignal) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (this.activeTokenUpdating) {
+                return this.activeTokenUpdating;
+            }
+            this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
+            try {
+                yield this.activeTokenUpdating;
+            }
+            finally {
+                this.activeTokenUpdating = null;
+            }
+        });
     }
-    async refreshTokenAndReschedule(abortSignal) {
-        this.currentToken = await this.refreshToken(abortSignal);
-        if (this.refreshProactively) {
-            this.scheduleRefresh();
-        }
+    refreshTokenAndReschedule(abortSignal) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.currentToken = yield this.refreshToken(abortSignal);
+            if (this.refreshProactively) {
+                this.scheduleRefresh();
+            }
+        });
     }
-    async refreshToken(abortSignal) {
-        try {
-            if (!this.activeTokenFetching) {
-                this.activeTokenFetching = this.refresh(abortSignal);
+    refreshToken(abortSignal) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                if (!this.activeTokenFetching) {
+                    this.activeTokenFetching = this.refresh(abortSignal);
+                }
+                return parseToken(yield this.activeTokenFetching);
             }
-            return parseToken(await this.activeTokenFetching);
-        }
-        finally {
-            this.activeTokenFetching = null;
-        }
+            finally {
+                this.activeTokenFetching = null;
+            }
+        });
     }
     scheduleRefresh() {
         if (this.disposed) {
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/autoRefreshTokenCredential.js.map" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/autoRefreshTokenCredential.js.map"
index df866c279..48eb3019b 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/autoRefreshTokenCredential.js.map"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/autoRefreshTokenCredential.js.map"
@@ -1 +1 @@
-{"version":3,"file":"autoRefreshTokenCredential.js","sourceRoot":"","sources":["../../src/autoRefreshTokenCredential.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { TokenCredential, CommunicationGetTokenOptions } from \"./communicationTokenCredential\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Function that returns a token acquired from the Communication configuration SDK.\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultRefreshingInterval = minutesToMs(10);\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly refreshingIntervalInMs: number = defaultRefreshingInterval;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isCurrentTokenExpiringSoon) {\n      return this.currentToken;\n    }\n\n    const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n\n    if (!this.isCurrentTokenValid) {\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    this.currentToken = await this.refreshToken(abortSignal);\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const timespanInMs =\n      this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private get isCurrentTokenValid(): boolean {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  private get isCurrentTokenExpiringSoon(): boolean {\n    return (\n      !this.currentToken ||\n      Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs\n    );\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"autoRefreshTokenCredential.js","sourceRoot":"","sources":["../../src/autoRefreshTokenCredential.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { TokenCredential, CommunicationGetTokenOptions } from \"./communicationTokenCredential\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Function that returns a token acquired from the Communication configuration SDK.\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultRefreshingInterval = minutesToMs(10);\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly refreshingIntervalInMs: number = defaultRefreshingInterval;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isCurrentTokenExpiringSoon) {\n      return this.currentToken;\n    }\n\n    const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n\n    if (!this.isCurrentTokenValid) {\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    this.currentToken = await this.refreshToken(abortSignal);\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const timespanInMs =\n      this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private get isCurrentTokenValid(): boolean {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  private get isCurrentTokenExpiringSoon(): boolean {\n    return (\n      !this.currentToken ||\n      Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/communicationTokenCredential.js" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/communicationTokenCredential.js"
index 290042cc6..6e5cba081 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/communicationTokenCredential.js"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/communicationTokenCredential.js"
@@ -1,5 +1,6 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT license.
+import { __awaiter } from "tslib";
 import { parseToken } from "./tokenParser";
 import { StaticTokenCredential } from "./staticTokenCredential";
 import { AutoRefreshTokenCredential } from "./autoRefreshTokenCredential";
@@ -20,11 +21,13 @@ export class AzureCommunicationTokenCredential {
      * Gets an `AccessToken` for the user. Throws if already disposed.
      * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
      */
-    async getToken(options) {
-        this.throwIfDisposed();
-        const token = await this.tokenCredential.getToken(options);
-        this.throwIfDisposed();
-        return token;
+    getToken(options) {
+        return __awaiter(this, void 0, void 0, function* () {
+            this.throwIfDisposed();
+            const token = yield this.tokenCredential.getToken(options);
+            this.throwIfDisposed();
+            return token;
+        });
     }
     /**
      * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/communicationTokenCredential.js.map" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/communicationTokenCredential.js.map"
index f3da024c7..a9499bc15 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/communicationTokenCredential.js.map"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/communicationTokenCredential.js.map"
@@ -1 +1 @@
-{"version":3,"file":"communicationTokenCredential.js","sourceRoot":"","sources":["../../src/communicationTokenCredential.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAGlC,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C,OAAO,EAAE,qBAAqB,EAAE,MAAM,yBAAyB,CAAC;AAChE,OAAO,EACL,0BAA0B,EAE3B,MAAM,8BAA8B,CAAC;AA6BtC;;GAEG;AACH,MAAM,OAAO,iCAAiC;IAe5C,YAAY,qBAAgE;QAbpE,aAAQ,GAAG,KAAK,CAAC;QAcvB,IAAI,OAAO,qBAAqB,KAAK,QAAQ,EAAE;YAC7C,IAAI,CAAC,eAAe,GAAG,IAAI,qBAAqB,CAAC,UAAU,CAAC,qBAAqB,CAAC,CAAC,CAAC;SACrF;aAAM;YACL,IAAI,CAAC,eAAe,GAAG,IAAI,0BAA0B,CAAC,qBAAqB,CAAC,CAAC;SAC9E;IACH,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,QAAQ,CAAC,OAAsC;QAC1D,IAAI,CAAC,eAAe,EAAE,CAAC;QACvB,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC3D,IAAI,CAAC,eAAe,EAAE,CAAC;QACvB,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACI,OAAO;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;IACjC,CAAC;IAEO,eAAe;QACrB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { StaticTokenCredential } from \"./staticTokenCredential\";\nimport {\n  AutoRefreshTokenCredential,\n  CommunicationTokenRefreshOptions\n} from \"./autoRefreshTokenCredential\";\n\nexport type TokenCredential = Pick<AzureCommunicationTokenCredential, \"getToken\" | \"dispose\">;\n\n/**\n * Options for `CommunicationTokenCredential`'s `getToken` function.\n */\nexport interface CommunicationGetTokenOptions {\n  /**\n   * An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The Azure Communication Services token credential.\n */\nexport interface CommunicationTokenCredential {\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param options - Additional options.\n   */\n  getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken>;\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  dispose(): void;\n}\n\n/**\n * The CommunicationTokenCredential implementation with support for proactive token refresh.\n */\nexport class AzureCommunicationTokenCredential implements CommunicationTokenCredential {\n  private readonly tokenCredential: TokenCredential;\n  private disposed = false;\n\n  /**\n   * Creates an instance of CommunicationTokenCredential with a static token and no proactive refreshing.\n   * @param token - A user access token issued by Communication Services.\n   */\n  constructor(token: string);\n  /**\n   * Creates an instance of CommunicationTokenCredential with a lambda to get a token and options\n   * to configure proactive refreshing.\n   * @param refreshOptions - Options to configure refresh and opt-in to proactive refreshing.\n   */\n  constructor(refreshOptions: CommunicationTokenRefreshOptions);\n  constructor(tokenOrRefreshOptions: string | CommunicationTokenRefreshOptions) {\n    if (typeof tokenOrRefreshOptions === \"string\") {\n      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));\n    } else {\n      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);\n    }\n  }\n\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    this.throwIfDisposed();\n    const token = await this.tokenCredential.getToken(options);\n    this.throwIfDisposed();\n    return token;\n  }\n\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  public dispose(): void {\n    this.disposed = true;\n    this.tokenCredential.dispose();\n  }\n\n  private throwIfDisposed(): void {\n    if (this.disposed) {\n      throw new Error(\"User credential is disposed\");\n    }\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"communicationTokenCredential.js","sourceRoot":"","sources":["../../src/communicationTokenCredential.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAGlC,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C,OAAO,EAAE,qBAAqB,EAAE,MAAM,yBAAyB,CAAC;AAChE,OAAO,EACL,0BAA0B,EAE3B,MAAM,8BAA8B,CAAC;AA6BtC;;GAEG;AACH,MAAM,OAAO,iCAAiC;IAe5C,YAAY,qBAAgE;QAbpE,aAAQ,GAAG,KAAK,CAAC;QAcvB,IAAI,OAAO,qBAAqB,KAAK,QAAQ,EAAE;YAC7C,IAAI,CAAC,eAAe,GAAG,IAAI,qBAAqB,CAAC,UAAU,CAAC,qBAAqB,CAAC,CAAC,CAAC;SACrF;aAAM;YACL,IAAI,CAAC,eAAe,GAAG,IAAI,0BAA0B,CAAC,qBAAqB,CAAC,CAAC;SAC9E;IACH,CAAC;IAED;;;OAGG;IACU,QAAQ,CAAC,OAAsC;;YAC1D,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YAC3D,IAAI,CAAC,eAAe,EAAE,CAAC;YACvB,OAAO,KAAK,CAAC;QACf,CAAC;KAAA;IAED;;OAEG;IACI,OAAO;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,CAAC;IACjC,CAAC;IAEO,eAAe;QACrB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { StaticTokenCredential } from \"./staticTokenCredential\";\nimport {\n  AutoRefreshTokenCredential,\n  CommunicationTokenRefreshOptions\n} from \"./autoRefreshTokenCredential\";\n\nexport type TokenCredential = Pick<AzureCommunicationTokenCredential, \"getToken\" | \"dispose\">;\n\n/**\n * Options for `CommunicationTokenCredential`'s `getToken` function.\n */\nexport interface CommunicationGetTokenOptions {\n  /**\n   * An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The Azure Communication Services token credential.\n */\nexport interface CommunicationTokenCredential {\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param options - Additional options.\n   */\n  getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken>;\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  dispose(): void;\n}\n\n/**\n * The CommunicationTokenCredential implementation with support for proactive token refresh.\n */\nexport class AzureCommunicationTokenCredential implements CommunicationTokenCredential {\n  private readonly tokenCredential: TokenCredential;\n  private disposed = false;\n\n  /**\n   * Creates an instance of CommunicationTokenCredential with a static token and no proactive refreshing.\n   * @param token - A user access token issued by Communication Services.\n   */\n  constructor(token: string);\n  /**\n   * Creates an instance of CommunicationTokenCredential with a lambda to get a token and options\n   * to configure proactive refreshing.\n   * @param refreshOptions - Options to configure refresh and opt-in to proactive refreshing.\n   */\n  constructor(refreshOptions: CommunicationTokenRefreshOptions);\n  constructor(tokenOrRefreshOptions: string | CommunicationTokenRefreshOptions) {\n    if (typeof tokenOrRefreshOptions === \"string\") {\n      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));\n    } else {\n      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);\n    }\n  }\n\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    this.throwIfDisposed();\n    const token = await this.tokenCredential.getToken(options);\n    this.throwIfDisposed();\n    return token;\n  }\n\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  public dispose(): void {\n    this.disposed = true;\n    this.tokenCredential.dispose();\n  }\n\n  private throwIfDisposed(): void {\n    if (this.disposed) {\n      throw new Error(\"User credential is disposed\");\n    }\n  }\n}\n"]}
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js"
index e24e197f4..cb336fe99 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js"
@@ -1,5 +1,6 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT license.
+import { __awaiter } from "tslib";
 import { URLBuilder, isNode, BaseRequestPolicy } from "@azure/core-http";
 import { shaHash, shaHMAC } from "./cryptoUtils";
 /**
@@ -34,35 +35,39 @@ class CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {
      *
      * @param webResource - The WebResource to be signed.
      */
-    async signRequest(webResource) {
-        const verb = webResource.method.toUpperCase();
-        const utcNow = new Date().toUTCString();
-        const contentHash = await shaHash(webResource.body || "");
-        const dateHeader = "x-ms-date";
-        const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
-        const url = URLBuilder.parse(webResource.url);
-        const query = url.getQuery();
-        const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
-        const port = url.getPort();
-        const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
-        const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
-        const signature = await shaHMAC(this.accessKey.key, stringToSign);
-        if (isNode) {
-            webResource.headers.set("Host", hostAndPort || "");
-        }
-        webResource.headers.set(dateHeader, utcNow);
-        webResource.headers.set("x-ms-content-sha256", contentHash);
-        webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
-        return webResource;
+    signRequest(webResource) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const verb = webResource.method.toUpperCase();
+            const utcNow = new Date().toUTCString();
+            const contentHash = yield shaHash(webResource.body || "");
+            const dateHeader = "x-ms-date";
+            const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
+            const url = URLBuilder.parse(webResource.url);
+            const query = url.getQuery();
+            const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
+            const port = url.getPort();
+            const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
+            const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
+            const signature = yield shaHMAC(this.accessKey.key, stringToSign);
+            if (isNode) {
+                webResource.headers.set("Host", hostAndPort || "");
+            }
+            webResource.headers.set(dateHeader, utcNow);
+            webResource.headers.set("x-ms-content-sha256", contentHash);
+            webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
+            return webResource;
+        });
     }
     /**
      * Signs the request and calls the next policy in the factory.
      */
-    async sendRequest(webResource) {
-        if (!webResource) {
-            throw new Error("webResource cannot be null or undefined");
-        }
-        return this._nextPolicy.sendRequest(await this.signRequest(webResource));
+    sendRequest(webResource) {
+        return __awaiter(this, void 0, void 0, function* () {
+            if (!webResource) {
+                throw new Error("webResource cannot be null or undefined");
+            }
+            return this._nextPolicy.sendRequest(yield this.signRequest(webResource));
+        });
     }
 }
 //# sourceMappingURL=communicationAccessKeyCredentialPolicy.js.map
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js.map" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js.map"
index e4d2b4a93..43ae10655 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js.map"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/communicationAccessKeyCredentialPolicy.js.map"
@@ -1 +1 @@
-{"version":3,"file":"communicationAccessKeyCredentialPolicy.js","sourceRoot":"","sources":["../../../src/credential/communicationAccessKeyCredentialPolicy.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAGlC,OAAO,EACL,UAAU,EAEV,MAAM,EAMN,iBAAiB,EAClB,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAEjD;;;;;GAKG;AACH,MAAM,CAAC,MAAM,4CAA4C,GAAG,CAC1D,UAAyB,EACH,EAAE;IACxB,OAAO;QACL,MAAM,EAAE,CAAC,UAAyB,EAAE,OAAiC,EAAE,EAAE;YACvE,OAAO,IAAI,sCAAsC,CAAC,UAAU,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;QACrF,CAAC;KACF,CAAC;AACJ,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,sCAAuC,SAAQ,iBAAiB;IACpE;;;;OAIG;IACH,YACmB,SAAwB,EACzC,UAAyB,EACzB,OAAiC;QAEjC,KAAK,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAJV,cAAS,GAAT,SAAS,CAAe;IAK3C,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAC,WAAW,CAAC,WAAwB;QAChD,MAAM,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;QAC9C,MAAM,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;QACxC,MAAM,WAAW,GAAG,MAAM,OAAO,CAAC,WAAW,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC;QAC1D,MAAM,UAAU,GAAG,WAAW,CAAC;QAC/B,MAAM,aAAa,GAAG,GAAG,UAAU,2BAA2B,CAAC;QAE/D,MAAM,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QAC9C,MAAM,KAAK,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;QAC7B,MAAM,eAAe,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,OAAO,EAAE,IAAI,KAAK,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;QAC5E,MAAM,IAAI,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;QAC3B,MAAM,WAAW,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;QAEtE,MAAM,YAAY,GAAG,GAAG,IAAI,KAAK,eAAe,KAAK,MAAM,IAAI,WAAW,IAAI,WAAW,EAAE,CAAC;QAC5F,MAAM,SAAS,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;QAElE,IAAI,MAAM,EAAE;YACV,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,WAAW,IAAI,EAAE,CAAC,CAAC;SACpD;QAED,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;QAC5C,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,qBAAqB,EAAE,WAAW,CAAC,CAAC;QAC5D,WAAW,CAAC,OAAO,CAAC,GAAG,CACrB,eAAe,EACf,6BAA6B,aAAa,cAAc,SAAS,EAAE,CACpE,CAAC;QAEF,OAAO,WAAW,CAAC;IACrB,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,WAAW,CAAC,WAA4B;QACnD,IAAI,CAAC,WAAW,EAAE;YAChB,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;SAC5D;QAED,OAAO,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC,CAAC;IAC3E,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  URLBuilder,\n  WebResource,\n  isNode,\n  RequestPolicy,\n  RequestPolicyOptionsLike,\n  RequestPolicyFactory,\n  WebResourceLike,\n  HttpOperationResponse,\n  BaseRequestPolicy\n} from \"@azure/core-http\";\nimport { shaHash, shaHMAC } from \"./cryptoUtils\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\nexport const createCommunicationAccessKeyCredentialPolicy = (\n  credential: KeyCredential\n): RequestPolicyFactory => {\n  return {\n    create: (nextpolicy: RequestPolicy, options: RequestPolicyOptionsLike) => {\n      return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);\n    }\n  };\n};\n\n/**\n * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nclass CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {\n  /**\n   * Initializes a new instance of the CommunicationAccessKeyCredential class\n   * using a base64 encoded key.\n   * @param accessKey - The base64 encoded key to be used for signing.\n   */\n  constructor(\n    private readonly accessKey: KeyCredential,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptionsLike\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Signs a request with the provided access key.\n   *\n   * @param webResource - The WebResource to be signed.\n   */\n  private async signRequest(webResource: WebResource): Promise<WebResource> {\n    const verb = webResource.method.toUpperCase();\n    const utcNow = new Date().toUTCString();\n    const contentHash = await shaHash(webResource.body || \"\");\n    const dateHeader = \"x-ms-date\";\n    const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n    const url = URLBuilder.parse(webResource.url);\n    const query = url.getQuery();\n    const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();\n    const port = url.getPort();\n    const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();\n\n    const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n    const signature = await shaHMAC(this.accessKey.key, stringToSign);\n\n    if (isNode) {\n      webResource.headers.set(\"Host\", hostAndPort || \"\");\n    }\n\n    webResource.headers.set(dateHeader, utcNow);\n    webResource.headers.set(\"x-ms-content-sha256\", contentHash);\n    webResource.headers.set(\n      \"Authorization\",\n      `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`\n    );\n\n    return webResource;\n  }\n\n  /**\n   * Signs the request and calls the next policy in the factory.\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource) {\n      throw new Error(\"webResource cannot be null or undefined\");\n    }\n\n    return this._nextPolicy.sendRequest(await this.signRequest(webResource));\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"communicationAccessKeyCredentialPolicy.js","sourceRoot":"","sources":["../../../src/credential/communicationAccessKeyCredentialPolicy.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAGlC,OAAO,EACL,UAAU,EAEV,MAAM,EAMN,iBAAiB,EAClB,MAAM,kBAAkB,CAAC;AAC1B,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AAEjD;;;;;GAKG;AACH,MAAM,CAAC,MAAM,4CAA4C,GAAG,CAC1D,UAAyB,EACH,EAAE;IACxB,OAAO;QACL,MAAM,EAAE,CAAC,UAAyB,EAAE,OAAiC,EAAE,EAAE;YACvE,OAAO,IAAI,sCAAsC,CAAC,UAAU,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;QACrF,CAAC;KACF,CAAC;AACJ,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,sCAAuC,SAAQ,iBAAiB;IACpE;;;;OAIG;IACH,YACmB,SAAwB,EACzC,UAAyB,EACzB,OAAiC;QAEjC,KAAK,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QAJV,cAAS,GAAT,SAAS,CAAe;IAK3C,CAAC;IAED;;;;OAIG;IACW,WAAW,CAAC,WAAwB;;YAChD,MAAM,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;YAC9C,MAAM,MAAM,GAAG,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;YACxC,MAAM,WAAW,GAAG,MAAM,OAAO,CAAC,WAAW,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC;YAC1D,MAAM,UAAU,GAAG,WAAW,CAAC;YAC/B,MAAM,aAAa,GAAG,GAAG,UAAU,2BAA2B,CAAC;YAE/D,MAAM,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YAC9C,MAAM,KAAK,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;YAC7B,MAAM,eAAe,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,OAAO,EAAE,IAAI,KAAK,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;YAC5E,MAAM,IAAI,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;YAC3B,MAAM,WAAW,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;YAEtE,MAAM,YAAY,GAAG,GAAG,IAAI,KAAK,eAAe,KAAK,MAAM,IAAI,WAAW,IAAI,WAAW,EAAE,CAAC;YAC5F,MAAM,SAAS,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,YAAY,CAAC,CAAC;YAElE,IAAI,MAAM,EAAE;gBACV,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,WAAW,IAAI,EAAE,CAAC,CAAC;aACpD;YAED,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;YAC5C,WAAW,CAAC,OAAO,CAAC,GAAG,CAAC,qBAAqB,EAAE,WAAW,CAAC,CAAC;YAC5D,WAAW,CAAC,OAAO,CAAC,GAAG,CACrB,eAAe,EACf,6BAA6B,aAAa,cAAc,SAAS,EAAE,CACpE,CAAC;YAEF,OAAO,WAAW,CAAC;QACrB,CAAC;KAAA;IAED;;OAEG;IACU,WAAW,CAAC,WAA4B;;YACnD,IAAI,CAAC,WAAW,EAAE;gBAChB,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;aAC5D;YAED,OAAO,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC,CAAC;QAC3E,CAAC;KAAA;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential } from \"@azure/core-auth\";\nimport {\n  URLBuilder,\n  WebResource,\n  isNode,\n  RequestPolicy,\n  RequestPolicyOptionsLike,\n  RequestPolicyFactory,\n  WebResourceLike,\n  HttpOperationResponse,\n  BaseRequestPolicy\n} from \"@azure/core-http\";\nimport { shaHash, shaHMAC } from \"./cryptoUtils\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\nexport const createCommunicationAccessKeyCredentialPolicy = (\n  credential: KeyCredential\n): RequestPolicyFactory => {\n  return {\n    create: (nextpolicy: RequestPolicy, options: RequestPolicyOptionsLike) => {\n      return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);\n    }\n  };\n};\n\n/**\n * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nclass CommunicationAccessKeyCredentialPolicy extends BaseRequestPolicy {\n  /**\n   * Initializes a new instance of the CommunicationAccessKeyCredential class\n   * using a base64 encoded key.\n   * @param accessKey - The base64 encoded key to be used for signing.\n   */\n  constructor(\n    private readonly accessKey: KeyCredential,\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptionsLike\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Signs a request with the provided access key.\n   *\n   * @param webResource - The WebResource to be signed.\n   */\n  private async signRequest(webResource: WebResource): Promise<WebResource> {\n    const verb = webResource.method.toUpperCase();\n    const utcNow = new Date().toUTCString();\n    const contentHash = await shaHash(webResource.body || \"\");\n    const dateHeader = \"x-ms-date\";\n    const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n    const url = URLBuilder.parse(webResource.url);\n    const query = url.getQuery();\n    const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();\n    const port = url.getPort();\n    const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();\n\n    const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n    const signature = await shaHMAC(this.accessKey.key, stringToSign);\n\n    if (isNode) {\n      webResource.headers.set(\"Host\", hostAndPort || \"\");\n    }\n\n    webResource.headers.set(dateHeader, utcNow);\n    webResource.headers.set(\"x-ms-content-sha256\", contentHash);\n    webResource.headers.set(\n      \"Authorization\",\n      `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`\n    );\n\n    return webResource;\n  }\n\n  /**\n   * Signs the request and calls the next policy in the factory.\n   */\n  public async sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!webResource) {\n      throw new Error(\"webResource cannot be null or undefined\");\n    }\n\n    return this._nextPolicy.sendRequest(await this.signRequest(webResource));\n  }\n}\n"]}
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/cryptoUtils.browser.js" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/cryptoUtils.browser.js"
index 6b4819e57..bcaa71136 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/cryptoUtils.browser.js"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/cryptoUtils.browser.js"
@@ -1,5 +1,6 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT license.
+import { __awaiter } from "tslib";
 import { encodeUTF8, encodeBase64, encodeUTF8fromBase64 } from "./encodeUtils.browser";
 const globalRef = globalThis;
 const getCrypto = () => {
@@ -11,18 +12,18 @@ const getCrypto = () => {
     }
     return globalRef.crypto.subtle;
 };
-export const shaHash = async (content) => {
+export const shaHash = (content) => __awaiter(void 0, void 0, void 0, function* () {
     const data = encodeUTF8(content);
-    const hash = await getCrypto().digest("SHA-256", data);
+    const hash = yield getCrypto().digest("SHA-256", data);
     return encodeBase64(hash);
-};
-export const shaHMAC = async (secret, content) => {
+});
+export const shaHMAC = (secret, content) => __awaiter(void 0, void 0, void 0, function* () {
     const importParams = { name: "HMAC", hash: { name: "SHA-256" } };
     const encodedMessage = encodeUTF8(content);
     const encodedKey = encodeUTF8fromBase64(secret);
     const crypto = getCrypto();
-    const cryptoKey = await crypto.importKey("raw", encodedKey, importParams, false, ["sign"]);
-    const signature = await crypto.sign(importParams, cryptoKey, encodedMessage);
+    const cryptoKey = yield crypto.importKey("raw", encodedKey, importParams, false, ["sign"]);
+    const signature = yield crypto.sign(importParams, cryptoKey, encodedMessage);
     return encodeBase64(signature);
-};
+});
 //# sourceMappingURL=cryptoUtils.browser.js.map
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/cryptoUtils.browser.js.map" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/cryptoUtils.browser.js.map"
index a6edffd40..0318e64e7 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/cryptoUtils.browser.js.map"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/cryptoUtils.browser.js.map"
@@ -1 +1 @@
-{"version":3,"file":"cryptoUtils.browser.js","sourceRoot":"","sources":["../../../src/credential/cryptoUtils.browser.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAEvF,MAAM,SAAS,GAAQ,UAAU,CAAC;AAElC,MAAM,SAAS,GAAG,GAAiB,EAAE;IACnC,IAAI,CAAC,SAAS,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;KAC1C;IAED,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,EAAE;QACjD,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;KACpE;IAED,OAAO,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC;AACjC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,OAAO,GAAG,KAAK,EAAE,OAAe,EAAmB,EAAE;IAChE,MAAM,IAAI,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;IACjC,MAAM,IAAI,GAAG,MAAM,SAAS,EAAE,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACvD,OAAO,YAAY,CAAC,IAAI,CAAC,CAAC;AAC5B,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,OAAO,GAAG,KAAK,EAAE,MAAc,EAAE,OAAe,EAAmB,EAAE;IAChF,MAAM,YAAY,GAAqB,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,CAAC;IACnF,MAAM,cAAc,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;IAC3C,MAAM,UAAU,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAChD,MAAM,MAAM,GAAG,SAAS,EAAE,CAAC;IAC3B,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,UAAU,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;IAC3F,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,YAAY,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;IAC7E,OAAO,YAAY,CAAC,SAAS,CAAC,CAAC;AACjC,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { encodeUTF8, encodeBase64, encodeUTF8fromBase64 } from \"./encodeUtils.browser\";\n\nconst globalRef: any = globalThis;\n\nconst getCrypto = (): SubtleCrypto => {\n  if (!globalRef) {\n    throw new Error(\"Could not find global\");\n  }\n\n  if (!globalRef.crypto || !globalRef.crypto.subtle) {\n    throw new Error(\"Browser does not support cryptography functions\");\n  }\n\n  return globalRef.crypto.subtle;\n};\n\nexport const shaHash = async (content: string): Promise<string> => {\n  const data = encodeUTF8(content);\n  const hash = await getCrypto().digest(\"SHA-256\", data);\n  return encodeBase64(hash);\n};\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const importParams: HmacImportParams = { name: \"HMAC\", hash: { name: \"SHA-256\" } };\n  const encodedMessage = encodeUTF8(content);\n  const encodedKey = encodeUTF8fromBase64(secret);\n  const crypto = getCrypto();\n  const cryptoKey = await crypto.importKey(\"raw\", encodedKey, importParams, false, [\"sign\"]);\n  const signature = await crypto.sign(importParams, cryptoKey, encodedMessage);\n  return encodeBase64(signature);\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"cryptoUtils.browser.js","sourceRoot":"","sources":["../../../src/credential/cryptoUtils.browser.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAElC,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,oBAAoB,EAAE,MAAM,uBAAuB,CAAC;AAEvF,MAAM,SAAS,GAAQ,UAAU,CAAC;AAElC,MAAM,SAAS,GAAG,GAAiB,EAAE;IACnC,IAAI,CAAC,SAAS,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;KAC1C;IAED,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,EAAE;QACjD,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;KACpE;IAED,OAAO,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC;AACjC,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,OAAO,GAAG,CAAO,OAAe,EAAmB,EAAE;IAChE,MAAM,IAAI,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;IACjC,MAAM,IAAI,GAAG,MAAM,SAAS,EAAE,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACvD,OAAO,YAAY,CAAC,IAAI,CAAC,CAAC;AAC5B,CAAC,CAAA,CAAC;AAEF,MAAM,CAAC,MAAM,OAAO,GAAG,CAAO,MAAc,EAAE,OAAe,EAAmB,EAAE;IAChF,MAAM,YAAY,GAAqB,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE,EAAE,CAAC;IACnF,MAAM,cAAc,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;IAC3C,MAAM,UAAU,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAChD,MAAM,MAAM,GAAG,SAAS,EAAE,CAAC;IAC3B,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,UAAU,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;IAC3F,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,IAAI,CAAC,YAAY,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;IAC7E,OAAO,YAAY,CAAC,SAAS,CAAC,CAAC;AACjC,CAAC,CAAA,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { encodeUTF8, encodeBase64, encodeUTF8fromBase64 } from \"./encodeUtils.browser\";\n\nconst globalRef: any = globalThis;\n\nconst getCrypto = (): SubtleCrypto => {\n  if (!globalRef) {\n    throw new Error(\"Could not find global\");\n  }\n\n  if (!globalRef.crypto || !globalRef.crypto.subtle) {\n    throw new Error(\"Browser does not support cryptography functions\");\n  }\n\n  return globalRef.crypto.subtle;\n};\n\nexport const shaHash = async (content: string): Promise<string> => {\n  const data = encodeUTF8(content);\n  const hash = await getCrypto().digest(\"SHA-256\", data);\n  return encodeBase64(hash);\n};\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const importParams: HmacImportParams = { name: \"HMAC\", hash: { name: \"SHA-256\" } };\n  const encodedMessage = encodeUTF8(content);\n  const encodedKey = encodeUTF8fromBase64(secret);\n  const crypto = getCrypto();\n  const cryptoKey = await crypto.importKey(\"raw\", encodedKey, importParams, false, [\"sign\"]);\n  const signature = await crypto.sign(importParams, cryptoKey, encodedMessage);\n  return encodeBase64(signature);\n};\n"]}
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/cryptoUtils.js" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/cryptoUtils.js"
index c8be29579..410e6d9b5 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/cryptoUtils.js"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/cryptoUtils.js"
@@ -1,13 +1,16 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT license.
+import { __awaiter } from "tslib";
 import { createHash, createHmac } from "crypto";
-export const shaHash = async (content) => createHash("sha256")
-    .update(content)
-    .digest("base64");
-export const shaHMAC = async (secret, content) => {
+export const shaHash = (content) => __awaiter(void 0, void 0, void 0, function* () {
+    return createHash("sha256")
+        .update(content)
+        .digest("base64");
+});
+export const shaHMAC = (secret, content) => __awaiter(void 0, void 0, void 0, function* () {
     const decodedSecret = Buffer.from(secret, "base64");
     return createHmac("sha256", decodedSecret)
         .update(content)
         .digest("base64");
-};
+});
 //# sourceMappingURL=cryptoUtils.js.map
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/cryptoUtils.js.map" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/cryptoUtils.js.map"
index 07122372a..ba824c9db 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/credential/cryptoUtils.js.map"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/credential/cryptoUtils.js.map"
@@ -1 +1 @@
-{"version":3,"file":"cryptoUtils.js","sourceRoot":"","sources":["../../../src/credential/cryptoUtils.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,QAAQ,CAAC;AAEhD,MAAM,CAAC,MAAM,OAAO,GAAG,KAAK,EAAE,OAAe,EAAmB,EAAE,CAChE,UAAU,CAAC,QAAQ,CAAC;KACjB,MAAM,CAAC,OAAO,CAAC;KACf,MAAM,CAAC,QAAQ,CAAC,CAAC;AAEtB,MAAM,CAAC,MAAM,OAAO,GAAG,KAAK,EAAE,MAAc,EAAE,OAAe,EAAmB,EAAE;IAChF,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAEpD,OAAO,UAAU,CAAC,QAAQ,EAAE,aAAa,CAAC;SACvC,MAAM,CAAC,OAAO,CAAC;SACf,MAAM,CAAC,QAAQ,CAAC,CAAC;AACtB,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createHash, createHmac } from \"crypto\";\n\nexport const shaHash = async (content: string): Promise<string> =>\n  createHash(\"sha256\")\n    .update(content)\n    .digest(\"base64\");\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const decodedSecret = Buffer.from(secret, \"base64\");\n\n  return createHmac(\"sha256\", decodedSecret)\n    .update(content)\n    .digest(\"base64\");\n};\n"]}
\ No newline at end of file
+{"version":3,"file":"cryptoUtils.js","sourceRoot":"","sources":["../../../src/credential/cryptoUtils.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAElC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,QAAQ,CAAC;AAEhD,MAAM,CAAC,MAAM,OAAO,GAAG,CAAO,OAAe,EAAmB,EAAE;IAChE,OAAA,UAAU,CAAC,QAAQ,CAAC;SACjB,MAAM,CAAC,OAAO,CAAC;SACf,MAAM,CAAC,QAAQ,CAAC,CAAA;EAAA,CAAC;AAEtB,MAAM,CAAC,MAAM,OAAO,GAAG,CAAO,MAAc,EAAE,OAAe,EAAmB,EAAE;IAChF,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAEpD,OAAO,UAAU,CAAC,QAAQ,EAAE,aAAa,CAAC;SACvC,MAAM,CAAC,OAAO,CAAC;SACf,MAAM,CAAC,QAAQ,CAAC,CAAC;AACtB,CAAC,CAAA,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createHash, createHmac } from \"crypto\";\n\nexport const shaHash = async (content: string): Promise<string> =>\n  createHash(\"sha256\")\n    .update(content)\n    .digest(\"base64\");\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const decodedSecret = Buffer.from(secret, \"base64\");\n\n  return createHmac(\"sha256\", decodedSecret)\n    .update(content)\n    .digest(\"base64\");\n};\n"]}
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/staticTokenCredential.js" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/staticTokenCredential.js"
index 244adf811..fe9696d55 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/staticTokenCredential.js"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/staticTokenCredential.js"
@@ -1,5 +1,6 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT license.
+import { __awaiter } from "tslib";
 /**
  * StaticTokenCredential
  */
@@ -7,8 +8,10 @@ export class StaticTokenCredential {
     constructor(token) {
         this.token = token;
     }
-    async getToken() {
-        return this.token;
+    getToken() {
+        return __awaiter(this, void 0, void 0, function* () {
+            return this.token;
+        });
     }
     dispose() {
         /* intentionally empty */
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/staticTokenCredential.js.map" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/staticTokenCredential.js.map"
index 1a5413a00..a1b399d9c 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/dist-esm/src/staticTokenCredential.js.map"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/dist-esm/src/staticTokenCredential.js.map"
@@ -1 +1 @@
-{"version":3,"file":"staticTokenCredential.js","sourceRoot":"","sources":["../../src/staticTokenCredential.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAKlC;;GAEG;AACH,MAAM,OAAO,qBAAqB;IAChC,YAA6B,KAAkB;QAAlB,UAAK,GAAL,KAAK,CAAa;IAAG,CAAC;IAE5C,KAAK,CAAC,QAAQ;QACnB,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAEM,OAAO;QACZ,yBAAyB;IAC3B,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-http\";\nimport { TokenCredential } from \"./communicationTokenCredential\";\n\n/**\n * StaticTokenCredential\n */\nexport class StaticTokenCredential implements TokenCredential {\n  constructor(private readonly token: AccessToken) {}\n\n  public async getToken(): Promise<AccessToken> {\n    return this.token;\n  }\n\n  public dispose(): void {\n    /* intentionally empty */\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"staticTokenCredential.js","sourceRoot":"","sources":["../../src/staticTokenCredential.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAKlC;;GAEG;AACH,MAAM,OAAO,qBAAqB;IAChC,YAA6B,KAAkB;QAAlB,UAAK,GAAL,KAAK,CAAa;IAAG,CAAC;IAEtC,QAAQ;;YACnB,OAAO,IAAI,CAAC,KAAK,CAAC;QACpB,CAAC;KAAA;IAEM,OAAO;QACZ,yBAAyB;IAC3B,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-http\";\nimport { TokenCredential } from \"./communicationTokenCredential\";\n\n/**\n * StaticTokenCredential\n */\nexport class StaticTokenCredential implements TokenCredential {\n  constructor(private readonly token: AccessToken) {}\n\n  public async getToken(): Promise<AccessToken> {\n    return this.token;\n  }\n\n  public dispose(): void {\n    /* intentionally empty */\n  }\n}\n"]}
\ No newline at end of file
diff --git "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/package.json" "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/package.json"
index e834c27ed..19c94a9c0 100644
--- "a/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-lastDev/package/package.json"
+++ "b/C:\\Users\\Praveen\\azure-communication-common-1.1.1-alpha.20211013.7-toPublishDev/package/package.json"
@@ -56,24 +56,24 @@
     "url": "https://github.com/Azure/azure-sdk-for-js/issues"
   },
   "engines": {
-    "node": ">=12.0.0"
+    "node": ">=8.0.0"
   },
-  "homepage": "https://github.com/Azure/azure-sdk-for-js/tree/main/sdk/communication/communication-common/",
+  "homepage": "https://github.com/Azure/azure-sdk-for-js/tree/master/sdk/communication/communication-common/",
   "sideEffects": false,
   "prettier": "@azure/eslint-plugin-azure-sdk/prettier.json",
   "dependencies": {
     "@azure/abort-controller": "^1.0.0",
     "@azure/core-auth": "^1.3.0",
-    "@azure/core-http": "^2.0.0",
-    "@azure/core-tracing": "1.0.0-preview.13",
+    "@azure/core-http": "^1.2.0",
+    "@azure/core-tracing": "1.0.0-preview.11",
     "events": "^3.0.0",
     "jwt-decode": "~2.2.0",
-    "tslib": "^2.2.0"
+    "tslib": "^2.0.0"
   },
   "devDependencies": {
-    "@azure/eslint-plugin-azure-sdk": ">=3.0.0-alpha <3.0.0-alphb",
-    "@azure/dev-tool": ">=1.0.0-alpha <1.0.0-alphb",
-    "@microsoft/api-extractor": "^7.18.11",
+    "@azure/eslint-plugin-azure-sdk": "^3.0.0-alpha",
+    "@azure/dev-tool": "^1.0.0-alpha",
+    "@microsoft/api-extractor": "7.7.11",
     "@rollup/plugin-commonjs": "11.0.2",
     "@rollup/plugin-json": "^4.0.0",
     "@rollup/plugin-multi-entry": "^3.0.0",
@@ -83,7 +83,7 @@
     "@types/chai": "^4.1.6",
     "@types/jwt-decode": "~2.2.1",
     "@types/mocha": "^7.0.2",
-    "@types/node": "^12.0.0",
+    "@types/node": "^8.0.0",
     "@types/sinon": "^9.0.4",
     "assert": "^1.4.1",
     "chai-as-promised": "^7.1.1",
