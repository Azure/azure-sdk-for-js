/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { tracingClient } from "../tracing.js";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers.js";
import * as Parameters from "../models/parameters.js";
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getSparkSessionsOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SparkSessionCollection,
        },
    },
    queryParameters: [Parameters.fromParam, Parameters.size, Parameters.detailed],
    urlParameters: [Parameters.endpoint, Parameters.livyApiVersion, Parameters.sparkPoolName],
    headerParameters: [Parameters.accept],
    serializer,
};
const createSparkSessionOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.SparkSession,
        },
    },
    requestBody: Parameters.sparkSessionOptions,
    queryParameters: [Parameters.detailed],
    urlParameters: [Parameters.endpoint, Parameters.livyApiVersion, Parameters.sparkPoolName],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getSparkSessionOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions/{sessionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SparkSession,
        },
    },
    queryParameters: [Parameters.detailed],
    urlParameters: [
        Parameters.endpoint,
        Parameters.livyApiVersion,
        Parameters.sparkPoolName,
        Parameters.sessionId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const cancelSparkSessionOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions/{sessionId}",
    httpMethod: "DELETE",
    responses: { 200: {} },
    urlParameters: [
        Parameters.endpoint,
        Parameters.livyApiVersion,
        Parameters.sparkPoolName,
        Parameters.sessionId,
    ],
    serializer,
};
const resetSparkSessionTimeoutOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions/{sessionId}/reset-timeout",
    httpMethod: "PUT",
    responses: { 200: {} },
    urlParameters: [
        Parameters.endpoint,
        Parameters.livyApiVersion,
        Parameters.sparkPoolName,
        Parameters.sessionId,
    ],
    serializer,
};
const getSparkStatementsOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions/{sessionId}/statements",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SparkStatementCollection,
        },
    },
    urlParameters: [
        Parameters.endpoint,
        Parameters.livyApiVersion,
        Parameters.sparkPoolName,
        Parameters.sessionId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const createSparkStatementOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions/{sessionId}/statements",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.SparkStatement,
        },
    },
    requestBody: Parameters.sparkStatementOptions,
    urlParameters: [
        Parameters.endpoint,
        Parameters.livyApiVersion,
        Parameters.sparkPoolName,
        Parameters.sessionId,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getSparkStatementOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions/{sessionId}/statements/{statementId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.SparkStatement,
        },
    },
    urlParameters: [
        Parameters.endpoint,
        Parameters.livyApiVersion,
        Parameters.sparkPoolName,
        Parameters.sessionId,
        Parameters.statementId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const cancelSparkStatementOperationSpec = {
    path: "/livyApi/versions/{livyApiVersion}/sparkPools/{sparkPoolName}/sessions/{sessionId}/statements/{statementId}/cancel",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.SparkStatementCancellationResult,
        },
    },
    urlParameters: [
        Parameters.endpoint,
        Parameters.livyApiVersion,
        Parameters.sparkPoolName,
        Parameters.sessionId,
        Parameters.statementId,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
/** Class containing SparkSessionOperations operations. */
export class SparkSessionOperationsImpl {
    /**
     * Initialize a new instance of the class SparkSessionOperations class.
     * @param client - Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all spark sessions which are running under a particular spark pool.
     * @param options - The options parameters.
     */
    async getSparkSessions(options) {
        return tracingClient.withSpan("SparkClient.getSparkSessions", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ updatedOptions }, getSparkSessionsOperationSpec);
        });
    }
    /**
     * Create new spark session.
     * @param sparkSessionOptions - Livy compatible batch job request payload.
     * @param options - The options parameters.
     */
    async createSparkSession(sparkSessionOptions, options) {
        return tracingClient.withSpan("SparkClient.createSparkSession", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ sparkSessionOptions, updatedOptions }, createSparkSessionOperationSpec);
        });
    }
    /**
     * Gets a single spark session.
     * @param sessionId - Identifier for the session.
     * @param options - The options parameters.
     */
    async getSparkSession(sessionId, options) {
        return tracingClient.withSpan("SparkClient.getSparkSession", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ sessionId, updatedOptions }, getSparkSessionOperationSpec);
        });
    }
    /**
     * Cancels a running spark session.
     * @param sessionId - Identifier for the session.
     * @param options - The options parameters.
     */
    async cancelSparkSession(sessionId, options) {
        return tracingClient.withSpan("SparkClient.cancelSparkSession", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ sessionId, updatedOptions }, cancelSparkSessionOperationSpec);
        });
    }
    /**
     * Sends a keep alive call to the current session to reset the session timeout.
     * @param sessionId - Identifier for the session.
     * @param options - The options parameters.
     */
    async resetSparkSessionTimeout(sessionId, options) {
        return tracingClient.withSpan("SparkClient.resetSparkSessionTimeout", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ sessionId, updatedOptions }, resetSparkSessionTimeoutOperationSpec);
        });
    }
    /**
     * Gets a list of statements within a spark session.
     * @param sessionId - Identifier for the session.
     * @param options - The options parameters.
     */
    async getSparkStatements(sessionId, options) {
        return tracingClient.withSpan("SparkClient.getSparkStatements", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ sessionId, updatedOptions }, getSparkStatementsOperationSpec);
        });
    }
    /**
     * Create statement within a spark session.
     * @param sessionId - Identifier for the session.
     * @param sparkStatementOptions - Livy compatible batch job request payload.
     * @param options - The options parameters.
     */
    async createSparkStatement(sessionId, sparkStatementOptions, options) {
        return tracingClient.withSpan("SparkClient.createSparkStatement", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ sessionId, sparkStatementOptions, updatedOptions }, createSparkStatementOperationSpec);
        });
    }
    /**
     * Gets a single statement within a spark session.
     * @param sessionId - Identifier for the session.
     * @param statementId - Identifier for the statement.
     * @param options - The options parameters.
     */
    async getSparkStatement(sessionId, statementId, options) {
        return tracingClient.withSpan("SparkClient.getSparkStatement", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ sessionId, statementId, updatedOptions }, getSparkStatementOperationSpec);
        });
    }
    /**
     * Kill a statement within a session.
     * @param sessionId - Identifier for the session.
     * @param statementId - Identifier for the statement.
     * @param options - The options parameters.
     */
    async cancelSparkStatement(sessionId, statementId, options) {
        return tracingClient.withSpan("SparkClient.cancelSparkStatement", options !== null && options !== void 0 ? options : {}, async (updatedOptions) => {
            return this.client.sendOperationRequest({ sessionId, statementId, updatedOptions }, cancelSparkStatementOperationSpec);
        });
    }
}
//# sourceMappingURL=sparkSessionOperations.js.map