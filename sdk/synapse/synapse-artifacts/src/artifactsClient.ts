/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";
import * as coreRestPipeline from "@azure/core-rest-pipeline";
import * as coreAuth from "@azure/core-auth";
import {
  SimplePollerLike,
  OperationState,
  createHttpPoller
} from "@azure/core-lro";
import { createLroSpec } from "./lroImpl";
import {
  LinkConnectionOperationsImpl,
  RunNotebookImpl,
  KqlScriptsImpl,
  KqlScriptOperationsImpl,
  MetastoreImpl,
  SparkConfigurationOperationsImpl,
  BigDataPoolsImpl,
  DataFlowOperationsImpl,
  DataFlowDebugSessionImpl,
  DatasetOperationsImpl,
  WorkspaceGitRepoManagementImpl,
  IntegrationRuntimesImpl,
  LibraryImpl,
  LinkedServiceOperationsImpl,
  NotebookOperationsImpl,
  NotebookOperationResultImpl,
  PipelineOperationsImpl,
  PipelineRunOperationsImpl,
  SparkJobDefinitionOperationsImpl,
  SqlPoolsImpl,
  SqlScriptOperationsImpl,
  TriggerOperationsImpl,
  TriggerRunOperationsImpl,
  WorkspaceOperationsImpl
} from "./operations";
import {
  LinkConnectionOperations,
  RunNotebook,
  KqlScripts,
  KqlScriptOperations,
  Metastore,
  SparkConfigurationOperations,
  BigDataPools,
  DataFlowOperations,
  DataFlowDebugSession,
  DatasetOperations,
  WorkspaceGitRepoManagement,
  IntegrationRuntimes,
  Library,
  LinkedServiceOperations,
  NotebookOperations,
  NotebookOperationResult,
  PipelineOperations,
  PipelineRunOperations,
  SparkJobDefinitionOperations,
  SqlPools,
  SqlScriptOperations,
  TriggerOperations,
  TriggerRunOperations,
  WorkspaceOperations
} from "./operationsInterfaces";
import { tracingClient } from "./tracing";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
import {
  ArtifactsClientOptionalParams,
  DDLBatch,
  ExecuteChangeOptionalParams,
  ExecuteChangeResponse,
  ExecuteChangeWithValidationOptionalParams,
  ListDatabasesOptionalParams,
  ListDatabasesResponse,
  SASEntityType,
  ListArtifactsOptionalParams,
  ListArtifactsResponse,
  ListArtifactsInSchemaByTypeOptionalParams,
  ListArtifactsInSchemaByTypeResponse,
  ListPartitionInfosForTableOptionalParams,
  ListPartitionInfosForTableResponse,
  ListPartitionInfosForViewOptionalParams,
  ListPartitionInfosForViewResponse,
  ListPartitionInfosForSchemaAndTableOptionalParams,
  ListPartitionInfosForSchemaAndTableResponse,
  ListPartitionInfosForSchemaAndViewOptionalParams,
  ListPartitionInfosForSchemaAndViewResponse,
  GetDatabaseOptionalParams,
  GetDatabaseResponse,
  DatabaseEntity,
  PutDatabaseOptionalParams,
  PutDatabaseResponse,
  DeleteDatabaseOptionalParams,
  GetArtifactFromDBOptionalParams,
  GetArtifactFromDBResponse,
  MDEntity,
  PutArtifactInDBOptionalParams,
  PutArtifactInDBResponse,
  DeleteArtifactForDBOptionalParams,
  GetArtifactFromSchemaOptionalParams,
  GetArtifactFromSchemaResponse,
  PutArtifactInSchemaOptionalParams,
  PutArtifactInSchemaResponse,
  DeleteArtifactFromSchemaOptionalParams,
  GetSyMSOperationStatusOptionalParams,
  GetSyMSOperationStatusResponse
} from "./models";

export class ArtifactsClient extends coreClient.ServiceClient {
  endpoint: string;
  userAgent: string;

  /**
   * Initializes a new instance of the ArtifactsClient class.
   * @param credentials Subscription credentials which uniquely identify client subscription.
   * @param endpoint The workspace development endpoint, for example
   *                 https://myworkspace.dev.azuresynapse.net.
   * @param userAgent User-Agent request header for servers to identify application
   * @param options The parameter options
   */
  constructor(
    credentials: coreAuth.TokenCredential,
    endpoint: string,
    userAgent: string,
    options?: ArtifactsClientOptionalParams
  ) {
    if (credentials === undefined) {
      throw new Error("'credentials' cannot be null");
    }
    if (endpoint === undefined) {
      throw new Error("'endpoint' cannot be null");
    }
    if (userAgent === undefined) {
      throw new Error("'userAgent' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults: ArtifactsClientOptionalParams = {
      requestContentType: "application/json; charset=utf-8",
      credential: credentials
    };

    const packageDetails = `azsdk-js-synapse-artifacts/1.0.0-beta.13`;
    const userAgentPrefix =
      options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
        : `${packageDetails}`;

    if (!options.credentialScopes) {
      options.credentialScopes = ["https://dev.azuresynapse.net/.default"];
    }
    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      endpoint: options.endpoint ?? options.baseUri ?? "{endpoint}"
    };
    super(optionsWithDefaults);

    let bearerTokenAuthenticationPolicyFound: boolean = false;
    if (options?.pipeline && options.pipeline.getOrderedPolicies().length > 0) {
      const pipelinePolicies: coreRestPipeline.PipelinePolicy[] = options.pipeline.getOrderedPolicies();
      bearerTokenAuthenticationPolicyFound = pipelinePolicies.some(
        (pipelinePolicy) =>
          pipelinePolicy.name ===
          coreRestPipeline.bearerTokenAuthenticationPolicyName
      );
    }
    if (
      !options ||
      !options.pipeline ||
      options.pipeline.getOrderedPolicies().length == 0 ||
      !bearerTokenAuthenticationPolicyFound
    ) {
      this.pipeline.removePolicy({
        name: coreRestPipeline.bearerTokenAuthenticationPolicyName
      });
      this.pipeline.addPolicy(
        coreRestPipeline.bearerTokenAuthenticationPolicy({
          credential: credentials,
          scopes:
            optionsWithDefaults.credentialScopes ??
            `${optionsWithDefaults.endpoint}/.default`,
          challengeCallbacks: {
            authorizeRequestOnChallenge:
              coreClient.authorizeRequestOnClaimChallenge
          }
        })
      );
    }
    // Parameter assignments
    this.endpoint = endpoint;
    this.userAgent = userAgent;
    this.linkConnectionOperations = new LinkConnectionOperationsImpl(this);
    this.runNotebook = new RunNotebookImpl(this);
    this.kqlScripts = new KqlScriptsImpl(this);
    this.kqlScriptOperations = new KqlScriptOperationsImpl(this);
    this.metastore = new MetastoreImpl(this);
    this.sparkConfigurationOperations = new SparkConfigurationOperationsImpl(
      this
    );
    this.bigDataPools = new BigDataPoolsImpl(this);
    this.dataFlowOperations = new DataFlowOperationsImpl(this);
    this.dataFlowDebugSession = new DataFlowDebugSessionImpl(this);
    this.datasetOperations = new DatasetOperationsImpl(this);
    this.workspaceGitRepoManagement = new WorkspaceGitRepoManagementImpl(this);
    this.integrationRuntimes = new IntegrationRuntimesImpl(this);
    this.library = new LibraryImpl(this);
    this.linkedServiceOperations = new LinkedServiceOperationsImpl(this);
    this.notebookOperations = new NotebookOperationsImpl(this);
    this.notebookOperationResult = new NotebookOperationResultImpl(this);
    this.pipelineOperations = new PipelineOperationsImpl(this);
    this.pipelineRunOperations = new PipelineRunOperationsImpl(this);
    this.sparkJobDefinitionOperations = new SparkJobDefinitionOperationsImpl(
      this
    );
    this.sqlPools = new SqlPoolsImpl(this);
    this.sqlScriptOperations = new SqlScriptOperationsImpl(this);
    this.triggerOperations = new TriggerOperationsImpl(this);
    this.triggerRunOperations = new TriggerRunOperationsImpl(this);
    this.workspaceOperations = new WorkspaceOperationsImpl(this);
  }

  /**
   * Batch execution of DDL Payload
   * @param createArtifactsPayload DDLBatch payload containing artifact drafts to be created or deleted
   *                               or modified
   * @param options The options parameters.
   */
  async executeChange(
    createArtifactsPayload: DDLBatch,
    options?: ExecuteChangeOptionalParams
  ): Promise<ExecuteChangeResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.executeChange",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { createArtifactsPayload, options },
          executeChangeOperationSpec
        ) as Promise<ExecuteChangeResponse>;
      }
    );
  }

  /**
   * Batch execution of DDL Payload
   * @param validationType Validation Type - Currently only IDWValidation is supported
   * @param createArtifactsPayload DDLBatch containing artifacts to be Created or Deleted or Modified.
   * @param options The options parameters.
   */
  async beginExecuteChangeWithValidation(
    validationType: string,
    createArtifactsPayload: DDLBatch,
    options?: ExecuteChangeWithValidationOptionalParams
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return tracingClient.withSpan(
        "ArtifactsClient.beginExecuteChangeWithValidation",
        options ?? {},
        async () => {
          return this.sendOperationRequest(args, spec) as Promise<void>;
        }
      );
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { validationType, createArtifactsPayload, options },
      spec: executeChangeWithValidationOperationSpec
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Batch execution of DDL Payload
   * @param validationType Validation Type - Currently only IDWValidation is supported
   * @param createArtifactsPayload DDLBatch containing artifacts to be Created or Deleted or Modified.
   * @param options The options parameters.
   */
  async beginExecuteChangeWithValidationAndWait(
    validationType: string,
    createArtifactsPayload: DDLBatch,
    options?: ExecuteChangeWithValidationOptionalParams
  ): Promise<void> {
    const poller = await this.beginExecuteChangeWithValidation(
      validationType,
      createArtifactsPayload,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Get all databases in a workspace
   * @param options The options parameters.
   */
  async listDatabases(
    options?: ListDatabasesOptionalParams
  ): Promise<ListDatabasesResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.listDatabases",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { options },
          listDatabasesOperationSpec
        ) as Promise<ListDatabasesResponse>;
      }
    );
  }

  /**
   * List all Artifacts of a type in a database
   * @param databaseName Database name.
   * @param artifactType Artifact type.
   * @param options The options parameters.
   */
  async listArtifacts(
    databaseName: string,
    artifactType: SASEntityType,
    options?: ListArtifactsOptionalParams
  ): Promise<ListArtifactsResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.listArtifacts",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, artifactType, options },
          listArtifactsOperationSpec
        ) as Promise<ListArtifactsResponse>;
      }
    );
  }

  /**
   * List all Artifacts in schema by type
   * @param databaseName Database name.
   * @param schemaName Schema name.
   * @param artifactType Artifact type.
   * @param options The options parameters.
   */
  async listArtifactsInSchemaByType(
    databaseName: string,
    schemaName: string,
    artifactType: SASEntityType,
    options?: ListArtifactsInSchemaByTypeOptionalParams
  ): Promise<ListArtifactsInSchemaByTypeResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.listArtifactsInSchemaByType",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, schemaName, artifactType, options },
          listArtifactsInSchemaByTypeOperationSpec
        ) as Promise<ListArtifactsInSchemaByTypeResponse>;
      }
    );
  }

  /**
   * List all partition information for a table
   * @param databaseName Database name.
   * @param tableName Table name.
   * @param options The options parameters.
   */
  async listPartitionInfosForTable(
    databaseName: string,
    tableName: string,
    options?: ListPartitionInfosForTableOptionalParams
  ): Promise<ListPartitionInfosForTableResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.listPartitionInfosForTable",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, tableName, options },
          listPartitionInfosForTableOperationSpec
        ) as Promise<ListPartitionInfosForTableResponse>;
      }
    );
  }

  /**
   * List all partition information for a view
   * @param databaseName Database name.
   * @param viewName View name.
   * @param options The options parameters.
   */
  async listPartitionInfosForView(
    databaseName: string,
    viewName: string,
    options?: ListPartitionInfosForViewOptionalParams
  ): Promise<ListPartitionInfosForViewResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.listPartitionInfosForView",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, viewName, options },
          listPartitionInfosForViewOperationSpec
        ) as Promise<ListPartitionInfosForViewResponse>;
      }
    );
  }

  /**
   * List all partition information for a table in schema
   * @param databaseName Database name.
   * @param schemaName Schema name.
   * @param tableName Table name.
   * @param options The options parameters.
   */
  async listPartitionInfosForSchemaAndTable(
    databaseName: string,
    schemaName: string,
    tableName: string,
    options?: ListPartitionInfosForSchemaAndTableOptionalParams
  ): Promise<ListPartitionInfosForSchemaAndTableResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.listPartitionInfosForSchemaAndTable",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, schemaName, tableName, options },
          listPartitionInfosForSchemaAndTableOperationSpec
        ) as Promise<ListPartitionInfosForSchemaAndTableResponse>;
      }
    );
  }

  /**
   * List all partition information for a view in schema
   * @param databaseName Database name.
   * @param schemaName Schema name.
   * @param viewName View name.
   * @param options The options parameters.
   */
  async listPartitionInfosForSchemaAndView(
    databaseName: string,
    schemaName: string,
    viewName: string,
    options?: ListPartitionInfosForSchemaAndViewOptionalParams
  ): Promise<ListPartitionInfosForSchemaAndViewResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.listPartitionInfosForSchemaAndView",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, schemaName, viewName, options },
          listPartitionInfosForSchemaAndViewOperationSpec
        ) as Promise<ListPartitionInfosForSchemaAndViewResponse>;
      }
    );
  }

  /**
   * Get details about a database
   * @param databaseName Database name.
   * @param options The options parameters.
   */
  async getDatabase(
    databaseName: string,
    options?: GetDatabaseOptionalParams
  ): Promise<GetDatabaseResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.getDatabase",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, options },
          getDatabaseOperationSpec
        ) as Promise<GetDatabaseResponse>;
      }
    );
  }

  /**
   * Put a database
   * @param databaseName Database name.
   * @param createArtifactsPayload Database entity payload to create or update a Database
   * @param options The options parameters.
   */
  async putDatabase(
    databaseName: string,
    createArtifactsPayload: DatabaseEntity,
    options?: PutDatabaseOptionalParams
  ): Promise<PutDatabaseResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.putDatabase",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, createArtifactsPayload, options },
          putDatabaseOperationSpec
        ) as Promise<PutDatabaseResponse>;
      }
    );
  }

  /**
   * Delete a database
   * @param databaseName Database name.
   * @param options The options parameters.
   */
  async deleteDatabase(
    databaseName: string,
    options?: DeleteDatabaseOptionalParams
  ): Promise<void> {
    return tracingClient.withSpan(
      "ArtifactsClient.deleteDatabase",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, options },
          deleteDatabaseOperationSpec
        ) as Promise<void>;
      }
    );
  }

  /**
   * Get an artifact from database
   * @param databaseName Database name.
   * @param artifactType Artifact type.
   * @param artifactName Artifact name.
   * @param options The options parameters.
   */
  async getArtifactFromDB(
    databaseName: string,
    artifactType: SASEntityType,
    artifactName: string,
    options?: GetArtifactFromDBOptionalParams
  ): Promise<GetArtifactFromDBResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.getArtifactFromDB",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, artifactType, artifactName, options },
          getArtifactFromDBOperationSpec
        ) as Promise<GetArtifactFromDBResponse>;
      }
    );
  }

  /**
   * Put an artifact in a Database
   * @param databaseName Database name.
   * @param artifactType Artifact type.
   * @param artifactName Artifact name.
   * @param createArtifactsPayload Payload containing artifact entity to be created/modified
   * @param options The options parameters.
   */
  async putArtifactInDB(
    databaseName: string,
    artifactType: SASEntityType,
    artifactName: string,
    createArtifactsPayload: MDEntity,
    options?: PutArtifactInDBOptionalParams
  ): Promise<PutArtifactInDBResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.putArtifactInDB",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          {
            databaseName,
            artifactType,
            artifactName,
            createArtifactsPayload,
            options
          },
          putArtifactInDBOperationSpec
        ) as Promise<PutArtifactInDBResponse>;
      }
    );
  }

  /**
   * Delete an artifact in a Database
   * @param databaseName Database name.
   * @param artifactType Artifact type
   * @param artifactName Artifact name.
   * @param options The options parameters.
   */
  async deleteArtifactForDB(
    databaseName: string,
    artifactType: SASEntityType,
    artifactName: string,
    options?: DeleteArtifactForDBOptionalParams
  ): Promise<void> {
    return tracingClient.withSpan(
      "ArtifactsClient.deleteArtifactForDB",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, artifactType, artifactName, options },
          deleteArtifactForDBOperationSpec
        ) as Promise<void>;
      }
    );
  }

  /**
   * Get an artifact from schema
   * @param databaseName Database name.
   * @param schemaName Schema name.
   * @param artifactType Artifact type.
   * @param artifactName Artifact name.
   * @param options The options parameters.
   */
  async getArtifactFromSchema(
    databaseName: string,
    schemaName: string,
    artifactType: SASEntityType,
    artifactName: string,
    options?: GetArtifactFromSchemaOptionalParams
  ): Promise<GetArtifactFromSchemaResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.getArtifactFromSchema",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, schemaName, artifactType, artifactName, options },
          getArtifactFromSchemaOperationSpec
        ) as Promise<GetArtifactFromSchemaResponse>;
      }
    );
  }

  /**
   * Create or Update an artifact in a schema
   * @param databaseName Database name.
   * @param schemaName Schema name.
   * @param artifactType Artifact type.
   * @param artifactName Artifact name.
   * @param createArtifactsPayload Payload containing artifact object to be create/updated
   * @param options The options parameters.
   */
  async putArtifactInSchema(
    databaseName: string,
    schemaName: string,
    artifactType: SASEntityType,
    artifactName: string,
    createArtifactsPayload: MDEntity,
    options?: PutArtifactInSchemaOptionalParams
  ): Promise<PutArtifactInSchemaResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.putArtifactInSchema",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          {
            databaseName,
            schemaName,
            artifactType,
            artifactName,
            createArtifactsPayload,
            options
          },
          putArtifactInSchemaOperationSpec
        ) as Promise<PutArtifactInSchemaResponse>;
      }
    );
  }

  /**
   * Delete an artifact from Schema
   * @param databaseName Database name.
   * @param schemaName Schema name.
   * @param artifactType Artifact type.
   * @param artifactName Artifact name.
   * @param options The options parameters.
   */
  async deleteArtifactFromSchema(
    databaseName: string,
    schemaName: string,
    artifactType: SASEntityType,
    artifactName: string,
    options?: DeleteArtifactFromSchemaOptionalParams
  ): Promise<void> {
    return tracingClient.withSpan(
      "ArtifactsClient.deleteArtifactFromSchema",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { databaseName, schemaName, artifactType, artifactName, options },
          deleteArtifactFromSchemaOperationSpec
        ) as Promise<void>;
      }
    );
  }

  /**
   * Get the status of validation by operation Id
   * @param operationId Operation Id.
   * @param options The options parameters.
   */
  async getSyMSOperationStatus(
    operationId: string,
    options?: GetSyMSOperationStatusOptionalParams
  ): Promise<GetSyMSOperationStatusResponse> {
    return tracingClient.withSpan(
      "ArtifactsClient.getSyMSOperationStatus",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { operationId, options },
          getSyMSOperationStatusOperationSpec
        ) as Promise<GetSyMSOperationStatusResponse>;
      }
    );
  }

  linkConnectionOperations: LinkConnectionOperations;
  runNotebook: RunNotebook;
  kqlScripts: KqlScripts;
  kqlScriptOperations: KqlScriptOperations;
  metastore: Metastore;
  sparkConfigurationOperations: SparkConfigurationOperations;
  bigDataPools: BigDataPools;
  dataFlowOperations: DataFlowOperations;
  dataFlowDebugSession: DataFlowDebugSession;
  datasetOperations: DatasetOperations;
  workspaceGitRepoManagement: WorkspaceGitRepoManagement;
  integrationRuntimes: IntegrationRuntimes;
  library: Library;
  linkedServiceOperations: LinkedServiceOperations;
  notebookOperations: NotebookOperations;
  notebookOperationResult: NotebookOperationResult;
  pipelineOperations: PipelineOperations;
  pipelineRunOperations: PipelineRunOperations;
  sparkJobDefinitionOperations: SparkJobDefinitionOperations;
  sqlPools: SqlPools;
  sqlScriptOperations: SqlScriptOperations;
  triggerOperations: TriggerOperations;
  triggerRunOperations: TriggerRunOperations;
  workspaceOperations: WorkspaceOperations;
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const executeChangeOperationSpec: coreClient.OperationSpec = {
  path: "/databases/ExecuteChange",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.SyMsapiddlResponses
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  requestBody: Parameters.createArtifactsPayload,
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [Parameters.endpoint],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.userAgent
  ],
  mediaType: "json",
  serializer
};
const executeChangeWithValidationOperationSpec: coreClient.OperationSpec = {
  path: "/databases/ExecuteChangeWithValidation",
  httpMethod: "POST",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  requestBody: Parameters.createArtifactsPayload,
  queryParameters: [Parameters.apiVersion6, Parameters.validationType],
  urlParameters: [Parameters.endpoint],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.userAgent
  ],
  mediaType: "json",
  serializer
};
const listDatabasesOperationSpec: coreClient.OperationSpec = {
  path: "/databases",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueryArtifactsResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [
    Parameters.apiVersion6,
    Parameters.continuationToken,
    Parameters.maxPageSize
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const listArtifactsOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}/{artifactType}s",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueryArtifactsResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [
    Parameters.apiVersion6,
    Parameters.continuationToken,
    Parameters.maxPageSize
  ],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.artifactType
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const listArtifactsInSchemaByTypeOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}/schemas/{schemaName}/{artifactType}s",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueryArtifactsResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [
    Parameters.apiVersion6,
    Parameters.continuationToken,
    Parameters.maxPageSize
  ],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.artifactType,
    Parameters.schemaName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const listPartitionInfosForTableOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}/tables/{tableName}/partitionInfos",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueryArtifactsResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [
    Parameters.apiVersion6,
    Parameters.continuationToken,
    Parameters.maxPageSize
  ],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.tableName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const listPartitionInfosForViewOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}/views/{viewName}/partitionInfos",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueryArtifactsResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [
    Parameters.apiVersion6,
    Parameters.continuationToken,
    Parameters.maxPageSize
  ],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.viewName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const listPartitionInfosForSchemaAndTableOperationSpec: coreClient.OperationSpec = {
  path:
    "/databases/{databaseName}/schemas/{schemaName}/tables/{tableName}/partitionInfos",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueryArtifactsResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [
    Parameters.apiVersion6,
    Parameters.continuationToken,
    Parameters.maxPageSize
  ],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.schemaName,
    Parameters.tableName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const listPartitionInfosForSchemaAndViewOperationSpec: coreClient.OperationSpec = {
  path:
    "/databases/{databaseName}/schemas/{schemaName}/views/{viewName}/partitionInfos",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueryArtifactsResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [
    Parameters.apiVersion6,
    Parameters.continuationToken,
    Parameters.maxPageSize
  ],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.schemaName,
    Parameters.viewName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const getDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DatabaseEntity
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [Parameters.endpoint, Parameters.databaseName],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const putDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SyMsapiddlResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  requestBody: Parameters.createArtifactsPayload1,
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [Parameters.endpoint, Parameters.databaseName],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.userAgent
  ],
  mediaType: "json",
  serializer
};
const deleteDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [Parameters.endpoint, Parameters.databaseName],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const getArtifactFromDBOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}/{artifactType}s/{artifactName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MDEntity
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.artifactType,
    Parameters.artifactName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const putArtifactInDBOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}/{artifactType}s/{artifactName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SyMsapiddlResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  requestBody: Parameters.createArtifactsPayload2,
  queryParameters: [
    Parameters.apiVersion6,
    Parameters.continuationToken,
    Parameters.maxPageSize
  ],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.artifactType,
    Parameters.artifactName
  ],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.userAgent
  ],
  mediaType: "json",
  serializer
};
const deleteArtifactForDBOperationSpec: coreClient.OperationSpec = {
  path: "/databases/{databaseName}/{artifactType}s/{artifactName}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.artifactType,
    Parameters.artifactName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const getArtifactFromSchemaOperationSpec: coreClient.OperationSpec = {
  path:
    "/databases/{databaseName}/schemas/{schemaName}/{artifactType}s/{artifactName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MDEntity
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.artifactType,
    Parameters.schemaName,
    Parameters.artifactName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const putArtifactInSchemaOperationSpec: coreClient.OperationSpec = {
  path:
    "/databases/{databaseName}/schemas/{schemaName}/{artifactType}s/{artifactName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SyMsapiddlResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  requestBody: Parameters.createArtifactsPayload2,
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.artifactType,
    Parameters.schemaName,
    Parameters.artifactName
  ],
  headerParameters: [
    Parameters.accept,
    Parameters.contentType,
    Parameters.userAgent
  ],
  mediaType: "json",
  serializer
};
const deleteArtifactFromSchemaOperationSpec: coreClient.OperationSpec = {
  path:
    "/databases/{databaseName}/schemas/{schemaName}/{artifactType}s/{artifactName}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [
    Parameters.endpoint,
    Parameters.databaseName,
    Parameters.artifactType,
    Parameters.schemaName,
    Parameters.artifactName
  ],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
const getSyMSOperationStatusOperationSpec: coreClient.OperationSpec = {
  path: "/databases/operations/{operationId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueryArtifactsResponse
    },
    default: {
      bodyMapper: Mappers.CloudErrorAutoGenerated
    }
  },
  queryParameters: [Parameters.apiVersion6],
  urlParameters: [Parameters.endpoint, Parameters.operationId],
  headerParameters: [Parameters.accept, Parameters.userAgent],
  serializer
};
