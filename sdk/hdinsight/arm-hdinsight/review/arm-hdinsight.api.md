## API Report File for "@azure/arm-hdinsight"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export interface AaddsResourceDetails {
    domainName?: string;
    initialSyncComplete?: boolean;
    ldapsEnabled?: boolean;
    ldapsPublicCertificateInBase64?: string;
    resourceId?: string;
    subnetId?: string;
    tenantId?: string;
}

// @public
export type Application = ProxyResource & {
    etag?: string;
    tags?: {
        [propertyName: string]: string;
    };
    properties?: ApplicationProperties;
    readonly systemData?: SystemData;
};

// @public
export interface ApplicationGetEndpoint {
    destinationPort?: number;
    location?: string;
    privateIPAddress?: string;
    publicPort?: number;
}

// @public
export interface ApplicationGetHttpsEndpoint {
    accessModes?: string[];
    destinationPort?: number;
    disableGatewayAuth?: boolean;
    readonly location?: string;
    privateIPAddress?: string;
    readonly publicPort?: number;
    subDomainSuffix?: string;
}

// @public
export interface ApplicationListResult {
    readonly nextLink?: string;
    value?: Application[];
}

// @public
export interface ApplicationProperties {
    readonly applicationState?: string;
    applicationType?: string;
    computeProfile?: ComputeProfile;
    readonly createdDate?: string;
    errors?: Errors[];
    httpsEndpoints?: ApplicationGetHttpsEndpoint[];
    installScriptActions?: RuntimeScriptAction[];
    readonly marketplaceIdentifier?: string;
    privateLinkConfigurations?: PrivateLinkConfiguration[];
    readonly provisioningState?: string;
    sshEndpoints?: ApplicationGetEndpoint[];
    uninstallScriptActions?: RuntimeScriptAction[];
}

// @public
export interface Applications {
    beginCreate(resourceGroupName: string, clusterName: string, applicationName: string, parameters: Application, options?: ApplicationsCreateOptionalParams): Promise<PollerLike<PollOperationState<ApplicationsCreateResponse>, ApplicationsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, clusterName: string, applicationName: string, parameters: Application, options?: ApplicationsCreateOptionalParams): Promise<ApplicationsCreateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsGetOptionalParams): Promise<ApplicationsGetResponse>;
    getAzureAsyncOperationStatus(resourceGroupName: string, clusterName: string, applicationName: string, operationId: string, options?: ApplicationsGetAzureAsyncOperationStatusOptionalParams): Promise<ApplicationsGetAzureAsyncOperationStatusResponse>;
    listByCluster(resourceGroupName: string, clusterName: string, options?: ApplicationsListByClusterOptionalParams): PagedAsyncIterableIterator<Application>;
}

// @public
export interface ApplicationsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ApplicationsCreateResponse = Application;

// @public
export interface ApplicationsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationsGetAzureAsyncOperationStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationsGetAzureAsyncOperationStatusResponse = AsyncOperationResult;

// @public
export interface ApplicationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationsGetResponse = Application;

// @public
export interface ApplicationsListByClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationsListByClusterNextResponse = ApplicationListResult;

// @public
export interface ApplicationsListByClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationsListByClusterResponse = ApplicationListResult;

// @public
export interface AsyncOperationResult {
    error?: Errors;
    status?: AsyncOperationState;
}

// @public
export type AsyncOperationState = string;

// @public
export interface Autoscale {
    capacity?: AutoscaleCapacity;
    recurrence?: AutoscaleRecurrence;
}

// @public
export interface AutoscaleCapacity {
    maxInstanceCount?: number;
    minInstanceCount?: number;
}

// @public
export interface AutoscaleConfigurationUpdateParameter {
    autoscale?: Autoscale;
}

// @public
export interface AutoscaleRecurrence {
    schedule?: AutoscaleSchedule[];
    timeZone?: string;
}

// @public
export interface AutoscaleSchedule {
    days?: DaysOfWeek[];
    timeAndCapacity?: AutoscaleTimeAndCapacity;
}

// @public
export interface AutoscaleTimeAndCapacity {
    maxInstanceCount?: number;
    minInstanceCount?: number;
    time?: string;
}

// @public
export interface AzureMonitorRequest {
    primaryKey?: string;
    selectedConfigurations?: AzureMonitorSelectedConfigurations;
    workspaceId?: string;
}

// @public
export interface AzureMonitorResponse {
    clusterMonitoringEnabled?: boolean;
    selectedConfigurations?: AzureMonitorSelectedConfigurations;
    workspaceId?: string;
}

// @public
export interface AzureMonitorSelectedConfigurations {
    configurationVersion?: string;
    globalConfigurations?: {
        [propertyName: string]: string;
    };
    tableList?: AzureMonitorTableConfiguration[];
}

// @public
export interface AzureMonitorTableConfiguration {
    name?: string;
}

// @public
export interface BillingMeters {
    meter?: string;
    meterParameter?: string;
    unit?: string;
}

// @public
export interface BillingResources {
    billingMeters?: BillingMeters[];
    diskBillingMeters?: DiskBillingMeters[];
    region?: string;
}

// @public
export interface BillingResponseListResult {
    billingResources?: BillingResources[];
    vmSizeFilters?: VmSizeCompatibilityFilterV2[];
    readonly vmSizeProperties?: VmSizeProperty[];
    vmSizes?: string[];
    vmSizesWithEncryptionAtHost?: string[];
}

// @public
export interface CapabilitiesResult {
    features?: string[];
    readonly quota?: QuotaCapability;
    regions?: {
        [propertyName: string]: RegionsCapability;
    };
    versions?: {
        [propertyName: string]: VersionsCapability;
    };
}

// @public
export interface ClientGroupInfo {
    groupId?: string;
    groupName?: string;
}

// @public
export type Cluster = TrackedResource & {
    etag?: string;
    zones?: string[];
    properties?: ClusterGetProperties;
    identity?: ClusterIdentity;
    readonly systemData?: SystemData;
};

// @public
export interface ClusterConfigurations {
    configurations?: {
        [propertyName: string]: {
            [propertyName: string]: string;
        };
    };
}

// @public
export interface ClusterCreateParametersExtended {
    identity?: ClusterIdentity;
    location?: string;
    properties?: ClusterCreateProperties;
    tags?: {
        [propertyName: string]: string;
    };
    zones?: string[];
}

// @public
export interface ClusterCreateProperties {
    clusterDefinition?: ClusterDefinition;
    clusterVersion?: string;
    computeIsolationProperties?: ComputeIsolationProperties;
    computeProfile?: ComputeProfile;
    diskEncryptionProperties?: DiskEncryptionProperties;
    encryptionInTransitProperties?: EncryptionInTransitProperties;
    kafkaRestProperties?: KafkaRestProperties;
    minSupportedTlsVersion?: string;
    networkProperties?: NetworkProperties;
    osType?: OSType;
    privateLinkConfigurations?: PrivateLinkConfiguration[];
    securityProfile?: SecurityProfile;
    storageProfile?: StorageProfile;
    tier?: Tier;
}

// @public
export type ClusterCreateRequestValidationParameters = ClusterCreateParametersExtended & {
    name?: string;
    type?: string;
    tenantId?: string;
    fetchAaddsResource?: boolean;
};

// @public
export interface ClusterCreateValidationResult {
    aaddsResourcesDetails?: AaddsResourceDetails[];
    estimatedCreationDuration?: string;
    validationErrors?: ValidationErrorInfo[];
    validationWarnings?: ValidationErrorInfo[];
}

// @public
export interface ClusterDefinition {
    blueprint?: string;
    componentVersion?: {
        [propertyName: string]: string;
    };
    configurations?: Record<string, unknown>;
    kind?: string;
}

// @public
export interface ClusterDiskEncryptionParameters {
    keyName?: string;
    keyVersion?: string;
    vaultUri?: string;
}

// @public
export interface ClusterGetProperties {
    clusterDefinition: ClusterDefinition;
    clusterHdpVersion?: string;
    clusterId?: string;
    clusterState?: string;
    clusterVersion?: string;
    computeIsolationProperties?: ComputeIsolationProperties;
    computeProfile?: ComputeProfile;
    connectivityEndpoints?: ConnectivityEndpoint[];
    createdDate?: string;
    diskEncryptionProperties?: DiskEncryptionProperties;
    encryptionInTransitProperties?: EncryptionInTransitProperties;
    errors?: Errors[];
    excludedServicesConfig?: ExcludedServicesConfig;
    kafkaRestProperties?: KafkaRestProperties;
    minSupportedTlsVersion?: string;
    networkProperties?: NetworkProperties;
    osType?: OSType;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    privateLinkConfigurations?: PrivateLinkConfiguration[];
    provisioningState?: HDInsightClusterProvisioningState;
    quotaInfo?: QuotaInfo;
    securityProfile?: SecurityProfile;
    storageProfile?: StorageProfile;
    tier?: Tier;
}

// @public
export interface ClusterIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ResourceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentity;
    };
}

// @public
export interface ClusterListPersistedScriptActionsResult {
    readonly nextLink?: string;
    value?: RuntimeScriptAction[];
}

// @public
export interface ClusterListResult {
    readonly nextLink?: string;
    value?: Cluster[];
}

// @public
export interface ClusterMonitoringRequest {
    primaryKey?: string;
    workspaceId?: string;
}

// @public
export interface ClusterMonitoringResponse {
    clusterMonitoringEnabled?: boolean;
    workspaceId?: string;
}

// @public
export interface ClusterPatchParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface ClusterResizeParameters {
    targetInstanceCount?: number;
}

// @public
export interface Clusters {
    beginCreate(resourceGroupName: string, clusterName: string, parameters: ClusterCreateParametersExtended, options?: ClustersCreateOptionalParams): Promise<PollerLike<PollOperationState<ClustersCreateResponse>, ClustersCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, clusterName: string, parameters: ClusterCreateParametersExtended, options?: ClustersCreateOptionalParams): Promise<ClustersCreateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, options?: ClustersDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, options?: ClustersDeleteOptionalParams): Promise<void>;
    beginExecuteScriptActions(resourceGroupName: string, clusterName: string, parameters: ExecuteScriptActionParameters, options?: ClustersExecuteScriptActionsOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginExecuteScriptActionsAndWait(resourceGroupName: string, clusterName: string, parameters: ExecuteScriptActionParameters, options?: ClustersExecuteScriptActionsOptionalParams): Promise<void>;
    beginResize(resourceGroupName: string, clusterName: string, roleName: RoleName, parameters: ClusterResizeParameters, options?: ClustersResizeOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginResizeAndWait(resourceGroupName: string, clusterName: string, roleName: RoleName, parameters: ClusterResizeParameters, options?: ClustersResizeOptionalParams): Promise<void>;
    beginRotateDiskEncryptionKey(resourceGroupName: string, clusterName: string, parameters: ClusterDiskEncryptionParameters, options?: ClustersRotateDiskEncryptionKeyOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginRotateDiskEncryptionKeyAndWait(resourceGroupName: string, clusterName: string, parameters: ClusterDiskEncryptionParameters, options?: ClustersRotateDiskEncryptionKeyOptionalParams): Promise<void>;
    beginUpdateAutoScaleConfiguration(resourceGroupName: string, clusterName: string, roleName: RoleName, parameters: AutoscaleConfigurationUpdateParameter, options?: ClustersUpdateAutoScaleConfigurationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginUpdateAutoScaleConfigurationAndWait(resourceGroupName: string, clusterName: string, roleName: RoleName, parameters: AutoscaleConfigurationUpdateParameter, options?: ClustersUpdateAutoScaleConfigurationOptionalParams): Promise<void>;
    beginUpdateGatewaySettings(resourceGroupName: string, clusterName: string, parameters: UpdateGatewaySettingsParameters, options?: ClustersUpdateGatewaySettingsOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginUpdateGatewaySettingsAndWait(resourceGroupName: string, clusterName: string, parameters: UpdateGatewaySettingsParameters, options?: ClustersUpdateGatewaySettingsOptionalParams): Promise<void>;
    beginUpdateIdentityCertificate(resourceGroupName: string, clusterName: string, parameters: UpdateClusterIdentityCertificateParameters, options?: ClustersUpdateIdentityCertificateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginUpdateIdentityCertificateAndWait(resourceGroupName: string, clusterName: string, parameters: UpdateClusterIdentityCertificateParameters, options?: ClustersUpdateIdentityCertificateOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, options?: ClustersGetOptionalParams): Promise<ClustersGetResponse>;
    getAzureAsyncOperationStatus(resourceGroupName: string, clusterName: string, operationId: string, options?: ClustersGetAzureAsyncOperationStatusOptionalParams): Promise<ClustersGetAzureAsyncOperationStatusResponse>;
    getGatewaySettings(resourceGroupName: string, clusterName: string, options?: ClustersGetGatewaySettingsOptionalParams): Promise<ClustersGetGatewaySettingsResponse>;
    list(options?: ClustersListOptionalParams): PagedAsyncIterableIterator<Cluster>;
    listByResourceGroup(resourceGroupName: string, options?: ClustersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Cluster>;
    update(resourceGroupName: string, clusterName: string, parameters: ClusterPatchParameters, options?: ClustersUpdateOptionalParams): Promise<ClustersUpdateResponse>;
}

// @public
export interface ClustersCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersCreateResponse = Cluster;

// @public
export interface ClustersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ClustersExecuteScriptActionsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ClustersGetAzureAsyncOperationStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersGetAzureAsyncOperationStatusResponse = AsyncOperationResult;

// @public
export interface ClustersGetGatewaySettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersGetGatewaySettingsResponse = GatewaySettings;

// @public
export interface ClustersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersGetResponse = Cluster;

// @public
export interface ClustersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListByResourceGroupNextResponse = ClusterListResult;

// @public
export interface ClustersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListByResourceGroupResponse = ClusterListResult;

// @public
export interface ClustersListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListNextResponse = ClusterListResult;

// @public
export interface ClustersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListResponse = ClusterListResult;

// @public
export interface ClustersResizeOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ClustersRotateDiskEncryptionKeyOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ClustersUpdateAutoScaleConfigurationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ClustersUpdateGatewaySettingsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ClustersUpdateIdentityCertificateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ClustersUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersUpdateResponse = Cluster;

// @public
export interface ComputeIsolationProperties {
    enableComputeIsolation?: boolean;
    hostSku?: string;
}

// @public
export interface ComputeProfile {
    roles?: Role[];
}

// @public
export interface Configurations {
    beginUpdate(resourceGroupName: string, clusterName: string, configurationName: string, parameters: {
        [propertyName: string]: string;
    }, options?: ConfigurationsUpdateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginUpdateAndWait(resourceGroupName: string, clusterName: string, configurationName: string, parameters: {
        [propertyName: string]: string;
    }, options?: ConfigurationsUpdateOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, configurationName: string, options?: ConfigurationsGetOptionalParams): Promise<ConfigurationsGetResponse>;
    list(resourceGroupName: string, clusterName: string, options?: ConfigurationsListOptionalParams): Promise<ConfigurationsListResponse>;
}

// @public
export interface ConfigurationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConfigurationsGetResponse = {
    [propertyName: string]: string;
};

// @public
export interface ConfigurationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConfigurationsListResponse = ClusterConfigurations;

// @public
export interface ConfigurationsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ConnectivityEndpoint {
    location?: string;
    name?: string;
    port?: number;
    privateIPAddress?: string;
    protocol?: string;
}

// @public
export type CreatedByType = string;

// @public
export interface DataDisksGroups {
    readonly diskSizeGB?: number;
    disksPerNode?: number;
    readonly storageAccountType?: string;
}

// @public
export type DaysOfWeek = string;

// @public
export interface Dimension {
    displayName?: string;
    internalName?: string;
    name?: string;
    toBeExportedForShoebox?: boolean;
}

// @public
export type DirectoryType = string;

// @public
export interface DiskBillingMeters {
    diskRpMeter?: string;
    sku?: string;
    tier?: Tier;
}

// @public
export interface DiskEncryptionProperties {
    encryptionAlgorithm?: JsonWebKeyEncryptionAlgorithm;
    encryptionAtHost?: boolean;
    keyName?: string;
    keyVersion?: string;
    msiResourceId?: string;
    vaultUri?: string;
}

// @public
export interface EncryptionInTransitProperties {
    isEncryptionInTransitEnabled?: boolean;
}

// @public
export interface ErrorResponse {
    code?: string;
    message?: string;
}

// @public
export interface Errors {
    code?: string;
    message?: string;
}

// @public
export interface ExcludedServicesConfig {
    excludedServicesConfigId?: string;
    excludedServicesList?: string;
}

// @public
export interface ExecuteScriptActionParameters {
    persistOnSuccess: boolean;
    scriptActions?: RuntimeScriptAction[];
}

// @public
export interface Extension {
    primaryKey?: string;
    workspaceId?: string;
}

// @public
export interface Extensions {
    beginCreate(resourceGroupName: string, clusterName: string, extensionName: string, parameters: Extension, options?: ExtensionsCreateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginCreateAndWait(resourceGroupName: string, clusterName: string, extensionName: string, parameters: Extension, options?: ExtensionsCreateOptionalParams): Promise<void>;
    beginDelete(resourceGroupName: string, clusterName: string, extensionName: string, options?: ExtensionsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, extensionName: string, options?: ExtensionsDeleteOptionalParams): Promise<void>;
    beginDisableAzureMonitor(resourceGroupName: string, clusterName: string, options?: ExtensionsDisableAzureMonitorOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDisableAzureMonitorAndWait(resourceGroupName: string, clusterName: string, options?: ExtensionsDisableAzureMonitorOptionalParams): Promise<void>;
    beginDisableMonitoring(resourceGroupName: string, clusterName: string, options?: ExtensionsDisableMonitoringOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDisableMonitoringAndWait(resourceGroupName: string, clusterName: string, options?: ExtensionsDisableMonitoringOptionalParams): Promise<void>;
    beginEnableAzureMonitor(resourceGroupName: string, clusterName: string, parameters: AzureMonitorRequest, options?: ExtensionsEnableAzureMonitorOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginEnableAzureMonitorAndWait(resourceGroupName: string, clusterName: string, parameters: AzureMonitorRequest, options?: ExtensionsEnableAzureMonitorOptionalParams): Promise<void>;
    beginEnableMonitoring(resourceGroupName: string, clusterName: string, parameters: ClusterMonitoringRequest, options?: ExtensionsEnableMonitoringOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginEnableMonitoringAndWait(resourceGroupName: string, clusterName: string, parameters: ClusterMonitoringRequest, options?: ExtensionsEnableMonitoringOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, extensionName: string, options?: ExtensionsGetOptionalParams): Promise<ExtensionsGetResponse>;
    getAzureAsyncOperationStatus(resourceGroupName: string, clusterName: string, extensionName: string, operationId: string, options?: ExtensionsGetAzureAsyncOperationStatusOptionalParams): Promise<ExtensionsGetAzureAsyncOperationStatusResponse>;
    getAzureMonitorStatus(resourceGroupName: string, clusterName: string, options?: ExtensionsGetAzureMonitorStatusOptionalParams): Promise<ExtensionsGetAzureMonitorStatusResponse>;
    getMonitoringStatus(resourceGroupName: string, clusterName: string, options?: ExtensionsGetMonitoringStatusOptionalParams): Promise<ExtensionsGetMonitoringStatusResponse>;
}

// @public
export interface ExtensionsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ExtensionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ExtensionsDisableAzureMonitorOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ExtensionsDisableMonitoringOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ExtensionsEnableAzureMonitorOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ExtensionsEnableMonitoringOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ExtensionsGetAzureAsyncOperationStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ExtensionsGetAzureAsyncOperationStatusResponse = AsyncOperationResult;

// @public
export interface ExtensionsGetAzureMonitorStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ExtensionsGetAzureMonitorStatusResponse = AzureMonitorResponse;

// @public
export interface ExtensionsGetMonitoringStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ExtensionsGetMonitoringStatusResponse = ClusterMonitoringResponse;

// @public
export interface ExtensionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ExtensionsGetResponse = ClusterMonitoringResponse;

// @public
export type FilterMode = string;

// @public
export interface GatewaySettings {
    readonly isCredentialEnabled?: string;
    readonly password?: string;
    readonly userName?: string;
}

// @public
export interface HardwareProfile {
    vmSize?: string;
}

// @public
export type HDInsightClusterProvisioningState = string;

// @public (undocumented)
export class HDInsightManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: HDInsightManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    applications: Applications;
    // (undocumented)
    clusters: Clusters;
    // (undocumented)
    configurations: Configurations;
    // (undocumented)
    extensions: Extensions;
    // (undocumented)
    locations: Locations;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    scriptActions: ScriptActions;
    // (undocumented)
    scriptExecutionHistory: ScriptExecutionHistory;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    virtualMachines: VirtualMachines;
}

// @public
export interface HDInsightManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface HostInfo {
    effectiveDiskEncryptionKeyUrl?: string;
    fqdn?: string;
    name?: string;
}

// @public
export interface IPConfiguration {
    readonly id?: string;
    name: string;
    primary?: boolean;
    privateIPAddress?: string;
    privateIPAllocationMethod?: PrivateIPAllocationMethod;
    readonly provisioningState?: PrivateLinkConfigurationProvisioningState;
    subnet?: ResourceId;
    readonly type?: string;
}

// @public
export type JsonWebKeyEncryptionAlgorithm = string;

// @public
export interface KafkaRestProperties {
    clientGroupInfo?: ClientGroupInfo;
    configurationOverride?: {
        [propertyName: string]: string;
    };
}

// @public
export enum KnownAsyncOperationState {
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export enum KnownCreatedByType {
    // (undocumented)
    Application = "Application",
    // (undocumented)
    Key = "Key",
    // (undocumented)
    ManagedIdentity = "ManagedIdentity",
    // (undocumented)
    User = "User"
}

// @public
export enum KnownDaysOfWeek {
    // (undocumented)
    Friday = "Friday",
    // (undocumented)
    Monday = "Monday",
    // (undocumented)
    Saturday = "Saturday",
    // (undocumented)
    Sunday = "Sunday",
    // (undocumented)
    Thursday = "Thursday",
    // (undocumented)
    Tuesday = "Tuesday",
    // (undocumented)
    Wednesday = "Wednesday"
}

// @public
export enum KnownDirectoryType {
    // (undocumented)
    ActiveDirectory = "ActiveDirectory"
}

// @public
export enum KnownFilterMode {
    // (undocumented)
    Default = "Default",
    // (undocumented)
    Exclude = "Exclude",
    // (undocumented)
    Include = "Include",
    // (undocumented)
    Recommend = "Recommend"
}

// @public
export enum KnownHDInsightClusterProvisioningState {
    // (undocumented)
    Canceled = "Canceled",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export enum KnownJsonWebKeyEncryptionAlgorithm {
    // (undocumented)
    RSA15 = "RSA1_5",
    // (undocumented)
    RSAOaep = "RSA-OAEP",
    // (undocumented)
    RSAOaep256 = "RSA-OAEP-256"
}

// @public
export enum KnownOSType {
    // (undocumented)
    Linux = "Linux",
    // (undocumented)
    Windows = "Windows"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    // (undocumented)
    Canceled = "Canceled",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Succeeded = "Succeeded",
    // (undocumented)
    Updating = "Updating"
}

// @public
export enum KnownPrivateIPAllocationMethod {
    // (undocumented)
    Dynamic = "dynamic",
    // (undocumented)
    Static = "static"
}

// @public
export enum KnownPrivateLink {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export enum KnownPrivateLinkConfigurationProvisioningState {
    // (undocumented)
    Canceled = "Canceled",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export enum KnownPrivateLinkServiceConnectionStatus {
    // (undocumented)
    Approved = "Approved",
    // (undocumented)
    Pending = "Pending",
    // (undocumented)
    Rejected = "Rejected",
    // (undocumented)
    Removed = "Removed"
}

// @public
export enum KnownResourceIdentityType {
    // (undocumented)
    None = "None",
    // (undocumented)
    SystemAssigned = "SystemAssigned",
    // (undocumented)
    SystemAssignedUserAssigned = "SystemAssigned, UserAssigned",
    // (undocumented)
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownResourceProviderConnection {
    // (undocumented)
    Inbound = "Inbound",
    // (undocumented)
    Outbound = "Outbound"
}

// @public
export enum KnownRoleName {
    // (undocumented)
    Workernode = "workernode"
}

// @public
export enum KnownTier {
    // (undocumented)
    Premium = "Premium",
    // (undocumented)
    Standard = "Standard"
}

// @public
export interface LinuxOperatingSystemProfile {
    password?: string;
    sshProfile?: SshProfile;
    username?: string;
}

// @public
export interface LocalizedName {
    localizedValue?: string;
    value?: string;
}

// @public
export interface Locations {
    checkNameAvailability(location: string, parameters: NameAvailabilityCheckRequestParameters, options?: LocationsCheckNameAvailabilityOptionalParams): Promise<LocationsCheckNameAvailabilityResponse>;
    getAzureAsyncOperationStatus(location: string, operationId: string, options?: LocationsGetAzureAsyncOperationStatusOptionalParams): Promise<LocationsGetAzureAsyncOperationStatusResponse>;
    getCapabilities(location: string, options?: LocationsGetCapabilitiesOptionalParams): Promise<LocationsGetCapabilitiesResponse>;
    listBillingSpecs(location: string, options?: LocationsListBillingSpecsOptionalParams): Promise<LocationsListBillingSpecsResponse>;
    listUsages(location: string, options?: LocationsListUsagesOptionalParams): Promise<LocationsListUsagesResponse>;
    validateClusterCreateRequest(location: string, parameters: ClusterCreateRequestValidationParameters, options?: LocationsValidateClusterCreateRequestOptionalParams): Promise<LocationsValidateClusterCreateRequestResponse>;
}

// @public
export interface LocationsCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationsCheckNameAvailabilityResponse = NameAvailabilityCheckResult;

// @public
export interface LocationsGetAzureAsyncOperationStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationsGetAzureAsyncOperationStatusResponse = AsyncOperationResult;

// @public
export interface LocationsGetCapabilitiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationsGetCapabilitiesResponse = CapabilitiesResult;

// @public
export interface LocationsListBillingSpecsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationsListBillingSpecsResponse = BillingResponseListResult;

// @public
export interface LocationsListUsagesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationsListUsagesResponse = UsagesListResult;

// @public
export interface LocationsValidateClusterCreateRequestOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationsValidateClusterCreateRequestResponse = ClusterCreateValidationResult;

// @public
export interface MetricSpecifications {
    aggregationType?: string;
    category?: string;
    delegateMetricNameOverride?: string;
    dimensions?: Dimension[];
    displayDescription?: string;
    displayName?: string;
    enableRegionalMdmAccount?: boolean;
    fillGapWithZero?: boolean;
    isInternal?: boolean;
    metricFilterPattern?: string;
    name?: string;
    resourceIdDimensionNameOverride?: string;
    sourceMdmAccount?: string;
    sourceMdmNamespace?: string;
    supportedAggregationTypes?: string[];
    supportedTimeGrainTypes?: string[];
    unit?: string;
}

// @public
export interface NameAvailabilityCheckRequestParameters {
    name?: string;
    type?: string;
}

// @public
export interface NameAvailabilityCheckResult {
    readonly message?: string;
    nameAvailable?: boolean;
    readonly reason?: string;
}

// @public
export interface NetworkProperties {
    privateLink?: PrivateLink;
    resourceProviderConnection?: ResourceProviderConnection;
}

// @public
export interface Operation {
    display?: OperationDisplay;
    name?: string;
    properties?: OperationProperties;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationListResult {
    nextLink?: string;
    value?: Operation[];
}

// @public
export interface OperationProperties {
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = OperationListResult;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface OsProfile {
    linuxOperatingSystemProfile?: LinuxOperatingSystemProfile;
}

// @public
export type OSType = string;

// @public
export interface PrivateEndpoint {
    id?: string;
}

// @public
export type PrivateEndpointConnection = Resource & {
    readonly systemData?: SystemData;
    readonly privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState: PrivateLinkServiceConnectionState;
    readonly linkIdentifier?: string;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
};

// @public
export interface PrivateEndpointConnectionListResult {
    readonly nextLink?: string;
    value?: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export interface PrivateEndpointConnections {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<PrivateEndpointConnectionsCreateOrUpdateResponse>, PrivateEndpointConnectionsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionsCreateOrUpdateOptionalParams): Promise<PrivateEndpointConnectionsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams): Promise<PrivateEndpointConnectionsGetResponse>;
    listByCluster(resourceGroupName: string, clusterName: string, options?: PrivateEndpointConnectionsListByClusterOptionalParams): PagedAsyncIterableIterator<PrivateEndpointConnection>;
}

// @public
export interface PrivateEndpointConnectionsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PrivateEndpointConnectionsCreateOrUpdateResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsListByClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListByClusterNextResponse = PrivateEndpointConnectionListResult;

// @public
export interface PrivateEndpointConnectionsListByClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListByClusterResponse = PrivateEndpointConnectionListResult;

// @public
export type PrivateIPAllocationMethod = string;

// @public
export type PrivateLink = string;

// @public
export interface PrivateLinkConfiguration {
    groupId: string;
    readonly id?: string;
    ipConfigurations: IPConfiguration[];
    name: string;
    readonly provisioningState?: PrivateLinkConfigurationProvisioningState;
    readonly type?: string;
}

// @public
export type PrivateLinkConfigurationProvisioningState = string;

// @public
export type PrivateLinkResource = ResourceAutoGenerated & {
    readonly systemData?: SystemData;
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
};

// @public
export interface PrivateLinkResourceListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkResources {
    get(resourceGroupName: string, clusterName: string, privateLinkResourceName: string, options?: PrivateLinkResourcesGetOptionalParams): Promise<PrivateLinkResourcesGetResponse>;
    listByCluster(resourceGroupName: string, clusterName: string, options?: PrivateLinkResourcesListByClusterOptionalParams): Promise<PrivateLinkResourcesListByClusterResponse>;
}

// @public
export interface PrivateLinkResourcesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesGetResponse = PrivateLinkResource;

// @public
export interface PrivateLinkResourcesListByClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesListByClusterResponse = PrivateLinkResourceListResult;

// @public
export interface PrivateLinkServiceConnectionState {
    actionsRequired?: string;
    description?: string;
    status: PrivateLinkServiceConnectionStatus;
}

// @public
export type PrivateLinkServiceConnectionStatus = string;

// @public
export type ProxyResource = Resource & {};

// @public
export interface QuotaCapability {
    coresUsed?: number;
    maxCoresAllowed?: number;
    regionalQuotas?: RegionalQuotaCapability[];
}

// @public
export interface QuotaInfo {
    coresUsed?: number;
}

// @public
export interface RegionalQuotaCapability {
    coresAvailable?: number;
    coresUsed?: number;
    regionName?: string;
}

// @public
export interface RegionsCapability {
    available?: string[];
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface ResourceAutoGenerated {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface ResourceId {
    id?: string;
}

// @public
export type ResourceIdentityType = string;

// @public
export type ResourceProviderConnection = string;

// @public
export interface Role {
    autoscaleConfiguration?: Autoscale;
    dataDisksGroups?: DataDisksGroups[];
    encryptDataDisks?: boolean;
    hardwareProfile?: HardwareProfile;
    minInstanceCount?: number;
    name?: string;
    osProfile?: OsProfile;
    scriptActions?: ScriptAction[];
    targetInstanceCount?: number;
    virtualNetworkProfile?: VirtualNetworkProfile;
    vMGroupName?: string;
}

// @public
export type RoleName = string;

// @public
export interface RuntimeScriptAction {
    readonly applicationName?: string;
    name: string;
    parameters?: string;
    roles: string[];
    uri: string;
}

// @public
export type RuntimeScriptActionDetail = RuntimeScriptAction & {
    readonly scriptExecutionId?: number;
    readonly startTime?: string;
    readonly endTime?: string;
    readonly status?: string;
    readonly operation?: string;
    readonly executionSummary?: ScriptActionExecutionSummary[];
    readonly debugInformation?: string;
};

// @public
export interface ScriptAction {
    name: string;
    parameters: string;
    uri: string;
}

// @public
export interface ScriptActionExecutionHistoryList {
    readonly nextLink?: string;
    readonly value?: RuntimeScriptActionDetail[];
}

// @public
export interface ScriptActionExecutionSummary {
    readonly instanceCount?: number;
    readonly status?: string;
}

// @public
export interface ScriptActionPersistedGetResponseSpec {
    applicationName?: string;
    name?: string;
    parameters?: string;
    roles?: string[];
    uri?: string;
}

// @public
export interface ScriptActions {
    delete(resourceGroupName: string, clusterName: string, scriptName: string, options?: ScriptActionsDeleteOptionalParams): Promise<void>;
    getExecutionAsyncOperationStatus(resourceGroupName: string, clusterName: string, operationId: string, options?: ScriptActionsGetExecutionAsyncOperationStatusOptionalParams): Promise<ScriptActionsGetExecutionAsyncOperationStatusResponse>;
    getExecutionDetail(resourceGroupName: string, clusterName: string, scriptExecutionId: string, options?: ScriptActionsGetExecutionDetailOptionalParams): Promise<ScriptActionsGetExecutionDetailResponse>;
    listByCluster(resourceGroupName: string, clusterName: string, options?: ScriptActionsListByClusterOptionalParams): PagedAsyncIterableIterator<RuntimeScriptActionDetail>;
}

// @public
export interface ScriptActionsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ScriptActionsGetExecutionAsyncOperationStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScriptActionsGetExecutionAsyncOperationStatusResponse = AsyncOperationResult;

// @public
export interface ScriptActionsGetExecutionDetailOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScriptActionsGetExecutionDetailResponse = RuntimeScriptActionDetail;

// @public
export interface ScriptActionsList {
    readonly nextLink?: string;
    value?: RuntimeScriptActionDetail[];
}

// @public
export interface ScriptActionsListByClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScriptActionsListByClusterNextResponse = ScriptActionsList;

// @public
export interface ScriptActionsListByClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScriptActionsListByClusterResponse = ScriptActionsList;

// @public
export interface ScriptExecutionHistory {
    listByCluster(resourceGroupName: string, clusterName: string, options?: ScriptExecutionHistoryListByClusterOptionalParams): PagedAsyncIterableIterator<RuntimeScriptActionDetail>;
    promote(resourceGroupName: string, clusterName: string, scriptExecutionId: string, options?: ScriptExecutionHistoryPromoteOptionalParams): Promise<void>;
}

// @public
export interface ScriptExecutionHistoryListByClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScriptExecutionHistoryListByClusterNextResponse = ScriptActionExecutionHistoryList;

// @public
export interface ScriptExecutionHistoryListByClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScriptExecutionHistoryListByClusterResponse = ScriptActionExecutionHistoryList;

// @public
export interface ScriptExecutionHistoryPromoteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface SecurityProfile {
    aaddsResourceId?: string;
    clusterUsersGroupDNs?: string[];
    directoryType?: DirectoryType;
    domain?: string;
    domainUsername?: string;
    domainUserPassword?: string;
    ldapsUrls?: string[];
    msiResourceId?: string;
    organizationalUnitDN?: string;
}

// @public
export interface ServiceSpecification {
    metricSpecifications?: MetricSpecifications[];
}

// @public
export interface SshProfile {
    publicKeys?: SshPublicKey[];
}

// @public
export interface SshPublicKey {
    certificateData?: string;
}

// @public
export interface StorageAccount {
    container?: string;
    fileshare?: string;
    fileSystem?: string;
    isDefault?: boolean;
    key?: string;
    msiResourceId?: string;
    name?: string;
    resourceId?: string;
    saskey?: string;
}

// @public
export interface StorageProfile {
    storageaccounts?: StorageAccount[];
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export type Tier = string;

// @public
export type TrackedResource = ResourceAutoGenerated & {
    tags?: {
        [propertyName: string]: string;
    };
    location: string;
};

// @public
export interface UpdateClusterIdentityCertificateParameters {
    applicationId?: string;
    certificate?: string;
    certificatePassword?: string;
}

// @public
export interface UpdateGatewaySettingsParameters {
    isCredentialEnabled?: boolean;
    password?: string;
    userName?: string;
}

// @public
export interface Usage {
    currentValue?: number;
    limit?: number;
    readonly name?: LocalizedName;
    unit?: string;
}

// @public
export interface UsagesListResult {
    value?: Usage[];
}

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
    tenantId?: string;
}

// @public
export interface ValidationErrorInfo {
    code?: string;
    errorResource?: string;
    message?: string;
    messageArguments?: string[];
}

// @public
export interface VersionsCapability {
    available?: VersionSpec[];
}

// @public
export interface VersionSpec {
    componentVersions?: {
        [propertyName: string]: string;
    };
    displayName?: string;
    friendlyName?: string;
    isDefault?: boolean;
}

// @public
export interface VirtualMachines {
    beginRestartHosts(resourceGroupName: string, clusterName: string, hosts: string[], options?: VirtualMachinesRestartHostsOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginRestartHostsAndWait(resourceGroupName: string, clusterName: string, hosts: string[], options?: VirtualMachinesRestartHostsOptionalParams): Promise<void>;
    getAsyncOperationStatus(resourceGroupName: string, clusterName: string, operationId: string, options?: VirtualMachinesGetAsyncOperationStatusOptionalParams): Promise<VirtualMachinesGetAsyncOperationStatusResponse>;
    listHosts(resourceGroupName: string, clusterName: string, options?: VirtualMachinesListHostsOptionalParams): Promise<VirtualMachinesListHostsResponse>;
}

// @public
export interface VirtualMachinesGetAsyncOperationStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VirtualMachinesGetAsyncOperationStatusResponse = AsyncOperationResult;

// @public
export interface VirtualMachinesListHostsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VirtualMachinesListHostsResponse = HostInfo[];

// @public
export interface VirtualMachinesRestartHostsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VirtualNetworkProfile {
    id?: string;
    subnet?: string;
}

// @public
export interface VmSizeCompatibilityFilterV2 {
    clusterFlavors?: string[];
    clusterVersions?: string[];
    computeIsolationSupported?: string;
    espApplied?: string;
    filterMode?: FilterMode;
    nodeTypes?: string[];
    osType?: OSType[];
    regions?: string[];
    vmSizes?: string[];
}

// @public
export interface VmSizeProperty {
    cores?: number;
    dataDiskStorageTier?: string;
    label?: string;
    maxDataDiskCount?: number;
    memoryInMb?: number;
    name?: string;
    supportedByVirtualMachines?: boolean;
    supportedByWebWorkerRoles?: boolean;
    virtualMachineResourceDiskSizeInMb?: number;
    webWorkerResourceDiskSizeInMb?: number;
}

// (No @packageDocumentation comment for this package)

```
