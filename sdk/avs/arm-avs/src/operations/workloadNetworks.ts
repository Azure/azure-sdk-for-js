/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { WorkloadNetworks } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { AzureVMwareSolutionAPI } from "../azureVMwareSolutionAPI";
import { PollerLike, PollOperationState, LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
import {
  WorkloadNetworkSegment,
  WorkloadNetworksListSegmentsNextOptionalParams,
  WorkloadNetworksListSegmentsOptionalParams,
  WorkloadNetworkDhcp,
  WorkloadNetworksListDhcpNextOptionalParams,
  WorkloadNetworksListDhcpOptionalParams,
  WorkloadNetworkGateway,
  WorkloadNetworksListGatewaysNextOptionalParams,
  WorkloadNetworksListGatewaysOptionalParams,
  WorkloadNetworkPortMirroring,
  WorkloadNetworksListPortMirroringNextOptionalParams,
  WorkloadNetworksListPortMirroringOptionalParams,
  WorkloadNetworkVMGroup,
  WorkloadNetworksListVMGroupsNextOptionalParams,
  WorkloadNetworksListVMGroupsOptionalParams,
  WorkloadNetworkVirtualMachine,
  WorkloadNetworksListVirtualMachinesNextOptionalParams,
  WorkloadNetworksListVirtualMachinesOptionalParams,
  WorkloadNetworkDnsService,
  WorkloadNetworksListDnsServicesNextOptionalParams,
  WorkloadNetworksListDnsServicesOptionalParams,
  WorkloadNetworkDnsZone,
  WorkloadNetworksListDnsZonesNextOptionalParams,
  WorkloadNetworksListDnsZonesOptionalParams,
  WorkloadNetworkPublicIP,
  WorkloadNetworksListPublicIPsNextOptionalParams,
  WorkloadNetworksListPublicIPsOptionalParams,
  WorkloadNetworksListSegmentsResponse,
  WorkloadNetworksGetSegmentOptionalParams,
  WorkloadNetworksGetSegmentResponse,
  WorkloadNetworksCreateSegmentsOptionalParams,
  WorkloadNetworksCreateSegmentsResponse,
  WorkloadNetworksUpdateSegmentsOptionalParams,
  WorkloadNetworksUpdateSegmentsResponse,
  WorkloadNetworksDeleteSegmentOptionalParams,
  WorkloadNetworksListDhcpResponse,
  WorkloadNetworksGetDhcpOptionalParams,
  WorkloadNetworksGetDhcpResponse,
  WorkloadNetworksCreateDhcpOptionalParams,
  WorkloadNetworksCreateDhcpResponse,
  WorkloadNetworksUpdateDhcpOptionalParams,
  WorkloadNetworksUpdateDhcpResponse,
  WorkloadNetworksDeleteDhcpOptionalParams,
  WorkloadNetworksListGatewaysResponse,
  WorkloadNetworksGetGatewayOptionalParams,
  WorkloadNetworksGetGatewayResponse,
  WorkloadNetworksListPortMirroringResponse,
  WorkloadNetworksGetPortMirroringOptionalParams,
  WorkloadNetworksGetPortMirroringResponse,
  WorkloadNetworksCreatePortMirroringOptionalParams,
  WorkloadNetworksCreatePortMirroringResponse,
  WorkloadNetworksUpdatePortMirroringOptionalParams,
  WorkloadNetworksUpdatePortMirroringResponse,
  WorkloadNetworksDeletePortMirroringOptionalParams,
  WorkloadNetworksListVMGroupsResponse,
  WorkloadNetworksGetVMGroupOptionalParams,
  WorkloadNetworksGetVMGroupResponse,
  WorkloadNetworksCreateVMGroupOptionalParams,
  WorkloadNetworksCreateVMGroupResponse,
  WorkloadNetworksUpdateVMGroupOptionalParams,
  WorkloadNetworksUpdateVMGroupResponse,
  WorkloadNetworksDeleteVMGroupOptionalParams,
  WorkloadNetworksListVirtualMachinesResponse,
  WorkloadNetworksGetVirtualMachineOptionalParams,
  WorkloadNetworksGetVirtualMachineResponse,
  WorkloadNetworksListDnsServicesResponse,
  WorkloadNetworksGetDnsServiceOptionalParams,
  WorkloadNetworksGetDnsServiceResponse,
  WorkloadNetworksCreateDnsServiceOptionalParams,
  WorkloadNetworksCreateDnsServiceResponse,
  WorkloadNetworksUpdateDnsServiceOptionalParams,
  WorkloadNetworksUpdateDnsServiceResponse,
  WorkloadNetworksDeleteDnsServiceOptionalParams,
  WorkloadNetworksListDnsZonesResponse,
  WorkloadNetworksGetDnsZoneOptionalParams,
  WorkloadNetworksGetDnsZoneResponse,
  WorkloadNetworksCreateDnsZoneOptionalParams,
  WorkloadNetworksCreateDnsZoneResponse,
  WorkloadNetworksUpdateDnsZoneOptionalParams,
  WorkloadNetworksUpdateDnsZoneResponse,
  WorkloadNetworksDeleteDnsZoneOptionalParams,
  WorkloadNetworksListPublicIPsResponse,
  WorkloadNetworksGetPublicIPOptionalParams,
  WorkloadNetworksGetPublicIPResponse,
  WorkloadNetworksCreatePublicIPOptionalParams,
  WorkloadNetworksCreatePublicIPResponse,
  WorkloadNetworksDeletePublicIPOptionalParams,
  WorkloadNetworksListSegmentsNextResponse,
  WorkloadNetworksListDhcpNextResponse,
  WorkloadNetworksListGatewaysNextResponse,
  WorkloadNetworksListPortMirroringNextResponse,
  WorkloadNetworksListVMGroupsNextResponse,
  WorkloadNetworksListVirtualMachinesNextResponse,
  WorkloadNetworksListDnsServicesNextResponse,
  WorkloadNetworksListDnsZonesNextResponse,
  WorkloadNetworksListPublicIPsNextResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing WorkloadNetworks operations. */
export class WorkloadNetworksImpl implements WorkloadNetworks {
  private readonly client: AzureVMwareSolutionAPI;

  /**
   * Initialize a new instance of the class WorkloadNetworks class.
   * @param client Reference to the service client
   */
  constructor(client: AzureVMwareSolutionAPI) {
    this.client = client;
  }

  /**
   * List of segments in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listSegments(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListSegmentsOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkSegment> {
    const iter = this.listSegmentsPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listSegmentsPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listSegmentsPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListSegmentsOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkSegment[]> {
    let result = await this._listSegments(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listSegmentsNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listSegmentsPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListSegmentsOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkSegment> {
    for await (const page of this.listSegmentsPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List dhcp in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDhcpOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkDhcp> {
    const iter = this.listDhcpPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listDhcpPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listDhcpPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDhcpOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkDhcp[]> {
    let result = await this._listDhcp(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listDhcpNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listDhcpPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDhcpOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkDhcp> {
    for await (const page of this.listDhcpPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List of gateways in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listGateways(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListGatewaysOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkGateway> {
    const iter = this.listGatewaysPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listGatewaysPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listGatewaysPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListGatewaysOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkGateway[]> {
    let result = await this._listGateways(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listGatewaysNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listGatewaysPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListGatewaysOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkGateway> {
    for await (const page of this.listGatewaysPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List of port mirroring profiles in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listPortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPortMirroringOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkPortMirroring> {
    const iter = this.listPortMirroringPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listPortMirroringPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listPortMirroringPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPortMirroringOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkPortMirroring[]> {
    let result = await this._listPortMirroring(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listPortMirroringNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listPortMirroringPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPortMirroringOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkPortMirroring> {
    for await (const page of this.listPortMirroringPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List of vm groups in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listVMGroups(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVMGroupsOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkVMGroup> {
    const iter = this.listVMGroupsPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listVMGroupsPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listVMGroupsPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVMGroupsOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkVMGroup[]> {
    let result = await this._listVMGroups(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listVMGroupsNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listVMGroupsPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVMGroupsOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkVMGroup> {
    for await (const page of this.listVMGroupsPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List of virtual machines in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listVirtualMachines(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVirtualMachinesOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkVirtualMachine> {
    const iter = this.listVirtualMachinesPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listVirtualMachinesPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listVirtualMachinesPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVirtualMachinesOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkVirtualMachine[]> {
    let result = await this._listVirtualMachines(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listVirtualMachinesNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listVirtualMachinesPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVirtualMachinesOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkVirtualMachine> {
    for await (const page of this.listVirtualMachinesPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List of DNS services in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listDnsServices(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsServicesOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkDnsService> {
    const iter = this.listDnsServicesPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listDnsServicesPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listDnsServicesPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsServicesOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkDnsService[]> {
    let result = await this._listDnsServices(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listDnsServicesNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listDnsServicesPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsServicesOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkDnsService> {
    for await (const page of this.listDnsServicesPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List of DNS zones in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listDnsZones(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsZonesOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkDnsZone> {
    const iter = this.listDnsZonesPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listDnsZonesPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listDnsZonesPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsZonesOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkDnsZone[]> {
    let result = await this._listDnsZones(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listDnsZonesNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listDnsZonesPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsZonesOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkDnsZone> {
    for await (const page of this.listDnsZonesPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List of Public IP Blocks in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listPublicIPs(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPublicIPsOptionalParams
  ): PagedAsyncIterableIterator<WorkloadNetworkPublicIP> {
    const iter = this.listPublicIPsPagingAll(
      resourceGroupName,
      privateCloudName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listPublicIPsPagingPage(
          resourceGroupName,
          privateCloudName,
          options
        );
      }
    };
  }

  private async *listPublicIPsPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPublicIPsOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkPublicIP[]> {
    let result = await this._listPublicIPs(
      resourceGroupName,
      privateCloudName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listPublicIPsNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listPublicIPsPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPublicIPsOptionalParams
  ): AsyncIterableIterator<WorkloadNetworkPublicIP> {
    for await (const page of this.listPublicIPsPagingPage(
      resourceGroupName,
      privateCloudName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * List of segments in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listSegments(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListSegmentsOptionalParams
  ): Promise<WorkloadNetworksListSegmentsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listSegmentsOperationSpec
    );
  }

  /**
   * Get a segment by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
   * @param options The options parameters.
   */
  getSegment(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    options?: WorkloadNetworksGetSegmentOptionalParams
  ): Promise<WorkloadNetworksGetSegmentResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, segmentId, options },
      getSegmentOperationSpec
    );
  }

  /**
   * Create a segment by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
   * @param workloadNetworkSegment NSX Segment
   * @param options The options parameters.
   */
  async beginCreateSegments(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    workloadNetworkSegment: WorkloadNetworkSegment,
    options?: WorkloadNetworksCreateSegmentsOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksCreateSegmentsResponse>,
      WorkloadNetworksCreateSegmentsResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksCreateSegmentsResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        segmentId,
        workloadNetworkSegment,
        options
      },
      createSegmentsOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create a segment by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
   * @param workloadNetworkSegment NSX Segment
   * @param options The options parameters.
   */
  async beginCreateSegmentsAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    workloadNetworkSegment: WorkloadNetworkSegment,
    options?: WorkloadNetworksCreateSegmentsOptionalParams
  ): Promise<WorkloadNetworksCreateSegmentsResponse> {
    const poller = await this.beginCreateSegments(
      resourceGroupName,
      privateCloudName,
      segmentId,
      workloadNetworkSegment,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Create or update a segment by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
   * @param workloadNetworkSegment NSX Segment
   * @param options The options parameters.
   */
  async beginUpdateSegments(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    workloadNetworkSegment: WorkloadNetworkSegment,
    options?: WorkloadNetworksUpdateSegmentsOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksUpdateSegmentsResponse>,
      WorkloadNetworksUpdateSegmentsResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksUpdateSegmentsResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        segmentId,
        workloadNetworkSegment,
        options
      },
      updateSegmentsOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create or update a segment by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
   * @param workloadNetworkSegment NSX Segment
   * @param options The options parameters.
   */
  async beginUpdateSegmentsAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    workloadNetworkSegment: WorkloadNetworkSegment,
    options?: WorkloadNetworksUpdateSegmentsOptionalParams
  ): Promise<WorkloadNetworksUpdateSegmentsResponse> {
    const poller = await this.beginUpdateSegments(
      resourceGroupName,
      privateCloudName,
      segmentId,
      workloadNetworkSegment,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a segment by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
   * @param options The options parameters.
   */
  async beginDeleteSegment(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    options?: WorkloadNetworksDeleteSegmentOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, privateCloudName, segmentId, options },
      deleteSegmentOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Delete a segment by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
   * @param options The options parameters.
   */
  async beginDeleteSegmentAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    options?: WorkloadNetworksDeleteSegmentOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteSegment(
      resourceGroupName,
      privateCloudName,
      segmentId,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * List dhcp in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDhcpOptionalParams
  ): Promise<WorkloadNetworksListDhcpResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listDhcpOperationSpec
    );
  }

  /**
   * Get dhcp by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  getDhcp(
    resourceGroupName: string,
    dhcpId: string,
    privateCloudName: string,
    options?: WorkloadNetworksGetDhcpOptionalParams
  ): Promise<WorkloadNetworksGetDhcpResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, dhcpId, privateCloudName, options },
      getDhcpOperationSpec
    );
  }

  /**
   * Create dhcp by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
   * @param workloadNetworkDhcp NSX DHCP
   * @param options The options parameters.
   */
  async beginCreateDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    workloadNetworkDhcp: WorkloadNetworkDhcp,
    options?: WorkloadNetworksCreateDhcpOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksCreateDhcpResponse>,
      WorkloadNetworksCreateDhcpResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksCreateDhcpResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        dhcpId,
        workloadNetworkDhcp,
        options
      },
      createDhcpOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create dhcp by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
   * @param workloadNetworkDhcp NSX DHCP
   * @param options The options parameters.
   */
  async beginCreateDhcpAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    workloadNetworkDhcp: WorkloadNetworkDhcp,
    options?: WorkloadNetworksCreateDhcpOptionalParams
  ): Promise<WorkloadNetworksCreateDhcpResponse> {
    const poller = await this.beginCreateDhcp(
      resourceGroupName,
      privateCloudName,
      dhcpId,
      workloadNetworkDhcp,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Create or update dhcp by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
   * @param workloadNetworkDhcp NSX DHCP
   * @param options The options parameters.
   */
  async beginUpdateDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    workloadNetworkDhcp: WorkloadNetworkDhcp,
    options?: WorkloadNetworksUpdateDhcpOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksUpdateDhcpResponse>,
      WorkloadNetworksUpdateDhcpResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksUpdateDhcpResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        dhcpId,
        workloadNetworkDhcp,
        options
      },
      updateDhcpOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create or update dhcp by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
   * @param workloadNetworkDhcp NSX DHCP
   * @param options The options parameters.
   */
  async beginUpdateDhcpAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    workloadNetworkDhcp: WorkloadNetworkDhcp,
    options?: WorkloadNetworksUpdateDhcpOptionalParams
  ): Promise<WorkloadNetworksUpdateDhcpResponse> {
    const poller = await this.beginUpdateDhcp(
      resourceGroupName,
      privateCloudName,
      dhcpId,
      workloadNetworkDhcp,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete dhcp by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
   * @param options The options parameters.
   */
  async beginDeleteDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    options?: WorkloadNetworksDeleteDhcpOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, privateCloudName, dhcpId, options },
      deleteDhcpOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Delete dhcp by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
   * @param options The options parameters.
   */
  async beginDeleteDhcpAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    options?: WorkloadNetworksDeleteDhcpOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteDhcp(
      resourceGroupName,
      privateCloudName,
      dhcpId,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * List of gateways in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listGateways(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListGatewaysOptionalParams
  ): Promise<WorkloadNetworksListGatewaysResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listGatewaysOperationSpec
    );
  }

  /**
   * Get a gateway by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param gatewayId NSX Gateway identifier. Generally the same as the Gateway's display name
   * @param options The options parameters.
   */
  getGateway(
    resourceGroupName: string,
    privateCloudName: string,
    gatewayId: string,
    options?: WorkloadNetworksGetGatewayOptionalParams
  ): Promise<WorkloadNetworksGetGatewayResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, gatewayId, options },
      getGatewayOperationSpec
    );
  }

  /**
   * List of port mirroring profiles in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listPortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPortMirroringOptionalParams
  ): Promise<WorkloadNetworksListPortMirroringResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listPortMirroringOperationSpec
    );
  }

  /**
   * Get a port mirroring profile by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
   *                        display name
   * @param options The options parameters.
   */
  getPortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    options?: WorkloadNetworksGetPortMirroringOptionalParams
  ): Promise<WorkloadNetworksGetPortMirroringResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, portMirroringId, options },
      getPortMirroringOperationSpec
    );
  }

  /**
   * Create a port mirroring profile by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
   *                        display name
   * @param workloadNetworkPortMirroring NSX port mirroring
   * @param options The options parameters.
   */
  async beginCreatePortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    workloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    options?: WorkloadNetworksCreatePortMirroringOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksCreatePortMirroringResponse>,
      WorkloadNetworksCreatePortMirroringResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksCreatePortMirroringResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        portMirroringId,
        workloadNetworkPortMirroring,
        options
      },
      createPortMirroringOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create a port mirroring profile by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
   *                        display name
   * @param workloadNetworkPortMirroring NSX port mirroring
   * @param options The options parameters.
   */
  async beginCreatePortMirroringAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    workloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    options?: WorkloadNetworksCreatePortMirroringOptionalParams
  ): Promise<WorkloadNetworksCreatePortMirroringResponse> {
    const poller = await this.beginCreatePortMirroring(
      resourceGroupName,
      privateCloudName,
      portMirroringId,
      workloadNetworkPortMirroring,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Create or update a port mirroring profile by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
   *                        display name
   * @param workloadNetworkPortMirroring NSX port mirroring
   * @param options The options parameters.
   */
  async beginUpdatePortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    workloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    options?: WorkloadNetworksUpdatePortMirroringOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksUpdatePortMirroringResponse>,
      WorkloadNetworksUpdatePortMirroringResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksUpdatePortMirroringResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        portMirroringId,
        workloadNetworkPortMirroring,
        options
      },
      updatePortMirroringOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create or update a port mirroring profile by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
   *                        display name
   * @param workloadNetworkPortMirroring NSX port mirroring
   * @param options The options parameters.
   */
  async beginUpdatePortMirroringAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    workloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    options?: WorkloadNetworksUpdatePortMirroringOptionalParams
  ): Promise<WorkloadNetworksUpdatePortMirroringResponse> {
    const poller = await this.beginUpdatePortMirroring(
      resourceGroupName,
      privateCloudName,
      portMirroringId,
      workloadNetworkPortMirroring,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a port mirroring profile by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
   *                        display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeletePortMirroring(
    resourceGroupName: string,
    portMirroringId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeletePortMirroringOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, portMirroringId, privateCloudName, options },
      deletePortMirroringOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Delete a port mirroring profile by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
   *                        display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeletePortMirroringAndWait(
    resourceGroupName: string,
    portMirroringId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeletePortMirroringOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeletePortMirroring(
      resourceGroupName,
      portMirroringId,
      privateCloudName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * List of vm groups in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listVMGroups(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVMGroupsOptionalParams
  ): Promise<WorkloadNetworksListVMGroupsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listVMGroupsOperationSpec
    );
  }

  /**
   * Get a vm group by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
   * @param options The options parameters.
   */
  getVMGroup(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    options?: WorkloadNetworksGetVMGroupOptionalParams
  ): Promise<WorkloadNetworksGetVMGroupResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, vmGroupId, options },
      getVMGroupOperationSpec
    );
  }

  /**
   * Create a vm group by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
   * @param workloadNetworkVMGroup NSX VM Group
   * @param options The options parameters.
   */
  async beginCreateVMGroup(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    workloadNetworkVMGroup: WorkloadNetworkVMGroup,
    options?: WorkloadNetworksCreateVMGroupOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksCreateVMGroupResponse>,
      WorkloadNetworksCreateVMGroupResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksCreateVMGroupResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        vmGroupId,
        workloadNetworkVMGroup,
        options
      },
      createVMGroupOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create a vm group by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
   * @param workloadNetworkVMGroup NSX VM Group
   * @param options The options parameters.
   */
  async beginCreateVMGroupAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    workloadNetworkVMGroup: WorkloadNetworkVMGroup,
    options?: WorkloadNetworksCreateVMGroupOptionalParams
  ): Promise<WorkloadNetworksCreateVMGroupResponse> {
    const poller = await this.beginCreateVMGroup(
      resourceGroupName,
      privateCloudName,
      vmGroupId,
      workloadNetworkVMGroup,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Create or update a vm group by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
   * @param workloadNetworkVMGroup NSX VM Group
   * @param options The options parameters.
   */
  async beginUpdateVMGroup(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    workloadNetworkVMGroup: WorkloadNetworkVMGroup,
    options?: WorkloadNetworksUpdateVMGroupOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksUpdateVMGroupResponse>,
      WorkloadNetworksUpdateVMGroupResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksUpdateVMGroupResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        vmGroupId,
        workloadNetworkVMGroup,
        options
      },
      updateVMGroupOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create or update a vm group by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
   * @param workloadNetworkVMGroup NSX VM Group
   * @param options The options parameters.
   */
  async beginUpdateVMGroupAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    workloadNetworkVMGroup: WorkloadNetworkVMGroup,
    options?: WorkloadNetworksUpdateVMGroupOptionalParams
  ): Promise<WorkloadNetworksUpdateVMGroupResponse> {
    const poller = await this.beginUpdateVMGroup(
      resourceGroupName,
      privateCloudName,
      vmGroupId,
      workloadNetworkVMGroup,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a vm group by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteVMGroup(
    resourceGroupName: string,
    vmGroupId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteVMGroupOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, vmGroupId, privateCloudName, options },
      deleteVMGroupOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Delete a vm group by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteVMGroupAndWait(
    resourceGroupName: string,
    vmGroupId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteVMGroupOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteVMGroup(
      resourceGroupName,
      vmGroupId,
      privateCloudName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * List of virtual machines in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listVirtualMachines(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVirtualMachinesOptionalParams
  ): Promise<WorkloadNetworksListVirtualMachinesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listVirtualMachinesOperationSpec
    );
  }

  /**
   * Get a virtual machine by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param virtualMachineId Virtual Machine identifier
   * @param options The options parameters.
   */
  getVirtualMachine(
    resourceGroupName: string,
    privateCloudName: string,
    virtualMachineId: string,
    options?: WorkloadNetworksGetVirtualMachineOptionalParams
  ): Promise<WorkloadNetworksGetVirtualMachineResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, virtualMachineId, options },
      getVirtualMachineOperationSpec
    );
  }

  /**
   * List of DNS services in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listDnsServices(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsServicesOptionalParams
  ): Promise<WorkloadNetworksListDnsServicesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listDnsServicesOperationSpec
    );
  }

  /**
   * Get a DNS service by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
   * @param options The options parameters.
   */
  getDnsService(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    options?: WorkloadNetworksGetDnsServiceOptionalParams
  ): Promise<WorkloadNetworksGetDnsServiceResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, dnsServiceId, options },
      getDnsServiceOperationSpec
    );
  }

  /**
   * Create a DNS service by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
   * @param workloadNetworkDnsService NSX DNS Service
   * @param options The options parameters.
   */
  async beginCreateDnsService(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    workloadNetworkDnsService: WorkloadNetworkDnsService,
    options?: WorkloadNetworksCreateDnsServiceOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksCreateDnsServiceResponse>,
      WorkloadNetworksCreateDnsServiceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksCreateDnsServiceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        dnsServiceId,
        workloadNetworkDnsService,
        options
      },
      createDnsServiceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create a DNS service by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
   * @param workloadNetworkDnsService NSX DNS Service
   * @param options The options parameters.
   */
  async beginCreateDnsServiceAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    workloadNetworkDnsService: WorkloadNetworkDnsService,
    options?: WorkloadNetworksCreateDnsServiceOptionalParams
  ): Promise<WorkloadNetworksCreateDnsServiceResponse> {
    const poller = await this.beginCreateDnsService(
      resourceGroupName,
      privateCloudName,
      dnsServiceId,
      workloadNetworkDnsService,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Create or update a DNS service by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
   * @param workloadNetworkDnsService NSX DNS Service
   * @param options The options parameters.
   */
  async beginUpdateDnsService(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    workloadNetworkDnsService: WorkloadNetworkDnsService,
    options?: WorkloadNetworksUpdateDnsServiceOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksUpdateDnsServiceResponse>,
      WorkloadNetworksUpdateDnsServiceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksUpdateDnsServiceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        dnsServiceId,
        workloadNetworkDnsService,
        options
      },
      updateDnsServiceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create or update a DNS service by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
   * @param workloadNetworkDnsService NSX DNS Service
   * @param options The options parameters.
   */
  async beginUpdateDnsServiceAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    workloadNetworkDnsService: WorkloadNetworkDnsService,
    options?: WorkloadNetworksUpdateDnsServiceOptionalParams
  ): Promise<WorkloadNetworksUpdateDnsServiceResponse> {
    const poller = await this.beginUpdateDnsService(
      resourceGroupName,
      privateCloudName,
      dnsServiceId,
      workloadNetworkDnsService,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a DNS service by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteDnsService(
    resourceGroupName: string,
    dnsServiceId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteDnsServiceOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, dnsServiceId, privateCloudName, options },
      deleteDnsServiceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Delete a DNS service by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteDnsServiceAndWait(
    resourceGroupName: string,
    dnsServiceId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteDnsServiceOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteDnsService(
      resourceGroupName,
      dnsServiceId,
      privateCloudName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * List of DNS zones in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listDnsZones(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsZonesOptionalParams
  ): Promise<WorkloadNetworksListDnsZonesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listDnsZonesOperationSpec
    );
  }

  /**
   * Get a DNS zone by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
   * @param options The options parameters.
   */
  getDnsZone(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    options?: WorkloadNetworksGetDnsZoneOptionalParams
  ): Promise<WorkloadNetworksGetDnsZoneResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, dnsZoneId, options },
      getDnsZoneOperationSpec
    );
  }

  /**
   * Create a DNS zone by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
   * @param workloadNetworkDnsZone NSX DNS Zone
   * @param options The options parameters.
   */
  async beginCreateDnsZone(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    workloadNetworkDnsZone: WorkloadNetworkDnsZone,
    options?: WorkloadNetworksCreateDnsZoneOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksCreateDnsZoneResponse>,
      WorkloadNetworksCreateDnsZoneResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksCreateDnsZoneResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        dnsZoneId,
        workloadNetworkDnsZone,
        options
      },
      createDnsZoneOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create a DNS zone by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
   * @param workloadNetworkDnsZone NSX DNS Zone
   * @param options The options parameters.
   */
  async beginCreateDnsZoneAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    workloadNetworkDnsZone: WorkloadNetworkDnsZone,
    options?: WorkloadNetworksCreateDnsZoneOptionalParams
  ): Promise<WorkloadNetworksCreateDnsZoneResponse> {
    const poller = await this.beginCreateDnsZone(
      resourceGroupName,
      privateCloudName,
      dnsZoneId,
      workloadNetworkDnsZone,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Create or update a DNS zone by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
   * @param workloadNetworkDnsZone NSX DNS Zone
   * @param options The options parameters.
   */
  async beginUpdateDnsZone(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    workloadNetworkDnsZone: WorkloadNetworkDnsZone,
    options?: WorkloadNetworksUpdateDnsZoneOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksUpdateDnsZoneResponse>,
      WorkloadNetworksUpdateDnsZoneResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksUpdateDnsZoneResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        dnsZoneId,
        workloadNetworkDnsZone,
        options
      },
      updateDnsZoneOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create or update a DNS zone by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
   * @param workloadNetworkDnsZone NSX DNS Zone
   * @param options The options parameters.
   */
  async beginUpdateDnsZoneAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    workloadNetworkDnsZone: WorkloadNetworkDnsZone,
    options?: WorkloadNetworksUpdateDnsZoneOptionalParams
  ): Promise<WorkloadNetworksUpdateDnsZoneResponse> {
    const poller = await this.beginUpdateDnsZone(
      resourceGroupName,
      privateCloudName,
      dnsZoneId,
      workloadNetworkDnsZone,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a DNS zone by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteDnsZone(
    resourceGroupName: string,
    dnsZoneId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteDnsZoneOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, dnsZoneId, privateCloudName, options },
      deleteDnsZoneOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Delete a DNS zone by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteDnsZoneAndWait(
    resourceGroupName: string,
    dnsZoneId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteDnsZoneOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteDnsZone(
      resourceGroupName,
      dnsZoneId,
      privateCloudName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * List of Public IP Blocks in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listPublicIPs(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPublicIPsOptionalParams
  ): Promise<WorkloadNetworksListPublicIPsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listPublicIPsOperationSpec
    );
  }

  /**
   * Get a Public IP Block by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
   *                   display name
   * @param options The options parameters.
   */
  getPublicIP(
    resourceGroupName: string,
    privateCloudName: string,
    publicIPId: string,
    options?: WorkloadNetworksGetPublicIPOptionalParams
  ): Promise<WorkloadNetworksGetPublicIPResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, publicIPId, options },
      getPublicIPOperationSpec
    );
  }

  /**
   * Create a Public IP Block by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
   *                   display name
   * @param workloadNetworkPublicIP NSX Public IP Block
   * @param options The options parameters.
   */
  async beginCreatePublicIP(
    resourceGroupName: string,
    privateCloudName: string,
    publicIPId: string,
    workloadNetworkPublicIP: WorkloadNetworkPublicIP,
    options?: WorkloadNetworksCreatePublicIPOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<WorkloadNetworksCreatePublicIPResponse>,
      WorkloadNetworksCreatePublicIPResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<WorkloadNetworksCreatePublicIPResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        privateCloudName,
        publicIPId,
        workloadNetworkPublicIP,
        options
      },
      createPublicIPOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Create a Public IP Block by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
   *                   display name
   * @param workloadNetworkPublicIP NSX Public IP Block
   * @param options The options parameters.
   */
  async beginCreatePublicIPAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    publicIPId: string,
    workloadNetworkPublicIP: WorkloadNetworkPublicIP,
    options?: WorkloadNetworksCreatePublicIPOptionalParams
  ): Promise<WorkloadNetworksCreatePublicIPResponse> {
    const poller = await this.beginCreatePublicIP(
      resourceGroupName,
      privateCloudName,
      publicIPId,
      workloadNetworkPublicIP,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a Public IP Block by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
   *                   display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeletePublicIP(
    resourceGroupName: string,
    publicIPId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeletePublicIPOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, publicIPId, privateCloudName, options },
      deletePublicIPOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Delete a Public IP Block by id in a private cloud workload network.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
   *                   display name
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeletePublicIPAndWait(
    resourceGroupName: string,
    publicIPId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeletePublicIPOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeletePublicIP(
      resourceGroupName,
      publicIPId,
      privateCloudName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * ListSegmentsNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListSegments method.
   * @param options The options parameters.
   */
  private _listSegmentsNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListSegmentsNextOptionalParams
  ): Promise<WorkloadNetworksListSegmentsNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listSegmentsNextOperationSpec
    );
  }

  /**
   * ListDhcpNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListDhcp method.
   * @param options The options parameters.
   */
  private _listDhcpNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListDhcpNextOptionalParams
  ): Promise<WorkloadNetworksListDhcpNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listDhcpNextOperationSpec
    );
  }

  /**
   * ListGatewaysNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListGateways method.
   * @param options The options parameters.
   */
  private _listGatewaysNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListGatewaysNextOptionalParams
  ): Promise<WorkloadNetworksListGatewaysNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listGatewaysNextOperationSpec
    );
  }

  /**
   * ListPortMirroringNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListPortMirroring method.
   * @param options The options parameters.
   */
  private _listPortMirroringNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListPortMirroringNextOptionalParams
  ): Promise<WorkloadNetworksListPortMirroringNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listPortMirroringNextOperationSpec
    );
  }

  /**
   * ListVMGroupsNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListVMGroups method.
   * @param options The options parameters.
   */
  private _listVMGroupsNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListVMGroupsNextOptionalParams
  ): Promise<WorkloadNetworksListVMGroupsNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listVMGroupsNextOperationSpec
    );
  }

  /**
   * ListVirtualMachinesNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListVirtualMachines method.
   * @param options The options parameters.
   */
  private _listVirtualMachinesNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListVirtualMachinesNextOptionalParams
  ): Promise<WorkloadNetworksListVirtualMachinesNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listVirtualMachinesNextOperationSpec
    );
  }

  /**
   * ListDnsServicesNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListDnsServices method.
   * @param options The options parameters.
   */
  private _listDnsServicesNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListDnsServicesNextOptionalParams
  ): Promise<WorkloadNetworksListDnsServicesNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listDnsServicesNextOperationSpec
    );
  }

  /**
   * ListDnsZonesNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListDnsZones method.
   * @param options The options parameters.
   */
  private _listDnsZonesNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListDnsZonesNextOptionalParams
  ): Promise<WorkloadNetworksListDnsZonesNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listDnsZonesNextOperationSpec
    );
  }

  /**
   * ListPublicIPsNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListPublicIPs method.
   * @param options The options parameters.
   */
  private _listPublicIPsNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListPublicIPsNextOptionalParams
  ): Promise<WorkloadNetworksListPublicIPsNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listPublicIPsNextOperationSpec
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listSegmentsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegmentsList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getSegmentOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.segmentId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createSegmentsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkSegment,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.segmentId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const updateSegmentsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkSegment
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkSegment,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.segmentId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteSegmentOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.segmentId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listDhcpOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcpList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getDhcpOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dhcpId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createDhcpOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkDhcp,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dhcpId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const updateDhcpOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDhcp
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkDhcp,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dhcpId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteDhcpOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dhcpId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listGatewaysOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkGatewayList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getGatewayOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways/{gatewayId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkGateway
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.gatewayId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listPortMirroringOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroringList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getPortMirroringOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.portMirroringId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createPortMirroringOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkPortMirroring,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.portMirroringId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const updatePortMirroringOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkPortMirroring,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.portMirroringId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deletePortMirroringOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.portMirroringId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listVMGroupsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroupsList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getVMGroupOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.vmGroupId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createVMGroupOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkVMGroup,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.vmGroupId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const updateVMGroupOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkVMGroup,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.vmGroupId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteVMGroupOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.vmGroupId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listVirtualMachinesOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVirtualMachinesList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getVirtualMachineOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines/{virtualMachineId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVirtualMachine
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.virtualMachineId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listDnsServicesOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsServicesList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getDnsServiceOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsServiceId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createDnsServiceOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkDnsService,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsServiceId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const updateDnsServiceOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDnsService
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkDnsService,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsServiceId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteDnsServiceOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsServiceId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listDnsZonesOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZonesList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getDnsZoneOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsZoneId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createDnsZoneOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkDnsZone,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsZoneId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const updateDnsZoneOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkDnsZone,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsZoneId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteDnsZoneOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsZoneId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listPublicIPsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPublicIPsList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getPublicIPOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.publicIPId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createPublicIPOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.workloadNetworkPublicIP,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.publicIPId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deletePublicIPOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.publicIPId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listSegmentsNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegmentsList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listDhcpNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcpList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listGatewaysNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkGatewayList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listPortMirroringNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroringList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listVMGroupsNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroupsList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listVirtualMachinesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVirtualMachinesList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listDnsServicesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsServicesList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listDnsZonesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZonesList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listPublicIPsNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPublicIPsList
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
