/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { setContinuationToken } from "../pagingHelper";
import { WorkloadNetworks } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { AzureVMwareSolutionAPI } from "../azureVMwareSolutionAPI";
import {
  SimplePollerLike,
  OperationState,
  createHttpPoller,
} from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
import {
  WorkloadNetwork,
  WorkloadNetworksListNextOptionalParams,
  WorkloadNetworksListOptionalParams,
  WorkloadNetworksListResponse,
  WorkloadNetworkDhcp,
  WorkloadNetworksListDhcpNextOptionalParams,
  WorkloadNetworksListDhcpOptionalParams,
  WorkloadNetworksListDhcpResponse,
  WorkloadNetworkDnsService,
  WorkloadNetworksListDnsServicesNextOptionalParams,
  WorkloadNetworksListDnsServicesOptionalParams,
  WorkloadNetworksListDnsServicesResponse,
  WorkloadNetworkDnsZone,
  WorkloadNetworksListDnsZonesNextOptionalParams,
  WorkloadNetworksListDnsZonesOptionalParams,
  WorkloadNetworksListDnsZonesResponse,
  WorkloadNetworkGateway,
  WorkloadNetworksListGatewaysNextOptionalParams,
  WorkloadNetworksListGatewaysOptionalParams,
  WorkloadNetworksListGatewaysResponse,
  WorkloadNetworkPortMirroring,
  WorkloadNetworksListPortMirroringNextOptionalParams,
  WorkloadNetworksListPortMirroringOptionalParams,
  WorkloadNetworksListPortMirroringResponse,
  WorkloadNetworkPublicIP,
  WorkloadNetworksListPublicIPsNextOptionalParams,
  WorkloadNetworksListPublicIPsOptionalParams,
  WorkloadNetworksListPublicIPsResponse,
  WorkloadNetworkSegment,
  WorkloadNetworksListSegmentsNextOptionalParams,
  WorkloadNetworksListSegmentsOptionalParams,
  WorkloadNetworksListSegmentsResponse,
  WorkloadNetworkVirtualMachine,
  WorkloadNetworksListVirtualMachinesNextOptionalParams,
  WorkloadNetworksListVirtualMachinesOptionalParams,
  WorkloadNetworksListVirtualMachinesResponse,
  WorkloadNetworkVMGroup,
  WorkloadNetworksListVMGroupsNextOptionalParams,
  WorkloadNetworksListVMGroupsOptionalParams,
  WorkloadNetworksListVMGroupsResponse,
  WorkloadNetworksGetOptionalParams,
  WorkloadNetworksGetResponse,
  WorkloadNetworksGetDhcpOptionalParams,
  WorkloadNetworksGetDhcpResponse,
  WorkloadNetworksCreateDhcpOptionalParams,
  WorkloadNetworksCreateDhcpResponse,
  WorkloadNetworksUpdateDhcpOptionalParams,
  WorkloadNetworksUpdateDhcpResponse,
  WorkloadNetworksDeleteDhcpOptionalParams,
  WorkloadNetworksGetDnsServiceOptionalParams,
  WorkloadNetworksGetDnsServiceResponse,
  WorkloadNetworksCreateDnsServiceOptionalParams,
  WorkloadNetworksCreateDnsServiceResponse,
  WorkloadNetworksUpdateDnsServiceOptionalParams,
  WorkloadNetworksUpdateDnsServiceResponse,
  WorkloadNetworksDeleteDnsServiceOptionalParams,
  WorkloadNetworksGetDnsZoneOptionalParams,
  WorkloadNetworksGetDnsZoneResponse,
  WorkloadNetworksCreateDnsZoneOptionalParams,
  WorkloadNetworksCreateDnsZoneResponse,
  WorkloadNetworksUpdateDnsZoneOptionalParams,
  WorkloadNetworksUpdateDnsZoneResponse,
  WorkloadNetworksDeleteDnsZoneOptionalParams,
  WorkloadNetworksGetGatewayOptionalParams,
  WorkloadNetworksGetGatewayResponse,
  WorkloadNetworksGetPortMirroringOptionalParams,
  WorkloadNetworksGetPortMirroringResponse,
  WorkloadNetworksCreatePortMirroringOptionalParams,
  WorkloadNetworksCreatePortMirroringResponse,
  WorkloadNetworksUpdatePortMirroringOptionalParams,
  WorkloadNetworksUpdatePortMirroringResponse,
  WorkloadNetworksDeletePortMirroringOptionalParams,
  WorkloadNetworksGetPublicIPOptionalParams,
  WorkloadNetworksGetPublicIPResponse,
  WorkloadNetworksCreatePublicIPOptionalParams,
  WorkloadNetworksCreatePublicIPResponse,
  WorkloadNetworksDeletePublicIPOptionalParams,
  WorkloadNetworksGetSegmentOptionalParams,
  WorkloadNetworksGetSegmentResponse,
  WorkloadNetworksCreateSegmentsOptionalParams,
  WorkloadNetworksCreateSegmentsResponse,
  WorkloadNetworksUpdateSegmentsOptionalParams,
  WorkloadNetworksUpdateSegmentsResponse,
  WorkloadNetworksDeleteSegmentOptionalParams,
  WorkloadNetworksGetVirtualMachineOptionalParams,
  WorkloadNetworksGetVirtualMachineResponse,
  WorkloadNetworksGetVMGroupOptionalParams,
  WorkloadNetworksGetVMGroupResponse,
  WorkloadNetworksCreateVMGroupOptionalParams,
  WorkloadNetworksCreateVMGroupResponse,
  WorkloadNetworksUpdateVMGroupOptionalParams,
  WorkloadNetworksUpdateVMGroupResponse,
  WorkloadNetworksDeleteVMGroupOptionalParams,
  WorkloadNetworksListNextResponse,
  WorkloadNetworksListDhcpNextResponse,
  WorkloadNetworksListDnsServicesNextResponse,
  WorkloadNetworksListDnsZonesNextResponse,
  WorkloadNetworksListGatewaysNextResponse,
  WorkloadNetworksListPortMirroringNextResponse,
  WorkloadNetworksListPublicIPsNextResponse,
  WorkloadNetworksListSegmentsNextResponse,
  WorkloadNetworksListVirtualMachinesNextResponse,
  WorkloadNetworksListVMGroupsNextResponse,
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing WorkloadNetworks operations. */
export class WorkloadNetworksImpl implements WorkloadNetworks {
  private readonly client: AzureVMwareSolutionAPI;

  /**
   * Initialize a new instance of the class WorkloadNetworks class.
   * @param client Reference to the service client
   */
  constructor(client: AzureVMwareSolutionAPI) {
    this.client = client;
  }

  /**
   * List WorkloadNetwork resources by PrivateCloud
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public list(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetwork> {
    const iter = this.listPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetwork[]> {
    let result: WorkloadNetworksListResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._list(resourceGroupName, privateCloudName, options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListOptionalParams,
  ): AsyncIterableIterator<WorkloadNetwork> {
    for await (const page of this.listPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkDhcp resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDhcpOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkDhcp> {
    const iter = this.listDhcpPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listDhcpPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listDhcpPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDhcpOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkDhcp[]> {
    let result: WorkloadNetworksListDhcpResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listDhcp(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listDhcpNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listDhcpPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDhcpOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkDhcp> {
    for await (const page of this.listDhcpPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkDnsService resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listDnsServices(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsServicesOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkDnsService> {
    const iter = this.listDnsServicesPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listDnsServicesPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listDnsServicesPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsServicesOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkDnsService[]> {
    let result: WorkloadNetworksListDnsServicesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listDnsServices(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listDnsServicesNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listDnsServicesPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsServicesOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkDnsService> {
    for await (const page of this.listDnsServicesPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkDnsZone resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listDnsZones(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsZonesOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkDnsZone> {
    const iter = this.listDnsZonesPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listDnsZonesPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listDnsZonesPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsZonesOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkDnsZone[]> {
    let result: WorkloadNetworksListDnsZonesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listDnsZones(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listDnsZonesNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listDnsZonesPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsZonesOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkDnsZone> {
    for await (const page of this.listDnsZonesPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkGateway resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listGateways(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListGatewaysOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkGateway> {
    const iter = this.listGatewaysPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listGatewaysPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listGatewaysPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListGatewaysOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkGateway[]> {
    let result: WorkloadNetworksListGatewaysResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listGateways(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listGatewaysNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listGatewaysPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListGatewaysOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkGateway> {
    for await (const page of this.listGatewaysPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkPortMirroring resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listPortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPortMirroringOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkPortMirroring> {
    const iter = this.listPortMirroringPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listPortMirroringPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listPortMirroringPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPortMirroringOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkPortMirroring[]> {
    let result: WorkloadNetworksListPortMirroringResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listPortMirroring(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listPortMirroringNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listPortMirroringPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPortMirroringOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkPortMirroring> {
    for await (const page of this.listPortMirroringPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkPublicIP resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listPublicIPs(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPublicIPsOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkPublicIP> {
    const iter = this.listPublicIPsPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listPublicIPsPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listPublicIPsPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPublicIPsOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkPublicIP[]> {
    let result: WorkloadNetworksListPublicIPsResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listPublicIPs(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listPublicIPsNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listPublicIPsPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPublicIPsOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkPublicIP> {
    for await (const page of this.listPublicIPsPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkSegment resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listSegments(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListSegmentsOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkSegment> {
    const iter = this.listSegmentsPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listSegmentsPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listSegmentsPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListSegmentsOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkSegment[]> {
    let result: WorkloadNetworksListSegmentsResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listSegments(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listSegmentsNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listSegmentsPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListSegmentsOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkSegment> {
    for await (const page of this.listSegmentsPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkVirtualMachine resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listVirtualMachines(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVirtualMachinesOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkVirtualMachine> {
    const iter = this.listVirtualMachinesPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listVirtualMachinesPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listVirtualMachinesPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVirtualMachinesOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkVirtualMachine[]> {
    let result: WorkloadNetworksListVirtualMachinesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listVirtualMachines(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listVirtualMachinesNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listVirtualMachinesPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVirtualMachinesOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkVirtualMachine> {
    for await (const page of this.listVirtualMachinesPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetworkVMGroup resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  public listVMGroups(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVMGroupsOptionalParams,
  ): PagedAsyncIterableIterator<WorkloadNetworkVMGroup> {
    const iter = this.listVMGroupsPagingAll(
      resourceGroupName,
      privateCloudName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listVMGroupsPagingPage(
          resourceGroupName,
          privateCloudName,
          options,
          settings,
        );
      },
    };
  }

  private async *listVMGroupsPagingPage(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVMGroupsOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<WorkloadNetworkVMGroup[]> {
    let result: WorkloadNetworksListVMGroupsResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listVMGroups(
        resourceGroupName,
        privateCloudName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listVMGroupsNext(
        resourceGroupName,
        privateCloudName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listVMGroupsPagingAll(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVMGroupsOptionalParams,
  ): AsyncIterableIterator<WorkloadNetworkVMGroup> {
    for await (const page of this.listVMGroupsPagingPage(
      resourceGroupName,
      privateCloudName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * List WorkloadNetwork resources by PrivateCloud
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _list(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListOptionalParams,
  ): Promise<WorkloadNetworksListResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  get(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksGetOptionalParams,
  ): Promise<WorkloadNetworksGetResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      getOperationSpec,
    );
  }

  /**
   * List WorkloadNetworkDhcp resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDhcpOptionalParams,
  ): Promise<WorkloadNetworksListDhcpResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listDhcpOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkDhcp
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dhcpId The ID of the DHCP configuration
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  getDhcp(
    resourceGroupName: string,
    dhcpId: string,
    privateCloudName: string,
    options?: WorkloadNetworksGetDhcpOptionalParams,
  ): Promise<WorkloadNetworksGetDhcpResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, dhcpId, privateCloudName, options },
      getDhcpOperationSpec,
    );
  }

  /**
   * Create a WorkloadNetworkDhcp
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId The ID of the DHCP configuration
   * @param workloadNetworkDhcp Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    workloadNetworkDhcp: WorkloadNetworkDhcp,
    options?: WorkloadNetworksCreateDhcpOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksCreateDhcpResponse>,
      WorkloadNetworksCreateDhcpResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksCreateDhcpResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        dhcpId,
        workloadNetworkDhcp,
        options,
      },
      spec: createDhcpOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksCreateDhcpResponse,
      OperationState<WorkloadNetworksCreateDhcpResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create a WorkloadNetworkDhcp
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId The ID of the DHCP configuration
   * @param workloadNetworkDhcp Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateDhcpAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    workloadNetworkDhcp: WorkloadNetworkDhcp,
    options?: WorkloadNetworksCreateDhcpOptionalParams,
  ): Promise<WorkloadNetworksCreateDhcpResponse> {
    const poller = await this.beginCreateDhcp(
      resourceGroupName,
      privateCloudName,
      dhcpId,
      workloadNetworkDhcp,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Update a WorkloadNetworkDhcp
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId The ID of the DHCP configuration
   * @param workloadNetworkDhcp The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    workloadNetworkDhcp: WorkloadNetworkDhcp,
    options?: WorkloadNetworksUpdateDhcpOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksUpdateDhcpResponse>,
      WorkloadNetworksUpdateDhcpResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksUpdateDhcpResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        dhcpId,
        workloadNetworkDhcp,
        options,
      },
      spec: updateDhcpOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksUpdateDhcpResponse,
      OperationState<WorkloadNetworksUpdateDhcpResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update a WorkloadNetworkDhcp
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId The ID of the DHCP configuration
   * @param workloadNetworkDhcp The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateDhcpAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    workloadNetworkDhcp: WorkloadNetworkDhcp,
    options?: WorkloadNetworksUpdateDhcpOptionalParams,
  ): Promise<WorkloadNetworksUpdateDhcpResponse> {
    const poller = await this.beginUpdateDhcp(
      resourceGroupName,
      privateCloudName,
      dhcpId,
      workloadNetworkDhcp,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a WorkloadNetworkDhcp
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId The ID of the DHCP configuration
   * @param options The options parameters.
   */
  async beginDeleteDhcp(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    options?: WorkloadNetworksDeleteDhcpOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, privateCloudName, dhcpId, options },
      spec: deleteDhcpOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Delete a WorkloadNetworkDhcp
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dhcpId The ID of the DHCP configuration
   * @param options The options parameters.
   */
  async beginDeleteDhcpAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dhcpId: string,
    options?: WorkloadNetworksDeleteDhcpOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteDhcp(
      resourceGroupName,
      privateCloudName,
      dhcpId,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * List WorkloadNetworkDnsService resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listDnsServices(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsServicesOptionalParams,
  ): Promise<WorkloadNetworksListDnsServicesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listDnsServicesOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkDnsService
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId ID of the DNS service.
   * @param options The options parameters.
   */
  getDnsService(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    options?: WorkloadNetworksGetDnsServiceOptionalParams,
  ): Promise<WorkloadNetworksGetDnsServiceResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, dnsServiceId, options },
      getDnsServiceOperationSpec,
    );
  }

  /**
   * Create a WorkloadNetworkDnsService
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId ID of the DNS service.
   * @param workloadNetworkDnsService Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateDnsService(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    workloadNetworkDnsService: WorkloadNetworkDnsService,
    options?: WorkloadNetworksCreateDnsServiceOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksCreateDnsServiceResponse>,
      WorkloadNetworksCreateDnsServiceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksCreateDnsServiceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        dnsServiceId,
        workloadNetworkDnsService,
        options,
      },
      spec: createDnsServiceOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksCreateDnsServiceResponse,
      OperationState<WorkloadNetworksCreateDnsServiceResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create a WorkloadNetworkDnsService
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId ID of the DNS service.
   * @param workloadNetworkDnsService Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateDnsServiceAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    workloadNetworkDnsService: WorkloadNetworkDnsService,
    options?: WorkloadNetworksCreateDnsServiceOptionalParams,
  ): Promise<WorkloadNetworksCreateDnsServiceResponse> {
    const poller = await this.beginCreateDnsService(
      resourceGroupName,
      privateCloudName,
      dnsServiceId,
      workloadNetworkDnsService,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Update a WorkloadNetworkDnsService
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId ID of the DNS service.
   * @param workloadNetworkDnsService The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateDnsService(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    workloadNetworkDnsService: WorkloadNetworkDnsService,
    options?: WorkloadNetworksUpdateDnsServiceOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksUpdateDnsServiceResponse>,
      WorkloadNetworksUpdateDnsServiceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksUpdateDnsServiceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        dnsServiceId,
        workloadNetworkDnsService,
        options,
      },
      spec: updateDnsServiceOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksUpdateDnsServiceResponse,
      OperationState<WorkloadNetworksUpdateDnsServiceResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update a WorkloadNetworkDnsService
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsServiceId ID of the DNS service.
   * @param workloadNetworkDnsService The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateDnsServiceAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dnsServiceId: string,
    workloadNetworkDnsService: WorkloadNetworkDnsService,
    options?: WorkloadNetworksUpdateDnsServiceOptionalParams,
  ): Promise<WorkloadNetworksUpdateDnsServiceResponse> {
    const poller = await this.beginUpdateDnsService(
      resourceGroupName,
      privateCloudName,
      dnsServiceId,
      workloadNetworkDnsService,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a WorkloadNetworkDnsService
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dnsServiceId ID of the DNS service.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteDnsService(
    resourceGroupName: string,
    dnsServiceId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteDnsServiceOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, dnsServiceId, privateCloudName, options },
      spec: deleteDnsServiceOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Delete a WorkloadNetworkDnsService
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dnsServiceId ID of the DNS service.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteDnsServiceAndWait(
    resourceGroupName: string,
    dnsServiceId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteDnsServiceOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteDnsService(
      resourceGroupName,
      dnsServiceId,
      privateCloudName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * List WorkloadNetworkDnsZone resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listDnsZones(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListDnsZonesOptionalParams,
  ): Promise<WorkloadNetworksListDnsZonesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listDnsZonesOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkDnsZone
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId ID of the DNS zone.
   * @param options The options parameters.
   */
  getDnsZone(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    options?: WorkloadNetworksGetDnsZoneOptionalParams,
  ): Promise<WorkloadNetworksGetDnsZoneResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, dnsZoneId, options },
      getDnsZoneOperationSpec,
    );
  }

  /**
   * Create a WorkloadNetworkDnsZone
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId ID of the DNS zone.
   * @param workloadNetworkDnsZone Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateDnsZone(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    workloadNetworkDnsZone: WorkloadNetworkDnsZone,
    options?: WorkloadNetworksCreateDnsZoneOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksCreateDnsZoneResponse>,
      WorkloadNetworksCreateDnsZoneResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksCreateDnsZoneResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        dnsZoneId,
        workloadNetworkDnsZone,
        options,
      },
      spec: createDnsZoneOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksCreateDnsZoneResponse,
      OperationState<WorkloadNetworksCreateDnsZoneResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create a WorkloadNetworkDnsZone
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId ID of the DNS zone.
   * @param workloadNetworkDnsZone Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateDnsZoneAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    workloadNetworkDnsZone: WorkloadNetworkDnsZone,
    options?: WorkloadNetworksCreateDnsZoneOptionalParams,
  ): Promise<WorkloadNetworksCreateDnsZoneResponse> {
    const poller = await this.beginCreateDnsZone(
      resourceGroupName,
      privateCloudName,
      dnsZoneId,
      workloadNetworkDnsZone,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Update a WorkloadNetworkDnsZone
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId ID of the DNS zone.
   * @param workloadNetworkDnsZone The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateDnsZone(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    workloadNetworkDnsZone: WorkloadNetworkDnsZone,
    options?: WorkloadNetworksUpdateDnsZoneOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksUpdateDnsZoneResponse>,
      WorkloadNetworksUpdateDnsZoneResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksUpdateDnsZoneResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        dnsZoneId,
        workloadNetworkDnsZone,
        options,
      },
      spec: updateDnsZoneOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksUpdateDnsZoneResponse,
      OperationState<WorkloadNetworksUpdateDnsZoneResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update a WorkloadNetworkDnsZone
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param dnsZoneId ID of the DNS zone.
   * @param workloadNetworkDnsZone The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateDnsZoneAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    dnsZoneId: string,
    workloadNetworkDnsZone: WorkloadNetworkDnsZone,
    options?: WorkloadNetworksUpdateDnsZoneOptionalParams,
  ): Promise<WorkloadNetworksUpdateDnsZoneResponse> {
    const poller = await this.beginUpdateDnsZone(
      resourceGroupName,
      privateCloudName,
      dnsZoneId,
      workloadNetworkDnsZone,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a WorkloadNetworkDnsZone
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dnsZoneId ID of the DNS zone.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteDnsZone(
    resourceGroupName: string,
    dnsZoneId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteDnsZoneOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, dnsZoneId, privateCloudName, options },
      spec: deleteDnsZoneOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Delete a WorkloadNetworkDnsZone
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param dnsZoneId ID of the DNS zone.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteDnsZoneAndWait(
    resourceGroupName: string,
    dnsZoneId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteDnsZoneOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteDnsZone(
      resourceGroupName,
      dnsZoneId,
      privateCloudName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * List WorkloadNetworkGateway resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listGateways(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListGatewaysOptionalParams,
  ): Promise<WorkloadNetworksListGatewaysResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listGatewaysOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkGateway
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param gatewayId The ID of the NSX Gateway
   * @param options The options parameters.
   */
  getGateway(
    resourceGroupName: string,
    privateCloudName: string,
    gatewayId: string,
    options?: WorkloadNetworksGetGatewayOptionalParams,
  ): Promise<WorkloadNetworksGetGatewayResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, gatewayId, options },
      getGatewayOperationSpec,
    );
  }

  /**
   * List WorkloadNetworkPortMirroring resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listPortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPortMirroringOptionalParams,
  ): Promise<WorkloadNetworksListPortMirroringResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listPortMirroringOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkPortMirroring
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId ID of the NSX port mirroring profile.
   * @param options The options parameters.
   */
  getPortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    options?: WorkloadNetworksGetPortMirroringOptionalParams,
  ): Promise<WorkloadNetworksGetPortMirroringResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, portMirroringId, options },
      getPortMirroringOperationSpec,
    );
  }

  /**
   * Create a WorkloadNetworkPortMirroring
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId ID of the NSX port mirroring profile.
   * @param workloadNetworkPortMirroring Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreatePortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    workloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    options?: WorkloadNetworksCreatePortMirroringOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksCreatePortMirroringResponse>,
      WorkloadNetworksCreatePortMirroringResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksCreatePortMirroringResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        portMirroringId,
        workloadNetworkPortMirroring,
        options,
      },
      spec: createPortMirroringOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksCreatePortMirroringResponse,
      OperationState<WorkloadNetworksCreatePortMirroringResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create a WorkloadNetworkPortMirroring
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId ID of the NSX port mirroring profile.
   * @param workloadNetworkPortMirroring Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreatePortMirroringAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    workloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    options?: WorkloadNetworksCreatePortMirroringOptionalParams,
  ): Promise<WorkloadNetworksCreatePortMirroringResponse> {
    const poller = await this.beginCreatePortMirroring(
      resourceGroupName,
      privateCloudName,
      portMirroringId,
      workloadNetworkPortMirroring,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Update a WorkloadNetworkPortMirroring
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId ID of the NSX port mirroring profile.
   * @param workloadNetworkPortMirroring The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdatePortMirroring(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    workloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    options?: WorkloadNetworksUpdatePortMirroringOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksUpdatePortMirroringResponse>,
      WorkloadNetworksUpdatePortMirroringResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksUpdatePortMirroringResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        portMirroringId,
        workloadNetworkPortMirroring,
        options,
      },
      spec: updatePortMirroringOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksUpdatePortMirroringResponse,
      OperationState<WorkloadNetworksUpdatePortMirroringResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update a WorkloadNetworkPortMirroring
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param portMirroringId ID of the NSX port mirroring profile.
   * @param workloadNetworkPortMirroring The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdatePortMirroringAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    portMirroringId: string,
    workloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    options?: WorkloadNetworksUpdatePortMirroringOptionalParams,
  ): Promise<WorkloadNetworksUpdatePortMirroringResponse> {
    const poller = await this.beginUpdatePortMirroring(
      resourceGroupName,
      privateCloudName,
      portMirroringId,
      workloadNetworkPortMirroring,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a WorkloadNetworkPortMirroring
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param portMirroringId ID of the NSX port mirroring profile.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeletePortMirroring(
    resourceGroupName: string,
    portMirroringId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeletePortMirroringOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, portMirroringId, privateCloudName, options },
      spec: deletePortMirroringOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Delete a WorkloadNetworkPortMirroring
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param portMirroringId ID of the NSX port mirroring profile.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeletePortMirroringAndWait(
    resourceGroupName: string,
    portMirroringId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeletePortMirroringOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeletePortMirroring(
      resourceGroupName,
      portMirroringId,
      privateCloudName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * List WorkloadNetworkPublicIP resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listPublicIPs(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListPublicIPsOptionalParams,
  ): Promise<WorkloadNetworksListPublicIPsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listPublicIPsOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkPublicIP
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param publicIPId ID of the DNS zone.
   * @param options The options parameters.
   */
  getPublicIP(
    resourceGroupName: string,
    privateCloudName: string,
    publicIPId: string,
    options?: WorkloadNetworksGetPublicIPOptionalParams,
  ): Promise<WorkloadNetworksGetPublicIPResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, publicIPId, options },
      getPublicIPOperationSpec,
    );
  }

  /**
   * Create a WorkloadNetworkPublicIP
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param publicIPId ID of the DNS zone.
   * @param workloadNetworkPublicIP Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreatePublicIP(
    resourceGroupName: string,
    privateCloudName: string,
    publicIPId: string,
    workloadNetworkPublicIP: WorkloadNetworkPublicIP,
    options?: WorkloadNetworksCreatePublicIPOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksCreatePublicIPResponse>,
      WorkloadNetworksCreatePublicIPResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksCreatePublicIPResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        publicIPId,
        workloadNetworkPublicIP,
        options,
      },
      spec: createPublicIPOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksCreatePublicIPResponse,
      OperationState<WorkloadNetworksCreatePublicIPResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create a WorkloadNetworkPublicIP
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param publicIPId ID of the DNS zone.
   * @param workloadNetworkPublicIP Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreatePublicIPAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    publicIPId: string,
    workloadNetworkPublicIP: WorkloadNetworkPublicIP,
    options?: WorkloadNetworksCreatePublicIPOptionalParams,
  ): Promise<WorkloadNetworksCreatePublicIPResponse> {
    const poller = await this.beginCreatePublicIP(
      resourceGroupName,
      privateCloudName,
      publicIPId,
      workloadNetworkPublicIP,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a WorkloadNetworkPublicIP
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param publicIPId ID of the DNS zone.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeletePublicIP(
    resourceGroupName: string,
    publicIPId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeletePublicIPOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, publicIPId, privateCloudName, options },
      spec: deletePublicIPOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Delete a WorkloadNetworkPublicIP
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param publicIPId ID of the DNS zone.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeletePublicIPAndWait(
    resourceGroupName: string,
    publicIPId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeletePublicIPOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeletePublicIP(
      resourceGroupName,
      publicIPId,
      privateCloudName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * List WorkloadNetworkSegment resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listSegments(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListSegmentsOptionalParams,
  ): Promise<WorkloadNetworksListSegmentsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listSegmentsOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkSegment
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId The ID of the NSX Segment
   * @param options The options parameters.
   */
  getSegment(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    options?: WorkloadNetworksGetSegmentOptionalParams,
  ): Promise<WorkloadNetworksGetSegmentResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, segmentId, options },
      getSegmentOperationSpec,
    );
  }

  /**
   * Create a WorkloadNetworkSegment
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId The ID of the NSX Segment
   * @param workloadNetworkSegment Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateSegments(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    workloadNetworkSegment: WorkloadNetworkSegment,
    options?: WorkloadNetworksCreateSegmentsOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksCreateSegmentsResponse>,
      WorkloadNetworksCreateSegmentsResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksCreateSegmentsResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        segmentId,
        workloadNetworkSegment,
        options,
      },
      spec: createSegmentsOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksCreateSegmentsResponse,
      OperationState<WorkloadNetworksCreateSegmentsResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create a WorkloadNetworkSegment
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId The ID of the NSX Segment
   * @param workloadNetworkSegment Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateSegmentsAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    workloadNetworkSegment: WorkloadNetworkSegment,
    options?: WorkloadNetworksCreateSegmentsOptionalParams,
  ): Promise<WorkloadNetworksCreateSegmentsResponse> {
    const poller = await this.beginCreateSegments(
      resourceGroupName,
      privateCloudName,
      segmentId,
      workloadNetworkSegment,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Update a WorkloadNetworkSegment
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId The ID of the NSX Segment
   * @param workloadNetworkSegment The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateSegments(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    workloadNetworkSegment: WorkloadNetworkSegment,
    options?: WorkloadNetworksUpdateSegmentsOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksUpdateSegmentsResponse>,
      WorkloadNetworksUpdateSegmentsResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksUpdateSegmentsResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        segmentId,
        workloadNetworkSegment,
        options,
      },
      spec: updateSegmentsOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksUpdateSegmentsResponse,
      OperationState<WorkloadNetworksUpdateSegmentsResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update a WorkloadNetworkSegment
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId The ID of the NSX Segment
   * @param workloadNetworkSegment The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateSegmentsAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    workloadNetworkSegment: WorkloadNetworkSegment,
    options?: WorkloadNetworksUpdateSegmentsOptionalParams,
  ): Promise<WorkloadNetworksUpdateSegmentsResponse> {
    const poller = await this.beginUpdateSegments(
      resourceGroupName,
      privateCloudName,
      segmentId,
      workloadNetworkSegment,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a WorkloadNetworkSegment
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId The ID of the NSX Segment
   * @param options The options parameters.
   */
  async beginDeleteSegment(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    options?: WorkloadNetworksDeleteSegmentOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, privateCloudName, segmentId, options },
      spec: deleteSegmentOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Delete a WorkloadNetworkSegment
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param segmentId The ID of the NSX Segment
   * @param options The options parameters.
   */
  async beginDeleteSegmentAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    segmentId: string,
    options?: WorkloadNetworksDeleteSegmentOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteSegment(
      resourceGroupName,
      privateCloudName,
      segmentId,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * List WorkloadNetworkVirtualMachine resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listVirtualMachines(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVirtualMachinesOptionalParams,
  ): Promise<WorkloadNetworksListVirtualMachinesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listVirtualMachinesOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkVirtualMachine
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param virtualMachineId ID of the virtual machine.
   * @param options The options parameters.
   */
  getVirtualMachine(
    resourceGroupName: string,
    privateCloudName: string,
    virtualMachineId: string,
    options?: WorkloadNetworksGetVirtualMachineOptionalParams,
  ): Promise<WorkloadNetworksGetVirtualMachineResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, virtualMachineId, options },
      getVirtualMachineOperationSpec,
    );
  }

  /**
   * List WorkloadNetworkVMGroup resources by WorkloadNetwork
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  private _listVMGroups(
    resourceGroupName: string,
    privateCloudName: string,
    options?: WorkloadNetworksListVMGroupsOptionalParams,
  ): Promise<WorkloadNetworksListVMGroupsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, options },
      listVMGroupsOperationSpec,
    );
  }

  /**
   * Get a WorkloadNetworkVMGroup
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId ID of the VM group.
   * @param options The options parameters.
   */
  getVMGroup(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    options?: WorkloadNetworksGetVMGroupOptionalParams,
  ): Promise<WorkloadNetworksGetVMGroupResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, vmGroupId, options },
      getVMGroupOperationSpec,
    );
  }

  /**
   * Create a WorkloadNetworkVMGroup
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId ID of the VM group.
   * @param workloadNetworkVMGroup Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateVMGroup(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    workloadNetworkVMGroup: WorkloadNetworkVMGroup,
    options?: WorkloadNetworksCreateVMGroupOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksCreateVMGroupResponse>,
      WorkloadNetworksCreateVMGroupResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksCreateVMGroupResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        vmGroupId,
        workloadNetworkVMGroup,
        options,
      },
      spec: createVMGroupOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksCreateVMGroupResponse,
      OperationState<WorkloadNetworksCreateVMGroupResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create a WorkloadNetworkVMGroup
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId ID of the VM group.
   * @param workloadNetworkVMGroup Resource create parameters.
   * @param options The options parameters.
   */
  async beginCreateVMGroupAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    workloadNetworkVMGroup: WorkloadNetworkVMGroup,
    options?: WorkloadNetworksCreateVMGroupOptionalParams,
  ): Promise<WorkloadNetworksCreateVMGroupResponse> {
    const poller = await this.beginCreateVMGroup(
      resourceGroupName,
      privateCloudName,
      vmGroupId,
      workloadNetworkVMGroup,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Update a WorkloadNetworkVMGroup
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId ID of the VM group.
   * @param workloadNetworkVMGroup The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateVMGroup(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    workloadNetworkVMGroup: WorkloadNetworkVMGroup,
    options?: WorkloadNetworksUpdateVMGroupOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<WorkloadNetworksUpdateVMGroupResponse>,
      WorkloadNetworksUpdateVMGroupResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<WorkloadNetworksUpdateVMGroupResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        privateCloudName,
        vmGroupId,
        workloadNetworkVMGroup,
        options,
      },
      spec: updateVMGroupOperationSpec,
    });
    const poller = await createHttpPoller<
      WorkloadNetworksUpdateVMGroupResponse,
      OperationState<WorkloadNetworksUpdateVMGroupResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update a WorkloadNetworkVMGroup
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param vmGroupId ID of the VM group.
   * @param workloadNetworkVMGroup The resource properties to be updated.
   * @param options The options parameters.
   */
  async beginUpdateVMGroupAndWait(
    resourceGroupName: string,
    privateCloudName: string,
    vmGroupId: string,
    workloadNetworkVMGroup: WorkloadNetworkVMGroup,
    options?: WorkloadNetworksUpdateVMGroupOptionalParams,
  ): Promise<WorkloadNetworksUpdateVMGroupResponse> {
    const poller = await this.beginUpdateVMGroup(
      resourceGroupName,
      privateCloudName,
      vmGroupId,
      workloadNetworkVMGroup,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Delete a WorkloadNetworkVMGroup
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param vmGroupId ID of the VM group.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteVMGroup(
    resourceGroupName: string,
    vmGroupId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteVMGroupOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, vmGroupId, privateCloudName, options },
      spec: deleteVMGroupOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Delete a WorkloadNetworkVMGroup
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param vmGroupId ID of the VM group.
   * @param privateCloudName Name of the private cloud
   * @param options The options parameters.
   */
  async beginDeleteVMGroupAndWait(
    resourceGroupName: string,
    vmGroupId: string,
    privateCloudName: string,
    options?: WorkloadNetworksDeleteVMGroupOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteVMGroup(
      resourceGroupName,
      vmGroupId,
      privateCloudName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * ListNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the List method.
   * @param options The options parameters.
   */
  private _listNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListNextOptionalParams,
  ): Promise<WorkloadNetworksListNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listNextOperationSpec,
    );
  }

  /**
   * ListDhcpNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListDhcp method.
   * @param options The options parameters.
   */
  private _listDhcpNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListDhcpNextOptionalParams,
  ): Promise<WorkloadNetworksListDhcpNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listDhcpNextOperationSpec,
    );
  }

  /**
   * ListDnsServicesNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListDnsServices method.
   * @param options The options parameters.
   */
  private _listDnsServicesNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListDnsServicesNextOptionalParams,
  ): Promise<WorkloadNetworksListDnsServicesNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listDnsServicesNextOperationSpec,
    );
  }

  /**
   * ListDnsZonesNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListDnsZones method.
   * @param options The options parameters.
   */
  private _listDnsZonesNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListDnsZonesNextOptionalParams,
  ): Promise<WorkloadNetworksListDnsZonesNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listDnsZonesNextOperationSpec,
    );
  }

  /**
   * ListGatewaysNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListGateways method.
   * @param options The options parameters.
   */
  private _listGatewaysNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListGatewaysNextOptionalParams,
  ): Promise<WorkloadNetworksListGatewaysNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listGatewaysNextOperationSpec,
    );
  }

  /**
   * ListPortMirroringNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListPortMirroring method.
   * @param options The options parameters.
   */
  private _listPortMirroringNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListPortMirroringNextOptionalParams,
  ): Promise<WorkloadNetworksListPortMirroringNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listPortMirroringNextOperationSpec,
    );
  }

  /**
   * ListPublicIPsNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListPublicIPs method.
   * @param options The options parameters.
   */
  private _listPublicIPsNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListPublicIPsNextOptionalParams,
  ): Promise<WorkloadNetworksListPublicIPsNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listPublicIPsNextOperationSpec,
    );
  }

  /**
   * ListSegmentsNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListSegments method.
   * @param options The options parameters.
   */
  private _listSegmentsNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListSegmentsNextOptionalParams,
  ): Promise<WorkloadNetworksListSegmentsNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listSegmentsNextOperationSpec,
    );
  }

  /**
   * ListVirtualMachinesNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListVirtualMachines method.
   * @param options The options parameters.
   */
  private _listVirtualMachinesNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListVirtualMachinesNextOptionalParams,
  ): Promise<WorkloadNetworksListVirtualMachinesNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listVirtualMachinesNextOperationSpec,
    );
  }

  /**
   * ListVMGroupsNext
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param privateCloudName Name of the private cloud
   * @param nextLink The nextLink from the previous successful call to the ListVMGroups method.
   * @param options The options parameters.
   */
  private _listVMGroupsNext(
    resourceGroupName: string,
    privateCloudName: string,
    nextLink: string,
    options?: WorkloadNetworksListVMGroupsNextOptionalParams,
  ): Promise<WorkloadNetworksListVMGroupsNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, privateCloudName, nextLink, options },
      listVMGroupsNextOperationSpec,
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetwork,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listDhcpOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcpList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getDhcpOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dhcpId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createDhcpOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkDhcp,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dhcpId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const updateDhcpOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDhcp,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkDhcp,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dhcpId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteDhcpOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dhcpId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listDnsServicesOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsServicesList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getDnsServiceOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsServiceId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createDnsServiceOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkDnsService,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsServiceId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const updateDnsServiceOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDnsService,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkDnsService,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsServiceId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteDnsServiceOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsServiceId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listDnsZonesOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZonesList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getDnsZoneOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsZoneId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createDnsZoneOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkDnsZone,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsZoneId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const updateDnsZoneOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkDnsZone,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkDnsZone,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsZoneId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteDnsZoneOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.dnsZoneId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listGatewaysOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkGatewayList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getGatewayOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways/{gatewayId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkGateway,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.gatewayId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listPortMirroringOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroringList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getPortMirroringOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.portMirroringId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createPortMirroringOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkPortMirroring,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.portMirroringId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const updatePortMirroringOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroring,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkPortMirroring,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.portMirroringId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deletePortMirroringOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.portMirroringId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listPublicIPsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPublicIPsList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getPublicIPOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.publicIPId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createPublicIPOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkPublicIP,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkPublicIP,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.publicIPId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deletePublicIPOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.publicIPId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listSegmentsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegmentsList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSegmentOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.segmentId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createSegmentsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkSegment,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.segmentId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const updateSegmentsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkSegment,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkSegment,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.segmentId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteSegmentOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.segmentId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listVirtualMachinesOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVirtualMachinesList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getVirtualMachineOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines/{virtualMachineId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVirtualMachine,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.virtualMachineId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listVMGroupsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroupsList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getVMGroupOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.vmGroupId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createVMGroupOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkVMGroup,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.vmGroupId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const updateVMGroupOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    201: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    202: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    204: {
      bodyMapper: Mappers.WorkloadNetworkVMGroup,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.workloadNetworkVMGroup,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.vmGroupId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteVMGroupOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
    Parameters.vmGroupId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listDhcpNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDhcpList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listDnsServicesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsServicesList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listDnsZonesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkDnsZonesList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listGatewaysNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkGatewayList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listPortMirroringNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPortMirroringList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listPublicIPsNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkPublicIPsList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listSegmentsNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkSegmentsList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listVirtualMachinesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVirtualMachinesList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listVMGroupsNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkloadNetworkVMGroupsList,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.nextLink,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.privateCloudName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
