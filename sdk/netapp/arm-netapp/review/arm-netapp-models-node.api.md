## API Report File for "@azure/arm-netapp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AcceptGrowCapacityPoolForShortTermCloneSplit = string;

// @public
export interface AccountEncryption {
    identity?: EncryptionIdentity;
    keySource?: KeySource;
    keyVaultProperties?: KeyVaultProperties;
}

// @public
export interface AccountProperties {
    activeDirectories?: ActiveDirectory[];
    readonly disableShowmount?: boolean | null;
    encryption?: AccountEncryption;
    ldapConfiguration?: LdapConfiguration;
    readonly multiAdStatus?: MultiAdStatus;
    nfsV4IDDomain?: string | null;
    readonly provisioningState?: string;
}

// @public
export interface ActiveDirectory {
    activeDirectoryId?: string | null;
    administrators?: string[];
    adName?: string;
    aesEncryption?: boolean;
    allowLocalNfsUsersWithLdap?: boolean;
    backupOperators?: string[];
    dns?: string;
    domain?: string;
    encryptDCConnections?: boolean;
    kdcIP?: string;
    ldapOverTLS?: boolean;
    ldapSearchScope?: LdapSearchScopeOpt;
    ldapSigning?: boolean;
    organizationalUnit?: string;
    password?: string;
    preferredServersForLdapClient?: string;
    securityOperators?: string[];
    serverRootCACertificate?: string;
    site?: string;
    smbServerName?: string;
    readonly status?: ActiveDirectoryStatus;
    readonly statusDetails?: string;
    username?: string;
}

// @public
export interface ActiveDirectoryConfig extends TrackedResource {
    readonly etag?: string;
    identity?: ManagedServiceIdentity;
    properties?: ActiveDirectoryConfigProperties;
}

// @public
export interface ActiveDirectoryConfigProperties {
    readonly activeDirectoryStatus?: ActiveDirectoryStatus;
    administrators?: string[];
    backupOperators?: string[];
    dns?: string[];
    domain: string;
    organizationalUnit?: string;
    readonly provisioningState?: NetAppProvisioningState;
    secretPassword: SecretPassword;
    securityOperators?: string[];
    site?: string;
    smbServerName?: string;
    userName?: string;
}

// @public
export interface ActiveDirectoryConfigUpdate {
    identity?: ManagedServiceIdentity;
    properties?: ActiveDirectoryConfigUpdateProperties;
    tags?: Record<string, string>;
}

// @public
export interface ActiveDirectoryConfigUpdateProperties {
    administrators?: string[];
    backupOperators?: string[];
    dns?: string[];
    domain?: string;
    organizationalUnit?: string;
    secretPassword?: SecretPassword;
    securityOperators?: string[];
    site?: string;
    smbServerName?: string;
    userName?: string;
}

// @public
export type ActiveDirectoryStatus = string;

// @public
export type ActualRansomwareProtectionState = string;

// @public
export type ApplicationType = string;

// @public
export interface AuthorizeRequest {
    remoteVolumeResourceId?: string;
}

// @public
export type AvsDataStore = string;

// @public
export interface Backup extends ProxyResource {
    properties: BackupProperties;
}

// @public
export interface BackupPatch {
    properties?: BackupPatchProperties;
}

// @public
export interface BackupPatchProperties {
    label?: string;
}

// @public
export interface BackupPolicy extends TrackedResource {
    readonly etag?: string;
    properties: BackupPolicyProperties;
}

// @public
export interface BackupPolicyPatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: BackupPolicyProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export interface BackupPolicyProperties {
    readonly backupPolicyId?: string;
    dailyBackupsToKeep?: number;
    enabled?: boolean;
    monthlyBackupsToKeep?: number;
    readonly provisioningState?: string;
    readonly volumeBackups?: VolumeBackups[];
    readonly volumesAssigned?: number;
    weeklyBackupsToKeep?: number;
}

// @public
export interface BackupProperties {
    readonly backupId?: string;
    readonly backupPolicyResourceId?: string;
    readonly backupType?: BackupType;
    readonly completionDate?: Date | null;
    readonly creationDate?: Date;
    readonly failureReason?: string;
    readonly isLargeVolume?: boolean;
    label?: string;
    readonly provisioningState?: string;
    readonly size?: number;
    readonly snapshotCreationDate?: Date | null;
    snapshotName?: string;
    useExistingSnapshot?: boolean;
    volumeResourceId: string;
}

// @public
export interface BackupRestoreFiles {
    destinationVolumeId: string;
    fileList: string[];
    restoreFilePath?: string;
}

// @public
export interface BackupsMigrationRequest {
    backupVaultId: string;
}

// @public
export interface BackupStatus {
    readonly errorMessage?: string;
    readonly healthy?: boolean;
    readonly lastTransferSize?: number;
    readonly lastTransferType?: string;
    readonly mirrorState?: MirrorState;
    readonly relationshipStatus?: VolumeBackupRelationshipStatus;
    readonly totalTransferBytes?: number;
    readonly transferProgressBytes?: number;
    readonly unhealthyReason?: string;
}

// @public
export type BackupType = string;

// @public
export interface BackupVault extends TrackedResource {
    properties?: BackupVaultProperties;
}

// @public
export interface BackupVaultPatch {
    tags?: Record<string, string>;
}

// @public
export interface BackupVaultProperties {
    readonly provisioningState?: string;
}

// @public
export interface BreakFileLocksRequest {
    clientIp?: string;
    confirmRunningDisruptiveOperation?: boolean;
}

// @public
export interface BreakReplicationRequest {
    forceBreakReplication?: boolean;
}

// @public
export type BreakthroughMode = string;

// @public
export interface Bucket extends ProxyResource {
    properties?: BucketProperties;
}

// @public
export interface BucketCredentialsExpiry {
    keyPairExpiryDays?: number;
}

// @public
export interface BucketGenerateCredentials {
    readonly accessKey?: string;
    readonly keyPairExpiry?: Date;
    readonly secretKey?: string;
}

// @public
export interface BucketPatch extends ProxyResource {
    properties?: BucketPatchProperties;
}

// @public
export type BucketPatchPermissions = string;

// @public
export interface BucketPatchProperties {
    fileSystemUser?: FileSystemUser;
    path?: string;
    permissions?: BucketPatchPermissions;
    readonly provisioningState?: NetAppProvisioningState;
    server?: BucketServerPatchProperties;
}

// @public
export type BucketPermissions = string;

// @public
export interface BucketProperties {
    fileSystemUser?: FileSystemUser;
    path?: string;
    permissions?: BucketPermissions;
    readonly provisioningState?: NetAppProvisioningState;
    server?: BucketServerProperties;
    readonly status?: CredentialsStatus;
}

// @public
export interface BucketServerPatchProperties {
    certificateObject?: string;
    fqdn?: string;
}

// @public
export interface BucketServerProperties {
    readonly certificateCommonName?: string;
    readonly certificateExpiryDate?: Date;
    certificateObject?: string;
    fqdn?: string;
    readonly ipAddress?: string;
}

// @public
export interface Cache extends TrackedResource {
    readonly etag?: string;
    properties: CacheProperties;
    zones?: string[];
}

// @public
export type CacheLifeCycleState = string;

// @public
export interface CacheMountTargetProperties {
    readonly ipAddress?: string;
    readonly mountTargetId?: string;
    readonly smbServerFqdn?: string;
}

// @public
export interface CacheProperties {
    readonly actualThroughputMibps?: number;
    readonly cacheState?: CacheLifeCycleState;
    cacheSubnetResourceId: string;
    cifsChangeNotifications?: CifsChangeNotifyState;
    readonly encryption?: EncryptionState;
    encryptionKeySource: EncryptionKeySource;
    exportPolicy?: ExportPolicyRule[];
    filepath: string;
    globalFileLocking?: GlobalFileLockingState;
    kerberos?: KerberosState;
    keyVaultPrivateEndpointResourceId?: string;
    readonly language?: VolumeLanguage;
    ldap?: LdapState;
    ldapServerType?: LdapServerType;
    readonly maximumNumberOfFiles?: number;
    readonly mountTargets?: CacheMountTargetProperties[];
    originClusterInformation: OriginClusterInformation;
    peeringSubnetResourceId: string;
    protocolTypes?: ProtocolTypes[];
    readonly provisioningState?: CacheProvisioningState;
    size: number;
    smbSettings?: SmbSettings;
    throughputMibps?: number;
    writeBack?: EnableWriteBackState;
}

// @public
export type CacheProvisioningState = string;

// @public
export interface CacheUpdate {
    properties?: CacheUpdateProperties;
    tags?: Record<string, string>;
}

// @public
export interface CacheUpdateProperties {
    cifsChangeNotifications?: CifsChangeNotifyState;
    exportPolicy?: ExportPolicyRule[];
    keyVaultPrivateEndpointResourceId?: string;
    protocolTypes?: ProtocolTypes[];
    size?: number;
    smbSettings?: SmbSettings;
    throughputMibps?: number;
    writeBack?: EnableWriteBackState;
}

// @public
export interface CapacityPool extends TrackedResource {
    readonly etag?: string;
    properties: PoolProperties;
}

// @public
export interface CapacityPoolPatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: PoolPatchProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export interface ChangeKeyVault {
    keyName: string;
    keyVaultPrivateEndpoints: KeyVaultPrivateEndpoint[];
    keyVaultResourceId?: string;
    keyVaultUri: string;
}

// @public
export interface ChangeZoneRequest {
    newZone: string;
}

// @public
export interface CheckAvailabilityResponse {
    isAvailable?: boolean;
    message?: string;
    reason?: InAvailabilityReasonType;
}

// @public
export type CheckElasticResourceAvailabilityReason = string;

// @public
export interface CheckElasticResourceAvailabilityResponse {
    isAvailable?: CheckElasticResourceAvailabilityStatus;
    message?: string;
    reason?: CheckElasticResourceAvailabilityReason;
}

// @public
export type CheckElasticResourceAvailabilityStatus = string;

// @public
export interface CheckElasticVolumeFilePathAvailabilityRequest {
    filePath: string;
}

// @public
export type CheckNameResourceTypes = string;

// @public
export type CheckQuotaNameResourceTypes = string;

// @public
export type ChownMode = string;

// @public
export type CifsChangeNotifyState = string;

// @public
export interface CifsUser {
    username?: string;
}

// @public
export interface ClusterPeerCommandResponse {
    peerAcceptCommand?: string;
}

// @public
export type CoolAccessRetrievalPolicy = string;

// @public
export type CoolAccessTieringPolicy = string;

// @public
export type CreatedByType = string;

// @public
export type CredentialsStatus = string;

// @public
export interface DailySchedule {
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export type DayOfWeek = string;

// @public
export type DesiredRansomwareProtectionState = string;

// @public
export interface DestinationReplication {
    region?: string;
    replicationType?: ReplicationType;
    resourceId?: string;
    zone?: string;
}

// @public
export interface Dimension {
    displayName?: string;
    name?: string;
}

// @public
export interface ElasticAccount extends TrackedResource {
    readonly eTag?: string;
    identity?: ManagedServiceIdentity;
    properties?: ElasticAccountProperties;
}

// @public
export interface ElasticAccountProperties {
    encryption?: ElasticEncryption;
    readonly provisioningState?: NetAppProvisioningState;
}

// @public
export interface ElasticAccountUpdate {
    identity?: ManagedServiceIdentity;
    properties?: ElasticAccountUpdateProperties;
    tags?: Record<string, string>;
}

// @public
export interface ElasticAccountUpdateProperties {
    encryption?: ElasticEncryption;
}

// @public
export interface ElasticBackup extends ProxyResource {
    properties?: ElasticBackupProperties;
}

// @public
export interface ElasticBackupPolicy extends TrackedResource {
    readonly eTag?: string;
    properties?: ElasticBackupPolicyProperties;
}

// @public
export interface ElasticBackupPolicyProperties {
    readonly assignedVolumesCount?: number;
    dailyBackupsToKeep?: number;
    monthlyBackupsToKeep?: number;
    policyState?: ElasticBackupPolicyState;
    readonly provisioningState?: NetAppProvisioningState;
    weeklyBackupsToKeep?: number;
}

// @public
export type ElasticBackupPolicyState = string;

// @public
export interface ElasticBackupPolicyUpdate {
    properties?: ElasticBackupPolicyUpdateProperties;
    tags?: Record<string, string>;
}

// @public
export interface ElasticBackupPolicyUpdateProperties {
    dailyBackupsToKeep?: number;
    monthlyBackupsToKeep?: number;
    policyState?: ElasticBackupPolicyState;
    weeklyBackupsToKeep?: number;
}

// @public
export interface ElasticBackupProperties {
    readonly backupType?: ElasticBackupType;
    readonly completionDate?: Date;
    readonly creationDate?: Date;
    readonly elasticBackupPolicyResourceId?: string;
    elasticSnapshotResourceId?: string;
    elasticVolumeResourceId: string;
    readonly failureReason?: string;
    label?: string;
    readonly provisioningState?: NetAppProvisioningState;
    readonly size?: number;
    readonly snapshotCreationDate?: Date;
    snapshotUsage?: SnapshotUsage;
    readonly volumeSize?: VolumeSize;
}

// @public
export type ElasticBackupType = string;

// @public
export interface ElasticBackupVault extends TrackedResource {
    readonly eTag?: string;
    properties?: ElasticBackupVaultProperties;
}

// @public
export interface ElasticBackupVaultProperties {
    readonly provisioningState?: NetAppProvisioningState;
}

// @public
export interface ElasticBackupVaultUpdate {
    tags?: Record<string, string>;
}

// @public
export interface ElasticCapacityPool extends TrackedResource {
    readonly eTag?: string;
    properties?: ElasticCapacityPoolProperties;
    zones?: string[];
}

// @public
export interface ElasticCapacityPoolProperties {
    activeDirectoryConfigResourceId?: string;
    readonly availabilityStatus?: ElasticResourceAvailabilityStatus;
    readonly currentZone?: string;
    encryption?: ElasticEncryptionConfiguration;
    readonly provisioningState?: NetAppProvisioningState;
    serviceLevel: ElasticServiceLevel;
    size: number;
    subnetResourceId: string;
    readonly totalThroughputMibps?: number;
}

// @public
export interface ElasticCapacityPoolUpdate {
    properties?: ElasticCapacityPoolUpdateProperties;
    tags?: Record<string, string>;
}

// @public
export interface ElasticCapacityPoolUpdateProperties {
    activeDirectoryConfigResourceId?: string;
    encryption?: ElasticEncryptionConfiguration;
    size?: number;
}

// @public
export interface ElasticEncryption {
    identity?: ElasticEncryptionIdentity;
    keySource?: KeySource;
    keyVaultProperties?: ElasticKeyVaultProperties;
}

// @public
export interface ElasticEncryptionConfiguration {
    elasticPoolEncryptionKeySource: ElasticPoolEncryptionKeySource;
    keyVaultPrivateEndpointResourceId: string;
}

// @public
export interface ElasticEncryptionIdentity {
    readonly principalId?: string;
    userAssignedIdentity?: string;
}

// @public
export interface ElasticExportPolicy {
    rules?: ElasticExportPolicyRule[];
}

// @public
export interface ElasticExportPolicyRule {
    allowedClients?: string[];
    nfsv3?: ElasticNfsv3Access;
    nfsv4?: ElasticNfsv4Access;
    rootAccess?: ElasticRootAccess;
    ruleIndex?: number;
    unixAccessRule?: ElasticUnixAccessRule;
}

// @public
export interface ElasticKeyVaultProperties {
    keyName?: string;
    keyVaultResourceId?: string;
    keyVaultUri?: string;
    readonly status?: ElasticKeyVaultStatus;
}

// @public
export type ElasticKeyVaultStatus = string;

// @public
export interface ElasticMountTargetProperties {
    readonly ipAddress?: string;
    readonly smbServerFqdn?: string;
}

// @public
export type ElasticNfsv3Access = string;

// @public
export type ElasticNfsv4Access = string;

// @public
export type ElasticPoolEncryptionKeySource = string;

// @public
export type ElasticProtocolType = string;

// @public
export type ElasticResourceAvailabilityStatus = string;

// @public
export type ElasticRootAccess = string;

// @public
export type ElasticServiceLevel = string;

// @public
export type ElasticSmbEncryption = string;

// @public
export interface ElasticSmbPatchProperties {
    smbEncryption?: ElasticSmbEncryption;
}

// @public
export interface ElasticSmbProperties {
    smbEncryption?: ElasticSmbEncryption;
}

// @public
export interface ElasticSnapshot extends ProxyResource {
    properties?: ElasticSnapshotProperties;
}

// @public
export interface ElasticSnapshotPolicy extends TrackedResource {
    readonly eTag?: string;
    properties?: ElasticSnapshotPolicyProperties;
}

// @public
export interface ElasticSnapshotPolicyDailySchedule {
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
}

// @public
export interface ElasticSnapshotPolicyHourlySchedule {
    minute?: number;
    snapshotsToKeep?: number;
}

// @public
export interface ElasticSnapshotPolicyMonthlySchedule {
    daysOfMonth?: number[];
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
}

// @public
export interface ElasticSnapshotPolicyProperties {
    dailySchedule?: ElasticSnapshotPolicyDailySchedule;
    hourlySchedule?: ElasticSnapshotPolicyHourlySchedule;
    monthlySchedule?: ElasticSnapshotPolicyMonthlySchedule;
    policyStatus?: PolicyStatus;
    readonly provisioningState?: NetAppProvisioningState;
    weeklySchedule?: ElasticSnapshotPolicyWeeklySchedule;
}

// @public
export interface ElasticSnapshotPolicyUpdate {
    properties?: ElasticSnapshotPolicyUpdateProperties;
    tags?: Record<string, string>;
}

// @public
export interface ElasticSnapshotPolicyUpdateProperties {
    dailySchedule?: ElasticSnapshotPolicyDailySchedule;
    hourlySchedule?: ElasticSnapshotPolicyHourlySchedule;
    monthlySchedule?: ElasticSnapshotPolicyMonthlySchedule;
    policyStatus?: PolicyStatus;
    weeklySchedule?: ElasticSnapshotPolicyWeeklySchedule;
}

// @public
export interface ElasticSnapshotPolicyWeeklySchedule {
    days?: DayOfWeek[];
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
}

// @public
export interface ElasticSnapshotProperties {
    readonly provisioningState?: NetAppProvisioningState;
}

// @public
export type ElasticUnixAccessRule = string;

// @public
export interface ElasticVolume extends TrackedResource {
    readonly eTag?: string;
    properties?: ElasticVolumeProperties;
    zones?: string[];
}

// @public
export interface ElasticVolumeBackupProperties {
    elasticBackupPolicyResourceId?: string;
    elasticBackupVaultResourceId?: string;
    policyEnforcement?: ElasticVolumePolicyEnforcement;
}

// @public
export interface ElasticVolumeDataProtectionPatchProperties {
    backup?: ElasticVolumeBackupProperties;
    snapshot?: ElasticVolumeSnapshotProperties;
}

// @public
export interface ElasticVolumeDataProtectionProperties {
    backup?: ElasticVolumeBackupProperties;
    snapshot?: ElasticVolumeSnapshotProperties;
}

// @public
export type ElasticVolumePolicyEnforcement = string;

// @public
export interface ElasticVolumeProperties {
    readonly availabilityStatus?: ElasticResourceAvailabilityStatus;
    backupResourceId?: string;
    dataProtection?: ElasticVolumeDataProtectionProperties;
    exportPolicy?: ElasticExportPolicy;
    filePath: string;
    readonly mountTargets?: ElasticMountTargetProperties[];
    protocolTypes: ElasticProtocolType[];
    readonly provisioningState?: NetAppProvisioningState;
    readonly restorationState?: ElasticVolumeRestorationState;
    size: number;
    smbProperties?: ElasticSmbProperties;
    snapshotDirectoryVisibility?: SnapshotDirectoryVisibility;
    snapshotResourceId?: string;
}

// @public
export type ElasticVolumeRestorationState = string;

// @public
export interface ElasticVolumeRevert {
    snapshotResourceId?: string;
}

// @public
export interface ElasticVolumeSnapshotProperties {
    snapshotPolicyResourceId?: string;
}

// @public
export interface ElasticVolumeUpdate {
    properties?: ElasticVolumeUpdateProperties;
    tags?: Record<string, string>;
}

// @public
export interface ElasticVolumeUpdateProperties {
    dataProtection?: ElasticVolumeDataProtectionPatchProperties;
    exportPolicy?: ElasticExportPolicy;
    size?: number;
    smbProperties?: ElasticSmbPatchProperties;
    snapshotDirectoryVisibility?: SnapshotDirectoryVisibility;
}

// @public
export type EnableSubvolumes = string;

// @public
export type EnableWriteBackState = string;

// @public
export interface EncryptionIdentity {
    federatedClientId?: string;
    readonly principalId?: string;
    userAssignedIdentity?: string;
}

// @public
export type EncryptionKeySource = string;

// @public
export type EncryptionState = string;

// @public
export interface EncryptionTransitionRequest {
    privateEndpointId: string;
    virtualNetworkId: string;
}

// @public
export type EncryptionType = string;

// @public
export type EndpointType = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: any;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
type Exclude_2 = string;
export { Exclude_2 as Exclude }

// @public
export interface ExportPolicyRule {
    allowedClients?: string;
    chownMode?: ChownMode;
    cifs?: boolean;
    hasRootAccess?: boolean;
    kerberos5IReadOnly?: boolean;
    kerberos5IReadWrite?: boolean;
    kerberos5PReadOnly?: boolean;
    kerberos5PReadWrite?: boolean;
    kerberos5ReadOnly?: boolean;
    kerberos5ReadWrite?: boolean;
    nfsv3?: boolean;
    nfsv41?: boolean;
    ruleIndex?: number;
    unixReadOnly?: boolean;
    unixReadWrite?: boolean;
}

// @public
export type ExternalReplicationSetupStatus = string;

// @public
export type FileAccessLogs = string;

// @public
export interface FilePathAvailabilityRequest {
    availabilityZone?: string | null;
    name: string;
    subnetId: string;
}

// @public
export interface FileSystemUser {
    cifsUser?: CifsUser;
    nfsUser?: NfsUser;
}

// @public
export interface GetGroupIdListForLdapUserRequest {
    username: string;
}

// @public
export interface GetGroupIdListForLdapUserResponse {
    groupIdsForLdapUser?: string[];
}

// @public
export interface GetKeyVaultStatusResponse {
    properties?: GetKeyVaultStatusResponseProperties;
}

// @public
export interface GetKeyVaultStatusResponseProperties {
    keyName?: string;
    keyVaultPrivateEndpoints?: KeyVaultPrivateEndpoint[];
    keyVaultResourceId?: string;
    keyVaultUri?: string;
}

// @public
export type GlobalFileLockingState = string;

// @public
export interface HourlySchedule {
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export type InAvailabilityReasonType = string;

// @public
export type KerberosState = string;

// @public
export type KeySource = string;

// @public
export interface KeyVaultPrivateEndpoint {
    privateEndpointId?: string;
    virtualNetworkId?: string;
}

// @public
export interface KeyVaultProperties {
    keyName: string;
    readonly keyVaultId?: string;
    keyVaultResourceId?: string;
    keyVaultUri: string;
    readonly status?: KeyVaultStatus;
}

// @public
export type KeyVaultStatus = string;

// @public
export enum KnownAcceptGrowCapacityPoolForShortTermCloneSplit {
    Accepted = "Accepted",
    Declined = "Declined"
}

// @public
export enum KnownActiveDirectoryStatus {
    Created = "Created",
    Deleted = "Deleted",
    Error = "Error",
    InUse = "InUse",
    Updating = "Updating"
}

// @public
export enum KnownActualRansomwareProtectionState {
    Disabled = "Disabled",
    Enabled = "Enabled",
    Learning = "Learning",
    Paused = "Paused"
}

// @public
export enum KnownApplicationType {
    Oracle = "ORACLE",
    SAPHana = "SAP-HANA"
}

// @public
export enum KnownAvsDataStore {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownBackupType {
    Manual = "Manual",
    Scheduled = "Scheduled"
}

// @public
export enum KnownBreakthroughMode {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownBucketPatchPermissions {
    ReadOnly = "ReadOnly",
    ReadWrite = "ReadWrite"
}

// @public
export enum KnownBucketPermissions {
    ReadOnly = "ReadOnly",
    ReadWrite = "ReadWrite"
}

// @public
export enum KnownCacheLifeCycleState {
    ClusterPeeringOfferSent = "ClusterPeeringOfferSent",
    Creating = "Creating",
    Failed = "Failed",
    Succeeded = "Succeeded",
    VserverPeeringOfferSent = "VserverPeeringOfferSent"
}

// @public
export enum KnownCacheProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownCheckElasticResourceAvailabilityReason {
    AlreadyExists = "AlreadyExists",
    Invalid = "Invalid"
}

// @public
export enum KnownCheckElasticResourceAvailabilityStatus {
    False = "False",
    True = "True"
}

// @public
export enum KnownCheckNameResourceTypes {
    MicrosoftNetAppNetAppAccounts = "Microsoft.NetApp/netAppAccounts",
    MicrosoftNetAppNetAppAccountsBackupVaultsBackups = "Microsoft.NetApp/netAppAccounts/backupVaults/backups",
    MicrosoftNetAppNetAppAccountsCapacityPools = "Microsoft.NetApp/netAppAccounts/capacityPools",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesBackups = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/backups",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots"
}

// @public
export enum KnownCheckQuotaNameResourceTypes {
    MicrosoftNetAppNetAppAccounts = "Microsoft.NetApp/netAppAccounts",
    MicrosoftNetAppNetAppAccountsBackupVaultsBackups = "Microsoft.NetApp/netAppAccounts/backupVaults/backups",
    MicrosoftNetAppNetAppAccountsCapacityPools = "Microsoft.NetApp/netAppAccounts/capacityPools",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesBackups = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/backups",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots"
}

// @public
export enum KnownChownMode {
    Restricted = "Restricted",
    Unrestricted = "Unrestricted"
}

// @public
export enum KnownCifsChangeNotifyState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownCoolAccessRetrievalPolicy {
    Default = "Default",
    Never = "Never",
    OnRead = "OnRead"
}

// @public
export enum KnownCoolAccessTieringPolicy {
    Auto = "Auto",
    SnapshotOnly = "SnapshotOnly"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownCredentialsStatus {
    Active = "Active",
    CredentialsExpired = "CredentialsExpired",
    NoCredentialsSet = "NoCredentialsSet"
}

// @public
export enum KnownDayOfWeek {
    Friday = "Friday",
    Monday = "Monday",
    Saturday = "Saturday",
    Sunday = "Sunday",
    Thursday = "Thursday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday"
}

// @public
export enum KnownDesiredRansomwareProtectionState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownElasticBackupPolicyState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownElasticBackupType {
    Manual = "Manual",
    Scheduled = "Scheduled"
}

// @public
export enum KnownElasticKeyVaultStatus {
    Created = "Created",
    Deleted = "Deleted",
    Error = "Error",
    InUse = "InUse",
    Updating = "Updating"
}

// @public
export enum KnownElasticNfsv3Access {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownElasticNfsv4Access {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownElasticPoolEncryptionKeySource {
    KeyVault = "KeyVault",
    NetApp = "NetApp"
}

// @public
export enum KnownElasticProtocolType {
    NFSv3 = "NFSv3",
    NFSv4 = "NFSv4",
    SMB = "SMB"
}

// @public
export enum KnownElasticResourceAvailabilityStatus {
    Offline = "Offline",
    Online = "Online"
}

// @public
export enum KnownElasticRootAccess {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownElasticServiceLevel {
    ZoneRedundant = "ZoneRedundant"
}

// @public
export enum KnownElasticSmbEncryption {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownElasticUnixAccessRule {
    NoAccess = "NoAccess",
    ReadOnly = "ReadOnly",
    ReadWrite = "ReadWrite"
}

// @public
export enum KnownElasticVolumePolicyEnforcement {
    Enforced = "Enforced",
    NotEnforced = "NotEnforced"
}

// @public
export enum KnownElasticVolumeRestorationState {
    Failed = "Failed",
    Restored = "Restored",
    Restoring = "Restoring"
}

// @public
export enum KnownEnableSubvolumes {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownEnableWriteBackState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownEncryptionKeySource {
    MicrosoftKeyVault = "Microsoft.KeyVault",
    MicrosoftNetApp = "Microsoft.NetApp"
}

// @public
export enum KnownEncryptionState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownEncryptionType {
    Double = "Double",
    Single = "Single"
}

// @public
export enum KnownEndpointType {
    Dst = "dst",
    Src = "src"
}

// @public
export enum KnownExclude {
    Deleted = "Deleted",
    None = "None"
}

// @public
export enum KnownExternalReplicationSetupStatus {
    ClusterPeerPending = "ClusterPeerPending",
    ClusterPeerRequired = "ClusterPeerRequired",
    NoActionRequired = "NoActionRequired",
    ReplicationCreateRequired = "ReplicationCreateRequired",
    VServerPeerRequired = "VServerPeerRequired"
}

// @public
export enum KnownFileAccessLogs {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownGlobalFileLockingState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownInAvailabilityReasonType {
    AlreadyExists = "AlreadyExists",
    Invalid = "Invalid"
}

// @public
export enum KnownKerberosState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownKeySource {
    MicrosoftKeyVault = "Microsoft.KeyVault",
    MicrosoftNetApp = "Microsoft.NetApp"
}

// @public
export enum KnownKeyVaultStatus {
    Created = "Created",
    Deleted = "Deleted",
    Error = "Error",
    InUse = "InUse",
    Updating = "Updating"
}

// @public
export enum KnownLargeVolumeType {
    ExtraLargeVolume7Dot2PiB = "PremExtraLargeVolume7Dot2PiB",
    LargeVolume = "LargeVolume"
}

// @public
export enum KnownLdapServerType {
    ActiveDirectory = "ActiveDirectory",
    OpenLdap = "OpenLDAP"
}

// @public
export enum KnownLdapState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownMetricAggregationType {
    Average = "Average"
}

// @public
export enum KnownMirrorState {
    Broken = "Broken",
    Mirrored = "Mirrored",
    Uninitialized = "Uninitialized"
}

// @public
export enum KnownMultiAdStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownNetAppProvisioningState {
    Accepted = "Accepted",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Moving = "Moving",
    Patching = "Patching",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownNetworkFeatures {
    Basic = "Basic",
    BasicStandard = "Basic_Standard",
    Standard = "Standard",
    StandardBasic = "Standard_Basic"
}

// @public
export enum KnownNetworkSiblingSetProvisioningState {
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownPolicyStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownProtocolTypes {
    NFSv3 = "NFSv3",
    NFSv4 = "NFSv4",
    SMB = "SMB"
}

// @public
export enum KnownQosType {
    Auto = "Auto",
    Manual = "Manual"
}

// @public
export enum KnownRansomwareReportSeverity {
    High = "High",
    Low = "Low",
    Moderate = "Moderate",
    None = "None"
}

// @public
export enum KnownRansomwareReportState {
    Active = "Active",
    Resolved = "Resolved"
}

// @public
export enum KnownRansomwareSuspectResolution {
    FalsePositive = "FalsePositive",
    PotentialThreat = "PotentialThreat"
}

// @public
export enum KnownRegionStorageToNetworkProximity {
    AcrossT2 = "AcrossT2",
    Default = "Default",
    T1 = "T1",
    T1AndAcrossT2 = "T1AndAcrossT2",
    T1AndT2 = "T1AndT2",
    T1AndT2AndAcrossT2 = "T1AndT2AndAcrossT2",
    T2 = "T2",
    T2AndAcrossT2 = "T2AndAcrossT2"
}

// @public
export enum KnownReplicationMirrorState {
    Broken = "Broken",
    Mirrored = "Mirrored",
    Uninitialized = "Uninitialized"
}

// @public
export enum KnownReplicationSchedule {
    "10Minutely" = "_10minutely",
    Daily = "daily",
    Hourly = "hourly"
}

// @public
export enum KnownReplicationType {
    CrossRegionReplication = "CrossRegionReplication",
    CrossZoneReplication = "CrossZoneReplication"
}

// @public
export enum KnownSecurityStyle {
    Ntfs = "ntfs",
    Unix = "unix"
}

// @public
export enum KnownServiceLevel {
    Flexible = "Flexible",
    Premium = "Premium",
    Standard = "Standard",
    StandardZRS = "StandardZRS",
    Ultra = "Ultra"
}

// @public
export enum KnownSmbAccessBasedEnumeration {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownSmbEncryptionState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownSmbNonBrowsable {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownSnapshotDirectoryVisibility {
    Hidden = "Hidden",
    Visible = "Visible"
}

// @public
export enum KnownSnapshotUsage {
    CreateNewSnapshot = "CreateNewSnapshot",
    UseExistingSnapshot = "UseExistingSnapshot"
}

// @public
export enum KnownType {
    DefaultGroupQuota = "DefaultGroupQuota",
    DefaultUserQuota = "DefaultUserQuota",
    IndividualGroupQuota = "IndividualGroupQuota",
    IndividualUserQuota = "IndividualUserQuota"
}

// @public
export enum KnownVersions {
    V20250601 = "2025-06-01",
    V20250701Preview = "2025-07-01-preview",
    V20250801 = "2025-08-01",
    V20250801Preview = "2025-08-01-preview",
    V20250901 = "2025-09-01",
    V20250901Preview = "2025-09-01-preview"
}

// @public
export enum KnownVolumeBackupRelationshipStatus {
    Failed = "Failed",
    Idle = "Idle",
    Transferring = "Transferring",
    Unknown = "Unknown"
}

// @public
export enum KnownVolumeLanguage {
    Ar = "ar",
    ArUtf8 = "ar.utf-8",
    C = "c",
    Cs = "cs",
    CsUtf8 = "cs.utf-8",
    CUtf8 = "c.utf-8",
    Da = "da",
    DaUtf8 = "da.utf-8",
    De = "de",
    DeUtf8 = "de.utf-8",
    En = "en",
    EnUs = "en-us",
    EnUsUtf8 = "en-us.utf-8",
    EnUtf8 = "en.utf-8",
    Es = "es",
    EsUtf8 = "es.utf-8",
    Fi = "fi",
    FiUtf8 = "fi.utf-8",
    Fr = "fr",
    FrUtf8 = "fr.utf-8",
    He = "he",
    HeUtf8 = "he.utf-8",
    Hr = "hr",
    HrUtf8 = "hr.utf-8",
    Hu = "hu",
    HuUtf8 = "hu.utf-8",
    It = "it",
    ItUtf8 = "it.utf-8",
    Ja = "ja",
    JaJp932 = "ja-jp.932",
    JaJp932Utf8 = "ja-jp.932.utf-8",
    JaJpPck = "ja-jp.pck",
    JaJpPckUtf8 = "ja-jp.pck.utf-8",
    JaJpPckV2 = "ja-jp.pck-v2",
    JaJpPckV2Utf8 = "ja-jp.pck-v2.utf-8",
    JaUtf8 = "ja.utf-8",
    JaV1 = "ja-v1",
    JaV1Utf8 = "ja-v1.utf-8",
    Ko = "ko",
    KoUtf8 = "ko.utf-8",
    Nl = "nl",
    NlUtf8 = "nl.utf-8",
    No = "no",
    NoUtf8 = "no.utf-8",
    Pl = "pl",
    PlUtf8 = "pl.utf-8",
    Pt = "pt",
    PtUtf8 = "pt.utf-8",
    Ro = "ro",
    RoUtf8 = "ro.utf-8",
    Ru = "ru",
    RuUtf8 = "ru.utf-8",
    Sk = "sk",
    SkUtf8 = "sk.utf-8",
    Sl = "sl",
    SlUtf8 = "sl.utf-8",
    Sv = "sv",
    SvUtf8 = "sv.utf-8",
    Tr = "tr",
    TrUtf8 = "tr.utf-8",
    Utf8Mb4 = "utf8mb4",
    Zh = "zh",
    ZhGbk = "zh.gbk",
    ZhGbkUtf8 = "zh.gbk.utf-8",
    ZhTw = "zh-tw",
    ZhTwBig5 = "zh-tw.big5",
    ZhTwBig5Utf8 = "zh-tw.big5.utf-8",
    ZhTwUtf8 = "zh-tw.utf-8",
    ZhUtf8 = "zh.utf-8"
}

// @public
export enum KnownVolumeReplicationRelationshipStatus {
    Idle = "Idle",
    Transferring = "Transferring"
}

// @public
export enum KnownVolumeRestoreRelationshipStatus {
    Failed = "Failed",
    Idle = "Idle",
    Transferring = "Transferring",
    Unknown = "Unknown"
}

// @public
export enum KnownVolumeSize {
    Large = "Large",
    Regular = "Regular"
}

// @public
export enum KnownVolumeStorageToNetworkProximity {
    AcrossT2 = "AcrossT2",
    Default = "Default",
    T1 = "T1",
    T2 = "T2"
}

// @public
export type LargeVolumeType = string;

// @public
export interface LdapConfiguration {
    certificateCNHost?: string | null;
    domain?: string;
    ldapOverTLS?: boolean;
    ldapServers?: string[];
    serverCACertificate?: string;
}

// @public
export interface LdapSearchScopeOpt {
    groupDN?: string;
    groupMembershipFilter?: string;
    userDN?: string;
}

// @public
export type LdapServerType = string;

// @public
export type LdapState = string;

// @public
export interface ListQuotaReportResponse {
    value?: QuotaReport[];
}

// @public
export interface ListReplicationsRequest {
    exclude?: Exclude_2;
}

// @public
export interface LogSpecification {
    displayName?: string;
    name?: string;
}

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentity | null>;
}

// @public
export type ManagedServiceIdentityType = string;

// @public
export type MetricAggregationType = string;

// @public
export interface MetricSpecification {
    aggregationType?: string;
    category?: string;
    dimensions?: Dimension[];
    displayDescription?: string;
    displayName?: string;
    enableRegionalMdmAccount?: boolean;
    fillGapWithZero?: boolean;
    internalMetricName?: string;
    isInternal?: boolean;
    name?: string;
    resourceIdDimensionNameOverride?: string;
    sourceMdmAccount?: string;
    sourceMdmNamespace?: string;
    supportedAggregationTypes?: MetricAggregationType[];
    supportedTimeGrainTypes?: string[];
    unit?: string;
}

// @public
export type MirrorState = string;

// @public
export interface MonthlySchedule {
    daysOfMonth?: string;
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export interface MountTargetProperties {
    fileSystemId: string;
    readonly ipAddress?: string;
    readonly mountTargetId?: string;
    smbServerFqdn?: string;
}

// @public
export type MultiAdStatus = string;

// @public
export interface NetAppAccount extends TrackedResource {
    readonly etag?: string;
    identity?: ManagedServiceIdentity;
    properties?: AccountProperties;
}

// @public
export interface NetAppAccountPatch {
    readonly id?: string;
    identity?: ManagedServiceIdentity;
    location?: string;
    readonly name?: string;
    properties?: AccountProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export type NetAppProvisioningState = string;

// @public
export type NetworkFeatures = string;

// @public
export interface NetworkSiblingSet {
    networkFeatures?: NetworkFeatures;
    networkSiblingSetId?: string;
    networkSiblingSetStateId?: string;
    nicInfoList?: NicInfo[];
    readonly provisioningState?: NetworkSiblingSetProvisioningState;
    subnetId?: string;
}

// @public
export type NetworkSiblingSetProvisioningState = string;

// @public
export interface NfsUser {
    groupId?: number;
    userId?: number;
}

// @public
export interface NicInfo {
    readonly ipAddress?: string;
    volumeResourceIds?: string[];
}

// @public
export interface Operation {
    display?: OperationDisplay;
    name?: string;
    origin?: string;
    properties?: OperationProperties;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationProperties {
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface OriginClusterInformation {
    peerAddresses: string[];
    peerClusterName: string;
    peerVolumeName: string;
    peerVserverName: string;
}

// @public
export interface PeerClusterForVolumeMigrationRequest {
    peerIpAddresses: string[];
}

// @public
export interface PeeringPassphrases {
    clusterPeeringCommand: string;
    clusterPeeringPassphrase: string;
    vserverPeeringCommand: string;
}

// @public
export interface PlacementKeyValuePairs {
    key: string;
    value: string;
}

// @public
export type PolicyStatus = string;

// @public
export interface PoolChangeRequest {
    newPoolResourceId: string;
}

// @public
export interface PoolPatchProperties {
    coolAccess?: boolean;
    customThroughputMibps?: number | null;
    qosType?: QosType;
    size?: number;
}

// @public
export interface PoolProperties {
    coolAccess?: boolean;
    customThroughputMibps?: number | null;
    encryptionType?: EncryptionType | null;
    readonly poolId?: string;
    readonly provisioningState?: string;
    qosType?: QosType;
    serviceLevel: ServiceLevel;
    size: number;
    readonly totalThroughputMibps?: number;
    readonly utilizedThroughputMibps?: number;
}

// @public
export type ProtocolTypes = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export type QosType = string;

// @public
export interface QueryNetworkSiblingSetRequest {
    networkSiblingSetId: string;
    subnetId: string;
}

// @public
export interface QuotaAvailabilityRequest {
    name: string;
    resourceGroup: string;
    type: CheckQuotaNameResourceTypes;
}

// @public
export interface QuotaItem extends ProxyResource {
    properties?: QuotaItemProperties;
}

// @public
export interface QuotaItemProperties {
    readonly current?: number;
    readonly default?: number;
    readonly usage?: number | null;
}

// @public
export interface QuotaReport {
    isDerivedQuota?: boolean;
    percentageUsed?: number;
    quotaLimitTotalInKiBs?: number;
    quotaLimitUsedInKiBs?: number;
    quotaTarget?: string;
    quotaType?: Type;
}

// @public
export interface RansomwareProtectionPatchSettings {
    desiredRansomwareProtectionState?: DesiredRansomwareProtectionState;
}

// @public
export interface RansomwareProtectionSettings {
    readonly actualRansomwareProtectionState?: ActualRansomwareProtectionState;
    desiredRansomwareProtectionState?: DesiredRansomwareProtectionState;
}

// @public
export interface RansomwareReport extends ProxyResource {
    properties?: RansomwareReportProperties;
}

// @public
export interface RansomwareReportProperties {
    readonly clearedCount?: number;
    readonly eventTime?: Date;
    readonly provisioningState?: string;
    readonly reportedCount?: number;
    readonly severity?: RansomwareReportSeverity;
    readonly state?: RansomwareReportState;
    readonly suspects?: RansomwareSuspects[];
}

// @public
export type RansomwareReportSeverity = string;

// @public
export type RansomwareReportState = string;

// @public
export type RansomwareSuspectResolution = string;

// @public
export interface RansomwareSuspects {
    readonly extension?: string;
    readonly fileCount?: number;
    readonly resolution?: RansomwareSuspectResolution;
    readonly suspectFiles?: SuspectFile[];
}

// @public
export interface RansomwareSuspectsClearRequest {
    extensions: string[];
    resolution: RansomwareSuspectResolution;
}

// @public
export interface ReestablishReplicationRequest {
    sourceVolumeId?: string;
}

// @public
export interface RegionInfo {
    availabilityZoneMappings?: RegionInfoAvailabilityZoneMappingsItem[];
    storageToNetworkProximity?: RegionStorageToNetworkProximity;
}

// @public
export interface RegionInfoAvailabilityZoneMappingsItem {
    availabilityZone?: string;
    isAvailable?: boolean;
}

// @public
export interface RegionInfoResource extends ProxyResource {
    properties?: RegionInfo;
}

// @public
export type RegionStorageToNetworkProximity = string;

// @public
export interface RelocateVolumeRequest {
    creationToken?: string;
}

// @public
export interface RemotePath {
    externalHostName: string;
    serverName: string;
    volumeName: string;
}

// @public
export interface Replication {
    endpointType?: EndpointType;
    readonly mirrorState?: ReplicationMirrorState;
    remoteVolumeRegion?: string;
    remoteVolumeResourceId: string;
    readonly replicationCreationTime?: Date;
    readonly replicationDeletionTime?: Date;
    readonly replicationId?: string;
    replicationSchedule?: ReplicationSchedule;
}

// @public
export type ReplicationMirrorState = string;

// @public
export interface ReplicationObject {
    readonly destinationReplications?: DestinationReplication[];
    readonly endpointType?: EndpointType;
    readonly externalReplicationSetupInfo?: string;
    readonly externalReplicationSetupStatus?: ExternalReplicationSetupStatus;
    readonly mirrorState?: MirrorState;
    readonly relationshipStatus?: VolumeReplicationRelationshipStatus;
    remotePath?: RemotePath;
    remoteVolumeRegion?: string;
    remoteVolumeResourceId?: string;
    readonly replicationId?: string;
    replicationSchedule?: ReplicationSchedule;
}

// @public
export type ReplicationSchedule = string;

// @public
export interface ReplicationStatus {
    errorMessage?: string;
    healthy?: boolean;
    mirrorState?: MirrorState;
    relationshipStatus?: VolumeReplicationRelationshipStatus;
    totalProgress?: string;
}

// @public
export type ReplicationType = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceNameAvailabilityRequest {
    name: string;
    resourceGroup: string;
    type: CheckNameResourceTypes;
}

// @public
export interface RestoreStatus {
    readonly errorMessage?: string;
    readonly healthy?: boolean;
    readonly mirrorState?: MirrorState;
    readonly relationshipStatus?: VolumeRestoreRelationshipStatus;
    readonly totalTransferBytes?: number;
    readonly unhealthyReason?: string;
}

// @public
export interface SecretPassword {
    identity?: SecretPasswordIdentity;
    keyVaultProperties?: SecretPasswordKeyVaultProperties;
}

// @public
export interface SecretPasswordIdentity {
    readonly principalId?: string;
    userAssignedIdentity?: string;
}

// @public
export interface SecretPasswordKeyVaultProperties {
    keyVaultUri: string;
    secretName: string;
}

// @public
export type SecurityStyle = string;

// @public
export type ServiceLevel = string;

// @public
export interface ServiceSpecification {
    logSpecifications?: LogSpecification[];
    metricSpecifications?: MetricSpecification[];
}

// @public
export type SmbAccessBasedEnumeration = string;

// @public
export type SmbEncryptionState = string;

// @public
export type SmbNonBrowsable = string;

// @public
export interface SmbSettings {
    smbAccessBasedEnumerations?: SmbAccessBasedEnumeration;
    smbEncryption?: SmbEncryptionState;
    smbNonBrowsable?: SmbNonBrowsable;
}

// @public
export interface Snapshot extends ProxyResource {
    location: string;
    properties?: SnapshotProperties;
}

// @public
export type SnapshotDirectoryVisibility = string;

// @public
export interface SnapshotPatch {
}

// @public
export interface SnapshotPolicy extends TrackedResource {
    readonly etag?: string;
    properties: SnapshotPolicyProperties;
}

// @public
export interface SnapshotPolicyPatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: SnapshotPolicyProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export interface SnapshotPolicyProperties {
    dailySchedule?: DailySchedule;
    enabled?: boolean;
    hourlySchedule?: HourlySchedule;
    monthlySchedule?: MonthlySchedule;
    readonly provisioningState?: string;
    weeklySchedule?: WeeklySchedule;
}

// @public
export interface SnapshotPolicyVolumeList {
    nextLink?: string;
    value: Volume[];
}

// @public
export interface SnapshotProperties {
    readonly created?: Date;
    readonly provisioningState?: string;
    readonly snapshotId?: string;
}

// @public
export interface SnapshotRestoreFiles {
    destinationPath?: string;
    filePaths: string[];
}

// @public
export type SnapshotUsage = string;

// @public
export interface SubvolumeInfo extends ProxyResource {
    properties?: SubvolumeProperties;
}

// @public
export interface SubvolumeModel {
    readonly id?: string;
    readonly name?: string;
    properties?: SubvolumeModelProperties;
    readonly type?: string;
}

// @public
export interface SubvolumeModelProperties {
    accessedTimeStamp?: Date;
    bytesUsed?: number;
    changedTimeStamp?: Date;
    creationTimeStamp?: Date;
    modifiedTimeStamp?: Date;
    parentPath?: string;
    path?: string;
    permissions?: string;
    provisioningState?: string;
    size?: number;
}

// @public
export interface SubvolumePatchParams {
    path?: string;
    size?: number | null;
}

// @public
export interface SubvolumePatchRequest {
    properties?: SubvolumePatchParams;
}

// @public
export interface SubvolumeProperties {
    parentPath?: string | null;
    path?: string;
    readonly provisioningState?: string;
    size?: number | null;
}

// @public
export interface SuspectFile {
    readonly fileTimestamp?: Date;
    readonly suspectFileName?: string;
}

// @public
export interface SvmPeerCommandResponse {
    svmPeeringCommand?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export type Type = string;

// @public
export interface UpdateNetworkSiblingSetRequest {
    networkFeatures: NetworkFeatures;
    networkSiblingSetId: string;
    networkSiblingSetStateId: string;
    subnetId: string;
}

// @public
export interface UsageName {
    localizedValue?: string;
    value?: string;
}

// @public
export interface UsageProperties {
    readonly currentValue?: number;
    readonly limit?: number;
    readonly unit?: string;
}

// @public
export interface UsageResult {
    readonly id?: string;
    readonly name?: UsageName;
    properties?: UsageProperties;
}

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface Volume extends TrackedResource {
    readonly etag?: string;
    properties: VolumeProperties;
    zones?: string[];
}

// @public
export interface VolumeBackupProperties {
    backupPolicyId?: string;
    backupVaultId?: string;
    policyEnforced?: boolean;
}

// @public
export type VolumeBackupRelationshipStatus = string;

// @public
export interface VolumeBackups {
    backupsCount?: number;
    policyEnabled?: boolean;
    volumeName?: string;
    volumeResourceId?: string;
}

// @public
export interface VolumeGroup {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: VolumeGroupListProperties;
    readonly type?: string;
}

// @public
export interface VolumeGroupDetails extends ProxyResource {
    location?: string;
    properties?: VolumeGroupProperties;
}

// @public
export interface VolumeGroupListProperties {
    groupMetaData?: VolumeGroupMetaData;
    readonly provisioningState?: string;
}

// @public
export interface VolumeGroupMetaData {
    applicationIdentifier?: string;
    applicationType?: ApplicationType;
    globalPlacementRules?: PlacementKeyValuePairs[];
    groupDescription?: string;
    readonly volumesCount?: number;
}

// @public
export interface VolumeGroupProperties {
    groupMetaData?: VolumeGroupMetaData;
    readonly provisioningState?: string;
    volumes?: VolumeGroupVolumeProperties[];
}

// @public
export interface VolumeGroupVolumeProperties {
    readonly id?: string;
    name?: string;
    properties: VolumeProperties;
    tags?: Record<string, string>;
    readonly type?: string;
    zones?: string[];
}

// @public
export type VolumeLanguage = string;

// @public
export interface VolumePatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: VolumePatchProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export interface VolumePatchProperties {
    coolAccess?: boolean;
    coolAccessRetrievalPolicy?: CoolAccessRetrievalPolicy;
    coolAccessTieringPolicy?: CoolAccessTieringPolicy;
    coolnessPeriod?: number;
    dataProtection?: VolumePatchPropertiesDataProtection;
    defaultGroupQuotaInKiBs?: number;
    defaultUserQuotaInKiBs?: number;
    exportPolicy?: VolumePatchPropertiesExportPolicy;
    isDefaultQuotaEnabled?: boolean;
    protocolTypes?: string[];
    serviceLevel?: ServiceLevel;
    smbAccessBasedEnumeration?: SmbAccessBasedEnumeration | null;
    smbNonBrowsable?: SmbNonBrowsable;
    snapshotDirectoryVisible?: boolean;
    throughputMibps?: number;
    unixPermissions?: string | null;
    usageThreshold?: number;
}

// @public
export interface VolumePatchPropertiesDataProtection {
    backup?: VolumeBackupProperties;
    ransomwareProtection?: RansomwareProtectionPatchSettings;
    snapshot?: VolumeSnapshotProperties;
}

// @public
export interface VolumePatchPropertiesExportPolicy {
    rules?: ExportPolicyRule[];
}

// @public
export interface VolumeProperties {
    acceptGrowCapacityPoolForShortTermCloneSplit?: AcceptGrowCapacityPoolForShortTermCloneSplit;
    readonly actualThroughputMibps?: number;
    avsDataStore?: AvsDataStore;
    backupId?: string | null;
    readonly baremetalTenantId?: string;
    breakthroughMode?: BreakthroughMode;
    capacityPoolResourceId?: string;
    readonly cloneProgress?: number | null;
    coolAccess?: boolean;
    coolAccessRetrievalPolicy?: CoolAccessRetrievalPolicy;
    coolAccessTieringPolicy?: CoolAccessTieringPolicy;
    coolnessPeriod?: number;
    creationToken: string;
    dataProtection?: VolumePropertiesDataProtection;
    readonly dataStoreResourceId?: string[];
    defaultGroupQuotaInKiBs?: number;
    defaultUserQuotaInKiBs?: number;
    deleteBaseSnapshot?: boolean;
    readonly effectiveNetworkFeatures?: NetworkFeatures;
    enableSubvolumes?: EnableSubvolumes;
    readonly encrypted?: boolean;
    encryptionKeySource?: EncryptionKeySource;
    exportPolicy?: VolumePropertiesExportPolicy;
    readonly fileAccessLogs?: FileAccessLogs;
    readonly fileSystemId?: string;
    readonly inheritedSizeInBytes?: number | null;
    isDefaultQuotaEnabled?: boolean;
    isLargeVolume?: boolean;
    readonly isRestoring?: boolean;
    kerberosEnabled?: boolean;
    keyVaultPrivateEndpointResourceId?: string;
    language?: VolumeLanguage;
    largeVolumeType?: LargeVolumeType;
    ldapEnabled?: boolean;
    ldapServerType?: LdapServerType;
    readonly maximumNumberOfFiles?: number;
    readonly mountTargets?: MountTargetProperties[];
    networkFeatures?: NetworkFeatures;
    readonly networkSiblingSetId?: string;
    readonly originatingResourceId?: string | null;
    placementRules?: PlacementKeyValuePairs[];
    protocolTypes?: string[];
    readonly provisionedAvailabilityZone?: string | null;
    readonly provisioningState?: string;
    proximityPlacementGroup?: string;
    securityStyle?: SecurityStyle;
    serviceLevel?: ServiceLevel;
    smbAccessBasedEnumeration?: SmbAccessBasedEnumeration | null;
    smbContinuouslyAvailable?: boolean;
    smbEncryption?: boolean;
    smbNonBrowsable?: SmbNonBrowsable;
    snapshotDirectoryVisible?: boolean;
    snapshotId?: string | null;
    readonly storageToNetworkProximity?: VolumeStorageToNetworkProximity;
    subnetId: string;
    readonly t2Network?: string;
    throughputMibps?: number | null;
    unixPermissions?: string | null;
    usageThreshold: number;
    readonly volumeGroupName?: string;
    volumeSpecName?: string;
    volumeType?: string;
}

// @public
export interface VolumePropertiesDataProtection {
    backup?: VolumeBackupProperties;
    ransomwareProtection?: RansomwareProtectionSettings;
    replication?: ReplicationObject;
    snapshot?: VolumeSnapshotProperties;
    volumeRelocation?: VolumeRelocationProperties;
}

// @public
export interface VolumePropertiesExportPolicy {
    rules?: ExportPolicyRule[];
}

// @public
export interface VolumeQuotaRule extends TrackedResource {
    properties?: VolumeQuotaRulesProperties;
}

// @public
export interface VolumeQuotaRulePatch {
    properties?: VolumeQuotaRulesProperties;
    tags?: Record<string, string>;
}

// @public
export interface VolumeQuotaRulesProperties {
    readonly provisioningState?: NetAppProvisioningState;
    quotaSizeInKiBs?: number;
    quotaTarget?: string;
    quotaType?: Type;
}

// @public
export interface VolumeRelocationProperties {
    readonly readyToBeFinalized?: boolean;
    relocationRequested?: boolean;
}

// @public
export type VolumeReplicationRelationshipStatus = string;

// @public
export type VolumeRestoreRelationshipStatus = string;

// @public
export interface VolumeRevert {
    snapshotId?: string;
}

// @public
export type VolumeSize = string;

// @public
export interface VolumeSnapshotProperties {
    snapshotPolicyId?: string;
}

// @public
export type VolumeStorageToNetworkProximity = string;

// @public
export interface WeeklySchedule {
    day?: string;
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// (No @packageDocumentation comment for this package)

```
