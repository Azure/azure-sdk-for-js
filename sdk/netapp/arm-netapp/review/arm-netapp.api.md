## API Report File for "@azure/arm-netapp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export interface AccountBackups {
    beginDelete(resourceGroupName: string, accountName: string, backupName: string, options?: AccountBackupsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, backupName: string, options?: AccountBackupsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, backupName: string, options?: AccountBackupsGetOptionalParams): Promise<AccountBackupsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: AccountBackupsListOptionalParams): PagedAsyncIterableIterator<Backup>;
}

// @public
export interface AccountBackupsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface AccountBackupsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountBackupsGetResponse = Backup;

// @public
export interface AccountBackupsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountBackupsListResponse = BackupsList;

// @public
export interface AccountEncryption {
    keySource?: string;
}

// @public
export interface Accounts {
    beginCreateOrUpdate(resourceGroupName: string, accountName: string, body: NetAppAccount, options?: AccountsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<AccountsCreateOrUpdateResponse>, AccountsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, accountName: string, body: NetAppAccount, options?: AccountsCreateOrUpdateOptionalParams): Promise<AccountsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, options?: AccountsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, options?: AccountsDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, body: NetAppAccountPatch, options?: AccountsUpdateOptionalParams): Promise<PollerLike<PollOperationState<AccountsUpdateResponse>, AccountsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, body: NetAppAccountPatch, options?: AccountsUpdateOptionalParams): Promise<AccountsUpdateResponse>;
    get(resourceGroupName: string, accountName: string, options?: AccountsGetOptionalParams): Promise<AccountsGetResponse>;
    list(resourceGroupName: string, options?: AccountsListOptionalParams): PagedAsyncIterableIterator<NetAppAccount>;
    listBySubscription(options?: AccountsListBySubscriptionOptionalParams): PagedAsyncIterableIterator<NetAppAccount>;
}

// @public
export interface AccountsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AccountsCreateOrUpdateResponse = NetAppAccount;

// @public
export interface AccountsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface AccountsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountsGetResponse = NetAppAccount;

// @public
export interface AccountsListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountsListBySubscriptionNextResponse = NetAppAccountList;

// @public
export interface AccountsListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountsListBySubscriptionResponse = NetAppAccountList;

// @public
export interface AccountsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountsListNextResponse = NetAppAccountList;

// @public
export interface AccountsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountsListResponse = NetAppAccountList;

// @public
export interface AccountsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AccountsUpdateResponse = NetAppAccount;

// @public
export interface ActiveDirectory {
    activeDirectoryId?: string;
    administrators?: string[];
    adName?: string;
    aesEncryption?: boolean;
    allowLocalNfsUsersWithLdap?: boolean;
    backupOperators?: string[];
    dns?: string;
    domain?: string;
    encryptDCConnections?: boolean;
    kdcIP?: string;
    ldapOverTLS?: boolean;
    ldapSearchScope?: LdapSearchScopeOpt;
    ldapSigning?: boolean;
    organizationalUnit?: string;
    password?: string;
    securityOperators?: string[];
    serverRootCACertificate?: string;
    site?: string;
    smbServerName?: string;
    readonly status?: ActiveDirectoryStatus;
    readonly statusDetails?: string;
    username?: string;
}

// @public
export type ActiveDirectoryStatus = string;

// @public
export type ApplicationType = string;

// @public
export interface AuthorizeRequest {
    remoteVolumeResourceId?: string;
}

// @public
export type AvsDataStore = string;

// @public
export interface Backup {
    readonly backupId?: string;
    readonly backupType?: BackupType;
    readonly creationDate?: Date;
    readonly failureReason?: string;
    readonly id?: string;
    label?: string;
    location: string;
    readonly name?: string;
    readonly provisioningState?: string;
    readonly size?: number;
    readonly type?: string;
    useExistingSnapshot?: boolean;
    readonly volumeName?: string;
}

// @public
export interface BackupPatch {
    readonly backupId?: string;
    readonly backupType?: BackupType;
    readonly creationDate?: Date;
    readonly failureReason?: string;
    label?: string;
    readonly provisioningState?: string;
    readonly size?: number;
    tags?: {
        [propertyName: string]: string;
    };
    useExistingSnapshot?: boolean;
    readonly volumeName?: string;
}

// @public
export interface BackupPolicies {
    beginCreate(resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicy, options?: BackupPoliciesCreateOptionalParams): Promise<PollerLike<PollOperationState<BackupPoliciesCreateResponse>, BackupPoliciesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicy, options?: BackupPoliciesCreateOptionalParams): Promise<BackupPoliciesCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, backupPolicyName: string, options?: BackupPoliciesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, backupPolicyName: string, options?: BackupPoliciesDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicyPatch, options?: BackupPoliciesUpdateOptionalParams): Promise<PollerLike<PollOperationState<BackupPoliciesUpdateResponse>, BackupPoliciesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicyPatch, options?: BackupPoliciesUpdateOptionalParams): Promise<BackupPoliciesUpdateResponse>;
    get(resourceGroupName: string, accountName: string, backupPolicyName: string, options?: BackupPoliciesGetOptionalParams): Promise<BackupPoliciesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: BackupPoliciesListOptionalParams): PagedAsyncIterableIterator<BackupPolicy>;
}

// @public
export interface BackupPoliciesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BackupPoliciesCreateResponse = BackupPolicy;

// @public
export interface BackupPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupPoliciesGetResponse = BackupPolicy;

// @public
export interface BackupPoliciesList {
    value?: BackupPolicy[];
}

// @public
export interface BackupPoliciesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupPoliciesListResponse = BackupPoliciesList;

// @public
export interface BackupPoliciesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BackupPoliciesUpdateResponse = BackupPolicy;

// @public
export type BackupPolicy = TrackedResource & {
    readonly etag?: string;
    readonly backupPolicyId?: string;
    readonly provisioningState?: string;
    dailyBackupsToKeep?: number;
    weeklyBackupsToKeep?: number;
    monthlyBackupsToKeep?: number;
    readonly volumesAssigned?: number;
    enabled?: boolean;
    readonly volumeBackups?: VolumeBackups[];
};

// @public
export interface BackupPolicyDetails {
    readonly backupPolicyId?: string;
    dailyBackupsToKeep?: number;
    enabled?: boolean;
    readonly id?: string;
    location?: string;
    monthlyBackupsToKeep?: number;
    readonly name?: string;
    readonly provisioningState?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
    readonly volumeBackups?: VolumeBackups[];
    readonly volumesAssigned?: number;
    weeklyBackupsToKeep?: number;
}

// @public
export interface BackupPolicyPatch {
    readonly backupPolicyId?: string;
    dailyBackupsToKeep?: number;
    enabled?: boolean;
    readonly id?: string;
    location?: string;
    monthlyBackupsToKeep?: number;
    readonly name?: string;
    readonly provisioningState?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
    readonly volumeBackups?: VolumeBackups[];
    readonly volumesAssigned?: number;
    weeklyBackupsToKeep?: number;
}

// @public
export interface Backups {
    beginCreate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, backupName: string, body: Backup, options?: BackupsCreateOptionalParams): Promise<PollerLike<PollOperationState<BackupsCreateResponse>, BackupsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, backupName: string, body: Backup, options?: BackupsCreateOptionalParams): Promise<BackupsCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, backupName: string, options?: BackupsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, backupName: string, options?: BackupsDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, backupName: string, options?: BackupsUpdateOptionalParams): Promise<PollerLike<PollOperationState<BackupsUpdateResponse>, BackupsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, backupName: string, options?: BackupsUpdateOptionalParams): Promise<BackupsUpdateResponse>;
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, backupName: string, options?: BackupsGetOptionalParams): Promise<BackupsGetResponse>;
    getStatus(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: BackupsGetStatusOptionalParams): Promise<BackupsGetStatusResponse>;
    getVolumeRestoreStatus(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: BackupsGetVolumeRestoreStatusOptionalParams): Promise<BackupsGetVolumeRestoreStatusResponse>;
    list(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: BackupsListOptionalParams): PagedAsyncIterableIterator<Backup>;
}

// @public
export interface BackupsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BackupsCreateResponse = Backup;

// @public
export interface BackupsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupsGetResponse = Backup;

// @public
export interface BackupsGetStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupsGetStatusResponse = BackupStatus;

// @public
export interface BackupsGetVolumeRestoreStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupsGetVolumeRestoreStatusResponse = RestoreStatus;

// @public
export interface BackupsList {
    value?: Backup[];
}

// @public
export interface BackupsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupsListResponse = BackupsList;

// @public
export interface BackupStatus {
    readonly errorMessage?: string;
    readonly healthy?: boolean;
    readonly lastTransferSize?: number;
    readonly lastTransferType?: string;
    readonly mirrorState?: MirrorState;
    readonly relationshipStatus?: RelationshipStatus;
    readonly totalTransferBytes?: number;
    readonly unhealthyReason?: string;
}

// @public
export interface BackupsUpdateOptionalParams extends coreClient.OperationOptions {
    body?: BackupPatch;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BackupsUpdateResponse = Backup;

// @public
export type BackupType = string;

// @public
export interface BreakReplicationRequest {
    forceBreakReplication?: boolean;
}

// @public
export type CapacityPool = TrackedResource & {
    readonly etag?: string;
    readonly poolId?: string;
    size: number;
    serviceLevel: ServiceLevel;
    readonly provisioningState?: string;
    readonly totalThroughputMibps?: number;
    readonly utilizedThroughputMibps?: number;
    qosType?: QosType;
    coolAccess?: boolean;
    encryptionType?: EncryptionType;
};

// @public
export interface CapacityPoolList {
    nextLink?: string;
    value?: CapacityPool[];
}

// @public
export interface CapacityPoolPatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    qosType?: QosType;
    size?: number;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export interface CheckAvailabilityResponse {
    isAvailable?: boolean;
    message?: string;
    reason?: InAvailabilityReasonType;
}

// @public
export type CheckNameResourceTypes = string;

// @public
export type CheckQuotaNameResourceTypes = string;

// @public
export type ChownMode = string;

// @public
export interface CloudError {
    error?: CloudErrorBody;
}

// @public
export interface CloudErrorBody {
    code?: string;
    message?: string;
}

// @public
export type CreatedByType = string;

// @public
export interface DailySchedule {
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export interface Dimension {
    displayName?: string;
    name?: string;
}

// @public
export type EnableSubvolumes = string;

// @public
export type EncryptionKeySource = string;

// @public
export type EncryptionType = string;

// @public
export type EndpointType = string;

// @public
export interface ExportPolicyRule {
    allowedClients?: string;
    chownMode?: ChownMode;
    cifs?: boolean;
    hasRootAccess?: boolean;
    kerberos5IReadOnly?: boolean;
    kerberos5IReadWrite?: boolean;
    kerberos5PReadOnly?: boolean;
    kerberos5PReadWrite?: boolean;
    kerberos5ReadOnly?: boolean;
    kerberos5ReadWrite?: boolean;
    nfsv3?: boolean;
    nfsv41?: boolean;
    ruleIndex?: number;
    unixReadOnly?: boolean;
    unixReadWrite?: boolean;
}

// @public
export interface FilePathAvailabilityRequest {
    name: string;
    subnetId: string;
}

// @public
export interface HourlySchedule {
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export type InAvailabilityReasonType = string;

// @public
export enum KnownActiveDirectoryStatus {
    Created = "Created",
    Deleted = "Deleted",
    Error = "Error",
    InUse = "InUse",
    Updating = "Updating"
}

// @public
export enum KnownApplicationType {
    // (undocumented)
    SAPHana = "SAP-HANA"
}

// @public
export enum KnownAvsDataStore {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownBackupType {
    Manual = "Manual",
    Scheduled = "Scheduled"
}

// @public
export enum KnownCheckNameResourceTypes {
    // (undocumented)
    MicrosoftNetAppNetAppAccounts = "Microsoft.NetApp/netAppAccounts",
    // (undocumented)
    MicrosoftNetAppNetAppAccountsCapacityPools = "Microsoft.NetApp/netAppAccounts/capacityPools",
    // (undocumented)
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes",
    // (undocumented)
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots"
}

// @public
export enum KnownCheckQuotaNameResourceTypes {
    // (undocumented)
    MicrosoftNetAppNetAppAccounts = "Microsoft.NetApp/netAppAccounts",
    // (undocumented)
    MicrosoftNetAppNetAppAccountsCapacityPools = "Microsoft.NetApp/netAppAccounts/capacityPools",
    // (undocumented)
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes",
    // (undocumented)
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots"
}

// @public
export enum KnownChownMode {
    // (undocumented)
    Restricted = "Restricted",
    // (undocumented)
    Unrestricted = "Unrestricted"
}

// @public
export enum KnownCreatedByType {
    // (undocumented)
    Application = "Application",
    // (undocumented)
    Key = "Key",
    // (undocumented)
    ManagedIdentity = "ManagedIdentity",
    // (undocumented)
    User = "User"
}

// @public
export enum KnownEnableSubvolumes {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownEncryptionKeySource {
    MicrosoftNetApp = "Microsoft.NetApp"
}

// @public
export enum KnownEncryptionType {
    Double = "Double",
    Single = "Single"
}

// @public
export enum KnownEndpointType {
    // (undocumented)
    Dst = "dst",
    // (undocumented)
    Src = "src"
}

// @public
export enum KnownInAvailabilityReasonType {
    // (undocumented)
    AlreadyExists = "AlreadyExists",
    // (undocumented)
    Invalid = "Invalid"
}

// @public
export enum KnownMetricAggregationType {
    // (undocumented)
    Average = "Average"
}

// @public
export enum KnownMirrorState {
    // (undocumented)
    Broken = "Broken",
    // (undocumented)
    Mirrored = "Mirrored",
    // (undocumented)
    Uninitialized = "Uninitialized"
}

// @public
export enum KnownNetworkFeatures {
    Basic = "Basic",
    Standard = "Standard"
}

// @public
export enum KnownQosType {
    Auto = "Auto",
    Manual = "Manual"
}

// @public
export enum KnownRelationshipStatus {
    // (undocumented)
    Idle = "Idle",
    // (undocumented)
    Transferring = "Transferring"
}

// @public
export enum KnownReplicationSchedule {
    // (undocumented)
    "10Minutely" = "_10minutely",
    // (undocumented)
    Daily = "daily",
    // (undocumented)
    Hourly = "hourly"
}

// @public
export enum KnownSecurityStyle {
    // (undocumented)
    Ntfs = "ntfs",
    // (undocumented)
    Unix = "unix"
}

// @public
export enum KnownServiceLevel {
    Premium = "Premium",
    Standard = "Standard",
    StandardZRS = "StandardZRS",
    Ultra = "Ultra"
}

// @public
export enum KnownType {
    DefaultGroupQuota = "DefaultGroupQuota",
    DefaultUserQuota = "DefaultUserQuota",
    IndividualGroupQuota = "IndividualGroupQuota",
    IndividualUserQuota = "IndividualUserQuota"
}

// @public
export enum KnownVolumeStorageToNetworkProximity {
    Default = "Default",
    T1 = "T1",
    T2 = "T2"
}

// @public
export interface LdapSearchScopeOpt {
    groupDN?: string;
    groupMembershipFilter?: string;
    userDN?: string;
}

// @public
export interface ListReplications {
    value?: Replication[];
}

// @public
export interface LogSpecification {
    displayName?: string;
    name?: string;
}

// @public
export type MetricAggregationType = string;

// @public
export interface MetricSpecification {
    aggregationType?: string;
    category?: string;
    dimensions?: Dimension[];
    displayDescription?: string;
    displayName?: string;
    enableRegionalMdmAccount?: boolean;
    fillGapWithZero?: boolean;
    internalMetricName?: string;
    isInternal?: boolean;
    name?: string;
    resourceIdDimensionNameOverride?: string;
    sourceMdmAccount?: string;
    sourceMdmNamespace?: string;
    supportedAggregationTypes?: MetricAggregationType[];
    supportedTimeGrainTypes?: string[];
    unit?: string;
}

// @public
export type MirrorState = string;

// @public
export interface MonthlySchedule {
    daysOfMonth?: string;
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export interface MountTarget {
    fileSystemId: string;
    readonly id?: string;
    readonly ipAddress?: string;
    location: string;
    readonly mountTargetId?: string;
    readonly name?: string;
    smbServerFqdn?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export interface MountTargetProperties {
    fileSystemId: string;
    readonly ipAddress?: string;
    readonly mountTargetId?: string;
    smbServerFqdn?: string;
}

// @public
export type NetAppAccount = TrackedResource & {
    readonly etag?: string;
    readonly provisioningState?: string;
    activeDirectories?: ActiveDirectory[];
    encryption?: AccountEncryption;
};

// @public
export interface NetAppAccountList {
    nextLink?: string;
    value?: NetAppAccount[];
}

// @public
export interface NetAppAccountPatch {
    activeDirectories?: ActiveDirectory[];
    encryption?: AccountEncryption;
    readonly id?: string;
    location?: string;
    readonly name?: string;
    readonly provisioningState?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public (undocumented)
export class NetAppManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: NetAppManagementClientOptionalParams);
    // (undocumented)
    accountBackups: AccountBackups;
    // (undocumented)
    accounts: Accounts;
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    backupPolicies: BackupPolicies;
    // (undocumented)
    backups: Backups;
    // (undocumented)
    netAppResource: NetAppResource;
    // (undocumented)
    netAppResourceQuotaLimits: NetAppResourceQuotaLimits;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    pools: Pools;
    // (undocumented)
    snapshotPolicies: SnapshotPolicies;
    // (undocumented)
    snapshots: Snapshots;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    subvolumes: Subvolumes;
    // (undocumented)
    vaults: Vaults;
    // (undocumented)
    volumeGroups: VolumeGroups;
    // (undocumented)
    volumeQuotaRules: VolumeQuotaRules;
    // (undocumented)
    volumes: Volumes;
}

// @public
export interface NetAppManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface NetAppResource {
    checkFilePathAvailability(location: string, name: string, subnetId: string, options?: NetAppResourceCheckFilePathAvailabilityOptionalParams): Promise<NetAppResourceCheckFilePathAvailabilityResponse>;
    checkNameAvailability(location: string, name: string, resourceGroup: string, typeParam: CheckNameResourceTypes, options?: NetAppResourceCheckNameAvailabilityOptionalParams): Promise<NetAppResourceCheckNameAvailabilityResponse>;
    checkQuotaAvailability(location: string, name: string, resourceGroup: string, typeParam: CheckQuotaNameResourceTypes, options?: NetAppResourceCheckQuotaAvailabilityOptionalParams): Promise<NetAppResourceCheckQuotaAvailabilityResponse>;
}

// @public
export interface NetAppResourceCheckFilePathAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetAppResourceCheckFilePathAvailabilityResponse = CheckAvailabilityResponse;

// @public
export interface NetAppResourceCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetAppResourceCheckNameAvailabilityResponse = CheckAvailabilityResponse;

// @public
export interface NetAppResourceCheckQuotaAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetAppResourceCheckQuotaAvailabilityResponse = CheckAvailabilityResponse;

// @public
export interface NetAppResourceQuotaLimits {
    get(location: string, quotaLimitName: string, options?: NetAppResourceQuotaLimitsGetOptionalParams): Promise<NetAppResourceQuotaLimitsGetResponse>;
    list(location: string, options?: NetAppResourceQuotaLimitsListOptionalParams): PagedAsyncIterableIterator<SubscriptionQuotaItem>;
}

// @public
export interface NetAppResourceQuotaLimitsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetAppResourceQuotaLimitsGetResponse = SubscriptionQuotaItem;

// @public
export interface NetAppResourceQuotaLimitsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetAppResourceQuotaLimitsListResponse = SubscriptionQuotaItemList;

// @public
export type NetworkFeatures = string;

// @public
export interface Operation {
    display?: OperationDisplay;
    name?: string;
    origin?: string;
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationListResult {
    value?: Operation[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface PlacementKeyValuePairs {
    key: string;
    value: string;
}

// @public
export interface PoolChangeRequest {
    newPoolResourceId: string;
}

// @public
export interface Pools {
    beginCreateOrUpdate(resourceGroupName: string, accountName: string, poolName: string, body: CapacityPool, options?: PoolsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<PoolsCreateOrUpdateResponse>, PoolsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, body: CapacityPool, options?: PoolsCreateOrUpdateOptionalParams): Promise<PoolsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, options?: PoolsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, options?: PoolsDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, body: CapacityPoolPatch, options?: PoolsUpdateOptionalParams): Promise<PollerLike<PollOperationState<PoolsUpdateResponse>, PoolsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, body: CapacityPoolPatch, options?: PoolsUpdateOptionalParams): Promise<PoolsUpdateResponse>;
    get(resourceGroupName: string, accountName: string, poolName: string, options?: PoolsGetOptionalParams): Promise<PoolsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: PoolsListOptionalParams): PagedAsyncIterableIterator<CapacityPool>;
}

// @public
export interface PoolsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PoolsCreateOrUpdateResponse = CapacityPool;

// @public
export interface PoolsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PoolsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PoolsGetResponse = CapacityPool;

// @public
export interface PoolsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PoolsListNextResponse = CapacityPoolList;

// @public
export interface PoolsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PoolsListResponse = CapacityPoolList;

// @public
export interface PoolsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PoolsUpdateResponse = CapacityPool;

// @public
export type ProvisioningState = "Accepted" | "Creating" | "Patching" | "Deleting" | "Moving" | "Failed" | "Succeeded";

// @public
export type ProxyResource = Resource;

// @public
export type QosType = string;

// @public
export interface QuotaAvailabilityRequest {
    name: string;
    resourceGroup: string;
    type: CheckQuotaNameResourceTypes;
}

// @public
export type RelationshipStatus = string;

// @public
export interface Replication {
    endpointType?: EndpointType;
    remoteVolumeRegion?: string;
    remoteVolumeResourceId: string;
    replicationSchedule?: ReplicationSchedule;
}

// @public
export interface ReplicationObject {
    endpointType?: EndpointType;
    remoteVolumeRegion?: string;
    remoteVolumeResourceId: string;
    replicationId?: string;
    replicationSchedule?: ReplicationSchedule;
}

// @public
export type ReplicationSchedule = string;

// @public
export interface ReplicationStatus {
    errorMessage?: string;
    healthy?: boolean;
    mirrorState?: MirrorState;
    relationshipStatus?: RelationshipStatus;
    totalProgress?: string;
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: string;
}

// @public
export interface ResourceNameAvailabilityRequest {
    name: string;
    resourceGroup: string;
    type: CheckNameResourceTypes;
}

// @public
export interface RestoreStatus {
    readonly errorMessage?: string;
    readonly healthy?: boolean;
    readonly mirrorState?: MirrorState;
    readonly relationshipStatus?: RelationshipStatus;
    readonly totalTransferBytes?: number;
    readonly unhealthyReason?: string;
}

// @public
export type SecurityStyle = string;

// @public
export type ServiceLevel = string;

// @public
export interface ServiceSpecification {
    logSpecifications?: LogSpecification[];
    metricSpecifications?: MetricSpecification[];
}

// @public
export interface Snapshot {
    readonly created?: Date;
    readonly id?: string;
    location: string;
    readonly name?: string;
    readonly provisioningState?: string;
    readonly snapshotId?: string;
    readonly type?: string;
}

// @public
export interface SnapshotPolicies {
    beginDelete(resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, snapshotPolicyName: string, body: SnapshotPolicyPatch, options?: SnapshotPoliciesUpdateOptionalParams): Promise<PollerLike<PollOperationState<SnapshotPoliciesUpdateResponse>, SnapshotPoliciesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, snapshotPolicyName: string, body: SnapshotPolicyPatch, options?: SnapshotPoliciesUpdateOptionalParams): Promise<SnapshotPoliciesUpdateResponse>;
    create(resourceGroupName: string, accountName: string, snapshotPolicyName: string, body: SnapshotPolicy, options?: SnapshotPoliciesCreateOptionalParams): Promise<SnapshotPoliciesCreateResponse>;
    get(resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesGetOptionalParams): Promise<SnapshotPoliciesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: SnapshotPoliciesListOptionalParams): PagedAsyncIterableIterator<SnapshotPolicy>;
    listVolumes(resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesListVolumesOptionalParams): Promise<SnapshotPoliciesListVolumesResponse>;
}

// @public
export interface SnapshotPoliciesCreateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotPoliciesCreateResponse = SnapshotPolicy;

// @public
export interface SnapshotPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotPoliciesGetResponse = SnapshotPolicy;

// @public
export interface SnapshotPoliciesList {
    value?: SnapshotPolicy[];
}

// @public
export interface SnapshotPoliciesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotPoliciesListResponse = SnapshotPoliciesList;

// @public
export interface SnapshotPoliciesListVolumesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotPoliciesListVolumesResponse = SnapshotPolicyVolumeList;

// @public
export interface SnapshotPoliciesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SnapshotPoliciesUpdateResponse = SnapshotPolicy;

// @public
export type SnapshotPolicy = TrackedResource & {
    readonly etag?: string;
    hourlySchedule?: HourlySchedule;
    dailySchedule?: DailySchedule;
    weeklySchedule?: WeeklySchedule;
    monthlySchedule?: MonthlySchedule;
    enabled?: boolean;
    readonly provisioningState?: string;
};

// @public
export interface SnapshotPolicyDetails {
    dailySchedule?: DailySchedule;
    enabled?: boolean;
    hourlySchedule?: HourlySchedule;
    readonly id?: string;
    location?: string;
    monthlySchedule?: MonthlySchedule;
    readonly name?: string;
    readonly provisioningState?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
    weeklySchedule?: WeeklySchedule;
}

// @public
export interface SnapshotPolicyPatch {
    dailySchedule?: DailySchedule;
    enabled?: boolean;
    hourlySchedule?: HourlySchedule;
    readonly id?: string;
    location?: string;
    monthlySchedule?: MonthlySchedule;
    readonly name?: string;
    readonly provisioningState?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
    weeklySchedule?: WeeklySchedule;
}

// @public
export interface SnapshotPolicyVolumeList {
    value?: Volume[];
}

// @public
export interface SnapshotRestoreFiles {
    destinationPath?: string;
    filePaths: string[];
}

// @public
export interface Snapshots {
    beginCreate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Snapshot, options?: SnapshotsCreateOptionalParams): Promise<PollerLike<PollOperationState<SnapshotsCreateResponse>, SnapshotsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Snapshot, options?: SnapshotsCreateOptionalParams): Promise<SnapshotsCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, options?: SnapshotsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, options?: SnapshotsDeleteOptionalParams): Promise<void>;
    beginRestoreFiles(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: SnapshotRestoreFiles, options?: SnapshotsRestoreFilesOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginRestoreFilesAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: SnapshotRestoreFiles, options?: SnapshotsRestoreFilesOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Record<string, unknown>, options?: SnapshotsUpdateOptionalParams): Promise<PollerLike<PollOperationState<SnapshotsUpdateResponse>, SnapshotsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Record<string, unknown>, options?: SnapshotsUpdateOptionalParams): Promise<SnapshotsUpdateResponse>;
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, options?: SnapshotsGetOptionalParams): Promise<SnapshotsGetResponse>;
    list(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: SnapshotsListOptionalParams): PagedAsyncIterableIterator<Snapshot>;
}

// @public
export interface SnapshotsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SnapshotsCreateResponse = Snapshot;

// @public
export interface SnapshotsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsGetResponse = Snapshot;

// @public
export interface SnapshotsList {
    value?: Snapshot[];
}

// @public
export interface SnapshotsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListResponse = SnapshotsList;

// @public
export interface SnapshotsRestoreFilesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SnapshotsUpdateResponse = Snapshot;

// @public
export type SubscriptionQuotaItem = ProxyResource & {
    readonly current?: number;
    readonly default?: number;
};

// @public
export interface SubscriptionQuotaItemList {
    value?: SubscriptionQuotaItem[];
}

// @public
export type SubvolumeInfo = ProxyResource & {
    path?: string;
    size?: number;
    parentPath?: string;
    readonly provisioningState?: string;
};

// @public
export interface SubvolumeModel {
    accessedTimeStamp?: Date;
    bytesUsed?: number;
    changedTimeStamp?: Date;
    creationTimeStamp?: Date;
    readonly id?: string;
    modifiedTimeStamp?: Date;
    readonly name?: string;
    parentPath?: string;
    path?: string;
    permissions?: string;
    provisioningState?: string;
    size?: number;
    readonly type?: string;
}

// @public
export interface SubvolumePatchRequest {
    path?: string;
    size?: number;
}

// @public
export interface Subvolumes {
    beginCreate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumeInfo, options?: SubvolumesCreateOptionalParams): Promise<PollerLike<PollOperationState<SubvolumesCreateResponse>, SubvolumesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumeInfo, options?: SubvolumesCreateOptionalParams): Promise<SubvolumesCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesDeleteOptionalParams): Promise<void>;
    beginGetMetadata(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesGetMetadataOptionalParams): Promise<PollerLike<PollOperationState<SubvolumesGetMetadataResponse>, SubvolumesGetMetadataResponse>>;
    beginGetMetadataAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesGetMetadataOptionalParams): Promise<SubvolumesGetMetadataResponse>;
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumePatchRequest, options?: SubvolumesUpdateOptionalParams): Promise<PollerLike<PollOperationState<SubvolumesUpdateResponse>, SubvolumesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumePatchRequest, options?: SubvolumesUpdateOptionalParams): Promise<SubvolumesUpdateResponse>;
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesGetOptionalParams): Promise<SubvolumesGetResponse>;
    listByVolume(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: SubvolumesListByVolumeOptionalParams): PagedAsyncIterableIterator<SubvolumeInfo>;
}

// @public
export interface SubvolumesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SubvolumesCreateResponse = SubvolumeInfo;

// @public
export interface SubvolumesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface SubvolumesGetMetadataOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SubvolumesGetMetadataResponse = SubvolumeModel;

// @public
export interface SubvolumesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SubvolumesGetResponse = SubvolumeInfo;

// @public
export interface SubvolumesList {
    nextLink?: string;
    value?: SubvolumeInfo[];
}

// @public
export interface SubvolumesListByVolumeNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SubvolumesListByVolumeNextResponse = SubvolumesList;

// @public
export interface SubvolumesListByVolumeOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SubvolumesListByVolumeResponse = SubvolumesList;

// @public
export interface SubvolumesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SubvolumesUpdateResponse = SubvolumeInfo;

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export type TrackedResource = Resource & {
    tags?: {
        [propertyName: string]: string;
    };
    location: string;
};

// @public
export type Type = string;

// @public
export interface Vault {
    readonly id?: string;
    location: string;
    readonly name?: string;
    readonly type?: string;
    vaultName?: string;
}

// @public
export interface VaultList {
    value?: Vault[];
}

// @public
export interface Vaults {
    list(resourceGroupName: string, accountName: string, options?: VaultsListOptionalParams): PagedAsyncIterableIterator<Vault>;
}

// @public
export interface VaultsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VaultsListResponse = VaultList;

// @public
export type Volume = TrackedResource & {
    readonly etag?: string;
    zones?: string[];
    readonly fileSystemId?: string;
    creationToken: string;
    serviceLevel?: ServiceLevel;
    usageThreshold: number;
    exportPolicy?: VolumePropertiesExportPolicy;
    protocolTypes?: string[];
    readonly provisioningState?: string;
    snapshotId?: string;
    backupId?: string;
    readonly baremetalTenantId?: string;
    subnetId: string;
    networkFeatures?: NetworkFeatures;
    readonly networkSiblingSetId?: string;
    readonly storageToNetworkProximity?: VolumeStorageToNetworkProximity;
    readonly mountTargets?: MountTargetProperties[];
    volumeType?: string;
    dataProtection?: VolumePropertiesDataProtection;
    isRestoring?: boolean;
    snapshotDirectoryVisible?: boolean;
    kerberosEnabled?: boolean;
    securityStyle?: SecurityStyle;
    smbEncryption?: boolean;
    smbContinuouslyAvailable?: boolean;
    throughputMibps?: number;
    encryptionKeySource?: EncryptionKeySource;
    ldapEnabled?: boolean;
    coolAccess?: boolean;
    coolnessPeriod?: number;
    unixPermissions?: string;
    readonly cloneProgress?: number;
    avsDataStore?: AvsDataStore;
    isDefaultQuotaEnabled?: boolean;
    defaultUserQuotaInKiBs?: number;
    defaultGroupQuotaInKiBs?: number;
    readonly maximumNumberOfFiles?: number;
    readonly volumeGroupName?: string;
    capacityPoolResourceId?: string;
    proximityPlacementGroup?: string;
    readonly t2Network?: string;
    volumeSpecName?: string;
    readonly encrypted?: boolean;
    placementRules?: PlacementKeyValuePairs[];
    enableSubvolumes?: EnableSubvolumes;
};

// @public
export interface VolumeBackupProperties {
    backupEnabled?: boolean;
    backupPolicyId?: string;
    policyEnforced?: boolean;
    vaultId?: string;
}

// @public
export interface VolumeBackups {
    backupsCount?: number;
    policyEnabled?: boolean;
    volumeName?: string;
}

// @public
export interface VolumeGroup {
    groupMetaData?: VolumeGroupMetaData;
    readonly id?: string;
    location?: string;
    readonly name?: string;
    readonly provisioningState?: string;
    readonly type?: string;
}

// @public
export interface VolumeGroupDetails {
    groupMetaData?: VolumeGroupMetaData;
    readonly id?: string;
    location?: string;
    readonly name?: string;
    readonly provisioningState?: string;
    readonly type?: string;
    volumes?: VolumeGroupVolumeProperties[];
}

// @public
export interface VolumeGroupList {
    value?: VolumeGroup[];
}

// @public
export interface VolumeGroupMetaData {
    applicationIdentifier?: string;
    applicationType?: ApplicationType;
    deploymentSpecId?: string;
    globalPlacementRules?: PlacementKeyValuePairs[];
    groupDescription?: string;
    readonly volumesCount?: number;
}

// @public
export interface VolumeGroups {
    beginCreate(resourceGroupName: string, accountName: string, volumeGroupName: string, body: VolumeGroupDetails, options?: VolumeGroupsCreateOptionalParams): Promise<PollerLike<PollOperationState<VolumeGroupsCreateResponse>, VolumeGroupsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, volumeGroupName: string, body: VolumeGroupDetails, options?: VolumeGroupsCreateOptionalParams): Promise<VolumeGroupsCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, volumeGroupName: string, options?: VolumeGroupsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, volumeGroupName: string, options?: VolumeGroupsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, volumeGroupName: string, options?: VolumeGroupsGetOptionalParams): Promise<VolumeGroupsGetResponse>;
    listByNetAppAccount(resourceGroupName: string, accountName: string, options?: VolumeGroupsListByNetAppAccountOptionalParams): PagedAsyncIterableIterator<VolumeGroup>;
}

// @public
export interface VolumeGroupsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumeGroupsCreateResponse = VolumeGroupDetails;

// @public
export interface VolumeGroupsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumeGroupsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumeGroupsGetResponse = VolumeGroupDetails;

// @public
export interface VolumeGroupsListByNetAppAccountOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumeGroupsListByNetAppAccountResponse = VolumeGroupList;

// @public
export interface VolumeGroupVolumeProperties {
    avsDataStore?: AvsDataStore;
    backupId?: string;
    readonly baremetalTenantId?: string;
    capacityPoolResourceId?: string;
    readonly cloneProgress?: number;
    coolAccess?: boolean;
    coolnessPeriod?: number;
    creationToken: string;
    dataProtection?: VolumePropertiesDataProtection;
    defaultGroupQuotaInKiBs?: number;
    defaultUserQuotaInKiBs?: number;
    enableSubvolumes?: EnableSubvolumes;
    readonly encrypted?: boolean;
    encryptionKeySource?: EncryptionKeySource;
    exportPolicy?: VolumePropertiesExportPolicy;
    readonly fileSystemId?: string;
    readonly id?: string;
    isDefaultQuotaEnabled?: boolean;
    isRestoring?: boolean;
    kerberosEnabled?: boolean;
    ldapEnabled?: boolean;
    readonly maximumNumberOfFiles?: number;
    readonly mountTargets?: MountTargetProperties[];
    name?: string;
    networkFeatures?: NetworkFeatures;
    readonly networkSiblingSetId?: string;
    placementRules?: PlacementKeyValuePairs[];
    protocolTypes?: string[];
    readonly provisioningState?: string;
    proximityPlacementGroup?: string;
    securityStyle?: SecurityStyle;
    serviceLevel?: ServiceLevel;
    smbContinuouslyAvailable?: boolean;
    smbEncryption?: boolean;
    snapshotDirectoryVisible?: boolean;
    snapshotId?: string;
    readonly storageToNetworkProximity?: VolumeStorageToNetworkProximity;
    subnetId: string;
    readonly t2Network?: string;
    tags?: {
        [propertyName: string]: string;
    };
    throughputMibps?: number;
    readonly type?: string;
    unixPermissions?: string;
    usageThreshold: number;
    readonly volumeGroupName?: string;
    volumeSpecName?: string;
    volumeType?: string;
}

// @public
export interface VolumeList {
    nextLink?: string;
    value?: Volume[];
}

// @public
export interface VolumePatch {
    dataProtection?: VolumePatchPropertiesDataProtection;
    defaultGroupQuotaInKiBs?: number;
    defaultUserQuotaInKiBs?: number;
    exportPolicy?: VolumePatchPropertiesExportPolicy;
    readonly id?: string;
    isDefaultQuotaEnabled?: boolean;
    location?: string;
    readonly name?: string;
    serviceLevel?: ServiceLevel;
    tags?: {
        [propertyName: string]: string;
    };
    throughputMibps?: number;
    readonly type?: string;
    unixPermissions?: string;
    usageThreshold?: number;
}

// @public
export interface VolumePatchPropertiesDataProtection {
    backup?: VolumeBackupProperties;
    snapshot?: VolumeSnapshotProperties;
}

// @public
export interface VolumePatchPropertiesExportPolicy {
    rules?: ExportPolicyRule[];
}

// @public
export interface VolumePropertiesDataProtection {
    backup?: VolumeBackupProperties;
    replication?: ReplicationObject;
    snapshot?: VolumeSnapshotProperties;
}

// @public
export interface VolumePropertiesExportPolicy {
    rules?: ExportPolicyRule[];
}

// @public
export type VolumeQuotaRule = TrackedResource & {
    readonly provisioningState?: ProvisioningState;
    quotaSizeInKiBs?: number;
    quotaType?: Type;
    quotaTarget?: string;
};

// @public
export interface VolumeQuotaRulePatch {
    readonly provisioningState?: ProvisioningState;
    quotaSizeInKiBs?: number;
    quotaTarget?: string;
    quotaType?: Type;
}

// @public
export interface VolumeQuotaRules {
    beginCreate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRule, options?: VolumeQuotaRulesCreateOptionalParams): Promise<PollerLike<PollOperationState<VolumeQuotaRulesCreateResponse>, VolumeQuotaRulesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRule, options?: VolumeQuotaRulesCreateOptionalParams): Promise<VolumeQuotaRulesCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, options?: VolumeQuotaRulesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, options?: VolumeQuotaRulesDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRulePatch, options?: VolumeQuotaRulesUpdateOptionalParams): Promise<PollerLike<PollOperationState<VolumeQuotaRulesUpdateResponse>, VolumeQuotaRulesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRulePatch, options?: VolumeQuotaRulesUpdateOptionalParams): Promise<VolumeQuotaRulesUpdateResponse>;
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, options?: VolumeQuotaRulesGetOptionalParams): Promise<VolumeQuotaRulesGetResponse>;
    listByVolume(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumeQuotaRulesListByVolumeOptionalParams): PagedAsyncIterableIterator<VolumeQuotaRule>;
}

// @public
export interface VolumeQuotaRulesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumeQuotaRulesCreateResponse = VolumeQuotaRule;

// @public
export interface VolumeQuotaRulesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumeQuotaRulesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumeQuotaRulesGetResponse = VolumeQuotaRule;

// @public
export interface VolumeQuotaRulesList {
    value?: VolumeQuotaRule[];
}

// @public
export interface VolumeQuotaRulesListByVolumeOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumeQuotaRulesListByVolumeResponse = VolumeQuotaRulesList;

// @public
export interface VolumeQuotaRulesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumeQuotaRulesUpdateResponse = VolumeQuotaRule;

// @public
export interface VolumeRelocationProperties {
    oldBareMetalTenantId?: string;
    oldVolumeId?: string;
    relocationRequested?: boolean;
}

// @public
export interface VolumeRevert {
    snapshotId?: string;
}

// @public
export interface Volumes {
    beginAuthorizeReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: AuthorizeRequest, options?: VolumesAuthorizeReplicationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginAuthorizeReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: AuthorizeRequest, options?: VolumesAuthorizeReplicationOptionalParams): Promise<void>;
    beginBreakReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesBreakReplicationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginBreakReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesBreakReplicationOptionalParams): Promise<void>;
    beginCreateOrUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: Volume, options?: VolumesCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<VolumesCreateOrUpdateResponse>, VolumesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: Volume, options?: VolumesCreateOrUpdateOptionalParams): Promise<VolumesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteOptionalParams): Promise<void>;
    beginDeleteReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteReplicationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteReplicationOptionalParams): Promise<void>;
    beginFinalizeRelocation(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesFinalizeRelocationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginFinalizeRelocationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesFinalizeRelocationOptionalParams): Promise<void>;
    beginPoolChange(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: PoolChangeRequest, options?: VolumesPoolChangeOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginPoolChangeAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: PoolChangeRequest, options?: VolumesPoolChangeOptionalParams): Promise<void>;
    beginReInitializeReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesReInitializeReplicationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginReInitializeReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesReInitializeReplicationOptionalParams): Promise<void>;
    beginRelocate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRelocateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginRelocateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRelocateOptionalParams): Promise<void>;
    beginResetCifsPassword(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResetCifsPasswordOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginResetCifsPasswordAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResetCifsPasswordOptionalParams): Promise<void>;
    beginResyncReplication(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResyncReplicationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginResyncReplicationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResyncReplicationOptionalParams): Promise<void>;
    beginRevert(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumeRevert, options?: VolumesRevertOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginRevertAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumeRevert, options?: VolumesRevertOptionalParams): Promise<void>;
    beginRevertRelocation(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRevertRelocationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginRevertRelocationAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRevertRelocationOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumePatch, options?: VolumesUpdateOptionalParams): Promise<PollerLike<PollOperationState<VolumesUpdateResponse>, VolumesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumePatch, options?: VolumesUpdateOptionalParams): Promise<VolumesUpdateResponse>;
    get(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesGetOptionalParams): Promise<VolumesGetResponse>;
    list(resourceGroupName: string, accountName: string, poolName: string, options?: VolumesListOptionalParams): PagedAsyncIterableIterator<Volume>;
    listReplications(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesListReplicationsOptionalParams): PagedAsyncIterableIterator<Replication>;
    replicationStatus(resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesReplicationStatusOptionalParams): Promise<VolumesReplicationStatusResponse>;
}

// @public
export interface VolumesAuthorizeReplicationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesBreakReplicationOptionalParams extends coreClient.OperationOptions {
    body?: BreakReplicationRequest;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumesCreateOrUpdateResponse = Volume;

// @public
export interface VolumesDeleteOptionalParams extends coreClient.OperationOptions {
    forceDelete?: boolean;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesDeleteReplicationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesFinalizeRelocationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesGetResponse = Volume;

// @public
export interface VolumesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListNextResponse = VolumeList;

// @public
export interface VolumesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface VolumesListReplicationsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListReplicationsResponse = ListReplications;

// @public
export type VolumesListResponse = VolumeList;

// @public
export interface VolumeSnapshotProperties {
    snapshotPolicyId?: string;
}

// @public
export interface VolumesPoolChangeOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesReInitializeReplicationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesRelocateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesReplicationStatusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesReplicationStatusResponse = ReplicationStatus;

// @public
export interface VolumesResetCifsPasswordOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesResyncReplicationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesRevertOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesRevertRelocationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumeStorageToNetworkProximity = string;

// @public
export interface VolumesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumesUpdateResponse = Volume;

// @public
export interface WeeklySchedule {
    day?: string;
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// (No @packageDocumentation comment for this package)

```
