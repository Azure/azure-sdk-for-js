## API Report File for "@azure/arm-netapp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import type { ClientOptions } from '@azure-rest/core-client';
import type { OperationOptions } from '@azure-rest/core-client';
import type { OperationState } from '@azure/core-lro';
import type { PathUncheckedResponse } from '@azure-rest/core-client';
import type { Pipeline } from '@azure/core-rest-pipeline';
import type { PollerLike } from '@azure/core-lro';
import type { TokenCredential } from '@azure/core-auth';

// @public
export type AcceptGrowCapacityPoolForShortTermCloneSplit = string;

// @public
export interface AccountEncryption {
    identity?: EncryptionIdentity;
    keySource?: KeySource;
    keyVaultProperties?: KeyVaultProperties;
}

// @public
export interface AccountProperties {
    activeDirectories?: ActiveDirectory[];
    readonly disableShowmount?: boolean | null;
    encryption?: AccountEncryption;
    ldapConfiguration?: LdapConfiguration;
    readonly multiAdStatus?: MultiAdStatus;
    nfsV4IDDomain?: string | null;
    readonly provisioningState?: string;
}

// @public
export interface AccountsChangeKeyVaultOptionalParams extends OperationOptions {
    body?: ChangeKeyVault;
    updateIntervalInMs?: number;
}

// @public
export interface AccountsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface AccountsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface AccountsGetChangeKeyVaultInformationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface AccountsGetOptionalParams extends OperationOptions {
}

// @public
export interface AccountsListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface AccountsListOptionalParams extends OperationOptions {
}

// @public
export interface AccountsOperations {
    changeKeyVault: (resourceGroupName: string, accountName: string, options?: AccountsChangeKeyVaultOptionalParams) => PollerLike<OperationState<void>, void>;
    createOrUpdate: (resourceGroupName: string, accountName: string, body: NetAppAccount, options?: AccountsCreateOrUpdateOptionalParams) => PollerLike<OperationState<NetAppAccount>, NetAppAccount>;
    delete: (resourceGroupName: string, accountName: string, options?: AccountsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, options?: AccountsGetOptionalParams) => Promise<NetAppAccount>;
    getChangeKeyVaultInformation: (resourceGroupName: string, accountName: string, options?: AccountsGetChangeKeyVaultInformationOptionalParams) => PollerLike<OperationState<GetKeyVaultStatusResponse>, GetKeyVaultStatusResponse>;
    list: (resourceGroupName: string, options?: AccountsListOptionalParams) => PagedAsyncIterableIterator<NetAppAccount>;
    listBySubscription: (options?: AccountsListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<NetAppAccount>;
    renewCredentials: (resourceGroupName: string, accountName: string, options?: AccountsRenewCredentialsOptionalParams) => PollerLike<OperationState<void>, void>;
    transitionToCmk: (resourceGroupName: string, accountName: string, options?: AccountsTransitionToCmkOptionalParams) => PollerLike<OperationState<void>, void>;
    update: (resourceGroupName: string, accountName: string, body: NetAppAccountPatch, options?: AccountsUpdateOptionalParams) => PollerLike<OperationState<NetAppAccount>, NetAppAccount>;
}

// @public
export interface AccountsRenewCredentialsOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface AccountsTransitionToCmkOptionalParams extends OperationOptions {
    body?: EncryptionTransitionRequest;
    updateIntervalInMs?: number;
}

// @public
export interface AccountsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ActiveDirectory {
    activeDirectoryId?: string | null;
    administrators?: string[];
    adName?: string;
    aesEncryption?: boolean;
    allowLocalNfsUsersWithLdap?: boolean;
    backupOperators?: string[];
    dns?: string;
    domain?: string;
    encryptDCConnections?: boolean;
    kdcIP?: string;
    ldapOverTLS?: boolean;
    ldapSearchScope?: LdapSearchScopeOpt;
    ldapSigning?: boolean;
    organizationalUnit?: string;
    password?: string;
    preferredServersForLdapClient?: string;
    securityOperators?: string[];
    serverRootCACertificate?: string;
    site?: string;
    smbServerName?: string;
    readonly status?: ActiveDirectoryStatus;
    readonly statusDetails?: string;
    username?: string;
}

// @public
export type ActiveDirectoryStatus = string;

// @public
export type ApplicationType = string;

// @public
export interface AuthorizeRequest {
    remoteVolumeResourceId?: string;
}

// @public
export type AvsDataStore = string;

// @public
export enum AzureClouds {
    AZURE_CHINA_CLOUD = "AZURE_CHINA_CLOUD",
    AZURE_PUBLIC_CLOUD = "AZURE_PUBLIC_CLOUD",
    AZURE_US_GOVERNMENT = "AZURE_US_GOVERNMENT"
}

// @public
export type AzureSupportedClouds = `${AzureClouds}`;

// @public
export interface Backup extends ProxyResource {
    properties: BackupProperties;
}

// @public
export interface BackupPatch {
    properties?: BackupPatchProperties;
}

// @public
export interface BackupPatchProperties {
    label?: string;
}

// @public
export interface BackupPoliciesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupPoliciesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupPoliciesGetOptionalParams extends OperationOptions {
}

// @public
export interface BackupPoliciesListOptionalParams extends OperationOptions {
}

// @public
export interface BackupPoliciesOperations {
    create: (resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicy, options?: BackupPoliciesCreateOptionalParams) => PollerLike<OperationState<BackupPolicy>, BackupPolicy>;
    delete: (resourceGroupName: string, accountName: string, backupPolicyName: string, options?: BackupPoliciesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, backupPolicyName: string, options?: BackupPoliciesGetOptionalParams) => Promise<BackupPolicy>;
    list: (resourceGroupName: string, accountName: string, options?: BackupPoliciesListOptionalParams) => PagedAsyncIterableIterator<BackupPolicy>;
    update: (resourceGroupName: string, accountName: string, backupPolicyName: string, body: BackupPolicyPatch, options?: BackupPoliciesUpdateOptionalParams) => PollerLike<OperationState<BackupPolicy>, BackupPolicy>;
}

// @public
export interface BackupPoliciesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupPolicy extends TrackedResource {
    readonly etag?: string;
    properties: BackupPolicyProperties;
}

// @public
export interface BackupPolicyPatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: BackupPolicyProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export interface BackupPolicyProperties {
    readonly backupPolicyId?: string;
    dailyBackupsToKeep?: number;
    enabled?: boolean;
    monthlyBackupsToKeep?: number;
    readonly provisioningState?: string;
    readonly volumeBackups?: VolumeBackups[];
    readonly volumesAssigned?: number;
    weeklyBackupsToKeep?: number;
}

// @public
export interface BackupProperties {
    readonly backupId?: string;
    readonly backupPolicyResourceId?: string;
    readonly backupType?: BackupType;
    readonly completionDate?: Date | null;
    readonly creationDate?: Date;
    readonly failureReason?: string;
    readonly isLargeVolume?: boolean;
    label?: string;
    readonly provisioningState?: string;
    readonly size?: number;
    readonly snapshotCreationDate?: Date | null;
    snapshotName?: string;
    useExistingSnapshot?: boolean;
    volumeResourceId: string;
}

// @public
export interface BackupRestoreFiles {
    destinationVolumeId: string;
    fileList: string[];
    restoreFilePath?: string;
}

// @public
export interface BackupsCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupsGetLatestStatusOptionalParams extends OperationOptions {
}

// @public
export interface BackupsGetOptionalParams extends OperationOptions {
}

// @public
export interface BackupsGetVolumeLatestRestoreStatusOptionalParams extends OperationOptions {
}

// @public
export interface BackupsListByVaultOptionalParams extends OperationOptions {
    filter?: string;
}

// @public
export interface BackupsMigrationRequest {
    backupVaultId: string;
}

// @public
export interface BackupsOperations {
    create: (resourceGroupName: string, accountName: string, backupVaultName: string, backupName: string, body: Backup, options?: BackupsCreateOptionalParams) => PollerLike<OperationState<Backup>, Backup>;
    delete: (resourceGroupName: string, accountName: string, backupVaultName: string, backupName: string, options?: BackupsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, backupVaultName: string, backupName: string, options?: BackupsGetOptionalParams) => Promise<Backup>;
    getLatestStatus: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: BackupsGetLatestStatusOptionalParams) => Promise<BackupStatus>;
    getVolumeLatestRestoreStatus: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: BackupsGetVolumeLatestRestoreStatusOptionalParams) => Promise<RestoreStatus>;
    listByVault: (resourceGroupName: string, accountName: string, backupVaultName: string, options?: BackupsListByVaultOptionalParams) => PagedAsyncIterableIterator<Backup>;
    update: (resourceGroupName: string, accountName: string, backupVaultName: string, backupName: string, options?: BackupsUpdateOptionalParams) => PollerLike<OperationState<Backup>, Backup>;
}

// @public
export interface BackupStatus {
    readonly errorMessage?: string;
    readonly healthy?: boolean;
    readonly lastTransferSize?: number;
    readonly lastTransferType?: string;
    readonly mirrorState?: MirrorState;
    readonly relationshipStatus?: VolumeBackupRelationshipStatus;
    readonly totalTransferBytes?: number;
    readonly transferProgressBytes?: number;
    readonly unhealthyReason?: string;
}

// @public
export interface BackupsUnderAccountMigrateBackupsOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupsUnderAccountOperations {
    migrateBackups: (resourceGroupName: string, accountName: string, body: BackupsMigrationRequest, options?: BackupsUnderAccountMigrateBackupsOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export interface BackupsUnderBackupVaultOperations {
    restoreFiles: (resourceGroupName: string, accountName: string, backupVaultName: string, backupName: string, body: BackupRestoreFiles, options?: BackupsUnderBackupVaultRestoreFilesOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export interface BackupsUnderBackupVaultRestoreFilesOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupsUnderVolumeMigrateBackupsOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupsUnderVolumeOperations {
    migrateBackups: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: BackupsMigrationRequest, options?: BackupsUnderVolumeMigrateBackupsOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export interface BackupsUpdateOptionalParams extends OperationOptions {
    body?: BackupPatch;
    updateIntervalInMs?: number;
}

// @public
export type BackupType = string;

// @public
export interface BackupVault extends TrackedResource {
    properties?: BackupVaultProperties;
}

// @public
export interface BackupVaultPatch {
    tags?: Record<string, string>;
}

// @public
export interface BackupVaultProperties {
    readonly provisioningState?: string;
}

// @public
export interface BackupVaultsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupVaultsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BackupVaultsGetOptionalParams extends OperationOptions {
}

// @public
export interface BackupVaultsListByNetAppAccountOptionalParams extends OperationOptions {
}

// @public
export interface BackupVaultsOperations {
    createOrUpdate: (resourceGroupName: string, accountName: string, backupVaultName: string, body: BackupVault, options?: BackupVaultsCreateOrUpdateOptionalParams) => PollerLike<OperationState<BackupVault>, BackupVault>;
    delete: (resourceGroupName: string, accountName: string, backupVaultName: string, options?: BackupVaultsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, backupVaultName: string, options?: BackupVaultsGetOptionalParams) => Promise<BackupVault>;
    listByNetAppAccount: (resourceGroupName: string, accountName: string, options?: BackupVaultsListByNetAppAccountOptionalParams) => PagedAsyncIterableIterator<BackupVault>;
    update: (resourceGroupName: string, accountName: string, backupVaultName: string, body: BackupVaultPatch, options?: BackupVaultsUpdateOptionalParams) => PollerLike<OperationState<BackupVault>, BackupVault>;
}

// @public
export interface BackupVaultsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BreakFileLocksRequest {
    clientIp?: string;
    confirmRunningDisruptiveOperation?: boolean;
}

// @public
export interface BreakReplicationRequest {
    forceBreakReplication?: boolean;
}

// @public
export interface Bucket extends ProxyResource {
    properties?: BucketProperties;
}

// @public
export interface BucketCredentialsExpiry {
    keyPairExpiryDays?: number;
}

// @public
export interface BucketGenerateCredentials {
    readonly accessKey?: string;
    readonly keyPairExpiry?: Date;
    readonly secretKey?: string;
}

// @public
export interface BucketPatch extends ProxyResource {
    properties?: BucketPatchProperties;
}

// @public
export type BucketPatchPermissions = string;

// @public
export interface BucketPatchProperties {
    fileSystemUser?: FileSystemUser;
    path?: string;
    permissions?: BucketPatchPermissions;
    readonly provisioningState?: NetAppProvisioningState;
    server?: BucketServerPatchProperties;
}

// @public
export type BucketPermissions = string;

// @public
export interface BucketProperties {
    fileSystemUser?: FileSystemUser;
    path?: string;
    permissions?: BucketPermissions;
    readonly provisioningState?: NetAppProvisioningState;
    server?: BucketServerProperties;
    readonly status?: CredentialsStatus;
}

// @public
export interface BucketsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BucketsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface BucketServerPatchProperties {
    certificateObject?: string;
    fqdn?: string;
}

// @public
export interface BucketServerProperties {
    readonly certificateCommonName?: string;
    readonly certificateExpiryDate?: Date;
    certificateObject?: string;
    fqdn?: string;
    readonly ipAddress?: string;
}

// @public
export interface BucketsGenerateCredentialsOptionalParams extends OperationOptions {
}

// @public
export interface BucketsGetOptionalParams extends OperationOptions {
}

// @public
export interface BucketsListOptionalParams extends OperationOptions {
}

// @public
export interface BucketsOperations {
    createOrUpdate: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, bucketName: string, body: Bucket, options?: BucketsCreateOrUpdateOptionalParams) => PollerLike<OperationState<Bucket>, Bucket>;
    delete: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, bucketName: string, options?: BucketsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    generateCredentials: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, bucketName: string, body: BucketCredentialsExpiry, options?: BucketsGenerateCredentialsOptionalParams) => Promise<BucketGenerateCredentials>;
    get: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, bucketName: string, options?: BucketsGetOptionalParams) => Promise<Bucket>;
    list: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: BucketsListOptionalParams) => PagedAsyncIterableIterator<Bucket>;
    update: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, bucketName: string, body: BucketPatch, options?: BucketsUpdateOptionalParams) => PollerLike<OperationState<Bucket>, Bucket>;
}

// @public
export interface BucketsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CapacityPool extends TrackedResource {
    readonly etag?: string;
    properties: PoolProperties;
}

// @public
export interface CapacityPoolPatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: PoolPatchProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export interface ChangeKeyVault {
    keyName: string;
    keyVaultPrivateEndpoints: KeyVaultPrivateEndpoint[];
    keyVaultResourceId?: string;
    keyVaultUri: string;
}

// @public
export interface CheckAvailabilityResponse {
    isAvailable?: boolean;
    message?: string;
    reason?: InAvailabilityReasonType;
}

// @public
export type CheckNameResourceTypes = string;

// @public
export type CheckQuotaNameResourceTypes = string;

// @public
export type ChownMode = string;

// @public
export interface CifsUser {
    username?: string;
}

// @public
export interface ClusterPeerCommandResponse {
    peerAcceptCommand?: string;
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export type CoolAccessRetrievalPolicy = string;

// @public
export type CoolAccessTieringPolicy = string;

// @public
export type CreatedByType = string;

// @public
export type CredentialsStatus = string;

// @public
export interface DailySchedule {
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export interface DestinationReplication {
    region?: string;
    replicationType?: ReplicationType;
    resourceId?: string;
    zone?: string;
}

// @public
export interface Dimension {
    displayName?: string;
    name?: string;
}

// @public
export type EnableSubvolumes = string;

// @public
export interface EncryptionIdentity {
    federatedClientId?: string;
    readonly principalId?: string;
    userAssignedIdentity?: string;
}

// @public
export type EncryptionKeySource = string;

// @public
export interface EncryptionTransitionRequest {
    privateEndpointId: string;
    virtualNetworkId: string;
}

// @public
export type EncryptionType = string;

// @public
export type EndpointType = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: any;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface ExportPolicyRule {
    allowedClients?: string;
    chownMode?: ChownMode;
    cifs?: boolean;
    hasRootAccess?: boolean;
    kerberos5IReadOnly?: boolean;
    kerberos5IReadWrite?: boolean;
    kerberos5PReadOnly?: boolean;
    kerberos5PReadWrite?: boolean;
    kerberos5ReadOnly?: boolean;
    kerberos5ReadWrite?: boolean;
    nfsv3?: boolean;
    nfsv41?: boolean;
    ruleIndex?: number;
    unixReadOnly?: boolean;
    unixReadWrite?: boolean;
}

// @public
export type ExternalReplicationSetupStatus = string;

// @public
export type FileAccessLogs = string;

// @public
export interface FilePathAvailabilityRequest {
    availabilityZone?: string | null;
    name: string;
    subnetId: string;
}

// @public
export interface FileSystemUser {
    cifsUser?: CifsUser;
    nfsUser?: NfsUser;
}

// @public
export interface GetGroupIdListForLdapUserRequest {
    username: string;
}

// @public
export interface GetGroupIdListForLdapUserResponse {
    groupIdsForLdapUser?: string[];
}

// @public
export interface GetKeyVaultStatusResponse {
    properties?: GetKeyVaultStatusResponseProperties;
}

// @public
export interface GetKeyVaultStatusResponseProperties {
    keyName?: string;
    keyVaultPrivateEndpoints?: KeyVaultPrivateEndpoint[];
    keyVaultResourceId?: string;
    keyVaultUri?: string;
}

// @public
export interface HourlySchedule {
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export type InAvailabilityReasonType = string;

// @public
export type KeySource = string;

// @public
export interface KeyVaultPrivateEndpoint {
    privateEndpointId?: string;
    virtualNetworkId?: string;
}

// @public
export interface KeyVaultProperties {
    keyName: string;
    readonly keyVaultId?: string;
    keyVaultResourceId?: string;
    keyVaultUri: string;
    readonly status?: KeyVaultStatus;
}

// @public
export type KeyVaultStatus = string;

// @public
export enum KnownAcceptGrowCapacityPoolForShortTermCloneSplit {
    Accepted = "Accepted",
    Declined = "Declined"
}

// @public
export enum KnownActiveDirectoryStatus {
    Created = "Created",
    Deleted = "Deleted",
    Error = "Error",
    InUse = "InUse",
    Updating = "Updating"
}

// @public
export enum KnownApplicationType {
    Oracle = "ORACLE",
    SAPHana = "SAP-HANA"
}

// @public
export enum KnownAvsDataStore {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownBackupType {
    Manual = "Manual",
    Scheduled = "Scheduled"
}

// @public
export enum KnownBucketPatchPermissions {
    ReadOnly = "ReadOnly",
    ReadWrite = "ReadWrite"
}

// @public
export enum KnownBucketPermissions {
    ReadOnly = "ReadOnly",
    ReadWrite = "ReadWrite"
}

// @public
export enum KnownCheckNameResourceTypes {
    MicrosoftNetAppNetAppAccounts = "Microsoft.NetApp/netAppAccounts",
    MicrosoftNetAppNetAppAccountsCapacityPools = "Microsoft.NetApp/netAppAccounts/capacityPools",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots"
}

// @public
export enum KnownCheckQuotaNameResourceTypes {
    MicrosoftNetAppNetAppAccounts = "Microsoft.NetApp/netAppAccounts",
    MicrosoftNetAppNetAppAccountsCapacityPools = "Microsoft.NetApp/netAppAccounts/capacityPools",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes",
    MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots"
}

// @public
export enum KnownChownMode {
    Restricted = "Restricted",
    Unrestricted = "Unrestricted"
}

// @public
export enum KnownCoolAccessRetrievalPolicy {
    Default = "Default",
    Never = "Never",
    OnRead = "OnRead"
}

// @public
export enum KnownCoolAccessTieringPolicy {
    Auto = "Auto",
    SnapshotOnly = "SnapshotOnly"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownCredentialsStatus {
    Active = "Active",
    CredentialsExpired = "CredentialsExpired",
    NoCredentialsSet = "NoCredentialsSet"
}

// @public
export enum KnownEnableSubvolumes {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownEncryptionKeySource {
    MicrosoftKeyVault = "Microsoft.KeyVault",
    MicrosoftNetApp = "Microsoft.NetApp"
}

// @public
export enum KnownEncryptionType {
    Double = "Double",
    Single = "Single"
}

// @public
export enum KnownEndpointType {
    Dst = "dst",
    Src = "src"
}

// @public
export enum KnownExternalReplicationSetupStatus {
    ClusterPeerPending = "ClusterPeerPending",
    ClusterPeerRequired = "ClusterPeerRequired",
    NoActionRequired = "NoActionRequired",
    ReplicationCreateRequired = "ReplicationCreateRequired",
    VServerPeerRequired = "VServerPeerRequired"
}

// @public
export enum KnownFileAccessLogs {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownInAvailabilityReasonType {
    AlreadyExists = "AlreadyExists",
    Invalid = "Invalid"
}

// @public
export enum KnownKeySource {
    MicrosoftKeyVault = "Microsoft.KeyVault",
    MicrosoftNetApp = "Microsoft.NetApp"
}

// @public
export enum KnownKeyVaultStatus {
    Created = "Created",
    Deleted = "Deleted",
    Error = "Error",
    InUse = "InUse",
    Updating = "Updating"
}

// @public
export enum KnownLdapServerType {
    ActiveDirectory = "ActiveDirectory",
    OpenLdap = "OpenLDAP"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownMetricAggregationType {
    Average = "Average"
}

// @public
export enum KnownMirrorState {
    Broken = "Broken",
    Mirrored = "Mirrored",
    Uninitialized = "Uninitialized"
}

// @public
export enum KnownMultiAdStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownNetAppProvisioningState {
    Accepted = "Accepted",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Moving = "Moving",
    Patching = "Patching",
    Succeeded = "Succeeded"
}

// @public
export enum KnownNetworkFeatures {
    Basic = "Basic",
    BasicStandard = "Basic_Standard",
    Standard = "Standard",
    StandardBasic = "Standard_Basic"
}

// @public
export enum KnownNetworkSiblingSetProvisioningState {
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownQosType {
    Auto = "Auto",
    Manual = "Manual"
}

// @public
export enum KnownRegionStorageToNetworkProximity {
    AcrossT2 = "AcrossT2",
    Default = "Default",
    T1 = "T1",
    T1AndAcrossT2 = "T1AndAcrossT2",
    T1AndT2 = "T1AndT2",
    T1AndT2AndAcrossT2 = "T1AndT2AndAcrossT2",
    T2 = "T2",
    T2AndAcrossT2 = "T2AndAcrossT2"
}

// @public
export enum KnownReplicationSchedule {
    "10Minutely" = "_10minutely",
    Daily = "daily",
    Hourly = "hourly"
}

// @public
export enum KnownReplicationType {
    CrossRegionReplication = "CrossRegionReplication",
    CrossZoneReplication = "CrossZoneReplication"
}

// @public
export enum KnownSecurityStyle {
    Ntfs = "ntfs",
    Unix = "unix"
}

// @public
export enum KnownServiceLevel {
    Flexible = "Flexible",
    Premium = "Premium",
    Standard = "Standard",
    StandardZRS = "StandardZRS",
    Ultra = "Ultra"
}

// @public
export enum KnownSmbAccessBasedEnumeration {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownSmbNonBrowsable {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownType {
    DefaultGroupQuota = "DefaultGroupQuota",
    DefaultUserQuota = "DefaultUserQuota",
    IndividualGroupQuota = "IndividualGroupQuota",
    IndividualUserQuota = "IndividualUserQuota"
}

// @public
export enum KnownVersions {
    V20250601 = "2025-06-01",
    V20250701Preview = "2025-07-01-preview"
}

// @public
export enum KnownVolumeBackupRelationshipStatus {
    Failed = "Failed",
    Idle = "Idle",
    Transferring = "Transferring",
    Unknown = "Unknown"
}

// @public
export enum KnownVolumeLanguage {
    Ar = "ar",
    ArUtf8 = "ar.utf-8",
    C = "c",
    Cs = "cs",
    CsUtf8 = "cs.utf-8",
    CUtf8 = "c.utf-8",
    Da = "da",
    DaUtf8 = "da.utf-8",
    De = "de",
    DeUtf8 = "de.utf-8",
    En = "en",
    EnUs = "en-us",
    EnUsUtf8 = "en-us.utf-8",
    EnUtf8 = "en.utf-8",
    Es = "es",
    EsUtf8 = "es.utf-8",
    Fi = "fi",
    FiUtf8 = "fi.utf-8",
    Fr = "fr",
    FrUtf8 = "fr.utf-8",
    He = "he",
    HeUtf8 = "he.utf-8",
    Hr = "hr",
    HrUtf8 = "hr.utf-8",
    Hu = "hu",
    HuUtf8 = "hu.utf-8",
    It = "it",
    ItUtf8 = "it.utf-8",
    Ja = "ja",
    JaJp932 = "ja-jp.932",
    JaJp932Utf8 = "ja-jp.932.utf-8",
    JaJpPck = "ja-jp.pck",
    JaJpPckUtf8 = "ja-jp.pck.utf-8",
    JaJpPckV2 = "ja-jp.pck-v2",
    JaJpPckV2Utf8 = "ja-jp.pck-v2.utf-8",
    JaUtf8 = "ja.utf-8",
    JaV1 = "ja-v1",
    JaV1Utf8 = "ja-v1.utf-8",
    Ko = "ko",
    KoUtf8 = "ko.utf-8",
    Nl = "nl",
    NlUtf8 = "nl.utf-8",
    No = "no",
    NoUtf8 = "no.utf-8",
    Pl = "pl",
    PlUtf8 = "pl.utf-8",
    Pt = "pt",
    PtUtf8 = "pt.utf-8",
    Ro = "ro",
    RoUtf8 = "ro.utf-8",
    Ru = "ru",
    RuUtf8 = "ru.utf-8",
    Sk = "sk",
    SkUtf8 = "sk.utf-8",
    Sl = "sl",
    SlUtf8 = "sl.utf-8",
    Sv = "sv",
    SvUtf8 = "sv.utf-8",
    Tr = "tr",
    TrUtf8 = "tr.utf-8",
    Utf8Mb4 = "utf8mb4",
    Zh = "zh",
    ZhGbk = "zh.gbk",
    ZhGbkUtf8 = "zh.gbk.utf-8",
    ZhTw = "zh-tw",
    ZhTwBig5 = "zh-tw.big5",
    ZhTwBig5Utf8 = "zh-tw.big5.utf-8",
    ZhTwUtf8 = "zh-tw.utf-8",
    ZhUtf8 = "zh.utf-8"
}

// @public
export enum KnownVolumeReplicationRelationshipStatus {
    Idle = "Idle",
    Transferring = "Transferring"
}

// @public
export enum KnownVolumeRestoreRelationshipStatus {
    Failed = "Failed",
    Idle = "Idle",
    Transferring = "Transferring",
    Unknown = "Unknown"
}

// @public
export enum KnownVolumeStorageToNetworkProximity {
    AcrossT2 = "AcrossT2",
    Default = "Default",
    T1 = "T1",
    T2 = "T2"
}

// @public
export interface LdapConfiguration {
    certificateCNHost?: string | null;
    domain?: string;
    ldapOverTLS?: boolean;
    ldapServers?: string[];
    serverCACertificate?: string;
}

// @public
export interface LdapSearchScopeOpt {
    groupDN?: string;
    groupMembershipFilter?: string;
    userDN?: string;
}

// @public
export type LdapServerType = string;

// @public
export interface ListQuotaReportResponse {
    value?: QuotaReport[];
}

// @public
export interface LogSpecification {
    displayName?: string;
    name?: string;
}

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentity | null>;
}

// @public
export type ManagedServiceIdentityType = string;

// @public
export type MetricAggregationType = string;

// @public
export interface MetricSpecification {
    aggregationType?: string;
    category?: string;
    dimensions?: Dimension[];
    displayDescription?: string;
    displayName?: string;
    enableRegionalMdmAccount?: boolean;
    fillGapWithZero?: boolean;
    internalMetricName?: string;
    isInternal?: boolean;
    name?: string;
    resourceIdDimensionNameOverride?: string;
    sourceMdmAccount?: string;
    sourceMdmNamespace?: string;
    supportedAggregationTypes?: MetricAggregationType[];
    supportedTimeGrainTypes?: string[];
    unit?: string;
}

// @public
export type MirrorState = string;

// @public
export interface MonthlySchedule {
    daysOfMonth?: string;
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// @public
export interface MountTargetProperties {
    fileSystemId: string;
    readonly ipAddress?: string;
    readonly mountTargetId?: string;
    smbServerFqdn?: string;
}

// @public
export type MultiAdStatus = string;

// @public
export interface NetAppAccount extends TrackedResource {
    readonly etag?: string;
    identity?: ManagedServiceIdentity;
    properties?: AccountProperties;
}

// @public
export interface NetAppAccountPatch {
    readonly id?: string;
    identity?: ManagedServiceIdentity;
    location?: string;
    readonly name?: string;
    properties?: AccountProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public (undocumented)
export class NetAppManagementClient {
    constructor(credential: TokenCredential, subscriptionId: string, options?: NetAppManagementClientOptionalParams);
    readonly accounts: AccountsOperations;
    readonly backupPolicies: BackupPoliciesOperations;
    readonly backups: BackupsOperations;
    readonly backupsUnderAccount: BackupsUnderAccountOperations;
    readonly backupsUnderBackupVault: BackupsUnderBackupVaultOperations;
    readonly backupsUnderVolume: BackupsUnderVolumeOperations;
    readonly backupVaults: BackupVaultsOperations;
    readonly buckets: BucketsOperations;
    readonly netAppResource: NetAppResourceOperations;
    readonly netAppResourceQuotaLimits: NetAppResourceQuotaLimitsOperations;
    readonly netAppResourceQuotaLimitsAccount: NetAppResourceQuotaLimitsAccountOperations;
    readonly netAppResourceRegionInfos: NetAppResourceRegionInfosOperations;
    readonly netAppResourceUsages: NetAppResourceUsagesOperations;
    readonly operations: OperationsOperations;
    readonly pipeline: Pipeline;
    readonly pools: PoolsOperations;
    readonly snapshotPolicies: SnapshotPoliciesOperations;
    readonly snapshots: SnapshotsOperations;
    readonly subvolumes: SubvolumesOperations;
    readonly volumeGroups: VolumeGroupsOperations;
    readonly volumeQuotaRules: VolumeQuotaRulesOperations;
    readonly volumes: VolumesOperations;
}

// @public
export interface NetAppManagementClientOptionalParams extends ClientOptions {
    apiVersion?: string;
    cloudSetting?: AzureSupportedClouds;
}

// @public
export type NetAppProvisioningState = string;

// @public
export interface NetAppResourceCheckFilePathAvailabilityOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceCheckNameAvailabilityOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceCheckQuotaAvailabilityOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceOperations {
    checkFilePathAvailability: (location: string, body: FilePathAvailabilityRequest, options?: NetAppResourceCheckFilePathAvailabilityOptionalParams) => Promise<CheckAvailabilityResponse>;
    checkNameAvailability: (location: string, body: ResourceNameAvailabilityRequest, options?: NetAppResourceCheckNameAvailabilityOptionalParams) => Promise<CheckAvailabilityResponse>;
    checkQuotaAvailability: (location: string, body: QuotaAvailabilityRequest, options?: NetAppResourceCheckQuotaAvailabilityOptionalParams) => Promise<CheckAvailabilityResponse>;
    queryNetworkSiblingSet: (location: string, body: QueryNetworkSiblingSetRequest, options?: NetAppResourceQueryNetworkSiblingSetOptionalParams) => Promise<NetworkSiblingSet>;
    queryRegionInfo: (location: string, options?: NetAppResourceQueryRegionInfoOptionalParams) => Promise<RegionInfo>;
    updateNetworkSiblingSet: (location: string, body: UpdateNetworkSiblingSetRequest, options?: NetAppResourceUpdateNetworkSiblingSetOptionalParams) => PollerLike<OperationState<NetworkSiblingSet>, NetworkSiblingSet>;
}

// @public
export interface NetAppResourceQueryNetworkSiblingSetOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceQueryRegionInfoOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceQuotaLimitsAccountGetOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceQuotaLimitsAccountListOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceQuotaLimitsAccountOperations {
    get: (resourceGroupName: string, accountName: string, quotaLimitName: string, options?: NetAppResourceQuotaLimitsAccountGetOptionalParams) => Promise<QuotaItem>;
    list: (resourceGroupName: string, accountName: string, options?: NetAppResourceQuotaLimitsAccountListOptionalParams) => PagedAsyncIterableIterator<QuotaItem>;
}

// @public
export interface NetAppResourceQuotaLimitsGetOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceQuotaLimitsListOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceQuotaLimitsOperations {
    get: (location: string, quotaLimitName: string, options?: NetAppResourceQuotaLimitsGetOptionalParams) => Promise<QuotaItem>;
    list: (location: string, options?: NetAppResourceQuotaLimitsListOptionalParams) => PagedAsyncIterableIterator<QuotaItem>;
}

// @public
export interface NetAppResourceRegionInfosGetOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceRegionInfosListOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceRegionInfosOperations {
    get: (location: string, options?: NetAppResourceRegionInfosGetOptionalParams) => Promise<RegionInfoResource>;
    list: (location: string, options?: NetAppResourceRegionInfosListOptionalParams) => PagedAsyncIterableIterator<RegionInfoResource>;
}

// @public
export interface NetAppResourceUpdateNetworkSiblingSetOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NetAppResourceUsagesGetOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceUsagesListOptionalParams extends OperationOptions {
}

// @public
export interface NetAppResourceUsagesOperations {
    get: (location: string, usageType: string, options?: NetAppResourceUsagesGetOptionalParams) => Promise<UsageResult>;
    list: (location: string, options?: NetAppResourceUsagesListOptionalParams) => PagedAsyncIterableIterator<UsageResult>;
}

// @public
export type NetworkFeatures = string;

// @public
export interface NetworkSiblingSet {
    networkFeatures?: NetworkFeatures;
    networkSiblingSetId?: string;
    networkSiblingSetStateId?: string;
    nicInfoList?: NicInfo[];
    readonly provisioningState?: NetworkSiblingSetProvisioningState;
    subnetId?: string;
}

// @public
export type NetworkSiblingSetProvisioningState = string;

// @public
export interface NfsUser {
    groupId?: number;
    userId?: number;
}

// @public
export interface NicInfo {
    readonly ipAddress?: string;
    volumeResourceIds?: string[];
}

// @public
export interface Operation {
    display?: OperationDisplay;
    name?: string;
    origin?: string;
    properties?: OperationProperties;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationProperties {
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface OperationsListOptionalParams extends OperationOptions {
}

// @public
export interface OperationsOperations {
    list: (options?: OperationsListOptionalParams) => PagedAsyncIterableIterator<Operation>;
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PeerClusterForVolumeMigrationRequest {
    peerIpAddresses: string[];
}

// @public
export interface PlacementKeyValuePairs {
    key: string;
    value: string;
}

// @public
export interface PoolChangeRequest {
    newPoolResourceId: string;
}

// @public
export interface PoolPatchProperties {
    coolAccess?: boolean;
    customThroughputMibps?: number | null;
    qosType?: QosType;
    size?: number;
}

// @public
export interface PoolProperties {
    coolAccess?: boolean;
    customThroughputMibps?: number | null;
    encryptionType?: EncryptionType | null;
    readonly poolId?: string;
    readonly provisioningState?: string;
    qosType?: QosType;
    serviceLevel: ServiceLevel;
    size: number;
    readonly totalThroughputMibps?: number;
    readonly utilizedThroughputMibps?: number;
}

// @public
export interface PoolsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface PoolsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface PoolsGetOptionalParams extends OperationOptions {
}

// @public
export interface PoolsListOptionalParams extends OperationOptions {
}

// @public
export interface PoolsOperations {
    createOrUpdate: (resourceGroupName: string, accountName: string, poolName: string, body: CapacityPool, options?: PoolsCreateOrUpdateOptionalParams) => PollerLike<OperationState<CapacityPool>, CapacityPool>;
    delete: (resourceGroupName: string, accountName: string, poolName: string, options?: PoolsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, poolName: string, options?: PoolsGetOptionalParams) => Promise<CapacityPool>;
    list: (resourceGroupName: string, accountName: string, options?: PoolsListOptionalParams) => PagedAsyncIterableIterator<CapacityPool>;
    update: (resourceGroupName: string, accountName: string, poolName: string, body: CapacityPoolPatch, options?: PoolsUpdateOptionalParams) => PollerLike<OperationState<CapacityPool>, CapacityPool>;
}

// @public
export interface PoolsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ProxyResource extends Resource {
}

// @public
export type QosType = string;

// @public
export interface QueryNetworkSiblingSetRequest {
    networkSiblingSetId: string;
    subnetId: string;
}

// @public
export interface QuotaAvailabilityRequest {
    name: string;
    resourceGroup: string;
    type: CheckQuotaNameResourceTypes;
}

// @public
export interface QuotaItem extends ProxyResource {
    properties?: QuotaItemProperties;
}

// @public
export interface QuotaItemProperties {
    readonly current?: number;
    readonly default?: number;
    readonly usage?: number | null;
}

// @public
export interface QuotaReport {
    isDerivedQuota?: boolean;
    percentageUsed?: number;
    quotaLimitTotalInKiBs?: number;
    quotaLimitUsedInKiBs?: number;
    quotaTarget?: string;
    quotaType?: Type;
}

// @public
export interface ReestablishReplicationRequest {
    sourceVolumeId?: string;
}

// @public
export interface RegionInfo {
    availabilityZoneMappings?: RegionInfoAvailabilityZoneMappingsItem[];
    storageToNetworkProximity?: RegionStorageToNetworkProximity;
}

// @public
export interface RegionInfoAvailabilityZoneMappingsItem {
    availabilityZone?: string;
    isAvailable?: boolean;
}

// @public
export interface RegionInfoResource extends ProxyResource {
    properties?: RegionInfo;
}

// @public
export type RegionStorageToNetworkProximity = string;

// @public
export interface RelocateVolumeRequest {
    creationToken?: string;
}

// @public
export interface RemotePath {
    externalHostName: string;
    serverName: string;
    volumeName: string;
}

// @public
export interface Replication {
    endpointType?: EndpointType;
    remoteVolumeRegion?: string;
    remoteVolumeResourceId: string;
    readonly replicationId?: string;
    replicationSchedule?: ReplicationSchedule;
}

// @public
export interface ReplicationObject {
    readonly destinationReplications?: DestinationReplication[];
    readonly endpointType?: EndpointType;
    readonly externalReplicationSetupInfo?: string;
    readonly externalReplicationSetupStatus?: ExternalReplicationSetupStatus;
    readonly mirrorState?: MirrorState;
    readonly relationshipStatus?: VolumeReplicationRelationshipStatus;
    remotePath?: RemotePath;
    remoteVolumeRegion?: string;
    remoteVolumeResourceId?: string;
    readonly replicationId?: string;
    replicationSchedule?: ReplicationSchedule;
}

// @public
export type ReplicationSchedule = string;

// @public
export interface ReplicationStatus {
    errorMessage?: string;
    healthy?: boolean;
    mirrorState?: MirrorState;
    relationshipStatus?: VolumeReplicationRelationshipStatus;
    totalProgress?: string;
}

// @public
export type ReplicationType = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceNameAvailabilityRequest {
    name: string;
    resourceGroup: string;
    type: CheckNameResourceTypes;
}

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: NetAppManagementClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export interface RestoreStatus {
    readonly errorMessage?: string;
    readonly healthy?: boolean;
    readonly mirrorState?: MirrorState;
    readonly relationshipStatus?: VolumeRestoreRelationshipStatus;
    readonly totalTransferBytes?: number;
    readonly unhealthyReason?: string;
}

// @public
export type SecurityStyle = string;

// @public
export type ServiceLevel = string;

// @public
export interface ServiceSpecification {
    logSpecifications?: LogSpecification[];
    metricSpecifications?: MetricSpecification[];
}

// @public
export type SmbAccessBasedEnumeration = string;

// @public
export type SmbNonBrowsable = string;

// @public
export interface Snapshot extends ProxyResource {
    location: string;
    properties?: SnapshotProperties;
}

// @public
export interface SnapshotPatch {
}

// @public
export interface SnapshotPoliciesCreateOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotPoliciesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotPoliciesGetOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotPoliciesListOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotPoliciesListVolumesOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotPoliciesOperations {
    create: (resourceGroupName: string, accountName: string, snapshotPolicyName: string, body: SnapshotPolicy, options?: SnapshotPoliciesCreateOptionalParams) => Promise<SnapshotPolicy>;
    delete: (resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesGetOptionalParams) => Promise<SnapshotPolicy>;
    list: (resourceGroupName: string, accountName: string, options?: SnapshotPoliciesListOptionalParams) => PagedAsyncIterableIterator<SnapshotPolicy>;
    listVolumes: (resourceGroupName: string, accountName: string, snapshotPolicyName: string, options?: SnapshotPoliciesListVolumesOptionalParams) => Promise<SnapshotPolicyVolumeList>;
    update: (resourceGroupName: string, accountName: string, snapshotPolicyName: string, body: SnapshotPolicyPatch, options?: SnapshotPoliciesUpdateOptionalParams) => PollerLike<OperationState<SnapshotPolicy>, SnapshotPolicy>;
}

// @public
export interface SnapshotPoliciesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotPolicy extends TrackedResource {
    readonly etag?: string;
    properties: SnapshotPolicyProperties;
}

// @public
export interface SnapshotPolicyPatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: SnapshotPolicyProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export interface SnapshotPolicyProperties {
    dailySchedule?: DailySchedule;
    enabled?: boolean;
    hourlySchedule?: HourlySchedule;
    monthlySchedule?: MonthlySchedule;
    readonly provisioningState?: string;
    weeklySchedule?: WeeklySchedule;
}

// @public
export interface SnapshotPolicyVolumeList {
    nextLink?: string;
    value: Volume[];
}

// @public
export interface SnapshotProperties {
    readonly created?: Date;
    readonly provisioningState?: string;
    readonly snapshotId?: string;
}

// @public
export interface SnapshotRestoreFiles {
    destinationPath?: string;
    filePaths: string[];
}

// @public
export interface SnapshotsCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotsGetOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsListOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsOperations {
    create: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: Snapshot, options?: SnapshotsCreateOptionalParams) => PollerLike<OperationState<Snapshot>, Snapshot>;
    delete: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, options?: SnapshotsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, options?: SnapshotsGetOptionalParams) => Promise<Snapshot>;
    list: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: SnapshotsListOptionalParams) => PagedAsyncIterableIterator<Snapshot>;
    restoreFiles: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: SnapshotRestoreFiles, options?: SnapshotsRestoreFilesOptionalParams) => PollerLike<OperationState<void>, void>;
    update: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, snapshotName: string, body: SnapshotPatch, options?: SnapshotsUpdateOptionalParams) => PollerLike<OperationState<Snapshot>, Snapshot>;
}

// @public
export interface SnapshotsRestoreFilesOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SubvolumeInfo extends ProxyResource {
    properties?: SubvolumeProperties;
}

// @public
export interface SubvolumeModel {
    readonly id?: string;
    readonly name?: string;
    properties?: SubvolumeModelProperties;
    readonly type?: string;
}

// @public
export interface SubvolumeModelProperties {
    accessedTimeStamp?: Date;
    bytesUsed?: number;
    changedTimeStamp?: Date;
    creationTimeStamp?: Date;
    modifiedTimeStamp?: Date;
    parentPath?: string;
    path?: string;
    permissions?: string;
    provisioningState?: string;
    size?: number;
}

// @public
export interface SubvolumePatchParams {
    path?: string;
    size?: number | null;
}

// @public
export interface SubvolumePatchRequest {
    properties?: SubvolumePatchParams;
}

// @public
export interface SubvolumeProperties {
    parentPath?: string | null;
    path?: string;
    readonly provisioningState?: string;
    size?: number | null;
}

// @public
export interface SubvolumesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SubvolumesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SubvolumesGetMetadataOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SubvolumesGetOptionalParams extends OperationOptions {
}

// @public
export interface SubvolumesListByVolumeOptionalParams extends OperationOptions {
}

// @public
export interface SubvolumesOperations {
    create: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumeInfo, options?: SubvolumesCreateOptionalParams) => PollerLike<OperationState<SubvolumeInfo>, SubvolumeInfo>;
    delete: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesGetOptionalParams) => Promise<SubvolumeInfo>;
    getMetadata: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, options?: SubvolumesGetMetadataOptionalParams) => PollerLike<OperationState<SubvolumeModel>, SubvolumeModel>;
    listByVolume: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: SubvolumesListByVolumeOptionalParams) => PagedAsyncIterableIterator<SubvolumeInfo>;
    update: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, subvolumeName: string, body: SubvolumePatchRequest, options?: SubvolumesUpdateOptionalParams) => PollerLike<OperationState<SubvolumeInfo>, SubvolumeInfo>;
}

// @public
export interface SubvolumesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SvmPeerCommandResponse {
    svmPeeringCommand?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export type Type = string;

// @public
export interface UpdateNetworkSiblingSetRequest {
    networkFeatures: NetworkFeatures;
    networkSiblingSetId: string;
    networkSiblingSetStateId: string;
    subnetId: string;
}

// @public
export interface UsageName {
    localizedValue?: string;
    value?: string;
}

// @public
export interface UsageProperties {
    readonly currentValue?: number;
    readonly limit?: number;
    readonly unit?: string;
}

// @public
export interface UsageResult {
    readonly id?: string;
    readonly name?: UsageName;
    properties?: UsageProperties;
}

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface Volume extends TrackedResource {
    readonly etag?: string;
    properties: VolumeProperties;
    zones?: string[];
}

// @public
export interface VolumeBackupProperties {
    backupPolicyId?: string;
    backupVaultId?: string;
    policyEnforced?: boolean;
}

// @public
export type VolumeBackupRelationshipStatus = string;

// @public
export interface VolumeBackups {
    backupsCount?: number;
    policyEnabled?: boolean;
    volumeName?: string;
    volumeResourceId?: string;
}

// @public
export interface VolumeGroup {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: VolumeGroupListProperties;
    readonly type?: string;
}

// @public
export interface VolumeGroupDetails extends ProxyResource {
    location?: string;
    properties?: VolumeGroupProperties;
}

// @public
export interface VolumeGroupListProperties {
    groupMetaData?: VolumeGroupMetaData;
    readonly provisioningState?: string;
}

// @public
export interface VolumeGroupMetaData {
    applicationIdentifier?: string;
    applicationType?: ApplicationType;
    globalPlacementRules?: PlacementKeyValuePairs[];
    groupDescription?: string;
    readonly volumesCount?: number;
}

// @public
export interface VolumeGroupProperties {
    groupMetaData?: VolumeGroupMetaData;
    readonly provisioningState?: string;
    volumes?: VolumeGroupVolumeProperties[];
}

// @public
export interface VolumeGroupsCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumeGroupsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumeGroupsGetOptionalParams extends OperationOptions {
}

// @public
export interface VolumeGroupsListByNetAppAccountOptionalParams extends OperationOptions {
}

// @public
export interface VolumeGroupsOperations {
    create: (resourceGroupName: string, accountName: string, volumeGroupName: string, body: VolumeGroupDetails, options?: VolumeGroupsCreateOptionalParams) => PollerLike<OperationState<VolumeGroupDetails>, VolumeGroupDetails>;
    delete: (resourceGroupName: string, accountName: string, volumeGroupName: string, options?: VolumeGroupsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, volumeGroupName: string, options?: VolumeGroupsGetOptionalParams) => Promise<VolumeGroupDetails>;
    listByNetAppAccount: (resourceGroupName: string, accountName: string, options?: VolumeGroupsListByNetAppAccountOptionalParams) => PagedAsyncIterableIterator<VolumeGroup>;
}

// @public
export interface VolumeGroupVolumeProperties {
    readonly id?: string;
    name?: string;
    properties: VolumeProperties;
    tags?: Record<string, string>;
    readonly type?: string;
    zones?: string[];
}

// @public
export type VolumeLanguage = string;

// @public
export interface VolumePatch {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    properties?: VolumePatchProperties;
    tags?: Record<string, string>;
    readonly type?: string;
}

// @public
export interface VolumePatchProperties {
    coolAccess?: boolean;
    coolAccessRetrievalPolicy?: CoolAccessRetrievalPolicy;
    coolAccessTieringPolicy?: CoolAccessTieringPolicy;
    coolnessPeriod?: number;
    dataProtection?: VolumePatchPropertiesDataProtection;
    defaultGroupQuotaInKiBs?: number;
    defaultUserQuotaInKiBs?: number;
    exportPolicy?: VolumePatchPropertiesExportPolicy;
    isDefaultQuotaEnabled?: boolean;
    protocolTypes?: string[];
    serviceLevel?: ServiceLevel;
    smbAccessBasedEnumeration?: SmbAccessBasedEnumeration | null;
    smbNonBrowsable?: SmbNonBrowsable;
    snapshotDirectoryVisible?: boolean;
    throughputMibps?: number;
    unixPermissions?: string | null;
    usageThreshold?: number;
}

// @public
export interface VolumePatchPropertiesDataProtection {
    backup?: VolumeBackupProperties;
    snapshot?: VolumeSnapshotProperties;
}

// @public
export interface VolumePatchPropertiesExportPolicy {
    rules?: ExportPolicyRule[];
}

// @public
export interface VolumeProperties {
    acceptGrowCapacityPoolForShortTermCloneSplit?: AcceptGrowCapacityPoolForShortTermCloneSplit;
    readonly actualThroughputMibps?: number;
    avsDataStore?: AvsDataStore;
    backupId?: string | null;
    readonly baremetalTenantId?: string;
    capacityPoolResourceId?: string;
    readonly cloneProgress?: number | null;
    coolAccess?: boolean;
    coolAccessRetrievalPolicy?: CoolAccessRetrievalPolicy;
    coolAccessTieringPolicy?: CoolAccessTieringPolicy;
    coolnessPeriod?: number;
    creationToken: string;
    dataProtection?: VolumePropertiesDataProtection;
    readonly dataStoreResourceId?: string[];
    defaultGroupQuotaInKiBs?: number;
    defaultUserQuotaInKiBs?: number;
    deleteBaseSnapshot?: boolean;
    readonly effectiveNetworkFeatures?: NetworkFeatures;
    enableSubvolumes?: EnableSubvolumes;
    readonly encrypted?: boolean;
    encryptionKeySource?: EncryptionKeySource;
    exportPolicy?: VolumePropertiesExportPolicy;
    readonly fileAccessLogs?: FileAccessLogs;
    readonly fileSystemId?: string;
    readonly inheritedSizeInBytes?: number | null;
    isDefaultQuotaEnabled?: boolean;
    isLargeVolume?: boolean;
    readonly isRestoring?: boolean;
    kerberosEnabled?: boolean;
    keyVaultPrivateEndpointResourceId?: string;
    language?: VolumeLanguage;
    ldapEnabled?: boolean;
    ldapServerType?: LdapServerType;
    readonly maximumNumberOfFiles?: number;
    readonly mountTargets?: MountTargetProperties[];
    networkFeatures?: NetworkFeatures;
    readonly networkSiblingSetId?: string;
    readonly originatingResourceId?: string | null;
    placementRules?: PlacementKeyValuePairs[];
    protocolTypes?: string[];
    readonly provisionedAvailabilityZone?: string | null;
    readonly provisioningState?: string;
    proximityPlacementGroup?: string;
    securityStyle?: SecurityStyle;
    serviceLevel?: ServiceLevel;
    smbAccessBasedEnumeration?: SmbAccessBasedEnumeration | null;
    smbContinuouslyAvailable?: boolean;
    smbEncryption?: boolean;
    smbNonBrowsable?: SmbNonBrowsable;
    snapshotDirectoryVisible?: boolean;
    snapshotId?: string | null;
    readonly storageToNetworkProximity?: VolumeStorageToNetworkProximity;
    subnetId: string;
    readonly t2Network?: string;
    throughputMibps?: number | null;
    unixPermissions?: string | null;
    usageThreshold: number;
    readonly volumeGroupName?: string;
    volumeSpecName?: string;
    volumeType?: string;
}

// @public
export interface VolumePropertiesDataProtection {
    backup?: VolumeBackupProperties;
    replication?: ReplicationObject;
    snapshot?: VolumeSnapshotProperties;
    volumeRelocation?: VolumeRelocationProperties;
}

// @public
export interface VolumePropertiesExportPolicy {
    rules?: ExportPolicyRule[];
}

// @public
export interface VolumeQuotaRule extends TrackedResource {
    properties?: VolumeQuotaRulesProperties;
}

// @public
export interface VolumeQuotaRulePatch {
    properties?: VolumeQuotaRulesProperties;
    tags?: Record<string, string>;
}

// @public
export interface VolumeQuotaRulesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumeQuotaRulesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumeQuotaRulesGetOptionalParams extends OperationOptions {
}

// @public
export interface VolumeQuotaRulesListByVolumeOptionalParams extends OperationOptions {
}

// @public
export interface VolumeQuotaRulesOperations {
    create: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRule, options?: VolumeQuotaRulesCreateOptionalParams) => PollerLike<OperationState<VolumeQuotaRule>, VolumeQuotaRule>;
    delete: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, options?: VolumeQuotaRulesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, options?: VolumeQuotaRulesGetOptionalParams) => Promise<VolumeQuotaRule>;
    listByVolume: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumeQuotaRulesListByVolumeOptionalParams) => PagedAsyncIterableIterator<VolumeQuotaRule>;
    update: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, volumeQuotaRuleName: string, body: VolumeQuotaRulePatch, options?: VolumeQuotaRulesUpdateOptionalParams) => PollerLike<OperationState<VolumeQuotaRule>, VolumeQuotaRule>;
}

// @public
export interface VolumeQuotaRulesProperties {
    readonly provisioningState?: NetAppProvisioningState;
    quotaSizeInKiBs?: number;
    quotaTarget?: string;
    quotaType?: Type;
}

// @public
export interface VolumeQuotaRulesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumeRelocationProperties {
    readonly readyToBeFinalized?: boolean;
    relocationRequested?: boolean;
}

// @public
export type VolumeReplicationRelationshipStatus = string;

// @public
export type VolumeRestoreRelationshipStatus = string;

// @public
export interface VolumeRevert {
    snapshotId?: string;
}

// @public
export interface VolumesAuthorizeExternalReplicationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesAuthorizeReplicationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesBreakFileLocksOptionalParams extends OperationOptions {
    body?: BreakFileLocksRequest;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesBreakReplicationOptionalParams extends OperationOptions {
    body?: BreakReplicationRequest;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesDeleteOptionalParams extends OperationOptions {
    forceDelete?: boolean;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesDeleteReplicationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesFinalizeExternalReplicationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesFinalizeRelocationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesGetOptionalParams extends OperationOptions {
}

// @public
export interface VolumesListGetGroupIdListForLdapUserOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesListOptionalParams extends OperationOptions {
}

// @public
export interface VolumesListQuotaReportOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesListReplicationsOptionalParams extends OperationOptions {
}

// @public
export interface VolumeSnapshotProperties {
    snapshotPolicyId?: string;
}

// @public
export interface VolumesOperations {
    authorizeExternalReplication: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesAuthorizeExternalReplicationOptionalParams) => PollerLike<OperationState<SvmPeerCommandResponse>, SvmPeerCommandResponse>;
    authorizeReplication: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: AuthorizeRequest, options?: VolumesAuthorizeReplicationOptionalParams) => PollerLike<OperationState<void>, void>;
    breakFileLocks: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesBreakFileLocksOptionalParams) => PollerLike<OperationState<void>, void>;
    breakReplication: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesBreakReplicationOptionalParams) => PollerLike<OperationState<void>, void>;
    createOrUpdate: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: Volume, options?: VolumesCreateOrUpdateOptionalParams) => PollerLike<OperationState<Volume>, Volume>;
    delete: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    deleteReplication: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesDeleteReplicationOptionalParams) => PollerLike<OperationState<void>, void>;
    finalizeExternalReplication: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesFinalizeExternalReplicationOptionalParams) => PollerLike<OperationState<void>, void>;
    finalizeRelocation: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesFinalizeRelocationOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesGetOptionalParams) => Promise<Volume>;
    list: (resourceGroupName: string, accountName: string, poolName: string, options?: VolumesListOptionalParams) => PagedAsyncIterableIterator<Volume>;
    listGetGroupIdListForLdapUser: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: GetGroupIdListForLdapUserRequest, options?: VolumesListGetGroupIdListForLdapUserOptionalParams) => PollerLike<OperationState<GetGroupIdListForLdapUserResponse>, GetGroupIdListForLdapUserResponse>;
    listQuotaReport: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesListQuotaReportOptionalParams) => PollerLike<OperationState<ListQuotaReportResponse>, ListQuotaReportResponse>;
    listReplications: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesListReplicationsOptionalParams) => PagedAsyncIterableIterator<Replication>;
    peerExternalCluster: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: PeerClusterForVolumeMigrationRequest, options?: VolumesPeerExternalClusterOptionalParams) => PollerLike<OperationState<ClusterPeerCommandResponse>, ClusterPeerCommandResponse>;
    performReplicationTransfer: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesPerformReplicationTransferOptionalParams) => PollerLike<OperationState<void>, void>;
    poolChange: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: PoolChangeRequest, options?: VolumesPoolChangeOptionalParams) => PollerLike<OperationState<void>, void>;
    populateAvailabilityZone: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesPopulateAvailabilityZoneOptionalParams) => PollerLike<OperationState<Volume>, Volume>;
    reestablishReplication: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: ReestablishReplicationRequest, options?: VolumesReestablishReplicationOptionalParams) => PollerLike<OperationState<void>, void>;
    reInitializeReplication: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesReInitializeReplicationOptionalParams) => PollerLike<OperationState<void>, void>;
    relocate: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRelocateOptionalParams) => PollerLike<OperationState<void>, void>;
    replicationStatus: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesReplicationStatusOptionalParams) => Promise<ReplicationStatus>;
    resetCifsPassword: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResetCifsPasswordOptionalParams) => PollerLike<OperationState<void>, void>;
    resyncReplication: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesResyncReplicationOptionalParams) => PollerLike<OperationState<void>, void>;
    revert: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumeRevert, options?: VolumesRevertOptionalParams) => PollerLike<OperationState<void>, void>;
    revertRelocation: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesRevertRelocationOptionalParams) => PollerLike<OperationState<void>, void>;
    splitCloneFromParent: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, options?: VolumesSplitCloneFromParentOptionalParams) => PollerLike<OperationState<Volume>, Volume>;
    update: (resourceGroupName: string, accountName: string, poolName: string, volumeName: string, body: VolumePatch, options?: VolumesUpdateOptionalParams) => PollerLike<OperationState<Volume>, Volume>;
}

// @public
export interface VolumesPeerExternalClusterOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesPerformReplicationTransferOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesPoolChangeOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesPopulateAvailabilityZoneOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesReestablishReplicationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesReInitializeReplicationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesRelocateOptionalParams extends OperationOptions {
    body?: RelocateVolumeRequest;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesReplicationStatusOptionalParams extends OperationOptions {
}

// @public
export interface VolumesResetCifsPasswordOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesResyncReplicationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesRevertOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesRevertRelocationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VolumesSplitCloneFromParentOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export type VolumeStorageToNetworkProximity = string;

// @public
export interface VolumesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface WeeklySchedule {
    day?: string;
    hour?: number;
    minute?: number;
    snapshotsToKeep?: number;
    usedBytes?: number;
}

// (No @packageDocumentation comment for this package)

```
