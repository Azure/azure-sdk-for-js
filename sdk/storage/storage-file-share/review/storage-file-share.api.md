## API Report File for "@azure/storage-file-share"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { BaseRequestPolicy } from '@azure/core-http';
import * as coreHttp from '@azure/core-http';
import { deserializationPolicy } from '@azure/core-http';
import { HttpHeaders } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { HttpRequestBody } from '@azure/core-http';
import { HttpResponse } from '@azure/core-http';
import { HttpClient as IHttpClient } from '@azure/core-http';
import { KeepAliveOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { ProxyOptions } from '@azure/core-http';
import { Readable } from 'stream';
import { RequestPolicy } from '@azure/core-http';
import { RequestPolicyFactory } from '@azure/core-http';
import { RequestPolicyOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { SpanOptions } from '@opentelemetry/types';
import { TransferProgressEvent } from '@azure/core-http';
import { UserAgentOptions } from '@azure/core-http';
import { WebResource } from '@azure/core-http';

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

export { BaseRequestPolicy }

// @public
export interface CommonOptions {
    // Warning: (ae-forgotten-export) The symbol "OperationTracingOptions" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    tracingOptions?: OperationTracingOptions;
}

// @public
export type CopyStatusType = 'pending' | 'success' | 'aborted' | 'failed';

// @public
export abstract class Credential implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;

// @public
export type DeleteSnapshotsOptionType = 'include';

export { deserializationPolicy }

// Warning: (ae-forgotten-export) The symbol "FileAndDirectoryCreateCommonOptions" needs to be exported by the entry point index.d.ts
// 
// @public
export interface DirectoryCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
    // Warning: (ae-forgotten-export) The symbol "Metadata" needs to be exported by the entry point index.d.ts
    metadata?: Metadata;
}

// Warning: (ae-forgotten-export) The symbol "DirectoryCreateHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type DirectoryCreateResponse = DirectoryCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: DirectoryCreateHeaders;
    };
};

// @public
export interface DirectoryDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "DirectoryDeleteHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type DirectoryDeleteResponse = DirectoryDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: DirectoryDeleteHeaders;
    };
};

// @public
export interface DirectoryForceCloseHandlesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "DirectoryForceCloseHandlesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type DirectoryForceCloseHandlesResponse = DirectoryForceCloseHandlesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: DirectoryForceCloseHandlesHeaders;
    };
};

// @public
export interface DirectoryForceCloseHandlesSegmentOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    recursive?: boolean;
}

// @public
export interface DirectoryGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "DirectoryGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type DirectoryGetPropertiesResponse = DirectoryGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: DirectoryGetPropertiesHeaders;
    };
};

// @public
export interface DirectoryItem {
    // (undocumented)
    name: string;
}

// @public
export interface DirectoryListFilesAndDirectoriesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    prefix?: string;
}

// Warning: (ae-forgotten-export) The symbol "ListFilesAndDirectoriesSegmentResponse" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DirectoryListFilesAndDirectoriesSegmentHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type DirectoryListFilesAndDirectoriesSegmentResponse = ListFilesAndDirectoriesSegmentResponse & DirectoryListFilesAndDirectoriesSegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: DirectoryListFilesAndDirectoriesSegmentHeaders;
        bodyAsText: string;
        parsedBody: ListFilesAndDirectoriesSegmentResponse;
    };
};

// @public
export interface DirectoryListHandlesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    recursive?: boolean;
}

// Warning: (ae-forgotten-export) The symbol "ListHandlesResponse" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DirectoryListHandlesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type DirectoryListHandlesResponse = ListHandlesResponse & DirectoryListHandlesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: DirectoryListHandlesHeaders;
        bodyAsText: string;
        parsedBody: ListHandlesResponse;
    };
};

// @public
export interface DirectoryListHandlesSegmentOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    maxResults?: number;
    recursive?: boolean;
}

// Warning: (ae-forgotten-export) The symbol "FileAndDirectorySetPropertiesCommonOptions" needs to be exported by the entry point index.d.ts
// 
// @public (undocumented)
export interface DirectoryProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface DirectorySetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "DirectorySetMetadataHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type DirectorySetMetadataResponse = DirectorySetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: DirectorySetMetadataHeaders;
    };
};

// Warning: (ae-forgotten-export) The symbol "DirectorySetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type DirectorySetPropertiesResponse = DirectorySetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: DirectorySetPropertiesHeaders;
    };
};

// @public
export interface FileAbortCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "FileAbortCopyHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileAbortCopyResponse = FileAbortCopyHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileAbortCopyHeaders;
    };
};

// @public
export type FileAttributesPreserveType = "preserve";

// @public
export interface FileClearRangeOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface FileCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
    // Warning: (ae-forgotten-export) The symbol "FileHttpHeaders" needs to be exported by the entry point index.d.ts
    fileHttpHeaders?: FileHttpHeaders;
    metadata?: Metadata;
}

// Warning: (ae-forgotten-export) The symbol "FileCreateHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileCreateResponse = FileCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileCreateHeaders;
    };
};

// @public
export interface FileDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "FileDeleteHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileDeleteResponse = FileDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileDeleteHeaders;
    };
};

// @public
export interface FileDownloadHeaders {
    acceptRanges?: string;
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentRange?: string;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    fileAttributes?: string;
    fileChangeOn?: Date;
    fileContentMD5?: Uint8Array;
    fileCreatedOn?: Date;
    fileId?: string;
    fileLastWriteOn?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface FileDownloadOptionalParams extends coreHttp.RequestOptionsBase {
    range?: string;
    rangeGetContentMD5?: boolean;
    timeoutInSeconds?: number;
}

// @public
export interface FileDownloadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    maxRetryRequests?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeGetContentMD5?: boolean;
}

// @public
export type FileDownloadResponseModel = FileDownloadHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileDownloadHeaders;
    };
};

// @public
export interface FileDownloadToBufferOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    concurrency?: number;
    maxRetryRequestsPerRange?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeSize?: number;
}

// @public
export interface FileForceCloseHandlesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "FileForceCloseHandlesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileForceCloseHandlesResponse = FileForceCloseHandlesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileForceCloseHandlesHeaders;
    };
};

// @public
export interface FileGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "FileGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileGetPropertiesResponse = FileGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileGetPropertiesHeaders;
    };
};

// @public
export interface FileGetRangeListHeaders {
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    fileContentLength?: number;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface FileGetRangeListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    range?: Range;
}

// @public
export type FileGetRangeListResponse = FileGetRangeListHeaders & {
    rangeList: RangeModel[];
    _response: HttpResponse & {
        parsedHeaders: FileGetRangeListHeaders;
        bodyAsText: string;
        parsedBody: RangeModel[];
    };
};

// @public
export interface FileItem {
    // (undocumented)
    name: string;
    // Warning: (ae-forgotten-export) The symbol "FileProperty" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    properties: FileProperty;
}

// @public (undocumented)
export interface FileListHandlesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "FileListHandlesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileListHandlesResponse = ListHandlesResponse & FileListHandlesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileListHandlesHeaders;
        bodyAsText: string;
        parsedBody: ListHandlesResponse;
    };
};

// @public
export interface FileListHandlesSegmentOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    maxPageSize?: number;
}

// @public
export interface FileParallelUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    concurrency?: number;
    fileHttpHeaders?: FileHttpHeaders;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeSize?: number;
}

// @public
export type FilePermissionInheritType = "inherit";

// @public
export type FilePermissionPreserveType = "preserve";

// @public (undocumented)
export interface FileProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
    fileHttpHeaders?: FileHttpHeaders;
}

// @public
export interface FileResizeOptions extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export class FileSASPermissions {
    create: boolean;
    delete: boolean;
    static parse(permissions: string): FileSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface FileSASSignatureValues {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    expiresOn?: Date;
    filePath?: string;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: FileSASPermissions;
    protocol?: SASProtocol;
    shareName: string;
    startsOn?: Date;
    version?: string;
}

// @public
export interface FileServiceProperties {
    // Warning: (ae-forgotten-export) The symbol "CorsRule" needs to be exported by the entry point index.d.ts
    cors?: CorsRule[];
    // Warning: (ae-forgotten-export) The symbol "Metrics" needs to be exported by the entry point index.d.ts
    hourMetrics?: Metrics;
    minuteMetrics?: Metrics;
}

// @public
export interface FileSetHttpHeadersOptions extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "FileSetHTTPHeadersHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileSetHTTPHeadersResponse = FileSetHTTPHeadersHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileSetHTTPHeadersHeaders;
    };
};

// @public
export interface FileSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "FileSetMetadataHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileSetMetadataResponse = FileSetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileSetMetadataHeaders;
    };
};

// @public
export interface FileStartCopyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: Metadata;
}

// Warning: (ae-forgotten-export) The symbol "FileStartCopyHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileStartCopyResponse = FileStartCopyHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileStartCopyHeaders;
    };
};

// @public
export class FileSystemAttributes {
    archive: boolean;
    directory: boolean;
    hidden: boolean;
    none: boolean;
    noScrubData: boolean;
    notContentIndexed: boolean;
    offline: boolean;
    static parse(fileAttributes: string): FileSystemAttributes;
    readonly: boolean;
    system: boolean;
    temporary: boolean;
    toString(): string;
}

// @public
export interface FileUploadRangeFromURLOptionalParams extends coreHttp.RequestOptionsBase {
    sourceContentCrc64?: Uint8Array;
    sourceModifiedAccessConditions?: SourceModifiedAccessConditions;
    sourceRange?: string;
    timeoutInSeconds?: number;
}

// @public
export interface FileUploadRangeFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    sourceConditions?: SourceModifiedAccessConditions;
    sourceContentCrc64?: Uint8Array;
    timeoutInSeconds?: number;
}

// Warning: (ae-forgotten-export) The symbol "FileUploadRangeFromURLHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileUploadRangeFromURLResponse = FileUploadRangeFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileUploadRangeFromURLHeaders;
    };
};

// @public
export interface FileUploadRangeOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    contentMD5?: Uint8Array;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// Warning: (ae-forgotten-export) The symbol "FileUploadRangeHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type FileUploadRangeResponse = FileUploadRangeHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileUploadRangeHeaders;
    };
};

// @public
export interface FileUploadStreamOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    fileHttpHeaders?: FileHttpHeaders;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateFileSASQueryParameters(fileSASSignatureValues: FileSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export interface HandleItem {
    clientIp: string;
    fileId: string;
    handleId: string;
    lastReconnectTime?: Date;
    openTime: Date;
    parentId?: string;
    path: string;
    sessionId: string;
}

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

export { IHttpClient }

// @public
export type ListSharesIncludeType = 'snapshots' | 'metadata';

// @public
export const logger: import("@azure/logger").AzureLogger;

// @public
export function newPipeline(credential: Credential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export class Pipeline {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: IHttpClient;
}

// @public
export interface Range {
    count?: number;
    offset: number;
}

// @public
export interface RangeModel {
    end: number;
    start: number;
}

export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

export { RestError }

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string);
    readonly cacheControl?: string;
    readonly contentDisposition?: string;
    readonly contentEncoding?: string;
    readonly contentLanguage?: string;
    readonly contentType?: string;
    readonly expiresOn?: Date;
    readonly identifier?: string;
    readonly ipRange: SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ServiceGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceGetPropertiesResponse = FileServiceProperties & ServiceGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetPropertiesHeaders;
        bodyAsText: string;
        parsedBody: FileServiceProperties;
    };
};

// @public
export interface ServiceListSharesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeMetadata?: boolean;
    includeSnapshots?: boolean;
    prefix?: string;
}

// Warning: (ae-forgotten-export) The symbol "ListSharesResponse" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ServiceListSharesSegmentHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceListSharesSegmentResponse = ListSharesResponse & ServiceListSharesSegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceListSharesSegmentHeaders;
        bodyAsText: string;
        parsedBody: ListSharesResponse;
    };
};

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ServiceSetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceSetPropertiesHeaders;
    };
};

// @public (undocumented)
export interface SetPropertiesResponse extends FileSetHTTPHeadersResponse {
}

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
// 
// @public
export class ShareClient extends StorageClient {
    constructor(connectionString: string, name: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    create(options?: ShareCreateOptions): Promise<ShareCreateResponse>;
    createDirectory(directoryName: string, options?: DirectoryCreateOptions): Promise<{
        directoryClient: ShareDirectoryClient;
        directoryCreateResponse: DirectoryCreateResponse;
    }>;
    createFile(fileName: string, size: number, options?: FileCreateOptions): Promise<{
        fileClient: ShareFileClient;
        fileCreateResponse: FileCreateResponse;
    }>;
    createPermission(filePermission: string, options?: ShareCreatePermissionOptions): Promise<ShareCreatePermissionResponse>;
    createSnapshot(options?: ShareCreateSnapshotOptions): Promise<ShareCreateSnapshotResponse>;
    delete(options?: ShareDeleteMethodOptions): Promise<ShareDeleteResponse>;
    deleteDirectory(directoryName: string, options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    deleteFile(fileName: string, options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    getAccessPolicy(options?: ShareGetAccessPolicyOptions): Promise<ShareGetAccessPolicyResponse>;
    getDirectoryClient(directoryName: string): ShareDirectoryClient;
    getPermission(filePermissionKey: string, options?: ShareGetPermissionOptions): Promise<ShareGetPermissionResponse>;
    getProperties(options?: ShareGetPropertiesOptions): Promise<ShareGetPropertiesResponse>;
    getStatistics(options?: ShareGetStatisticsOptions): Promise<ShareGetStatisticsResponse>;
    readonly name: string;
    readonly rootDirectoryClient: ShareDirectoryClient;
    setAccessPolicy(shareAcl?: SignedIdentifier[], options?: ShareSetAccessPolicyOptions): Promise<ShareSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: ShareSetMetadataOptions): Promise<ShareSetMetadataResponse>;
    setQuota(quotaInGB: number, options?: ShareSetQuotaOptions): Promise<ShareSetQuotaResponse>;
    withSnapshot(snapshot: string): ShareClient;
}

// @public
export interface ShareCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: {
        [propertyName: string]: string;
    };
    quota?: number;
}

// @public
export interface ShareCreatePermissionOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ShareCreatePermissionHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareCreatePermissionResponse = ShareCreatePermissionHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareCreatePermissionHeaders;
    };
};

// Warning: (ae-forgotten-export) The symbol "ShareCreateHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareCreateResponse = ShareCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareCreateHeaders;
    };
};

// @public
export interface ShareCreateSnapshotOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: {
        [propertyName: string]: string;
    };
}

// Warning: (ae-forgotten-export) The symbol "ShareCreateSnapshotHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareCreateSnapshotResponse = ShareCreateSnapshotHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareCreateSnapshotHeaders;
    };
};

// @public
export interface ShareDeleteMethodOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    deleteSnapshots?: DeleteSnapshotsOptionType;
}

// Warning: (ae-forgotten-export) The symbol "ShareDeleteHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareDeleteResponse = ShareDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareDeleteHeaders;
    };
};

// @public
export class ShareDirectoryClient extends StorageClient {
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    create(options?: DirectoryCreateOptions): Promise<DirectoryCreateResponse>;
    createFile(fileName: string, size: number, options?: FileCreateOptions): Promise<{
        fileClient: ShareFileClient;
        fileCreateResponse: FileCreateResponse;
    }>;
    createSubdirectory(directoryName: string, options?: DirectoryCreateOptions): Promise<{
        directoryClient: ShareDirectoryClient;
        directoryCreateResponse: DirectoryCreateResponse;
    }>;
    delete(options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    deleteFile(fileName: string, options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    deleteSubdirectory(directoryName: string, options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    forceCloseAllHandles(options?: DirectoryForceCloseHandlesSegmentOptions): Promise<number>;
    forceCloseHandle(handleId: string, options?: DirectoryForceCloseHandlesOptions): Promise<DirectoryForceCloseHandlesResponse>;
    getDirectoryClient(subDirectoryName: string): ShareDirectoryClient;
    getFileClient(fileName: string): ShareFileClient;
    getProperties(options?: DirectoryGetPropertiesOptions): Promise<DirectoryGetPropertiesResponse>;
    listFilesAndDirectories(options?: DirectoryListFilesAndDirectoriesOptions): PagedAsyncIterableIterator<{
        kind: "file";
    } & FileItem | {
        kind: "directory";
    } & DirectoryItem, DirectoryListFilesAndDirectoriesSegmentResponse>;
    listHandles(options?: DirectoryListHandlesOptions): PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse>;
    readonly name: string;
    readonly path: string;
    setMetadata(metadata?: Metadata, options?: DirectorySetMetadataOptions): Promise<DirectorySetMetadataResponse>;
    setProperties(properties?: DirectoryProperties): Promise<DirectorySetPropertiesResponse>;
    readonly shareName: string;
    }

// @public
export class ShareFileClient extends StorageClient {
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    abortCopyFromURL(copyId: string, options?: FileAbortCopyFromURLOptions): Promise<FileAbortCopyResponse>;
    clearRange(offset: number, contentLength: number, options?: FileClearRangeOptions): Promise<FileUploadRangeResponse>;
    create(size: number, options?: FileCreateOptions): Promise<FileCreateResponse>;
    delete(options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    download(offset?: number, count?: number, options?: FileDownloadOptions): Promise<FileDownloadResponseModel>;
    downloadToBuffer(buffer: Buffer, offset?: number, count?: number, options?: FileDownloadToBufferOptions): Promise<Buffer>;
    downloadToBuffer(offset?: number, count?: number, options?: FileDownloadToBufferOptions): Promise<Buffer>;
    downloadToFile(filePath: string, offset?: number, count?: number, options?: FileDownloadOptions): Promise<FileDownloadResponseModel>;
    forceCloseAllHandles(options?: FileForceCloseHandlesOptions): Promise<number>;
    forceCloseHandle(handleId: string, options?: FileForceCloseHandlesOptions): Promise<FileForceCloseHandlesResponse>;
    getProperties(options?: FileGetPropertiesOptions): Promise<FileGetPropertiesResponse>;
    getRangeList(options?: FileGetRangeListOptions): Promise<FileGetRangeListResponse>;
    listHandles(options?: FileListHandlesOptions): PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse>;
    readonly name: string;
    readonly path: string;
    resize(length: number, options?: FileResizeOptions): Promise<FileSetHTTPHeadersResponse>;
    setHttpHeaders(fileHttpHeaders?: FileHttpHeaders, options?: FileSetHttpHeadersOptions): Promise<FileSetHTTPHeadersResponse>;
    setMetadata(metadata?: Metadata, options?: FileSetMetadataOptions): Promise<FileSetMetadataResponse>;
    setProperties(properties?: FileProperties): Promise<SetPropertiesResponse>;
    readonly shareName: string;
    startCopyFromURL(copySource: string, options?: FileStartCopyOptions): Promise<FileStartCopyResponse>;
    uploadBrowserData(browserData: Blob | ArrayBuffer | ArrayBufferView, options?: FileParallelUploadOptions): Promise<void>;
    uploadFile(filePath: string, options?: FileParallelUploadOptions): Promise<void>;
    uploadRange(body: HttpRequestBody, offset: number, contentLength: number, options?: FileUploadRangeOptions): Promise<FileUploadRangeResponse>;
    uploadRangeFromURL(sourceURL: string, sourceOffset: number, destOffset: number, count: number, options?: FileUploadRangeFromURLOptions): Promise<FileUploadRangeFromURLResponse>;
    uploadResetableStream(streamFactory: (offset: number, count?: number) => NodeJS.ReadableStream, size: number, options?: FileParallelUploadOptions): Promise<void>;
    uploadSeekableBlob(blobFactory: (offset: number, size: number) => Blob, size: number, options?: FileParallelUploadOptions): Promise<void>;
    uploadStream(stream: Readable, size: number, bufferSize: number, maxBuffers: number, options?: FileUploadStreamOptions): Promise<void>;
}

// @public
export interface ShareGetAccessPolicyHeaders {
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type ShareGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifier[];
} & ShareGetAccessPolicyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ShareGetAccessPolicyHeaders;
        bodyAsText: string;
        parsedBody: SignedIdentifierModel[];
    };
};

// @public
export interface ShareGetPermissionOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "SharePermission" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ShareGetPermissionHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareGetPermissionResponse = SharePermission & ShareGetPermissionHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareGetPermissionHeaders;
        bodyAsText: string;
        parsedBody: SharePermission;
    };
};

// @public
export interface ShareGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ShareGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareGetPropertiesResponse = ShareGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareGetPropertiesHeaders;
    };
};

// @public
export interface ShareGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ShareGetStatisticsResponse = ShareGetStatisticsResponseModel & {
    shareUsage: number;
};

// Warning: (ae-forgotten-export) The symbol "ShareStats" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ShareGetStatisticsHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareGetStatisticsResponseModel = ShareStats & ShareGetStatisticsHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareGetStatisticsHeaders;
        bodyAsText: string;
        parsedBody: ShareStats;
    };
};

// @public
export interface ShareItem {
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // Warning: (ae-forgotten-export) The symbol "ShareProperties" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    properties: ShareProperties;
    // (undocumented)
    snapshot?: string;
}

// @public
export class ShareSASPermissions {
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): ShareSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export class ShareServiceClient extends StorageClient {
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createShare(shareName: string, options?: ShareCreateOptions): Promise<{
        shareCreateResponse: ShareCreateResponse;
        shareClient: ShareClient;
    }>;
    deleteShare(shareName: string, options?: ShareDeleteMethodOptions): Promise<ShareDeleteResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): ShareServiceClient;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getShareClient(shareName: string): ShareClient;
    listShares(options?: ServiceListSharesOptions): PagedAsyncIterableIterator<ShareItem, ServiceListSharesSegmentResponse>;
    setProperties(properties: FileServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
}

// @public
export interface ShareSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ShareSetAccessPolicyHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareSetAccessPolicyResponse = ShareSetAccessPolicyHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareSetAccessPolicyHeaders;
    };
};

// @public
export interface ShareSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ShareSetMetadataHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareSetMetadataResponse = ShareSetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareSetMetadataHeaders;
    };
};

// @public
export interface ShareSetQuotaOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ShareSetQuotaHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ShareSetQuotaResponse = ShareSetQuotaHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ShareSetQuotaHeaders;
    };
};

// @public
export interface SignedIdentifier {
    accessPolicy: {
        startsOn: Date;
        expiresOn: Date;
        permissions: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    // Warning: (ae-forgotten-export) The symbol "AccessPolicy" needs to be exported by the entry point index.d.ts
    accessPolicy?: AccessPolicy;
    id: string;
}

// @public
export interface SourceModifiedAccessConditions {
    sourceIfMatchCrc64?: Uint8Array;
    sourceIfNoneMatchCrc64?: Uint8Array;
}

// @public
export class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}

// @public
export class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}

// @public
export interface StoragePipelineOptions {
    httpClient?: IHttpClient;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxyOptions;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentOptions;
}

// @public
export interface StorageRetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: StorageRetryPolicyType;
    readonly tryTimeoutInMs?: number;
}

// @public
export class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions);
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
}

// @public
export class StorageRetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: StorageRetryOptions);
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
    }

// @public
export enum StorageRetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export class StorageSharedKeyCredential extends Credential {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
}

// @public
export class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type TimeNowType = "now";

// @public
export type TimePreserveType = "preserve";

export { WebResource }


// (No @packageDocumentation comment for this package)

```
