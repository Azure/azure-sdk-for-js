## API Report File for "@azure/storage-file-share"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';
import { AzureLogger } from '@azure/logger';
import * as coreClient from '@azure/core-client';
import * as coreHttpCompat from '@azure/core-http-compat';
import * as coreRestPipeline from '@azure/core-rest-pipeline';
import { HttpHeadersLike as HttpHeaders } from '@azure/core-http-compat';
import { CompatResponse as HttpOperationResponse } from '@azure/core-http-compat';
import { HttpPipelineLogLevel } from '@azure/core-http-compat';
import { RequestBodyType as HttpRequestBody } from '@azure/core-rest-pipeline';
import { KeepAliveOptions } from '@azure/core-http-compat';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { ProxySettings } from '@azure/core-rest-pipeline';
import { Readable } from 'stream';
import { RequestPolicy } from '@azure/core-http-compat';
import { RequestPolicyFactory } from '@azure/core-http-compat';
import { RequestPolicyOptionsLike as RequestPolicyOptions } from '@azure/core-http-compat';
import { RestError } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';
import { TransferProgressEvent } from '@azure/core-rest-pipeline';
import { UserAgentPolicyOptions } from '@azure/core-rest-pipeline';
import { WebResourceLike as WebResource } from '@azure/core-http-compat';

// @public
export interface AccessPolicy {
    expiresOn?: string;
    permissions?: string;
    startsOn?: string;
}

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential_2 {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

// @public
export abstract class BaseRequestPolicy implements RequestPolicy {
    protected constructor(
    _nextPolicy: RequestPolicy,
    _options: RequestPolicyOptions);
    log(logLevel: HttpPipelineLogLevel, message: string): void;
    readonly _nextPolicy: RequestPolicy;
    readonly _options: RequestPolicyOptions;
    abstract sendRequest(webResource: WebResource): Promise<HttpOperationResponse>;
    shouldLog(logLevel: HttpPipelineLogLevel): boolean;
}

// @public (undocumented)
export interface ClearRange {
    // (undocumented)
    end: number;
    // (undocumented)
    start: number;
}

// @public
export interface CloseHandlesInfo {
    // (undocumented)
    closedHandlesCount: number;
    closeFailureCount?: number;
}

// @public
export interface CommonGenerateSasUrlOptions {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface CommonOptions {
    // (undocumented)
    tracingOptions?: OperationTracingOptions;
}

// @public
export interface CopyFileSmbInfo {
    fileAttributes?: string;
    fileChangeTime?: string;
    fileCreationTime?: string;
    fileLastWriteTime?: string;
    filePermissionCopyMode?: PermissionCopyModeType;
    ignoreReadOnly?: boolean;
    setArchiveAttribute?: boolean;
}

// @public
export type CopyStatusType = "pending" | "success" | "aborted" | "failed";

// @public
export interface CorsRule {
    allowedHeaders: string;
    allowedMethods: string;
    allowedOrigins: string;
    exposedHeaders: string;
    maxAgeInSeconds: number;
}

// @public
abstract class Credential_2 implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}
export { Credential_2 as Credential }

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;

// @public
export type DeleteSnapshotsOptionType = "include" | "include-leased";

// @public
export interface DirectoryCloseHandlesHeaders {
    date?: Date;
    marker?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface DirectoryCreateHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileAttributes?: string;
    fileChangeOn?: Date;
    fileCreatedOn?: Date;
    fileId?: string;
    fileLastWriteOn?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface DirectoryCreateIfNotExistsResponse extends DirectoryCreateResponse {
    succeeded: boolean;
}

// @public
export interface DirectoryCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: Metadata;
}

// @public
export type DirectoryCreateResponse = WithResponse<DirectoryCreateHeaders, DirectoryCreateHeaders>;

// @public
export interface DirectoryDeleteHeaders {
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface DirectoryDeleteIfExistsResponse extends DirectoryDeleteResponse {
    succeeded: boolean;
}

// @public
export interface DirectoryDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type DirectoryDeleteResponse = WithResponse<DirectoryDeleteHeaders, DirectoryDeleteHeaders>;

// @public
export interface DirectoryExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface DirectoryForceCloseHandlesHeaders {
    date?: Date;
    errorCode?: string;
    marker?: string;
    numberOfHandlesClosed?: number;
    numberOfHandlesFailedToClose?: number;
    requestId?: string;
    version?: string;
}

// @public
export interface DirectoryForceCloseHandlesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type DirectoryForceCloseHandlesResponse = WithResponse<CloseHandlesInfo & DirectoryCloseHandlesHeaders, DirectoryForceCloseHandlesHeaders>;

// @public
export interface DirectoryForceCloseHandlesSegmentOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    recursive?: boolean;
}

// @public
export interface DirectoryGetPropertiesHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileAttributes?: string;
    fileChangeOn?: Date;
    fileCreatedOn?: Date;
    fileId?: string;
    fileLastWriteOn?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface DirectoryGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type DirectoryGetPropertiesResponse = WithResponse<DirectoryGetPropertiesHeaders, DirectoryGetPropertiesHeaders>;

// @public
export interface DirectoryItem {
    // (undocumented)
    attributes?: string;
    // (undocumented)
    fileId?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    permissionKey?: string;
    properties?: FileProperty;
}

// @public
export interface DirectoryListFilesAndDirectoriesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    // (undocumented)
    includeAttributes?: boolean;
    // (undocumented)
    includeEtag?: boolean;
    includeExtendedInfo?: boolean;
    // (undocumented)
    includePermissionKey?: boolean;
    // (undocumented)
    includeTimestamps?: boolean;
    prefix?: string;
}

// @public
export interface DirectoryListFilesAndDirectoriesSegmentHeaders {
    contentType?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type DirectoryListFilesAndDirectoriesSegmentResponse = WithResponse<DirectoryListFilesAndDirectoriesSegmentHeaders & ListFilesAndDirectoriesSegmentResponse, DirectoryListFilesAndDirectoriesSegmentHeaders, ListFilesAndDirectoriesSegmentResponse>;

// @public
export interface DirectoryListHandlesHeaders {
    contentType?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface DirectoryListHandlesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    recursive?: boolean;
}

// @public
export type DirectoryListHandlesResponse = WithResponse<DirectoryListHandlesHeaders & ListHandlesResponse, DirectoryListHandlesHeaders, ListHandlesResponse>;

// @public
export interface DirectoryListHandlesSegmentOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    maxResults?: number;
    recursive?: boolean;
}

// @public (undocumented)
export interface DirectoryProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface DirectoryRenameHeaders {
    date?: Date;
    etag?: string;
    fileAttributes?: string;
    fileChangeTime?: Date;
    fileCreationTime?: Date;
    fileId?: string;
    fileLastWriteTime?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface DirectoryRenameOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    copyFileSmbInfo?: CopyFileSmbInfo;
    destinationLeaseAccessConditions?: LeaseAccessConditions;
    filePermission?: string;
    filePermissionKey?: string;
    ignoreReadOnly?: boolean;
    metadata?: Metadata;
    replaceIfExists?: boolean;
    sourceLeaseAccessConditions?: LeaseAccessConditions;
    timeoutInSeconds?: number;
}

// @public
export type DirectoryRenameResponse = WithResponse<DirectoryRenameHeaders, DirectoryRenameHeaders>;

// @public
export interface DirectorySetMetadataHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    requestId?: string;
    version?: string;
}

// @public
export interface DirectorySetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type DirectorySetMetadataResponse = WithResponse<DirectorySetMetadataHeaders, DirectorySetMetadataHeaders>;

// @public
export interface DirectorySetPropertiesHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileAttributes?: string;
    fileChangeOn?: Date;
    fileCreatedOn?: Date;
    fileId?: string;
    fileLastWriteOn?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export type DirectorySetPropertiesResponse = WithResponse<DirectorySetPropertiesHeaders, DirectorySetPropertiesHeaders>;

// @public
export interface FileAbortCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export interface FileAbortCopyHeaders {
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type FileAbortCopyResponse = WithResponse<FileAbortCopyHeaders, FileAbortCopyHeaders>;

// @public (undocumented)
export interface FileAndDirectoryCreateCommonOptions {
    changeTime?: Date | TimeNowType;
    creationTime?: Date | TimeNowType;
    fileAttributes?: FileSystemAttributes;
    filePermission?: string | FilePermissionInheritType;
    filePermissionKey?: string;
    lastWriteTime?: Date | TimeNowType;
}

// @public (undocumented)
export interface FileAndDirectorySetPropertiesCommonOptions {
    changeTime?: Date | TimeNowType;
    creationTime?: Date | TimeNowType | TimePreserveType;
    fileAttributes?: FileSystemAttributes | FileAttributesPreserveType;
    filePermission?: string | FilePermissionInheritType | FilePermissionPreserveType;
    filePermissionKey?: string;
    lastWriteTime?: Date | TimeNowType | TimePreserveType;
}

// @public
export type FileAttributesPreserveType = "preserve";

// @public
export interface FileClearRangeOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    fileLastWrittenMode?: FileLastWrittenMode;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export interface FileCloseHandlesHeaders {
    date?: Date;
    marker?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface FileCreateHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileAttributes?: string;
    fileChangeOn?: Date;
    fileCreatedOn?: Date;
    fileId?: string;
    fileLastWriteOn?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface FileCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
    fileHttpHeaders?: FileHttpHeaders;
    leaseAccessConditions?: LeaseAccessConditions;
    metadata?: Metadata;
}

// @public
export type FileCreateResponse = WithResponse<FileCreateHeaders, FileCreateHeaders>;

// @public
export interface FileDeleteHeaders {
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface FileDeleteIfExistsResponse extends FileDeleteResponse {
    succeeded: boolean;
}

// @public
export interface FileDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type FileDeleteResponse = WithResponse<FileDeleteHeaders, FileDeleteHeaders>;

// @public
export interface FileDownloadHeaders {
    acceptRanges?: string;
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentRange?: string;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileAttributes?: string;
    fileChangeOn?: Date;
    fileContentMD5?: Uint8Array;
    fileCreatedOn?: Date;
    fileId?: string;
    fileLastWriteOn?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface FileDownloadOptionalParams extends coreClient.OperationOptions {
    allowTrailingDot?: boolean;
    fileRequestIntent?: ShareTokenIntent;
    leaseAccessConditions?: LeaseAccessConditions;
    range?: string;
    rangeGetContentMD5?: boolean;
    timeoutInSeconds?: number;
}

// @public
export interface FileDownloadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
    maxRetryRequests?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeGetContentMD5?: boolean;
}

// @public
export type FileDownloadResponseModel = WithResponse<RawFileDownloadResponse, FileDownloadHeaders>;

// @public
export interface FileDownloadToBufferOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    concurrency?: number;
    leaseAccessConditions?: LeaseAccessConditions;
    maxRetryRequestsPerRange?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeSize?: number;
}

// @public
export interface FileExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface FileForceCloseHandlesHeaders {
    date?: Date;
    errorCode?: string;
    marker?: string;
    numberOfHandlesClosed?: number;
    numberOfHandlesFailedToClose?: number;
    requestId?: string;
    version?: string;
}

// @public
export interface FileForceCloseHandlesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type FileForceCloseHandlesResponse = WithResponse<CloseHandlesInfo & FileCloseHandlesHeaders, FileForceCloseHandlesHeaders>;

// @public
export interface FileGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: FileSASPermissions;
}

// @public
export interface FileGetPropertiesHeaders {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileAttributes?: string;
    fileChangeOn?: Date;
    fileCreatedOn?: Date;
    fileId?: string;
    fileLastWriteOn?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    fileType?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface FileGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type FileGetPropertiesResponse = WithResponse<FileGetPropertiesHeaders, FileGetPropertiesHeaders>;

// @public
export type FileGetRangeListDiffResponse = WithResponse<FileGetRangeListHeaders & ShareFileRangeList, FileGetRangeListHeaders, ShareFileRangeList>;

// @public
export interface FileGetRangeListHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileContentLength?: number;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface FileGetRangeListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
    range?: Range_2;
}

// @public
export type FileGetRangeListResponse = WithResponse<FileGetRangeListHeaders & {
    rangeList: RangeModel[];
}, FileGetRangeListHeaders, RangeModel[]>;

// @public (undocumented)
export interface FileHttpHeaders {
    fileCacheControl?: string;
    fileContentDisposition?: string;
    fileContentEncoding?: string;
    fileContentLanguage?: string;
    fileContentMD5?: Uint8Array;
    fileContentType?: string;
}

// @public
export interface FileItem {
    // (undocumented)
    attributes?: string;
    // (undocumented)
    fileId?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    permissionKey?: string;
    properties: FileProperty;
}

// @public
export type FileLastWrittenMode = "Now" | "Preserve";

// @public
export interface FileListHandlesHeaders {
    contentType?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export interface FileListHandlesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type FileListHandlesResponse = WithResponse<FileListHandlesHeaders & ListHandlesResponse, FileListHandlesHeaders, ListHandlesResponse>;

// @public
export interface FileListHandlesSegmentOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    maxPageSize?: number;
}

// @public
export interface FileParallelUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    concurrency?: number;
    fileHttpHeaders?: FileHttpHeaders;
    leaseAccessConditions?: LeaseAccessConditions;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeSize?: number;
}

// @public
export type FilePermissionInheritType = "inherit";

// @public
export type FilePermissionPreserveType = "preserve";

// @public (undocumented)
export interface FileProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
    fileHttpHeaders?: FileHttpHeaders;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export interface FileProperty {
    // (undocumented)
    changeTime?: Date;
    contentLength: number;
    // (undocumented)
    creationTime?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastAccessTime?: Date;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    lastWriteTime?: Date;
}

// @public
export interface FileRenameHeaders {
    date?: Date;
    etag?: string;
    fileAttributes?: string;
    fileChangeTime?: Date;
    fileCreationTime?: Date;
    fileId?: string;
    fileLastWriteTime?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface FileRenameOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    contentType?: string;
    copyFileSmbInfo?: CopyFileSmbInfo;
    destinationLeaseAccessConditions?: LeaseAccessConditions;
    filePermission?: string;
    filePermissionKey?: string;
    ignoreReadOnly?: boolean;
    metadata?: Metadata;
    replaceIfExists?: boolean;
    sourceLeaseAccessConditions?: LeaseAccessConditions;
    timeoutInSeconds?: number;
}

// @public
export type FileRenameResponse = WithResponse<FileRenameHeaders, FileRenameHeaders>;

// @public
export interface FileResizeOptions extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export interface FilesAndDirectoriesListSegment {
    // (undocumented)
    directoryItems: DirectoryItem[];
    // (undocumented)
    fileItems: FileItem[];
}

// @public
export class FileSASPermissions {
    create: boolean;
    delete: boolean;
    static parse(permissions: string): FileSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface FileSASSignatureValues {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    expiresOn?: Date;
    filePath?: string;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: FileSASPermissions | ShareSASPermissions;
    protocol?: SASProtocol;
    shareName: string;
    startsOn?: Date;
    version?: string;
}

// @public
export interface FileServiceProperties {
    cors?: CorsRule[];
    hourMetrics?: Metrics;
    minuteMetrics?: Metrics;
    protocol?: ShareProtocolSettings;
}

// @public
export interface FileSetHTTPHeadersHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileAttributes?: string;
    fileChangeOn?: Date;
    fileCreatedOn?: Date;
    fileId?: string;
    fileLastWriteOn?: Date;
    fileParentId?: string;
    filePermissionKey?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface FileSetHttpHeadersOptions extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type FileSetHTTPHeadersResponse = WithResponse<FileSetHTTPHeadersHeaders, FileSetHTTPHeadersHeaders>;

// @public
export interface FileSetMetadataHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    requestId?: string;
    version?: string;
}

// @public
export interface FileSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type FileSetMetadataResponse = WithResponse<FileSetMetadataHeaders, FileSetMetadataHeaders>;

// @public
export interface FileStartCopyHeaders {
    copyId?: string;
    copyStatus?: CopyStatusType;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface FileStartCopyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    copyFileSmbInfo?: CopyFileSmbInfo;
    filePermission?: string;
    filePermissionKey?: string;
    leaseAccessConditions?: LeaseAccessConditions;
    metadata?: Metadata;
}

// @public
export type FileStartCopyResponse = WithResponse<FileStartCopyHeaders, FileStartCopyHeaders>;

// @public
export class FileSystemAttributes {
    archive: boolean;
    directory: boolean;
    hidden: boolean;
    none: boolean;
    noScrubData: boolean;
    notContentIndexed: boolean;
    offline: boolean;
    static parse(fileAttributes: string): FileSystemAttributes;
    readonly: boolean;
    system: boolean;
    temporary: boolean;
    toString(): string;
}

// @public
export interface FileUploadRangeFromURLHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileLastWriteTime?: Date;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface FileUploadRangeFromURLOptionalParams extends coreClient.OperationOptions {
    allowSourceTrailingDot?: boolean;
    allowTrailingDot?: boolean;
    copySourceAuthorization?: string;
    fileLastWrittenMode?: FileLastWrittenMode;
    leaseAccessConditions?: LeaseAccessConditions;
    sourceContentCrc64?: Uint8Array;
    sourceModifiedAccessConditions?: SourceModifiedAccessConditions;
    sourceRange?: string;
    timeoutInSeconds?: number;
}

// @public
export interface FileUploadRangeFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    fileLastWrittenMode?: FileLastWrittenMode;
    leaseAccessConditions?: LeaseAccessConditions;
    sourceAuthorization?: HttpAuthorization;
    sourceConditions?: SourceModifiedAccessConditions;
    sourceContentCrc64?: Uint8Array;
    timeoutInSeconds?: number;
}

// @public
export type FileUploadRangeFromURLResponse = WithResponse<FileUploadRangeFromURLHeaders, FileUploadRangeFromURLHeaders>;

// @public
export interface FileUploadRangeHeaders {
    contentMD5?: Uint8Array;
    date?: Date;
    errorCode?: string;
    etag?: string;
    fileLastWriteTime?: Date;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface FileUploadRangeOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    contentMD5?: Uint8Array;
    fileLastWrittenMode?: FileLastWrittenMode;
    leaseAccessConditions?: LeaseAccessConditions;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export type FileUploadRangeResponse = WithResponse<FileUploadRangeHeaders, FileUploadRangeHeaders>;

// @public
export interface FileUploadStreamOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    fileHttpHeaders?: FileHttpHeaders;
    leaseAccessConditions?: LeaseAccessConditions;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateFileSASQueryParameters(fileSASSignatureValues: FileSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public (undocumented)
export function getFileServiceAccountAudience(storageAccountName: string): string;

// @public
export interface HandleItem {
    // (undocumented)
    accessRightList?: ShareFileHandleAccessRights[];
    clientIp: string;
    fileId: string;
    handleId: string;
    lastReconnectTime?: Date;
    openTime: Date;
    parentId?: string;
    path: string;
    sessionId: string;
}

// @public
export interface HttpAuthorization {
    scheme: string;
    value: string;
}

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

// @public
export interface HttpResponse {
    headers: HttpHeaders;
    request: WebResource;
    status: number;
}

// @public
export function isPipelineLike(pipeline: unknown): pipeline is PipelineLike;

// @public
export enum KnownShareTokenIntent {
    // (undocumented)
    Backup = "backup"
}

// @public
export interface LeaseAccessConditions {
    leaseId?: string;
}

// @public
export type LeaseDurationType = "infinite" | "fixed";

// @public
export interface LeaseOperationOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type LeaseOperationResponse = WithResponse<LeaseOperationResponseHeaders, LeaseOperationResponseHeaders>;

// @public
export interface LeaseOperationResponseHeaders {
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    leaseId?: string;
    leaseTimeInSeconds?: number;
    requestId?: string;
    version?: string;
}

// @public
export type LeaseStateType = "available" | "leased" | "expired" | "breaking" | "broken";

// @public
export type LeaseStatusType = "locked" | "unlocked";

// @public
export interface ListFilesAndDirectoriesSegmentResponse {
    // (undocumented)
    continuationToken: string;
    // (undocumented)
    directoryId?: string;
    // (undocumented)
    directoryPath: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxResults?: number;
    // (undocumented)
    prefix: string;
    segment: FilesAndDirectoriesListSegment;
    // (undocumented)
    serviceEndpoint: string;
    // (undocumented)
    shareName: string;
    // (undocumented)
    shareSnapshot?: string;
}

// @public
export interface ListHandlesResponse {
    // (undocumented)
    continuationToken: string;
    // (undocumented)
    handleList?: HandleItem[];
}

// @public
export type ListSharesIncludeType = "snapshots" | "metadata" | "deleted";

// @public
export interface ListSharesResponse {
    // (undocumented)
    continuationToken: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxResults?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    serviceEndpoint: string;
    // (undocumented)
    shareItems?: ShareItem[];
}

// @public
export interface ListSharesResponseModel {
    // (undocumented)
    continuationToken: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxResults?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    serviceEndpoint: string;
    // (undocumented)
    shareItems?: ShareItemInternal[];
}

// @public
export const logger: AzureLogger;

// @public (undocumented)
export interface Metadata {
    // (undocumented)
    [propertyName: string]: string;
}

// @public
export interface Metrics {
    enabled: boolean;
    includeAPIs?: boolean;
    retentionPolicy?: RetentionPolicy;
    version: string;
}

// @public
export function newPipeline(credential?: Credential_2 | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export type PermissionCopyModeType = "source" | "override";

// @public
export class Pipeline implements PipelineLike {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineLike {
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: RequestPolicy;
    shareTokenIntent?: ShareTokenIntent;
}

// @public
interface Range_2 {
    count?: number;
    offset: number;
}
export { Range_2 as Range }

// @public
export interface RangeModel {
    end: number;
    start: number;
}

// @public
export type RawFileDownloadResponse = FileDownloadHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
};

export { RequestPolicy as IHttpClient }
export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

// @public
export interface ResponseLike {
    _response: HttpResponse;
}

// @public
export interface ResponseWithBody<Headers, Body> {
    _response: HttpResponse & {
        parsedHeaders: Headers;
        bodyAsText: string;
        parsedBody: Body;
    };
}

// @public
export interface ResponseWithHeaders<Headers> {
    _response: HttpResponse & {
        parsedHeaders: Headers;
    };
}

export { RestError }

// @public
export interface RetentionPolicy {
    days?: number;
    enabled: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string);
    readonly cacheControl?: string;
    readonly contentDisposition?: string;
    readonly contentEncoding?: string;
    readonly contentLanguage?: string;
    readonly contentType?: string;
    readonly expiresOn?: Date;
    readonly identifier?: string;
    get ipRange(): SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface ServiceClientOptions {
    httpClient?: RequestPolicy;
    requestPolicyFactories?: RequestPolicyFactory[] | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);
}

// @public
export interface ServiceGenerateAccountSasUrlOptions {
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface ServiceGetPropertiesHeaders {
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetPropertiesResponse = WithResponse<ServiceGetPropertiesHeaders & FileServiceProperties, ServiceGetPropertiesHeaders, FileServiceProperties>;

// @public
export interface ServiceListSharesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeDeleted?: boolean;
    includeMetadata?: boolean;
    includeSnapshots?: boolean;
    prefix?: string;
}

// @public
export interface ServiceListSharesSegmentHeaders {
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ServiceListSharesSegmentResponse = WithResponse<ListSharesResponse & ServiceListSharesSegmentHeaders, ServiceListSharesSegmentHeaders, ListSharesResponseModel>;

// @public
export interface ServiceSetPropertiesHeaders {
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceSetPropertiesResponse = WithResponse<ServiceSetPropertiesHeaders, ServiceSetPropertiesHeaders>;

// @public
export interface ServiceUndeleteShareOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export interface SetPropertiesResponse extends FileSetHTTPHeadersResponse {
}

// @public
export type ShareAccessTier = "TransactionOptimized" | "Hot" | "Cool";

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class ShareClient extends StorageClient {
    constructor(connectionString: string, name: string, options?: ShareClientOptions);
    constructor(url: string, credential?: Credential_2 | TokenCredential, options?: ShareClientOptions);
    constructor(url: string, pipeline: Pipeline, options?: ShareClientConfig);
    create(options?: ShareCreateOptions): Promise<ShareCreateResponse>;
    createDirectory(directoryName: string, options?: DirectoryCreateOptions): Promise<{
        directoryClient: ShareDirectoryClient;
        directoryCreateResponse: DirectoryCreateResponse;
    }>;
    createFile(fileName: string, size: number, options?: FileCreateOptions): Promise<{
        fileClient: ShareFileClient;
        fileCreateResponse: FileCreateResponse;
    }>;
    createIfNotExists(options?: ShareCreateOptions): Promise<ShareCreateIfNotExistsResponse>;
    createPermission(filePermission: string, options?: ShareCreatePermissionOptions): Promise<ShareCreatePermissionResponse>;
    createSnapshot(options?: ShareCreateSnapshotOptions): Promise<ShareCreateSnapshotResponse>;
    delete(options?: ShareDeleteMethodOptions): Promise<ShareDeleteResponse>;
    deleteDirectory(directoryName: string, options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    deleteFile(fileName: string, options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    deleteIfExists(options?: ShareDeleteMethodOptions): Promise<ShareDeleteIfExistsResponse>;
    exists(options?: ShareExistsOptions): Promise<boolean>;
    generateSasUrl(options: ShareGenerateSasUrlOptions): string;
    getAccessPolicy(options?: ShareGetAccessPolicyOptions): Promise<ShareGetAccessPolicyResponse>;
    getDirectoryClient(directoryName: string): ShareDirectoryClient;
    getPermission(filePermissionKey: string, options?: ShareGetPermissionOptions): Promise<ShareGetPermissionResponse>;
    getProperties(options?: ShareGetPropertiesOptions): Promise<ShareGetPropertiesResponse>;
    getStatistics(options?: ShareGetStatisticsOptions): Promise<ShareGetStatisticsResponse>;
    get name(): string;
    get rootDirectoryClient(): ShareDirectoryClient;
    setAccessPolicy(shareAcl?: SignedIdentifier[], options?: ShareSetAccessPolicyOptions): Promise<ShareSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: ShareSetMetadataOptions): Promise<ShareSetMetadataResponse>;
    setProperties(options?: ShareSetPropertiesOptions): Promise<ShareSetPropertiesResponse>;
    // @deprecated
    setQuota(quotaInGB: number, options?: ShareSetQuotaOptions): Promise<ShareSetQuotaResponse>;
    withSnapshot(snapshot: string): ShareClient;
}

// @public (undocumented)
export interface ShareClientConfig {
    allowSourceTrailingDot?: boolean;
    allowTrailingDot?: boolean;
    fileRequestIntent?: ShareTokenIntent;
}

// @public (undocumented)
export type ShareClientOptions = StoragePipelineOptions & ShareClientConfig;

// @public
export interface ShareCreateHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareCreateIfNotExistsResponse extends ShareCreateResponse {
    succeeded: boolean;
}

// @public
export interface ShareCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    accessTier?: ShareAccessTier;
    metadata?: {
        [propertyName: string]: string;
    };
    protocols?: ShareProtocols;
    quota?: number;
    rootSquash?: ShareRootSquash;
}

// @public
export interface ShareCreatePermissionHeaders {
    date?: Date;
    errorCode?: string;
    filePermissionKey?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareCreatePermissionOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ShareCreatePermissionResponse = WithResponse<ShareCreatePermissionHeaders, ShareCreatePermissionHeaders>;

// @public
export type ShareCreateResponse = WithResponse<ShareCreateHeaders, ShareCreateHeaders>;

// @public
export interface ShareCreateSnapshotHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    snapshot?: string;
    version?: string;
}

// @public
export interface ShareCreateSnapshotOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: {
        [propertyName: string]: string;
    };
}

// @public
export type ShareCreateSnapshotResponse = WithResponse<ShareCreateSnapshotHeaders, ShareCreateSnapshotHeaders>;

// @public
export interface ShareDeleteHeaders {
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareDeleteIfExistsResponse extends ShareDeleteResponse {
    succeeded: boolean;
}

// @public
export interface ShareDeleteMethodOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    deleteSnapshots?: DeleteSnapshotsOptionType;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type ShareDeleteResponse = WithResponse<ShareDeleteHeaders, ShareDeleteHeaders>;

// @public
export class ShareDirectoryClient extends StorageClient {
    constructor(url: string, credential?: Credential_2 | TokenCredential, options?: ShareClientOptions);
    constructor(url: string, pipeline: Pipeline, options?: ShareClientConfig);
    create(options?: DirectoryCreateOptions): Promise<DirectoryCreateResponse>;
    createFile(fileName: string, size: number, options?: FileCreateOptions): Promise<{
        fileClient: ShareFileClient;
        fileCreateResponse: FileCreateResponse;
    }>;
    createIfNotExists(options?: DirectoryCreateOptions): Promise<DirectoryCreateIfNotExistsResponse>;
    createSubdirectory(directoryName: string, options?: DirectoryCreateOptions): Promise<{
        directoryClient: ShareDirectoryClient;
        directoryCreateResponse: DirectoryCreateResponse;
    }>;
    delete(options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    deleteFile(fileName: string, options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    deleteIfExists(options?: DirectoryDeleteOptions): Promise<DirectoryDeleteIfExistsResponse>;
    deleteSubdirectory(directoryName: string, options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    exists(options?: DirectoryExistsOptions): Promise<boolean>;
    forceCloseAllHandles(options?: DirectoryForceCloseHandlesSegmentOptions): Promise<CloseHandlesInfo>;
    forceCloseHandle(handleId: string, options?: DirectoryForceCloseHandlesOptions): Promise<DirectoryForceCloseHandlesResponse>;
    getDirectoryClient(subDirectoryName: string): ShareDirectoryClient;
    getFileClient(fileName: string): ShareFileClient;
    getProperties(options?: DirectoryGetPropertiesOptions): Promise<DirectoryGetPropertiesResponse>;
    listFilesAndDirectories(options?: DirectoryListFilesAndDirectoriesOptions): PagedAsyncIterableIterator<({
        kind: "file";
    } & FileItem) | ({
        kind: "directory";
    } & DirectoryItem), DirectoryListFilesAndDirectoriesSegmentResponse>;
    listHandles(options?: DirectoryListHandlesOptions): PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse>;
    get name(): string;
    get path(): string;
    rename(destinationPath: string, options?: DirectoryRenameOptions): Promise<{
        destinationDirectoryClient: ShareDirectoryClient;
        directoryRenameResponse: DirectoryRenameResponse;
    }>;
    setMetadata(metadata?: Metadata, options?: DirectorySetMetadataOptions): Promise<DirectorySetMetadataResponse>;
    setProperties(properties?: DirectoryProperties): Promise<DirectorySetPropertiesResponse>;
    get shareName(): string;
}

// @public
export interface ShareExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export class ShareFileClient extends StorageClient {
    constructor(url: string, credential?: Credential_2 | TokenCredential, options?: ShareClientOptions);
    constructor(url: string, pipeline: Pipeline, options?: ShareClientConfig);
    abortCopyFromURL(copyId: string, options?: FileAbortCopyFromURLOptions): Promise<FileAbortCopyResponse>;
    clearRange(offset: number, contentLength: number, options?: FileClearRangeOptions): Promise<FileUploadRangeResponse>;
    create(size: number, options?: FileCreateOptions): Promise<FileCreateResponse>;
    delete(options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    deleteIfExists(options?: FileDeleteOptions): Promise<FileDeleteIfExistsResponse>;
    download(offset?: number, count?: number, options?: FileDownloadOptions): Promise<FileDownloadResponseModel>;
    downloadToBuffer(buffer: Buffer, offset?: number, count?: number, options?: FileDownloadToBufferOptions): Promise<Buffer>;
    downloadToBuffer(offset?: number, count?: number, options?: FileDownloadToBufferOptions): Promise<Buffer>;
    downloadToFile(filePath: string, offset?: number, count?: number, options?: FileDownloadOptions): Promise<FileDownloadResponseModel>;
    exists(options?: FileExistsOptions): Promise<boolean>;
    forceCloseAllHandles(options?: FileForceCloseHandlesOptions): Promise<CloseHandlesInfo>;
    forceCloseHandle(handleId: string, options?: FileForceCloseHandlesOptions): Promise<FileForceCloseHandlesResponse>;
    generateSasUrl(options: FileGenerateSasUrlOptions): string;
    getProperties(options?: FileGetPropertiesOptions): Promise<FileGetPropertiesResponse>;
    getRangeList(options?: FileGetRangeListOptions): Promise<FileGetRangeListResponse>;
    getRangeListDiff(prevShareSnapshot: string, options?: FileGetRangeListOptions): Promise<FileGetRangeListDiffResponse>;
    getShareLeaseClient(proposeLeaseId?: string): ShareLeaseClient;
    listHandles(options?: FileListHandlesOptions): PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse>;
    get name(): string;
    get path(): string;
    rename(destinationPath: string, options?: FileRenameOptions): Promise<{
        destinationFileClient: ShareFileClient;
        fileRenameResponse: FileRenameResponse;
    }>;
    resize(length: number, options?: FileResizeOptions): Promise<FileSetHTTPHeadersResponse>;
    setHttpHeaders(fileHttpHeaders?: FileHttpHeaders, options?: FileSetHttpHeadersOptions): Promise<FileSetHTTPHeadersResponse>;
    setMetadata(metadata?: Metadata, options?: FileSetMetadataOptions): Promise<FileSetMetadataResponse>;
    setProperties(properties?: FileProperties): Promise<SetPropertiesResponse>;
    get shareName(): string;
    startCopyFromURL(copySource: string, options?: FileStartCopyOptions): Promise<FileStartCopyResponse>;
    uploadData(data: Buffer | Blob | ArrayBuffer | ArrayBufferView, options?: FileParallelUploadOptions): Promise<void>;
    uploadFile(filePath: string, options?: FileParallelUploadOptions): Promise<void>;
    uploadRange(body: HttpRequestBody, offset: number, contentLength: number, options?: FileUploadRangeOptions): Promise<FileUploadRangeResponse>;
    uploadRangeFromURL(sourceURL: string, sourceOffset: number, destOffset: number, count: number, options?: FileUploadRangeFromURLOptions): Promise<FileUploadRangeFromURLResponse>;
    uploadResetableStream(streamFactory: (offset: number, count?: number) => NodeJS.ReadableStream, size: number, options?: FileParallelUploadOptions): Promise<void>;
    uploadSeekableBlob(blobFactory: (offset: number, size: number) => Blob, size: number, options?: FileParallelUploadOptions): Promise<void>;
    uploadStream(stream: Readable, size: number, bufferSize: number, maxBuffers: number, options?: FileUploadStreamOptions): Promise<void>;
    withShareSnapshot(shareSnapshot: string): ShareFileClient;
}

// @public
export type ShareFileHandleAccessRights = "Read" | "Write" | "Delete";

// @public
export interface ShareFileRangeList {
    // (undocumented)
    clearRanges?: ClearRange[];
    // (undocumented)
    ranges?: RangeModel[];
}

// @public
export interface ShareGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: ShareSASPermissions;
}

// @public
export interface ShareGetAccessPolicyHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public (undocumented)
export type ShareGetAccessPolicyResponse = WithResponse<{
    signedIdentifiers: SignedIdentifier[];
} & ShareGetAccessPolicyHeaders, ShareGetAccessPolicyHeaders, SignedIdentifierModel[]>;

// @public
export interface ShareGetPermissionHeaders {
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareGetPermissionOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ShareGetPermissionResponse = WithResponse<ShareGetPermissionHeaders & SharePermission, ShareGetPermissionHeaders, SharePermission>;

// @public
export interface ShareGetPropertiesHeaders {
    accessTier?: string;
    accessTierChangeTime?: Date;
    accessTierTransitionState?: string;
    date?: Date;
    enabledProtocols?: string;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    metadata?: {
        [propertyName: string]: string;
    };
    nextAllowedQuotaDowngradeTime?: Date;
    provisionedBandwidthMibps?: number;
    provisionedEgressMBps?: number;
    provisionedIngressMBps?: number;
    provisionedIops?: number;
    quota?: number;
    requestId?: string;
    rootSquash?: ShareRootSquash;
    version?: string;
}

// @public
export interface ShareGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type ShareGetPropertiesResponse = ShareGetPropertiesResponseModel & {
    protocols?: ShareProtocols;
};

// @public
export type ShareGetPropertiesResponseModel = WithResponse<ShareGetPropertiesHeaders, ShareGetPropertiesHeaders>;

// @public
export interface ShareGetStatisticsHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type ShareGetStatisticsResponse = ShareGetStatisticsResponseModel & {
    shareUsage: number;
};

// @public
export type ShareGetStatisticsResponseModel = WithResponse<ShareGetStatisticsHeaders & ShareStats, ShareGetStatisticsHeaders, ShareStats>;

// @public
export interface ShareItem {
    // (undocumented)
    deleted?: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    properties: ShareProperties;
    // (undocumented)
    snapshot?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface ShareItemInternal {
    // (undocumented)
    deleted?: boolean;
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    properties: SharePropertiesInternal;
    // (undocumented)
    snapshot?: string;
    // (undocumented)
    version?: string;
}

// @public
export class ShareLeaseClient {
    constructor(client: ShareFileClient, leaseId?: string);
    acquireLease(duration?: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    breakLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    get leaseId(): string;
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    renewLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    get url(): string;
}

// @public
export interface SharePermission {
    permission: string;
}

// @public
export type ShareProperties = SharePropertiesInternal & {
    protocols?: ShareProtocols;
};

// @public
export interface SharePropertiesInternal {
    // (undocumented)
    accessTier?: string;
    // (undocumented)
    accessTierChangeTime?: Date;
    // (undocumented)
    accessTierTransitionState?: string;
    // (undocumented)
    deletedTime?: Date;
    // (undocumented)
    enabledProtocols?: string;
    // (undocumented)
    etag: string;
    // (undocumented)
    lastModified: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    nextAllowedQuotaDowngradeTime?: Date;
    // (undocumented)
    provisionedBandwidthMiBps?: number;
    // (undocumented)
    provisionedEgressMBps?: number;
    // (undocumented)
    provisionedIngressMBps?: number;
    // (undocumented)
    provisionedIops?: number;
    // (undocumented)
    quota: number;
    // (undocumented)
    remainingRetentionDays?: number;
    // (undocumented)
    rootSquash?: ShareRootSquash;
}

// @public
export interface ShareProtocols {
    nfsEnabled?: boolean;
    smbEnabled?: boolean;
}

// @public
export interface ShareProtocolSettings {
    smb?: ShareSmbSettings;
}

// @public
export type ShareRootSquash = "NoRootSquash" | "RootSquash" | "AllSquash";

// @public
export class ShareSASPermissions {
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): ShareSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export class ShareServiceClient extends StorageClient {
    constructor(url: string, credential?: Credential_2 | TokenCredential, options?: ShareClientOptions);
    constructor(url: string, pipeline: Pipeline, options?: ShareClientConfig);
    createShare(shareName: string, options?: ShareCreateOptions): Promise<{
        shareCreateResponse: ShareCreateResponse;
        shareClient: ShareClient;
    }>;
    deleteShare(shareName: string, options?: ShareDeleteMethodOptions): Promise<ShareDeleteResponse>;
    static fromConnectionString(connectionString: string, options?: ShareClientOptions): ShareServiceClient;
    generateAccountSasUrl(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getShareClient(shareName: string): ShareClient;
    listShares(options?: ServiceListSharesOptions): PagedAsyncIterableIterator<ShareItem, ServiceListSharesSegmentResponse>;
    setProperties(properties: FileServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
    undeleteShare(deletedShareName: string, deletedShareVersion: string, options?: ServiceUndeleteShareOptions): Promise<ShareClient>;
}

// @public
export interface ShareSetAccessPolicyHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type ShareSetAccessPolicyResponse = WithResponse<ShareSetAccessPolicyHeaders, ShareGetAccessPolicyHeaders>;

// @public
export interface ShareSetMetadataHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type ShareSetMetadataResponse = WithResponse<ShareSetMetadataHeaders, ShareSetMetadataHeaders>;

// @public
export interface ShareSetPropertiesHeaders {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ShareSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    accessTier?: ShareAccessTier;
    leaseAccessConditions?: LeaseAccessConditions;
    quotaInGB?: number;
    rootSquash?: ShareRootSquash;
}

// @public
export type ShareSetPropertiesResponse = WithResponse<ShareSetPropertiesHeaders, ShareSetPropertiesHeaders>;

// @public
export type ShareSetQuotaHeaders = ShareSetPropertiesHeaders;

// @public
export interface ShareSetQuotaOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    leaseAccessConditions?: LeaseAccessConditions;
}

// @public
export type ShareSetQuotaResponse = WithResponse<ShareSetQuotaHeaders, ShareSetQuotaHeaders>;

// @public
export interface ShareSmbSettings {
    multichannel?: SmbMultichannel;
}

// @public
export interface ShareStats {
    shareUsageBytes: number;
}

// @public
export type ShareTokenIntent = string;

// @public
export interface SignedIdentifier {
    accessPolicy: {
        startsOn: Date;
        expiresOn: Date;
        permissions: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    accessPolicy?: AccessPolicy;
    id: string;
}

// @public
export interface SmbMultichannel {
    enabled?: boolean;
}

// @public
export interface SourceModifiedAccessConditions {
    sourceIfMatchCrc64?: Uint8Array;
    sourceIfNoneMatchCrc64?: Uint8Array;
}

// @public
export class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}

// @public
export class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}

// @public
export enum StorageFileAudience {
    StorageOAuthScopes = "https://storage.azure.com/.default"
}

// @public
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    audience?: string;
    httpClient?: RequestPolicy;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxySettings;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentPolicyOptions;
}

// @public
export interface StorageRetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: StorageRetryPolicyType;
    readonly tryTimeoutInMs?: number;
}

// @public
export class StorageRetryPolicy extends BaseRequestPolicy {
    // Warning: (ae-forgotten-export) The symbol "StorageRetryOptions_2" needs to be exported by the entry point index.d.ts
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions_2);
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
}

// @public
export class StorageRetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: StorageRetryOptions);
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
}

// @public
export enum StorageRetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export class StorageSharedKeyCredential extends Credential_2 {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
}

// @public
export class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type TimeNowType = "now";

// @public
export type TimePreserveType = "preserve";

export { WebResource }

// @public
export type WithResponse<T, Headers = undefined, Body = undefined> = T & (Body extends object ? ResponseWithBody<Headers, Body> : Headers extends object ? ResponseWithHeaders<Headers> : ResponseLike);

// (No @packageDocumentation comment for this package)

```
