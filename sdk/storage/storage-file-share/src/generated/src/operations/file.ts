/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { StorageClientContext } from "../storageClientContext";
import {
  FileCreateOptionalParams,
  FileCreateResponse,
  FileDownloadOptionalParams,
  FileDownloadResponse,
  FileGetPropertiesOptionalParams,
  FileGetPropertiesResponse,
  FileDeleteOptionalParams,
  FileDeleteResponse,
  FileSetHttpHeadersOptionalParams,
  FileSetHttpHeadersResponse,
  FileSetMetadataOptionalParams,
  FileSetMetadataResponse,
  FileAcquireLeaseOptionalParams,
  FileAcquireLeaseResponse,
  FileReleaseLeaseOptionalParams,
  FileReleaseLeaseResponse,
  FileChangeLeaseOptionalParams,
  FileChangeLeaseResponse,
  FileBreakLeaseOptionalParams,
  FileBreakLeaseResponse,
  FileRangeWriteType,
  FileUploadRangeOptionalParams,
  FileUploadRangeResponse,
  FileUploadRangeFromURLOptionalParams,
  FileUploadRangeFromURLResponse,
  FileGetRangeListOptionalParams,
  FileGetRangeListResponse,
  FileStartCopyOptionalParams,
  FileStartCopyResponse,
  FileAbortCopyOptionalParams,
  FileAbortCopyResponse,
  FileListHandlesOptionalParams,
  FileListHandlesResponse,
  FileForceCloseHandlesOptionalParams,
  FileForceCloseHandlesResponse,
  FileRenameOptionalParams,
  FileRenameResponse
} from "../models";

/** Class representing a File. */
export class File {
  private readonly client: StorageClientContext;

  /**
   * Initialize a new instance of the class File class.
   * @param client Reference to the service client
   */
  constructor(client: StorageClientContext) {
    this.client = client;
  }

  /**
   * Creates a new file or replaces a file. Note it only initializes the file with no content.
   * @param fileContentLength Specifies the maximum size for the file, up to 4 TB.
   * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
   *                       ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
   * @param options The options parameters.
   */
  create(
    fileContentLength: number,
    fileAttributes: string,
    options?: FileCreateOptionalParams
  ): Promise<FileCreateResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      fileContentLength,
      fileAttributes,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      createOperationSpec
    ) as Promise<FileCreateResponse>;
  }

  /**
   * Reads or downloads a file from the system, including its metadata and properties.
   * @param options The options parameters.
   */
  download(
    options?: FileDownloadOptionalParams
  ): Promise<FileDownloadResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      downloadOperationSpec
    ) as Promise<FileDownloadResponse>;
  }

  /**
   * Returns all user-defined metadata, standard HTTP properties, and system properties for the file. It
   * does not return the content of the file.
   * @param options The options parameters.
   */
  getProperties(
    options?: FileGetPropertiesOptionalParams
  ): Promise<FileGetPropertiesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getPropertiesOperationSpec
    ) as Promise<FileGetPropertiesResponse>;
  }

  /**
   * removes the file from the storage account.
   * @param options The options parameters.
   */
  delete(options?: FileDeleteOptionalParams): Promise<FileDeleteResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      deleteOperationSpec
    ) as Promise<FileDeleteResponse>;
  }

  /**
   * Sets HTTP headers on the file.
   * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
   *                       ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
   * @param options The options parameters.
   */
  setHttpHeaders(
    fileAttributes: string,
    options?: FileSetHttpHeadersOptionalParams
  ): Promise<FileSetHttpHeadersResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      fileAttributes,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      setHttpHeadersOperationSpec
    ) as Promise<FileSetHttpHeadersResponse>;
  }

  /**
   * Updates user-defined metadata for the specified file.
   * @param options The options parameters.
   */
  setMetadata(
    options?: FileSetMetadataOptionalParams
  ): Promise<FileSetMetadataResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      setMetadataOperationSpec
    ) as Promise<FileSetMetadataResponse>;
  }

  /**
   * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
   * operations
   * @param options The options parameters.
   */
  acquireLease(
    options?: FileAcquireLeaseOptionalParams
  ): Promise<FileAcquireLeaseResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      acquireLeaseOperationSpec
    ) as Promise<FileAcquireLeaseResponse>;
  }

  /**
   * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  releaseLease(
    leaseId: string,
    options?: FileReleaseLeaseOptionalParams
  ): Promise<FileReleaseLeaseResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      leaseId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      releaseLeaseOperationSpec
    ) as Promise<FileReleaseLeaseResponse>;
  }

  /**
   * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param options The options parameters.
   */
  changeLease(
    leaseId: string,
    options?: FileChangeLeaseOptionalParams
  ): Promise<FileChangeLeaseResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      leaseId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      changeLeaseOperationSpec
    ) as Promise<FileChangeLeaseResponse>;
  }

  /**
   * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
   * operations
   * @param options The options parameters.
   */
  breakLease(
    options?: FileBreakLeaseOptionalParams
  ): Promise<FileBreakLeaseResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      breakLeaseOperationSpec
    ) as Promise<FileBreakLeaseResponse>;
  }

  /**
   * Upload a range of bytes to a file.
   * @param range Specifies the range of bytes to be written. Both the start and end of the range must be
   *              specified. For an update operation, the range can be up to 4 MB in size. For a clear operation, the
   *              range can be up to the value of the file's full size. The File service accepts only a single byte
   *              range for the Range and 'x-ms-range' headers, and the byte range must be specified in the following
   *              format: bytes=startByte-endByte.
   * @param fileRangeWrite Specify one of the following options: - Update: Writes the bytes specified by
   *                       the request body into the specified range. The Range and Content-Length headers must match to
   *                       perform the update. - Clear: Clears the specified range and releases the space used in storage for
   *                       that range. To clear a range, set the Content-Length header to zero, and set the Range header to a
   *                       value that indicates the range to clear, up to maximum file size.
   * @param contentLength Specifies the number of bytes being transmitted in the request body. When the
   *                      x-ms-write header is set to clear, the value of this header must be set to zero.
   * @param options The options parameters.
   */
  uploadRange(
    range: string,
    fileRangeWrite: FileRangeWriteType,
    contentLength: number,
    options?: FileUploadRangeOptionalParams
  ): Promise<FileUploadRangeResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      range,
      fileRangeWrite,
      contentLength,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      uploadRangeOperationSpec
    ) as Promise<FileUploadRangeResponse>;
  }

  /**
   * Upload a range of bytes to a file where the contents are read from a URL.
   * @param range Writes data to the specified byte range in the file.
   * @param copySource Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file
   *                   to another file within the same storage account, you may use Shared Key to authenticate the source
   *                   file. If you are copying a file from another storage account, or if you are copying a blob from the
   *                   same storage account or another storage account, then you must authenticate the source file or blob
   *                   using a shared access signature. If the source is a public blob, no authentication is required to
   *                   perform the copy operation. A file in a share snapshot can also be specified as a copy source.
   * @param contentLength Specifies the number of bytes being transmitted in the request body. When the
   *                      x-ms-write header is set to clear, the value of this header must be set to zero.
   * @param options The options parameters.
   */
  uploadRangeFromURL(
    range: string,
    copySource: string,
    contentLength: number,
    options?: FileUploadRangeFromURLOptionalParams
  ): Promise<FileUploadRangeFromURLResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      range,
      copySource,
      contentLength,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      uploadRangeFromURLOperationSpec
    ) as Promise<FileUploadRangeFromURLResponse>;
  }

  /**
   * Returns the list of valid ranges for a file.
   * @param options The options parameters.
   */
  getRangeList(
    options?: FileGetRangeListOptionalParams
  ): Promise<FileGetRangeListResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getRangeListOperationSpec
    ) as Promise<FileGetRangeListResponse>;
  }

  /**
   * Copies a blob or file to a destination file within the storage account.
   * @param copySource Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file
   *                   to another file within the same storage account, you may use Shared Key to authenticate the source
   *                   file. If you are copying a file from another storage account, or if you are copying a blob from the
   *                   same storage account or another storage account, then you must authenticate the source file or blob
   *                   using a shared access signature. If the source is a public blob, no authentication is required to
   *                   perform the copy operation. A file in a share snapshot can also be specified as a copy source.
   * @param options The options parameters.
   */
  startCopy(
    copySource: string,
    options?: FileStartCopyOptionalParams
  ): Promise<FileStartCopyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      copySource,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      startCopyOperationSpec
    ) as Promise<FileStartCopyResponse>;
  }

  /**
   * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
   * metadata.
   * @param copyId The copy identifier provided in the x-ms-copy-id header of the original Copy File
   *               operation.
   * @param options The options parameters.
   */
  abortCopy(
    copyId: string,
    options?: FileAbortCopyOptionalParams
  ): Promise<FileAbortCopyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      copyId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      abortCopyOperationSpec
    ) as Promise<FileAbortCopyResponse>;
  }

  /**
   * Lists handles for file
   * @param options The options parameters.
   */
  listHandles(
    options?: FileListHandlesOptionalParams
  ): Promise<FileListHandlesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      listHandlesOperationSpec
    ) as Promise<FileListHandlesResponse>;
  }

  /**
   * Closes all handles open for given file
   * @param handleId Specifies handle ID opened on the file or directory to be closed. Asterisk (‘*’) is
   *                 a wildcard that specifies all handles.
   * @param options The options parameters.
   */
  forceCloseHandles(
    handleId: string,
    options?: FileForceCloseHandlesOptionalParams
  ): Promise<FileForceCloseHandlesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      handleId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      forceCloseHandlesOperationSpec
    ) as Promise<FileForceCloseHandlesResponse>;
  }

  /**
   * Renames a file
   * @param renameSource Required. Specifies the URI-style path of the source file, up to 2 KB in length.
   * @param options The options parameters.
   */
  rename(
    renameSource: string,
    options?: FileRenameOptionalParams
  ): Promise<FileRenameResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      renameSource,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      renameOperationSpec
    ) as Promise<FileRenameResponse>;
  }
}
// Operation Specifications
const xmlSerializer = new coreHttp.Serializer(Mappers, /* isXml */ true);

const createOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: Mappers.FileCreateHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileCreateExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.metadata,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.filePermission,
    Parameters.filePermissionKey1,
    Parameters.fileAttributes,
    Parameters.fileCreatedOn,
    Parameters.fileLastWriteOn,
    Parameters.fileChangeOn,
    Parameters.fileContentLength,
    Parameters.fileTypeConstant,
    Parameters.fileContentType,
    Parameters.fileContentEncoding,
    Parameters.fileContentLanguage,
    Parameters.fileCacheControl,
    Parameters.fileContentMD5,
    Parameters.fileContentDisposition
  ],
  isXML: true,
  serializer: xmlSerializer
};
const downloadOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: Mappers.FileDownloadHeaders
    },
    206: {
      bodyMapper: {
        type: { name: "Stream" },
        serializedName: "parsedResponse"
      },
      headersMapper: Mappers.FileDownloadHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileDownloadExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.range,
    Parameters.rangeGetContentMD5
  ],
  isXML: true,
  serializer: xmlSerializer
};
const getPropertiesOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "HEAD",
  responses: {
    200: {
      headersMapper: Mappers.FileGetPropertiesHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileGetPropertiesExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds, Parameters.shareSnapshot],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot
  ],
  isXML: true,
  serializer: xmlSerializer
};
const deleteOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "DELETE",
  responses: {
    202: {
      headersMapper: Mappers.FileDeleteHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileDeleteExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot
  ],
  isXML: true,
  serializer: xmlSerializer
};
const setHttpHeadersOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: Mappers.FileSetHttpHeadersHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileSetHttpHeadersExceptionHeaders
    }
  },
  queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.filePermission,
    Parameters.filePermissionKey1,
    Parameters.fileAttributes,
    Parameters.fileCreatedOn,
    Parameters.fileLastWriteOn,
    Parameters.fileChangeOn,
    Parameters.fileContentType,
    Parameters.fileContentEncoding,
    Parameters.fileContentLanguage,
    Parameters.fileCacheControl,
    Parameters.fileContentMD5,
    Parameters.fileContentDisposition,
    Parameters.fileContentLength1
  ],
  isXML: true,
  serializer: xmlSerializer
};
const setMetadataOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: Mappers.FileSetMetadataHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileSetMetadataExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds, Parameters.comp5],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.metadata,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot
  ],
  isXML: true,
  serializer: xmlSerializer
};
const acquireLeaseOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: Mappers.FileAcquireLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileAcquireLeaseExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds, Parameters.comp2],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.action,
    Parameters.duration,
    Parameters.proposedLeaseId,
    Parameters.requestId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot
  ],
  isXML: true,
  serializer: xmlSerializer
};
const releaseLeaseOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: Mappers.FileReleaseLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileReleaseLeaseExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds, Parameters.comp2],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.requestId,
    Parameters.action1,
    Parameters.leaseId1,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot
  ],
  isXML: true,
  serializer: xmlSerializer
};
const changeLeaseOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: Mappers.FileChangeLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileChangeLeaseExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds, Parameters.comp2],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.proposedLeaseId,
    Parameters.requestId,
    Parameters.leaseId1,
    Parameters.action2,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot
  ],
  isXML: true,
  serializer: xmlSerializer
};
const breakLeaseOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: Mappers.FileBreakLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileBreakLeaseExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds, Parameters.comp2],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.leaseId,
    Parameters.requestId,
    Parameters.action4,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot
  ],
  isXML: true,
  serializer: xmlSerializer
};
const uploadRangeOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: Mappers.FileUploadRangeHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileUploadRangeExceptionHeaders
    }
  },
  requestBody: Parameters.body,
  queryParameters: [Parameters.timeoutInSeconds, Parameters.comp12],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.contentType1,
    Parameters.accept3,
    Parameters.range1,
    Parameters.fileRangeWrite,
    Parameters.contentLength,
    Parameters.contentMD5,
    Parameters.fileLastWrittenMode
  ],
  contentType: "application/octet-stream",
  isXML: true,
  serializer: xmlSerializer
};
const uploadRangeFromURLOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    201: {
      headersMapper: Mappers.FileUploadRangeFromURLHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileUploadRangeFromURLExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds, Parameters.comp12],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.leaseId,
    Parameters.allowTrailingDot,
    Parameters.allowSourceTrailingDot,
    Parameters.range1,
    Parameters.contentLength,
    Parameters.fileLastWrittenMode,
    Parameters.copySource,
    Parameters.sourceRange,
    Parameters.fileRangeWriteFromUrl,
    Parameters.sourceContentCrc64,
    Parameters.sourceIfMatchCrc64,
    Parameters.sourceIfNoneMatchCrc64,
    Parameters.copySourceAuthorization
  ],
  isXML: true,
  serializer: xmlSerializer
};
const getRangeListOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ShareFileRangeList,
      headersMapper: Mappers.FileGetRangeListHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileGetRangeListExceptionHeaders
    }
  },
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.shareSnapshot,
    Parameters.comp13,
    Parameters.prevsharesnapshot
  ],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.range
  ],
  isXML: true,
  serializer: xmlSerializer
};
const startCopyOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    202: {
      headersMapper: Mappers.FileStartCopyHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileStartCopyExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.metadata,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.filePermission,
    Parameters.filePermissionKey1,
    Parameters.fileAttributes1,
    Parameters.fileCreationTime,
    Parameters.fileLastWriteTime,
    Parameters.fileChangeTime,
    Parameters.allowSourceTrailingDot,
    Parameters.copySource,
    Parameters.filePermissionCopyMode,
    Parameters.ignoreReadOnly1,
    Parameters.setArchiveAttribute
  ],
  isXML: true,
  serializer: xmlSerializer
};
const abortCopyOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    204: {
      headersMapper: Mappers.FileAbortCopyHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileAbortCopyExceptionHeaders
    }
  },
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp14,
    Parameters.copyId
  ],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.leaseId,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.copyActionAbortConstant
  ],
  isXML: true,
  serializer: xmlSerializer
};
const listHandlesOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ListHandlesResponse,
      headersMapper: Mappers.FileListHandlesHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileListHandlesExceptionHeaders
    }
  },
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.marker,
    Parameters.maxResults,
    Parameters.shareSnapshot,
    Parameters.comp9
  ],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot
  ],
  isXML: true,
  serializer: xmlSerializer
};
const forceCloseHandlesOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: Mappers.FileForceCloseHandlesHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileForceCloseHandlesExceptionHeaders
    }
  },
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.marker,
    Parameters.shareSnapshot,
    Parameters.comp10
  ],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.handleId
  ],
  isXML: true,
  serializer: xmlSerializer
};
const renameOperationSpec: coreHttp.OperationSpec = {
  path: "/{shareName}/{directory}/{fileName}",
  httpMethod: "PUT",
  responses: {
    200: {
      headersMapper: Mappers.FileRenameHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.FileRenameExceptionHeaders
    }
  },
  queryParameters: [Parameters.timeoutInSeconds, Parameters.comp11],
  urlParameters: [Parameters.url],
  headerParameters: [
    Parameters.version,
    Parameters.accept1,
    Parameters.metadata,
    Parameters.fileRequestIntent,
    Parameters.allowTrailingDot,
    Parameters.filePermission,
    Parameters.filePermissionKey1,
    Parameters.renameSource,
    Parameters.replaceIfExists,
    Parameters.ignoreReadOnly,
    Parameters.sourceLeaseId,
    Parameters.destinationLeaseId,
    Parameters.fileAttributes1,
    Parameters.fileCreationTime,
    Parameters.fileLastWriteTime,
    Parameters.fileChangeTime,
    Parameters.allowSourceTrailingDot,
    Parameters.fileContentType
  ],
  isXML: true,
  serializer: xmlSerializer
};
