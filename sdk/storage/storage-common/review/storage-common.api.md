## API Report File for "@azure/storage-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { ExtendedServiceClientOptions } from '@azure/core-http-compat';
import { HttpHeadersLike as HttpHeaders } from '@azure/core-http-compat';
import { CompatResponse as HttpOperationResponse } from '@azure/core-http-compat';
import { HttpPipelineLogLevel } from '@azure/core-http-compat';
import { RequestBodyType as HttpRequestBody } from '@azure/core-rest-pipeline';
import { KeepAliveOptions } from '@azure/core-http-compat';
import { OperationTracingOptions } from '@azure/core-tracing';
import { ProxySettings } from '@azure/core-rest-pipeline';
import { Readable } from 'stream';
import { RequestPolicy } from '@azure/core-http-compat';
import { RequestPolicyFactory } from '@azure/core-http-compat';
import { RequestPolicyOptionsLike as RequestPolicyOptions } from '@azure/core-http-compat';
import { RestError } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';
import { UserAgentPolicyOptions } from '@azure/core-rest-pipeline';
import { WebResourceLike as WebResource } from '@azure/core-http-compat';

// @public
export class AnonymousCredential extends Credential_2 {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

// @public
export abstract class BaseRequestPolicy implements RequestPolicy {
    protected constructor(
    _nextPolicy: RequestPolicy,
    _options: RequestPolicyOptions);
    log(logLevel: HttpPipelineLogLevel, message: string): void;
    readonly _nextPolicy: RequestPolicy;
    readonly _options: RequestPolicyOptions;
    abstract sendRequest(webResource: WebResource): Promise<HttpOperationResponse>;
    shouldLog(logLevel: HttpPipelineLogLevel): boolean;
}

// @public
export class BufferScheduler {
    constructor(readable: Readable, bufferSize: number, maxBuffers: number, outgoingHandler: OutgoingHandler, concurrency: number, encoding?: BufferEncoding);
    do(): Promise<void>;
}

// @public
export interface CommonOptions {
    tracingOptions?: OperationTracingOptions;
}

// @public (undocumented)
export function convertV2Pipeline(pipeline: PipelineLike): void;

// @public
abstract class Credential_2 implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}
export { Credential_2 as Credential }

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public (undocumented)
export function getCoreClientOptions(pipeline: PipelineLike): ExtendedServiceClientOptions;

// @public (undocumented)
export function getCredentialFromPipeline(pipeline: PipelineLike): StorageSharedKeyCredential | AnonymousCredential | TokenCredential;

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

// @public
export function isPipelineLike(pipeline: unknown): pipeline is PipelineLike;

// @public
export function newPipeline(credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export type OutgoingHandler = (body: () => NodeJS.ReadableStream, length: number, offset?: number) => Promise<any>;

// @public
export class Pipeline implements PipelineLike {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineLike {
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: RequestPolicy;
}

export { RequestPolicy as IHttpClient }
export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

// @public
export interface ServiceClientOptions {
    httpClient?: RequestPolicy;
    requestPolicyFactories?: RequestPolicyFactory[] | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);
}

// @public
export class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}

// @public
export class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}

// @public
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    audience?: string | string[];
    httpClient?: RequestPolicy;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxySettings;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentPolicyOptions;
}

// @public
export interface StorageRetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: StorageRetryPolicyType;
    readonly secondaryHost?: string;
    readonly tryTimeoutInMs?: number;
}

// @public
export class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions);
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
}

// @public
export class StorageRetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: StorageRetryOptions);
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
}

// @public
export enum StorageRetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export class StorageSharedKeyCredential extends Credential_2 {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
}

// @public
export class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

export { WebResource }

// Warning: (ae-forgotten-export) The symbol "ResponseWithBody" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ResponseWithHeaders" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ResponseLike" needs to be exported by the entry point index.d.ts
//
// @public
export type WithResponse<T, Headers = undefined, Body = undefined> = T & (Body extends object ? ResponseWithBody<Headers, Body> : Headers extends object ? ResponseWithHeaders<Headers> : ResponseLike);

// (No @packageDocumentation comment for this package)

```
