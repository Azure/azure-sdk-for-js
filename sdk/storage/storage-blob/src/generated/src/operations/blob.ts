/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import { createSerializer, OperationOptions, OperationSpec } from "@azure/core-client";
import * as Models from "../models";
import * as Mappers from "../models/blobMappers";
import * as Parameters from "../models/parameters";
import { StorageClientContext } from "../storageClientContext";

/** Class representing a Blob. */
export class Blob {
  private readonly client: StorageClientContext;

  /**
   * Create a Blob.
   * @param {StorageClientContext} client Reference to the service client.
   */
  constructor(client: StorageClientContext) {
    this.client = client;
  }

  /**
   * The Download operation reads or downloads a blob from the system, including its metadata and
   * properties. You can also call Download to read a snapshot.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobDownloadResponse>
   */
  download(options?: Models.BlobDownloadOptionalParams): Promise<Models.BlobDownloadResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      downloadOperationSpec) as Promise<Models.BlobDownloadResponse>;
  }

  /**
   * The Get Properties operation returns all user-defined metadata, standard HTTP properties, and
   * system properties for the blob. It does not return the content of the blob.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobGetPropertiesResponse>
   */
  getProperties(options?: Models.BlobGetPropertiesOptionalParams): Promise<Models.BlobGetPropertiesResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      getPropertiesOperationSpec) as Promise<Models.BlobGetPropertiesResponse>;
  }

  /**
   * If the storage account's soft delete feature is disabled then, when a blob is deleted, it is
   * permanently removed from the storage account. If the storage account's soft delete feature is
   * enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible
   * immediately. However, the blob service retains the blob or snapshot for the number of days
   * specified by the DeleteRetentionPolicy section of [Storage service properties]
   * (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data
   * is permanently removed from the storage account. Note that you continue to be charged for the
   * soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify
   * the "include=deleted" query parameter to discover which blobs and snapshots have been soft
   * deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other
   * operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code
   * of 404 (ResourceNotFound).
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobDeleteResponse>
   */
  deleteMethod(options?: Models.BlobDeleteMethodOptionalParams): Promise<Models.BlobDeleteResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      deleteMethodOperationSpec) as Promise<Models.BlobDeleteResponse>;
  }

  /**
   * Set the owner, group, permissions, or access control list for a blob.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobSetAccessControlResponse>
   */
  setAccessControl(options?: Models.BlobSetAccessControlOptionalParams): Promise<Models.BlobSetAccessControlResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      setAccessControlOperationSpec) as Promise<Models.BlobSetAccessControlResponse>;
  }

  /**
   * Get the owner, group, permissions, or access control list for a blob.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobGetAccessControlResponse>
   */
  getAccessControl(options?: Models.BlobGetAccessControlOptionalParams): Promise<Models.BlobGetAccessControlResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      getAccessControlOperationSpec) as Promise<Models.BlobGetAccessControlResponse>;
  }

  /**
   * Rename a blob/file.  By default, the destination is overwritten and if the destination already
   * exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.
   * For more information, see [Specifying Conditional Headers for Blob Service
   * Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
   * To fail if the destination already exists, use a conditional request with If-None-Match: "*".
   * @param renameSource The file or directory to be renamed. The value must have the following
   * format: "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties will
   * overwrite the existing properties; otherwise, the existing properties will be preserved.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobRenameResponse>
   */
  rename(renameSource: string, options?: Models.BlobRenameOptionalParams): Promise<Models.BlobRenameResponse> {
    return this.client.sendOperationRequest(
      {
        renameSource,
        options
      },
      renameOperationSpec) as Promise<Models.BlobRenameResponse>;
  }

  /**
   * Undelete a blob that was previously soft deleted
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobUndeleteResponse>
   */
  undelete(options?: Models.BlobUndeleteOptionalParams): Promise<Models.BlobUndeleteResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      undeleteOperationSpec) as Promise<Models.BlobUndeleteResponse>;
  }

  /**
   * Sets the time a blob will expire and be deleted.
   * @param expiryOptions Required. Indicates mode of the expiry time. Possible values include:
   * 'NeverExpire', 'RelativeToCreation', 'RelativeToNow', 'Absolute'
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobSetExpiryResponse>
   */
  setExpiry(expiryOptions: Models.BlobExpiryOptions, options?: Models.BlobSetExpiryOptionalParams): Promise<Models.BlobSetExpiryResponse> {
    return this.client.sendOperationRequest(
      {
        expiryOptions,
        options
      },
      setExpiryOperationSpec) as Promise<Models.BlobSetExpiryResponse>;
  }

  /**
   * The Set HTTP Headers operation sets system properties on the blob
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobSetHTTPHeadersResponse>
   */
  setHTTPHeaders(options?: Models.BlobSetHTTPHeadersOptionalParams): Promise<Models.BlobSetHTTPHeadersResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      setHTTPHeadersOperationSpec) as Promise<Models.BlobSetHTTPHeadersResponse>;
  }

  /**
   * The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more
   * name-value pairs
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobSetMetadataResponse>
   */
  setMetadata(options?: Models.BlobSetMetadataOptionalParams): Promise<Models.BlobSetMetadataResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      setMetadataOperationSpec) as Promise<Models.BlobSetMetadataResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobAcquireLeaseResponse>
   */
  acquireLease(options?: Models.BlobAcquireLeaseOptionalParams): Promise<Models.BlobAcquireLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      acquireLeaseOperationSpec) as Promise<Models.BlobAcquireLeaseResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobReleaseLeaseResponse>
   */
  releaseLease(leaseId: string, options?: Models.BlobReleaseLeaseOptionalParams): Promise<Models.BlobReleaseLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        leaseId,
        options
      },
      releaseLeaseOperationSpec) as Promise<Models.BlobReleaseLeaseResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobRenewLeaseResponse>
   */
  renewLease(leaseId: string, options?: Models.BlobRenewLeaseOptionalParams): Promise<Models.BlobRenewLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        leaseId,
        options
      },
      renewLeaseOperationSpec) as Promise<Models.BlobRenewLeaseResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param leaseId Specifies the current lease ID on the resource.
   * @param proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service returns 400
   * (Invalid request) if the proposed lease ID is not in the correct format. See Guid Constructor
   * (String) for a list of valid GUID string formats.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobChangeLeaseResponse>
   */
  changeLease(leaseId: string, proposedLeaseId: string, options?: Models.BlobChangeLeaseOptionalParams): Promise<Models.BlobChangeLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        leaseId,
        proposedLeaseId,
        options
      },
      changeLeaseOperationSpec) as Promise<Models.BlobChangeLeaseResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobBreakLeaseResponse>
   */
  breakLease(options?: Models.BlobBreakLeaseOptionalParams): Promise<Models.BlobBreakLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      breakLeaseOperationSpec) as Promise<Models.BlobBreakLeaseResponse>;
  }

  /**
   * The Create Snapshot operation creates a read-only snapshot of a blob
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobCreateSnapshotResponse>
   */
  createSnapshot(options?: Models.BlobCreateSnapshotOptionalParams): Promise<Models.BlobCreateSnapshotResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      createSnapshotOperationSpec) as Promise<Models.BlobCreateSnapshotResponse>;
  }

  /**
   * The Start Copy From URL operation copies a blob or an internet resource to a new blob.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up
   * to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it
   * would appear in a request URI. The source blob must either be public or must be authenticated
   * via a shared access signature.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobStartCopyFromURLResponse>
   */
  startCopyFromURL(copySource: string, options?: Models.BlobStartCopyFromURLOptionalParams): Promise<Models.BlobStartCopyFromURLResponse> {
    return this.client.sendOperationRequest(
      {
        copySource,
        options
      },
      startCopyFromURLOperationSpec) as Promise<Models.BlobStartCopyFromURLResponse>;
  }

  /**
   * The Copy From URL operation copies a blob or an internet resource to a new blob. It will not
   * return a response until the copy is complete.
   * @param copySource Specifies the name of the source page blob snapshot. This value is a URL of up
   * to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded as it
   * would appear in a request URI. The source blob must either be public or must be authenticated
   * via a shared access signature.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobCopyFromURLResponse>
   */
  copyFromURL(copySource: string, options?: Models.BlobCopyFromURLOptionalParams): Promise<Models.BlobCopyFromURLResponse> {
    return this.client.sendOperationRequest(
      {
        copySource,
        options
      },
      copyFromURLOperationSpec) as Promise<Models.BlobCopyFromURLResponse>;
  }

  /**
   * The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a
   * destination blob with zero length and full metadata.
   * @param copyId The copy identifier provided in the x-ms-copy-id header of the original Copy Blob
   * operation.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobAbortCopyFromURLResponse>
   */
  abortCopyFromURL(copyId: string, options?: Models.BlobAbortCopyFromURLOptionalParams): Promise<Models.BlobAbortCopyFromURLResponse> {
    return this.client.sendOperationRequest(
      {
        copyId,
        options
      },
      abortCopyFromURLOperationSpec) as Promise<Models.BlobAbortCopyFromURLResponse>;
  }

  /**
   * The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a
   * premium storage account and on a block blob in a blob storage account (locally redundant storage
   * only). A premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob.
   * A block blob's tier determines Hot/Cool/Archive storage type. This operation does not update the
   * blob's ETag.
   * @param tier Indicates the tier to be set on the blob. Possible values include: 'P4', 'P6',
   * 'P10', 'P15', 'P20', 'P30', 'P40', 'P50', 'P60', 'P70', 'P80', 'Hot', 'Cool', 'Archive'
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobSetTierResponse>
   */
  setTier(tier: Models.AccessTier, options?: Models.BlobSetTierOptionalParams): Promise<Models.BlobSetTierResponse> {
    return this.client.sendOperationRequest(
      {
        tier,
        options
      },
      setTierOperationSpec) as Promise<Models.BlobSetTierResponse>;
  }

  /**
   * Returns the sku name and account kind
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobGetAccountInfoResponse>
   */
  getAccountInfo(options?: OperationOptions): Promise<Models.BlobGetAccountInfoResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      getAccountInfoOperationSpec) as Promise<Models.BlobGetAccountInfoResponse>;
  }

  /**
   * The Query operation enables users to select/project on blob data by providing simple query
   * expressions.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobQueryResponse>
   */
  query(options?: Models.BlobQueryOptionalParams): Promise<Models.BlobQueryResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      queryOperationSpec) as Promise<Models.BlobQueryResponse>;
  }

  /**
   * The Get Tags operation enables users to get the tags associated with a blob.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobGetTagsResponse>
   */
  getTags(options?: Models.BlobGetTagsOptionalParams): Promise<Models.BlobGetTagsResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      getTagsOperationSpec) as Promise<Models.BlobGetTagsResponse>;
  }

  /**
   * The Set Tags operation enables users to set tags on a blob.
   * @param [options] The optional parameters
   * @returns Promise<Models.BlobSetTagsResponse>
   */
  setTags(options?: Models.BlobSetTagsOptionalParams): Promise<Models.BlobSetTagsResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      setTagsOperationSpec) as Promise<Models.BlobSetTagsResponse>;
  }
}

// Operation Specifications
const serializer = createSerializer(Mappers, true);
const downloadOperationSpec: OperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.snapshot,
    Parameters.versionId,
    Parameters.timeoutInSeconds
  ],
  headerParameters: [
    Parameters.range0,
    Parameters.rangeGetContentMD5,
    Parameters.rangeGetContentCRC64,
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.encryptionKey,
    Parameters.encryptionKeySha256,
    Parameters.encryptionAlgorithm,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: Mappers.BlobDownloadHeaders
    },
    206: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: Mappers.BlobDownloadHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobDownloadHeaders
    }
  },
  isXML: true,
  serializer
};

const getPropertiesOperationSpec: OperationSpec = {
  httpMethod: "HEAD",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.snapshot,
    Parameters.versionId,
    Parameters.timeoutInSeconds
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.encryptionKey,
    Parameters.encryptionKeySha256,
    Parameters.encryptionAlgorithm,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobGetPropertiesHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobGetPropertiesHeaders
    }
  },
  isXML: true,
  serializer
};

const deleteMethodOperationSpec: OperationSpec = {
  httpMethod: "DELETE",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.snapshot,
    Parameters.versionId,
    Parameters.timeoutInSeconds,
    Parameters.blobDeleteType
  ],
  headerParameters: [
    Parameters.deleteSnapshots,
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    202: {
      headersMapper: Mappers.BlobDeleteHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobDeleteHeaders
    }
  },
  isXML: true,
  serializer
};

const setAccessControlOperationSpec: OperationSpec = {
  httpMethod: "PATCH",
  path: "{filesystem}/{path}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.action5
  ],
  headerParameters: [
    Parameters.owner,
    Parameters.group,
    Parameters.posixPermissions,
    Parameters.posixAcl,
    Parameters.requestId,
    Parameters.version,
    Parameters.leaseId0,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobSetAccessControlHeaders
    },
    default: {
      bodyMapper: Mappers.DataLakeStorageError,
      headersMapper: Mappers.BlobSetAccessControlHeaders
    }
  },
  isXML: true,
  serializer
};

const getAccessControlOperationSpec: OperationSpec = {
  httpMethod: "HEAD",
  path: "{filesystem}/{path}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.upn,
    Parameters.action6
  ],
  headerParameters: [
    Parameters.requestId,
    Parameters.version,
    Parameters.leaseId0,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobGetAccessControlHeaders
    },
    default: {
      bodyMapper: Mappers.DataLakeStorageError,
      headersMapper: Mappers.BlobGetAccessControlHeaders
    }
  },
  isXML: true,
  serializer
};

const renameOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{filesystem}/{path}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.pathRenameMode
  ],
  headerParameters: [
    Parameters.renameSource,
    Parameters.directoryProperties,
    Parameters.posixPermissions,
    Parameters.posixUmask,
    Parameters.sourceLeaseId,
    Parameters.version,
    Parameters.requestId,
    Parameters.cacheControl,
    Parameters.contentType,
    Parameters.contentEncoding,
    Parameters.contentLanguage,
    Parameters.contentDisposition,
    Parameters.leaseId0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.sourceIfModifiedSince,
    Parameters.sourceIfUnmodifiedSince,
    Parameters.sourceIfMatch,
    Parameters.sourceIfNoneMatch
  ],
  responses: {
    201: {
      headersMapper: Mappers.BlobRenameHeaders
    },
    default: {
      bodyMapper: Mappers.DataLakeStorageError,
      headersMapper: Mappers.BlobRenameHeaders
    }
  },
  isXML: true,
  serializer
};

const undeleteOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp8
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobUndeleteHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobUndeleteHeaders
    }
  },
  isXML: true,
  serializer
};

const setExpiryOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp11
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.expiryOptions,
    Parameters.expiresOn
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobSetExpiryHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobSetExpiryHeaders
    }
  },
  isXML: true,
  serializer
};

const setHTTPHeadersOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp0
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.blobCacheControl,
    Parameters.blobContentType,
    Parameters.blobContentMD5,
    Parameters.blobContentEncoding,
    Parameters.blobContentLanguage,
    Parameters.blobContentDisposition,
    Parameters.leaseId0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobSetHTTPHeadersHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobSetHTTPHeadersHeaders
    }
  },
  isXML: true,
  serializer
};

const setMetadataOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp6
  ],
  headerParameters: [
    Parameters.metadata,
    Parameters.encryptionScope,
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.encryptionKey,
    Parameters.encryptionKeySha256,
    Parameters.encryptionAlgorithm,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobSetMetadataHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobSetMetadataHeaders
    }
  },
  isXML: true,
  serializer
};

const acquireLeaseOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp10
  ],
  headerParameters: [
    Parameters.duration,
    Parameters.proposedLeaseId0,
    Parameters.version,
    Parameters.requestId,
    Parameters.action0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    201: {
      headersMapper: Mappers.BlobAcquireLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobAcquireLeaseHeaders
    }
  },
  isXML: true,
  serializer
};

const releaseLeaseOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp10
  ],
  headerParameters: [
    Parameters.leaseId1,
    Parameters.version,
    Parameters.requestId,
    Parameters.action1,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobReleaseLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobReleaseLeaseHeaders
    }
  },
  isXML: true,
  serializer
};

const renewLeaseOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp10
  ],
  headerParameters: [
    Parameters.leaseId1,
    Parameters.version,
    Parameters.requestId,
    Parameters.action2,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobRenewLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobRenewLeaseHeaders
    }
  },
  isXML: true,
  serializer
};

const changeLeaseOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp10
  ],
  headerParameters: [
    Parameters.leaseId1,
    Parameters.proposedLeaseId1,
    Parameters.version,
    Parameters.requestId,
    Parameters.action4,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobChangeLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobChangeLeaseHeaders
    }
  },
  isXML: true,
  serializer
};

const breakLeaseOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp10
  ],
  headerParameters: [
    Parameters.breakPeriod,
    Parameters.version,
    Parameters.requestId,
    Parameters.action3,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  responses: {
    202: {
      headersMapper: Mappers.BlobBreakLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobBreakLeaseHeaders
    }
  },
  isXML: true,
  serializer
};

const createSnapshotOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.comp12
  ],
  headerParameters: [
    Parameters.metadata,
    Parameters.encryptionScope,
    Parameters.version,
    Parameters.requestId,
    Parameters.encryptionKey,
    Parameters.encryptionKeySha256,
    Parameters.encryptionAlgorithm,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags,
    Parameters.leaseId0
  ],
  responses: {
    201: {
      headersMapper: Mappers.BlobCreateSnapshotHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobCreateSnapshotHeaders
    }
  },
  isXML: true,
  serializer
};

const startCopyFromURLOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds
  ],
  headerParameters: [
    Parameters.metadata,
    Parameters.tier0,
    Parameters.rehydratePriority,
    Parameters.copySource,
    Parameters.version,
    Parameters.requestId,
    Parameters.blobTagsString,
    Parameters.sealBlob,
    Parameters.sourceIfModifiedSince,
    Parameters.sourceIfUnmodifiedSince,
    Parameters.sourceIfMatch,
    Parameters.sourceIfNoneMatch,
    Parameters.sourceIfTags,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags,
    Parameters.leaseId0
  ],
  responses: {
    202: {
      headersMapper: Mappers.BlobStartCopyFromURLHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobStartCopyFromURLHeaders
    }
  },
  isXML: true,
  serializer
};

const copyFromURLOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds
  ],
  headerParameters: [
    Parameters.metadata,
    Parameters.tier0,
    Parameters.copySource,
    Parameters.version,
    Parameters.requestId,
    Parameters.sourceContentMD5,
    Parameters.blobTagsString,
    Parameters.xMsRequiresSync,
    Parameters.sourceIfModifiedSince,
    Parameters.sourceIfUnmodifiedSince,
    Parameters.sourceIfMatch,
    Parameters.sourceIfNoneMatch,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags,
    Parameters.leaseId0
  ],
  responses: {
    202: {
      headersMapper: Mappers.BlobCopyFromURLHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobCopyFromURLHeaders
    }
  },
  isXML: true,
  serializer
};

const abortCopyFromURLOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.copyId,
    Parameters.timeoutInSeconds,
    Parameters.comp13
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.copyActionAbortConstant,
    Parameters.leaseId0
  ],
  responses: {
    204: {
      headersMapper: Mappers.BlobAbortCopyFromURLHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobAbortCopyFromURLHeaders
    }
  },
  isXML: true,
  serializer
};

const setTierOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.snapshot,
    Parameters.versionId,
    Parameters.timeoutInSeconds,
    Parameters.comp14
  ],
  headerParameters: [
    Parameters.tier1,
    Parameters.rehydratePriority,
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.ifTags
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobSetTierHeaders
    },
    202: {
      headersMapper: Mappers.BlobSetTierHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobSetTierHeaders
    }
  },
  isXML: true,
  serializer
};

const getAccountInfoOperationSpec: OperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.restype1,
    Parameters.comp0
  ],
  headerParameters: [
    Parameters.version
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobGetAccountInfoHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobGetAccountInfoHeaders
    }
  },
  isXML: true,
  serializer
};

const queryOperationSpec: OperationSpec = {
  httpMethod: "POST",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.snapshot,
    Parameters.timeoutInSeconds,
    Parameters.comp15
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.encryptionKey,
    Parameters.encryptionKeySha256,
    Parameters.encryptionAlgorithm,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.ifTags
  ],
  requestBody: {
    parameterPath: [
      "options",
      "queryRequest"
    ],
    mapper: Mappers.QueryRequest
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: Mappers.BlobQueryHeaders
    },
    206: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: Mappers.BlobQueryHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobQueryHeaders
    }
  },
  isXML: true,
  serializer
};

const getTagsOperationSpec: OperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.snapshot,
    Parameters.versionId,
    Parameters.comp16
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.ifTags,
    Parameters.leaseId0
  ],
  responses: {
    200: {
      bodyMapper: Mappers.BlobTags,
      headersMapper: Mappers.BlobGetTagsHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobGetTagsHeaders
    }
  },
  isXML: true,
  serializer
};

const setTagsOperationSpec: OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeoutInSeconds,
    Parameters.versionId,
    Parameters.comp16
  ],
  headerParameters: [
    Parameters.version,
    Parameters.transactionalContentMD5,
    Parameters.transactionalContentCrc64,
    Parameters.requestId,
    Parameters.ifTags,
    Parameters.leaseId0
  ],
  requestBody: {
    parameterPath: [
      "options",
      "tags"
    ],
    mapper: Mappers.BlobTags
  },
  contentType: "application/xml; charset=utf-8",
  responses: {
    204: {
      headersMapper: Mappers.BlobSetTagsHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError,
      headersMapper: Mappers.BlobSetTagsHeaders
    }
  },
  isXML: true,
  serializer
};
