## API Report File for "@azure/storage-blob"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { BaseRequestPolicy } from '@azure/core-http';
import * as coreHttp from '@azure/core-http';
import { deserializationPolicy } from '@azure/core-http';
import { HttpHeaders } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { HttpRequestBody } from '@azure/core-http';
import { HttpResponse } from '@azure/core-http';
import { HttpClient as IHttpClient } from '@azure/core-http';
import { KeepAliveOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { ProxyOptions } from '@azure/core-http';
import { Readable } from 'stream';
import { RequestPolicy } from '@azure/core-http';
import { RequestPolicyFactory } from '@azure/core-http';
import { RequestPolicyOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { SpanOptions } from '@opentelemetry/types';
import { TokenCredential } from '@azure/core-http';
import { TransferProgressEvent } from '@azure/core-http';
import { UserAgentOptions } from '@azure/core-http';
import { WebResource } from '@azure/core-http';

// @public
export interface AccessPolicy {
    expiresOn: string;
    permissions: string;
    startsOn: string;
}

// @public
export type AccessTier = 'P4' | 'P6' | 'P10' | 'P15' | 'P20' | 'P30' | 'P40' | 'P50' | 'P60' | 'P70' | 'P80' | 'Hot' | 'Cool' | 'Archive';

// @public
export type AccountKind = 'Storage' | 'BlobStorage' | 'StorageV2';

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

// @public
export interface AppendBlobAppendBlockFromUrlHeaders {
    blobAppendOffset?: string;
    blobCommittedBlockCount?: number;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface AppendBlobAppendBlockFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    sourceConditions?: ModifiedAccessConditions;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type AppendBlobAppendBlockFromUrlResponse = AppendBlobAppendBlockFromUrlHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: AppendBlobAppendBlockFromUrlHeaders;
    };
};

// @public
export interface AppendBlobAppendBlockHeaders {
    blobAppendOffset?: string;
    blobCommittedBlockCount?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface AppendBlobAppendBlockOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type AppendBlobAppendBlockResponse = AppendBlobAppendBlockHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: AppendBlobAppendBlockHeaders;
    };
};

// @public
export class AppendBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    appendBlock(body: HttpRequestBody, contentLength: number, options?: AppendBlobAppendBlockOptions): Promise<AppendBlobAppendBlockResponse>;
    appendBlockFromURL(sourceURL: string, sourceOffset: number, count: number, options?: AppendBlobAppendBlockFromURLOptions): Promise<AppendBlobAppendBlockFromUrlResponse>;
    create(options?: AppendBlobCreateOptions): Promise<AppendBlobCreateResponse>;
    withSnapshot(snapshot: string): AppendBlobClient;
}

// @public
export interface AppendBlobCreateHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface AppendBlobCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
}

// @public
export type AppendBlobCreateResponse = AppendBlobCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: AppendBlobCreateHeaders;
    };
};

// @public
export interface AppendBlobRequestConditions extends BlobRequestConditions, AppendPositionAccessConditions {
}

// @public
export interface AppendPositionAccessConditions {
    appendPosition?: number;
    maxSize?: number;
}

// @public
export type ArchiveStatus = 'rehydrate-pending-to-hot' | 'rehydrate-pending-to-cool';

export { BaseRequestPolicy }

// @public
export interface BatchSubRequest {
    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;
    url: string;
}

// @public
export interface BatchSubResponse {
    bodyAsText?: string;
    errorCode?: string;
    headers: HttpHeaders;
    _request: BatchSubRequest;
    status: number;
    statusMessage: string;
}

// @public
export interface BlobAbortCopyFromURLHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobAbortCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type BlobAbortCopyFromURLResponse = BlobAbortCopyFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobAbortCopyFromURLHeaders;
    };
};

// @public
export interface BlobAcquireLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class BlobBatch {
    constructor();
    deleteBlob(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: BlobDeleteOptions): Promise<void>;
    deleteBlob(blobClient: BlobClient, options?: BlobDeleteOptions): Promise<void>;
    getHttpRequestBody(): string;
    getMultiPartContentType(): string;
    getSubRequests(): Map<number, BatchSubRequest>;
    setBlobAccessTier(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, tier: AccessTier, options?: BlobSetTierOptions): Promise<void>;
    setBlobAccessTier(blobClient: BlobClient, tier: AccessTier, options?: BlobSetTierOptions): Promise<void>;
}

// @public
export class BlobBatchClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createBatch(): BlobBatch;
    deleteBlobs(urls: string[], credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: BlobDeleteOptions): Promise<BlobBatchDeleteBlobsResponse>;
    deleteBlobs(blobClients: BlobClient[], options?: BlobDeleteOptions): Promise<BlobBatchDeleteBlobsResponse>;
    setBlobsAccessTier(urls: string[], credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, tier: AccessTier, options?: BlobSetTierOptions): Promise<BlobBatchSetBlobsAccessTierResponse>;
    setBlobsAccessTier(blobClients: BlobClient[], tier: AccessTier, options?: BlobSetTierOptions): Promise<BlobBatchSetBlobsAccessTierResponse>;
    submitBatch(batchRequest: BlobBatch, options?: BlobBatchSubmitBatchOptionalParams): Promise<BlobBatchSubmitBatchResponse>;
}

// @public
export type BlobBatchDeleteBlobsResponse = BlobBatchSubmitBatchResponse;

// @public
export type BlobBatchSetBlobsAccessTierResponse = BlobBatchSubmitBatchResponse;

// @public
export interface BlobBatchSubmitBatchOptionalParams extends ServiceSubmitBatchOptionalParamsModel, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type BlobBatchSubmitBatchResponse = ParsedBatchResponse & ServiceSubmitBatchHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ServiceSubmitBatchHeaders;
    };
};

// @public
export interface BlobBeginCopyFromURLOptions extends BlobStartCopyFromURLOptions {
    intervalInMs?: number;
    onProgress?: (state: BlobBeginCopyFromUrlPollState) => void;
    resumeFrom?: string;
}

// @public
export interface BlobBeginCopyFromUrlPollState extends PollOperationState<BlobBeginCopyFromURLResponse> {
    readonly blobClient: CopyPollerBlobClient;
    copyId?: string;
    copyProgress?: string;
    copySource: string;
    readonly startCopyFromURLOptions?: BlobStartCopyFromURLOptions;
}

// @public
export interface BlobBeginCopyFromURLResponse extends BlobStartCopyFromURLResponse {
}

// @public
export interface BlobBreakLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobChangeLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class BlobClient extends StorageClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    abortCopyFromURL(copyId: string, options?: BlobAbortCopyFromURLOptions): Promise<BlobAbortCopyFromURLResponse>;
    beginCopyFromURL(copySource: string, options?: BlobBeginCopyFromURLOptions): Promise<PollerLike<PollOperationState<BlobBeginCopyFromURLResponse>, BlobBeginCopyFromURLResponse>>;
    readonly containerName: string;
    createSnapshot(options?: BlobCreateSnapshotOptions): Promise<BlobCreateSnapshotResponse>;
    delete(options?: BlobDeleteOptions): Promise<BlobDeleteResponse>;
    download(offset?: number, count?: number, options?: BlobDownloadOptions): Promise<BlobDownloadResponseModel>;
    downloadToBuffer(offset?: number, count?: number, options?: BlobDownloadToBufferOptions): Promise<Buffer>;
    downloadToBuffer(buffer: Buffer, offset?: number, count?: number, options?: BlobDownloadToBufferOptions): Promise<Buffer>;
    downloadToFile(filePath: string, offset?: number, count?: number, options?: BlobDownloadOptions): Promise<BlobDownloadResponseModel>;
    exists(options?: BlobExistsOptions): Promise<boolean>;
    getAppendBlobClient(): AppendBlobClient;
    getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient;
    getBlockBlobClient(): BlockBlobClient;
    getPageBlobClient(): PageBlobClient;
    getProperties(options?: BlobGetPropertiesOptions): Promise<BlobGetPropertiesResponse>;
    readonly name: string;
    setAccessTier(tier: BlockBlobTier | PremiumPageBlobTier | string, options?: BlobSetTierOptions): Promise<BlobSetTierResponse>;
    setHTTPHeaders(blobHTTPHeaders?: BlobHTTPHeaders, options?: BlobSetHTTPHeadersOptions): Promise<BlobSetHTTPHeadersResponse>;
    setMetadata(metadata?: Metadata, options?: BlobSetMetadataOptions): Promise<BlobSetMetadataResponse>;
    syncCopyFromURL(copySource: string, options?: BlobSyncCopyFromURLOptions): Promise<BlobCopyFromURLResponse>;
    undelete(options?: BlobUndeleteOptions): Promise<BlobUndeleteResponse>;
    withSnapshot(snapshot: string): BlobClient;
}

// @public
export interface BlobCopyFromURLHeaders {
    clientRequestId?: string;
    copyId?: string;
    copyStatus?: SyncCopyStatusType;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export type BlobCopyFromURLResponse = BlobCopyFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobCopyFromURLHeaders;
    };
};

// @public
export interface BlobCreateSnapshotHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    snapshot?: string;
    version?: string;
}

// @public
export interface BlobCreateSnapshotOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
}

// @public
export type BlobCreateSnapshotResponse = BlobCreateSnapshotHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobCreateSnapshotHeaders;
    };
};

// @public
export interface BlobDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    deleteSnapshots?: DeleteSnapshotsOptionType;
}

// @public
export type BlobDeleteResponse = BlobDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobDeleteHeaders;
    };
};

// @public
export interface BlobDownloadHeaders {
    acceptRanges?: string;
    blobCommittedBlockCount?: number;
    blobContentMD5?: Uint8Array;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentCrc64?: Uint8Array;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentRange?: string;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface BlobDownloadOptionalParams extends coreHttp.RequestOptionsBase {
    cpkInfo?: CpkInfo;
    leaseAccessConditions?: LeaseAccessConditions;
    modifiedAccessConditions?: ModifiedAccessConditions;
    range?: string;
    rangeGetContentCRC64?: boolean;
    rangeGetContentMD5?: boolean;
    requestId?: string;
    snapshot?: string;
    timeoutInSeconds?: number;
}

// @public
export interface BlobDownloadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    maxRetryRequests?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeGetContentCrc64?: boolean;
    rangeGetContentMD5?: boolean;
    snapshot?: string;
}

// @public
export type BlobDownloadResponseModel = BlobDownloadHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobDownloadHeaders;
    };
};

// @public
export interface BlobDownloadToBufferOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blockSize?: number;
    concurrency?: number;
    conditions?: BlobRequestConditions;
    maxRetryRequestsPerBlock?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export interface BlobExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    customerProvidedKey?: CpkInfo;
}

// @public
export interface BlobFlatListSegment {
    // (undocumented)
    blobItems: BlobItem[];
}

// @public
export interface BlobGetPropertiesHeaders {
    acceptRanges?: string;
    accessTier?: string;
    accessTierChangedOn?: Date;
    accessTierInferred?: boolean;
    archiveStatus?: string;
    blobCommittedBlockCount?: number;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    createdOn?: Date;
    date?: Date;
    destinationSnapshot?: string;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isIncrementalCopy?: boolean;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface BlobGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export type BlobGetPropertiesResponse = BlobGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobGetPropertiesHeaders;
    };
};

// @public
export interface BlobHierarchyListSegment {
    // (undocumented)
    blobItems: BlobItem[];
    // (undocumented)
    blobPrefixes?: BlobPrefix[];
}

// @public
export interface BlobHTTPHeaders {
    blobCacheControl?: string;
    blobContentDisposition?: string;
    blobContentEncoding?: string;
    blobContentLanguage?: string;
    blobContentMD5?: Uint8Array;
    blobContentType?: string;
}

// @public
export interface BlobItem {
    // (undocumented)
    deleted: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    properties: BlobProperties;
    // (undocumented)
    snapshot: string;
}

// @public
export class BlobLeaseClient {
    constructor(client: ContainerClient | BlobClient, leaseId?: string);
    acquireLease(duration: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    breakLease(breakPeriod: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    readonly leaseId: string;
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    renewLease(options?: LeaseOperationOptions): Promise<Lease>;
    readonly url: string;
    }

// @public
export interface BlobPrefix {
    // (undocumented)
    name: string;
}

// @public
export interface BlobProperties {
    accessTier?: AccessTier;
    // (undocumented)
    accessTierChangedOn?: Date;
    // (undocumented)
    accessTierInferred?: boolean;
    archiveStatus?: ArchiveStatus;
    // (undocumented)
    blobSequenceNumber?: number;
    blobType?: BlobType;
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    contentLength?: number;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    copyCompletedOn?: Date;
    // (undocumented)
    copyId?: string;
    // (undocumented)
    copyProgress?: string;
    // (undocumented)
    copySource?: string;
    copyStatus?: CopyStatusType;
    // (undocumented)
    copyStatusDescription?: string;
    // (undocumented)
    createdOn?: Date;
    // (undocumented)
    customerProvidedKeySha256?: string;
    // (undocumented)
    deletedOn?: Date;
    // (undocumented)
    destinationSnapshot?: string;
    // (undocumented)
    etag: string;
    // (undocumented)
    incrementalCopy?: boolean;
    // (undocumented)
    lastModified: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    remainingRetentionDays?: number;
    // (undocumented)
    serverEncrypted?: boolean;
}

// @public
export interface BlobReleaseLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobRenewLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobRequestConditions extends ModifiedAccessConditions, LeaseAccessConditions {
}

// @public
export class BlobSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    static parse(permissions: string): BlobSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface BlobSASSignatureValues {
    blobName?: string;
    cacheControl?: string;
    containerName: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: BlobSASPermissions;
    protocol?: SASProtocol;
    snapshotTime?: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class BlobServiceClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createContainer(containerName: string, options?: ContainerCreateOptions): Promise<{
        containerClient: ContainerClient;
        containerCreateResponse: ContainerCreateResponse;
    }>;
    deleteContainer(containerName: string, options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): BlobServiceClient;
    getAccountInfo(options?: ServiceGetAccountInfoOptions): Promise<ServiceGetAccountInfoResponse>;
    getBlobBatchClient(): BlobBatchClient;
    getContainerClient(containerName: string): ContainerClient;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getStatistics(options?: ServiceGetStatisticsOptions): Promise<ServiceGetStatisticsResponse>;
    getUserDelegationKey(startsOn: Date, expiresOn: Date, options?: ServiceGetUserDelegationKeyOptions): Promise<ServiceGetUserDelegationKeyResponse>;
    listContainers(options?: ServiceListContainersOptions): PagedAsyncIterableIterator<ContainerItem, ServiceListContainersSegmentResponse>;
    setProperties(properties: BlobServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
}

// @public
export interface BlobServiceProperties {
    // (undocumented)
    blobAnalyticsLogging?: Logging;
    cors?: CorsRule[];
    defaultServiceVersion?: string;
    // (undocumented)
    deleteRetentionPolicy?: RetentionPolicy;
    // (undocumented)
    hourMetrics?: Metrics;
    // (undocumented)
    minuteMetrics?: Metrics;
    // (undocumented)
    staticWebsite?: StaticWebsite;
}

// @public
export interface BlobServiceStatistics {
    // (undocumented)
    geoReplication?: GeoReplication;
}

// @public
export interface BlobSetHTTPHeadersHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetHTTPHeadersOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export type BlobSetHTTPHeadersResponse = BlobSetHTTPHeadersHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobSetHTTPHeadersHeaders;
    };
};

// @public
export interface BlobSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export type BlobSetMetadataResponse = BlobSetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobSetMetadataHeaders;
    };
};

// @public
export interface BlobSetTierHeaders {
    clientRequestId?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetTierOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    rehydratePriority?: RehydratePriority;
}

// @public
export type BlobSetTierResponse = BlobSetTierHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobSetTierHeaders;
    };
};

// @public
export interface BlobStartCopyFromURLHeaders {
    clientRequestId?: string;
    copyId?: string;
    copyStatus?: CopyStatusType;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobStartCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    metadata?: Metadata;
    rehydratePriority?: RehydratePriority;
    sourceConditions?: ModifiedAccessConditions;
    tier?: BlockBlobTier | PremiumPageBlobTier | string;
}

// @public
export type BlobStartCopyFromURLResponse = BlobStartCopyFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobStartCopyFromURLHeaders;
    };
};

// @public
export interface BlobSyncCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    metadata?: Metadata;
    sourceConditions?: ModifiedAccessConditions;
}

// @public
export type BlobType = 'BlockBlob' | 'PageBlob' | 'AppendBlob';

// @public
export interface BlobUndeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobUndeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    customerProvidedKey?: CpkInfo;
}

// @public
export type BlobUndeleteResponse = BlobUndeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobUndeleteHeaders;
    };
};

// @public
export type BlobUploadCommonResponse = BlockBlobUploadHeaders & {
    _response: HttpResponse;
};

// @public
export interface Block {
    name: string;
    size: number;
}

// @public
export class BlockBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    commitBlockList(blocks: string[], options?: BlockBlobCommitBlockListOptions): Promise<BlockBlobCommitBlockListResponse>;
    getBlockList(listType: BlockListType, options?: BlockBlobGetBlockListOptions): Promise<BlockBlobGetBlockListResponse>;
    stageBlock(blockId: string, body: HttpRequestBody, contentLength: number, options?: BlockBlobStageBlockOptions): Promise<BlockBlobStageBlockResponse>;
    stageBlockFromURL(blockId: string, sourceURL: string, offset?: number, count?: number, options?: BlockBlobStageBlockFromURLOptions): Promise<BlockBlobStageBlockFromURLResponse>;
    upload(body: HttpRequestBody, contentLength: number, options?: BlockBlobUploadOptions): Promise<BlockBlobUploadResponse>;
    uploadBrowserData(browserData: Blob | ArrayBuffer | ArrayBufferView, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadFile(filePath: string, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadStream(stream: Readable, bufferSize?: number, maxConcurrency?: number, options?: BlockBlobUploadStreamOptions): Promise<BlobUploadCommonResponse>;
    withSnapshot(snapshot: string): BlockBlobClient;
}

// @public
export interface BlockBlobCommitBlockListHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobCommitBlockListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
    tier?: BlockBlobTier | string;
}

// @public
export type BlockBlobCommitBlockListResponse = BlockBlobCommitBlockListHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobCommitBlockListHeaders;
    };
};

// @public
export interface BlockBlobGetBlockListHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlockBlobGetBlockListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type BlockBlobGetBlockListResponse = BlockList & BlockBlobGetBlockListHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobGetBlockListHeaders;
        bodyAsText: string;
        parsedBody: BlockList;
    };
};

// @public
export interface BlockBlobParallelUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blockSize?: number;
    concurrency?: number;
    conditions?: BlobRequestConditions;
    maxSingleShotSize?: number;
    metadata?: {
        [propertyName: string]: string;
    };
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export interface BlockBlobStageBlockFromURLHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    isServerEncrypted?: boolean;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobStageBlockFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    range?: Range;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type BlockBlobStageBlockFromURLResponse = BlockBlobStageBlockFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobStageBlockFromURLHeaders;
    };
};

// @public
export interface BlockBlobStageBlockHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    isServerEncrypted?: boolean;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobStageBlockOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type BlockBlobStageBlockResponse = BlockBlobStageBlockHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobStageBlockHeaders;
    };
};

// @public
export enum BlockBlobTier {
    Archive = "Archive",
    Cool = "Cool",
    Hot = "Hot"
}

// @public
export interface BlockBlobUploadHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlockBlobUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
    tier?: BlockBlobTier | string;
}

// @public
export type BlockBlobUploadResponse = BlockBlobUploadHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobUploadHeaders;
    };
};

// @public
export interface BlockBlobUploadStreamOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    metadata?: {
        [propertyName: string]: string;
    };
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export interface BlockList {
    // (undocumented)
    committedBlocks?: Block[];
    // (undocumented)
    uncommittedBlocks?: Block[];
}

// @public
export type BlockListType = 'committed' | 'uncommitted' | 'all';

// @public
export interface CommonOptions {
    // Warning: (ae-forgotten-export) The symbol "OperationTracingOptions" needs to be exported by the entry point index.d.ts
    tracingOptions?: OperationTracingOptions;
}

// @public
export interface ContainerAcquireLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerBreakLeaseOptionalParams extends coreHttp.RequestOptionsBase {
    breakPeriod?: number;
    modifiedAccessConditions?: ModifiedAccessConditions;
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export interface ContainerBreakLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerChangeLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class ContainerClient extends StorageClient {
    constructor(connectionString: string, containerName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    readonly containerName: string;
    create(options?: ContainerCreateOptions): Promise<ContainerCreateResponse>;
    delete(options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteResponse>;
    deleteBlob(blobName: string, options?: BlobDeleteOptions): Promise<BlobDeleteResponse>;
    exists(options?: ContainerExistsOptions): Promise<boolean>;
    getAccessPolicy(options?: ContainerGetAccessPolicyOptions): Promise<ContainerGetAccessPolicyResponse>;
    getAppendBlobClient(blobName: string): AppendBlobClient;
    getBlobClient(blobName: string): BlobClient;
    getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient;
    getBlockBlobClient(blobName: string): BlockBlobClient;
    getPageBlobClient(blobName: string): PageBlobClient;
    getProperties(options?: ContainerGetPropertiesOptions): Promise<ContainerGetPropertiesResponse>;
    listBlobsByHierarchy(delimiter: string, options?: ContainerListBlobsOptions): PagedAsyncIterableIterator<({
        kind: "prefix";
    } & BlobPrefix) | ({
        kind: "blob";
    } & BlobItem), ContainerListBlobHierarchySegmentResponse>;
    listBlobsFlat(options?: ContainerListBlobsOptions): PagedAsyncIterableIterator<BlobItem, ContainerListBlobFlatSegmentResponse>;
    setAccessPolicy(access?: PublicAccessType, containerAcl?: SignedIdentifier[], options?: ContainerSetAccessPolicyOptions): Promise<ContainerSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: ContainerSetMetadataOptions): Promise<ContainerSetMetadataResponse>;
    uploadBlockBlob(blobName: string, body: HttpRequestBody, contentLength: number, options?: BlockBlobUploadOptions): Promise<{
        blockBlobClient: BlockBlobClient;
        response: BlockBlobUploadResponse;
    }>;
}

// @public
export interface ContainerCreateHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    access?: PublicAccessType;
    metadata?: Metadata;
}

// @public
export type ContainerCreateResponse = ContainerCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerCreateHeaders;
    };
};

// @public
export interface ContainerDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerDeleteMethodOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export type ContainerDeleteResponse = ContainerDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerDeleteHeaders;
    };
};

// @public
export interface ContainerExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface ContainerGetAccessPolicyHeaders {
    blobPublicAccess?: PublicAccessType;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type ContainerGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifierModel[];
} & ContainerGetAccessPolicyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ContainerGetAccessPolicyHeaders;
        bodyAsText: string;
        parsedBody: SignedIdentifierModel[];
    };
};

// @public
export interface ContainerGetPropertiesHeaders {
    blobPublicAccess?: PublicAccessType;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    hasImmutabilityPolicy?: boolean;
    hasLegalHold?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type ContainerGetPropertiesResponse = ContainerGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerGetPropertiesHeaders;
    };
};

// @public
export interface ContainerItem {
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    properties: ContainerProperties;
}

// @public
export interface ContainerListBlobFlatSegmentHeaders {
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerListBlobFlatSegmentResponse = ListBlobsFlatSegmentResponse & ContainerListBlobFlatSegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerListBlobFlatSegmentHeaders;
        bodyAsText: string;
        parsedBody: ListBlobsFlatSegmentResponse;
    };
};

// @public
export interface ContainerListBlobHierarchySegmentHeaders {
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerListBlobHierarchySegmentResponse = ListBlobsHierarchySegmentResponse & ContainerListBlobHierarchySegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerListBlobHierarchySegmentHeaders;
        bodyAsText: string;
        parsedBody: ListBlobsHierarchySegmentResponse;
    };
};

// @public
export interface ContainerListBlobsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeCopy?: boolean;
    includeDeleted?: boolean;
    includeMetadata?: boolean;
    includeSnapshots?: boolean;
    includeUncommitedBlobs?: boolean;
    prefix?: string;
}

// @public
export interface ContainerProperties {
    // (undocumented)
    etag: string;
    // (undocumented)
    hasImmutabilityPolicy?: boolean;
    // (undocumented)
    hasLegalHold?: boolean;
    // (undocumented)
    lastModified: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    publicAccess?: PublicAccessType;
}

// @public
export interface ContainerReleaseLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerRenewLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class ContainerSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): ContainerSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface ContainerSetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export type ContainerSetAccessPolicyResponse = ContainerSetAccessPolicyHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerSetAccessPolicyHeaders;
    };
};

// @public
export interface ContainerSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export type ContainerSetMetadataResponse = ContainerSetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerSetMetadataHeaders;
    };
};

// @public
export type CopyPollerBlobClient = Pick<BlobClient, "abortCopyFromURL" | "getProperties"> & {
    startCopyFromURL(copySource: string, options?: BlobStartCopyFromURLOptions): Promise<BlobBeginCopyFromURLResponse>;
};

// @public
export type CopyStatusType = 'pending' | 'success' | 'aborted' | 'failed';

// @public
export interface CorsRule {
    allowedHeaders: string;
    allowedMethods: string;
    allowedOrigins: string;
    exposedHeaders: string;
    maxAgeInSeconds: number;
}

// @public
export interface CpkInfo {
    encryptionAlgorithm?: EncryptionAlgorithmType;
    encryptionKey?: string;
    encryptionKeySha256?: string;
}

// @public
export abstract class Credential implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;

// @public
export type DeleteSnapshotsOptionType = 'include' | 'only';

export { deserializationPolicy }

// @public
export type EncryptionAlgorithmType = 'AES256';

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateBlobSASQueryParameters(blobSASSignatureValues: BlobSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateBlobSASQueryParameters(blobSASSignatureValues: BlobSASSignatureValues, userDelegationKey: UserDelegationKey, accountName: string): SASQueryParameters;

// @public
export interface GeoReplication {
    lastSyncOn: Date;
    status: GeoReplicationStatusType;
}

// @public
export type GeoReplicationStatusType = 'live' | 'bootstrap' | 'unavailable';

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

export { IHttpClient }

// @public
export interface Lease {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    leaseId?: string;
    leaseTime?: number;
    requestId?: string;
    version?: string;
}

// @public
export interface LeaseAccessConditions {
    leaseId?: string;
}

// @public
export type LeaseDurationType = 'infinite' | 'fixed';

// @public
export interface LeaseOperationOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export type LeaseOperationResponse = Lease & {
    _response: HttpResponse & {
        parsedHeaders: Lease;
    };
};

// @public
export type LeaseStateType = 'available' | 'leased' | 'expired' | 'breaking' | 'broken';

// @public
export type LeaseStatusType = 'locked' | 'unlocked';

// @public
export interface ListBlobsFlatSegmentResponse {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobFlatListSegment;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export interface ListBlobsHierarchySegmentResponse {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobHierarchyListSegment;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export type ListBlobsIncludeItem = 'copy' | 'deleted' | 'metadata' | 'snapshots' | 'uncommittedblobs';

// @public
export type ListContainersIncludeType = 'metadata';

// @public
export interface ListContainersSegmentResponse {
    // (undocumented)
    containerItems: ContainerItem[];
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export const logger: import("@azure/logger").AzureLogger;

// @public
export interface Logging {
    deleteProperty: boolean;
    read: boolean;
    // (undocumented)
    retentionPolicy: RetentionPolicy;
    version: string;
    write: boolean;
}

// @public
export interface Metadata {
    [propertyName: string]: string;
}

// @public
export interface Metrics {
    enabled: boolean;
    includeAPIs?: boolean;
    // (undocumented)
    retentionPolicy?: RetentionPolicy;
    version?: string;
}

// @public
export interface ModifiedAccessConditions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
}

// @public
export function newPipeline(credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export interface PageBlobClearPagesHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobClearPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export type PageBlobClearPagesResponse = PageBlobClearPagesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobClearPagesHeaders;
    };
};

// @public
export class PageBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    clearPages(offset?: number, count?: number, options?: PageBlobClearPagesOptions): Promise<PageBlobClearPagesResponse>;
    create(size: number, options?: PageBlobCreateOptions): Promise<PageBlobCreateResponse>;
    getPageRanges(offset?: number, count?: number, options?: PageBlobGetPageRangesOptions): Promise<PageBlobGetPageRangesResponse>;
    getPageRangesDiff(offset: number, count: number, prevSnapshot: string, options?: PageBlobGetPageRangesDiffOptions): Promise<PageBlobGetPageRangesDiffResponse>;
    resize(size: number, options?: PageBlobResizeOptions): Promise<PageBlobResizeResponse>;
    startCopyIncremental(copySource: string, options?: PageBlobStartCopyIncrementalOptions): Promise<PageBlobCopyIncrementalResponse>;
    updateSequenceNumber(sequenceNumberAction: SequenceNumberActionType, sequenceNumber?: number, options?: PageBlobUpdateSequenceNumberOptions): Promise<PageBlobUpdateSequenceNumberResponse>;
    uploadPages(body: HttpRequestBody, offset: number, count: number, options?: PageBlobUploadPagesOptions): Promise<PageBlobUploadPagesResponse>;
    uploadPagesFromURL(sourceURL: string, sourceOffset: number, destOffset: number, count: number, options?: PageBlobUploadPagesFromURLOptions): Promise<PageBlobUploadPagesFromURLResponse>;
    withSnapshot(snapshot: string): PageBlobClient;
}

// @public
export interface PageBlobCopyIncrementalHeaders {
    clientRequestId?: string;
    copyId?: string;
    copyStatus?: CopyStatusType;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export type PageBlobCopyIncrementalResponse = PageBlobCopyIncrementalHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobCopyIncrementalHeaders;
    };
};

// @public
export interface PageBlobCreateHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blobSequenceNumber?: number;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
    tier?: PremiumPageBlobTier | string;
}

// @public
export type PageBlobCreateResponse = PageBlobCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobCreateHeaders;
    };
};

// @public
export interface PageBlobGetPageRangesDiffHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobGetPageRangesDiffOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    range?: string;
}

// @public
export interface PageBlobGetPageRangesDiffResponse extends PageList, PageBlobGetPageRangesDiffHeaders {
    _response: HttpResponse & {
        parsedHeaders: PageBlobGetPageRangesDiffHeaders;
        bodyAsText: string;
        parsedBody: PageList;
    };
}

// @public
export interface PageBlobGetPageRangesHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobGetPageRangesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export interface PageBlobGetPageRangesResponse extends PageList, PageBlobGetPageRangesHeaders {
    _response: HttpResponse & {
        parsedHeaders: PageBlobGetPageRangesHeaders;
        bodyAsText: string;
        parsedBody: PageList;
    };
}

// @public
export interface PageBlobRequestConditions extends BlobRequestConditions, SequenceNumberAccessConditions {
}

// @public
export interface PageBlobResizeHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobResizeOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export type PageBlobResizeResponse = PageBlobResizeHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobResizeHeaders;
    };
};

// @public
export interface PageBlobStartCopyIncrementalOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface PageBlobUpdateSequenceNumberHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobUpdateSequenceNumberOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export type PageBlobUpdateSequenceNumberResponse = PageBlobUpdateSequenceNumberHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobUpdateSequenceNumberHeaders;
    };
};

// @public
export interface PageBlobUploadPagesFromURLHeaders {
    blobSequenceNumber?: number;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobUploadPagesFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    sourceConditions?: ModifiedAccessConditions;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type PageBlobUploadPagesFromURLResponse = PageBlobUploadPagesFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobUploadPagesFromURLHeaders;
    };
};

// @public
export interface PageBlobUploadPagesHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobUploadPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type PageBlobUploadPagesResponse = PageBlobUploadPagesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobUploadPagesHeaders;
    };
};

// @public
export interface PageList {
    clearRange?: Range[];
    pageRange?: Range[];
}

// @public
export interface ParsedBatchResponse {
    subResponses: BatchSubResponse[];
    subResponsesFailedCount: number;
    subResponsesSucceededCount: number;
}

// @public
export class Pipeline {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: IHttpClient;
}

export { PollerLike }

export { PollOperationState }

// @public
export enum PremiumPageBlobTier {
    P10 = "P10",
    P15 = "P15",
    P20 = "P20",
    P30 = "P30",
    P4 = "P4",
    P40 = "P40",
    P50 = "P50",
    P6 = "P6",
    P60 = "P60",
    P70 = "P70",
    P80 = "P80"
}

// @public
export type PublicAccessType = 'container' | 'blob';

// @public
export interface Range {
    count?: number;
    offset: number;
}

// @public
export type RehydratePriority = 'High' | 'Standard';

export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

export { RestError }

// @public
export interface RetentionPolicy {
    days?: number;
    enabled: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string, userDelegationKey?: UserDelegationKey);
    readonly cacheControl?: string;
    readonly contentDisposition?: string;
    readonly contentEncoding?: string;
    readonly contentLanguage?: string;
    readonly contentType?: string;
    readonly expiresOn?: Date;
    readonly identifier?: string;
    readonly ipRange: SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface SequenceNumberAccessConditions {
    ifSequenceNumberEqualTo?: number;
    ifSequenceNumberLessThan?: number;
    ifSequenceNumberLessThanOrEqualTo?: number;
}

// @public
export type SequenceNumberActionType = 'max' | 'update' | 'increment';

// @public
export interface ServiceGetAccountInfoHeaders {
    accountKind?: AccountKind;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    skuName?: SkuName;
    version?: string;
}

// @public
export interface ServiceGetAccountInfoOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetAccountInfoResponse = ServiceGetAccountInfoHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetAccountInfoHeaders;
    };
};

// @public
export interface ServiceGetPropertiesHeaders {
    clientRequestId?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetPropertiesResponse = BlobServiceProperties & ServiceGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetPropertiesHeaders;
        bodyAsText: string;
        parsedBody: BlobServiceProperties;
    };
};

// @public
export interface ServiceGetStatisticsHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetStatisticsResponse = BlobServiceStatistics & ServiceGetStatisticsHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetStatisticsHeaders;
        bodyAsText: string;
        parsedBody: BlobServiceStatistics;
    };
};

// @public
export interface ServiceGetUserDelegationKeyHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetUserDelegationKeyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetUserDelegationKeyResponse = UserDelegationKey & ServiceGetUserDelegationKeyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ServiceGetUserDelegationKeyHeaders;
        bodyAsText: string;
        parsedBody: UserDelegationKeyModel;
    };
};

// @public
export interface ServiceListContainersOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeMetadata?: boolean;
    prefix?: string;
}

// @public
export interface ServiceListContainersSegmentHeaders {
    clientRequestId?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ServiceListContainersSegmentResponse = ListContainersSegmentResponse & ServiceListContainersSegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceListContainersSegmentHeaders;
        bodyAsText: string;
        parsedBody: ListContainersSegmentResponse;
    };
};

// @public
export interface ServiceSetPropertiesHeaders {
    clientRequestId?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceSetPropertiesHeaders;
    };
};

// @public
export interface ServiceSubmitBatchHeaders {
    clientRequestId?: string;
    contentType?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSubmitBatchOptionalParamsModel extends coreHttp.RequestOptionsBase {
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export type ServiceSubmitBatchResponseModel = ServiceSubmitBatchHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceSubmitBatchHeaders;
    };
};

// @public
export interface SignedIdentifier {
    accessPolicy: {
        startsOn?: Date;
        expiresOn?: Date;
        permissions: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    // (undocumented)
    accessPolicy: AccessPolicy;
    id: string;
}

// @public
export type SkuName = 'Standard_LRS' | 'Standard_GRS' | 'Standard_RAGRS' | 'Standard_ZRS' | 'Premium_LRS';

// @public
export interface StaticWebsite {
    enabled: boolean;
    errorDocument404Path?: string;
    indexDocument?: string;
}

// @public
export class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}

// @public
export class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}

// @public
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    httpClient?: IHttpClient;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxyOptions;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentOptions;
}

// @public
export interface StorageRetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: StorageRetryPolicyType;
    readonly secondaryHost?: string;
    readonly tryTimeoutInMs?: number;
}

// @public
export class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions);
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
}

// @public
export class StorageRetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: StorageRetryOptions);
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
    }

// @public
export enum StorageRetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export class StorageSharedKeyCredential extends Credential {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
}

// @public
export class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type SyncCopyStatusType = 'success';

// @public
export interface UserDelegationKey {
    signedExpiresOn: Date;
    signedObjectId: string;
    signedService: string;
    signedStartsOn: Date;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}

// @public
export interface UserDelegationKeyModel {
    signedExpiresOn: string;
    signedObjectId: string;
    signedService: string;
    signedStartsOn: string;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}

export { WebResource }


// (No @packageDocumentation comment for this package)

```
