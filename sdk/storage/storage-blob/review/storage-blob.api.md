## API Report File for "@azure/storage-blob"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { BaseRequestPolicy } from '@azure/core-http';
import * as coreHttp from '@azure/core-http';
import { deserializationPolicy } from '@azure/core-http';
import { HttpHeaders } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { HttpPipelineLogLevel } from '@azure/core-http';
import { HttpRequestBody } from '@azure/core-http';
import { HttpResponse } from '@azure/core-http';
import { HttpClient as IHttpClient } from '@azure/core-http';
import { HttpPipelineLogger as IHttpPipelineLogger } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { ProxySettings } from '@azure/core-http';
import { Readable } from 'stream';
import { RequestPolicy } from '@azure/core-http';
import { RequestPolicyFactory } from '@azure/core-http';
import { RequestPolicyOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { SpanOptions } from '@azure/core-tracing';
import { TokenCredential } from '@azure/core-http';
import { TransferProgressEvent } from '@azure/core-http';
import { WebResource } from '@azure/core-http';

// @public
export type AccessTier = 'P4' | 'P6' | 'P10' | 'P15' | 'P20' | 'P30' | 'P40' | 'P50' | 'P60' | 'P70' | 'P80' | 'Hot' | 'Cool' | 'Archive';

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiryTime: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startTime?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

// @public (undocumented)
export interface AppendBlobAppendBlockFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    // Warning: (ae-forgotten-export) The symbol "AppendBlobRequestConditions" needs to be exported by the entry point index.d.ts
    conditions?: AppendBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    sourceConditions?: ModifiedAccessConditions;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// Warning: (ae-forgotten-export) The symbol "AppendBlobAppendBlockFromUrlHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type AppendBlobAppendBlockFromUrlResponse = AppendBlobAppendBlockFromUrlHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: AppendBlobAppendBlockFromUrlHeaders;
    };
};

// @public
export interface AppendBlobAppendBlockOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// Warning: (ae-forgotten-export) The symbol "AppendBlobAppendBlockHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type AppendBlobAppendBlockResponse = AppendBlobAppendBlockHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: AppendBlobAppendBlockHeaders;
    };
};

// @public
export class AppendBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    appendBlock(body: HttpRequestBody, contentLength: number, options?: AppendBlobAppendBlockOptions): Promise<AppendBlobAppendBlockResponse>;
    appendBlockFromURL(sourceURL: string, sourceOffset: number, count: number, options?: AppendBlobAppendBlockFromURLOptions): Promise<AppendBlobAppendBlockFromUrlResponse>;
    create(options?: AppendBlobCreateOptions): Promise<AppendBlobCreateResponse>;
    withSnapshot(snapshot: string): AppendBlobClient;
}

// @public
export interface AppendBlobCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    // Warning: (ae-forgotten-export) The symbol "BlobRequestConditions" needs to be exported by the entry point index.d.ts
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    // Warning: (ae-forgotten-export) The symbol "Metadata" needs to be exported by the entry point index.d.ts
    metadata?: Metadata;
}

// Warning: (ae-forgotten-export) The symbol "AppendBlobCreateHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type AppendBlobCreateResponse = AppendBlobCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: AppendBlobCreateHeaders;
    };
};

// @public
export interface AppendPositionAccessConditions {
    appendPosition?: number;
    maxSize?: number;
}

export { BaseRequestPolicy }

// @public (undocumented)
export interface BatchSubRequest {
    credential: SharedKeyCredential | AnonymousCredential | TokenCredential;
    url: string;
}

// @public (undocumented)
export interface BatchSubResponse {
    bodyAsText?: string;
    errorCode?: string;
    headers: HttpHeaders;
    _request: BatchSubRequest;
    status: number;
    statusMessage: string;
}

// @public
export interface BlobAbortCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// Warning: (ae-forgotten-export) The symbol "BlobAbortCopyFromURLHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobAbortCopyFromURLResponse = BlobAbortCopyFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobAbortCopyFromURLHeaders;
    };
};

// @public
export interface BlobAcquireLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class BlobBatch {
    constructor();
    deleteBlob(url: string, credential: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: BlobDeleteOptions): Promise<void>;
    deleteBlob(blobClient: BlobClient, options?: BlobDeleteOptions): Promise<void>;
    getHttpRequestBody(): string;
    getMultiPartContentType(): string;
    getSubRequests(): Map<number, BatchSubRequest>;
    setBlobAccessTier(url: string, credential: SharedKeyCredential | AnonymousCredential | TokenCredential, tier: AccessTier, options?: BlobSetTierOptions): Promise<void>;
    setBlobAccessTier(blobClient: BlobClient, tier: AccessTier, options?: BlobSetTierOptions): Promise<void>;
}

// @public
export class BlobBatchClient {
    constructor(url: string, credential?: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    // (undocumented)
    createBatch(): BlobBatch;
    deleteBlobs(urls: string[], credential: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: BlobDeleteOptions): Promise<BlobBatchDeleteBlobsResponse>;
    deleteBlobs(blobClients: BlobClient[], options?: BlobDeleteOptions): Promise<BlobBatchDeleteBlobsResponse>;
    setBlobsAccessTier(urls: string[], credential: SharedKeyCredential | AnonymousCredential | TokenCredential, tier: AccessTier, options?: BlobSetTierOptions): Promise<BlobBatchSetBlobsAccessTierResponse>;
    setBlobsAccessTier(blobClients: BlobClient[], tier: AccessTier, options?: BlobSetTierOptions): Promise<BlobBatchSetBlobsAccessTierResponse>;
    submitBatch(batchRequest: BlobBatch, options?: BlobBatchSubmitBatchOptionalParams): Promise<BlobBatchSubmitBatchResponse>;
}

// @public (undocumented)
export type BlobBatchDeleteBlobsResponse = BlobBatchSubmitBatchResponse;

// @public (undocumented)
export type BlobBatchSetBlobsAccessTierResponse = BlobBatchSubmitBatchResponse;

// @public
export interface BlobBatchSubmitBatchOptionalParams extends ServiceSubmitBatchOptionalParamsModel, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type BlobBatchSubmitBatchResponse = ParsedBatchResponse & ServiceSubmitBatchHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ServiceSubmitBatchHeaders;
    };
};

// @public
export interface BlobBeginCopyFromURLOptions extends BlobStartCopyFromURLOptions {
    intervalInMs?: number;
    onProgress?: (state: BlobBeginCopyFromUrlPollState) => void;
    resumeFrom?: string;
}

// @public
export interface BlobBeginCopyFromUrlPollState extends PollOperationState<BlobBeginCopyFromURLResponse> {
    readonly blobClient: CopyPollerBlobClient;
    copyId?: string;
    copyProgress?: string;
    copySource: string;
    readonly startCopyFromURLOptions?: BlobStartCopyFromURLOptions;
}

// @public
export interface BlobBeginCopyFromURLResponse extends BlobStartCopyFromURLResponse {
}

// @public
export interface BlobBreakLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobChangeLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
// 
// @public
export class BlobClient extends StorageClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    abortCopyFromURL(copyId: string, options?: BlobAbortCopyFromURLOptions): Promise<BlobAbortCopyFromURLResponse>;
    beginCopyFromURL(copySource: string, options?: BlobBeginCopyFromURLOptions): Promise<PollerLike<PollOperationState<BlobBeginCopyFromURLResponse>, BlobBeginCopyFromURLResponse>>;
    // (undocumented)
    readonly containerName: string;
    createSnapshot(options?: BlobCreateSnapshotOptions): Promise<BlobCreateSnapshotResponse>;
    delete(options?: BlobDeleteOptions): Promise<BlobDeleteResponse>;
    download(offset?: number, count?: number, options?: BlobDownloadOptions): Promise<BlobDownloadResponseModel>;
    downloadToBuffer(offset?: number, count?: number, options?: BlobDownloadToBufferOptions): Promise<Buffer>;
    downloadToBuffer(buffer: Buffer, offset?: number, count?: number, options?: BlobDownloadToBufferOptions): Promise<Buffer>;
    downloadToFile(filePath: string, offset?: number, count?: number, options?: BlobDownloadOptions): Promise<BlobDownloadResponseModel>;
    exists(options?: BlobExistsOptions): Promise<boolean>;
    getAppendBlobClient(): AppendBlobClient;
    getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient;
    getBlockBlobClient(): BlockBlobClient;
    getPageBlobClient(): PageBlobClient;
    getProperties(options?: BlobGetPropertiesOptions): Promise<BlobGetPropertiesResponse>;
    // (undocumented)
    readonly name: string;
    setAccessTier(tier: BlockBlobTier | PremiumPageBlobTier | string, options?: BlobSetTierOptions): Promise<BlobSetTierResponse>;
    setHTTPHeaders(blobHTTPHeaders?: BlobHTTPHeaders, options?: BlobSetHTTPHeadersOptions): Promise<BlobSetHTTPHeadersResponse>;
    setMetadata(metadata?: Metadata, options?: BlobSetMetadataOptions): Promise<BlobSetMetadataResponse>;
    syncCopyFromURL(copySource: string, options?: BlobSyncCopyFromURLOptions): Promise<BlobCopyFromURLResponse>;
    undelete(options?: BlobUndeleteOptions): Promise<BlobUndeleteResponse>;
    withSnapshot(snapshot: string): BlobClient;
}

// Warning: (ae-forgotten-export) The symbol "BlobCopyFromURLHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobCopyFromURLResponse = BlobCopyFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobCopyFromURLHeaders;
    };
};

// @public
export interface BlobCreateSnapshotOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
}

// Warning: (ae-forgotten-export) The symbol "BlobCreateSnapshotHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobCreateSnapshotResponse = BlobCreateSnapshotHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobCreateSnapshotHeaders;
    };
};

// @public
export interface BlobDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    deleteSnapshots?: DeleteSnapshotsOptionType;
}

// Warning: (ae-forgotten-export) The symbol "BlobDeleteHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobDeleteResponse = BlobDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobDeleteHeaders;
    };
};

// @public
export interface BlobDownloadHeaders {
    acceptRanges?: string;
    blobCommittedBlockCount?: number;
    blobContentMD5?: Uint8Array;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentCrc64?: Uint8Array;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentRange?: string;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface BlobDownloadOptionalParams extends coreHttp.RequestOptionsBase {
    cpkInfo?: CpkInfo;
    leaseAccessConditions?: LeaseAccessConditions;
    modifiedAccessConditions?: ModifiedAccessConditions;
    range?: string;
    rangeGetContentCRC64?: boolean;
    rangeGetContentMD5?: boolean;
    requestId?: string;
    snapshot?: string;
    timeoutInSeconds?: number;
}

// @public
export interface BlobDownloadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    maxRetryRequests?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeGetContentCrc64?: boolean;
    rangeGetContentMD5?: boolean;
    snapshot?: string;
}

// @public
export type BlobDownloadResponseModel = BlobDownloadHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobDownloadHeaders;
    };
};

// @public
export interface BlobDownloadToBufferOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blockSize?: number;
    concurrency?: number;
    conditions?: BlobRequestConditions;
    maxRetryRequestsPerBlock?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export interface BlobExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    customerProvidedKey?: CpkInfo;
}

// @public
export interface BlobGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// Warning: (ae-forgotten-export) The symbol "BlobGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobGetPropertiesResponse = BlobGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobGetPropertiesHeaders;
    };
};

// @public
export interface BlobHTTPHeaders {
    blobCacheControl?: string;
    blobContentDisposition?: string;
    blobContentEncoding?: string;
    blobContentLanguage?: string;
    blobContentMD5?: Uint8Array;
    blobContentType?: string;
}

// @public
export interface BlobItem {
    // (undocumented)
    deleted: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // Warning: (ae-forgotten-export) The symbol "BlobProperties" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    properties: BlobProperties;
    // (undocumented)
    snapshot: string;
}

// @public
export class BlobLeaseClient {
    constructor(client: ContainerClient | BlobClient, leaseId?: string);
    acquireLease(duration: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    breakLease(breakPeriod: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    readonly leaseId: string;
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    renewLease(options?: LeaseOperationOptions): Promise<Lease>;
    readonly url: string;
    }

// @public
export interface BlobPrefix {
    // (undocumented)
    name: string;
}

// @public
export interface BlobReleaseLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobRenewLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class BlobSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    static parse(permissions: string): BlobSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface BlobSASSignatureValues {
    blobName?: string;
    cacheControl?: string;
    containerName: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    expiryTime?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: BlobSASPermissions;
    protocol?: SASProtocol;
    snapshotTime?: string;
    startTime?: Date;
    version?: string;
}

// @public
export class BlobServiceClient extends StorageClient {
    constructor(url: string, credential?: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createContainer(containerName: string, options?: ContainerCreateOptions): Promise<{
        containerClient: ContainerClient;
        containerCreateResponse: ContainerCreateResponse;
    }>;
    deleteContainer(containerName: string, options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): BlobServiceClient;
    getAccountInfo(options?: ServiceGetAccountInfoOptions): Promise<ServiceGetAccountInfoResponse>;
    getBlobBatchClient(): BlobBatchClient;
    getContainerClient(containerName: string): ContainerClient;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getStatistics(options?: ServiceGetStatisticsOptions): Promise<ServiceGetStatisticsResponse>;
    getUserDelegationKey(start: Date, expiry: Date, options?: ServiceGetUserDelegationKeyOptions): Promise<ServiceGetUserDelegationKeyResponse>;
    listContainers(options?: ServiceListContainersOptions): PagedAsyncIterableIterator<ContainerItem, ServiceListContainersSegmentResponse>;
    setProperties(properties: BlobServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
}

// @public
export interface BlobServiceProperties {
    // Warning: (ae-forgotten-export) The symbol "Logging" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    blobAnalyticsLogging?: Logging;
    // Warning: (ae-forgotten-export) The symbol "CorsRule" needs to be exported by the entry point index.d.ts
    cors?: CorsRule[];
    defaultServiceVersion?: string;
    // Warning: (ae-forgotten-export) The symbol "RetentionPolicy" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    deleteRetentionPolicy?: RetentionPolicy;
    // Warning: (ae-forgotten-export) The symbol "Metrics" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    hourMetrics?: Metrics;
    // (undocumented)
    minuteMetrics?: Metrics;
    // Warning: (ae-forgotten-export) The symbol "StaticWebsite" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    staticWebsite?: StaticWebsite;
}

// @public
export interface BlobSetHTTPHeadersOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// Warning: (ae-forgotten-export) The symbol "BlobSetHTTPHeadersHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobSetHTTPHeadersResponse = BlobSetHTTPHeadersHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobSetHTTPHeadersHeaders;
    };
};

// @public
export interface BlobSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// Warning: (ae-forgotten-export) The symbol "BlobSetMetadataHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobSetMetadataResponse = BlobSetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobSetMetadataHeaders;
    };
};

// @public
export interface BlobSetTierOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    rehydratePriority?: RehydratePriority;
}

// Warning: (ae-forgotten-export) The symbol "BlobSetTierHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobSetTierResponse = BlobSetTierHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobSetTierHeaders;
    };
};

// @public
export interface BlobStartCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    metadata?: Metadata;
    rehydratePriority?: RehydratePriority;
    sourceConditions?: ModifiedAccessConditions;
    tier?: BlockBlobTier | PremiumPageBlobTier | string;
}

// Warning: (ae-forgotten-export) The symbol "BlobStartCopyFromURLHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobStartCopyFromURLResponse = BlobStartCopyFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobStartCopyFromURLHeaders;
    };
};

// @public
export interface BlobSyncCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    metadata?: Metadata;
    sourceConditions?: ModifiedAccessConditions;
}

// @public
export type BlobType = 'BlockBlob' | 'PageBlob' | 'AppendBlob';

// @public
export interface BlobUndeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    customerProvidedKey?: CpkInfo;
}

// Warning: (ae-forgotten-export) The symbol "BlobUndeleteHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlobUndeleteResponse = BlobUndeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlobUndeleteHeaders;
    };
};

// @public
export type BlobUploadCommonResponse = BlockBlobUploadHeaders & {
    _response: HttpResponse;
};

// @public
export class BlockBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    commitBlockList(blocks: string[], options?: BlockBlobCommitBlockListOptions): Promise<BlockBlobCommitBlockListResponse>;
    getBlockList(listType: BlockListType, options?: BlockBlobGetBlockListOptions): Promise<BlockBlobGetBlockListResponse>;
    stageBlock(blockId: string, body: HttpRequestBody, contentLength: number, options?: BlockBlobStageBlockOptions): Promise<BlockBlobStageBlockResponse>;
    stageBlockFromURL(blockId: string, sourceURL: string, offset?: number, count?: number, options?: BlockBlobStageBlockFromURLOptions): Promise<BlockBlobStageBlockFromURLResponse>;
    upload(body: HttpRequestBody, contentLength: number, options?: BlockBlobUploadOptions): Promise<BlockBlobUploadResponse>;
    uploadBrowserData(browserData: Blob | ArrayBuffer | ArrayBufferView, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadFile(filePath: string, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadStream(stream: Readable, bufferSize: number, maxBuffers: number, options?: BlockBlobUploadStreamOptions): Promise<BlobUploadCommonResponse>;
    withSnapshot(snapshot: string): BlockBlobClient;
}

// @public
export interface BlockBlobCommitBlockListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
    tier?: BlockBlobTier | string;
}

// Warning: (ae-forgotten-export) The symbol "BlockBlobCommitBlockListHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlockBlobCommitBlockListResponse = BlockBlobCommitBlockListHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobCommitBlockListHeaders;
    };
};

// @public
export interface BlockBlobGetBlockListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// Warning: (ae-forgotten-export) The symbol "BlockList" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "BlockBlobGetBlockListHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlockBlobGetBlockListResponse = BlockList & BlockBlobGetBlockListHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobGetBlockListHeaders;
        bodyAsText: string;
        parsedBody: BlockList;
    };
};

// @public
export interface BlockBlobParallelUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blockSize?: number;
    concurrency?: number;
    conditions?: BlobRequestConditions;
    maxSingleShotSize?: number;
    metadata?: {
        [propertyName: string]: string;
    };
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export interface BlockBlobStageBlockFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    range?: Range;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// Warning: (ae-forgotten-export) The symbol "BlockBlobStageBlockFromURLHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlockBlobStageBlockFromURLResponse = BlockBlobStageBlockFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobStageBlockFromURLHeaders;
    };
};

// @public
export interface BlockBlobStageBlockOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// Warning: (ae-forgotten-export) The symbol "BlockBlobStageBlockHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type BlockBlobStageBlockResponse = BlockBlobStageBlockHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobStageBlockHeaders;
    };
};

// @public (undocumented)
export enum BlockBlobTier {
    // (undocumented)
    Archive = "Archive",
    // (undocumented)
    Cool = "Cool",
    // (undocumented)
    Hot = "Hot"
}

// @public
export interface BlockBlobUploadHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlockBlobUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
    tier?: BlockBlobTier | string;
}

// @public
export type BlockBlobUploadResponse = BlockBlobUploadHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: BlockBlobUploadHeaders;
    };
};

// @public
export interface BlockBlobUploadStreamOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    metadata?: {
        [propertyName: string]: string;
    };
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export type BlockListType = 'committed' | 'uncommitted' | 'all';

// @public
export class BrowserPolicyFactory implements RequestPolicyFactory {
    // Warning: (ae-forgotten-export) The symbol "BrowserPolicy" needs to be exported by the entry point index.d.ts
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): BrowserPolicy;
}

// @public
export interface CommonOptions {
    // (undocumented)
    spanOptions?: SpanOptions;
}

// @public
export interface ContainerAcquireLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerBreakLeaseOptionalParams extends coreHttp.RequestOptionsBase {
    breakPeriod?: number;
    modifiedAccessConditions?: ModifiedAccessConditions;
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export interface ContainerBreakLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerChangeLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class ContainerClient extends StorageClient {
    constructor(connectionString: string, containerName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    // (undocumented)
    readonly containerName: string;
    create(options?: ContainerCreateOptions): Promise<ContainerCreateResponse>;
    delete(options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteResponse>;
    deleteBlob(blobName: string, options?: BlobDeleteOptions): Promise<BlobDeleteResponse>;
    exists(options?: ContainerExistsOptions): Promise<boolean>;
    getAccessPolicy(options?: ContainerGetAccessPolicyOptions): Promise<ContainerGetAccessPolicyResponse>;
    getAppendBlobClient(blobName: string): AppendBlobClient;
    getBlobClient(blobName: string): BlobClient;
    getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient;
    getBlockBlobClient(blobName: string): BlockBlobClient;
    getPageBlobClient(blobName: string): PageBlobClient;
    getProperties(options?: ContainerGetPropertiesOptions): Promise<ContainerGetPropertiesResponse>;
    listBlobsByHierarchy(delimiter: string, options?: ContainerListBlobsOptions): PagedAsyncIterableIterator<{
        kind: "prefix";
    } & BlobPrefix | {
        kind: "blob";
    } & BlobItem, ContainerListBlobHierarchySegmentResponse>;
    listBlobsFlat(options?: ContainerListBlobsOptions): PagedAsyncIterableIterator<BlobItem, ContainerListBlobFlatSegmentResponse>;
    setAccessPolicy(access?: PublicAccessType, containerAcl?: SignedIdentifier[], options?: ContainerSetAccessPolicyOptions): Promise<ContainerSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: ContainerSetMetadataOptions): Promise<ContainerSetMetadataResponse>;
    uploadBlockBlob(blobName: string, body: HttpRequestBody, contentLength: number, options?: BlockBlobUploadOptions): Promise<{
        blockBlobClient: BlockBlobClient;
        response: BlockBlobUploadResponse;
    }>;
}

// @public
export interface ContainerCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    access?: PublicAccessType;
    metadata?: Metadata;
}

// Warning: (ae-forgotten-export) The symbol "ContainerCreateHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ContainerCreateResponse = ContainerCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerCreateHeaders;
    };
};

// @public
export interface ContainerDeleteMethodOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// Warning: (ae-forgotten-export) The symbol "ContainerDeleteHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ContainerDeleteResponse = ContainerDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerDeleteHeaders;
    };
};

// @public
export interface ContainerExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface ContainerGetAccessPolicyHeaders {
    blobPublicAccess?: PublicAccessType;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public (undocumented)
export type ContainerGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifierModel[];
} & ContainerGetAccessPolicyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ContainerGetAccessPolicyHeaders;
        bodyAsText: string;
        parsedBody: SignedIdentifierModel[];
    };
};

// @public
export interface ContainerGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// Warning: (ae-forgotten-export) The symbol "ContainerGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ContainerGetPropertiesResponse = ContainerGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerGetPropertiesHeaders;
    };
};

// @public
export interface ContainerItem {
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // Warning: (ae-forgotten-export) The symbol "ContainerProperties" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    properties: ContainerProperties;
}

// Warning: (ae-forgotten-export) The symbol "ContainerListBlobFlatSegmentHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ContainerListBlobFlatSegmentResponse = ListBlobsFlatSegmentResponse & ContainerListBlobFlatSegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerListBlobFlatSegmentHeaders;
        bodyAsText: string;
        parsedBody: ListBlobsFlatSegmentResponse;
    };
};

// Warning: (ae-forgotten-export) The symbol "ListBlobsHierarchySegmentResponse" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ContainerListBlobHierarchySegmentHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ContainerListBlobHierarchySegmentResponse = ListBlobsHierarchySegmentResponse & ContainerListBlobHierarchySegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerListBlobHierarchySegmentHeaders;
        bodyAsText: string;
        parsedBody: ListBlobsHierarchySegmentResponse;
    };
};

// @public
export interface ContainerListBlobsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeCopy?: boolean;
    includeDeleted?: boolean;
    includeMetadata?: boolean;
    includeSnapshots?: boolean;
    includeUncommitedBlobs?: boolean;
    prefix?: string;
}

// @public
export interface ContainerReleaseLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerRenewLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class ContainerSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): ContainerSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface ContainerSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// Warning: (ae-forgotten-export) The symbol "ContainerSetAccessPolicyHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ContainerSetAccessPolicyResponse = ContainerSetAccessPolicyHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerSetAccessPolicyHeaders;
    };
};

// @public
export interface ContainerSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// Warning: (ae-forgotten-export) The symbol "ContainerSetMetadataHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ContainerSetMetadataResponse = ContainerSetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ContainerSetMetadataHeaders;
    };
};

// @public
export type CopyPollerBlobClient = Pick<BlobClient, "abortCopyFromURL" | "getProperties"> & {
    startCopyFromURL(copySource: string, options?: BlobStartCopyFromURLOptions): Promise<BlobBeginCopyFromURLResponse>;
};

// @public
export type CopyStatusType = 'pending' | 'success' | 'aborted' | 'failed';

// @public
export interface CpkInfo {
    // Warning: (ae-forgotten-export) The symbol "EncryptionAlgorithmType" needs to be exported by the entry point index.d.ts
    encryptionAlgorithm?: EncryptionAlgorithmType;
    encryptionKey?: string;
    encryptionKeySha256?: string;
}

// @public
export abstract class Credential implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;

// @public
export type DeleteSnapshotsOptionType = 'include' | 'only';

export { deserializationPolicy }

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: SharedKeyCredential): SASQueryParameters;

// @public
export function generateBlobSASQueryParameters(blobSASSignatureValues: BlobSASSignatureValues, sharedKeyCredential: SharedKeyCredential): SASQueryParameters;

// @public
export function generateBlobSASQueryParameters(blobSASSignatureValues: BlobSASSignatureValues, userDelegationKey: UserDelegationKey, accountName: string): SASQueryParameters;

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpPipelineLogLevel }

export { HttpRequestBody }

export { IHttpClient }

export { IHttpPipelineLogger }

// @public (undocumented)
export interface Lease {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    leaseId?: string;
    leaseTime?: number;
    requestId?: string;
    version?: string;
}

// @public
export interface LeaseAccessConditions {
    leaseId?: string;
}

// @public
export type LeaseDurationType = 'infinite' | 'fixed';

// @public
export interface LeaseOperationOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public (undocumented)
export type LeaseOperationResponse = Lease & {
    _response: HttpResponse & {
        parsedHeaders: Lease;
    };
};

// @public
export type LeaseStateType = 'available' | 'leased' | 'expired' | 'breaking' | 'broken';

// @public
export type LeaseStatusType = 'locked' | 'unlocked';

// @public
export interface ListBlobsFlatSegmentResponse {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // Warning: (ae-forgotten-export) The symbol "BlobFlatListSegment" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    segment: BlobFlatListSegment;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export type ListBlobsIncludeItem = 'copy' | 'deleted' | 'metadata' | 'snapshots' | 'uncommittedblobs';

// @public
export type ListContainersIncludeType = 'metadata';

// @public
export const logger: import("@azure/logger").AzureLogger;

// @public
export interface ModifiedAccessConditions {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifUnmodifiedSince?: Date;
}

// @public
export function newPipeline(credential: SharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export interface PageBlobClearPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    // Warning: (ae-forgotten-export) The symbol "PageBlobRequestConditions" needs to be exported by the entry point index.d.ts
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// Warning: (ae-forgotten-export) The symbol "PageBlobClearPagesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type PageBlobClearPagesResponse = PageBlobClearPagesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobClearPagesHeaders;
    };
};

// @public
export class PageBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    clearPages(offset?: number, count?: number, options?: PageBlobClearPagesOptions): Promise<PageBlobClearPagesResponse>;
    create(size: number, options?: PageBlobCreateOptions): Promise<PageBlobCreateResponse>;
    getPageRanges(offset?: number, count?: number, options?: PageBlobGetPageRangesOptions): Promise<PageBlobGetPageRangesResponse>;
    getPageRangesDiff(offset: number, count: number, prevSnapshot: string, options?: PageBlobGetPageRangesDiffOptions): Promise<PageBlobGetPageRangesDiffResponse>;
    resize(size: number, options?: PageBlobResizeOptions): Promise<PageBlobResizeResponse>;
    startCopyIncremental(copySource: string, options?: PageBlobStartCopyIncrementalOptions): Promise<PageBlobCopyIncrementalResponse>;
    updateSequenceNumber(sequenceNumberAction: SequenceNumberActionType, sequenceNumber?: number, options?: PageBlobUpdateSequenceNumberOptions): Promise<PageBlobUpdateSequenceNumberResponse>;
    uploadPages(body: HttpRequestBody, offset: number, count: number, options?: PageBlobUploadPagesOptions): Promise<PageBlobUploadPagesResponse>;
    uploadPagesFromURL(sourceURL: string, sourceOffset: number, destOffset: number, count: number, options?: PageBlobUploadPagesFromURLOptions): Promise<PageBlobUploadPagesFromURLResponse>;
    withSnapshot(snapshot: string): PageBlobClient;
}

// Warning: (ae-forgotten-export) The symbol "PageBlobCopyIncrementalHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type PageBlobCopyIncrementalResponse = PageBlobCopyIncrementalHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobCopyIncrementalHeaders;
    };
};

// @public
export interface PageBlobCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blobSequenceNumber?: number;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    metadata?: Metadata;
    tier?: PremiumPageBlobTier | string;
}

// Warning: (ae-forgotten-export) The symbol "PageBlobCreateHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type PageBlobCreateResponse = PageBlobCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobCreateHeaders;
    };
};

// @public
export interface PageBlobGetPageRangesDiffHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobGetPageRangesDiffOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    range?: string;
}

// @public
export interface PageBlobGetPageRangesDiffResponse extends PageList, PageBlobGetPageRangesDiffHeaders {
    _response: HttpResponse & {
        parsedHeaders: PageBlobGetPageRangesDiffHeaders;
        bodyAsText: string;
        parsedBody: PageList;
    };
}

// @public
export interface PageBlobGetPageRangesHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobGetPageRangesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public (undocumented)
export interface PageBlobGetPageRangesResponse extends PageList, PageBlobGetPageRangesHeaders {
    _response: HttpResponse & {
        parsedHeaders: PageBlobGetPageRangesHeaders;
        bodyAsText: string;
        parsedBody: PageList;
    };
}

// @public
export interface PageBlobResizeOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// Warning: (ae-forgotten-export) The symbol "PageBlobResizeHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type PageBlobResizeResponse = PageBlobResizeHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobResizeHeaders;
    };
};

// @public
export interface PageBlobStartCopyIncrementalOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface PageBlobUpdateSequenceNumberOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// Warning: (ae-forgotten-export) The symbol "PageBlobUpdateSequenceNumberHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type PageBlobUpdateSequenceNumberResponse = PageBlobUpdateSequenceNumberHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobUpdateSequenceNumberHeaders;
    };
};

// @public (undocumented)
export interface PageBlobUploadPagesFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    sourceConditions?: ModifiedAccessConditions;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// Warning: (ae-forgotten-export) The symbol "PageBlobUploadPagesFromURLHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type PageBlobUploadPagesFromURLResponse = PageBlobUploadPagesFromURLHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobUploadPagesFromURLHeaders;
    };
};

// @public
export interface PageBlobUploadPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// Warning: (ae-forgotten-export) The symbol "PageBlobUploadPagesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type PageBlobUploadPagesResponse = PageBlobUploadPagesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PageBlobUploadPagesHeaders;
    };
};

// @public (undocumented)
export interface PageList {
    // (undocumented)
    clearRange?: Range[];
    // (undocumented)
    pageRange?: Range[];
}

// @public (undocumented)
export interface ParsedBatchResponse {
    subResponses: BatchSubResponse[];
    subResponsesFailedCount: number;
    subResponsesSucceededCount: number;
}

// @public
export class Pipeline {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    HTTPClient?: IHttpClient;
    logger?: IHttpPipelineLogger;
}

export { PollerLike }

export { PollOperationState }

// @public (undocumented)
export enum PremiumPageBlobTier {
    // (undocumented)
    P10 = "P10",
    // (undocumented)
    P15 = "P15",
    // (undocumented)
    P20 = "P20",
    // (undocumented)
    P30 = "P30",
    // (undocumented)
    P4 = "P4",
    // (undocumented)
    P40 = "P40",
    // (undocumented)
    P50 = "P50",
    // (undocumented)
    P6 = "P6",
    // (undocumented)
    P60 = "P60",
    // (undocumented)
    P70 = "P70",
    // (undocumented)
    P80 = "P80"
}

// @public
export type PublicAccessType = 'container' | 'blob';

// @public
export interface Range {
    count?: number;
    offset: number;
}

// @public
export type RehydratePriority = 'High' | 'Standard';

export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

export { RestError }

// @public
export interface RetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: RetryPolicyType;
    readonly secondaryHost?: string;
    readonly tryTimeoutInMs?: number;
}

// @public
export class RetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: RetryOptions);
    // Warning: (ae-forgotten-export) The symbol "RetryPolicy" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): RetryPolicy;
    }

// @public
export enum RetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startTime?: Date, expiryTime?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string, userDelegationKey?: UserDelegationKey);
    readonly cacheControl?: string;
    readonly contentDisposition?: string;
    readonly contentEncoding?: string;
    readonly contentLanguage?: string;
    readonly contentType?: string;
    readonly expiryTime?: Date;
    readonly identifier?: string;
    readonly ipRange: SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startTime?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface SequenceNumberAccessConditions {
    ifSequenceNumberEqualTo?: number;
    ifSequenceNumberLessThan?: number;
    ifSequenceNumberLessThanOrEqualTo?: number;
}

// @public
export type SequenceNumberActionType = 'max' | 'update' | 'increment';

// @public
export interface ServiceGetAccountInfoOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ServiceGetAccountInfoHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceGetAccountInfoResponse = ServiceGetAccountInfoHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetAccountInfoHeaders;
    };
};

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ServiceGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceGetPropertiesResponse = BlobServiceProperties & ServiceGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetPropertiesHeaders;
        bodyAsText: string;
        parsedBody: BlobServiceProperties;
    };
};

// @public
export interface ServiceGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "BlobServiceStatistics" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ServiceGetStatisticsHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceGetStatisticsResponse = BlobServiceStatistics & ServiceGetStatisticsHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetStatisticsHeaders;
        bodyAsText: string;
        parsedBody: BlobServiceStatistics;
    };
};

// @public
export interface ServiceGetUserDelegationKeyHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetUserDelegationKeyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type ServiceGetUserDelegationKeyResponse = UserDelegationKey & ServiceGetUserDelegationKeyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ServiceGetUserDelegationKeyHeaders;
        bodyAsText: string;
        parsedBody: UserDelegationKeyModel;
    };
};

// @public
export interface ServiceListContainersOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeMetadata?: boolean;
    prefix?: string;
}

// Warning: (ae-forgotten-export) The symbol "ListContainersSegmentResponse" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ServiceListContainersSegmentHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceListContainersSegmentResponse = ListContainersSegmentResponse & ServiceListContainersSegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceListContainersSegmentHeaders;
        bodyAsText: string;
        parsedBody: ListContainersSegmentResponse;
    };
};

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ServiceSetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceSetPropertiesHeaders;
    };
};

// @public
export interface ServiceSubmitBatchHeaders {
    clientRequestId?: string;
    contentType?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSubmitBatchOptionalParamsModel extends coreHttp.RequestOptionsBase {
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export type ServiceSubmitBatchResponseModel = ServiceSubmitBatchHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceSubmitBatchHeaders;
    };
};

// @public
export class SharedKeyCredential extends Credential {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): SharedKeyCredentialPolicy;
}

// @public
export class SharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: SharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

// @public
export interface SignedIdentifier {
    accessPolicy: {
        start?: Date;
        expiry?: Date;
        permissions: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    // Warning: (ae-forgotten-export) The symbol "AccessPolicy" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    accessPolicy: AccessPolicy;
    id: string;
}

// @public (undocumented)
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    httpClient?: IHttpClient;
    // Warning: (ae-forgotten-export) The symbol "KeepAliveOptions" needs to be exported by the entry point index.d.ts
    keepAliveOptions?: KeepAliveOptions;
    logger?: IHttpPipelineLogger;
    // (undocumented)
    proxy?: ProxySettings | string;
    retryOptions?: RetryOptions;
    telemetry?: TelemetryOptions;
}

// @public
export interface TelemetryOptions {
    value: string;
}

// @public
export class TelemetryPolicyFactory implements RequestPolicyFactory {
    constructor(telemetry?: TelemetryOptions);
    // Warning: (ae-forgotten-export) The symbol "TelemetryPolicy" needs to be exported by the entry point index.d.ts
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): TelemetryPolicy;
    }

// @public
export class UniqueRequestIDPolicyFactory implements RequestPolicyFactory {
    // Warning: (ae-forgotten-export) The symbol "UniqueRequestIDPolicy" needs to be exported by the entry point index.d.ts
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): UniqueRequestIDPolicy;
}

// @public (undocumented)
export interface UserDelegationKey {
    signedExpiry: Date;
    signedObjectId: string;
    signedService: string;
    signedStart: Date;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}

// @public
export interface UserDelegationKeyModel {
    signedExpiry: string;
    signedObjectId: string;
    signedService: string;
    signedStart: string;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}

export { WebResource }


// (No @packageDocumentation comment for this package)

```
