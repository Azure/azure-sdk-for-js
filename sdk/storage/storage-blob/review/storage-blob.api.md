## API Report File for "@azure/storage-blob"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { deserializationPolicy } from '@azure/core-client';
import { HttpHeaders } from '@azure/core-https';
import { HttpsClient as IHttpClient } from '@azure/core-https';
import { OperationOptions } from '@azure/core-client';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { Pipeline as Pipeline_2 } from '@azure/core-https';
import { PipelinePolicy } from '@azure/core-https';
import { PipelineRequest } from '@azure/core-https';
import { PipelineResponse } from '@azure/core-https';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { ProxySettings } from '@azure/core-https';
import { RawResponseCallback } from '@azure/core-client';
import { Readable } from 'stream';
import { RequestBodyType } from '@azure/core-https';
import { RestError } from '@azure/core-https';
import { SendRequest } from '@azure/core-https';
import { ServiceClient } from '@azure/core-client';
import { ServiceClientOptions } from '@azure/core-client';
import { TokenCredential } from '@azure/core-auth';
import { TransferProgressEvent } from '@azure/core-https';
import { UserAgentPolicyOptions } from '@azure/core-https';

// @public
export interface AccessPolicy {
    expiresOn?: string;
    permissions?: string;
    startsOn?: string;
}

// @public
export type AccessTier = 'P4' | 'P6' | 'P10' | 'P15' | 'P20' | 'P30' | 'P40' | 'P50' | 'P60' | 'P70' | 'P80' | 'Hot' | 'Cool' | 'Archive';

// @public
export type AccountKind = 'Storage' | 'BlobStorage' | 'StorageV2' | 'FileStorage' | 'BlockBlobStorage';

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    deleteVersion: boolean;
    filter: boolean;
    static from(permissionLike: AccountSASPermissionsLike): AccountSASPermissions;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    tag: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export interface AccountSASPermissionsLike {
    add?: boolean;
    create?: boolean;
    delete?: boolean;
    deleteVersion?: boolean;
    filter?: boolean;
    list?: boolean;
    process?: boolean;
    read?: boolean;
    tag?: boolean;
    update?: boolean;
    write?: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential {
    // (undocumented)
    name: string;
    // (undocumented)
    signRequest(request: PipelineRequest): PipelineRequest;
}

// @public
export interface AppendBlobAppendBlockFromUrlHeaders {
    blobAppendOffset?: string;
    blobCommittedBlockCount?: number;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface AppendBlobAppendBlockFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    sourceConditions?: MatchConditions & ModificationConditions;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type AppendBlobAppendBlockFromUrlResponse = AppendBlobAppendBlockFromUrlHeaders;

// @public
export interface AppendBlobAppendBlockHeaders {
    blobAppendOffset?: string;
    blobCommittedBlockCount?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface AppendBlobAppendBlockOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type AppendBlobAppendBlockResponse = AppendBlobAppendBlockHeaders;

// @public
export class AppendBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    appendBlock(body: RequestBodyType, contentLength: number, options?: AppendBlobAppendBlockOptions): Promise<AppendBlobAppendBlockResponse>;
    appendBlockFromURL(sourceURL: string, sourceOffset: number, count: number, options?: AppendBlobAppendBlockFromURLOptions): Promise<AppendBlobAppendBlockFromUrlResponse>;
    create(options?: AppendBlobCreateOptions): Promise<AppendBlobCreateResponse>;
    createIfNotExists(options?: AppendBlobCreateIfNotExistsOptions): Promise<AppendBlobCreateIfNotExistsResponse>;
    seal(options?: AppendBlobSealOptions): Promise<AppendBlobAppendBlockResponse>;
    withSnapshot(snapshot: string): AppendBlobClient;
}

// @public
export interface AppendBlobCreateHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface AppendBlobCreateIfNotExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
}

// @public
export interface AppendBlobCreateIfNotExistsResponse extends AppendBlobCreateResponse {
    succeeded: boolean;
}

// @public
export interface AppendBlobCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
    tags?: Tags;
}

// @public
export type AppendBlobCreateResponse = AppendBlobCreateHeaders;

// @public
export interface AppendBlobRequestConditions extends BlobRequestConditions, AppendPositionAccessConditions {
}

// @public
export interface AppendBlobSealOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: AppendBlobRequestConditions;
}

// @public
export interface AppendPositionAccessConditions {
    appendPosition?: number;
    maxSize?: number;
}

// @public
export type ArchiveStatus = 'rehydrate-pending-to-hot' | 'rehydrate-pending-to-cool';

// @public
export interface BatchSubRequest {
    credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential;
    url: string;
}

// @public
export interface BatchSubResponse {
    bodyAsText?: string;
    errorCode?: string;
    headers: HttpHeaders;
    _request: BatchSubRequest;
    status: number;
    statusMessage: string;
}

// @public
export interface BlobAbortCopyFromURLHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobAbortCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type BlobAbortCopyFromURLResponse = BlobAbortCopyFromURLHeaders;

// @public
export interface BlobAcquireLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class BlobBatch {
    constructor();
    deleteBlob(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: BlobDeleteOptions): Promise<void>;
    deleteBlob(blobClient: BlobClient, options?: BlobDeleteOptions): Promise<void>;
    getHttpRequestBody(): string;
    getMultiPartContentType(): string;
    getSubRequests(): Map<number, BatchSubRequest>;
    setBlobAccessTier(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, tier: AccessTier, options?: BlobSetTierOptions): Promise<void>;
    setBlobAccessTier(blobClient: BlobClient, tier: AccessTier, options?: BlobSetTierOptions): Promise<void>;
}

// @public
export class BlobBatchClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createBatch(): BlobBatch;
    deleteBlobs(urls: string[], credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: BlobDeleteOptions): Promise<BlobBatchDeleteBlobsResponse>;
    deleteBlobs(blobClients: BlobClient[], options?: BlobDeleteOptions): Promise<BlobBatchDeleteBlobsResponse>;
    setBlobsAccessTier(urls: string[], credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, tier: AccessTier, options?: BlobSetTierOptions): Promise<BlobBatchSetBlobsAccessTierResponse>;
    setBlobsAccessTier(blobClients: BlobClient[], tier: AccessTier, options?: BlobSetTierOptions): Promise<BlobBatchSetBlobsAccessTierResponse>;
    submitBatch(batchRequest: BlobBatch, options?: BlobBatchSubmitBatchOptionalParams): Promise<BlobBatchSubmitBatchResponse>;
}

// @public
export type BlobBatchDeleteBlobsResponse = BlobBatchSubmitBatchResponse;

// @public
export type BlobBatchSetBlobsAccessTierResponse = BlobBatchSubmitBatchResponse;

// @public
export interface BlobBatchSubmitBatchOptionalParams extends ServiceSubmitBatchOptionalParamsModel, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type BlobBatchSubmitBatchResponse = ParsedBatchResponse & ServiceSubmitBatchHeaders;

// @public
export interface BlobBeginCopyFromURLOptions extends BlobStartCopyFromURLOptions {
    intervalInMs?: number;
    onProgress?: (state: BlobBeginCopyFromUrlPollState) => void;
    resumeFrom?: string;
}

// @public
export interface BlobBeginCopyFromUrlPollState extends PollOperationState<BlobBeginCopyFromURLResponse> {
    readonly blobClient: CopyPollerBlobClient;
    copyId?: string;
    copyProgress?: string;
    copySource: string;
    readonly startCopyFromURLOptions?: BlobStartCopyFromURLOptions;
}

// @public
export interface BlobBeginCopyFromURLResponse extends BlobStartCopyFromURLResponse {
}

// @public
export interface BlobBreakLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobChangeLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class BlobClient extends StorageClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    abortCopyFromURL(copyId: string, options?: BlobAbortCopyFromURLOptions): Promise<BlobAbortCopyFromURLResponse>;
    beginCopyFromURL(copySource: string, options?: BlobBeginCopyFromURLOptions): Promise<PollerLike<PollOperationState<BlobBeginCopyFromURLResponse>, BlobBeginCopyFromURLResponse>>;
    get containerName(): string;
    createSnapshot(options?: BlobCreateSnapshotOptions): Promise<BlobCreateSnapshotResponse>;
    delete(options?: BlobDeleteOptions): Promise<BlobDeleteResponse>;
    deleteIfExists(options?: BlobDeleteOptions): Promise<BlobDeleteIfExistsResponse>;
    download(offset?: number, count?: number, options?: BlobDownloadOptions): Promise<BlobDownloadResponseParsed>;
    downloadToBuffer(offset?: number, count?: number, options?: BlobDownloadToBufferOptions): Promise<Buffer>;
    downloadToBuffer(buffer: Buffer, offset?: number, count?: number, options?: BlobDownloadToBufferOptions): Promise<Buffer>;
    downloadToFile(filePath: string, offset?: number, count?: number, options?: BlobDownloadOptions): Promise<BlobDownloadResponseParsed>;
    exists(options?: BlobExistsOptions): Promise<boolean>;
    generateSasUrl(options: BlobGenerateSasUrlOptions): Promise<string>;
    getAppendBlobClient(): AppendBlobClient;
    getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient;
    getBlockBlobClient(): BlockBlobClient;
    getPageBlobClient(): PageBlobClient;
    getProperties(options?: BlobGetPropertiesOptions): Promise<BlobGetPropertiesResponse>;
    getTags(options?: BlobGetTagsOptions): Promise<BlobGetTagsResponse>;
    get name(): string;
    setAccessTier(tier: BlockBlobTier | PremiumPageBlobTier | string, options?: BlobSetTierOptions): Promise<BlobSetTierResponse>;
    setHTTPHeaders(blobHTTPHeaders?: BlobHTTPHeaders, options?: BlobSetHTTPHeadersOptions): Promise<BlobSetHTTPHeadersResponse>;
    setMetadata(metadata?: Metadata, options?: BlobSetMetadataOptions): Promise<BlobSetMetadataResponse>;
    setTags(tags: Tags, options?: BlobSetTagsOptions): Promise<BlobSetTagsResponse>;
    syncCopyFromURL(copySource: string, options?: BlobSyncCopyFromURLOptions): Promise<BlobCopyFromURLResponse>;
    undelete(options?: BlobUndeleteOptions): Promise<BlobUndeleteResponse>;
    withSnapshot(snapshot: string): BlobClient;
    withVersion(versionId: string): BlobClient;
}

// @public
export interface BlobCopyFromURLHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    copyId?: string;
    copyStatus?: SyncCopyStatusType;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export type BlobCopyFromURLResponse = BlobCopyFromURLHeaders;

// @public
export interface BlobCreateSnapshotHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    snapshot?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobCreateSnapshotOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
}

// @public
export type BlobCreateSnapshotResponse = BlobCreateSnapshotHeaders;

// @public
export interface BlobDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobDeleteIfExistsResponse extends BlobDeleteResponse {
    succeeded: boolean;
}

// @public
export interface BlobDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    deleteSnapshots?: DeleteSnapshotsOptionType;
}

// @public
export type BlobDeleteResponse = BlobDeleteHeaders;

// @public
export interface BlobDownloadHeaders {
    acceptRanges?: string;
    blobCommittedBlockCount?: number;
    blobContentMD5?: Uint8Array;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentCrc64?: Uint8Array;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentRange?: string;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isCurrentVersion?: boolean;
    isSealed?: boolean;
    isServerEncrypted?: boolean;
    lastAccessed?: Date;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    objectReplicationPolicyId?: string;
    // (undocumented)
    objectReplicationRules?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    tagCount?: number;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobDownloadOptionalParams extends OperationOptions {
    cpkInfo?: CpkInfo;
    leaseAccessConditions?: LeaseAccessConditions;
    modifiedAccessConditions?: ModifiedAccessConditionsModel;
    range?: string;
    rangeGetContentCRC64?: boolean;
    rangeGetContentMD5?: boolean;
    requestId?: string;
    snapshot?: string;
    timeoutInSeconds?: number;
    versionId?: string;
}

// @public
export interface BlobDownloadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    maxRetryRequests?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
    rangeGetContentCrc64?: boolean;
    rangeGetContentMD5?: boolean;
    snapshot?: string;
}

// @public
export type BlobDownloadResponseModel = BlobDownloadHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
};

// @public
export interface BlobDownloadResponseParsed extends BlobDownloadResponseModel {
    objectReplicationDestinationPolicyId?: string;
    objectReplicationSourceProperties?: ObjectReplicationPolicy[];
}

// @public
export interface BlobDownloadToBufferOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blockSize?: number;
    concurrency?: number;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    maxRetryRequestsPerBlock?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export interface BlobExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export interface BlobFlatListSegment {
    // (undocumented)
    blobItems: BlobItem[];
}

// @public
export interface BlobFlatListSegmentModel {
    // (undocumented)
    blobItems: BlobItemInternal[];
}

// @public
export interface BlobGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: BlobSASPermissions;
}

// @public
export interface BlobGetPropertiesHeaders {
    acceptRanges?: string;
    accessTier?: string;
    accessTierChangedOn?: Date;
    accessTierInferred?: boolean;
    archiveStatus?: string;
    blobCommittedBlockCount?: number;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentType?: string;
    copyCompletedOn?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    createdOn?: Date;
    date?: Date;
    destinationSnapshot?: string;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    expiresOn?: Date;
    isCurrentVersion?: boolean;
    isIncrementalCopy?: boolean;
    isSealed?: boolean;
    isServerEncrypted?: boolean;
    lastAccessed?: Date;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    objectReplicationPolicyId?: string;
    // (undocumented)
    objectReplicationRules?: {
        [propertyName: string]: string;
    };
    rehydratePriority?: RehydratePriority;
    requestId?: string;
    tagCount?: number;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export interface BlobGetPropertiesResponse extends BlobGetPropertiesResponseModel {
    objectReplicationDestinationPolicyId?: string;
    objectReplicationSourceProperties?: ObjectReplicationPolicy[];
}

// @public
export type BlobGetPropertiesResponseModel = BlobGetPropertiesHeaders;

// @public
export interface BlobGetTagsHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobGetTagsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: TagConditions & LeaseAccessConditions;
}

// @public
export type BlobGetTagsResponse = {
    tags: Tags;
} & BlobGetTagsHeaders;

// @public
export interface BlobHierarchyListSegment {
    // (undocumented)
    blobItems: BlobItem[];
    // (undocumented)
    blobPrefixes?: BlobPrefix[];
}

// @public
export interface BlobHierarchyListSegmentModel {
    // (undocumented)
    blobItems: BlobItemInternal[];
    // (undocumented)
    blobPrefixes?: BlobPrefix[];
}

// @public
export interface BlobHTTPHeaders {
    blobCacheControl?: string;
    blobContentDisposition?: string;
    blobContentEncoding?: string;
    blobContentLanguage?: string;
    blobContentMD5?: Uint8Array;
    blobContentType?: string;
}

// @public
export interface BlobItem {
    // (undocumented)
    deleted: boolean;
    // (undocumented)
    isCurrentVersion?: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    objectReplicationSourceProperties?: ObjectReplicationPolicy[];
    // (undocumented)
    properties: BlobProperties;
    // (undocumented)
    snapshot: string;
    // (undocumented)
    tags?: Tags;
    // (undocumented)
    versionId?: string;
}

// @public
export interface BlobItemInternal {
    // (undocumented)
    blobTags?: BlobTags;
    // (undocumented)
    deleted: boolean;
    // (undocumented)
    isCurrentVersion?: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    objectReplicationMetadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    properties: BlobProperties;
    // (undocumented)
    snapshot: string;
    // (undocumented)
    versionId?: string;
}

// @public
export class BlobLeaseClient {
    constructor(client: ContainerClient | BlobClient, leaseId?: string);
    acquireLease(duration: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    breakLease(breakPeriod: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    get leaseId(): string;
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    renewLease(options?: LeaseOperationOptions): Promise<Lease>;
    get url(): string;
    }

// @public
export interface BlobPrefix {
    // (undocumented)
    name: string;
}

// @public
export interface BlobProperties {
    accessTier?: AccessTier;
    // (undocumented)
    accessTierChangedOn?: Date;
    // (undocumented)
    accessTierInferred?: boolean;
    archiveStatus?: ArchiveStatus;
    // (undocumented)
    blobSequenceNumber?: number;
    blobType?: BlobType;
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    contentLength?: number;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    copyCompletedOn?: Date;
    // (undocumented)
    copyId?: string;
    // (undocumented)
    copyProgress?: string;
    // (undocumented)
    copySource?: string;
    copyStatus?: CopyStatusType;
    // (undocumented)
    copyStatusDescription?: string;
    // (undocumented)
    createdOn?: Date;
    // (undocumented)
    customerProvidedKeySha256?: string;
    // (undocumented)
    deletedOn?: Date;
    // (undocumented)
    destinationSnapshot?: string;
    encryptionScope?: string;
    // (undocumented)
    etag: string;
    // (undocumented)
    expiresOn?: Date;
    // (undocumented)
    incrementalCopy?: boolean;
    // (undocumented)
    isSealed?: boolean;
    // (undocumented)
    lastAccessedOn?: Date;
    // (undocumented)
    lastModified: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    rehydratePriority?: RehydratePriority;
    // (undocumented)
    remainingRetentionDays?: number;
    // (undocumented)
    serverEncrypted?: boolean;
    // (undocumented)
    tagCount?: number;
}

// @public
export interface BlobQueryArrowConfiguration {
    kind: "arrow";
    schema: BlobQueryArrowField[];
}

// @public
export interface BlobQueryArrowField {
    name?: string;
    precision?: number;
    scale?: number;
    type: BlobQueryArrowFieldType;
}

// @public
export type BlobQueryArrowFieldType = "int64" | "bool" | "timestamp[ms]" | "string" | "double" | "decimal";

// @public
export interface BlobQueryCsvTextConfiguration {
    columnSeparator?: string;
    escapeCharacter?: string;
    fieldQuote?: string;
    hasHeaders?: boolean;
    kind: "csv";
    recordSeparator: string;
}

// @public
export interface BlobQueryError {
    description: string;
    isFatal: boolean;
    name: string;
    position: number;
}

// @public
export interface BlobQueryHeaders {
    acceptRanges?: string;
    blobCommittedBlockCount?: number;
    blobContentMD5?: Uint8Array;
    blobSequenceNumber?: number;
    blobType?: BlobType;
    cacheControl?: string;
    clientRequestId?: string;
    contentCrc64?: Uint8Array;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: Uint8Array;
    contentRange?: string;
    contentType?: string;
    copyCompletionTime?: Date;
    copyId?: string;
    copyProgress?: string;
    copySource?: string;
    copyStatus?: CopyStatusType;
    copyStatusDescription?: string;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface BlobQueryJsonTextConfiguration {
    kind: "json";
    recordSeparator: string;
}

// @public
export type BlobQueryResponseModel = BlobQueryHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
};

// @public
export interface BlobReleaseLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobRenewLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface BlobRequestConditions extends ModifiedAccessConditions, LeaseAccessConditions {
}

// @public
export class BlobSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    deleteVersion: boolean;
    execute: boolean;
    static from(permissionLike: BlobSASPermissionsLike): BlobSASPermissions;
    move: boolean;
    static parse(permissions: string): BlobSASPermissions;
    read: boolean;
    tag: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface BlobSASPermissionsLike {
    add?: boolean;
    create?: boolean;
    delete?: boolean;
    deleteVersion?: boolean;
    execute?: boolean;
    move?: boolean;
    read?: boolean;
    tag?: boolean;
    write?: boolean;
}

// @public
export interface BlobSASSignatureValues {
    blobName?: string;
    cacheControl?: string;
    containerName: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    correlationId?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: BlobSASPermissions | ContainerSASPermissions;
    preauthorizedAgentObjectId?: string;
    protocol?: SASProtocol;
    snapshotTime?: string;
    startsOn?: Date;
    version?: string;
    versionId?: string;
}

// @public
export class BlobServiceClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createContainer(containerName: string, options?: ContainerCreateOptions): Promise<{
        containerClient: ContainerClient;
        containerCreateResponse: ContainerCreateResponse;
    }>;
    deleteContainer(containerName: string, options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteResponse>;
    findBlobsByTags(tagFilterSqlExpression: string, options?: ServiceFindBlobByTagsOptions): PagedAsyncIterableIterator<FilterBlobItem, ServiceFindBlobsByTagsSegmentResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): BlobServiceClient;
    generateAccountSasUrl(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
    getAccountInfo(options?: ServiceGetAccountInfoOptions): Promise<ServiceGetAccountInfoResponse>;
    getBlobBatchClient(): BlobBatchClient;
    getContainerClient(containerName: string): ContainerClient;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getStatistics(options?: ServiceGetStatisticsOptions): Promise<ServiceGetStatisticsResponse>;
    getUserDelegationKey(startsOn: Date, expiresOn: Date, options?: ServiceGetUserDelegationKeyOptions): Promise<ServiceGetUserDelegationKeyResponse>;
    listContainers(options?: ServiceListContainersOptions): PagedAsyncIterableIterator<ContainerItem, ServiceListContainersSegmentResponse>;
    setProperties(properties: BlobServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
    undeleteContainer(deletedContainerName: string, deletedContainerVersion: string, options?: ServiceUndeleteContainerOptions): Promise<{
        containerClient: ContainerClient;
        containerUndeleteResponse: ContainerUndeleteResponse;
    }>;
}

// @public
export interface BlobServiceProperties {
    // (undocumented)
    blobAnalyticsLogging?: Logging;
    cors?: CorsRule[];
    defaultServiceVersion?: string;
    // (undocumented)
    deleteRetentionPolicy?: RetentionPolicy;
    // (undocumented)
    hourMetrics?: Metrics;
    // (undocumented)
    minuteMetrics?: Metrics;
    // (undocumented)
    staticWebsite?: StaticWebsite;
}

// @public
export interface BlobServiceStatistics {
    // (undocumented)
    geoReplication?: GeoReplication;
}

// @public
export interface BlobSetHTTPHeadersHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetHTTPHeadersOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public
export type BlobSetHTTPHeadersResponse = BlobSetHTTPHeadersHeaders;

// @public
export interface BlobSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
}

// @public
export type BlobSetMetadataResponse = BlobSetMetadataHeaders;

// @public
export interface BlobSetTagsHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetTagsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: TagConditions & LeaseAccessConditions;
}

// @public
export type BlobSetTagsResponse = BlobSetTagsHeaders;

// @public
export interface BlobSetTierHeaders {
    clientRequestId?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobSetTierOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions & TagConditions;
    rehydratePriority?: RehydratePriority;
}

// @public
export type BlobSetTierResponse = BlobSetTierHeaders;

// @public
export interface BlobStartCopyFromURLHeaders {
    clientRequestId?: string;
    copyId?: string;
    copyStatus?: CopyStatusType;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface BlobStartCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    metadata?: Metadata;
    rehydratePriority?: RehydratePriority;
    sealBlob?: boolean;
    sourceConditions?: ModifiedAccessConditions;
    tags?: Tags;
    tier?: BlockBlobTier | PremiumPageBlobTier | string;
}

// @public
export type BlobStartCopyFromURLResponse = BlobStartCopyFromURLHeaders;

// @public
export interface BlobSyncCopyFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    metadata?: Metadata;
    sourceConditions?: MatchConditions & ModificationConditions;
    sourceContentMD5?: Uint8Array;
    tags?: Tags;
}

// @public
export interface BlobTag {
    // (undocumented)
    key: string;
    // (undocumented)
    value: string;
}

// @public
export interface BlobTags {
    // (undocumented)
    blobTagSet: BlobTag[];
}

// @public
export type BlobType = 'BlockBlob' | 'PageBlob' | 'AppendBlob';

// @public
export interface BlobUndeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface BlobUndeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    customerProvidedKey?: CpkInfo;
}

// @public
export type BlobUndeleteResponse = BlobUndeleteHeaders;

// @public
export type BlobUploadCommonResponse = BlockBlobUploadHeaders;

// @public
export interface Block {
    name: string;
    size: number;
}

// @public
export class BlockBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    commitBlockList(blocks: string[], options?: BlockBlobCommitBlockListOptions): Promise<BlockBlobCommitBlockListResponse>;
    getBlockList(listType: BlockListType, options?: BlockBlobGetBlockListOptions): Promise<BlockBlobGetBlockListResponse>;
    query(query: string, options?: BlockBlobQueryOptions): Promise<BlobDownloadResponseModel>;
    stageBlock(blockId: string, body: RequestBodyType, contentLength: number, options?: BlockBlobStageBlockOptions): Promise<BlockBlobStageBlockResponse>;
    stageBlockFromURL(blockId: string, sourceURL: string, offset?: number, count?: number, options?: BlockBlobStageBlockFromURLOptions): Promise<BlockBlobStageBlockFromURLResponse>;
    syncUploadFromURL(sourceURL: string, options?: BlockBlobSyncUploadFromURLOptions): Promise<BlockBlobPutBlobFromUrlResponse>;
    upload(body: RequestBodyType, contentLength: number, options?: BlockBlobUploadOptions): Promise<BlockBlobUploadResponse>;
    // @deprecated
    uploadBrowserData(browserData: Blob | ArrayBuffer | ArrayBufferView, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadData(data: Buffer | Blob | ArrayBuffer | ArrayBufferView, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadFile(filePath: string, options?: BlockBlobParallelUploadOptions): Promise<BlobUploadCommonResponse>;
    uploadStream(stream: Readable, bufferSize?: number, maxConcurrency?: number, options?: BlockBlobUploadStreamOptions): Promise<BlobUploadCommonResponse>;
    withSnapshot(snapshot: string): BlockBlobClient;
}

// @public
export interface BlockBlobCommitBlockListHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobCommitBlockListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
    tags?: Tags;
    tier?: BlockBlobTier | string;
}

// @public
export type BlockBlobCommitBlockListResponse = BlockBlobCommitBlockListHeaders;

// @public
export interface BlockBlobGetBlockListHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface BlockBlobGetBlockListOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions & TagConditions;
}

// @public
export type BlockBlobGetBlockListResponse = BlockList & BlockBlobGetBlockListHeaders;

// @public
export interface BlockBlobParallelUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blockSize?: number;
    concurrency?: number;
    conditions?: BlobRequestConditions;
    encryptionScope?: string;
    maxSingleShotSize?: number;
    metadata?: {
        [propertyName: string]: string;
    };
    onProgress?: (progress: TransferProgressEvent) => void;
    tags?: Tags;
    tier?: BlockBlobTier | string;
}

// @public
export interface BlockBlobPutBlobFromUrlHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export type BlockBlobPutBlobFromUrlResponse = BlockBlobPutBlobFromUrlHeaders;

// @public
export interface BlockBlobQueryOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    inputTextConfiguration?: BlobQueryJsonTextConfiguration | BlobQueryCsvTextConfiguration;
    onError?: (error: BlobQueryError) => void;
    onProgress?: (progress: TransferProgressEvent) => void;
    outputTextConfiguration?: BlobQueryJsonTextConfiguration | BlobQueryCsvTextConfiguration | BlobQueryArrowConfiguration;
}

// @public
export interface BlockBlobStageBlockFromURLHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    isServerEncrypted?: boolean;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobStageBlockFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    range?: Range;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type BlockBlobStageBlockFromURLResponse = BlockBlobStageBlockFromURLHeaders;

// @public
export interface BlockBlobStageBlockHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    isServerEncrypted?: boolean;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface BlockBlobStageBlockOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type BlockBlobStageBlockResponse = BlockBlobStageBlockHeaders;

// @public
export interface BlockBlobSyncUploadFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    copySourceBlobProperties?: boolean;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
    sourceConditions?: ModifiedAccessConditions;
    sourceContentMD5?: Uint8Array;
    tags?: Tags;
    tier?: BlockBlobTier | string;
    timeoutInSeconds?: number;
}

// @public
export enum BlockBlobTier {
    Archive = "Archive",
    Cool = "Cool",
    Hot = "Hot"
}

// @public
export interface BlockBlobUploadHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface BlockBlobUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
    tags?: Tags;
    tier?: BlockBlobTier | string;
}

// @public
export type BlockBlobUploadResponse = BlockBlobUploadHeaders;

// @public
export interface BlockBlobUploadStreamOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    conditions?: BlobRequestConditions;
    encryptionScope?: string;
    metadata?: {
        [propertyName: string]: string;
    };
    onProgress?: (progress: TransferProgressEvent) => void;
    tags?: Tags;
    tier?: BlockBlobTier | string;
}

// @public
export interface BlockList {
    // (undocumented)
    committedBlocks?: Block[];
    // (undocumented)
    uncommittedBlocks?: Block[];
}

// @public
export type BlockListType = 'committed' | 'uncommitted' | 'all';

// @public
export interface CommonGenerateSasUrlOptions {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface CommonOptions {
    onResponse?: RawResponseCallback;
    tracingOptions?: OperationTracingOptions;
}

// @public
export interface ContainerAcquireLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerBreakLeaseOptionalParams extends OperationOptions {
    breakPeriod?: number;
    modifiedAccessConditions?: ModifiedAccessConditionsModel;
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export interface ContainerBreakLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerChangeLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export class ContainerClient extends StorageClient {
    constructor(connectionString: string, containerName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    get containerName(): string;
    create(options?: ContainerCreateOptions): Promise<ContainerCreateResponse>;
    createIfNotExists(options?: ContainerCreateOptions): Promise<ContainerCreateIfNotExistsResponse>;
    delete(options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteResponse>;
    deleteBlob(blobName: string, options?: ContainerDeleteBlobOptions): Promise<BlobDeleteResponse>;
    deleteIfExists(options?: ContainerDeleteMethodOptions): Promise<ContainerDeleteIfExistsResponse>;
    exists(options?: ContainerExistsOptions): Promise<boolean>;
    generateSasUrl(options: ContainerGenerateSasUrlOptions): Promise<string>;
    getAccessPolicy(options?: ContainerGetAccessPolicyOptions): Promise<ContainerGetAccessPolicyResponse>;
    getAppendBlobClient(blobName: string): AppendBlobClient;
    getBlobBatchClient(): BlobBatchClient;
    getBlobClient(blobName: string): BlobClient;
    getBlobLeaseClient(proposeLeaseId?: string): BlobLeaseClient;
    getBlockBlobClient(blobName: string): BlockBlobClient;
    getPageBlobClient(blobName: string): PageBlobClient;
    getProperties(options?: ContainerGetPropertiesOptions): Promise<ContainerGetPropertiesResponse>;
    listBlobsByHierarchy(delimiter: string, options?: ContainerListBlobsOptions): PagedAsyncIterableIterator<({
        kind: "prefix";
    } & BlobPrefix) | ({
        kind: "blob";
    } & BlobItem), ContainerListBlobHierarchySegmentResponse>;
    listBlobsFlat(options?: ContainerListBlobsOptions): PagedAsyncIterableIterator<BlobItem, ContainerListBlobFlatSegmentResponse>;
    setAccessPolicy(access?: PublicAccessType, containerAcl?: SignedIdentifier[], options?: ContainerSetAccessPolicyOptions): Promise<ContainerSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: ContainerSetMetadataOptions): Promise<ContainerSetMetadataResponse>;
    uploadBlockBlob(blobName: string, body: RequestBodyType, contentLength: number, options?: BlockBlobUploadOptions): Promise<{
        blockBlobClient: BlockBlobClient;
        response: BlockBlobUploadResponse;
    }>;
}

// @public
export interface ContainerCreateHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerCreateIfNotExistsResponse extends ContainerCreateResponse {
    succeeded: boolean;
}

// @public
export interface ContainerCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    access?: PublicAccessType;
    containerEncryptionScope?: ContainerEncryptionScope;
    metadata?: Metadata;
}

// @public
export type ContainerCreateResponse = ContainerCreateHeaders;

// @public
export interface ContainerDeleteBlobOptions extends BlobDeleteOptions {
    versionId?: string;
}

// @public
export interface ContainerDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerDeleteIfExistsResponse extends ContainerDeleteResponse {
    succeeded: boolean;
}

// @public
export interface ContainerDeleteMethodOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ContainerRequestConditions;
}

// @public
export type ContainerDeleteResponse = ContainerDeleteHeaders;

// @public
export interface ContainerEncryptionScope {
    defaultEncryptionScope?: string;
    preventEncryptionScopeOverride?: boolean;
}

// @public
export interface ContainerExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface ContainerGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: ContainerSASPermissions;
}

// @public
export interface ContainerGetAccessPolicyHeaders {
    blobPublicAccess?: PublicAccessType;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type ContainerGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifier[];
} & ContainerGetAccessPolicyHeaders;

// @public
export interface ContainerGetPropertiesHeaders {
    blobPublicAccess?: PublicAccessType;
    clientRequestId?: string;
    date?: Date;
    defaultEncryptionScope?: string;
    denyEncryptionScopeOverride?: boolean;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    hasImmutabilityPolicy?: boolean;
    hasLegalHold?: boolean;
    lastModified?: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: LeaseAccessConditions;
}

// @public
export type ContainerGetPropertiesResponse = ContainerGetPropertiesHeaders;

// @public
export interface ContainerItem {
    // (undocumented)
    deleted?: boolean;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    properties: ContainerProperties;
    // (undocumented)
    version?: string;
}

// @public
export interface ContainerListBlobFlatSegmentHeaders {
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerListBlobFlatSegmentResponse = ListBlobsFlatSegmentResponse & ContainerListBlobFlatSegmentHeaders;

// @public
export interface ContainerListBlobHierarchySegmentHeaders {
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerListBlobHierarchySegmentResponse = ListBlobsHierarchySegmentResponse & ContainerListBlobHierarchySegmentHeaders;

// @public
export interface ContainerListBlobsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeCopy?: boolean;
    includeDeleted?: boolean;
    includeMetadata?: boolean;
    includeSnapshots?: boolean;
    includeTags?: boolean;
    includeUncommitedBlobs?: boolean;
    includeVersions?: boolean;
    prefix?: string;
}

// @public
export interface ContainerProperties {
    // (undocumented)
    defaultEncryptionScope?: string;
    // (undocumented)
    deletedOn?: Date;
    // (undocumented)
    etag: string;
    // (undocumented)
    hasImmutabilityPolicy?: boolean;
    // (undocumented)
    hasLegalHold?: boolean;
    // (undocumented)
    lastModified: Date;
    leaseDuration?: LeaseDurationType;
    leaseState?: LeaseStateType;
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    preventEncryptionScopeOverride?: boolean;
    publicAccess?: PublicAccessType;
    // (undocumented)
    remainingRetentionDays?: number;
}

// @public
export interface ContainerReleaseLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerRenameHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerRenameResponse = ContainerRenameHeaders;

// @public
export interface ContainerRenewLeaseOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface ContainerRequestConditions extends LeaseAccessConditions, ModificationConditions {
}

// @public
export class ContainerSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    deleteVersion: boolean;
    execute: boolean;
    static from(permissionLike: ContainerSASPermissionsLike): ContainerSASPermissions;
    list: boolean;
    move: boolean;
    static parse(permissions: string): ContainerSASPermissions;
    read: boolean;
    tag: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface ContainerSASPermissionsLike {
    add?: boolean;
    create?: boolean;
    delete?: boolean;
    deleteVersion?: boolean;
    execute?: boolean;
    list?: boolean;
    move?: boolean;
    read?: boolean;
    tag?: boolean;
    write?: boolean;
}

// @public
export interface ContainerSetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ContainerRequestConditions;
}

// @public
export type ContainerSetAccessPolicyResponse = ContainerSetAccessPolicyHeaders;

// @public
export interface ContainerSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ContainerSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ContainerRequestConditions;
}

// @public
export type ContainerSetMetadataResponse = ContainerSetMetadataHeaders;

// @public
export interface ContainerUndeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ContainerUndeleteResponse = ContainerUndeleteHeaders;

// @public
export type CopyPollerBlobClient = Pick<BlobClient, "abortCopyFromURL" | "getProperties"> & {
    startCopyFromURL(copySource: string, options?: BlobStartCopyFromURLOptions): Promise<BlobBeginCopyFromURLResponse>;
};

// @public
export type CopyStatusType = 'pending' | 'success' | 'aborted' | 'failed';

// @public
export interface CorsRule {
    allowedHeaders: string;
    allowedMethods: string;
    allowedOrigins: string;
    exposedHeaders: string;
    maxAgeInSeconds: number;
}

// @public
export interface CpkInfo {
    encryptionAlgorithm?: EncryptionAlgorithmType;
    encryptionKey?: string;
    encryptionKeySha256?: string;
}

// @public
export abstract class Credential implements PipelinePolicy {
    // (undocumented)
    abstract name: string;
    // (undocumented)
    sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;
    // (undocumented)
    protected abstract signRequest(request: PipelineRequest): PipelineRequest;
}

// @public
export type DeleteSnapshotsOptionType = 'include' | 'only';

export { deserializationPolicy }

// @public
export type EncryptionAlgorithmType = 'AES256';

// @public
export interface FilterBlobItem {
    containerName: string;
    name: string;
    tags?: Tags;
    // @deprecated
    tagValue: string;
}

// @public
export interface FilterBlobItemModel {
    // (undocumented)
    containerName: string;
    // (undocumented)
    name: string;
    // (undocumented)
    tags?: BlobTags;
}

// @public
export interface FilterBlobSegment {
    // (undocumented)
    blobs: FilterBlobItem[];
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    serviceEndpoint: string;
    // (undocumented)
    where: string;
}

// @public
export interface FilterBlobSegmentModel {
    // (undocumented)
    blobs: FilterBlobItemModel[];
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    serviceEndpoint: string;
    // (undocumented)
    where: string;
}

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateBlobSASQueryParameters(blobSASSignatureValues: BlobSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateBlobSASQueryParameters(blobSASSignatureValues: BlobSASSignatureValues, userDelegationKey: UserDelegationKey, accountName: string): SASQueryParameters;

// @public
export interface GeoReplication {
    lastSyncOn: Date;
    status: GeoReplicationStatusType;
}

// @public
export type GeoReplicationStatusType = 'live' | 'bootstrap' | 'unavailable';

export { HttpHeaders }

export { IHttpClient }

// @public
export interface Lease {
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    leaseId?: string;
    leaseTime?: number;
    requestId?: string;
    version?: string;
}

// @public
export interface LeaseAccessConditions {
    leaseId?: string;
}

// @public
export type LeaseDurationType = 'infinite' | 'fixed';

// @public
export interface LeaseOperationOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export type LeaseOperationResponse = Lease;

// @public
export type LeaseStateType = 'available' | 'leased' | 'expired' | 'breaking' | 'broken';

// @public
export type LeaseStatusType = 'locked' | 'unlocked';

// @public
export interface ListBlobsFlatSegmentResponse {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobFlatListSegment;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export interface ListBlobsFlatSegmentResponseModel {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobFlatListSegmentModel;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export interface ListBlobsHierarchySegmentResponse {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobHierarchyListSegment;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export interface ListBlobsHierarchySegmentResponseModel {
    // (undocumented)
    containerName: string;
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobHierarchyListSegmentModel;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export type ListBlobsIncludeItem = 'copy' | 'deleted' | 'metadata' | 'snapshots' | 'uncommittedblobs' | 'versions' | 'tags';

// @public
export type ListContainersIncludeType = 'metadata' | 'deleted';

// @public
export interface ListContainersSegmentResponse {
    // (undocumented)
    containerItems: ContainerItem[];
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export const logger: import("@azure/logger").AzureLogger;

// @public
export interface Logging {
    deleteProperty: boolean;
    read: boolean;
    // (undocumented)
    retentionPolicy: RetentionPolicy;
    version: string;
    write: boolean;
}

// @public
export interface MatchConditions {
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface Metadata {
    [propertyName: string]: string;
}

// @public
export interface Metrics {
    enabled: boolean;
    includeAPIs?: boolean;
    // (undocumented)
    retentionPolicy?: RetentionPolicy;
    version?: string;
}

// @public
export interface ModificationConditions {
    ifModifiedSince?: Date;
    ifUnmodifiedSince?: Date;
}

// @public
export interface ModifiedAccessConditions extends MatchConditions, ModificationConditions, TagConditions {
}

// @public
export interface ModifiedAccessConditionsModel {
    ifMatch?: string;
    ifModifiedSince?: Date;
    ifNoneMatch?: string;
    ifTags?: string;
    ifUnmodifiedSince?: Date;
}

// @public
export function newPipeline(credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export interface ObjectReplicationPolicy {
    policyId: string;
    rules: ObjectReplicationRule[];
}

// @public
export interface ObjectReplicationRule {
    replicationStatus: ObjectReplicationStatus;
    ruleId: string;
}

// @public
export type ObjectReplicationStatus = "complete" | "failed";

// @public
export interface PageBlobClearPagesHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobClearPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
}

// @public
export type PageBlobClearPagesResponse = PageBlobClearPagesHeaders;

// @public
export class PageBlobClient extends BlobClient {
    constructor(connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    clearPages(offset?: number, count?: number, options?: PageBlobClearPagesOptions): Promise<PageBlobClearPagesResponse>;
    create(size: number, options?: PageBlobCreateOptions): Promise<PageBlobCreateResponse>;
    createIfNotExists(size: number, options?: PageBlobCreateIfNotExistsOptions): Promise<PageBlobCreateIfNotExistsResponse>;
    getPageRanges(offset?: number, count?: number, options?: PageBlobGetPageRangesOptions): Promise<PageBlobGetPageRangesResponse>;
    getPageRangesDiff(offset: number, count: number, prevSnapshot: string, options?: PageBlobGetPageRangesDiffOptions): Promise<PageBlobGetPageRangesDiffResponse>;
    getPageRangesDiffForManagedDisks(offset: number, count: number, prevSnapshotUrl: string, options?: PageBlobGetPageRangesDiffOptions): Promise<PageBlobGetPageRangesDiffResponse>;
    resize(size: number, options?: PageBlobResizeOptions): Promise<PageBlobResizeResponse>;
    startCopyIncremental(copySource: string, options?: PageBlobStartCopyIncrementalOptions): Promise<PageBlobCopyIncrementalResponse>;
    updateSequenceNumber(sequenceNumberAction: SequenceNumberActionType, sequenceNumber?: number, options?: PageBlobUpdateSequenceNumberOptions): Promise<PageBlobUpdateSequenceNumberResponse>;
    uploadPages(body: RequestBodyType, offset: number, count: number, options?: PageBlobUploadPagesOptions): Promise<PageBlobUploadPagesResponse>;
    uploadPagesFromURL(sourceURL: string, sourceOffset: number, destOffset: number, count: number, options?: PageBlobUploadPagesFromURLOptions): Promise<PageBlobUploadPagesFromURLResponse>;
    withSnapshot(snapshot: string): PageBlobClient;
}

// @public
export interface PageBlobCopyIncrementalHeaders {
    clientRequestId?: string;
    copyId?: string;
    copyStatus?: CopyStatusType;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export type PageBlobCopyIncrementalResponse = PageBlobCopyIncrementalHeaders;

// @public
export interface PageBlobCreateHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    versionId?: string;
}

// @public
export interface PageBlobCreateIfNotExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blobSequenceNumber?: number;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
    tier?: PremiumPageBlobTier | string;
}

// @public
export interface PageBlobCreateIfNotExistsResponse extends PageBlobCreateResponse {
    succeeded: boolean;
}

// @public
export interface PageBlobCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    blobHTTPHeaders?: BlobHTTPHeaders;
    blobSequenceNumber?: number;
    conditions?: BlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    metadata?: Metadata;
    tags?: Tags;
    tier?: PremiumPageBlobTier | string;
}

// @public
export type PageBlobCreateResponse = PageBlobCreateHeaders;

// @public
export interface PageBlobGetPageRangesDiffHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobGetPageRangesDiffOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    range?: string;
}

// @public
export interface PageBlobGetPageRangesDiffResponse extends PageList, PageBlobGetPageRangesDiffHeaders {
}

// @public
export interface PageBlobGetPageRangesHeaders {
    blobContentLength?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobGetPageRangesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export interface PageBlobGetPageRangesResponse extends PageList, PageBlobGetPageRangesHeaders {
}

// @public
export interface PageBlobRequestConditions extends BlobRequestConditions, SequenceNumberAccessConditions {
}

// @public
export interface PageBlobResizeHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobResizeOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
    encryptionScope?: string;
}

// @public
export type PageBlobResizeResponse = PageBlobResizeHeaders;

// @public
export interface PageBlobStartCopyIncrementalOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: ModifiedAccessConditions;
}

// @public
export interface PageBlobUpdateSequenceNumberHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PageBlobUpdateSequenceNumberOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: BlobRequestConditions;
}

// @public
export type PageBlobUpdateSequenceNumberResponse = PageBlobUpdateSequenceNumberHeaders;

// @public
export interface PageBlobUploadPagesFromURLHeaders {
    blobSequenceNumber?: number;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobUploadPagesFromURLOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    sourceConditions?: MatchConditions & ModificationConditions;
    sourceContentCrc64?: Uint8Array;
    sourceContentMD5?: Uint8Array;
}

// @public
export type PageBlobUploadPagesFromURLResponse = PageBlobUploadPagesFromURLHeaders;

// @public
export interface PageBlobUploadPagesHeaders {
    blobSequenceNumber?: number;
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PageBlobUploadPagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: PageBlobRequestConditions;
    customerProvidedKey?: CpkInfo;
    encryptionScope?: string;
    onProgress?: (progress: TransferProgressEvent) => void;
    transactionalContentCrc64?: Uint8Array;
    transactionalContentMD5?: Uint8Array;
}

// @public
export type PageBlobUploadPagesResponse = PageBlobUploadPagesHeaders;

// @public
export interface PageList {
    clearRange?: Range[];
    pageRange?: Range[];
}

// @public
export interface ParsedBatchResponse {
    subResponses: BatchSubResponse[];
    subResponsesFailedCount: number;
    subResponsesSucceededCount: number;
}

// @public
export class Pipeline {
    constructor(factories: Pipeline_2, options?: PipelineOptions);
    readonly factories: Pipeline_2;
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: IHttpClient;
}

export { PipelineResponse }

export { PollerLike }

export { PollOperationState }

// @public
export enum PremiumPageBlobTier {
    P10 = "P10",
    P15 = "P15",
    P20 = "P20",
    P30 = "P30",
    P4 = "P4",
    P40 = "P40",
    P50 = "P50",
    P6 = "P6",
    P60 = "P60",
    P70 = "P70",
    P80 = "P80"
}

// @public
export type PublicAccessType = 'container' | 'blob';

// @public
export interface Range {
    count?: number;
    offset: number;
}

// @public
export type RehydratePriority = 'High' | 'Standard';

export { RequestBodyType }

export { RestError }

// @public
export interface RetentionPolicy {
    days?: number;
    enabled: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string, userDelegationKey?: UserDelegationKey, preauthorizedAgentObjectId?: string, correlationId?: string);
    constructor(version: string, signature: string, options?: SASQueryParametersOptions);
    readonly cacheControl?: string;
    readonly contentDisposition?: string;
    readonly contentEncoding?: string;
    readonly contentLanguage?: string;
    readonly contentType?: string;
    readonly correlationId?: string;
    readonly expiresOn?: Date;
    readonly identifier?: string;
    get ipRange(): SasIPRange | undefined;
    readonly permissions?: string;
    readonly preauthorizedAgentObjectId?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface SASQueryParametersOptions {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    correlationId?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: string;
    preauthorizedAgentObjectId?: string;
    protocol?: SASProtocol;
    resource?: string;
    resourceTypes?: string;
    services?: string;
    startsOn?: Date;
    userDelegationKey?: UserDelegationKey;
}

// @public
export interface SequenceNumberAccessConditions {
    ifSequenceNumberEqualTo?: number;
    ifSequenceNumberLessThan?: number;
    ifSequenceNumberLessThanOrEqualTo?: number;
}

// @public
export type SequenceNumberActionType = 'max' | 'update' | 'increment';

// @public
export interface ServiceFilterBlobsHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceFindBlobByTagsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceFindBlobsByTagsSegmentResponse = FilterBlobSegment & ServiceFilterBlobsHeaders;

// @public
export interface ServiceGenerateAccountSasUrlOptions {
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface ServiceGetAccountInfoHeaders {
    accountKind?: AccountKind;
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    isHierarchicalNamespaceEnabled?: boolean;
    requestId?: string;
    skuName?: SkuName;
    version?: string;
}

// @public
export interface ServiceGetAccountInfoOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetAccountInfoResponse = ServiceGetAccountInfoHeaders;

// @public
export interface ServiceGetPropertiesHeaders {
    clientRequestId?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetPropertiesResponse = BlobServiceProperties & ServiceGetPropertiesHeaders;

// @public
export interface ServiceGetStatisticsHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetStatisticsResponse = BlobServiceStatistics & ServiceGetStatisticsHeaders;

// @public
export interface ServiceGetUserDelegationKeyHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetUserDelegationKeyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetUserDelegationKeyResponse = UserDelegationKey & ServiceGetUserDelegationKeyHeaders;

// @public
export interface ServiceListContainersOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeDeleted?: boolean;
    includeMetadata?: boolean;
    prefix?: string;
}

// @public
export interface ServiceListContainersSegmentHeaders {
    clientRequestId?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ServiceListContainersSegmentResponse = ListContainersSegmentResponse & ServiceListContainersSegmentHeaders;

// @public
export interface ServiceRenameContainerOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    sourceCondition?: LeaseAccessConditions;
}

// @public
export interface ServiceSetPropertiesHeaders {
    clientRequestId?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders;

// @public
export interface ServiceSubmitBatchHeaders {
    clientRequestId?: string;
    contentType?: string;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSubmitBatchOptionalParamsModel extends OperationOptions {
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export type ServiceSubmitBatchResponseModel = ServiceSubmitBatchHeaders & {
    blobBody?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
};

// @public
export interface ServiceUndeleteContainerOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    destinationContainerName?: string;
}

// @public
export interface SignedIdentifier {
    accessPolicy: {
        startsOn?: Date;
        expiresOn?: Date;
        permissions?: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    // (undocumented)
    accessPolicy: AccessPolicy;
    id: string;
}

// @public
export type SkuName = 'Standard_LRS' | 'Standard_GRS' | 'Standard_RAGRS' | 'Standard_ZRS' | 'Premium_LRS';

// @public
export interface StaticWebsite {
    defaultIndexDocumentPath?: string;
    enabled: boolean;
    errorDocument404Path?: string;
    indexDocument?: string;
}

// @public
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    httpClient?: IHttpClient;
    // (undocumented)
    keepAliveOptions?: {
        enable: boolean;
    };
    proxyOptions?: ProxySettings;
    // Warning: (ae-forgotten-export) The symbol "StorageRetryOptions" needs to be exported by the entry point index.d.ts
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentPolicyOptions;
}

// @public
export class StorageSharedKeyCredential extends Credential {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    // (undocumented)
    getCanonicalizedHeadersString(request: PipelineRequest): string;
    // (undocumented)
    getCanonicalizedResourceString(request: PipelineRequest, accountName: string): string;
    // (undocumented)
    getHeaderValueToSign(request: PipelineRequest, headerName: string): string;
    // (undocumented)
    name: string;
    // (undocumented)
    signRequest(request: PipelineRequest): PipelineRequest;
}

// @public
export type SyncCopyStatusType = 'success';

// @public
export interface TagConditions {
    tagConditions?: string;
}

// @public
export type Tags = Record<string, string>;

// @public
export interface UserDelegationKey {
    signedExpiresOn: Date;
    signedObjectId: string;
    signedService: string;
    signedStartsOn: Date;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}

// @public
export interface UserDelegationKeyModel {
    signedExpiresOn: string;
    signedObjectId: string;
    signedService: string;
    signedStartsOn: string;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}


// (No @packageDocumentation comment for this package)

```
