{"version":3,"file":"ShardFactory.js","sourceRoot":"","sources":["../../src/ShardFactory.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAIlC,OAAO,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;AAInC,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAC;AAanD,MAAM,OAAO,YAAY;IAGvB,YAAY,YAA0B;QACpC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IACnC,CAAC;IAEM,KAAK,CAAC,MAAM,CACjB,eAAgC,EAChC,SAAiB,EACjB,WAAyB,EACzB,UAA8B,EAAE;QAEhC,OAAO,aAAa,CAAC,QAAQ,CAAC,qBAAqB,EAAE,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,EAAE;;YACrF,MAAM,MAAM,GAAa,EAAE,CAAC;YAC5B,MAAM,WAAW,GAAW,CAAA,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,WAAW,KAAI,CAAC,CAAC;YAC1D,MAAM,UAAU,GAAW,CAAA,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,UAAU,KAAI,CAAC,CAAC;;gBAExD,KAA6B,eAAA,KAAA,cAAA,eAAe,CAAC,aAAa,CAAC;oBACzD,MAAM,EAAE,SAAS;oBACjB,WAAW,EAAE,OAAO,CAAC,WAAW;oBAChC,cAAc,EAAE,cAAc,CAAC,cAAc;iBAC9C,CAAC,CAAA,IAAA,sDAAE,CAAC;oBAJwB,cAI3B;oBAJ2B,WAI3B;oBAJS,MAAM,QAAQ,KAAA,CAAA;oBAKvB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAC7B,CAAC;;;;;;;;;YAED,MAAM,gBAAgB,GAAG,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,gBAAgB,CAAC;YACvD,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC;YACpB,IAAI,YAAY,GAAsB,SAAS,CAAC;YAChD,8CAA8C;YAC9C,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACxB,gCAAgC;gBAChC,IAAI,gBAAgB,EAAE,CAAC;oBACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;wBACvC,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,gBAAgB,EAAE,CAAC;4BACnC,UAAU,GAAG,CAAC,CAAC;4BACf,MAAM;wBACR,CAAC;oBACH,CAAC;oBACD,IAAI,UAAU,KAAK,CAAC,CAAC,EAAE,CAAC;wBACtB,MAAM,IAAI,KAAK,CAAC,SAAS,gBAAgB,aAAa,CAAC,CAAC;oBAC1D,CAAC;gBACH,CAAC;qBAAM,CAAC;oBACN,UAAU,GAAG,CAAC,CAAC;gBACjB,CAAC;gBAED,iCAAiC;gBACjC,IAAI,UAAU,GAAG,CAAC,EAAE,CAAC;oBACnB,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;gBAC/B,CAAC;gBAED,YAAY,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAC3C,eAAe,EACf,MAAM,CAAC,KAAK,EAAG,EACf,WAAW,EACX,UAAU,EACV;oBACE,WAAW,EAAE,OAAO,CAAC,WAAW;oBAChC,cAAc,EAAE,cAAc,CAAC,cAAc;iBAC9C,CACF,CAAC;YACJ,CAAC;YAED,OAAO,IAAI,KAAK,CAAC,eAAe,EAAE,IAAI,CAAC,YAAY,EAAE,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC;QACxF,CAAC,CAAC,CAAC;IACL,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { ChunkFactory } from \"./ChunkFactory.js\";\nimport type { ShardCursor } from \"./models/ChangeFeedCursor.js\";\nimport { Shard } from \"./Shard.js\";\nimport type { ContainerClient, CommonOptions } from \"@azure/storage-blob\";\nimport type { Chunk } from \"./Chunk.js\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { tracingClient } from \"./utils/tracing.js\";\n\n/**\n * Options to configure {@link ShardFactory.create} operation.\n */\nexport interface CreateShardOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\nexport class ShardFactory {\n  private readonly chunkFactory: ChunkFactory;\n\n  constructor(chunkFactory: ChunkFactory) {\n    this.chunkFactory = chunkFactory;\n  }\n\n  public async create(\n    containerClient: ContainerClient,\n    shardPath: string,\n    shardCursor?: ShardCursor,\n    options: CreateShardOptions = {},\n  ): Promise<Shard> {\n    return tracingClient.withSpan(\"ShardFactory-create\", options, async (updatedOptions) => {\n      const chunks: string[] = [];\n      const blockOffset: number = shardCursor?.BlockOffset || 0;\n      const eventIndex: number = shardCursor?.EventIndex || 0;\n\n      for await (const blobItem of containerClient.listBlobsFlat({\n        prefix: shardPath,\n        abortSignal: options.abortSignal,\n        tracingOptions: updatedOptions.tracingOptions,\n      })) {\n        chunks.push(blobItem.name);\n      }\n\n      const currentChunkPath = shardCursor?.CurrentChunkPath;\n      let chunkIndex = -1;\n      let currentChunk: Chunk | undefined = undefined;\n      // Chunks can be empty right after hour flips.\n      if (chunks.length !== 0) {\n        // Fast forward to current Chunk\n        if (currentChunkPath) {\n          for (let i = 0; i < chunks.length; i++) {\n            if (chunks[i] === currentChunkPath) {\n              chunkIndex = i;\n              break;\n            }\n          }\n          if (chunkIndex === -1) {\n            throw new Error(`Chunk ${currentChunkPath} not found.`);\n          }\n        } else {\n          chunkIndex = 0;\n        }\n\n        // Fast forward to current Chunk.\n        if (chunkIndex > 0) {\n          chunks.splice(0, chunkIndex);\n        }\n\n        currentChunk = await this.chunkFactory.create(\n          containerClient,\n          chunks.shift()!,\n          blockOffset,\n          eventIndex,\n          {\n            abortSignal: options.abortSignal,\n            tracingOptions: updatedOptions.tracingOptions,\n          },\n        );\n      }\n\n      return new Shard(containerClient, this.chunkFactory, chunks, currentChunk, shardPath);\n    });\n  }\n}\n"]}