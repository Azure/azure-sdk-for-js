{"version":3,"file":"LazyLoadingBlobStream.js","sourceRoot":"","sources":["../../src/LazyLoadingBlobStream.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { ReadableOptions } from \"node:stream\";\nimport { Readable } from \"node:stream\";\nimport type { BlobClient, CommonOptions } from \"@azure/storage-blob\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { tracingClient } from \"./utils/tracing.js\";\n\n/**\n * Options to configure the LazyLoadingBlobStream.\n */\nexport interface LazyLoadingBlobStreamOptions extends ReadableOptions, CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\ninterface LazyLoadingBlobStreamDownloadBlockOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * This class generates a readable stream from a blobClient's data.\n */\nexport class LazyLoadingBlobStream extends Readable {\n  /**\n   * BlobClient to make download calls with.\n   */\n  private readonly blobClient: BlobClient;\n\n  /**\n   * The offset within the blob of the next block we will download.\n   */\n  private offset: number;\n\n  private readonly blockSize: number;\n\n  private lastDownloadBytes: number;\n\n  private lastDownloadData?: Buffer;\n\n  private blobLength: number;\n\n  private options?: LazyLoadingBlobStreamOptions;\n\n  /**\n   * Creates an instance of LazyLoadingBlobStream.\n   *\n   * @param byteLength - The total length of data contained in the buffers\n   */\n  constructor(\n    blobClient: BlobClient,\n    offset: number,\n    blockSize: number,\n    options?: LazyLoadingBlobStreamOptions,\n  ) {\n    super(options);\n    this.blobClient = blobClient;\n    this.offset = offset;\n    this.blockSize = blockSize;\n    this.lastDownloadBytes = -1;\n    this.blobLength = -1;\n    this.options = options;\n  }\n\n  private async downloadBlock(options: LazyLoadingBlobStreamDownloadBlockOptions = {}) {\n    return tracingClient.withSpan(\n      \"LazyLoadingBlobStream-downloadBlock\",\n      options,\n      async (updatedOptions) => {\n        const properties = await this.blobClient.getProperties({\n          abortSignal: options.abortSignal,\n          tracingOptions: updatedOptions.tracingOptions,\n        });\n        this.blobLength = properties.contentLength!;\n\n        this.lastDownloadBytes = Math.min(this.blockSize, this.blobLength - this.offset);\n        if (this.lastDownloadBytes === 0) {\n          this.lastDownloadData = undefined;\n          return;\n        }\n\n        this.lastDownloadData = await this.blobClient.downloadToBuffer(\n          this.offset,\n          this.lastDownloadBytes,\n          {\n            abortSignal: options.abortSignal,\n            tracingOptions: updatedOptions.tracingOptions,\n          },\n        );\n        this.offset += this.lastDownloadBytes;\n      },\n    );\n  }\n\n  /**\n   * Internal _read() that will be called when the stream wants to pull more data in.\n   *\n   * @param size - Optional. The size of data to be read\n   */\n  public async _read(size?: number): Promise<void> {\n    return tracingClient.withSpan(\n      \"LazyLoadingBlobStream-read\",\n      this.options ?? {},\n      async (updatedOptions) => {\n        if (!size) {\n          size = this.readableHighWaterMark;\n        }\n        let count = 0;\n        let chunkSize = 0;\n        const chunksToPush = [];\n        do {\n          if (this.lastDownloadData === undefined || this.lastDownloadData?.byteLength === 0) {\n            await this.downloadBlock({\n              abortSignal: this.options?.abortSignal,\n              tracingOptions: updatedOptions?.tracingOptions,\n            });\n          }\n          if (this.lastDownloadData?.byteLength) {\n            chunkSize = Math.min(size - count, this.lastDownloadData?.byteLength);\n            chunksToPush.push(this.lastDownloadData.slice(0, chunkSize));\n            this.lastDownloadData = this.lastDownloadData.slice(chunkSize);\n            count += chunkSize;\n          } else {\n            chunkSize = 0;\n          }\n        } while (chunkSize > 0 && count < size);\n\n        this.push(Buffer.concat(chunksToPush));\n\n        if (count < size) {\n          this.push(null);\n        }\n      },\n    );\n  }\n}\n"]}