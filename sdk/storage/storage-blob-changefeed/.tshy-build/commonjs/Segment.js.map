{"version":3,"file":"Segment.js","sourceRoot":"","sources":["../../src/Segment.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAOlC,mDAAmD;AAanD,MAAa,OAAO;IAYlB,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED,YACE,MAAe,EACf,UAAkB,EAClB,QAAc,EACG,YAAoB;QAApB,iBAAY,GAAZ,YAAY,CAAQ;QAErC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAE1B,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAClD,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;IAC1B,CAAC;IAEM,OAAO;QACZ,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC;IAClD,CAAC;IAEM,KAAK,CAAC,SAAS,CACpB,UAAmC,EAAE;QAErC,OAAO,0BAAa,CAAC,QAAQ,CAAC,mBAAmB,EAAE,OAAO,EAAE,KAAK,EAAE,cAAc,EAAE,EAAE;YACnF,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,UAAU,GAAG,CAAC,EAAE,CAAC;gBACjE,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;YACzC,CAAC;YAED,IAAI,KAAK,GAAoC,SAAS,CAAC;YACvD,OAAO,KAAK,KAAK,SAAS,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE,CAAC;gBAC7C,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC;oBACpC,IAAI,CAAC,UAAU,GAAG,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,4BAA4B;oBAC1F,SAAS;gBACX,CAAC;gBAED,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;gBAClD,KAAK,GAAG,MAAM,YAAY,CAAC,SAAS,CAAC;oBACnC,WAAW,EAAE,OAAO,CAAC,WAAW;oBAChC,cAAc,EAAE,cAAc,CAAC,cAAc;iBAC9C,CAAC,CAAC;gBAEH,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,EAAE,CAAC;oBAC5B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;oBACvC,IAAI,CAAC,cAAc,EAAE,CAAC;gBACxB,CAAC;gBACD,0BAA0B;gBAC1B,IAAI,CAAC,UAAU,GAAG,CAAC,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;YAC/D,CAAC;YACD,OAAO,KAAK,CAAC;QACf,CAAC,CAAC,CAAC;IACL,CAAC;IAEM,SAAS;QACd,MAAM,YAAY,GAAkB,EAAE,CAAC;QACvC,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC;YAChC,MAAM,WAAW,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC;YACtC,IAAI,WAAW,EAAE,CAAC;gBAChB,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YACjC,CAAC;QACH,CAAC;QAED,OAAO;YACL,WAAW,EAAE,IAAI,CAAC,YAAY;YAC9B,YAAY,EAAE,YAAY;YAC1B,gBAAgB,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,SAAS;SACzD,CAAC;IACJ,CAAC;CACF;AAjFD,0BAiFC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { BlobChangeFeedEvent } from \"./models/BlobChangeFeedEvent.js\";\nimport type { Shard } from \"./Shard.js\";\nimport type { SegmentCursor, ShardCursor } from \"./models/ChangeFeedCursor.js\";\nimport type { CommonOptions } from \"@azure/storage-blob\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { tracingClient } from \"./utils/tracing.js\";\n\n/**\n * Options to configure {@link Segment.getChange} operation.\n */\nexport interface SegmentGetChangeOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\nexport class Segment {\n  private readonly shards: Shard[];\n\n  // Track shards that we have finished reading from.\n  private shardDone: boolean[];\n  private shardDoneCount: number;\n\n  private shardIndex: number;\n\n  // Assuming the dateTime of segments is rounded to hour. If not, our logic for fetching\n  // change events between a time range would be incorrect.\n  private _dateTime: Date;\n  public get dateTime(): Date {\n    return this._dateTime;\n  }\n\n  constructor(\n    shards: Shard[],\n    shardIndex: number,\n    dateTime: Date,\n    private readonly manifestPath: string,\n  ) {\n    this.shards = shards;\n    this.shardIndex = shardIndex;\n    this._dateTime = dateTime;\n\n    this.shardDone = Array(shards.length).fill(false);\n    this.shardDoneCount = 0;\n  }\n\n  public hasNext(): boolean {\n    return this.shards.length > this.shardDoneCount;\n  }\n\n  public async getChange(\n    options: SegmentGetChangeOptions = {},\n  ): Promise<BlobChangeFeedEvent | undefined> {\n    return tracingClient.withSpan(\"Segment-getChange\", options, async (updatedOptions) => {\n      if (this.shardIndex >= this.shards.length || this.shardIndex < 0) {\n        throw new Error(\"shardIndex invalid.\");\n      }\n\n      let event: BlobChangeFeedEvent | undefined = undefined;\n      while (event === undefined && this.hasNext()) {\n        if (this.shardDone[this.shardIndex]) {\n          this.shardIndex = (this.shardIndex + 1) % this.shards.length; // find next available shard\n          continue;\n        }\n\n        const currentShard = this.shards[this.shardIndex];\n        event = await currentShard.getChange({\n          abortSignal: options.abortSignal,\n          tracingOptions: updatedOptions.tracingOptions,\n        });\n\n        if (!currentShard.hasNext()) {\n          this.shardDone[this.shardIndex] = true;\n          this.shardDoneCount++;\n        }\n        // Round robin with shards\n        this.shardIndex = (this.shardIndex + 1) % this.shards.length;\n      }\n      return event;\n    });\n  }\n\n  public getCursor(): SegmentCursor {\n    const shardCursors: ShardCursor[] = [];\n    for (const shard of this.shards) {\n      const shardCursor = shard.getCursor();\n      if (shardCursor) {\n        shardCursors.push(shardCursor);\n      }\n    }\n\n    return {\n      SegmentPath: this.manifestPath,\n      ShardCursors: shardCursors,\n      CurrentShardPath: this.shards[this.shardIndex].shardPath,\n    };\n  }\n}\n"]}