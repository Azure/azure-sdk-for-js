## API Report File for "@azure/storage-file-datalake"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';
import { AnonymousCredential } from '@azure/storage-blob';
import { AnonymousCredentialPolicy } from '@azure/storage-blob';
import { AzureLogger } from '@azure/logger';
import { BlobLeaseClient } from '@azure/storage-blob';
import { BlobQueryArrowConfiguration } from '@azure/storage-blob';
import { CommonOptions } from '@azure/storage-blob';
import { ContainerRenameResponse } from '@azure/storage-blob';
import { ContainerUndeleteResponse } from '@azure/storage-blob';
import * as coreClient from '@azure/core-client';
import * as coreHttpCompat from '@azure/core-http-compat';
import * as coreRestPipeline from '@azure/core-rest-pipeline';
import { Credential as Credential_2 } from '@azure/storage-blob';
import { CredentialPolicy } from '@azure/storage-blob';
import { ServiceGetPropertiesResponse as DataLakeServiceGetPropertiesResponse } from '@azure/storage-blob';
import { BlobServiceProperties as DataLakeServiceProperties } from '@azure/storage-blob';
import { Lease } from '@azure/storage-blob';
import { LeaseAccessConditions } from '@azure/storage-blob';
import { LeaseOperationOptions } from '@azure/storage-blob';
import { LeaseOperationResponse } from '@azure/storage-blob';
import { ModifiedAccessConditions as ModifiedAccessConditions_3 } from '@azure/storage-blob';
import { newPipeline } from '@azure/storage-blob';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { Pipeline } from '@azure/storage-blob';
import { Readable } from 'stream';
import { RequestBodyType } from '@azure/core-rest-pipeline';
import { RestError } from '@azure/core-rest-pipeline';
import { ServiceGetPropertiesOptions } from '@azure/storage-blob';
import { ServiceListContainersSegmentResponse } from '@azure/storage-blob';
import { ServiceRenameContainerOptions } from '@azure/storage-blob';
import { ServiceSetPropertiesOptions } from '@azure/storage-blob';
import { ServiceSetPropertiesResponse } from '@azure/storage-blob';
import { StorageBrowserPolicy } from '@azure/storage-blob';
import { StorageBrowserPolicyFactory } from '@azure/storage-blob';
import { StoragePipelineOptions } from '@azure/storage-blob';
import { StorageRetryPolicy } from '@azure/storage-blob';
import { StorageRetryPolicyFactory } from '@azure/storage-blob';
import { StorageSharedKeyCredential } from '@azure/storage-blob';
import { StorageSharedKeyCredentialPolicy } from '@azure/storage-blob';
import { TokenCredential } from '@azure/core-auth';
import { TransferProgressEvent } from '@azure/core-rest-pipeline';
import { UserDelegationKeyModel } from '@azure/storage-blob';
import { WithResponse } from '@azure/storage-blob';

// @public
export interface AccessControlChangeCounters {
    changedDirectoriesCount: number;
    changedFilesCount: number;
    failedChangesCount: number;
}

// @public
export interface AccessControlChangeError {
    isDirectory: boolean;
    message: string;
    name: string;
}

// @public
export interface AccessControlChanges {
    aggregateCounters: AccessControlChangeCounters;
    batchCounters: AccessControlChangeCounters;
    batchFailures: AccessControlChangeError[];
    continuationToken?: string;
}

// @public (undocumented)
export type AccessControlType = "user" | "group" | "mask" | "other";

// @public (undocumented)
export interface AccessPolicy {
    // (undocumented)
    expiresOn?: Date;
    // (undocumented)
    permissions: string;
    // (undocumented)
    startsOn?: Date;
}

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    encryptionScope?: string;
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

export { AnonymousCredential }

export { AnonymousCredentialPolicy }

// @public (undocumented)
export interface BlobHierarchyListSegment {
    // (undocumented)
    blobItems: BlobItemModel[];
    // (undocumented)
    blobPrefixes?: BlobPrefix[];
}

// @public
export interface BlobItemModel {
    // (undocumented)
    deleted: boolean;
    // (undocumented)
    deletionId?: string;
    // (undocumented)
    isCurrentVersion?: boolean;
    // (undocumented)
    name: string;
    properties: BlobPropertiesModel;
    // (undocumented)
    snapshot: string;
    // (undocumented)
    versionId?: string;
}

// @public (undocumented)
export interface BlobPrefix {
    // (undocumented)
    name: string;
}

// @public
export interface BlobPropertiesModel {
    // (undocumented)
    accessTierChangeTime?: Date;
    // (undocumented)
    accessTierInferred?: boolean;
    // (undocumented)
    blobSequenceNumber?: number;
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    contentLength?: number;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    copyCompletionTime?: Date;
    // (undocumented)
    copyId?: string;
    // (undocumented)
    copyProgress?: string;
    // (undocumented)
    copySource?: string;
    // (undocumented)
    copyStatusDescription?: string;
    // (undocumented)
    creationTime?: Date;
    // (undocumented)
    customerProvidedKeySha256?: string;
    // (undocumented)
    deletedTime?: Date;
    // (undocumented)
    destinationSnapshot?: string;
    encryptionScope?: string;
    // (undocumented)
    etag: string;
    // (undocumented)
    expiresOn?: Date;
    // (undocumented)
    incrementalCopy?: boolean;
    // (undocumented)
    lastAccessedOn?: Date;
    // (undocumented)
    lastModified: Date;
    // (undocumented)
    remainingRetentionDays?: number;
    // (undocumented)
    sealed?: boolean;
    // (undocumented)
    serverEncrypted?: boolean;
    // (undocumented)
    tagCount?: number;
}

// @public
export interface CommonGenerateSasUrlOptions {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    encryptionScope?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

export { CommonOptions }

// @public (undocumented)
export type CopyStatusType = "pending" | "success" | "aborted" | "failed";

// @public
export interface CpkInfo {
    encryptionAlgorithm?: EncryptionAlgorithmType;
    encryptionKey?: string;
    encryptionKeySha256?: string;
}

export { Credential_2 as Credential }

export { CredentialPolicy }

// @public
export class DataLakeAclChangeFailedError extends Error {
    constructor(error: RestError | Error, continuationToken?: string);
    continuationToken?: string;
    innerError: RestError | Error;
}

// @public
export class DataLakeDirectoryClient extends DataLakePathClient {
    create(resourceType: PathResourceTypeModel, options?: PathCreateOptions): Promise<PathCreateResponse>;
    create(options?: DirectoryCreateOptions): Promise<DirectoryCreateResponse>;
    createIfNotExists(resourceType: PathResourceTypeModel, options?: PathCreateIfNotExistsOptions): Promise<PathCreateIfNotExistsResponse>;
    createIfNotExists(options?: DirectoryCreateIfNotExistsOptions): Promise<DirectoryCreateIfNotExistsResponse>;
    generateSasUrl(options: DirectoryGenerateSasUrlOptions): Promise<string>;
    getFileClient(fileName: string): DataLakeFileClient;
    getSubdirectoryClient(subdirectoryName: string): DataLakeDirectoryClient;
}

// @public
export class DataLakeFileClient extends DataLakePathClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    append(body: RequestBodyType, offset: number, length: number, options?: FileAppendOptions): Promise<FileAppendResponse>;
    create(resourceType: PathResourceTypeModel, options?: PathCreateOptions): Promise<PathCreateResponse>;
    create(options?: FileCreateOptions): Promise<FileCreateResponse>;
    createIfNotExists(resourceType: PathResourceTypeModel, options?: PathCreateIfNotExistsOptions): Promise<PathCreateIfNotExistsResponse>;
    createIfNotExists(options?: FileCreateIfNotExistsOptions): Promise<FileCreateIfNotExistsResponse>;
    flush(position: number, options?: FileFlushOptions): Promise<FileFlushResponse>;
    generateSasUrl(options: FileGenerateSasUrlOptions): Promise<string>;
    query(query: string, options?: FileQueryOptions): Promise<FileReadResponse>;
    read(offset?: number, count?: number, options?: FileReadOptions): Promise<FileReadResponse>;
    readToBuffer(buffer: Buffer, offset?: number, count?: number, options?: FileReadToBufferOptions): Promise<Buffer>;
    readToBuffer(offset?: number, count?: number, options?: FileReadToBufferOptions): Promise<Buffer>;
    readToFile(filePath: string, offset?: number, count?: number, options?: FileReadOptions): Promise<FileReadResponse>;
    setExpiry(mode: FileExpiryMode, options?: FileSetExpiryOptions): Promise<FileSetExpiryResponse>;
    upload(data: Buffer | Blob | ArrayBuffer | ArrayBufferView, options?: FileParallelUploadOptions): Promise<FileUploadResponse>;
    uploadFile(filePath: string, options?: FileParallelUploadOptions): Promise<FileUploadResponse>;
    uploadStream(stream: Readable, options?: FileParallelUploadOptions): Promise<FileUploadResponse>;
}

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class DataLakeFileSystemClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    create(options?: FileSystemCreateOptions): Promise<FileSystemCreateResponse>;
    createIfNotExists(options?: FileSystemCreateOptions): Promise<FileSystemCreateIfNotExistsResponse>;
    delete(options?: FileSystemDeleteOptions): Promise<FileSystemDeleteResponse>;
    deleteIfExists(options?: FileSystemDeleteOptions): Promise<FileSystemDeleteIfExistsResponse>;
    exists(options?: FileSystemExistsOptions): Promise<boolean>;
    generateSasUrl(options: FileSystemGenerateSasUrlOptions): Promise<string>;
    getAccessPolicy(options?: FileSystemGetAccessPolicyOptions): Promise<FileSystemGetAccessPolicyResponse>;
    getDataLakeLeaseClient(proposeLeaseId?: string): DataLakeLeaseClient;
    getDirectoryClient(directoryName: string): DataLakeDirectoryClient;
    getFileClient(fileName: string): DataLakeFileClient;
    getProperties(options?: FileSystemGetPropertiesOptions): Promise<FileSystemGetPropertiesResponse>;
    listDeletedPaths(options?: ListDeletedPathsOptions): PagedAsyncIterableIterator<DeletedPath, FileSystemListDeletedPathsResponse>;
    listPaths(options?: ListPathsOptions): PagedAsyncIterableIterator<Path, FileSystemListPathsResponse>;
    get name(): string;
    setAccessPolicy(access?: PublicAccessType, fileSystemAcl?: SignedIdentifier<AccessPolicy>[], options?: FileSystemSetAccessPolicyOptions): Promise<FileSystemSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: FileSystemSetMetadataOptions): Promise<FileSystemSetMetadataResponse>;
    undeletePath(deletedPath: string, deletionId: string, options?: FileSystemUndeletePathOption): Promise<FileSystemUndeletePathResponse>;
}

// @public (undocumented)
export class DataLakeLeaseClient {
    constructor(client: BlobLeaseClient);
    // (undocumented)
    acquireLease(duration: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    // (undocumented)
    breakLease(breakPeriod: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    // (undocumented)
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    // (undocumented)
    get leaseId(): string;
    // (undocumented)
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    // (undocumented)
    renewLease(options?: LeaseOperationOptions): Promise<Lease>;
    // (undocumented)
    get url(): string;
}

// @public
export class DataLakePathClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    create(resourceType: PathResourceTypeModel, options?: PathCreateOptions): Promise<PathCreateResponse>;
    createIfNotExists(resourceType: PathResourceTypeModel, options?: PathCreateIfNotExistsOptions): Promise<PathCreateIfNotExistsResponse>;
    delete(recursive?: boolean, options?: PathDeleteOptions): Promise<PathDeleteResponse>;
    deleteIfExists(recursive?: boolean, options?: PathDeleteOptions): Promise<PathDeleteIfExistsResponse>;
    exists(options?: PathExistsOptions): Promise<boolean>;
    get fileSystemName(): string;
    getAccessControl(options?: PathGetAccessControlOptions): Promise<PathGetAccessControlResponse>;
    getDataLakeLeaseClient(proposeLeaseId?: string): DataLakeLeaseClient;
    getProperties(options?: PathGetPropertiesOptions): Promise<PathGetPropertiesResponse>;
    move(destinationPath: string, options?: PathMoveOptions): Promise<PathMoveResponse>;
    move(destinationFileSystem: string, destinationPath: string, options?: PathMoveOptions): Promise<PathMoveResponse>;
    get name(): string;
    removeAccessControlRecursive(acl: RemovePathAccessControlItem[], options?: PathChangeAccessControlRecursiveOptions): Promise<PathChangeAccessControlRecursiveResponse>;
    setAccessControl(acl: PathAccessControlItem[], options?: PathSetAccessControlOptions): Promise<PathSetAccessControlResponse>;
    setAccessControlRecursive(acl: PathAccessControlItem[], options?: PathChangeAccessControlRecursiveOptions): Promise<PathChangeAccessControlRecursiveResponse>;
    setHttpHeaders(httpHeaders: PathHttpHeaders, options?: PathSetHttpHeadersOptions): Promise<PathSetHttpHeadersResponse>;
    setMetadata(metadata?: Metadata, options?: PathSetMetadataOptions): Promise<PathSetMetadataResponse>;
    setPermissions(permissions: PathPermissions, options?: PathSetPermissionsOptions): Promise<PathSetPermissionsResponse>;
    toDirectoryClient(): DataLakeDirectoryClient;
    toFileClient(): DataLakeFileClient;
    updateAccessControlRecursive(acl: PathAccessControlItem[], options?: PathChangeAccessControlRecursiveOptions): Promise<PathChangeAccessControlRecursiveResponse>;
}

// @public (undocumented)
export interface DataLakeRequestConditions extends ModifiedAccessConditions, LeaseAccessConditions {
}

// @public
export class DataLakeSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    execute: boolean;
    manageAccessControl: boolean;
    manageOwnership: boolean;
    move: boolean;
    static parse(permissions: string): DataLakeSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface DataLakeSASSignatureValues {
    agentObjectId?: string;
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    correlationId?: string;
    directoryDepth?: number;
    encryptionScope?: string;
    expiresOn?: Date;
    fileSystemName: string;
    identifier?: string;
    ipRange?: SasIPRange;
    isDirectory?: boolean;
    pathName?: string;
    permissions?: DataLakeSASPermissions | DirectorySASPermissions | FileSystemSASPermissions;
    preauthorizedAgentObjectId?: string;
    protocol?: SASProtocol;
    snapshotTime?: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class DataLakeServiceClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): DataLakeServiceClient;
    generateAccountSasUrl(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
    getFileSystemClient(fileSystemName: string): DataLakeFileSystemClient;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<DataLakeServiceGetPropertiesResponse>;
    getUserDelegationKey(startsOn: Date, expiresOn: Date, options?: ServiceGetUserDelegationKeyOptions): Promise<ServiceGetUserDelegationKeyResponse>;
    listFileSystems(options?: ServiceListFileSystemsOptions): PagedAsyncIterableIterator<FileSystemItem, ServiceListFileSystemsSegmentResponse>;
    setProperties(properties: DataLakeServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
    undeleteFileSystem(deletedFileSystemName: string, deleteFileSystemVersion: string, options?: ServiceUndeleteFileSystemOptions): Promise<{
        fileSystemClient: DataLakeFileSystemClient;
        fileSystemUndeleteResponse: FileSystemUndeleteResponse;
    }>;
}

export { DataLakeServiceGetPropertiesResponse }

export { DataLakeServiceProperties }

// @public (undocumented)
export interface DeletedPath {
    // (undocumented)
    deletedOn?: Date;
    // (undocumented)
    deletionId?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    remainingRetentionDays?: number;
}

// @public (undocumented)
export interface DeletedPathList {
    // (undocumented)
    pathItems?: DeletedPath[];
}

// @public (undocumented)
export interface DirectoryCreateIfNotExistsOptions extends PathCreateIfNotExistsOptions {
}

// @public (undocumented)
export interface DirectoryCreateIfNotExistsResponse extends PathCreateIfNotExistsResponse {
}

// @public
export interface DirectoryCreateOptions extends PathCreateOptions {
}

// @public (undocumented)
export interface DirectoryCreateResponse extends PathCreateResponse {
}

// @public
export interface DirectoryGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: DirectorySASPermissions;
}

// @public
export class DirectorySASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    execute: boolean;
    list: boolean;
    manageAccessControl: boolean;
    manageOwnership: boolean;
    move: boolean;
    static parse(permissions: string): DirectorySASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export type EncryptionAlgorithmType = string;

// @public (undocumented)
export interface FileAppendOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: LeaseAccessConditions;
    customerProvidedKey?: CpkInfo;
    flush?: boolean;
    // Warning: (ae-forgotten-export) The symbol "LeaseAction" needs to be exported by the entry point index.d.ts
    leaseAction?: LeaseAction;
    leaseDurationInSeconds?: number;
    // (undocumented)
    onProgress?: (progress: TransferProgressEvent) => void;
    proposedLeaseId?: string;
    // (undocumented)
    transactionalContentMD5?: Uint8Array;
}

// @public (undocumented)
export type FileAppendResponse = WithResponse<PathAppendDataHeaders, PathAppendDataHeaders>;

// @public (undocumented)
export interface FileCreateIfNotExistsOptions extends PathCreateIfNotExistsOptions {
}

// @public (undocumented)
export interface FileCreateIfNotExistsResponse extends PathCreateIfNotExistsResponse {
}

// @public (undocumented)
export interface FileCreateOptions extends PathCreateOptions {
}

// @public (undocumented)
export interface FileCreateResponse extends PathCreateResponse {
}

// @public
export type FileExpiryMode = "NeverExpire" | "RelativeToCreation" | "RelativeToNow" | "Absolute";

// @public (undocumented)
export interface FileFlushOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    close?: boolean;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    customerProvidedKey?: CpkInfo;
    leaseAction?: LeaseAction;
    leaseDurationInSeconds?: number;
    // (undocumented)
    pathHttpHeaders?: PathHttpHeaders;
    proposedLeaseId?: string;
    // (undocumented)
    retainUncommittedData?: boolean;
}

// @public (undocumented)
export type FileFlushResponse = WithResponse<PathFlushDataHeaders, PathFlushDataHeaders>;

// @public
export interface FileGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: DataLakeSASPermissions;
}

// @public
export interface FileParallelUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    chunkSize?: number;
    close?: boolean;
    conditions?: DataLakeRequestConditions;
    customerProvidedKey?: CpkInfo;
    maxConcurrency?: number;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
    pathHttpHeaders?: PathHttpHeaders;
    permissions?: string;
    singleUploadThreshold?: number;
    umask?: string;
}

// @public
export type FileQueryArrowConfiguration = BlobQueryArrowConfiguration;

// @public
export interface FileQueryCsvTextConfiguration {
    columnSeparator?: string;
    escapeCharacter?: string;
    fieldQuote?: string;
    hasHeaders?: boolean;
    kind: "csv";
    recordSeparator: string;
}

// @public
export interface FileQueryError {
    description: string;
    isFatal: boolean;
    name: string;
    position: number;
}

// @public
export interface FileQueryJsonTextConfiguration {
    kind: "json";
    recordSeparator: string;
}

// @public
export interface FileQueryOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: DataLakeRequestConditions;
    customerProvidedKey?: CpkInfo;
    inputTextConfiguration?: FileQueryJsonTextConfiguration | FileQueryCsvTextConfiguration | FileQueryParquetConfiguration;
    onError?: (error: FileQueryError) => void;
    onProgress?: (progress: TransferProgressEvent) => void;
    outputTextConfiguration?: FileQueryJsonTextConfiguration | FileQueryCsvTextConfiguration | FileQueryArrowConfiguration;
}

// @public
export interface FileQueryParquetConfiguration {
    kind: "parquet";
}

// @public (undocumented)
export interface FileReadHeaders {
    // (undocumented)
    acceptRanges?: string;
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    contentCrc64?: Uint8Array;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentRange?: string;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    copyCompletedOn?: Date;
    // (undocumented)
    copyId?: string;
    // (undocumented)
    copyProgress?: string;
    // (undocumented)
    copySource?: string;
    // (undocumented)
    copyStatus?: CopyStatusType;
    // (undocumented)
    copyStatusDescription?: string;
    createdOn?: Date;
    // (undocumented)
    date?: Date;
    // (undocumented)
    encryptionKeySha256?: string;
    // (undocumented)
    etag?: string;
    // (undocumented)
    fileContentMD5?: Uint8Array;
    // (undocumented)
    isServerEncrypted?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface FileReadOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    customerProvidedKey?: CpkInfo;
    // (undocumented)
    maxRetryRequests?: number;
    // (undocumented)
    onProgress?: (progress: TransferProgressEvent) => void;
    // (undocumented)
    rangeGetContentCrc64?: boolean;
    // (undocumented)
    rangeGetContentMD5?: boolean;
}

// @public (undocumented)
export type FileReadResponse = WithResponse<FileReadHeaders & {
    contentAsBlob?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
}, FileReadHeaders>;

// @public
export interface FileReadToBufferOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    chunkSize?: number;
    concurrency?: number;
    conditions?: DataLakeRequestConditions;
    customerProvidedKey?: CpkInfo;
    maxRetryRequestsPerChunk?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public
export interface FileSetExpiryHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface FileSetExpiryOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    expiresOn?: Date;
    timeToExpireInMs?: number;
}

// @public (undocumented)
export type FileSetExpiryResponse = WithResponse<FileSetExpiryHeaders, FileSetExpiryHeaders>;

// @public (undocumented)
export interface FileSystemCreateHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface FileSystemCreateIfNotExistsResponse extends FileSystemCreateResponse {
    succeeded: boolean;
}

// @public
export interface FileSystemCreateOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    access?: PublicAccessType;
    fileSystemEncryptionScope?: FileSystemEncryptionScope;
    // (undocumented)
    metadata?: Metadata;
}

// @public (undocumented)
export type FileSystemCreateResponse = WithResponse<FileSystemCreateHeaders, FileSystemCreateHeaders>;

// @public (undocumented)
export interface FileSystemDeleteHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface FileSystemDeleteIfExistsResponse extends FileSystemDeleteResponse {
    succeeded: boolean;
}

// @public (undocumented)
export interface FileSystemDeleteOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type FileSystemDeleteResponse = WithResponse<FileSystemDeleteHeaders, FileSystemDeleteHeaders>;

// @public
export interface FileSystemEncryptionScope {
    defaultEncryptionScope?: string;
    preventEncryptionScopeOverride?: boolean;
}

// @public
export interface FileSystemExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface FileSystemGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    permissions?: FileSystemSASPermissions;
}

// @public (undocumented)
export interface FileSystemGetAccessPolicyHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    publicAccess?: PublicAccessType;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface FileSystemGetAccessPolicyOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: LeaseAccessConditions;
}

// @public (undocumented)
export type FileSystemGetAccessPolicyResponse = WithResponse<{
    signedIdentifiers: SignedIdentifier<AccessPolicy>[];
} & FileSystemGetAccessPolicyHeaders, FileSystemGetAccessPolicyHeaders, SignedIdentifier<RawAccessPolicy>[]>;

// @public (undocumented)
export interface FileSystemGetPropertiesHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    defaultEncryptionScope?: string;
    // (undocumented)
    etag?: string;
    // (undocumented)
    hasImmutabilityPolicy?: boolean;
    // (undocumented)
    hasLegalHold?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    publicAccess?: PublicAccessType;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface FileSystemGetPropertiesOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: LeaseAccessConditions;
}

// @public (undocumented)
export type FileSystemGetPropertiesResponse = WithResponse<FileSystemGetPropertiesHeaders, FileSystemGetPropertiesHeaders>;

// @public (undocumented)
export interface FileSystemItem {
    // (undocumented)
    deleted?: boolean;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    name: string;
    // (undocumented)
    properties: FileSystemProperties;
    // (undocumented)
    versionId?: string;
}

// @public
export interface FileSystemListBlobHierarchySegmentHeaders {
    clientRequestId?: string;
    contentType?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export type FileSystemListDeletedPathsResponse = WithResponse<DeletedPathList & FileSystemListBlobHierarchySegmentHeaders & ListBlobsHierarchySegmentResponse & {
    continuation?: string;
}, FileSystemListBlobHierarchySegmentHeaders, ListBlobsHierarchySegmentResponse>;

// @public
export interface FileSystemListPathsHeaders {
    continuation?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export type FileSystemListPathsResponse = WithResponse<PathList & FileSystemListPathsHeaders, FileSystemListPathsHeaders, PathListModel>;

// @public (undocumented)
export interface FileSystemProperties {
    // (undocumented)
    defaultEncryptionScope?: string;
    // (undocumented)
    deletedOn?: Date;
    // (undocumented)
    etag: string;
    // (undocumented)
    hasImmutabilityPolicy?: boolean;
    // (undocumented)
    hasLegalHold?: boolean;
    // (undocumented)
    lastModified: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    publicAccess?: PublicAccessType;
    // (undocumented)
    remainingRetentionDays?: number;
}

// @public
export type FileSystemRenameResponse = ContainerRenameResponse;

// @public
export class FileSystemSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    execute: boolean;
    list: boolean;
    manageAccessControl: boolean;
    manageOwnership: boolean;
    move: boolean;
    static parse(permissions: string): FileSystemSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public (undocumented)
export interface FileSystemSetAccessPolicyHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface FileSystemSetAccessPolicyOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type FileSystemSetAccessPolicyResponse = WithResponse<FileSystemSetAccessPolicyHeaders, FileSystemSetAccessPolicyHeaders>;

// @public (undocumented)
export interface FileSystemSetMetadataHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface FileSystemSetMetadataOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type FileSystemSetMetadataResponse = WithResponse<FileSystemSetMetadataHeaders, FileSystemSetMetadataHeaders>;

// @public (undocumented)
export interface FileSystemUndeletePathOption extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type FileSystemUndeletePathResponse = WithResponse<PathUndeleteHeaders & {
    pathClient: DataLakePathClient;
}, PathUndeleteHeaders>;

// @public
export type FileSystemUndeleteResponse = ContainerUndeleteResponse;

// @public (undocumented)
export type FileUploadResponse = WithResponse<PathFlushDataHeaders, PathFlushDataHeaders>;

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateDataLakeSASQueryParameters(dataLakeSASSignatureValues: DataLakeSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateDataLakeSASQueryParameters(dataLakeSASSignatureValues: DataLakeSASSignatureValues, userDelegationKey: UserDelegationKey, accountName: string): SASQueryParameters;

export { Lease }

export { LeaseAccessConditions }

// @public (undocumented)
export type LeaseDurationType = "infinite" | "fixed";

export { LeaseOperationOptions }

export { LeaseOperationResponse }

// @public (undocumented)
export type LeaseStateType = "available" | "leased" | "expired" | "breaking" | "broken";

// @public (undocumented)
export type LeaseStatusType = "locked" | "unlocked";

// @public
export interface ListBlobsHierarchySegmentResponse {
    // (undocumented)
    containerName: string;
    // (undocumented)
    delimiter?: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxResults?: number;
    // (undocumented)
    nextMarker?: string;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    segment: BlobHierarchyListSegment;
    // (undocumented)
    serviceEndpoint: string;
}

// @public (undocumented)
export interface ListDeletedPathsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    prefix?: string;
}

// @public (undocumented)
export interface ListDeletedPathsSegmentOptions extends ListDeletedPathsOptions {
    // (undocumented)
    maxResults?: number;
}

// @public (undocumented)
export interface ListFileSystemsSegmentResponse {
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    fileSystemItems: FileSystemItem[];
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    serviceEndpoint: string;
}

// @public (undocumented)
export interface ListPathsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    path?: string;
    // (undocumented)
    recursive?: boolean;
    // (undocumented)
    userPrincipalName?: boolean;
}

// @public (undocumented)
export interface ListPathsSegmentOptions extends ListPathsOptions {
    // (undocumented)
    maxResults?: number;
}

// @public
export const logger: AzureLogger;

// @public
export interface Metadata {
    // (undocumented)
    [propertyName: string]: string;
}

// @public (undocumented)
export type ModifiedAccessConditions = Omit<ModifiedAccessConditions_3, "ifTags">;

export { newPipeline }

// @public (undocumented)
export interface Path {
    // (undocumented)
    contentLength?: number;
    createdOn?: Date;
    encryptionScope?: string;
    // (undocumented)
    etag?: string;
    expiresOn?: Date;
    // (undocumented)
    group?: string;
    // (undocumented)
    isDirectory?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    name?: string;
    // (undocumented)
    owner?: string;
    // (undocumented)
    permissions?: PathPermissions;
}

// @public (undocumented)
export interface PathAccessControl {
    // (undocumented)
    acl: PathAccessControlItem[];
    // (undocumented)
    group?: string;
    // (undocumented)
    owner?: string;
    // (undocumented)
    permissions?: PathPermissions;
}

// @public (undocumented)
export interface PathAccessControlItem {
    accessControlType: AccessControlType;
    defaultScope: boolean;
    entityId: string;
    permissions: RolePermissions;
}

// @public
export interface PathAppendDataHeaders {
    clientRequestId?: string;
    contentMD5?: Uint8Array;
    date?: Date;
    encryptionKeySha256?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    leaseRenewed?: boolean;
    requestId?: string;
    version?: string;
    xMsContentCrc64?: Uint8Array;
}

// @public
export interface PathChangeAccessControlRecursiveOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    batchSize?: number;
    continuationToken?: string;
    continueOnFailure?: boolean;
    maxBatches?: number;
    onProgress?: (progress: AccessControlChanges) => void;
}

// @public
export interface PathChangeAccessControlRecursiveResponse {
    continuationToken?: string;
    counters: AccessControlChangeCounters;
}

// @public
export interface PathCreateHeaders {
    contentLength?: number;
    continuation?: string;
    date?: Date;
    encryptionKeySha256?: string;
    errorCode?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export interface PathCreateHttpHeaders {
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    // (undocumented)
    contentType?: string;
}

// @public (undocumented)
export interface PathCreateIfNotExistsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    acl?: PathAccessControlItem[];
    customerProvidedKey?: CpkInfo;
    expiresOn?: number | Date;
    group?: string;
    leaseDuration?: number;
    // (undocumented)
    metadata?: Metadata;
    owner?: string;
    // (undocumented)
    pathHttpHeaders?: PathCreateHttpHeaders;
    // (undocumented)
    permissions?: string;
    proposedLeaseId?: string;
    // (undocumented)
    umask?: string;
}

// @public
export interface PathCreateIfNotExistsResponse extends PathCreateResponse {
    succeeded: boolean;
}

// @public (undocumented)
export interface PathCreateOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    acl?: PathAccessControlItem[];
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    customerProvidedKey?: CpkInfo;
    expiresOn?: number | Date;
    group?: string;
    leaseDuration?: number;
    // (undocumented)
    metadata?: Metadata;
    owner?: string;
    // (undocumented)
    pathHttpHeaders?: PathCreateHttpHeaders;
    // (undocumented)
    permissions?: string;
    proposedLeaseId?: string;
    // (undocumented)
    umask?: string;
}

// @public (undocumented)
export type PathCreateResponse = WithResponse<PathCreateHeaders, PathCreateHeaders>;

// @public
export interface PathDeleteHeaders {
    continuation?: string;
    date?: Date;
    deletionId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface PathDeleteIfExistsResponse extends PathDeleteResponse {
    succeeded: boolean;
}

// @public (undocumented)
export interface PathDeleteOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type PathDeleteResponse = WithResponse<PathDeleteHeaders, PathDeleteHeaders>;

// @public
export interface PathExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    customerProvidedKey?: CpkInfo;
}

// @public
export interface PathFlushDataHeaders {
    clientRequestId?: string;
    contentLength?: number;
    date?: Date;
    encryptionKeySha256?: string;
    etag?: string;
    isServerEncrypted?: boolean;
    lastModified?: Date;
    leaseRenewed?: boolean;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export interface PathGetAccessControlHeaders {
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    group?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    owner?: string;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface PathGetAccessControlOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    userPrincipalName?: boolean;
}

// @public (undocumented)
export type PathGetAccessControlResponse = WithResponse<PathAccessControl & PathGetAccessControlHeaders, PathGetPropertiesHeadersModel>;

// @public
export enum PathGetPropertiesAction {
    // (undocumented)
    GetAccessControl = "getAccessControl",
    // (undocumented)
    GetStatus = "getStatus"
}

// @public
export type PathGetPropertiesActionModel = "getAccessControl" | "getStatus";

// @public (undocumented)
export interface PathGetPropertiesHeaders {
    // (undocumented)
    acceptRanges?: string;
    // (undocumented)
    accessTier?: string;
    // (undocumented)
    accessTierChangedOn?: Date;
    // (undocumented)
    accessTierInferred?: boolean;
    // (undocumented)
    archiveStatus?: string;
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    copyCompletedOn?: Date;
    // (undocumented)
    copyId?: string;
    // (undocumented)
    copyProgress?: string;
    // (undocumented)
    copySource?: string;
    // (undocumented)
    copyStatus?: CopyStatusType;
    // (undocumented)
    copyStatusDescription?: string;
    // (undocumented)
    createdOn?: Date;
    // (undocumented)
    date?: Date;
    // (undocumented)
    destinationSnapshot?: string;
    // (undocumented)
    encryptionKeySha256?: string;
    encryptionScope?: string;
    // (undocumented)
    etag?: string;
    expiresOn?: Date;
    // (undocumented)
    isIncrementalCopy?: boolean;
    // (undocumented)
    isServerEncrypted?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface PathGetPropertiesHeadersModel {
    acceptRanges?: string;
    acl?: string;
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: string;
    contentRange?: string;
    contentType?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    group?: string;
    lastModified?: Date;
    leaseDuration?: string;
    leaseState?: string;
    leaseStatus?: string;
    owner?: string;
    permissions?: string;
    properties?: string;
    requestId?: string;
    resourceType?: string;
    version?: string;
}

// @public (undocumented)
export interface PathGetPropertiesOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public (undocumented)
export type PathGetPropertiesResponse = WithResponse<PathGetPropertiesHeaders, PathGetPropertiesHeaders>;

// @public (undocumented)
export interface PathHttpHeaders {
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentType?: string;
}

// @public (undocumented)
export interface PathList {
    // (undocumented)
    pathItems?: Path[];
}

// @public (undocumented)
export interface PathListModel {
    // (undocumented)
    paths?: PathModel[];
}

// @public (undocumented)
export interface PathModel {
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    creationTime?: string;
    encryptionScope?: string;
    // (undocumented)
    etag?: string;
    // (undocumented)
    expiryTime?: string;
    // (undocumented)
    group?: string;
    // (undocumented)
    isDirectory?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    name?: string;
    // (undocumented)
    owner?: string;
    // (undocumented)
    permissions?: string;
}

// @public (undocumented)
export interface PathMoveOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    destinationConditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type PathMoveResponse = WithResponse<PathRemoveHeaders, PathRemoveHeaders>;

// @public (undocumented)
export interface PathPermissions {
    // (undocumented)
    extendedAcls: boolean;
    // (undocumented)
    group: RolePermissions;
    // (undocumented)
    other: RolePermissions;
    // (undocumented)
    owner: RolePermissions;
    // (undocumented)
    stickyBit: boolean;
}

// @public (undocumented)
export interface PathRemoveHeaders {
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export enum PathRenameMode {
    // (undocumented)
    Legacy = "legacy",
    // (undocumented)
    Posix = "posix"
}

// @public
export type PathRenameModeModel = "legacy" | "posix";

// @public
export enum PathResourceType {
    // (undocumented)
    Directory = "directory",
    // (undocumented)
    File = "file"
}

// @public
export type PathResourceTypeModel = "directory" | "file";

// @public
export interface PathSetAccessControlHeaders {
    clientRequestId?: string;
    date?: Date;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export interface PathSetAccessControlOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    group?: string;
    // (undocumented)
    owner?: string;
}

// @public (undocumented)
export type PathSetAccessControlResponse = WithResponse<PathSetAccessControlHeaders, PathSetAccessControlHeaders>;

// @public (undocumented)
export interface PathSetHttpHeadersHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface PathSetHttpHeadersOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type PathSetHttpHeadersResponse = WithResponse<PathSetHttpHeadersHeaders, PathSetHttpHeadersHeaders>;

// @public (undocumented)
export interface PathSetMetadataHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    encryptionKeySha256?: string;
    // (undocumented)
    etag?: string;
    // (undocumented)
    isServerEncrypted?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface PathSetMetadataOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    customerProvidedKey?: CpkInfo;
}

// @public (undocumented)
export type PathSetMetadataResponse = WithResponse<PathSetMetadataHeaders, PathSetMetadataHeaders>;

// @public (undocumented)
export interface PathSetPermissionsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    group?: string;
    // (undocumented)
    owner?: string;
}

// @public (undocumented)
export type PathSetPermissionsResponse = WithResponse<PathSetAccessControlHeaders, PathSetAccessControlHeaders>;

// @public
export interface PathUndeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    requestId?: string;
    resourceType?: string;
    version?: string;
}

// @public
export interface PathUpdateHeaders {
    acceptRanges?: string;
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: string;
    contentRange?: string;
    contentType?: string;
    date?: Date;
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    properties?: string;
    requestId?: string;
    version?: string;
    xMsContinuation?: string;
}

export { Pipeline }

// @public (undocumented)
export type PublicAccessType = "filesystem" | "file";

// @public (undocumented)
export interface RawAccessPolicy {
    // (undocumented)
    expiresOn?: string;
    // (undocumented)
    permissions: string;
    // (undocumented)
    startsOn?: string;
}

// @public (undocumented)
export interface RemovePathAccessControlItem {
    accessControlType: AccessControlType;
    defaultScope: boolean;
    entityId?: string;
}

export { RestError }

// @public (undocumented)
export interface RolePermissions {
    // (undocumented)
    execute: boolean;
    // (undocumented)
    read: boolean;
    // (undocumented)
    write: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string, userDelegationKey?: UserDelegationKey, directoryDepth?: number, preauthorizedAgentObjectId?: string, agentObjectId?: string, correlationId?: string, encryptionScope?: string);
    constructor(version: string, signature: string, options?: SASQueryParametersOptions);
    readonly agentObjectId?: string;
    readonly cacheControl?: string;
    readonly contentDisposition?: string;
    readonly contentEncoding?: string;
    readonly contentLanguage?: string;
    readonly contentType?: string;
    readonly correlationId?: string;
    readonly directoryDepth?: number;
    readonly encryptionScope?: string;
    readonly expiresOn?: Date;
    readonly identifier?: string;
    get ipRange(): SasIPRange | undefined;
    readonly permissions?: string;
    readonly preauthorizedAgentObjectId?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface SASQueryParametersOptions {
    agentObjectId?: string;
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    correlationId?: string;
    directoryDepth?: number;
    encryptionScope?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: string;
    preauthorizedAgentObjectId?: string;
    protocol?: SASProtocol;
    resource?: string;
    resourceTypes?: string;
    services?: string;
    startsOn?: Date;
    userDelegationKey?: UserDelegationKey;
}

// @public
export interface ServiceGenerateAccountSasUrlOptions {
    encryptionScope?: string;
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public (undocumented)
export interface ServiceGetUserDelegationKeyHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface ServiceGetUserDelegationKeyOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type ServiceGetUserDelegationKeyResponse = WithResponse<UserDelegationKey & ServiceGetUserDelegationKeyHeaders, ServiceGetUserDelegationKeyHeaders, UserDelegationKeyModel>;

export { ServiceListContainersSegmentResponse }

// @public (undocumented)
export interface ServiceListFileSystemsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    includeDeleted?: boolean;
    // (undocumented)
    includeMetadata?: boolean;
    // (undocumented)
    prefix?: string;
}

// @public (undocumented)
export interface ServiceListFileSystemsSegmentHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export type ServiceListFileSystemsSegmentResponse = WithResponse<ListFileSystemsSegmentResponse & ServiceListFileSystemsSegmentHeaders, ServiceListFileSystemsSegmentHeaders, ListFileSystemsSegmentResponse>;

// @public
export type ServiceRenameFileSystemOptions = ServiceRenameContainerOptions;

// @public
export interface ServiceUndeleteFileSystemOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    // @deprecated
    destinationFileSystemName?: string;
}

// @public (undocumented)
export interface SignedIdentifier<T> {
    // (undocumented)
    accessPolicy: T;
    // (undocumented)
    id: string;
}

export { StorageBrowserPolicy }

export { StorageBrowserPolicyFactory }

export { StoragePipelineOptions }

export { StorageRetryPolicy }

export { StorageRetryPolicyFactory }

export { StorageSharedKeyCredential }

export { StorageSharedKeyCredentialPolicy }

// @public (undocumented)
export const ToBlobEndpointHostMappings: string[][];

// @public (undocumented)
export const ToDfsEndpointHostMappings: string[][];

// @public (undocumented)
export interface UserDelegationKey {
    // (undocumented)
    signedExpiresOn: Date;
    // (undocumented)
    signedObjectId: string;
    // (undocumented)
    signedService: string;
    // (undocumented)
    signedStartsOn: Date;
    // (undocumented)
    signedTenantId: string;
    // (undocumented)
    signedVersion: string;
    // (undocumented)
    value: string;
}

export { UserDelegationKeyModel }

// (No @packageDocumentation comment for this package)

```
