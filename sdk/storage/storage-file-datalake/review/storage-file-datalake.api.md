## API Report File for "@azure/storage-file-datalake"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { BaseRequestPolicy } from '@azure/core-http';
import { BlobLeaseClient } from '@azure/storage-blob';
import * as coreHttp from '@azure/core-http';
import { deserializationPolicy } from '@azure/core-http';
import { HttpHeaders } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { HttpRequestBody } from '@azure/core-http';
import { HttpResponse } from '@azure/core-http';
import { HttpClient as IHttpClient } from '@azure/core-http';
import { KeepAliveOptions } from '@azure/core-http';
import { Lease } from '@azure/storage-blob';
import { LeaseAccessConditions } from '@azure/storage-blob';
import { LeaseOperationOptions } from '@azure/storage-blob';
import { LeaseOperationResponse } from '@azure/storage-blob';
import { ModifiedAccessConditions as ModifiedAccessConditions_2 } from '@azure/storage-blob';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { Pipeline as Pipeline_2 } from '@azure/storage-blob';
import { ProxyOptions } from '@azure/core-http';
import { Readable } from 'stream';
import { RequestPolicy } from '@azure/core-http';
import { RequestPolicyFactory } from '@azure/core-http';
import { RequestPolicyOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { ServiceListContainersSegmentResponse } from '@azure/storage-blob';
import { TokenCredential } from '@azure/core-http';
import { TransferProgressEvent } from '@azure/core-http';
import { UserAgentOptions } from '@azure/core-http';
import { UserDelegationKeyModel } from '@azure/storage-blob';
import { WebResource } from '@azure/core-http';

// @public (undocumented)
export type AccessControlType = "user" | "group" | "mask" | "other";

// @public (undocumented)
export interface AccessPolicy {
    // (undocumented)
    expiresOn?: Date;
    // (undocumented)
    permissions: string;
    // (undocumented)
    startsOn?: Date;
}

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

export { BaseRequestPolicy }

// @public
export interface CommonOptions {
    tracingOptions?: OperationTracingOptions;
}

// @public (undocumented)
export type CopyStatusType = "pending" | "success" | "aborted" | "failed";

// @public
export abstract class Credential implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;

// @public
export class DataLakeDirectoryClient extends DataLakePathClient {
    create(resourceType: PathResourceType, options?: PathCreateOptions): Promise<PathCreateResponse>;
    create(options?: DirectoryCreateOptions): Promise<DirectoryCreateResponse>;
    createIfNotExists(resourceType: PathResourceType, options?: PathCreateIfNotExistsOptions): Promise<PathCreateIfNotExistsResponse>;
    createIfNotExists(options?: DirectoryCreateIfNotExistsOptions): Promise<DirectoryCreateIfNotExistsResponse>;
    getFileClient(fileName: string): DataLakeFileClient;
    getSubdirectoryClient(subdirectoryName: string): DataLakeDirectoryClient;
}

// @public
export class DataLakeFileClient extends DataLakePathClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    append(body: HttpRequestBody, offset: number, length: number, options?: FileAppendOptions): Promise<FileAppendResponse>;
    create(resourceType: PathResourceType, options?: PathCreateOptions): Promise<PathCreateResponse>;
    create(options?: FileCreateOptions): Promise<FileCreateResponse>;
    createIfNotExists(resourceType: PathResourceType, options?: PathCreateIfNotExistsOptions): Promise<PathCreateIfNotExistsResponse>;
    createIfNotExists(options?: FileCreateIfNotExistsOptions): Promise<FileCreateIfNotExistsResponse>;
    flush(position: number, options?: FileFlushOptions): Promise<PathFlushDataResponse>;
    query(query: string, options?: FileQueryOptions): Promise<FileReadResponse>;
    read(offset?: number, count?: number, options?: FileReadOptions): Promise<FileReadResponse>;
    readToBuffer(buffer: Buffer, offset?: number, count?: number, options?: FileReadToBufferOptions): Promise<Buffer>;
    readToBuffer(offset?: number, count?: number, options?: FileReadToBufferOptions): Promise<Buffer>;
    readToFile(filePath: string, offset?: number, count?: number, options?: FileReadOptions): Promise<FileReadResponse>;
    upload(data: Buffer | Blob | ArrayBuffer | ArrayBufferView, options?: FileParallelUploadOptions): Promise<PathFlushDataResponse>;
    uploadFile(filePath: string, options?: FileParallelUploadOptions): Promise<PathFlushDataResponse>;
    uploadStream(stream: Readable, options?: FileParallelUploadOptions): Promise<PathFlushDataResponse>;
}

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class DataLakeFileSystemClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    create(options?: FileSystemCreateOptions): Promise<FileSystemCreateResponse>;
    createIfNotExists(options?: FileSystemCreateOptions): Promise<FileSystemCreateIfNotExistsResponse>;
    delete(options?: FileSystemDeleteOptions): Promise<FileSystemDeleteResponse>;
    deleteIfExists(options?: FileSystemDeleteOptions): Promise<FileSystemDeleteIfExistsResponse>;
    exists(options?: FileSystemExistsOptions): Promise<boolean>;
    getAccessPolicy(options?: FileSystemGetAccessPolicyOptions): Promise<FileSystemGetAccessPolicyResponse>;
    getDataLakeLeaseClient(proposeLeaseId?: string): DataLakeLeaseClient;
    getDirectoryClient(directoryName: string): DataLakeDirectoryClient;
    getFileClient(fileName: string): DataLakeFileClient;
    getProperties(options?: FileSystemGetPropertiesOptions): Promise<FileSystemGetPropertiesResponse>;
    listPaths(options?: ListPathsOptions): PagedAsyncIterableIterator<Path, FileSystemListPathsResponse>;
    get name(): string;
    setAccessPolicy(access?: PublicAccessType, fileSystemAcl?: SignedIdentifier<AccessPolicy>[], options?: FileSystemSetAccessPolicyOptions): Promise<FileSystemSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: FileSystemSetMetadataOptions): Promise<FileSystemSetMetadataResponse>;
}

// @public (undocumented)
export class DataLakeLeaseClient {
    constructor(client: BlobLeaseClient);
    // (undocumented)
    acquireLease(duration: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    // (undocumented)
    breakLease(breakPeriod: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    // (undocumented)
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    // (undocumented)
    get leaseId(): string;
    // (undocumented)
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    // (undocumented)
    renewLease(options?: LeaseOperationOptions): Promise<Lease>;
    // (undocumented)
    get url(): string;
}

// @public
export class DataLakePathClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    create(resourceType: PathResourceType, options?: PathCreateOptions): Promise<PathCreateResponse>;
    createIfNotExists(resourceType: PathResourceType, options?: PathCreateIfNotExistsOptions): Promise<PathCreateIfNotExistsResponse>;
    delete(recursive?: boolean, options?: PathDeleteOptions): Promise<PathDeleteResponse>;
    deleteIfExists(recursive?: boolean, options?: PathDeleteOptions): Promise<PathDeleteIfExistsResponse>;
    exists(options?: PathExistsOptions): Promise<boolean>;
    get fileSystemName(): string;
    getAccessControl(options?: PathGetAccessControlOptions): Promise<PathGetAccessControlResponse>;
    getDataLakeLeaseClient(proposeLeaseId?: string): DataLakeLeaseClient;
    getProperties(options?: PathGetPropertiesOptions): Promise<PathGetPropertiesResponse>;
    move(destinationPath: string, options?: PathMoveOptions): Promise<PathMoveResponse>;
    move(destinationFileSystem: string, destinationPath: string, options?: PathMoveOptions): Promise<PathMoveResponse>;
    get name(): string;
    setAccessControl(acl: PathAccessControlItem[], options?: PathSetAccessControlOptions): Promise<PathSetAccessControlResponse>;
    setHttpHeaders(httpHeaders: PathHttpHeaders, options?: PathSetHttpHeadersOptions): Promise<PathSetHttpHeadersResponse>;
    setMetadata(metadata?: Metadata, options?: PathSetMetadataOptions): Promise<PathSetMetadataResponse>;
    setPermissions(permissions: PathPermissions, options?: PathSetPermissionsOptions): Promise<PathSetAccessControlResponse>;
    toDirectoryClient(): DataLakeDirectoryClient;
    toFileClient(): DataLakeFileClient;
}

// @public (undocumented)
export interface DataLakeRequestConditions extends ModifiedAccessConditions, LeaseAccessConditions {
}

// @public
export class DataLakeSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    static parse(permissions: string): DataLakeSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public
export interface DataLakeSASSignatureValues {
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    expiresOn?: Date;
    fileSystemName: string;
    identifier?: string;
    ipRange?: SasIPRange;
    pathName?: string;
    permissions?: DataLakeSASPermissions;
    protocol?: SASProtocol;
    snapshotTime?: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class DataLakeServiceClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    getFileSystemClient(fileSystemName: string): DataLakeFileSystemClient;
    getUserDelegationKey(startsOn: Date, expiresOn: Date, options?: ServiceGetUserDelegationKeyOptions): Promise<ServiceGetUserDelegationKeyResponse>;
    listFileSystems(options?: ServiceListFileSystemsOptions): PagedAsyncIterableIterator<FileSystemItem, ServiceListFileSystemsSegmentResponse>;
}

export { deserializationPolicy }

// @public (undocumented)
export interface DirectoryCreateIfNotExistsOptions extends PathCreateIfNotExistsOptions {
}

// @public (undocumented)
export interface DirectoryCreateIfNotExistsResponse extends PathCreateIfNotExistsResponse {
}

// @public
export interface DirectoryCreateOptions extends PathCreateOptions {
}

// @public (undocumented)
export interface DirectoryCreateResponse extends PathCreateResponse {
}

// @public (undocumented)
export interface FileAppendOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: LeaseAccessConditions;
    // (undocumented)
    onProgress?: (progress: TransferProgressEvent) => void;
    // (undocumented)
    transactionalContentMD5?: Uint8Array;
}

// @public
export type FileAppendResponse = PathAppendDataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PathAppendDataHeaders;
    };
};

// @public (undocumented)
export interface FileCreateIfNotExistsOptions extends PathCreateIfNotExistsOptions {
}

// @public (undocumented)
export interface FileCreateIfNotExistsResponse extends PathCreateIfNotExistsResponse {
}

// @public (undocumented)
export interface FileCreateOptions extends PathCreateOptions {
}

// @public (undocumented)
export interface FileCreateResponse extends PathCreateResponse {
}

// @public (undocumented)
export interface FileFlushOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    close?: boolean;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    pathHttpHeaders?: PathHttpHeaders;
    // (undocumented)
    retainUncommittedData?: boolean;
}

// @public
export interface FileParallelUploadOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    chunkSize?: number;
    close?: boolean;
    conditions?: DataLakeRequestConditions;
    maxConcurrency?: number;
    metadata?: Metadata;
    onProgress?: (progress: TransferProgressEvent) => void;
    pathHttpHeaders?: PathHttpHeaders;
    permissions?: string;
    singleUploadThreshold?: number;
    umask?: string;
}

// @public
export interface FileQueryCsvTextConfiguration {
    columnSeparator?: string;
    escapeCharacter?: string;
    fieldQuote?: string;
    hasHeaders?: boolean;
    kind: "csv";
    recordSeparator: string;
}

// @public
export interface FileQueryError {
    description: string;
    isFatal: boolean;
    name: string;
    position: number;
}

// @public
export interface FileQueryJsonTextConfiguration {
    kind: "json";
    recordSeparator: string;
}

// @public
export interface FileQueryOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    conditions?: DataLakeRequestConditions;
    inputTextConfiguration?: FileQueryJsonTextConfiguration | FileQueryCsvTextConfiguration;
    onError?: (error: FileQueryError) => void;
    onProgress?: (progress: TransferProgressEvent) => void;
    outputTextConfiguration?: FileQueryJsonTextConfiguration | FileQueryCsvTextConfiguration;
}

// @public (undocumented)
export interface FileReadHeaders {
    // (undocumented)
    acceptRanges?: string;
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    contentCrc64?: Uint8Array;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentRange?: string;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    copyCompletedOn?: Date;
    // (undocumented)
    copyId?: string;
    // (undocumented)
    copyProgress?: string;
    // (undocumented)
    copySource?: string;
    // (undocumented)
    copyStatus?: CopyStatusType;
    // (undocumented)
    copyStatusDescription?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    encryptionKeySha256?: string;
    // (undocumented)
    etag?: string;
    // (undocumented)
    fileContentMD5?: Uint8Array;
    // (undocumented)
    isServerEncrypted?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface FileReadOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    maxRetryRequests?: number;
    // (undocumented)
    onProgress?: (progress: TransferProgressEvent) => void;
    // (undocumented)
    rangeGetContentCrc64?: boolean;
    // (undocumented)
    rangeGetContentMD5?: boolean;
}

// @public (undocumented)
export type FileReadResponse = FileReadHeaders & {
    contentAsBlob?: Promise<Blob>;
    readableStreamBody?: NodeJS.ReadableStream;
    _response: HttpResponse & {
        parsedHeaders: FileReadHeaders;
    };
};

// @public
export interface FileReadToBufferOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    chunkSize?: number;
    concurrency?: number;
    conditions?: DataLakeRequestConditions;
    maxRetryRequestsPerChunk?: number;
    onProgress?: (progress: TransferProgressEvent) => void;
}

// @public (undocumented)
export interface FileSystemCreateHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface FileSystemCreateIfNotExistsResponse extends FileSystemCreateResponse {
    succeeded: boolean;
}

// @public
export interface FileSystemCreateOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    access?: PublicAccessType;
    // (undocumented)
    metadata?: Metadata;
}

// @public (undocumented)
export type FileSystemCreateResponse = FileSystemCreateHeaders & {
    _response: HttpResponse & {
        parsedHeaders: FileSystemCreateHeaders;
    };
};

// @public (undocumented)
export interface FileSystemDeleteHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface FileSystemDeleteIfExistsResponse extends FileSystemDeleteResponse {
    succeeded: boolean;
}

// @public (undocumented)
export interface FileSystemDeleteOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type FileSystemDeleteResponse = FileSystemDeleteHeaders & {
    _response: HttpResponse & {
        parsedHeaders: FileSystemDeleteHeaders;
    };
};

// @public
export interface FileSystemExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export interface FileSystemGetAccessPolicyHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    publicAccess?: PublicAccessType;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface FileSystemGetAccessPolicyOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: LeaseAccessConditions;
}

// @public (undocumented)
export type FileSystemGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifier<AccessPolicy>[];
} & FileSystemGetAccessPolicyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: FileSystemGetAccessPolicyHeaders;
        bodyAsText: string;
        parsedBody: SignedIdentifier<RawAccessPolicy>[];
    };
};

// @public (undocumented)
export interface FileSystemGetPropertiesHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    hasImmutabilityPolicy?: boolean;
    // (undocumented)
    hasLegalHold?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    publicAccess?: PublicAccessType;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface FileSystemGetPropertiesOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: LeaseAccessConditions;
}

// @public (undocumented)
export type FileSystemGetPropertiesResponse = FileSystemGetPropertiesHeaders & {
    _response: HttpResponse & {
        parsedHeaders: FileSystemGetPropertiesHeaders;
    };
};

// @public (undocumented)
export interface FileSystemItem {
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    name: string;
    // (undocumented)
    properties: FileSystemProperties;
}

// @public
export interface FileSystemListPathsHeaders {
    continuation?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export type FileSystemListPathsResponse = PathList & FileSystemListPathsHeaders & {
    _response: HttpResponse & {
        parsedHeaders: FileSystemListPathsHeaders;
        bodyAsText: string;
        parsedBody: PathListModel;
    };
};

// @public (undocumented)
export interface FileSystemProperties {
    // (undocumented)
    etag: string;
    // (undocumented)
    hasImmutabilityPolicy?: boolean;
    // (undocumented)
    hasLegalHold?: boolean;
    // (undocumented)
    lastModified: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    publicAccess?: PublicAccessType;
}

// @public
export class FileSystemSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): FileSystemSASPermissions;
    read: boolean;
    toString(): string;
    write: boolean;
}

// @public (undocumented)
export interface FileSystemSetAccessPolicyHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface FileSystemSetAccessPolicyOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type FileSystemSetAccessPolicyResponse = FileSystemSetAccessPolicyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: FileSystemSetAccessPolicyHeaders;
    };
};

// @public (undocumented)
export interface FileSystemSetMetadataHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface FileSystemSetMetadataOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type FileSystemSetMetadataResponse = FileSystemSetMetadataHeaders & {
    _response: HttpResponse & {
        parsedHeaders: FileSystemSetMetadataHeaders;
    };
};

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateDataLakeSASQueryParameters(dataLakeSASSignatureValues: DataLakeSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateDataLakeSASQueryParameters(dataLakeSASSignatureValues: DataLakeSASSignatureValues, userDelegationKey: UserDelegationKey, accountName: string): SASQueryParameters;

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

export { IHttpClient }

export { Lease }

export { LeaseAccessConditions }

// @public (undocumented)
export type LeaseDurationType = "infinite" | "fixed";

export { LeaseOperationOptions }

export { LeaseOperationResponse }

// @public (undocumented)
export type LeaseStateType = "available" | "leased" | "expired" | "breaking" | "broken";

// @public (undocumented)
export type LeaseStatusType = "locked" | "unlocked";

// @public (undocumented)
export interface ListFileSystemsSegmentResponse {
    // (undocumented)
    continuationToken?: string;
    // (undocumented)
    fileSystemItems: FileSystemItem[];
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize?: number;
    // (undocumented)
    prefix?: string;
    // (undocumented)
    serviceEndpoint: string;
}

// @public (undocumented)
export interface ListPathsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    path?: string;
    // (undocumented)
    recursive?: boolean;
    // (undocumented)
    userPrincipalName?: boolean;
}

// @public (undocumented)
export interface ListPathsSegmentOptions extends ListPathsOptions {
    // (undocumented)
    maxResults?: number;
}

// @public
export type ListPathsSegmentResponse = PathListModel & FileSystemListPathsHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: FileSystemListPathsHeaders;
        bodyAsText: string;
        parsedBody: PathListModel;
    };
};

// @public
export const logger: import("@azure/logger").AzureLogger;

// @public
export interface Metadata {
    // (undocumented)
    [propertyName: string]: string;
}

// @public (undocumented)
export type ModifiedAccessConditions = Omit<ModifiedAccessConditions_2, "ifTags">;

// @public
export function newPipeline(credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public (undocumented)
export interface Path {
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    etag?: string;
    // (undocumented)
    group?: string;
    // (undocumented)
    isDirectory?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    name?: string;
    // (undocumented)
    owner?: string;
    // (undocumented)
    permissions?: PathPermissions;
}

// @public (undocumented)
export interface PathAccessControl {
    // (undocumented)
    acl: PathAccessControlItem[];
    // (undocumented)
    group?: string;
    // (undocumented)
    owner?: string;
    // (undocumented)
    permissions?: PathPermissions;
}

// @public (undocumented)
export interface PathAccessControlItem {
    // (undocumented)
    accessControlType: AccessControlType;
    // (undocumented)
    defaultScope: boolean;
    // (undocumented)
    entityId: string;
    // (undocumented)
    permissions: RolePermissions;
}

// @public
export interface PathAppendDataHeaders {
    clientRequestId?: string;
    date?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface PathCreateHeaders {
    contentLength?: number;
    continuation?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export interface PathCreateHttpHeaders {
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    // (undocumented)
    contentType?: string;
}

// @public (undocumented)
export interface PathCreateIfNotExistsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    pathHttpHeaders?: PathCreateHttpHeaders;
    // (undocumented)
    permissions?: string;
    // (undocumented)
    umask?: string;
}

// @public
export interface PathCreateIfNotExistsResponse extends PathCreateResponse {
    succeeded: boolean;
}

// @public (undocumented)
export interface PathCreateOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    pathHttpHeaders?: PathCreateHttpHeaders;
    // (undocumented)
    permissions?: string;
    // (undocumented)
    umask?: string;
}

// @public
export type PathCreateResponse = PathCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PathCreateHeaders;
    };
};

// @public
export interface PathDeleteHeaders {
    continuation?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface PathDeleteIfExistsResponse extends PathDeleteResponse {
    succeeded: boolean;
}

// @public (undocumented)
export interface PathDeleteOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public
export type PathDeleteResponse = PathDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PathDeleteHeaders;
    };
};

// @public
export interface PathExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface PathFlushDataHeaders {
    clientRequestId?: string;
    contentLength?: number;
    date?: Date;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public
type PathFlushDataResponse = PathFlushDataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PathFlushDataHeaders;
    };
};

export { PathFlushDataResponse as FileFlushResponse }

export { PathFlushDataResponse as FileUploadResponse }

// @public (undocumented)
export interface PathGetAccessControlHeaders {
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    group?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    owner?: string;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface PathGetAccessControlOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    userPrincipalName?: boolean;
}

// @public (undocumented)
export type PathGetAccessControlResponse = PathAccessControl & PathGetAccessControlHeaders & {
    _response: HttpResponse & {
        parsedHeaders: PathGetPropertiesHeadersModel;
    };
};

// @public
export enum PathGetPropertiesAction {
    // (undocumented)
    GetAccessControl = "getAccessControl",
    // (undocumented)
    GetStatus = "getStatus"
}

// @public (undocumented)
export interface PathGetPropertiesHeaders {
    // (undocumented)
    acceptRanges?: string;
    // (undocumented)
    accessTier?: string;
    // (undocumented)
    accessTierChangedOn?: Date;
    // (undocumented)
    accessTierInferred?: boolean;
    // (undocumented)
    archiveStatus?: string;
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentType?: string;
    // (undocumented)
    copyCompletedOn?: Date;
    // (undocumented)
    copyId?: string;
    // (undocumented)
    copyProgress?: string;
    // (undocumented)
    copySource?: string;
    // (undocumented)
    copyStatus?: CopyStatusType;
    // (undocumented)
    copyStatusDescription?: string;
    // (undocumented)
    createdOn?: Date;
    // (undocumented)
    date?: Date;
    // (undocumented)
    destinationSnapshot?: string;
    // (undocumented)
    encryptionKeySha256?: string;
    // (undocumented)
    etag?: string;
    // (undocumented)
    isIncrementalCopy?: boolean;
    // (undocumented)
    isServerEncrypted?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    leaseDuration?: LeaseDurationType;
    // (undocumented)
    leaseState?: LeaseStateType;
    // (undocumented)
    leaseStatus?: LeaseStatusType;
    // (undocumented)
    metadata?: Metadata;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface PathGetPropertiesHeadersModel {
    acceptRanges?: string;
    acl?: string;
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: string;
    contentRange?: string;
    contentType?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    group?: string;
    lastModified?: Date;
    leaseDuration?: string;
    leaseState?: string;
    leaseStatus?: string;
    owner?: string;
    permissions?: string;
    properties?: string;
    requestId?: string;
    resourceType?: string;
    version?: string;
}

// @public (undocumented)
export interface PathGetPropertiesOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type PathGetPropertiesResponse = PathGetPropertiesHeaders & {
    _response: HttpResponse & {
        parsedHeaders: PathGetPropertiesHeaders;
    };
};

// @public (undocumented)
export interface PathHttpHeaders {
    // (undocumented)
    cacheControl?: string;
    // (undocumented)
    contentDisposition?: string;
    // (undocumented)
    contentEncoding?: string;
    // (undocumented)
    contentLanguage?: string;
    // (undocumented)
    contentMD5?: Uint8Array;
    // (undocumented)
    contentType?: string;
}

// @public (undocumented)
export interface PathList {
    // (undocumented)
    pathItems?: Path[];
}

// @public
export interface PathListModel {
    // (undocumented)
    paths?: PathModel[];
}

// @public
export interface PathModel {
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    etag?: string;
    // (undocumented)
    group?: string;
    isDirectory?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    name?: string;
    // (undocumented)
    owner?: string;
    // (undocumented)
    permissions?: string;
}

// @public (undocumented)
export interface PathMoveOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    destinationConditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type PathMoveResponse = PathRemoveHeaders & {
    _response: HttpResponse & {
        parsedHeaders: PathRemoveHeaders;
    };
};

// @public (undocumented)
export interface PathPermissions {
    // (undocumented)
    extendedAcls: boolean;
    // (undocumented)
    group: RolePermissions;
    // (undocumented)
    other: RolePermissions;
    // (undocumented)
    owner: RolePermissions;
    // (undocumented)
    stickyBit: boolean;
}

// @public (undocumented)
export interface PathRemoveHeaders {
    // (undocumented)
    contentLength?: number;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export enum PathRenameMode {
    // (undocumented)
    Legacy = "legacy",
    // (undocumented)
    Posix = "posix"
}

// @public
export enum PathResourceType {
    // (undocumented)
    Directory = "directory",
    // (undocumented)
    File = "file"
}

// @public
export interface PathSetAccessControlHeaders {
    clientRequestId?: string;
    date?: Date;
    etag?: string;
    lastModified?: Date;
    requestId?: string;
    version?: string;
}

// @public (undocumented)
export interface PathSetAccessControlOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    group?: string;
    // (undocumented)
    owner?: string;
}

// @public
type PathSetAccessControlResponse = PathSetAccessControlHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: PathSetAccessControlHeaders;
    };
};

export { PathSetAccessControlResponse }

export { PathSetAccessControlResponse as PathSetPermissionsResponse }

// @public (undocumented)
export interface PathSetHttpHeadersHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    etag?: string;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface PathSetHttpHeadersOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type PathSetHttpHeadersResponse = PathSetHttpHeadersHeaders & {
    _response: HttpResponse & {
        parsedHeaders: PathSetHttpHeadersHeaders;
    };
};

// @public (undocumented)
export interface PathSetMetadataHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    encryptionKeySha256?: string;
    // (undocumented)
    etag?: string;
    // (undocumented)
    isServerEncrypted?: boolean;
    // (undocumented)
    lastModified?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export interface PathSetMetadataOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
}

// @public (undocumented)
export type PathSetMetadataResponse = PathSetMetadataHeaders & {
    _response: HttpResponse & {
        parsedHeaders: PathSetMetadataHeaders;
    };
};

// @public (undocumented)
export interface PathSetPermissionsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    conditions?: DataLakeRequestConditions;
    // (undocumented)
    group?: string;
    // (undocumented)
    owner?: string;
}

// @public
export interface PathUpdateHeaders {
    acceptRanges?: string;
    cacheControl?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentLength?: number;
    contentMD5?: string;
    contentRange?: string;
    contentType?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    etag?: string;
    lastModified?: Date;
    properties?: string;
    requestId?: string;
    version?: string;
    xMsContinuation?: string;
}

// @public
export class Pipeline extends Pipeline_2 {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: IHttpClient;
}

// @public (undocumented)
export type PublicAccessType = "filesystem" | "file";

// @public (undocumented)
export interface RawAccessPolicy {
    // (undocumented)
    expiresOn?: string;
    // (undocumented)
    permissions: string;
    // (undocumented)
    startsOn?: string;
}

export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

export { RestError }

// @public (undocumented)
export interface RolePermissions {
    // (undocumented)
    execute: boolean;
    // (undocumented)
    read: boolean;
    // (undocumented)
    write: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string, userDelegationKey?: UserDelegationKey);
    readonly cacheControl?: string;
    readonly contentDisposition?: string;
    readonly contentEncoding?: string;
    readonly contentLanguage?: string;
    readonly contentType?: string;
    readonly expiresOn?: Date;
    readonly identifier?: string;
    get ipRange(): SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public (undocumented)
export interface ServiceGetUserDelegationKeyHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    date?: Date;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public
export interface ServiceGetUserDelegationKeyOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type ServiceGetUserDelegationKeyResponse = UserDelegationKey & ServiceGetUserDelegationKeyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ServiceGetUserDelegationKeyHeaders;
        bodyAsText: string;
        parsedBody: UserDelegationKeyModel;
    };
};

export { ServiceListContainersSegmentResponse }

// @public (undocumented)
export interface ServiceListFileSystemsOptions extends CommonOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    includeMetadata?: boolean;
    // (undocumented)
    prefix?: string;
}

// @public (undocumented)
export interface ServiceListFileSystemsSegmentHeaders {
    // (undocumented)
    clientRequestId?: string;
    // (undocumented)
    requestId?: string;
    // (undocumented)
    version?: string;
}

// @public (undocumented)
export type ServiceListFileSystemsSegmentResponse = ListFileSystemsSegmentResponse & ServiceListFileSystemsSegmentHeaders & {
    _response: HttpResponse & {
        parsedHeaders: ServiceListFileSystemsSegmentHeaders;
        bodyAsText: string;
        parsedBody: ListFileSystemsSegmentResponse;
    };
};

// @public (undocumented)
export interface SignedIdentifier<T> {
    // (undocumented)
    accessPolicy: T;
    // (undocumented)
    id: string;
}

// @public
export class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}

// @public
export class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}

// @public (undocumented)
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    httpClient?: IHttpClient;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxyOptions;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentOptions;
}

// @public
export interface StorageRetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: StorageRetryPolicyType;
    readonly secondaryHost?: string;
    readonly tryTimeoutInMs?: number;
}

// @public
export class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions);
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
}

// @public
export class StorageRetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: StorageRetryOptions);
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
    }

// @public
export enum StorageRetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export class StorageSharedKeyCredential extends Credential {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
}

// @public
export class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

// @public (undocumented)
export const ToBlobEndpointHostMappings: string[][];

// @public (undocumented)
export const ToDfsEndpointHostMappings: string[][];

// @public (undocumented)
export interface UserDelegationKey {
    // (undocumented)
    signedExpiresOn: Date;
    // (undocumented)
    signedObjectId: string;
    // (undocumented)
    signedService: string;
    // (undocumented)
    signedStartsOn: Date;
    // (undocumented)
    signedTenantId: string;
    // (undocumented)
    signedVersion: string;
    // (undocumented)
    value: string;
}

export { UserDelegationKeyModel }

export { WebResource }


// (No @packageDocumentation comment for this package)

```
