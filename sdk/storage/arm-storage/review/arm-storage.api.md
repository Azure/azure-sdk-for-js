## API Report File for "@azure/arm-storage"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public (undocumented)
export interface AccessPolicy {
    expiryTime?: Date;
    permission?: string;
    startTime?: Date;
}

// @public
export type AccessTier = "Hot" | "Cool" | "Premium";

// @public
export interface AccountImmutabilityPolicyProperties {
    allowProtectedAppendWrites?: boolean;
    immutabilityPeriodSinceCreationInDays?: number;
    state?: AccountImmutabilityPolicyState;
}

// @public
export type AccountImmutabilityPolicyState = string;

// @public
export interface AccountSasParameters {
    iPAddressOrRange?: string;
    keyToSign?: string;
    permissions: Permissions_2;
    protocols?: HttpProtocol;
    resourceTypes: SignedResourceTypes;
    services: Services;
    sharedAccessExpiryTime: Date;
    sharedAccessStartTime?: Date;
}

// @public
export type AccountStatus = "available" | "unavailable";

// @public
export interface ActiveDirectoryProperties {
    accountType?: ActiveDirectoryPropertiesAccountType;
    azureStorageSid: string;
    domainGuid: string;
    domainName: string;
    domainSid: string;
    forestName: string;
    netBiosDomainName: string;
    samAccountName?: string;
}

// @public
export type ActiveDirectoryPropertiesAccountType = string;

// @public
export type AllowedCopyScope = string;

// @public
export type AzureEntityResource = Resource & {
    readonly etag?: string;
};

// @public
export interface AzureFilesIdentityBasedAuthentication {
    activeDirectoryProperties?: ActiveDirectoryProperties;
    defaultSharePermission?: DefaultSharePermission;
    directoryServiceOptions: DirectoryServiceOptions;
}

// @public
export type BlobContainer = AzureEntityResource & {
    readonly version?: string;
    readonly deleted?: boolean;
    readonly deletedTime?: Date;
    readonly remainingRetentionDays?: number;
    defaultEncryptionScope?: string;
    denyEncryptionScopeOverride?: boolean;
    publicAccess?: PublicAccess;
    readonly lastModifiedTime?: Date;
    readonly leaseStatus?: LeaseStatus;
    readonly leaseState?: LeaseState;
    readonly leaseDuration?: LeaseDuration;
    metadata?: {
        [propertyName: string]: string;
    };
    readonly immutabilityPolicy?: ImmutabilityPolicyProperties;
    readonly legalHold?: LegalHoldProperties;
    readonly hasLegalHold?: boolean;
    readonly hasImmutabilityPolicy?: boolean;
    immutableStorageWithVersioning?: ImmutableStorageWithVersioning;
    enableNfsV3RootSquash?: boolean;
    enableNfsV3AllSquash?: boolean;
};

// @public
export interface BlobContainers {
    beginObjectLevelWorm(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersObjectLevelWormOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginObjectLevelWormAndWait(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersObjectLevelWormOptionalParams): Promise<void>;
    clearLegalHold(resourceGroupName: string, accountName: string, containerName: string, legalHold: LegalHold, options?: BlobContainersClearLegalHoldOptionalParams): Promise<BlobContainersClearLegalHoldResponse>;
    create(resourceGroupName: string, accountName: string, containerName: string, blobContainer: BlobContainer, options?: BlobContainersCreateOptionalParams): Promise<BlobContainersCreateResponse>;
    createOrUpdateImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersCreateOrUpdateImmutabilityPolicyOptionalParams): Promise<BlobContainersCreateOrUpdateImmutabilityPolicyResponse>;
    delete(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersDeleteOptionalParams): Promise<void>;
    deleteImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, ifMatch: string, options?: BlobContainersDeleteImmutabilityPolicyOptionalParams): Promise<BlobContainersDeleteImmutabilityPolicyResponse>;
    extendImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, ifMatch: string, options?: BlobContainersExtendImmutabilityPolicyOptionalParams): Promise<BlobContainersExtendImmutabilityPolicyResponse>;
    get(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersGetOptionalParams): Promise<BlobContainersGetResponse>;
    getImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersGetImmutabilityPolicyOptionalParams): Promise<BlobContainersGetImmutabilityPolicyResponse>;
    lease(resourceGroupName: string, accountName: string, containerName: string, options?: BlobContainersLeaseOptionalParams): Promise<BlobContainersLeaseResponse>;
    list(resourceGroupName: string, accountName: string, options?: BlobContainersListOptionalParams): PagedAsyncIterableIterator<ListContainerItem>;
    lockImmutabilityPolicy(resourceGroupName: string, accountName: string, containerName: string, ifMatch: string, options?: BlobContainersLockImmutabilityPolicyOptionalParams): Promise<BlobContainersLockImmutabilityPolicyResponse>;
    setLegalHold(resourceGroupName: string, accountName: string, containerName: string, legalHold: LegalHold, options?: BlobContainersSetLegalHoldOptionalParams): Promise<BlobContainersSetLegalHoldResponse>;
    update(resourceGroupName: string, accountName: string, containerName: string, blobContainer: BlobContainer, options?: BlobContainersUpdateOptionalParams): Promise<BlobContainersUpdateResponse>;
}

// @public
export interface BlobContainersClearLegalHoldOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobContainersClearLegalHoldResponse = LegalHold;

// @public
export interface BlobContainersCreateOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface BlobContainersCreateOrUpdateImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersCreateOrUpdateImmutabilityPolicyOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    parameters?: ImmutabilityPolicy;
}

// @public
export type BlobContainersCreateOrUpdateImmutabilityPolicyResponse = BlobContainersCreateOrUpdateImmutabilityPolicyHeaders & ImmutabilityPolicy;

// @public
export type BlobContainersCreateResponse = BlobContainer;

// @public
export interface BlobContainersDeleteImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersDeleteImmutabilityPolicyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobContainersDeleteImmutabilityPolicyResponse = BlobContainersDeleteImmutabilityPolicyHeaders & ImmutabilityPolicy;

// @public
export interface BlobContainersDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface BlobContainersExtendImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersExtendImmutabilityPolicyOptionalParams extends coreClient.OperationOptions {
    parameters?: ImmutabilityPolicy;
}

// @public
export type BlobContainersExtendImmutabilityPolicyResponse = BlobContainersExtendImmutabilityPolicyHeaders & ImmutabilityPolicy;

// @public
export interface BlobContainersGetImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersGetImmutabilityPolicyOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
}

// @public
export type BlobContainersGetImmutabilityPolicyResponse = BlobContainersGetImmutabilityPolicyHeaders & ImmutabilityPolicy;

// @public
export interface BlobContainersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobContainersGetResponse = BlobContainer;

// @public
export interface BlobContainersLeaseOptionalParams extends coreClient.OperationOptions {
    parameters?: LeaseContainerRequest;
}

// @public
export type BlobContainersLeaseResponse = LeaseContainerResponse;

// @public
export interface BlobContainersListNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    include?: ListContainersInclude;
    maxpagesize?: string;
}

// @public
export type BlobContainersListNextResponse = ListContainerItems;

// @public
export interface BlobContainersListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    include?: ListContainersInclude;
    maxpagesize?: string;
}

// @public
export type BlobContainersListResponse = ListContainerItems;

// @public
export interface BlobContainersLockImmutabilityPolicyHeaders {
    eTag?: string;
}

// @public
export interface BlobContainersLockImmutabilityPolicyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobContainersLockImmutabilityPolicyResponse = BlobContainersLockImmutabilityPolicyHeaders & ImmutabilityPolicy;

// @public
export interface BlobContainersObjectLevelWormOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BlobContainersSetLegalHoldOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobContainersSetLegalHoldResponse = LegalHold;

// @public
export interface BlobContainersUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobContainersUpdateResponse = BlobContainer;

// @public
export interface BlobInventoryPolicies {
    createOrUpdate(resourceGroupName: string, accountName: string, blobInventoryPolicyName: BlobInventoryPolicyName, properties: BlobInventoryPolicy, options?: BlobInventoryPoliciesCreateOrUpdateOptionalParams): Promise<BlobInventoryPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, blobInventoryPolicyName: BlobInventoryPolicyName, options?: BlobInventoryPoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, blobInventoryPolicyName: BlobInventoryPolicyName, options?: BlobInventoryPoliciesGetOptionalParams): Promise<BlobInventoryPoliciesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: BlobInventoryPoliciesListOptionalParams): PagedAsyncIterableIterator<BlobInventoryPolicy>;
}

// @public
export interface BlobInventoryPoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobInventoryPoliciesCreateOrUpdateResponse = BlobInventoryPolicy;

// @public
export interface BlobInventoryPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface BlobInventoryPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobInventoryPoliciesGetResponse = BlobInventoryPolicy;

// @public
export interface BlobInventoryPoliciesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobInventoryPoliciesListResponse = ListBlobInventoryPolicy;

// @public
export type BlobInventoryPolicy = Resource & {
    readonly systemData?: SystemData;
    readonly lastModifiedTime?: Date;
    policy?: BlobInventoryPolicySchema;
};

// @public
export interface BlobInventoryPolicyDefinition {
    filters?: BlobInventoryPolicyFilter;
    format: Format;
    objectType: ObjectType;
    schedule: Schedule;
    schemaFields: string[];
}

// @public
export interface BlobInventoryPolicyFilter {
    blobTypes?: string[];
    excludePrefix?: string[];
    includeBlobVersions?: boolean;
    includeDeleted?: boolean;
    includeSnapshots?: boolean;
    prefixMatch?: string[];
}

// @public
export type BlobInventoryPolicyName = string;

// @public
export interface BlobInventoryPolicyRule {
    definition: BlobInventoryPolicyDefinition;
    destination: string;
    enabled: boolean;
    name: string;
}

// @public
export interface BlobInventoryPolicySchema {
    readonly destination?: string;
    enabled: boolean;
    rules: BlobInventoryPolicyRule[];
    type: InventoryRuleType;
}

// @public
export interface BlobRestoreParameters {
    blobRanges: BlobRestoreRange[];
    timeToRestore: Date;
}

// @public
export type BlobRestoreProgressStatus = string;

// @public
export interface BlobRestoreRange {
    endRange: string;
    startRange: string;
}

// @public
export interface BlobRestoreStatus {
    readonly failureReason?: string;
    readonly parameters?: BlobRestoreParameters;
    readonly restoreId?: string;
    readonly status?: BlobRestoreProgressStatus;
}

// @public (undocumented)
export interface BlobServiceItems {
    readonly value?: BlobServiceProperties[];
}

// @public
export type BlobServiceProperties = Resource & {
    readonly sku?: Sku;
    cors?: CorsRules;
    defaultServiceVersion?: string;
    deleteRetentionPolicy?: DeleteRetentionPolicy;
    isVersioningEnabled?: boolean;
    automaticSnapshotPolicyEnabled?: boolean;
    changeFeed?: ChangeFeed;
    restorePolicy?: RestorePolicyProperties;
    containerDeleteRetentionPolicy?: DeleteRetentionPolicy;
    lastAccessTimeTrackingPolicy?: LastAccessTimeTrackingPolicy;
};

// @public
export interface BlobServices {
    getServiceProperties(resourceGroupName: string, accountName: string, options?: BlobServicesGetServicePropertiesOptionalParams): Promise<BlobServicesGetServicePropertiesResponse>;
    list(resourceGroupName: string, accountName: string, options?: BlobServicesListOptionalParams): PagedAsyncIterableIterator<BlobServiceProperties>;
    setServiceProperties(resourceGroupName: string, accountName: string, parameters: BlobServiceProperties, options?: BlobServicesSetServicePropertiesOptionalParams): Promise<BlobServicesSetServicePropertiesResponse>;
}

// @public
export interface BlobServicesGetServicePropertiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobServicesGetServicePropertiesResponse = BlobServiceProperties;

// @public
export interface BlobServicesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobServicesListResponse = BlobServiceItems;

// @public
export interface BlobServicesSetServicePropertiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobServicesSetServicePropertiesResponse = BlobServiceProperties;

// @public
export type Bypass = string;

// @public
export interface ChangeFeed {
    enabled?: boolean;
    retentionInDays?: number;
}

// @public
export interface CheckNameAvailabilityResult {
    readonly message?: string;
    readonly nameAvailable?: boolean;
    readonly reason?: Reason;
}

// @public
export interface CloudError {
    error?: CloudErrorBody;
}

// @public
export interface CloudErrorBody {
    code?: string;
    details?: CloudErrorBody[];
    message?: string;
    target?: string;
}

// @public
export interface CorsRule {
    allowedHeaders: string[];
    allowedMethods: CorsRuleAllowedMethodsItem[];
    allowedOrigins: string[];
    exposedHeaders: string[];
    maxAgeInSeconds: number;
}

// @public
export type CorsRuleAllowedMethodsItem = string;

// @public
export interface CorsRules {
    corsRules?: CorsRule[];
}

// @public
export type CreatedByType = string;

// @public
export interface CustomDomain {
    name: string;
    useSubDomainName?: boolean;
}

// @public
export interface DateAfterCreation {
    daysAfterCreationGreaterThan: number;
    daysAfterLastTierChangeGreaterThan?: number;
}

// @public
export interface DateAfterModification {
    daysAfterCreationGreaterThan?: number;
    daysAfterLastAccessTimeGreaterThan?: number;
    daysAfterLastTierChangeGreaterThan?: number;
    daysAfterModificationGreaterThan?: number;
}

// @public
export type DefaultAction = "Allow" | "Deny";

// @public
export type DefaultSharePermission = string;

// @public
export type DeletedAccount = ProxyResource & {
    readonly storageAccountResourceId?: string;
    readonly location?: string;
    readonly restoreReference?: string;
    readonly creationTime?: string;
    readonly deletionTime?: string;
};

// @public
export interface DeletedAccountListResult {
    readonly nextLink?: string;
    readonly value?: DeletedAccount[];
}

// @public
export interface DeletedAccounts {
    get(deletedAccountName: string, location: string, options?: DeletedAccountsGetOptionalParams): Promise<DeletedAccountsGetResponse>;
    list(options?: DeletedAccountsListOptionalParams): PagedAsyncIterableIterator<DeletedAccount>;
}

// @public
export interface DeletedAccountsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DeletedAccountsGetResponse = DeletedAccount;

// @public
export interface DeletedAccountsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DeletedAccountsListNextResponse = DeletedAccountListResult;

// @public
export interface DeletedAccountsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DeletedAccountsListResponse = DeletedAccountListResult;

// @public
export interface DeletedShare {
    deletedShareName: string;
    deletedShareVersion: string;
}

// @public
export interface DeleteRetentionPolicy {
    allowPermanentDelete?: boolean;
    days?: number;
    enabled?: boolean;
}

// @public
export interface Dimension {
    displayName?: string;
    name?: string;
}

// @public
export type DirectoryServiceOptions = string;

// @public
export type DnsEndpointType = string;

// @public
export type EnabledProtocols = string;

// @public
export interface Encryption {
    encryptionIdentity?: EncryptionIdentity;
    keySource: KeySource;
    keyVaultProperties?: KeyVaultProperties;
    requireInfrastructureEncryption?: boolean;
    services?: EncryptionServices;
}

// @public
export interface EncryptionIdentity {
    encryptionFederatedIdentityClientId?: string;
    encryptionUserAssignedIdentity?: string;
}

// @public
export type EncryptionScope = Resource & {
    source?: EncryptionScopeSource;
    state?: EncryptionScopeState;
    readonly creationTime?: Date;
    readonly lastModifiedTime?: Date;
    keyVaultProperties?: EncryptionScopeKeyVaultProperties;
    requireInfrastructureEncryption?: boolean;
};

// @public
export interface EncryptionScopeKeyVaultProperties {
    readonly currentVersionedKeyIdentifier?: string;
    keyUri?: string;
    readonly lastKeyRotationTimestamp?: Date;
}

// @public
export interface EncryptionScopeListResult {
    readonly nextLink?: string;
    readonly value?: EncryptionScope[];
}

// @public
export interface EncryptionScopes {
    get(resourceGroupName: string, accountName: string, encryptionScopeName: string, options?: EncryptionScopesGetOptionalParams): Promise<EncryptionScopesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: EncryptionScopesListOptionalParams): PagedAsyncIterableIterator<EncryptionScope>;
    patch(resourceGroupName: string, accountName: string, encryptionScopeName: string, encryptionScope: EncryptionScope, options?: EncryptionScopesPatchOptionalParams): Promise<EncryptionScopesPatchResponse>;
    put(resourceGroupName: string, accountName: string, encryptionScopeName: string, encryptionScope: EncryptionScope, options?: EncryptionScopesPutOptionalParams): Promise<EncryptionScopesPutResponse>;
}

// @public
export interface EncryptionScopesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesGetResponse = EncryptionScope;

// @public
export interface EncryptionScopesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesListNextResponse = EncryptionScopeListResult;

// @public
export interface EncryptionScopesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesListResponse = EncryptionScopeListResult;

// @public
export type EncryptionScopeSource = string;

// @public
export interface EncryptionScopesPatchOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesPatchResponse = EncryptionScope;

// @public
export interface EncryptionScopesPutOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesPutResponse = EncryptionScope;

// @public
export type EncryptionScopeState = string;

// @public
export interface EncryptionService {
    enabled?: boolean;
    keyType?: KeyType_2;
    readonly lastEnabledTime?: Date;
}

// @public
export interface EncryptionServices {
    blob?: EncryptionService;
    file?: EncryptionService;
    queue?: EncryptionService;
    table?: EncryptionService;
}

// @public
export interface Endpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    internetEndpoints?: StorageAccountInternetEndpoints;
    microsoftEndpoints?: StorageAccountMicrosoftEndpoints;
    readonly queue?: string;
    readonly table?: string;
    readonly web?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorResponseBody;
}

// @public
export interface ErrorResponseBody {
    code?: string;
    message?: string;
}

// @public
export type ExpirationAction = string;

// @public
export interface ExtendedLocation {
    name?: string;
    type?: ExtendedLocationTypes;
}

// @public
export type ExtendedLocationTypes = string;

// @public (undocumented)
export interface FileServiceItems {
    readonly value?: FileServiceProperties[];
}

// @public
export type FileServiceProperties = Resource & {
    readonly sku?: Sku;
    cors?: CorsRules;
    shareDeleteRetentionPolicy?: DeleteRetentionPolicy;
    protocolSettings?: ProtocolSettings;
};

// @public
export interface FileServices {
    getServiceProperties(resourceGroupName: string, accountName: string, options?: FileServicesGetServicePropertiesOptionalParams): Promise<FileServicesGetServicePropertiesResponse>;
    list(resourceGroupName: string, accountName: string, options?: FileServicesListOptionalParams): Promise<FileServicesListResponse>;
    setServiceProperties(resourceGroupName: string, accountName: string, parameters: FileServiceProperties, options?: FileServicesSetServicePropertiesOptionalParams): Promise<FileServicesSetServicePropertiesResponse>;
}

// @public
export interface FileServicesGetServicePropertiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileServicesGetServicePropertiesResponse = FileServiceProperties;

// @public
export interface FileServicesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileServicesListResponse = FileServiceItems;

// @public
export interface FileServicesSetServicePropertiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileServicesSetServicePropertiesResponse = FileServiceProperties;

// @public
export type FileShare = AzureEntityResource & {
    readonly lastModifiedTime?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    shareQuota?: number;
    enabledProtocols?: EnabledProtocols;
    rootSquash?: RootSquashType;
    readonly version?: string;
    readonly deleted?: boolean;
    readonly deletedTime?: Date;
    readonly remainingRetentionDays?: number;
    accessTier?: ShareAccessTier;
    readonly accessTierChangeTime?: Date;
    readonly accessTierStatus?: string;
    readonly shareUsageBytes?: number;
    readonly leaseStatus?: LeaseStatus;
    readonly leaseState?: LeaseState;
    readonly leaseDuration?: LeaseDuration;
    signedIdentifiers?: SignedIdentifier[];
    readonly snapshotTime?: Date;
};

// @public
export type FileShareItem = AzureEntityResource & {
    readonly lastModifiedTime?: Date;
    metadata?: {
        [propertyName: string]: string;
    };
    shareQuota?: number;
    enabledProtocols?: EnabledProtocols;
    rootSquash?: RootSquashType;
    readonly version?: string;
    readonly deleted?: boolean;
    readonly deletedTime?: Date;
    readonly remainingRetentionDays?: number;
    accessTier?: ShareAccessTier;
    readonly accessTierChangeTime?: Date;
    readonly accessTierStatus?: string;
    readonly shareUsageBytes?: number;
    readonly leaseStatus?: LeaseStatus;
    readonly leaseState?: LeaseState;
    readonly leaseDuration?: LeaseDuration;
    signedIdentifiers?: SignedIdentifier[];
    readonly snapshotTime?: Date;
};

// @public
export interface FileShareItems {
    readonly nextLink?: string;
    readonly value?: FileShareItem[];
}

// @public
export interface FileShares {
    create(resourceGroupName: string, accountName: string, shareName: string, fileShare: FileShare, options?: FileSharesCreateOptionalParams): Promise<FileSharesCreateResponse>;
    delete(resourceGroupName: string, accountName: string, shareName: string, options?: FileSharesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, shareName: string, options?: FileSharesGetOptionalParams): Promise<FileSharesGetResponse>;
    lease(resourceGroupName: string, accountName: string, shareName: string, options?: FileSharesLeaseOptionalParams): Promise<FileSharesLeaseResponse>;
    list(resourceGroupName: string, accountName: string, options?: FileSharesListOptionalParams): PagedAsyncIterableIterator<FileShareItem>;
    restore(resourceGroupName: string, accountName: string, shareName: string, deletedShare: DeletedShare, options?: FileSharesRestoreOptionalParams): Promise<void>;
    update(resourceGroupName: string, accountName: string, shareName: string, fileShare: FileShare, options?: FileSharesUpdateOptionalParams): Promise<FileSharesUpdateResponse>;
}

// @public
export interface FileSharesCreateOptionalParams extends coreClient.OperationOptions {
    expand?: string;
}

// @public
export type FileSharesCreateResponse = FileShare;

// @public
export interface FileSharesDeleteOptionalParams extends coreClient.OperationOptions {
    include?: string;
    xMsSnapshot?: string;
}

// @public
export interface FileSharesGetOptionalParams extends coreClient.OperationOptions {
    expand?: string;
    xMsSnapshot?: string;
}

// @public
export type FileSharesGetResponse = FileShare;

// @public
export interface FileSharesLeaseHeaders {
    eTag?: string;
}

// @public
export interface FileSharesLeaseOptionalParams extends coreClient.OperationOptions {
    parameters?: LeaseShareRequest;
    xMsSnapshot?: string;
}

// @public
export type FileSharesLeaseResponse = FileSharesLeaseHeaders & LeaseShareResponse;

// @public
export interface FileSharesListNextOptionalParams extends coreClient.OperationOptions {
    expand?: string;
    filter?: string;
    maxpagesize?: string;
}

// @public
export type FileSharesListNextResponse = FileShareItems;

// @public
export interface FileSharesListOptionalParams extends coreClient.OperationOptions {
    expand?: string;
    filter?: string;
    maxpagesize?: string;
}

// @public
export type FileSharesListResponse = FileShareItems;

// @public
export interface FileSharesRestoreOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface FileSharesUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileSharesUpdateResponse = FileShare;

// @public
export type Format = string;

// @public
export interface GeoReplicationStats {
    readonly canFailover?: boolean;
    readonly lastSyncTime?: Date;
    readonly status?: GeoReplicationStatus;
}

// @public
export type GeoReplicationStatus = string;

// @public
export type HttpProtocol = "https,http" | "https";

// @public
export interface Identity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: IdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentity;
    };
}

// @public
export type IdentityType = string;

// @public
export type ImmutabilityPolicy = AzureEntityResource & {
    immutabilityPeriodSinceCreationInDays?: number;
    readonly state?: ImmutabilityPolicyState;
    allowProtectedAppendWrites?: boolean;
    allowProtectedAppendWritesAll?: boolean;
};

// @public
export interface ImmutabilityPolicyProperties {
    allowProtectedAppendWrites?: boolean;
    allowProtectedAppendWritesAll?: boolean;
    readonly etag?: string;
    immutabilityPeriodSinceCreationInDays?: number;
    readonly state?: ImmutabilityPolicyState;
    readonly updateHistory?: UpdateHistoryProperty[];
}

// @public
export type ImmutabilityPolicyState = string;

// @public
export type ImmutabilityPolicyUpdateType = string;

// @public
export interface ImmutableStorageAccount {
    enabled?: boolean;
    immutabilityPolicy?: AccountImmutabilityPolicyProperties;
}

// @public
export interface ImmutableStorageWithVersioning {
    enabled?: boolean;
    readonly migrationState?: MigrationState;
    readonly timeStamp?: Date;
}

// @public
export type InventoryRuleType = string;

// @public
export interface IPRule {
    action?: "Allow";
    iPAddressOrRange: string;
}

// @public
export interface KeyCreationTime {
    // (undocumented)
    key1?: Date;
    // (undocumented)
    key2?: Date;
}

// @public
export type KeyPermission = "Read" | "Full";

// @public
export interface KeyPolicy {
    keyExpirationPeriodInDays: number;
}

// @public
export type KeySource = string;

// @public
type KeyType_2 = string;
export { KeyType_2 as KeyType }

// @public
export interface KeyVaultProperties {
    readonly currentVersionedKeyExpirationTimestamp?: Date;
    readonly currentVersionedKeyIdentifier?: string;
    keyName?: string;
    keyVaultUri?: string;
    keyVersion?: string;
    readonly lastKeyRotationTimestamp?: Date;
}

// @public
export type Kind = string;

// @public
export enum KnownAccountImmutabilityPolicyState {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Unlocked = "Unlocked"
}

// @public
export enum KnownActiveDirectoryPropertiesAccountType {
    // (undocumented)
    Computer = "Computer",
    // (undocumented)
    User = "User"
}

// @public
export enum KnownAllowedCopyScope {
    // (undocumented)
    AAD = "AAD",
    // (undocumented)
    PrivateLink = "PrivateLink"
}

// @public
export enum KnownBlobInventoryPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export enum KnownBlobRestoreProgressStatus {
    // (undocumented)
    Complete = "Complete",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress"
}

// @public
export enum KnownBypass {
    // (undocumented)
    AzureServices = "AzureServices",
    // (undocumented)
    Logging = "Logging",
    // (undocumented)
    Metrics = "Metrics",
    // (undocumented)
    None = "None"
}

// @public
export enum KnownCorsRuleAllowedMethodsItem {
    // (undocumented)
    Delete = "DELETE",
    // (undocumented)
    GET = "GET",
    // (undocumented)
    Head = "HEAD",
    // (undocumented)
    Merge = "MERGE",
    // (undocumented)
    Options = "OPTIONS",
    // (undocumented)
    Patch = "PATCH",
    // (undocumented)
    Post = "POST",
    // (undocumented)
    PUT = "PUT"
}

// @public
export enum KnownCreatedByType {
    // (undocumented)
    Application = "Application",
    // (undocumented)
    Key = "Key",
    // (undocumented)
    ManagedIdentity = "ManagedIdentity",
    // (undocumented)
    User = "User"
}

// @public
export enum KnownDefaultSharePermission {
    // (undocumented)
    None = "None",
    // (undocumented)
    StorageFileDataSmbShareContributor = "StorageFileDataSmbShareContributor",
    // (undocumented)
    StorageFileDataSmbShareElevatedContributor = "StorageFileDataSmbShareElevatedContributor",
    // (undocumented)
    StorageFileDataSmbShareReader = "StorageFileDataSmbShareReader"
}

// @public
export enum KnownDirectoryServiceOptions {
    // (undocumented)
    Aadds = "AADDS",
    // (undocumented)
    AD = "AD",
    // (undocumented)
    None = "None"
}

// @public
export enum KnownDnsEndpointType {
    // (undocumented)
    AzureDnsZone = "AzureDnsZone",
    // (undocumented)
    Standard = "Standard"
}

// @public
export enum KnownEnabledProtocols {
    // (undocumented)
    NFS = "NFS",
    // (undocumented)
    SMB = "SMB"
}

// @public
export enum KnownEncryptionScopeSource {
    // (undocumented)
    MicrosoftKeyVault = "Microsoft.KeyVault",
    // (undocumented)
    MicrosoftStorage = "Microsoft.Storage"
}

// @public
export enum KnownEncryptionScopeState {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export enum KnownExpirationAction {
    // (undocumented)
    Log = "Log"
}

// @public
export enum KnownExtendedLocationTypes {
    // (undocumented)
    EdgeZone = "EdgeZone"
}

// @public
export enum KnownFormat {
    // (undocumented)
    Csv = "Csv",
    // (undocumented)
    Parquet = "Parquet"
}

// @public
export enum KnownGeoReplicationStatus {
    // (undocumented)
    Bootstrap = "Bootstrap",
    // (undocumented)
    Live = "Live",
    // (undocumented)
    Unavailable = "Unavailable"
}

// @public
export enum KnownIdentityType {
    // (undocumented)
    None = "None",
    // (undocumented)
    SystemAssigned = "SystemAssigned",
    // (undocumented)
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    // (undocumented)
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownImmutabilityPolicyState {
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Unlocked = "Unlocked"
}

// @public
export enum KnownImmutabilityPolicyUpdateType {
    // (undocumented)
    Extend = "extend",
    // (undocumented)
    Lock = "lock",
    // (undocumented)
    Put = "put"
}

// @public
export enum KnownInventoryRuleType {
    // (undocumented)
    Inventory = "Inventory"
}

// @public
export enum KnownKeySource {
    // (undocumented)
    MicrosoftKeyvault = "Microsoft.Keyvault",
    // (undocumented)
    MicrosoftStorage = "Microsoft.Storage"
}

// @public
export enum KnownKeyType {
    // (undocumented)
    Account = "Account",
    // (undocumented)
    Service = "Service"
}

// @public
export enum KnownKind {
    // (undocumented)
    BlobStorage = "BlobStorage",
    // (undocumented)
    BlockBlobStorage = "BlockBlobStorage",
    // (undocumented)
    FileStorage = "FileStorage",
    // (undocumented)
    Storage = "Storage",
    // (undocumented)
    StorageV2 = "StorageV2"
}

// @public
export enum KnownLargeFileSharesState {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export enum KnownLeaseContainerRequestAction {
    // (undocumented)
    Acquire = "Acquire",
    // (undocumented)
    Break = "Break",
    // (undocumented)
    Change = "Change",
    // (undocumented)
    Release = "Release",
    // (undocumented)
    Renew = "Renew"
}

// @public
export enum KnownLeaseDuration {
    // (undocumented)
    Fixed = "Fixed",
    // (undocumented)
    Infinite = "Infinite"
}

// @public
export enum KnownLeaseShareAction {
    // (undocumented)
    Acquire = "Acquire",
    // (undocumented)
    Break = "Break",
    // (undocumented)
    Change = "Change",
    // (undocumented)
    Release = "Release",
    // (undocumented)
    Renew = "Renew"
}

// @public
export enum KnownLeaseState {
    // (undocumented)
    Available = "Available",
    // (undocumented)
    Breaking = "Breaking",
    // (undocumented)
    Broken = "Broken",
    // (undocumented)
    Expired = "Expired",
    // (undocumented)
    Leased = "Leased"
}

// @public
export enum KnownLeaseStatus {
    // (undocumented)
    Locked = "Locked",
    // (undocumented)
    Unlocked = "Unlocked"
}

// @public
export enum KnownListContainersInclude {
    // (undocumented)
    Deleted = "deleted"
}

// @public
export enum KnownManagementPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export enum KnownMigrationState {
    // (undocumented)
    Completed = "Completed",
    // (undocumented)
    InProgress = "InProgress"
}

// @public
export enum KnownMinimumTlsVersion {
    // (undocumented)
    TLS10 = "TLS1_0",
    // (undocumented)
    TLS11 = "TLS1_1",
    // (undocumented)
    TLS12 = "TLS1_2"
}

// @public
export enum KnownName {
    // (undocumented)
    AccessTimeTracking = "AccessTimeTracking"
}

// @public
export enum KnownObjectType {
    // (undocumented)
    Blob = "Blob",
    // (undocumented)
    Container = "Container"
}

// @public
export enum KnownPermissions {
    // (undocumented)
    A = "a",
    // (undocumented)
    C = "c",
    // (undocumented)
    D = "d",
    // (undocumented)
    L = "l",
    // (undocumented)
    P = "p",
    // (undocumented)
    R = "r",
    // (undocumented)
    U = "u",
    // (undocumented)
    W = "w"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export enum KnownPrivateEndpointServiceConnectionStatus {
    // (undocumented)
    Approved = "Approved",
    // (undocumented)
    Pending = "Pending",
    // (undocumented)
    Rejected = "Rejected"
}

// @public
export enum KnownPublicNetworkAccess {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export enum KnownReasonCode {
    // (undocumented)
    NotAvailableForSubscription = "NotAvailableForSubscription",
    // (undocumented)
    QuotaId = "QuotaId"
}

// @public
export enum KnownRootSquashType {
    // (undocumented)
    AllSquash = "AllSquash",
    // (undocumented)
    NoRootSquash = "NoRootSquash",
    // (undocumented)
    RootSquash = "RootSquash"
}

// @public
export enum KnownRoutingChoice {
    // (undocumented)
    InternetRouting = "InternetRouting",
    // (undocumented)
    MicrosoftRouting = "MicrosoftRouting"
}

// @public
export enum KnownRuleType {
    // (undocumented)
    Lifecycle = "Lifecycle"
}

// @public
export enum KnownSchedule {
    // (undocumented)
    Daily = "Daily",
    // (undocumented)
    Weekly = "Weekly"
}

// @public
export enum KnownServices {
    // (undocumented)
    B = "b",
    // (undocumented)
    F = "f",
    // (undocumented)
    Q = "q",
    // (undocumented)
    T = "t"
}

// @public
export enum KnownShareAccessTier {
    // (undocumented)
    Cool = "Cool",
    // (undocumented)
    Hot = "Hot",
    // (undocumented)
    Premium = "Premium",
    // (undocumented)
    TransactionOptimized = "TransactionOptimized"
}

// @public
export enum KnownSignedResource {
    // (undocumented)
    B = "b",
    // (undocumented)
    C = "c",
    // (undocumented)
    F = "f",
    // (undocumented)
    S = "s"
}

// @public
export enum KnownSignedResourceTypes {
    // (undocumented)
    C = "c",
    // (undocumented)
    O = "o",
    // (undocumented)
    S = "s"
}

// @public
export enum KnownSkuConversionStatus {
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export enum KnownSkuName {
    // (undocumented)
    PremiumLRS = "Premium_LRS",
    // (undocumented)
    PremiumZRS = "Premium_ZRS",
    // (undocumented)
    StandardGRS = "Standard_GRS",
    // (undocumented)
    StandardGzrs = "Standard_GZRS",
    // (undocumented)
    StandardLRS = "Standard_LRS",
    // (undocumented)
    StandardRagrs = "Standard_RAGRS",
    // (undocumented)
    StandardRagzrs = "Standard_RAGZRS",
    // (undocumented)
    StandardZRS = "Standard_ZRS"
}

// @public
export enum KnownState {
    // (undocumented)
    Deprovisioning = "Deprovisioning",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    NetworkSourceDeleted = "NetworkSourceDeleted",
    // (undocumented)
    Provisioning = "Provisioning",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export type LargeFileSharesState = string;

// @public
export interface LastAccessTimeTrackingPolicy {
    blobType?: string[];
    enable: boolean;
    name?: Name;
    trackingGranularityInDays?: number;
}

// @public
export interface LeaseContainerRequest {
    action: LeaseContainerRequestAction;
    breakPeriod?: number;
    leaseDuration?: number;
    leaseId?: string;
    proposedLeaseId?: string;
}

// @public
export type LeaseContainerRequestAction = string;

// @public
export interface LeaseContainerResponse {
    leaseId?: string;
    leaseTimeSeconds?: string;
}

// @public
export type LeaseDuration = string;

// @public
export type LeaseShareAction = string;

// @public
export interface LeaseShareRequest {
    action: LeaseShareAction;
    breakPeriod?: number;
    leaseDuration?: number;
    leaseId?: string;
    proposedLeaseId?: string;
}

// @public
export interface LeaseShareResponse {
    leaseId?: string;
    leaseTimeSeconds?: string;
}

// @public
export type LeaseState = string;

// @public
export type LeaseStatus = string;

// @public
export interface LegalHold {
    allowProtectedAppendWritesAll?: boolean;
    readonly hasLegalHold?: boolean;
    tags: string[];
}

// @public
export interface LegalHoldProperties {
    readonly hasLegalHold?: boolean;
    protectedAppendWritesHistory?: ProtectedAppendWritesHistory;
    tags?: TagProperty[];
}

// @public
export interface ListAccountSasResponse {
    readonly accountSasToken?: string;
}

// @public
export interface ListBlobInventoryPolicy {
    readonly value?: BlobInventoryPolicy[];
}

// @public
export type ListContainerItem = AzureEntityResource & {
    readonly version?: string;
    readonly deleted?: boolean;
    readonly deletedTime?: Date;
    readonly remainingRetentionDays?: number;
    defaultEncryptionScope?: string;
    denyEncryptionScopeOverride?: boolean;
    publicAccess?: PublicAccess;
    readonly lastModifiedTime?: Date;
    readonly leaseStatus?: LeaseStatus;
    readonly leaseState?: LeaseState;
    readonly leaseDuration?: LeaseDuration;
    metadata?: {
        [propertyName: string]: string;
    };
    readonly immutabilityPolicy?: ImmutabilityPolicyProperties;
    readonly legalHold?: LegalHoldProperties;
    readonly hasLegalHold?: boolean;
    readonly hasImmutabilityPolicy?: boolean;
    immutableStorageWithVersioning?: ImmutableStorageWithVersioning;
    enableNfsV3RootSquash?: boolean;
    enableNfsV3AllSquash?: boolean;
};

// @public
export interface ListContainerItems {
    readonly nextLink?: string;
    readonly value?: ListContainerItem[];
}

// @public
export type ListContainersInclude = string;

// @public (undocumented)
export type ListQueue = Resource & {
    metadata?: {
        [propertyName: string]: string;
    };
};

// @public
export interface ListQueueResource {
    readonly nextLink?: string;
    readonly value?: ListQueue[];
}

// @public (undocumented)
export interface ListQueueServices {
    readonly value?: QueueServiceProperties[];
}

// @public
export interface ListServiceSasResponse {
    readonly serviceSasToken?: string;
}

// @public
export interface ListTableResource {
    readonly nextLink?: string;
    readonly value?: Table[];
}

// @public (undocumented)
export interface ListTableServices {
    readonly value?: TableServiceProperties[];
}

// @public
export type LocalUser = Resource & {
    readonly systemData?: SystemData;
    permissionScopes?: PermissionScope[];
    homeDirectory?: string;
    sshAuthorizedKeys?: SshPublicKey[];
    readonly sid?: string;
    hasSharedKey?: boolean;
    hasSshKey?: boolean;
    hasSshPassword?: boolean;
};

// @public
export interface LocalUserKeys {
    readonly sharedKey?: string;
    sshAuthorizedKeys?: SshPublicKey[];
}

// @public
export interface LocalUserRegeneratePasswordResult {
    readonly sshPassword?: string;
}

// @public
export interface LocalUsers {
    value?: LocalUser[];
}

// @public
export interface LocalUsersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocalUsersCreateOrUpdateResponse = LocalUser;

// @public
export interface LocalUsersDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface LocalUsersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocalUsersGetResponse = LocalUser;

// @public
export interface LocalUsersListKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocalUsersListKeysResponse = LocalUserKeys;

// @public
export interface LocalUsersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocalUsersListResponse = LocalUsers;

// @public
export interface LocalUsersOperations {
    createOrUpdate(resourceGroupName: string, accountName: string, username: string, properties: LocalUser, options?: LocalUsersCreateOrUpdateOptionalParams): Promise<LocalUsersCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, username: string, options?: LocalUsersDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, username: string, options?: LocalUsersGetOptionalParams): Promise<LocalUsersGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: LocalUsersListOptionalParams): PagedAsyncIterableIterator<LocalUser>;
    listKeys(resourceGroupName: string, accountName: string, username: string, options?: LocalUsersListKeysOptionalParams): Promise<LocalUsersListKeysResponse>;
    regeneratePassword(resourceGroupName: string, accountName: string, username: string, options?: LocalUsersRegeneratePasswordOptionalParams): Promise<LocalUsersRegeneratePasswordResponse>;
}

// @public
export interface LocalUsersRegeneratePasswordOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocalUsersRegeneratePasswordResponse = LocalUserRegeneratePasswordResult;

// @public
export interface ManagementPolicies {
    createOrUpdate(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, properties: ManagementPolicy, options?: ManagementPoliciesCreateOrUpdateOptionalParams): Promise<ManagementPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, options?: ManagementPoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, options?: ManagementPoliciesGetOptionalParams): Promise<ManagementPoliciesGetResponse>;
}

// @public
export interface ManagementPoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagementPoliciesCreateOrUpdateResponse = ManagementPolicy;

// @public
export interface ManagementPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagementPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagementPoliciesGetResponse = ManagementPolicy;

// @public
export type ManagementPolicy = Resource & {
    readonly lastModifiedTime?: Date;
    policy?: ManagementPolicySchema;
};

// @public
export interface ManagementPolicyAction {
    baseBlob?: ManagementPolicyBaseBlob;
    snapshot?: ManagementPolicySnapShot;
    version?: ManagementPolicyVersion;
}

// @public
export interface ManagementPolicyBaseBlob {
    delete?: DateAfterModification;
    enableAutoTierToHotFromCool?: boolean;
    tierToArchive?: DateAfterModification;
    tierToCool?: DateAfterModification;
}

// @public
export interface ManagementPolicyDefinition {
    actions: ManagementPolicyAction;
    filters?: ManagementPolicyFilter;
}

// @public
export interface ManagementPolicyFilter {
    blobIndexMatch?: TagFilter[];
    blobTypes: string[];
    prefixMatch?: string[];
}

// @public
export type ManagementPolicyName = string;

// @public
export interface ManagementPolicyRule {
    definition: ManagementPolicyDefinition;
    enabled?: boolean;
    name: string;
    type: RuleType;
}

// @public
export interface ManagementPolicySchema {
    rules: ManagementPolicyRule[];
}

// @public
export interface ManagementPolicySnapShot {
    delete?: DateAfterCreation;
    tierToArchive?: DateAfterCreation;
    tierToCool?: DateAfterCreation;
}

// @public
export interface ManagementPolicyVersion {
    delete?: DateAfterCreation;
    tierToArchive?: DateAfterCreation;
    tierToCool?: DateAfterCreation;
}

// @public
export interface MetricSpecification {
    aggregationType?: string;
    category?: string;
    dimensions?: Dimension[];
    displayDescription?: string;
    displayName?: string;
    fillGapWithZero?: boolean;
    name?: string;
    resourceIdDimensionNameOverride?: string;
    unit?: string;
}

// @public
export type MigrationState = string;

// @public
export type MinimumTlsVersion = string;

// @public
export interface Multichannel {
    enabled?: boolean;
}

// @public
export type Name = string;

// @public
export interface NetworkRuleSet {
    bypass?: Bypass;
    defaultAction: DefaultAction;
    ipRules?: IPRule[];
    resourceAccessRules?: ResourceAccessRule[];
    virtualNetworkRules?: VirtualNetworkRule[];
}

// @public
export interface ObjectReplicationPolicies {
    value?: ObjectReplicationPolicy[];
}

// @public
export interface ObjectReplicationPoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ObjectReplicationPoliciesCreateOrUpdateResponse = ObjectReplicationPolicy;

// @public
export interface ObjectReplicationPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ObjectReplicationPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ObjectReplicationPoliciesGetResponse = ObjectReplicationPolicy;

// @public
export interface ObjectReplicationPoliciesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ObjectReplicationPoliciesListResponse = ObjectReplicationPolicies;

// @public
export interface ObjectReplicationPoliciesOperations {
    createOrUpdate(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, properties: ObjectReplicationPolicy, options?: ObjectReplicationPoliciesCreateOrUpdateOptionalParams): Promise<ObjectReplicationPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, options?: ObjectReplicationPoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, options?: ObjectReplicationPoliciesGetOptionalParams): Promise<ObjectReplicationPoliciesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: ObjectReplicationPoliciesListOptionalParams): PagedAsyncIterableIterator<ObjectReplicationPolicy>;
}

// @public
export type ObjectReplicationPolicy = Resource & {
    readonly policyId?: string;
    readonly enabledTime?: Date;
    sourceAccount?: string;
    destinationAccount?: string;
    rules?: ObjectReplicationPolicyRule[];
};

// @public
export interface ObjectReplicationPolicyFilter {
    minCreationTime?: string;
    prefixMatch?: string[];
}

// @public
export interface ObjectReplicationPolicyRule {
    destinationContainer: string;
    filters?: ObjectReplicationPolicyFilter;
    ruleId?: string;
    sourceContainer: string;
}

// @public
export type ObjectType = string;

// @public
export interface Operation {
    display?: OperationDisplay;
    name?: string;
    origin?: string;
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationListResult {
    value?: Operation[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
type Permissions_2 = string;
export { Permissions_2 as Permissions }

// @public (undocumented)
export interface PermissionScope {
    permissions: string;
    resourceName: string;
    service: string;
}

// @public
export interface PrivateEndpoint {
    readonly id?: string;
}

// @public
export type PrivateEndpointConnection = Resource & {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
};

// @public
export interface PrivateEndpointConnectionListResult {
    value?: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export interface PrivateEndpointConnections {
    delete(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams): Promise<PrivateEndpointConnectionsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: PrivateEndpointConnectionsListOptionalParams): PagedAsyncIterableIterator<PrivateEndpointConnection>;
    put(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, properties: PrivateEndpointConnection, options?: PrivateEndpointConnectionsPutOptionalParams): Promise<PrivateEndpointConnectionsPutResponse>;
}

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult;

// @public
export interface PrivateEndpointConnectionsPutOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsPutResponse = PrivateEndpointConnection;

// @public
export type PrivateEndpointServiceConnectionStatus = string;

// @public
export type PrivateLinkResource = Resource & {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
};

// @public
export interface PrivateLinkResourceListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkResources {
    listByStorageAccount(resourceGroupName: string, accountName: string, options?: PrivateLinkResourcesListByStorageAccountOptionalParams): Promise<PrivateLinkResourcesListByStorageAccountResponse>;
}

// @public
export interface PrivateLinkResourcesListByStorageAccountOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesListByStorageAccountResponse = PrivateLinkResourceListResult;

// @public
export interface PrivateLinkServiceConnectionState {
    actionRequired?: string;
    description?: string;
    status?: PrivateEndpointServiceConnectionStatus;
}

// @public
export interface ProtectedAppendWritesHistory {
    allowProtectedAppendWritesAll?: boolean;
    readonly timestamp?: Date;
}

// @public
export interface ProtocolSettings {
    smb?: SmbSetting;
}

// @public
export type ProvisioningState = "Creating" | "ResolvingDNS" | "Succeeded";

// @public
export type ProxyResource = Resource;

// @public
export type PublicAccess = "Container" | "Blob" | "None";

// @public
export type PublicNetworkAccess = string;

// @public
export interface Queue {
    create(resourceGroupName: string, accountName: string, queueName: string, queue: StorageQueue, options?: QueueCreateOptionalParams): Promise<QueueCreateResponse>;
    delete(resourceGroupName: string, accountName: string, queueName: string, options?: QueueDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, queueName: string, options?: QueueGetOptionalParams): Promise<QueueGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: QueueListOptionalParams): PagedAsyncIterableIterator<ListQueue>;
    update(resourceGroupName: string, accountName: string, queueName: string, queue: StorageQueue, options?: QueueUpdateOptionalParams): Promise<QueueUpdateResponse>;
}

// @public
export interface QueueCreateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type QueueCreateResponse = StorageQueue;

// @public
export interface QueueDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface QueueGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type QueueGetResponse = StorageQueue;

// @public
export interface QueueListNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type QueueListNextResponse = ListQueueResource;

// @public
export interface QueueListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    maxpagesize?: string;
}

// @public
export type QueueListResponse = ListQueueResource;

// @public
export type QueueServiceProperties = Resource & {
    cors?: CorsRules;
};

// @public
export interface QueueServices {
    getServiceProperties(resourceGroupName: string, accountName: string, options?: QueueServicesGetServicePropertiesOptionalParams): Promise<QueueServicesGetServicePropertiesResponse>;
    list(resourceGroupName: string, accountName: string, options?: QueueServicesListOptionalParams): Promise<QueueServicesListResponse>;
    setServiceProperties(resourceGroupName: string, accountName: string, parameters: QueueServiceProperties, options?: QueueServicesSetServicePropertiesOptionalParams): Promise<QueueServicesSetServicePropertiesResponse>;
}

// @public
export interface QueueServicesGetServicePropertiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type QueueServicesGetServicePropertiesResponse = QueueServiceProperties;

// @public
export interface QueueServicesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type QueueServicesListResponse = ListQueueServices;

// @public
export interface QueueServicesSetServicePropertiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type QueueServicesSetServicePropertiesResponse = QueueServiceProperties;

// @public
export interface QueueUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type QueueUpdateResponse = StorageQueue;

// @public
export type Reason = "AccountNameInvalid" | "AlreadyExists";

// @public
export type ReasonCode = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface ResourceAccessRule {
    resourceId?: string;
    tenantId?: string;
}

// @public
export interface RestorePolicyProperties {
    days?: number;
    enabled: boolean;
    readonly lastEnabledTime?: Date;
    readonly minRestoreTime?: Date;
}

// @public
export interface Restriction {
    reasonCode?: ReasonCode;
    readonly type?: string;
    readonly values?: string[];
}

// @public
export type RootSquashType = string;

// @public
export type RoutingChoice = string;

// @public
export interface RoutingPreference {
    publishInternetEndpoints?: boolean;
    publishMicrosoftEndpoints?: boolean;
    routingChoice?: RoutingChoice;
}

// @public
export type RuleType = string;

// @public
export interface SasPolicy {
    expirationAction: ExpirationAction;
    sasExpirationPeriod: string;
}

// @public
export type Schedule = string;

// @public
export type Services = string;

// @public
export interface ServiceSasParameters {
    cacheControl?: string;
    canonicalizedResource: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    identifier?: string;
    iPAddressOrRange?: string;
    keyToSign?: string;
    partitionKeyEnd?: string;
    partitionKeyStart?: string;
    permissions?: Permissions_2;
    protocols?: HttpProtocol;
    resource?: SignedResource;
    rowKeyEnd?: string;
    rowKeyStart?: string;
    sharedAccessExpiryTime?: Date;
    sharedAccessStartTime?: Date;
}

// @public
export interface ServiceSpecification {
    metricSpecifications?: MetricSpecification[];
}

// @public
export type ShareAccessTier = string;

// @public (undocumented)
export interface SignedIdentifier {
    accessPolicy?: AccessPolicy;
    id?: string;
}

// @public
export type SignedResource = string;

// @public
export type SignedResourceTypes = string;

// @public
export interface Sku {
    name: SkuName;
    readonly tier?: SkuTier;
}

// @public
export interface SKUCapability {
    readonly name?: string;
    readonly value?: string;
}

// @public
export type SkuConversionStatus = string;

// @public
export interface SkuInformation {
    readonly capabilities?: SKUCapability[];
    readonly kind?: Kind;
    readonly locations?: string[];
    name: SkuName;
    readonly resourceType?: string;
    restrictions?: Restriction[];
    readonly tier?: SkuTier;
}

// @public
export type SkuName = string;

// @public
export interface Skus {
    list(options?: SkusListOptionalParams): PagedAsyncIterableIterator<SkuInformation>;
}

// @public
export interface SkusListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SkusListResponse = StorageSkuListResult;

// @public
export type SkuTier = "Standard" | "Premium";

// @public
export interface SmbSetting {
    authenticationMethods?: string;
    channelEncryption?: string;
    kerberosTicketEncryption?: string;
    multichannel?: Multichannel;
    versions?: string;
}

// @public (undocumented)
export interface SshPublicKey {
    description?: string;
    key?: string;
}

// @public
export type State = string;

// @public
export type StorageAccount = TrackedResource & {
    readonly sku?: Sku;
    readonly kind?: Kind;
    identity?: Identity;
    extendedLocation?: ExtendedLocation;
    readonly provisioningState?: ProvisioningState;
    readonly primaryEndpoints?: Endpoints;
    readonly primaryLocation?: string;
    readonly statusOfPrimary?: AccountStatus;
    readonly lastGeoFailoverTime?: Date;
    readonly secondaryLocation?: string;
    readonly statusOfSecondary?: AccountStatus;
    readonly creationTime?: Date;
    readonly customDomain?: CustomDomain;
    readonly sasPolicy?: SasPolicy;
    readonly keyPolicy?: KeyPolicy;
    readonly keyCreationTime?: KeyCreationTime;
    readonly secondaryEndpoints?: Endpoints;
    readonly encryption?: Encryption;
    readonly accessTier?: AccessTier;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    enableHttpsTrafficOnly?: boolean;
    readonly networkRuleSet?: NetworkRuleSet;
    isSftpEnabled?: boolean;
    isLocalUserEnabled?: boolean;
    isHnsEnabled?: boolean;
    readonly geoReplicationStats?: GeoReplicationStats;
    readonly failoverInProgress?: boolean;
    largeFileSharesState?: LargeFileSharesState;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    routingPreference?: RoutingPreference;
    readonly blobRestoreStatus?: BlobRestoreStatus;
    allowBlobPublicAccess?: boolean;
    minimumTlsVersion?: MinimumTlsVersion;
    allowSharedKeyAccess?: boolean;
    enableNfsV3?: boolean;
    allowCrossTenantReplication?: boolean;
    defaultToOAuthAuthentication?: boolean;
    publicNetworkAccess?: PublicNetworkAccess;
    immutableStorageWithVersioning?: ImmutableStorageAccount;
    allowedCopyScope?: AllowedCopyScope;
    storageAccountSkuConversionStatus?: StorageAccountSkuConversionStatus;
    dnsEndpointType?: DnsEndpointType;
};

// @public
export interface StorageAccountCheckNameAvailabilityParameters {
    name: string;
    type: "Microsoft.Storage/storageAccounts";
}

// @public
export interface StorageAccountCreateParameters {
    accessTier?: AccessTier;
    allowBlobPublicAccess?: boolean;
    allowCrossTenantReplication?: boolean;
    allowedCopyScope?: AllowedCopyScope;
    allowSharedKeyAccess?: boolean;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    customDomain?: CustomDomain;
    defaultToOAuthAuthentication?: boolean;
    dnsEndpointType?: DnsEndpointType;
    enableHttpsTrafficOnly?: boolean;
    enableNfsV3?: boolean;
    encryption?: Encryption;
    extendedLocation?: ExtendedLocation;
    identity?: Identity;
    immutableStorageWithVersioning?: ImmutableStorageAccount;
    isHnsEnabled?: boolean;
    isLocalUserEnabled?: boolean;
    isSftpEnabled?: boolean;
    keyPolicy?: KeyPolicy;
    kind: Kind;
    largeFileSharesState?: LargeFileSharesState;
    location: string;
    minimumTlsVersion?: MinimumTlsVersion;
    networkRuleSet?: NetworkRuleSet;
    publicNetworkAccess?: PublicNetworkAccess;
    routingPreference?: RoutingPreference;
    sasPolicy?: SasPolicy;
    sku: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type StorageAccountExpand = "geoReplicationStats" | "blobRestoreStatus";

// @public
export interface StorageAccountInternetEndpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    readonly web?: string;
}

// @public
export interface StorageAccountKey {
    readonly creationTime?: Date;
    readonly keyName?: string;
    readonly permissions?: KeyPermission;
    readonly value?: string;
}

// @public
export interface StorageAccountListKeysResult {
    readonly keys?: StorageAccountKey[];
}

// @public
export interface StorageAccountListResult {
    readonly nextLink?: string;
    readonly value?: StorageAccount[];
}

// @public
export interface StorageAccountMicrosoftEndpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    readonly queue?: string;
    readonly table?: string;
    readonly web?: string;
}

// @public
export interface StorageAccountRegenerateKeyParameters {
    keyName: string;
}

// @public
export interface StorageAccounts {
    beginAbortHierarchicalNamespaceMigration(resourceGroupName: string, accountName: string, options?: StorageAccountsAbortHierarchicalNamespaceMigrationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginAbortHierarchicalNamespaceMigrationAndWait(resourceGroupName: string, accountName: string, options?: StorageAccountsAbortHierarchicalNamespaceMigrationOptionalParams): Promise<void>;
    beginCreate(resourceGroupName: string, accountName: string, parameters: StorageAccountCreateParameters, options?: StorageAccountsCreateOptionalParams): Promise<PollerLike<PollOperationState<StorageAccountsCreateResponse>, StorageAccountsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, parameters: StorageAccountCreateParameters, options?: StorageAccountsCreateOptionalParams): Promise<StorageAccountsCreateResponse>;
    beginFailover(resourceGroupName: string, accountName: string, options?: StorageAccountsFailoverOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginFailoverAndWait(resourceGroupName: string, accountName: string, options?: StorageAccountsFailoverOptionalParams): Promise<void>;
    beginHierarchicalNamespaceMigration(resourceGroupName: string, accountName: string, requestType: string, options?: StorageAccountsHierarchicalNamespaceMigrationOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginHierarchicalNamespaceMigrationAndWait(resourceGroupName: string, accountName: string, requestType: string, options?: StorageAccountsHierarchicalNamespaceMigrationOptionalParams): Promise<void>;
    beginRestoreBlobRanges(resourceGroupName: string, accountName: string, parameters: BlobRestoreParameters, options?: StorageAccountsRestoreBlobRangesOptionalParams): Promise<PollerLike<PollOperationState<StorageAccountsRestoreBlobRangesResponse>, StorageAccountsRestoreBlobRangesResponse>>;
    beginRestoreBlobRangesAndWait(resourceGroupName: string, accountName: string, parameters: BlobRestoreParameters, options?: StorageAccountsRestoreBlobRangesOptionalParams): Promise<StorageAccountsRestoreBlobRangesResponse>;
    checkNameAvailability(accountName: StorageAccountCheckNameAvailabilityParameters, options?: StorageAccountsCheckNameAvailabilityOptionalParams): Promise<StorageAccountsCheckNameAvailabilityResponse>;
    delete(resourceGroupName: string, accountName: string, options?: StorageAccountsDeleteOptionalParams): Promise<void>;
    getProperties(resourceGroupName: string, accountName: string, options?: StorageAccountsGetPropertiesOptionalParams): Promise<StorageAccountsGetPropertiesResponse>;
    list(options?: StorageAccountsListOptionalParams): PagedAsyncIterableIterator<StorageAccount>;
    listAccountSAS(resourceGroupName: string, accountName: string, parameters: AccountSasParameters, options?: StorageAccountsListAccountSASOptionalParams): Promise<StorageAccountsListAccountSASResponse>;
    listByResourceGroup(resourceGroupName: string, options?: StorageAccountsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<StorageAccount>;
    listKeys(resourceGroupName: string, accountName: string, options?: StorageAccountsListKeysOptionalParams): Promise<StorageAccountsListKeysResponse>;
    listServiceSAS(resourceGroupName: string, accountName: string, parameters: ServiceSasParameters, options?: StorageAccountsListServiceSASOptionalParams): Promise<StorageAccountsListServiceSASResponse>;
    regenerateKey(resourceGroupName: string, accountName: string, regenerateKey: StorageAccountRegenerateKeyParameters, options?: StorageAccountsRegenerateKeyOptionalParams): Promise<StorageAccountsRegenerateKeyResponse>;
    revokeUserDelegationKeys(resourceGroupName: string, accountName: string, options?: StorageAccountsRevokeUserDelegationKeysOptionalParams): Promise<void>;
    update(resourceGroupName: string, accountName: string, parameters: StorageAccountUpdateParameters, options?: StorageAccountsUpdateOptionalParams): Promise<StorageAccountsUpdateResponse>;
}

// @public
export interface StorageAccountsAbortHierarchicalNamespaceMigrationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StorageAccountsCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsCheckNameAvailabilityResponse = CheckNameAvailabilityResult;

// @public
export interface StorageAccountsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAccountsCreateResponse = StorageAccount;

// @public
export interface StorageAccountsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface StorageAccountsFailoverOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StorageAccountsGetPropertiesOptionalParams extends coreClient.OperationOptions {
    expand?: StorageAccountExpand;
}

// @public
export type StorageAccountsGetPropertiesResponse = StorageAccount;

// @public
export interface StorageAccountsHierarchicalNamespaceMigrationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StorageAccountSkuConversionStatus {
    readonly endTime?: string;
    readonly skuConversionStatus?: SkuConversionStatus;
    readonly startTime?: string;
    targetSkuName?: SkuName;
}

// @public
export interface StorageAccountsListAccountSASOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListAccountSASResponse = ListAccountSasResponse;

// @public
export interface StorageAccountsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListByResourceGroupNextResponse = StorageAccountListResult;

// @public
export interface StorageAccountsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListByResourceGroupResponse = StorageAccountListResult;

// @public
export interface StorageAccountsListKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListKeysResponse = StorageAccountListKeysResult;

// @public
export interface StorageAccountsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListNextResponse = StorageAccountListResult;

// @public
export interface StorageAccountsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListResponse = StorageAccountListResult;

// @public
export interface StorageAccountsListServiceSASOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListServiceSASResponse = ListServiceSasResponse;

// @public
export interface StorageAccountsRegenerateKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsRegenerateKeyResponse = StorageAccountListKeysResult;

// @public
export interface StorageAccountsRestoreBlobRangesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAccountsRestoreBlobRangesResponse = BlobRestoreStatus;

// @public
export interface StorageAccountsRevokeUserDelegationKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface StorageAccountsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsUpdateResponse = StorageAccount;

// @public
export interface StorageAccountUpdateParameters {
    accessTier?: AccessTier;
    allowBlobPublicAccess?: boolean;
    allowCrossTenantReplication?: boolean;
    allowedCopyScope?: AllowedCopyScope;
    allowSharedKeyAccess?: boolean;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    customDomain?: CustomDomain;
    defaultToOAuthAuthentication?: boolean;
    dnsEndpointType?: DnsEndpointType;
    enableHttpsTrafficOnly?: boolean;
    encryption?: Encryption;
    identity?: Identity;
    immutableStorageWithVersioning?: ImmutableStorageAccount;
    isLocalUserEnabled?: boolean;
    isSftpEnabled?: boolean;
    keyPolicy?: KeyPolicy;
    kind?: Kind;
    largeFileSharesState?: LargeFileSharesState;
    minimumTlsVersion?: MinimumTlsVersion;
    networkRuleSet?: NetworkRuleSet;
    publicNetworkAccess?: PublicNetworkAccess;
    routingPreference?: RoutingPreference;
    sasPolicy?: SasPolicy;
    sku?: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public (undocumented)
export class StorageManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: StorageManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    blobContainers: BlobContainers;
    // (undocumented)
    blobInventoryPolicies: BlobInventoryPolicies;
    // (undocumented)
    blobServices: BlobServices;
    // (undocumented)
    deletedAccounts: DeletedAccounts;
    // (undocumented)
    encryptionScopes: EncryptionScopes;
    // (undocumented)
    fileServices: FileServices;
    // (undocumented)
    fileShares: FileShares;
    // (undocumented)
    localUsersOperations: LocalUsersOperations;
    // (undocumented)
    managementPolicies: ManagementPolicies;
    // (undocumented)
    objectReplicationPoliciesOperations: ObjectReplicationPoliciesOperations;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    queue: Queue;
    // (undocumented)
    queueServices: QueueServices;
    // (undocumented)
    skus: Skus;
    // (undocumented)
    storageAccounts: StorageAccounts;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    tableOperations: TableOperations;
    // (undocumented)
    tableServices: TableServices;
    // (undocumented)
    usages: Usages;
}

// @public
export interface StorageManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public (undocumented)
export type StorageQueue = Resource & {
    metadata?: {
        [propertyName: string]: string;
    };
    readonly approximateMessageCount?: number;
};

// @public
export interface StorageSkuListResult {
    readonly value?: SkuInformation[];
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export type Table = Resource & {
    readonly tableName?: string;
    signedIdentifiers?: TableSignedIdentifier[];
};

// @public
export interface TableAccessPolicy {
    expiryTime?: Date;
    permission: string;
    startTime?: Date;
}

// @public
export interface TableCreateOptionalParams extends coreClient.OperationOptions {
    parameters?: Table;
}

// @public
export type TableCreateResponse = Table;

// @public
export interface TableDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface TableGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TableGetResponse = Table;

// @public
export interface TableListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TableListNextResponse = ListTableResource;

// @public
export interface TableListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TableListResponse = ListTableResource;

// @public
export interface TableOperations {
    create(resourceGroupName: string, accountName: string, tableName: string, options?: TableCreateOptionalParams): Promise<TableCreateResponse>;
    delete(resourceGroupName: string, accountName: string, tableName: string, options?: TableDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, tableName: string, options?: TableGetOptionalParams): Promise<TableGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: TableListOptionalParams): PagedAsyncIterableIterator<Table>;
    update(resourceGroupName: string, accountName: string, tableName: string, options?: TableUpdateOptionalParams): Promise<TableUpdateResponse>;
}

// @public
export type TableServiceProperties = Resource & {
    cors?: CorsRules;
};

// @public
export interface TableServices {
    getServiceProperties(resourceGroupName: string, accountName: string, options?: TableServicesGetServicePropertiesOptionalParams): Promise<TableServicesGetServicePropertiesResponse>;
    list(resourceGroupName: string, accountName: string, options?: TableServicesListOptionalParams): Promise<TableServicesListResponse>;
    setServiceProperties(resourceGroupName: string, accountName: string, parameters: TableServiceProperties, options?: TableServicesSetServicePropertiesOptionalParams): Promise<TableServicesSetServicePropertiesResponse>;
}

// @public
export interface TableServicesGetServicePropertiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TableServicesGetServicePropertiesResponse = TableServiceProperties;

// @public
export interface TableServicesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TableServicesListResponse = ListTableServices;

// @public
export interface TableServicesSetServicePropertiesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TableServicesSetServicePropertiesResponse = TableServiceProperties;

// @public
export interface TableSignedIdentifier {
    accessPolicy?: TableAccessPolicy;
    id: string;
}

// @public
export interface TableUpdateOptionalParams extends coreClient.OperationOptions {
    parameters?: Table;
}

// @public
export type TableUpdateResponse = Table;

// @public
export interface TagFilter {
    name: string;
    op: string;
    value: string;
}

// @public
export interface TagProperty {
    readonly objectIdentifier?: string;
    readonly tag?: string;
    readonly tenantId?: string;
    readonly timestamp?: Date;
    readonly upn?: string;
}

// @public
export type TrackedResource = Resource & {
    tags?: {
        [propertyName: string]: string;
    };
    location: string;
};

// @public
export interface UpdateHistoryProperty {
    allowProtectedAppendWrites?: boolean;
    allowProtectedAppendWritesAll?: boolean;
    readonly immutabilityPeriodSinceCreationInDays?: number;
    readonly objectIdentifier?: string;
    readonly tenantId?: string;
    readonly timestamp?: Date;
    readonly update?: ImmutabilityPolicyUpdateType;
    readonly upn?: string;
}

// @public
export interface Usage {
    readonly currentValue?: number;
    readonly limit?: number;
    readonly name?: UsageName;
    readonly unit?: UsageUnit;
}

// @public
export interface UsageListResult {
    value?: Usage[];
}

// @public
export interface UsageName {
    readonly localizedValue?: string;
    readonly value?: string;
}

// @public
export interface Usages {
    listByLocation(location: string, options?: UsagesListByLocationOptionalParams): PagedAsyncIterableIterator<Usage>;
}

// @public
export interface UsagesListByLocationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type UsagesListByLocationResponse = UsageListResult;

// @public
export type UsageUnit = "Count" | "Bytes" | "Seconds" | "Percent" | "CountsPerSecond" | "BytesPerSecond";

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface VirtualNetworkRule {
    action?: "Allow";
    state?: State;
    virtualNetworkResourceId: string;
}

// (No @packageDocumentation comment for this package)

```
