## API Report File for "@azure/arm-storage-profile-2020-09-01-hybrid"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export type AccessTier = "Hot" | "Cool";

// @public
export interface AccountSasParameters {
    iPAddressOrRange?: string;
    keyToSign?: string;
    permissions: Permissions_2;
    protocols?: HttpProtocol;
    resourceTypes: SignedResourceTypes;
    services: Services;
    sharedAccessExpiryTime: Date;
    sharedAccessStartTime?: Date;
}

// @public
export type AccountStatus = "available" | "unavailable";

// @public
export interface ActiveDirectoryProperties {
    azureStorageSid: string;
    domainGuid: string;
    domainName: string;
    domainSid: string;
    forestName: string;
    netBiosDomainName: string;
}

// @public
export interface AzureFilesIdentityBasedAuthentication {
    activeDirectoryProperties?: ActiveDirectoryProperties;
    directoryServiceOptions: DirectoryServiceOptions;
}

// @public
export interface BlobInventoryPolicies {
    createOrUpdate(resourceGroupName: string, accountName: string, blobInventoryPolicyName: BlobInventoryPolicyName, properties: BlobInventoryPolicy, options?: BlobInventoryPoliciesCreateOrUpdateOptionalParams): Promise<BlobInventoryPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, blobInventoryPolicyName: BlobInventoryPolicyName, options?: BlobInventoryPoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, blobInventoryPolicyName: BlobInventoryPolicyName, options?: BlobInventoryPoliciesGetOptionalParams): Promise<BlobInventoryPoliciesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: BlobInventoryPoliciesListOptionalParams): PagedAsyncIterableIterator<BlobInventoryPolicy>;
}

// @public
export interface BlobInventoryPoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobInventoryPoliciesCreateOrUpdateResponse = BlobInventoryPolicy;

// @public
export interface BlobInventoryPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface BlobInventoryPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobInventoryPoliciesGetResponse = BlobInventoryPolicy;

// @public
export interface BlobInventoryPoliciesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BlobInventoryPoliciesListResponse = ListBlobInventoryPolicy;

// @public
export type BlobInventoryPolicy = Resource & {
    readonly systemData?: SystemData;
    readonly lastModifiedTime?: Date;
    policy?: BlobInventoryPolicySchema;
};

// @public
export interface BlobInventoryPolicyDefinition {
    filters: BlobInventoryPolicyFilter;
}

// @public
export interface BlobInventoryPolicyFilter {
    blobTypes: string[];
    includeBlobVersions?: boolean;
    includeSnapshots?: boolean;
    prefixMatch?: string[];
}

// @public
export type BlobInventoryPolicyName = string;

// @public
export interface BlobInventoryPolicyRule {
    definition: BlobInventoryPolicyDefinition;
    enabled: boolean;
    name: string;
}

// @public
export interface BlobInventoryPolicySchema {
    destination: string;
    enabled: boolean;
    rules: BlobInventoryPolicyRule[];
    type: InventoryRuleType;
}

// @public
export interface BlobRestoreParameters {
    blobRanges: BlobRestoreRange[];
    timeToRestore: Date;
}

// @public
export type BlobRestoreProgressStatus = string;

// @public
export interface BlobRestoreRange {
    endRange: string;
    startRange: string;
}

// @public
export interface BlobRestoreStatus {
    readonly failureReason?: string;
    readonly parameters?: BlobRestoreParameters;
    readonly restoreId?: string;
    readonly status?: BlobRestoreProgressStatus;
}

// @public
export type Bypass = string;

// @public
export interface CheckNameAvailabilityResult {
    readonly message?: string;
    readonly nameAvailable?: boolean;
    readonly reason?: Reason;
}

// @public
export type CreatedByType = string;

// @public
export interface CustomDomain {
    name: string;
    useSubDomainName?: boolean;
}

// @public
export interface DateAfterCreation {
    daysAfterCreationGreaterThan: number;
}

// @public
export interface DateAfterModification {
    daysAfterLastAccessTimeGreaterThan?: number;
    daysAfterModificationGreaterThan?: number;
}

// @public
export type DefaultAction = "Allow" | "Deny";

// @public
export interface Dimension {
    displayName?: string;
    name?: string;
}

// @public
export type DirectoryServiceOptions = string;

// @public
export interface Encryption {
    keySource: KeySource;
    keyVaultProperties?: KeyVaultProperties;
    requireInfrastructureEncryption?: boolean;
    services?: EncryptionServices;
}

// @public
export type EncryptionScope = Resource & {
    source?: EncryptionScopeSource;
    state?: EncryptionScopeState;
    readonly creationTime?: Date;
    readonly lastModifiedTime?: Date;
    keyVaultProperties?: EncryptionScopeKeyVaultProperties;
};

// @public
export interface EncryptionScopeKeyVaultProperties {
    keyUri?: string;
}

// @public
export interface EncryptionScopeListResult {
    readonly nextLink?: string;
    readonly value?: EncryptionScope[];
}

// @public
export interface EncryptionScopes {
    get(resourceGroupName: string, accountName: string, encryptionScopeName: string, options?: EncryptionScopesGetOptionalParams): Promise<EncryptionScopesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: EncryptionScopesListOptionalParams): PagedAsyncIterableIterator<EncryptionScope>;
    patch(resourceGroupName: string, accountName: string, encryptionScopeName: string, encryptionScope: EncryptionScope, options?: EncryptionScopesPatchOptionalParams): Promise<EncryptionScopesPatchResponse>;
    put(resourceGroupName: string, accountName: string, encryptionScopeName: string, encryptionScope: EncryptionScope, options?: EncryptionScopesPutOptionalParams): Promise<EncryptionScopesPutResponse>;
}

// @public
export interface EncryptionScopesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesGetResponse = EncryptionScope;

// @public
export interface EncryptionScopesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesListNextResponse = EncryptionScopeListResult;

// @public
export interface EncryptionScopesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesListResponse = EncryptionScopeListResult;

// @public
export type EncryptionScopeSource = string;

// @public
export interface EncryptionScopesPatchOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesPatchResponse = EncryptionScope;

// @public
export interface EncryptionScopesPutOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EncryptionScopesPutResponse = EncryptionScope;

// @public
export type EncryptionScopeState = string;

// @public
export interface EncryptionService {
    enabled?: boolean;
    keyType?: KeyType_2;
    readonly lastEnabledTime?: Date;
}

// @public
export interface EncryptionServices {
    blob?: EncryptionService;
    file?: EncryptionService;
    queue?: EncryptionService;
    table?: EncryptionService;
}

// @public
export interface Endpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    internetEndpoints?: StorageAccountInternetEndpoints;
    microsoftEndpoints?: StorageAccountMicrosoftEndpoints;
    readonly queue?: string;
    readonly table?: string;
    readonly web?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorResponseBody;
}

// @public
export interface ErrorResponseBody {
    code?: string;
    message?: string;
}

// @public
export interface GeoReplicationStats {
    readonly canFailover?: boolean;
    readonly lastSyncTime?: Date;
    readonly status?: GeoReplicationStatus;
}

// @public
export type GeoReplicationStatus = string;

// @public
export type HttpProtocol = "https,http" | "https";

// @public
export interface Identity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: "SystemAssigned";
}

// @public
export type InventoryRuleType = string;

// @public
export interface IPRule {
    action?: "Allow";
    iPAddressOrRange: string;
}

// @public
export type KeyPermission = "Read" | "Full";

// @public
export type KeySource = string;

// @public
type KeyType_2 = string;
export { KeyType_2 as KeyType }

// @public
export interface KeyVaultProperties {
    readonly currentVersionedKeyIdentifier?: string;
    keyName?: string;
    keyVaultUri?: string;
    keyVersion?: string;
    readonly lastKeyRotationTimestamp?: Date;
}

// @public
export type Kind = string;

// @public
export enum KnownBlobInventoryPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export enum KnownBlobRestoreProgressStatus {
    // (undocumented)
    Complete = "Complete",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress"
}

// @public
export enum KnownBypass {
    // (undocumented)
    AzureServices = "AzureServices",
    // (undocumented)
    Logging = "Logging",
    // (undocumented)
    Metrics = "Metrics",
    // (undocumented)
    None = "None"
}

// @public
export enum KnownCreatedByType {
    // (undocumented)
    Application = "Application",
    // (undocumented)
    Key = "Key",
    // (undocumented)
    ManagedIdentity = "ManagedIdentity",
    // (undocumented)
    User = "User"
}

// @public
export enum KnownDirectoryServiceOptions {
    // (undocumented)
    Aadds = "AADDS",
    // (undocumented)
    AD = "AD",
    // (undocumented)
    None = "None"
}

// @public
export enum KnownEncryptionScopeSource {
    // (undocumented)
    MicrosoftKeyVault = "Microsoft.KeyVault",
    // (undocumented)
    MicrosoftStorage = "Microsoft.Storage"
}

// @public
export enum KnownEncryptionScopeState {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export enum KnownGeoReplicationStatus {
    // (undocumented)
    Bootstrap = "Bootstrap",
    // (undocumented)
    Live = "Live",
    // (undocumented)
    Unavailable = "Unavailable"
}

// @public
export enum KnownInventoryRuleType {
    // (undocumented)
    Inventory = "Inventory"
}

// @public
export enum KnownKeySource {
    // (undocumented)
    MicrosoftKeyvault = "Microsoft.Keyvault",
    // (undocumented)
    MicrosoftStorage = "Microsoft.Storage"
}

// @public
export enum KnownKeyType {
    // (undocumented)
    Account = "Account",
    // (undocumented)
    Service = "Service"
}

// @public
export enum KnownKind {
    // (undocumented)
    BlobStorage = "BlobStorage",
    // (undocumented)
    BlockBlobStorage = "BlockBlobStorage",
    // (undocumented)
    FileStorage = "FileStorage",
    // (undocumented)
    Storage = "Storage",
    // (undocumented)
    StorageV2 = "StorageV2"
}

// @public
export enum KnownLargeFileSharesState {
    // (undocumented)
    Disabled = "Disabled",
    // (undocumented)
    Enabled = "Enabled"
}

// @public
export enum KnownManagementPolicyName {
    // (undocumented)
    Default = "default"
}

// @public
export enum KnownMinimumTlsVersion {
    // (undocumented)
    TLS10 = "TLS1_0",
    // (undocumented)
    TLS11 = "TLS1_1",
    // (undocumented)
    TLS12 = "TLS1_2"
}

// @public
export enum KnownPermissions {
    // (undocumented)
    A = "a",
    // (undocumented)
    C = "c",
    // (undocumented)
    D = "d",
    // (undocumented)
    L = "l",
    // (undocumented)
    P = "p",
    // (undocumented)
    R = "r",
    // (undocumented)
    U = "u",
    // (undocumented)
    W = "w"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    Succeeded = "Succeeded"
}

// @public
export enum KnownPrivateEndpointServiceConnectionStatus {
    // (undocumented)
    Approved = "Approved",
    // (undocumented)
    Pending = "Pending",
    // (undocumented)
    Rejected = "Rejected"
}

// @public
export enum KnownReasonCode {
    // (undocumented)
    NotAvailableForSubscription = "NotAvailableForSubscription",
    // (undocumented)
    QuotaId = "QuotaId"
}

// @public
export enum KnownRoutingChoice {
    // (undocumented)
    InternetRouting = "InternetRouting",
    // (undocumented)
    MicrosoftRouting = "MicrosoftRouting"
}

// @public
export enum KnownRuleType {
    // (undocumented)
    Lifecycle = "Lifecycle"
}

// @public
export enum KnownServices {
    // (undocumented)
    B = "b",
    // (undocumented)
    F = "f",
    // (undocumented)
    Q = "q",
    // (undocumented)
    T = "t"
}

// @public
export enum KnownSignedResource {
    // (undocumented)
    B = "b",
    // (undocumented)
    C = "c",
    // (undocumented)
    F = "f",
    // (undocumented)
    S = "s"
}

// @public
export enum KnownSignedResourceTypes {
    // (undocumented)
    C = "c",
    // (undocumented)
    O = "o",
    // (undocumented)
    S = "s"
}

// @public
export enum KnownSkuName {
    // (undocumented)
    PremiumLRS = "Premium_LRS",
    // (undocumented)
    PremiumZRS = "Premium_ZRS",
    // (undocumented)
    StandardGRS = "Standard_GRS",
    // (undocumented)
    StandardGzrs = "Standard_GZRS",
    // (undocumented)
    StandardLRS = "Standard_LRS",
    // (undocumented)
    StandardRagrs = "Standard_RAGRS",
    // (undocumented)
    StandardRagzrs = "Standard_RAGZRS",
    // (undocumented)
    StandardZRS = "Standard_ZRS"
}

// @public
export type LargeFileSharesState = string;

// @public
export interface ListAccountSasResponse {
    readonly accountSasToken?: string;
}

// @public
export interface ListBlobInventoryPolicy {
    readonly value?: BlobInventoryPolicy[];
}

// @public
export interface ListServiceSasResponse {
    readonly serviceSasToken?: string;
}

// @public
export interface ManagementPolicies {
    createOrUpdate(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, properties: ManagementPolicy, options?: ManagementPoliciesCreateOrUpdateOptionalParams): Promise<ManagementPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, options?: ManagementPoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, managementPolicyName: ManagementPolicyName, options?: ManagementPoliciesGetOptionalParams): Promise<ManagementPoliciesGetResponse>;
}

// @public
export interface ManagementPoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagementPoliciesCreateOrUpdateResponse = ManagementPolicy;

// @public
export interface ManagementPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagementPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagementPoliciesGetResponse = ManagementPolicy;

// @public
export type ManagementPolicy = Resource & {
    readonly lastModifiedTime?: Date;
    policy?: ManagementPolicySchema;
};

// @public
export interface ManagementPolicyAction {
    baseBlob?: ManagementPolicyBaseBlob;
    snapshot?: ManagementPolicySnapShot;
    version?: ManagementPolicyVersion;
}

// @public
export interface ManagementPolicyBaseBlob {
    delete?: DateAfterModification;
    enableAutoTierToHotFromCool?: boolean;
    tierToArchive?: DateAfterModification;
    tierToCool?: DateAfterModification;
}

// @public
export interface ManagementPolicyDefinition {
    actions: ManagementPolicyAction;
    filters?: ManagementPolicyFilter;
}

// @public
export interface ManagementPolicyFilter {
    blobIndexMatch?: TagFilter[];
    blobTypes: string[];
    prefixMatch?: string[];
}

// @public
export type ManagementPolicyName = string;

// @public
export interface ManagementPolicyRule {
    definition: ManagementPolicyDefinition;
    enabled?: boolean;
    name: string;
    type: RuleType;
}

// @public
export interface ManagementPolicySchema {
    rules: ManagementPolicyRule[];
}

// @public
export interface ManagementPolicySnapShot {
    delete?: DateAfterCreation;
    tierToArchive?: DateAfterCreation;
    tierToCool?: DateAfterCreation;
}

// @public
export interface ManagementPolicyVersion {
    delete?: DateAfterCreation;
    tierToArchive?: DateAfterCreation;
    tierToCool?: DateAfterCreation;
}

// @public
export interface MetricSpecification {
    aggregationType?: string;
    category?: string;
    dimensions?: Dimension[];
    displayDescription?: string;
    displayName?: string;
    fillGapWithZero?: boolean;
    name?: string;
    resourceIdDimensionNameOverride?: string;
    unit?: string;
}

// @public
export type MinimumTlsVersion = string;

// @public
export interface NetworkRuleSet {
    bypass?: Bypass;
    defaultAction: DefaultAction;
    ipRules?: IPRule[];
    virtualNetworkRules?: VirtualNetworkRule[];
}

// @public
export interface ObjectReplicationPolicies {
    value?: ObjectReplicationPolicy[];
}

// @public
export interface ObjectReplicationPoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ObjectReplicationPoliciesCreateOrUpdateResponse = ObjectReplicationPolicy;

// @public
export interface ObjectReplicationPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ObjectReplicationPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ObjectReplicationPoliciesGetResponse = ObjectReplicationPolicy;

// @public
export interface ObjectReplicationPoliciesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ObjectReplicationPoliciesListResponse = ObjectReplicationPolicies;

// @public
export interface ObjectReplicationPoliciesOperations {
    createOrUpdate(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, properties: ObjectReplicationPolicy, options?: ObjectReplicationPoliciesCreateOrUpdateOptionalParams): Promise<ObjectReplicationPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, options?: ObjectReplicationPoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, objectReplicationPolicyId: string, options?: ObjectReplicationPoliciesGetOptionalParams): Promise<ObjectReplicationPoliciesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: ObjectReplicationPoliciesListOptionalParams): PagedAsyncIterableIterator<ObjectReplicationPolicy>;
}

// @public
export type ObjectReplicationPolicy = Resource & {
    readonly policyId?: string;
    readonly enabledTime?: Date;
    sourceAccount?: string;
    destinationAccount?: string;
    rules?: ObjectReplicationPolicyRule[];
};

// @public
export interface ObjectReplicationPolicyFilter {
    minCreationTime?: string;
    prefixMatch?: string[];
}

// @public
export interface ObjectReplicationPolicyRule {
    destinationContainer: string;
    filters?: ObjectReplicationPolicyFilter;
    ruleId?: string;
    sourceContainer: string;
}

// @public
export interface Operation {
    display?: OperationDisplay;
    name?: string;
    origin?: string;
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationListResult {
    value?: Operation[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
type Permissions_2 = string;
export { Permissions_2 as Permissions }

// @public
export interface PrivateEndpoint {
    readonly id?: string;
}

// @public
export type PrivateEndpointConnection = Resource & {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
};

// @public
export interface PrivateEndpointConnectionListResult {
    value?: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export interface PrivateEndpointConnections {
    delete(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams): Promise<PrivateEndpointConnectionsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: PrivateEndpointConnectionsListOptionalParams): PagedAsyncIterableIterator<PrivateEndpointConnection>;
    put(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, properties: PrivateEndpointConnection, options?: PrivateEndpointConnectionsPutOptionalParams): Promise<PrivateEndpointConnectionsPutResponse>;
}

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult;

// @public
export interface PrivateEndpointConnectionsPutOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsPutResponse = PrivateEndpointConnection;

// @public
export type PrivateEndpointServiceConnectionStatus = string;

// @public
export type PrivateLinkResource = Resource & {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
};

// @public
export interface PrivateLinkResourceListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkResources {
    listByStorageAccount(resourceGroupName: string, accountName: string, options?: PrivateLinkResourcesListByStorageAccountOptionalParams): Promise<PrivateLinkResourcesListByStorageAccountResponse>;
}

// @public
export interface PrivateLinkResourcesListByStorageAccountOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesListByStorageAccountResponse = PrivateLinkResourceListResult;

// @public
export interface PrivateLinkServiceConnectionState {
    actionRequired?: string;
    description?: string;
    status?: PrivateEndpointServiceConnectionStatus;
}

// @public
export type ProvisioningState = "Creating" | "ResolvingDNS" | "Succeeded";

// @public
export type Reason = "AccountNameInvalid" | "AlreadyExists";

// @public
export type ReasonCode = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface Restriction {
    reasonCode?: ReasonCode;
    readonly type?: string;
    readonly values?: string[];
}

// @public
export type RoutingChoice = string;

// @public
export interface RoutingPreference {
    publishInternetEndpoints?: boolean;
    publishMicrosoftEndpoints?: boolean;
    routingChoice?: RoutingChoice;
}

// @public
export type RuleType = string;

// @public
export type Services = string;

// @public
export interface ServiceSasParameters {
    cacheControl?: string;
    canonicalizedResource: string;
    contentDisposition?: string;
    contentEncoding?: string;
    contentLanguage?: string;
    contentType?: string;
    identifier?: string;
    iPAddressOrRange?: string;
    keyToSign?: string;
    partitionKeyEnd?: string;
    partitionKeyStart?: string;
    permissions?: Permissions_2;
    protocols?: HttpProtocol;
    resource?: SignedResource;
    rowKeyEnd?: string;
    rowKeyStart?: string;
    sharedAccessExpiryTime?: Date;
    sharedAccessStartTime?: Date;
}

// @public
export interface ServiceSpecification {
    metricSpecifications?: MetricSpecification[];
}

// @public
export type SignedResource = string;

// @public
export type SignedResourceTypes = string;

// @public
export interface Sku {
    name: SkuName;
    readonly tier?: SkuTier;
}

// @public
export interface SKUCapability {
    readonly name?: string;
    readonly value?: string;
}

// @public
export interface SkuInformation {
    readonly capabilities?: SKUCapability[];
    readonly kind?: Kind;
    readonly locations?: string[];
    name: SkuName;
    readonly resourceType?: string;
    restrictions?: Restriction[];
    readonly tier?: SkuTier;
}

// @public
export type SkuName = string;

// @public
export interface Skus {
    list(options?: SkusListOptionalParams): PagedAsyncIterableIterator<SkuInformation>;
}

// @public
export interface SkusListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SkusListResponse = StorageSkuListResult;

// @public
export type SkuTier = "Standard" | "Premium";

// @public
export type State = "provisioning" | "deprovisioning" | "succeeded" | "failed" | "networkSourceDeleted";

// @public
export type StorageAccount = TrackedResource & {
    readonly sku?: Sku;
    readonly kind?: Kind;
    identity?: Identity;
    readonly provisioningState?: ProvisioningState;
    readonly primaryEndpoints?: Endpoints;
    readonly primaryLocation?: string;
    readonly statusOfPrimary?: AccountStatus;
    readonly lastGeoFailoverTime?: Date;
    readonly secondaryLocation?: string;
    readonly statusOfSecondary?: AccountStatus;
    readonly creationTime?: Date;
    readonly customDomain?: CustomDomain;
    readonly secondaryEndpoints?: Endpoints;
    readonly encryption?: Encryption;
    readonly accessTier?: AccessTier;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    enableHttpsTrafficOnly?: boolean;
    readonly networkRuleSet?: NetworkRuleSet;
    isHnsEnabled?: boolean;
    readonly geoReplicationStats?: GeoReplicationStats;
    readonly failoverInProgress?: boolean;
    largeFileSharesState?: LargeFileSharesState;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    routingPreference?: RoutingPreference;
    readonly blobRestoreStatus?: BlobRestoreStatus;
    allowBlobPublicAccess?: boolean;
    minimumTlsVersion?: MinimumTlsVersion;
    allowSharedKeyAccess?: boolean;
};

// @public
export interface StorageAccountCheckNameAvailabilityParameters {
    name: string;
    type: "Microsoft.Storage/storageAccounts";
}

// @public
export interface StorageAccountCreateParameters {
    accessTier?: AccessTier;
    allowBlobPublicAccess?: boolean;
    allowSharedKeyAccess?: boolean;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    customDomain?: CustomDomain;
    enableHttpsTrafficOnly?: boolean;
    encryption?: Encryption;
    identity?: Identity;
    isHnsEnabled?: boolean;
    kind: Kind;
    largeFileSharesState?: LargeFileSharesState;
    location: string;
    minimumTlsVersion?: MinimumTlsVersion;
    networkRuleSet?: NetworkRuleSet;
    routingPreference?: RoutingPreference;
    sku: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type StorageAccountExpand = "geoReplicationStats" | "blobRestoreStatus";

// @public
export interface StorageAccountInternetEndpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    readonly web?: string;
}

// @public
export interface StorageAccountKey {
    readonly keyName?: string;
    readonly permissions?: KeyPermission;
    readonly value?: string;
}

// @public
export interface StorageAccountListKeysResult {
    readonly keys?: StorageAccountKey[];
}

// @public
export interface StorageAccountListResult {
    readonly nextLink?: string;
    readonly value?: StorageAccount[];
}

// @public
export interface StorageAccountMicrosoftEndpoints {
    readonly blob?: string;
    readonly dfs?: string;
    readonly file?: string;
    readonly queue?: string;
    readonly table?: string;
    readonly web?: string;
}

// @public
export interface StorageAccountRegenerateKeyParameters {
    keyName: string;
}

// @public
export interface StorageAccounts {
    beginCreate(resourceGroupName: string, accountName: string, parameters: StorageAccountCreateParameters, options?: StorageAccountsCreateOptionalParams): Promise<PollerLike<PollOperationState<StorageAccountsCreateResponse>, StorageAccountsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, parameters: StorageAccountCreateParameters, options?: StorageAccountsCreateOptionalParams): Promise<StorageAccountsCreateResponse>;
    beginFailover(resourceGroupName: string, accountName: string, options?: StorageAccountsFailoverOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginFailoverAndWait(resourceGroupName: string, accountName: string, options?: StorageAccountsFailoverOptionalParams): Promise<void>;
    beginRestoreBlobRanges(resourceGroupName: string, accountName: string, parameters: BlobRestoreParameters, options?: StorageAccountsRestoreBlobRangesOptionalParams): Promise<PollerLike<PollOperationState<StorageAccountsRestoreBlobRangesResponse>, StorageAccountsRestoreBlobRangesResponse>>;
    beginRestoreBlobRangesAndWait(resourceGroupName: string, accountName: string, parameters: BlobRestoreParameters, options?: StorageAccountsRestoreBlobRangesOptionalParams): Promise<StorageAccountsRestoreBlobRangesResponse>;
    checkNameAvailability(accountName: StorageAccountCheckNameAvailabilityParameters, options?: StorageAccountsCheckNameAvailabilityOptionalParams): Promise<StorageAccountsCheckNameAvailabilityResponse>;
    delete(resourceGroupName: string, accountName: string, options?: StorageAccountsDeleteOptionalParams): Promise<void>;
    getProperties(resourceGroupName: string, accountName: string, options?: StorageAccountsGetPropertiesOptionalParams): Promise<StorageAccountsGetPropertiesResponse>;
    list(options?: StorageAccountsListOptionalParams): PagedAsyncIterableIterator<StorageAccount>;
    listAccountSAS(resourceGroupName: string, accountName: string, parameters: AccountSasParameters, options?: StorageAccountsListAccountSASOptionalParams): Promise<StorageAccountsListAccountSASResponse>;
    listByResourceGroup(resourceGroupName: string, options?: StorageAccountsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<StorageAccount>;
    listKeys(resourceGroupName: string, accountName: string, options?: StorageAccountsListKeysOptionalParams): Promise<StorageAccountsListKeysResponse>;
    listServiceSAS(resourceGroupName: string, accountName: string, parameters: ServiceSasParameters, options?: StorageAccountsListServiceSASOptionalParams): Promise<StorageAccountsListServiceSASResponse>;
    regenerateKey(resourceGroupName: string, accountName: string, regenerateKey: StorageAccountRegenerateKeyParameters, options?: StorageAccountsRegenerateKeyOptionalParams): Promise<StorageAccountsRegenerateKeyResponse>;
    revokeUserDelegationKeys(resourceGroupName: string, accountName: string, options?: StorageAccountsRevokeUserDelegationKeysOptionalParams): Promise<void>;
    update(resourceGroupName: string, accountName: string, parameters: StorageAccountUpdateParameters, options?: StorageAccountsUpdateOptionalParams): Promise<StorageAccountsUpdateResponse>;
}

// @public
export interface StorageAccountsCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsCheckNameAvailabilityResponse = CheckNameAvailabilityResult;

// @public
export interface StorageAccountsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAccountsCreateResponse = StorageAccount;

// @public
export interface StorageAccountsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface StorageAccountsFailoverOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StorageAccountsGetPropertiesOptionalParams extends coreClient.OperationOptions {
    expand?: StorageAccountExpand;
}

// @public
export type StorageAccountsGetPropertiesResponse = StorageAccount;

// @public
export interface StorageAccountsListAccountSASOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListAccountSASResponse = ListAccountSasResponse;

// @public
export interface StorageAccountsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListByResourceGroupResponse = StorageAccountListResult;

// @public
export interface StorageAccountsListKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListKeysResponse = StorageAccountListKeysResult;

// @public
export interface StorageAccountsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListNextResponse = StorageAccountListResult;

// @public
export interface StorageAccountsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListResponse = StorageAccountListResult;

// @public
export interface StorageAccountsListServiceSASOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListServiceSASResponse = ListServiceSasResponse;

// @public
export interface StorageAccountsRegenerateKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsRegenerateKeyResponse = StorageAccountListKeysResult;

// @public
export interface StorageAccountsRestoreBlobRangesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAccountsRestoreBlobRangesResponse = BlobRestoreStatus;

// @public
export interface StorageAccountsRevokeUserDelegationKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface StorageAccountsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsUpdateResponse = StorageAccount;

// @public
export interface StorageAccountUpdateParameters {
    accessTier?: AccessTier;
    allowBlobPublicAccess?: boolean;
    allowSharedKeyAccess?: boolean;
    azureFilesIdentityBasedAuthentication?: AzureFilesIdentityBasedAuthentication;
    customDomain?: CustomDomain;
    enableHttpsTrafficOnly?: boolean;
    encryption?: Encryption;
    identity?: Identity;
    kind?: Kind;
    largeFileSharesState?: LargeFileSharesState;
    minimumTlsVersion?: MinimumTlsVersion;
    networkRuleSet?: NetworkRuleSet;
    routingPreference?: RoutingPreference;
    sku?: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public (undocumented)
export class StorageManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: StorageManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    blobInventoryPolicies: BlobInventoryPolicies;
    // (undocumented)
    encryptionScopes: EncryptionScopes;
    // (undocumented)
    managementPolicies: ManagementPolicies;
    // (undocumented)
    objectReplicationPoliciesOperations: ObjectReplicationPoliciesOperations;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    skus: Skus;
    // (undocumented)
    storageAccounts: StorageAccounts;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    usages: Usages;
}

// @public
export interface StorageManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface StorageSkuListResult {
    readonly value?: SkuInformation[];
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TagFilter {
    name: string;
    op: string;
    value: string;
}

// @public
export type TrackedResource = Resource & {
    tags?: {
        [propertyName: string]: string;
    };
    location: string;
};

// @public
export interface Usage {
    readonly currentValue?: number;
    readonly limit?: number;
    readonly name?: UsageName;
    readonly unit?: UsageUnit;
}

// @public
export interface UsageListResult {
    value?: Usage[];
}

// @public
export interface UsageName {
    readonly localizedValue?: string;
    readonly value?: string;
}

// @public
export interface Usages {
    listByLocation(location: string, options?: UsagesListByLocationOptionalParams): PagedAsyncIterableIterator<Usage>;
}

// @public
export interface UsagesListByLocationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type UsagesListByLocationResponse = UsageListResult;

// @public
export type UsageUnit = "Count" | "Bytes" | "Seconds" | "Percent" | "CountsPerSecond" | "BytesPerSecond";

// @public
export interface VirtualNetworkRule {
    action?: "Allow";
    state?: State;
    virtualNetworkResourceId: string;
}

// (No @packageDocumentation comment for this package)

```
