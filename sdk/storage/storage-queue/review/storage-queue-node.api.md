## API Report File for "@azure/storage-queue"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import { AnonymousCredential } from '@azure/storage-common';
import { AnonymousCredentialPolicy } from '@azure/storage-common';
import { AzureLogger } from '@azure/logger';
import { BaseRequestPolicy } from '@azure/storage-common';
import * as coreClient from '@azure/core-client';
import * as coreHttpCompat from '@azure/core-http-compat';
import { Credential as Credential_2 } from '@azure/storage-common';
import { CredentialPolicy } from '@azure/storage-common';
import { HttpHeadersLike as HttpHeaders } from '@azure/core-http-compat';
import { CompatResponse as HttpOperationResponse } from '@azure/core-http-compat';
import { RequestBodyType as HttpRequestBody } from '@azure/core-rest-pipeline';
import type { KeepAliveOptions } from '@azure/core-http-compat';
import type { OperationTracingOptions } from '@azure/core-tracing';
import type { PagedAsyncIterableIterator } from '@azure/core-paging';
import type { ProxySettings } from '@azure/core-rest-pipeline';
import { RequestPolicy } from '@azure/core-http-compat';
import { RequestPolicyFactory } from '@azure/core-http-compat';
import { RequestPolicyOptionsLike as RequestPolicyOptions } from '@azure/core-http-compat';
import { RestError } from '@azure/core-rest-pipeline';
import { StorageBrowserPolicyFactory } from '@azure/storage-common';
import { StorageRetryOptions } from '@azure/storage-common';
import { StorageRetryPolicy } from '@azure/storage-common';
import { StorageRetryPolicyFactory } from '@azure/storage-common';
import { StorageRetryPolicyType } from '@azure/storage-common';
import { StorageSharedKeyCredential } from '@azure/storage-common';
import { StorageSharedKeyCredentialPolicy } from '@azure/storage-common';
import type { TokenCredential } from '@azure/core-auth';
import type { UserAgentPolicyOptions } from '@azure/core-rest-pipeline';
import { UserDelegationKey as UserDelegationKey_2 } from '@azure/storage-common';
import { WebResourceLike as WebResource } from '@azure/core-http-compat';

// @public
export interface AccessPolicy {
    expiresOn?: string;
    permissions?: string;
    startsOn?: string;
}

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

export { AnonymousCredential }

export { AnonymousCredentialPolicy }

export { BaseRequestPolicy }

// @public
export interface CommonOptions {
    tracingOptions?: OperationTracingOptions;
}

// @public
export interface CorsRule {
    allowedHeaders: string;
    allowedMethods: string;
    allowedOrigins: string;
    exposedHeaders: string;
    maxAgeInSeconds: number;
}

export { Credential_2 as Credential }

export { CredentialPolicy }

// @public
export interface DequeuedMessageItem {
    dequeueCount: number;
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    messageText: string;
    nextVisibleOn: Date;
    popReceipt: string;
}

// @public
export interface EnqueuedMessage {
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    nextVisibleOn: Date;
    popReceipt: string;
}

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateQueueSASQueryParameters(queueSASSignatureValues: QueueSASSignatureValues, userDelegationKey: UserDelegationKey, accountName: string): SASQueryParameters;

// @public (undocumented)
export function generateQueueSASQueryParameters(queueSASSignatureValues: QueueSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export interface GeoReplication {
    lastSyncOn: Date;
    status: GeoReplicationStatusType;
}

// @public
export type GeoReplicationStatusType = "live" | "bootstrap" | "unavailable";

// @public
export function getQueueServiceAccountAudience(storageAccountName: string): string;

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

// @public
export interface HttpResponse {
    headers: HttpHeaders;
    request: WebResource;
    status: number;
}

// @public
export function isPipelineLike(pipeline: unknown): pipeline is PipelineLike;

// @public
export type ListQueuesIncludeType = "metadata";

// @public
export interface ListQueuesSegmentResponse {
    // (undocumented)
    continuationToken: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize: number;
    // (undocumented)
    prefix: string;
    // (undocumented)
    queueItems?: QueueItem[];
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export const logger: AzureLogger;

// @public
export interface Logging {
    deleteProperty: boolean;
    read: boolean;
    retentionPolicy: RetentionPolicy;
    version: string;
    write: boolean;
}

// @public
export interface MessageIdDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessageIdDeleteResponse = WithResponse<MessageIdDeleteHeaders, MessageIdDeleteHeaders>;

// @public
export interface MessageIdUpdateHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    nextVisibleOn?: Date;
    popReceipt?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessageIdUpdateResponse = WithResponse<MessageIdUpdateHeaders, MessageIdUpdateHeaders>;

// @public
export interface MessagesClearHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessagesClearResponse = WithResponse<MessagesClearHeaders, MessagesClearHeaders>;

// @public
export interface MessagesDequeueHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesDequeueOptionalParams extends CommonOptions {
    numberOfMessages?: number;
    requestId?: string;
    timeoutInSeconds?: number;
    visibilityTimeout?: number;
}

// @public
export interface MessagesEnqueueHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesEnqueueOptionalParams extends CommonOptions {
    messageTimeToLive?: number;
    requestId?: string;
    timeoutInSeconds?: number;
    visibilityTimeout?: number;
}

// @public
export interface MessagesPeekHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesPeekOptionalParams extends CommonOptions {
    numberOfMessages?: number;
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export interface Metadata {
    [propertyName: string]: string;
}

// @public
export interface Metrics {
    enabled: boolean;
    includeAPIs?: boolean;
    retentionPolicy?: RetentionPolicy;
    version?: string;
}

// @public
export function newPipeline(credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export interface PeekedMessageItem {
    dequeueCount: number;
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    messageText: string;
}

// @public
export class Pipeline implements PipelineLike {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineLike {
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: RequestPolicy;
}

// @public
export interface QueueClearMessagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueClearMessagesResponse = MessagesClearResponse;

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class QueueClient extends StorageClient {
    constructor(connectionString: string, queueName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    clearMessages(options?: QueueClearMessagesOptions): Promise<QueueClearMessagesResponse>;
    create(options?: QueueCreateOptions): Promise<QueueCreateResponse>;
    createIfNotExists(options?: QueueCreateOptions): Promise<QueueCreateIfNotExistsResponse>;
    delete(options?: QueueDeleteOptions): Promise<QueueDeleteResponse>;
    deleteIfExists(options?: QueueDeleteOptions): Promise<QueueDeleteIfExistsResponse>;
    deleteMessage(messageId: string, popReceipt: string, options?: QueueDeleteMessageOptions): Promise<QueueDeleteMessageResponse>;
    exists(options?: QueueExistsOptions): Promise<boolean>;
    generateSasStringToSign(options: QueueGenerateSasUrlOptions): string;
    generateSasUrl(options: QueueGenerateSasUrlOptions): string;
    generateUserDelegationSasUrl(options: QueueGenerateSasUrlOptions, userDelegationKey: UserDelegationKey): string;
    generateUserDelegationStringToSign(options: QueueGenerateSasUrlOptions, userDelegationKey: UserDelegationKey): string;
    getAccessPolicy(options?: QueueGetAccessPolicyOptions): Promise<QueueGetAccessPolicyResponse>;
    getProperties(options?: QueueGetPropertiesOptions): Promise<QueueGetPropertiesResponse>;
    get name(): string;
    peekMessages(options?: QueuePeekMessagesOptions): Promise<QueuePeekMessagesResponse>;
    receiveMessages(options?: QueueReceiveMessageOptions): Promise<QueueReceiveMessageResponse>;
    sendMessage(messageText: string, options?: QueueSendMessageOptions): Promise<QueueSendMessageResponse>;
    setAccessPolicy(queueAcl?: SignedIdentifier[], options?: QueueSetAccessPolicyOptions): Promise<QueueSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: QueueSetMetadataOptions): Promise<QueueSetMetadataResponse>;
    updateMessage(messageId: string, popReceipt: string, message?: string, visibilityTimeout?: number, options?: QueueUpdateMessageOptions): Promise<QueueUpdateMessageResponse>;
}

// @public
export interface QueueCreateHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueCreateIfNotExistsResponse extends QueueCreateResponse {
    succeeded: boolean;
}

// @public
export interface QueueCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: Metadata;
}

// @public
export type QueueCreateResponse = WithResponse<QueueCreateHeaders, QueueCreateHeaders>;

// @public
export interface QueueDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueDeleteIfExistsResponse extends QueueDeleteResponse {
    succeeded: boolean;
}

// @public
export interface QueueDeleteMessageOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueDeleteMessageResponse = MessageIdDeleteResponse;

// @public
export interface QueueDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueDeleteResponse = WithResponse<QueueDeleteHeaders, QueueDeleteHeaders>;

// @public
export interface QueueExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface QueueGenerateSasUrlOptions {
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: QueueSASPermissions;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface QueueGetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueGetAccessPolicyResponse = WithResponse<{
    signedIdentifiers: SignedIdentifier[];
} & QueueGetAccessPolicyHeaders, QueueGetAccessPolicyHeaders, SignedIdentifierModel[]>;

// @public
export interface QueueGetPropertiesHeaders {
    approximateMessagesCount?: number;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface QueueGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueGetPropertiesResponse = WithResponse<QueueGetPropertiesHeaders, QueueGetPropertiesHeaders>;

// @public
export interface QueueItem {
    metadata?: {
        [propertyName: string]: string;
    };
    name: string;
}

// @public
export interface QueuePeekMessagesOptions extends MessagesPeekOptionalParams, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueuePeekMessagesResponse = WithResponse<{
    peekedMessageItems: PeekedMessageItem[];
} & MessagesPeekHeaders, MessagesPeekHeaders, PeekedMessageItem[]>;

// @public
export interface QueueReceiveMessageOptions extends MessagesDequeueOptionalParams, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueReceiveMessageResponse = WithResponse<{
    receivedMessageItems: ReceivedMessageItem[];
} & MessagesDequeueHeaders, MessagesDequeueHeaders, ReceivedMessageItem[]>;

// @public
export class QueueSASPermissions {
    add: boolean;
    static parse(permissions: string): QueueSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
}

// @public
export interface QueueSASSignatureValues {
    delegatedUserObjectId?: string;
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: QueueSASPermissions;
    protocol?: SASProtocol;
    queueName: string;
    startsOn?: Date;
    version?: string;
}

// @public
export interface QueueSendMessageOptions extends MessagesEnqueueOptionalParams, CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueSendMessageResponse = WithResponse<{
    messageId: string;
    popReceipt: string;
    insertedOn: Date;
    expiresOn: Date;
    nextVisibleOn: Date;
} & MessagesEnqueueHeaders, MessagesEnqueueHeaders, EnqueuedMessage[]>;

// @public
export class QueueServiceClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createQueue(queueName: string, options?: QueueCreateOptions): Promise<QueueCreateResponse>;
    deleteQueue(queueName: string, options?: QueueDeleteOptions): Promise<QueueDeleteResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): QueueServiceClient;
    generateAccountSasUrl(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
    generateSasStringToSign(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getQueueClient(queueName: string): QueueClient;
    getStatistics(options?: ServiceGetStatisticsOptions): Promise<ServiceGetStatisticsResponse>;
    getUserDelegationKey(startsOn: Date, expiresOn: Date, options?: ServiceGetUserDelegationKeyOptions): Promise<ServiceGetUserDelegationKeyResponse>;
    listQueues(options?: ServiceListQueuesOptions): PagedAsyncIterableIterator<QueueItem, ServiceListQueuesSegmentResponse>;
    setProperties(properties: QueueServiceProperties, options?: ServiceGetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
}

// @public
export interface QueueServiceProperties {
    cors?: CorsRule[];
    hourMetrics?: Metrics;
    minuteMetrics?: Metrics;
    queueAnalyticsLogging?: Logging;
}

// @public
export interface QueueServiceStatistics {
    geoReplication?: GeoReplication;
}

// @public
export interface QueueSetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueSetAccessPolicyResponse = WithResponse<QueueSetAccessPolicyHeaders, QueueSetAccessPolicyHeaders>;

// @public
export interface QueueSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueSetMetadataResponse = WithResponse<QueueSetMetadataHeaders, QueueSetMetadataHeaders>;

// @public
export interface QueueUpdateMessageOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueUpdateMessageResponse = MessageIdUpdateResponse;

// @public
export type ReceivedMessageItem = DequeuedMessageItem;

export { RequestPolicy as IHttpClient }
export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

// @public
export interface ResponseLike {
    _response: HttpResponse;
}

// @public
export interface ResponseWithBody<Headers, Body> {
    _response: HttpResponse & {
        parsedHeaders: Headers;
        bodyAsText: string;
        parsedBody: Body;
    };
}

// @public
export interface ResponseWithHeaders<Headers> {
    _response: HttpResponse & {
        parsedHeaders: Headers;
    };
}

export { RestError }

// @public
export interface RetentionPolicy {
    days?: number;
    enabled: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, userDelegationKey?: UserDelegationKey_2, delegatedUserObjectId?: string);
    readonly delegatedUserObjectId?: string;
    readonly expiresOn?: Date;
    readonly identifier?: string;
    get ipRange(): SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface ServiceClientOptions {
    httpClient?: RequestPolicy;
    requestPolicyFactories?: RequestPolicyFactory[] | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);
}

// @public
export interface ServiceGenerateAccountSasUrlOptions {
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface ServiceGetPropertiesHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetPropertiesResponse = WithResponse<ServiceGetPropertiesHeaders & QueueServiceProperties, ServiceGetPropertiesHeaders, QueueServiceProperties>;

// @public
export interface ServiceGetStatisticsHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetStatisticsResponse = WithResponse<ServiceGetStatisticsHeaders & QueueServiceStatistics, ServiceGetStatisticsHeaders, QueueServiceStatistics>;

// @public
export interface ServiceGetUserDelegationKeyHeaders {
    clientRequestId?: string;
    date?: Date;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetUserDelegationKeyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetUserDelegationKeyResponse = WithResponse<UserDelegationKey & ServiceGetUserDelegationKeyHeaders, ServiceGetUserDelegationKeyHeaders, UserDelegationKeyModel>;

// @public
export type ServiceGetUserDelegationKeyResponseModel = ServiceGetUserDelegationKeyHeaders & UserDelegationKeyModel;

// @public
export interface ServiceListQueuesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeMetadata?: boolean;
    prefix?: string;
}

// @public
export interface ServiceListQueuesSegmentHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ServiceListQueuesSegmentResponse = WithResponse<ServiceListQueuesSegmentHeaders & ListQueuesSegmentResponse, ServiceListQueuesSegmentHeaders, ListQueuesSegmentResponse>;

// @public
export interface ServiceSetPropertiesHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceSetPropertiesResponse = WithResponse<ServiceSetPropertiesHeaders, ServiceSetPropertiesHeaders>;

// @public
export interface SignedIdentifier {
    accessPolicy: {
        startsOn?: Date;
        expiresOn?: Date;
        permissions?: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    accessPolicy: AccessPolicy;
    id: string;
}

export { StorageBrowserPolicyFactory }

// @public
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    audience?: string;
    httpClient?: RequestPolicy;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxySettings;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentPolicyOptions;
}

// @public
export enum StorageQueueAudience {
    StorageOAuthScopes = "https://storage.azure.com/.default"
}

export { StorageRetryOptions }

export { StorageRetryPolicy }

export { StorageRetryPolicyFactory }

export { StorageRetryPolicyType }

export { StorageSharedKeyCredential }

export { StorageSharedKeyCredentialPolicy }

// @public
export interface UserDelegationKey {
    signedExpiresOn: Date;
    signedObjectId: string;
    signedService: string;
    signedStartsOn: Date;
    signedTenantId: string;
    signedVersion: string;
    value: string;
}

// @public
export interface UserDelegationKeyModel {
    signedExpiry: Date;
    signedOid: string;
    signedService: string;
    signedStart: Date;
    signedTid: string;
    signedVersion: string;
    value: string;
}

export { WebResource }

// @public
export type WithResponse<T, Headers = undefined, Body = undefined> = T & (Body extends object ? ResponseWithBody<Headers, Body> : Headers extends object ? ResponseWithHeaders<Headers> : ResponseLike);

// (No @packageDocumentation comment for this package)

```
