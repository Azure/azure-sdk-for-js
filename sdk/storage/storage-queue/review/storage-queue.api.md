## API Report File for "@azure/storage-queue"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { BaseRequestPolicy } from '@azure/core-http';
import * as coreHttp from '@azure/core-http';
import { deserializationPolicy } from '@azure/core-http';
import { HttpHeaders } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { HttpRequestBody } from '@azure/core-http';
import { HttpResponse } from '@azure/core-http';
import { HttpClient as IHttpClient } from '@azure/core-http';
import { KeepAliveOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { ProxyOptions } from '@azure/core-http';
import { RequestPolicy } from '@azure/core-http';
import { RequestPolicyFactory } from '@azure/core-http';
import { RequestPolicyOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { SpanOptions } from '@azure/core-tracing';
import { TokenCredential } from '@azure/core-http';
import { UserAgentOptions } from '@azure/core-http';
import { WebResource } from '@azure/core-http';

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiryTime: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startTime?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

export { BaseRequestPolicy }

// @public
export interface CommonOptions {
    // (undocumented)
    spanOptions?: SpanOptions;
}

// @public
export abstract class Credential implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;

// @public
export interface DequeuedMessageItem {
    dequeueCount: number;
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    messageText: string;
    nextVisibleOn: Date;
    popReceipt: string;
}

export { deserializationPolicy }

// @public
export interface EnqueuedMessage {
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    nextVisibleOn: Date;
    popReceipt: string;
}

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: SharedKeyCredential): SASQueryParameters;

// @public
export function generateQueueSASQueryParameters(queueSASSignatureValues: QueueSASSignatureValues, sharedKeyCredential: SharedKeyCredential): SASQueryParameters;

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

export { IHttpClient }

// @public
export type ListQueuesIncludeType = 'metadata';

// @public
export interface ListQueuesSegmentResponse {
    // (undocumented)
    continuationToken: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize: number;
    // (undocumented)
    prefix: string;
    // (undocumented)
    queueItems?: QueueItem[];
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export const logger: import("@azure/logger").AzureLogger;

// Warning: (ae-forgotten-export) The symbol "MessageIdDeleteHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type MessageIdDeleteResponse = MessageIdDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: MessageIdDeleteHeaders;
    };
};

// Warning: (ae-forgotten-export) The symbol "MessageIdUpdateHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type MessageIdUpdateResponse = MessageIdUpdateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: MessageIdUpdateHeaders;
    };
};

// Warning: (ae-forgotten-export) The symbol "MessagesClearHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type MessagesClearResponse = MessagesClearHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: MessagesClearHeaders;
    };
};

// @public
export interface MessagesDequeueHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesDequeueOptionalParams extends coreHttp.RequestOptionsBase {
    numberOfMessages?: number;
    requestId?: string;
    timeoutInSeconds?: number;
    visibilityTimeout?: number;
}

// @public
export interface MessagesEnqueueHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesEnqueueOptionalParams extends coreHttp.RequestOptionsBase {
    messageTimeToLive?: number;
    requestId?: string;
    timeoutInSeconds?: number;
    visibilityTimeout?: number;
}

// @public
export interface MessagesPeekHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesPeekOptionalParams extends coreHttp.RequestOptionsBase {
    numberOfMessages?: number;
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public (undocumented)
export interface Metadata {
    // (undocumented)
    [propertyName: string]: string;
}

// @public
export function newPipeline(credential: SharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export interface PeekedMessageItem {
    dequeueCount: number;
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    messageText: string;
}

// @public
export class Pipeline {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: IHttpClient;
}

// @public
export interface QueueClearMessagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type QueueClearMessagesResponse = MessagesClearResponse;

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
// 
// @public
export class QueueClient extends StorageClient {
    constructor(connectionString: string, queueName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    clearMessages(options?: QueueClearMessagesOptions): Promise<QueueClearMessagesResponse>;
    create(options?: QueueCreateOptions): Promise<QueueCreateResponse>;
    delete(options?: QueueDeleteOptions): Promise<QueueDeleteResponse>;
    deleteMessage(messageId: string, popReceipt: string, options?: QueueDeleteMessageOptions): Promise<QueueDeleteMessageResponse>;
    getAccessPolicy(options?: QueueGetAccessPolicyOptions): Promise<QueueGetAccessPolicyResponse>;
    getProperties(options?: QueueGetPropertiesOptions): Promise<QueueGetPropertiesResponse>;
    // (undocumented)
    readonly name: string;
    peekMessages(options?: QueuePeekMessagesOptions): Promise<QueuePeekMessagesResponse>;
    receiveMessages(options?: QueueReceiveMessageOptions): Promise<QueueReceiveMessageResponse>;
    sendMessage(messageText: string, options?: QueueSendMessageOptions): Promise<QueueSendMessageResponse>;
    setAccessPolicy(queueAcl?: SignedIdentifier[], options?: QueueSetAccessPolicyOptions): Promise<QueueSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: QueueSetMetadataOptions): Promise<QueueSetMetadataResponse>;
    updateMessage(messageId: string, popReceipt: string, message: string, visibilityTimeout?: number, options?: QueueUpdateMessageOptions): Promise<QueueUpdateMessageResponse>;
}

// @public
export interface QueueCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: Metadata;
}

// Warning: (ae-forgotten-export) The symbol "QueueCreateHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type QueueCreateResponse = QueueCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueCreateHeaders;
    };
};

// @public
export interface QueueDeleteMessageOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type QueueDeleteMessageResponse = MessageIdDeleteResponse;

// @public
export interface QueueDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "QueueDeleteHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type QueueDeleteResponse = QueueDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueDeleteHeaders;
    };
};

// @public
export interface QueueGetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    // (undocumented)
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type QueueGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifier[];
} & QueueGetAccessPolicyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: QueueGetAccessPolicyHeaders;
        bodyAsText: string;
        parsedBody: SignedIdentifierModel[];
    };
};

// @public
export interface QueueGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "QueueGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type QueueGetPropertiesResponse = QueueGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueGetPropertiesHeaders;
    };
};

// @public
export interface QueueItem {
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    name: string;
}

// @public
export interface QueuePeekMessagesOptions extends MessagesPeekOptionalParams, CommonOptions {
}

// @public (undocumented)
export type QueuePeekMessagesResponse = {
    peekedMessageItems: PeekedMessageItem[];
} & MessagesPeekHeaders & {
    _response: HttpResponse & {
        parsedHeaders: MessagesPeekHeaders;
        bodyAsText: string;
        parsedBody: PeekedMessageItem[];
    };
};

// @public
export interface QueueReceiveMessageOptions extends MessagesDequeueOptionalParams, CommonOptions {
}

// @public (undocumented)
export type QueueReceiveMessageResponse = {
    receivedMessageItems: ReceivedMessageItem[];
} & MessagesDequeueHeaders & {
    _response: HttpResponse & {
        parsedHeaders: MessagesDequeueHeaders;
        bodyAsText: string;
        parsedBody: ReceivedMessageItem[];
    };
};

// @public
export class QueueSASPermissions {
    add: boolean;
    static parse(permissions: string): QueueSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
}

// @public
export interface QueueSASSignatureValues {
    expiryTime?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: QueueSASPermissions;
    protocol?: SASProtocol;
    queueName: string;
    startTime?: Date;
    version?: string;
}

// @public
export interface QueueSendMessageOptions extends MessagesEnqueueOptionalParams, CommonOptions {
}

// @public (undocumented)
export type QueueSendMessageResponse = {
    messageId: string;
    popReceipt: string;
    insertedOn: Date;
    expiresOn: Date;
    nextVisibleOn: Date;
} & MessagesEnqueueHeaders & {
    _response: HttpResponse & {
        parsedHeaders: MessagesEnqueueHeaders;
        bodyAsText: string;
        parsedBody: EnqueuedMessage[];
    };
};

// @public
export class QueueServiceClient extends StorageClient {
    constructor(url: string, credential?: SharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createQueue(queueName: string, options?: QueueCreateOptions): Promise<QueueCreateResponse>;
    deleteQueue(queueName: string, options?: QueueDeleteOptions): Promise<QueueDeleteResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): QueueServiceClient;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getQueueClient(queueName: string): QueueClient;
    getStatistics(options?: ServiceGetStatisticsOptions): Promise<ServiceGetStatisticsResponse>;
    listQueues(options?: ServiceListQueuesOptions): PagedAsyncIterableIterator<QueueItem, ServiceListQueuesSegmentResponse>;
    setProperties(properties: QueueServiceProperties, options?: ServiceGetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
}

// @public
export interface QueueServiceProperties {
    // Warning: (ae-forgotten-export) The symbol "CorsRule" needs to be exported by the entry point index.d.ts
    cors?: CorsRule[];
    // Warning: (ae-forgotten-export) The symbol "Metrics" needs to be exported by the entry point index.d.ts
    hourMetrics?: Metrics;
    minuteMetrics?: Metrics;
    // Warning: (ae-forgotten-export) The symbol "Logging" needs to be exported by the entry point index.d.ts
    queueAnalyticsLogging?: Logging;
}

// @public
export interface QueueSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "QueueSetAccessPolicyHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type QueueSetAccessPolicyResponse = QueueSetAccessPolicyHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueSetAccessPolicyHeaders;
    };
};

// @public
export interface QueueSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "QueueSetMetadataHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type QueueSetMetadataResponse = QueueSetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueSetMetadataHeaders;
    };
};

// @public
export interface QueueUpdateMessageOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public (undocumented)
export type QueueUpdateMessageResponse = MessageIdUpdateResponse;

// @public (undocumented)
export type ReceivedMessageItem = DequeuedMessageItem;

export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

export { RestError }

// @public
export interface RetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: RetryPolicyType;
    readonly secondaryHost?: string;
    readonly tryTimeoutInMs?: number;
}

// @public
export class RetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: RetryOptions);
    // Warning: (ae-forgotten-export) The symbol "RetryPolicy" needs to be exported by the entry point index.d.ts
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): RetryPolicy;
    }

// @public
export enum RetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startTime?: Date, expiryTime?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string);
    readonly expiryTime?: Date;
    readonly identifier?: string;
    readonly ipRange: SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startTime?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ServiceGetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceGetPropertiesResponse = QueueServiceProperties & ServiceGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetPropertiesHeaders;
        bodyAsText: string;
        parsedBody: QueueServiceProperties;
    };
};

// @public
export interface ServiceGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "QueueServiceStatistics" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ServiceGetStatisticsHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceGetStatisticsResponse = QueueServiceStatistics & ServiceGetStatisticsHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceGetStatisticsHeaders;
        bodyAsText: string;
        parsedBody: QueueServiceStatistics;
    };
};

// @public
export interface ServiceListQueuesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeMetadata?: boolean;
    prefix?: string;
}

// Warning: (ae-forgotten-export) The symbol "ServiceListQueuesSegmentHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceListQueuesSegmentResponse = ListQueuesSegmentResponse & ServiceListQueuesSegmentHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceListQueuesSegmentHeaders;
        bodyAsText: string;
        parsedBody: ListQueuesSegmentResponse;
    };
};

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// Warning: (ae-forgotten-export) The symbol "ServiceSetPropertiesHeaders" needs to be exported by the entry point index.d.ts
// 
// @public
export type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceSetPropertiesHeaders;
    };
};

// @public
export class SharedKeyCredential extends Credential {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): SharedKeyCredentialPolicy;
}

// @public
export class SharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: SharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

// @public
export interface SignedIdentifier {
    accessPolicy: {
        start: Date;
        expiry: Date;
        permissions: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    // Warning: (ae-forgotten-export) The symbol "AccessPolicy" needs to be exported by the entry point index.d.ts
    accessPolicy: AccessPolicy;
    id: string;
}

// @public (undocumented)
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    httpClient?: IHttpClient;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxyOptions;
    retryOptions?: RetryOptions;
    userAgentOptions?: UserAgentOptions;
}

export { WebResource }


// (No @packageDocumentation comment for this package)

```
