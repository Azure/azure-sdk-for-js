## API Report File for "@azure/storage-queue"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { AzureLogger } from '@azure/logger';
import { BaseRequestPolicy } from '@azure/core-http';
import * as coreHttp from '@azure/core-http';
import { deserializationPolicy } from '@azure/core-http';
import { HttpHeaders } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { HttpRequestBody } from '@azure/core-http';
import { HttpResponse } from '@azure/core-http';
import { HttpClient as IHttpClient } from '@azure/core-http';
import { KeepAliveOptions } from '@azure/core-http';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { ProxyOptions } from '@azure/core-http';
import { RequestOptionsBase } from '@azure/core-http';
import { RequestPolicy } from '@azure/core-http';
import { RequestPolicyFactory } from '@azure/core-http';
import { RequestPolicyOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { TokenCredential } from '@azure/core-http';
import { UserAgentOptions } from '@azure/core-http';
import { WebResource } from '@azure/core-http';

// @public
export interface AccessPolicy {
    expiresOn?: string;
    permissions?: string;
    startsOn?: string;
}

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential_2 {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

export { BaseRequestPolicy }

// @public
export interface CommonOptions {
    tracingOptions?: OperationTracingOptions;
}

// @public
export interface CorsRule {
    allowedHeaders: string;
    allowedMethods: string;
    allowedOrigins: string;
    exposedHeaders: string;
    maxAgeInSeconds: number;
}

// @public
abstract class Credential_2 implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}
export { Credential_2 as Credential }

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;

// @public
export interface DequeuedMessageItem {
    dequeueCount: number;
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    messageText: string;
    nextVisibleOn: Date;
    popReceipt: string;
}

export { deserializationPolicy }

// @public
export interface EnqueuedMessage {
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    nextVisibleOn: Date;
    popReceipt: string;
}

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateQueueSASQueryParameters(queueSASSignatureValues: QueueSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export interface GeoReplication {
    lastSyncOn: Date;
    status: GeoReplicationStatusType;
}

// @public
export type GeoReplicationStatusType = "live" | "bootstrap" | "unavailable";

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

export { IHttpClient }

// @public
export type ListQueuesIncludeType = "metadata";

// @public
export interface ListQueuesSegmentResponse {
    // (undocumented)
    continuationToken: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize: number;
    // (undocumented)
    prefix: string;
    // (undocumented)
    queueItems?: QueueItem[];
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export const logger: AzureLogger;

// @public
export interface Logging {
    deleteProperty: boolean;
    read: boolean;
    retentionPolicy: RetentionPolicy;
    version: string;
    write: boolean;
}

// @public
export interface MessageIdDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessageIdDeleteResponse = MessageIdDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: MessageIdDeleteHeaders;
    };
};

// @public
export interface MessageIdUpdateHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    nextVisibleOn?: Date;
    popReceipt?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessageIdUpdateResponse = MessageIdUpdateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: MessageIdUpdateHeaders;
    };
};

// @public
export interface MessagesClearHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessagesClearResponse = MessagesClearHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: MessagesClearHeaders;
    };
};

// @public
export interface MessagesDequeueHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesDequeueOptionalParams extends RequestOptionsBase {
    numberOfMessages?: number;
    requestId?: string;
    timeoutInSeconds?: number;
    visibilityTimeout?: number;
}

// @public
export interface MessagesEnqueueHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesEnqueueOptionalParams extends RequestOptionsBase {
    messageTimeToLive?: number;
    requestId?: string;
    timeoutInSeconds?: number;
    visibilityTimeout?: number;
}

// @public
export interface MessagesPeekHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesPeekOptionalParams extends RequestOptionsBase {
    numberOfMessages?: number;
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export interface Metadata {
    [propertyName: string]: string;
}

// @public
export interface Metrics {
    enabled: boolean;
    includeAPIs?: boolean;
    retentionPolicy?: RetentionPolicy;
    version?: string;
}

// @public
export function newPipeline(credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export interface PeekedMessageItem {
    dequeueCount: number;
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    messageText: string;
}

// @public
export class Pipeline {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: IHttpClient;
}

// @public
export interface QueueClearMessagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueClearMessagesResponse = MessagesClearResponse;

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class QueueClient extends StorageClient {
    constructor(connectionString: string, queueName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    clearMessages(options?: QueueClearMessagesOptions): Promise<QueueClearMessagesResponse>;
    create(options?: QueueCreateOptions): Promise<QueueCreateResponse>;
    createIfNotExists(options?: QueueCreateOptions): Promise<QueueCreateIfNotExistsResponse>;
    delete(options?: QueueDeleteOptions): Promise<QueueDeleteResponse>;
    deleteIfExists(options?: QueueDeleteOptions): Promise<QueueDeleteIfExistsResponse>;
    deleteMessage(messageId: string, popReceipt: string, options?: QueueDeleteMessageOptions): Promise<QueueDeleteMessageResponse>;
    exists(options?: QueueExistsOptions): Promise<boolean>;
    generateSasUrl(options: QueueGenerateSasUrlOptions): string;
    getAccessPolicy(options?: QueueGetAccessPolicyOptions): Promise<QueueGetAccessPolicyResponse>;
    getProperties(options?: QueueGetPropertiesOptions): Promise<QueueGetPropertiesResponse>;
    get name(): string;
    peekMessages(options?: QueuePeekMessagesOptions): Promise<QueuePeekMessagesResponse>;
    receiveMessages(options?: QueueReceiveMessageOptions): Promise<QueueReceiveMessageResponse>;
    sendMessage(messageText: string, options?: QueueSendMessageOptions): Promise<QueueSendMessageResponse>;
    setAccessPolicy(queueAcl?: SignedIdentifier[], options?: QueueSetAccessPolicyOptions): Promise<QueueSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: QueueSetMetadataOptions): Promise<QueueSetMetadataResponse>;
    updateMessage(messageId: string, popReceipt: string, message?: string, visibilityTimeout?: number, options?: QueueUpdateMessageOptions): Promise<QueueUpdateMessageResponse>;
}

// @public
export interface QueueCreateHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueCreateIfNotExistsResponse extends QueueCreateResponse {
    succeeded: boolean;
}

// @public
export interface QueueCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: Metadata;
}

// @public
export type QueueCreateResponse = QueueCreateHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueCreateHeaders;
    };
};

// @public
export interface QueueDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueDeleteIfExistsResponse extends QueueDeleteResponse {
    succeeded: boolean;
}

// @public
export interface QueueDeleteMessageOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueDeleteMessageResponse = MessageIdDeleteResponse;

// @public
export interface QueueDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueDeleteResponse = QueueDeleteHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueDeleteHeaders;
    };
};

// @public
export interface QueueExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface QueueGenerateSasUrlOptions {
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: QueueSASPermissions;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface QueueGetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifier[];
} & QueueGetAccessPolicyHeaders & {
    _response: HttpResponse & {
        parsedHeaders: QueueGetAccessPolicyHeaders;
        bodyAsText: string;
        parsedBody: SignedIdentifierModel[];
    };
};

// @public
export interface QueueGetPropertiesHeaders {
    approximateMessagesCount?: number;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface QueueGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueGetPropertiesResponse = QueueGetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueGetPropertiesHeaders;
    };
};

// @public
export interface QueueItem {
    metadata?: {
        [propertyName: string]: string;
    };
    name: string;
}

// @public
export interface QueuePeekMessagesOptions extends MessagesPeekOptionalParams, CommonOptions {
}

// @public
export type QueuePeekMessagesResponse = {
    peekedMessageItems: PeekedMessageItem[];
} & MessagesPeekHeaders & {
    _response: HttpResponse & {
        parsedHeaders: MessagesPeekHeaders;
        bodyAsText: string;
        parsedBody: PeekedMessageItem[];
    };
};

// @public
export interface QueueReceiveMessageOptions extends MessagesDequeueOptionalParams, CommonOptions {
}

// @public
export type QueueReceiveMessageResponse = {
    receivedMessageItems: ReceivedMessageItem[];
} & MessagesDequeueHeaders & {
    _response: HttpResponse & {
        parsedHeaders: MessagesDequeueHeaders;
        bodyAsText: string;
        parsedBody: ReceivedMessageItem[];
    };
};

// @public
export class QueueSASPermissions {
    add: boolean;
    static parse(permissions: string): QueueSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
}

// @public
export interface QueueSASSignatureValues {
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: QueueSASPermissions;
    protocol?: SASProtocol;
    queueName: string;
    startsOn?: Date;
    version?: string;
}

// @public
export interface QueueSendMessageOptions extends MessagesEnqueueOptionalParams, CommonOptions {
}

// @public
export type QueueSendMessageResponse = {
    messageId: string;
    popReceipt: string;
    insertedOn: Date;
    expiresOn: Date;
    nextVisibleOn: Date;
} & MessagesEnqueueHeaders & {
    _response: HttpResponse & {
        parsedHeaders: MessagesEnqueueHeaders;
        bodyAsText: string;
        parsedBody: EnqueuedMessage[];
    };
};

// @public
export class QueueServiceClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createQueue(queueName: string, options?: QueueCreateOptions): Promise<QueueCreateResponse>;
    deleteQueue(queueName: string, options?: QueueDeleteOptions): Promise<QueueDeleteResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): QueueServiceClient;
    generateAccountSasUrl(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getQueueClient(queueName: string): QueueClient;
    getStatistics(options?: ServiceGetStatisticsOptions): Promise<ServiceGetStatisticsResponse>;
    listQueues(options?: ServiceListQueuesOptions): PagedAsyncIterableIterator<QueueItem, ServiceListQueuesSegmentResponse>;
    setProperties(properties: QueueServiceProperties, options?: ServiceGetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
}

// @public
export interface QueueServiceProperties {
    cors?: CorsRule[];
    hourMetrics?: Metrics;
    minuteMetrics?: Metrics;
    queueAnalyticsLogging?: Logging;
}

// @public
export interface QueueServiceStatistics {
    geoReplication?: GeoReplication;
}

// @public
export interface QueueSetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueSetAccessPolicyResponse = QueueSetAccessPolicyHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueSetAccessPolicyHeaders;
    };
};

// @public
export interface QueueSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueSetMetadataResponse = QueueSetMetadataHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: QueueSetMetadataHeaders;
    };
};

// @public
export interface QueueUpdateMessageOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueUpdateMessageResponse = MessageIdUpdateResponse;

// @public
export type ReceivedMessageItem = DequeuedMessageItem;

export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

export { RestError }

// @public
export interface RetentionPolicy {
    days?: number;
    enabled: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string);
    readonly expiresOn?: Date;
    readonly identifier?: string;
    get ipRange(): SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface ServiceGenerateAccountSasUrlOptions {
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface ServiceGetPropertiesHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetPropertiesResponse = ServiceGetPropertiesHeaders & QueueServiceProperties & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: QueueServiceProperties;
        parsedHeaders: ServiceGetPropertiesHeaders;
    };
};

// @public
export interface ServiceGetStatisticsHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetStatisticsResponse = ServiceGetStatisticsHeaders & QueueServiceStatistics & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: QueueServiceStatistics;
        parsedHeaders: ServiceGetStatisticsHeaders;
    };
};

// @public
export interface ServiceListQueuesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeMetadata?: boolean;
    prefix?: string;
}

// @public
export interface ServiceListQueuesSegmentHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ServiceListQueuesSegmentResponse = ServiceListQueuesSegmentHeaders & ListQueuesSegmentResponse & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: ListQueuesSegmentResponse;
        parsedHeaders: ServiceListQueuesSegmentHeaders;
    };
};

// @public
export interface ServiceSetPropertiesHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders & {
    _response: coreHttp.HttpResponse & {
        parsedHeaders: ServiceSetPropertiesHeaders;
    };
};

// @public
export interface SignedIdentifier {
    accessPolicy: {
        startsOn?: Date;
        expiresOn?: Date;
        permissions?: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    accessPolicy: AccessPolicy;
    id: string;
}

// @public
export class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}

// @public
export class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}

// @public
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    httpClient?: IHttpClient;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxyOptions;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentOptions;
}

// @public
export interface StorageRetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: StorageRetryPolicyType;
    readonly secondaryHost?: string;
    readonly tryTimeoutInMs?: number;
}

// @public
export class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions);
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
}

// @public
export class StorageRetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: StorageRetryOptions);
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
}

// @public
export enum StorageRetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export class StorageSharedKeyCredential extends Credential_2 {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
}

// @public
export class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

export { WebResource }

// (No @packageDocumentation comment for this package)

```
