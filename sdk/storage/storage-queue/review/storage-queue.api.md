## API Report File for "@azure/storage-queue"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { AzureLogger } from '@azure/logger';
import * as coreClient from '@azure/core-client';
import * as coreHttpCompat from '@azure/core-http-compat';
import { HttpHeadersLike as HttpHeaders } from '@azure/core-http-compat';
import { CompatResponse as HttpOperationResponse } from '@azure/core-http-compat';
import { HttpPipelineLogLevel } from '@azure/core-http-compat';
import { RequestBodyType as HttpRequestBody } from '@azure/core-rest-pipeline';
import { KeepAliveOptions } from '@azure/core-http-compat';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { ProxySettings } from '@azure/core-rest-pipeline';
import { RequestPolicy } from '@azure/core-http-compat';
import { RequestPolicyFactory } from '@azure/core-http-compat';
import { RequestPolicyOptionsLike as RequestPolicyOptions } from '@azure/core-http-compat';
import { RestError } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';
import { UserAgentPolicyOptions } from '@azure/core-rest-pipeline';
import { WebResourceLike as WebResource } from '@azure/core-http-compat';

// @public
export interface AccessPolicy {
    expiresOn?: string;
    permissions?: string;
    startsOn?: string;
}

// @public
export class AccountSASPermissions {
    add: boolean;
    create: boolean;
    delete: boolean;
    list: boolean;
    static parse(permissions: string): AccountSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
    write: boolean;
}

// @public
export class AccountSASResourceTypes {
    container: boolean;
    object: boolean;
    static parse(resourceTypes: string): AccountSASResourceTypes;
    service: boolean;
    toString(): string;
}

// @public
export class AccountSASServices {
    blob: boolean;
    file: boolean;
    static parse(services: string): AccountSASServices;
    queue: boolean;
    table: boolean;
    toString(): string;
}

// @public
export interface AccountSASSignatureValues {
    expiresOn: Date;
    ipRange?: SasIPRange;
    permissions: AccountSASPermissions;
    protocol?: SASProtocol;
    resourceTypes: string;
    services: string;
    startsOn?: Date;
    version?: string;
}

// @public
export class AnonymousCredential extends Credential_2 {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}

// @public
export class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}

// @public
export abstract class BaseRequestPolicy implements RequestPolicy {
    protected constructor(
    _nextPolicy: RequestPolicy,
    _options: RequestPolicyOptions);
    log(logLevel: HttpPipelineLogLevel, message: string): void;
    readonly _nextPolicy: RequestPolicy;
    readonly _options: RequestPolicyOptions;
    abstract sendRequest(webResource: WebResource): Promise<HttpOperationResponse>;
    shouldLog(logLevel: HttpPipelineLogLevel): boolean;
}

// @public
export interface CommonOptions {
    tracingOptions?: OperationTracingOptions;
}

// @public
export interface CorsRule {
    allowedHeaders: string;
    allowedMethods: string;
    allowedOrigins: string;
    exposedHeaders: string;
    maxAgeInSeconds: number;
}

// @public
abstract class Credential_2 implements RequestPolicyFactory {
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}
export { Credential_2 as Credential }

// @public
export abstract class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected signRequest(request: WebResource): WebResource;
}

// @public
export type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;

// @public
export interface DequeuedMessageItem {
    dequeueCount: number;
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    messageText: string;
    nextVisibleOn: Date;
    popReceipt: string;
}

// @public
export interface EnqueuedMessage {
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    nextVisibleOn: Date;
    popReceipt: string;
}

// @public
export function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export function generateQueueSASQueryParameters(queueSASSignatureValues: QueueSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;

// @public
export interface GeoReplication {
    lastSyncOn: Date;
    status: GeoReplicationStatusType;
}

// @public
export type GeoReplicationStatusType = "live" | "bootstrap" | "unavailable";

// @public (undocumented)
export function getQueueServiceAccountAudience(storageAccountName: string): string;

export { HttpHeaders }

export { HttpOperationResponse }

export { HttpRequestBody }

// @public
export interface HttpResponse {
    headers: HttpHeaders;
    request: WebResource;
    status: number;
}

// @public
export function isPipelineLike(pipeline: unknown): pipeline is PipelineLike;

// @public
export type ListQueuesIncludeType = "metadata";

// @public
export interface ListQueuesSegmentResponse {
    // (undocumented)
    continuationToken: string;
    // (undocumented)
    marker?: string;
    // (undocumented)
    maxPageSize: number;
    // (undocumented)
    prefix: string;
    // (undocumented)
    queueItems?: QueueItem[];
    // (undocumented)
    serviceEndpoint: string;
}

// @public
export const logger: AzureLogger;

// @public
export interface Logging {
    deleteProperty: boolean;
    read: boolean;
    retentionPolicy: RetentionPolicy;
    version: string;
    write: boolean;
}

// @public
export interface MessageIdDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessageIdDeleteResponse = WithResponse<MessageIdDeleteHeaders, MessageIdDeleteHeaders>;

// @public
export interface MessageIdUpdateHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    nextVisibleOn?: Date;
    popReceipt?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessageIdUpdateResponse = WithResponse<MessageIdUpdateHeaders, MessageIdUpdateHeaders>;

// @public
export interface MessagesClearHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type MessagesClearResponse = WithResponse<MessagesClearHeaders, MessagesClearHeaders>;

// @public
export interface MessagesDequeueHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesDequeueOptionalParams extends CommonOptions {
    numberOfMessages?: number;
    requestId?: string;
    timeoutInSeconds?: number;
    visibilityTimeout?: number;
}

// @public
export interface MessagesEnqueueHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesEnqueueOptionalParams extends CommonOptions {
    messageTimeToLive?: number;
    requestId?: string;
    timeoutInSeconds?: number;
    visibilityTimeout?: number;
}

// @public
export interface MessagesPeekHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface MessagesPeekOptionalParams extends CommonOptions {
    numberOfMessages?: number;
    requestId?: string;
    timeoutInSeconds?: number;
}

// @public
export interface Metadata {
    [propertyName: string]: string;
}

// @public
export interface Metrics {
    enabled: boolean;
    includeAPIs?: boolean;
    retentionPolicy?: RetentionPolicy;
    version?: string;
}

// @public
export function newPipeline(credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, pipelineOptions?: StoragePipelineOptions): Pipeline;

// @public
export interface PeekedMessageItem {
    dequeueCount: number;
    expiresOn: Date;
    insertedOn: Date;
    messageId: string;
    messageText: string;
}

// @public
export class Pipeline implements PipelineLike {
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineLike {
    readonly factories: RequestPolicyFactory[];
    readonly options: PipelineOptions;
    toServiceClientOptions(): ServiceClientOptions;
}

// @public
export interface PipelineOptions {
    httpClient?: RequestPolicy;
}

// @public
export interface QueueClearMessagesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueClearMessagesResponse = MessagesClearResponse;

// Warning: (ae-forgotten-export) The symbol "StorageClient" needs to be exported by the entry point index.d.ts
//
// @public
export class QueueClient extends StorageClient {
    constructor(connectionString: string, queueName: string, options?: StoragePipelineOptions);
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    clearMessages(options?: QueueClearMessagesOptions): Promise<QueueClearMessagesResponse>;
    create(options?: QueueCreateOptions): Promise<QueueCreateResponse>;
    createIfNotExists(options?: QueueCreateOptions): Promise<QueueCreateIfNotExistsResponse>;
    delete(options?: QueueDeleteOptions): Promise<QueueDeleteResponse>;
    deleteIfExists(options?: QueueDeleteOptions): Promise<QueueDeleteIfExistsResponse>;
    deleteMessage(messageId: string, popReceipt: string, options?: QueueDeleteMessageOptions): Promise<QueueDeleteMessageResponse>;
    exists(options?: QueueExistsOptions): Promise<boolean>;
    generateSasUrl(options: QueueGenerateSasUrlOptions): string;
    getAccessPolicy(options?: QueueGetAccessPolicyOptions): Promise<QueueGetAccessPolicyResponse>;
    getProperties(options?: QueueGetPropertiesOptions): Promise<QueueGetPropertiesResponse>;
    get name(): string;
    peekMessages(options?: QueuePeekMessagesOptions): Promise<QueuePeekMessagesResponse>;
    receiveMessages(options?: QueueReceiveMessageOptions): Promise<QueueReceiveMessageResponse>;
    sendMessage(messageText: string, options?: QueueSendMessageOptions): Promise<QueueSendMessageResponse>;
    setAccessPolicy(queueAcl?: SignedIdentifier[], options?: QueueSetAccessPolicyOptions): Promise<QueueSetAccessPolicyResponse>;
    setMetadata(metadata?: Metadata, options?: QueueSetMetadataOptions): Promise<QueueSetMetadataResponse>;
    updateMessage(messageId: string, popReceipt: string, message?: string, visibilityTimeout?: number, options?: QueueUpdateMessageOptions): Promise<QueueUpdateMessageResponse>;
}

// @public
export interface QueueCreateHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueCreateIfNotExistsResponse extends QueueCreateResponse {
    succeeded: boolean;
}

// @public
export interface QueueCreateOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    metadata?: Metadata;
}

// @public
export type QueueCreateResponse = WithResponse<QueueCreateHeaders, QueueCreateHeaders>;

// @public
export interface QueueDeleteHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueDeleteIfExistsResponse extends QueueDeleteResponse {
    succeeded: boolean;
}

// @public
export interface QueueDeleteMessageOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueDeleteMessageResponse = MessageIdDeleteResponse;

// @public
export interface QueueDeleteOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueDeleteResponse = WithResponse<QueueDeleteHeaders, QueueDeleteHeaders>;

// @public
export interface QueueExistsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface QueueGenerateSasUrlOptions {
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: QueueSASPermissions;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface QueueGetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueGetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueGetAccessPolicyResponse = WithResponse<{
    signedIdentifiers: SignedIdentifier[];
} & QueueGetAccessPolicyHeaders, QueueGetAccessPolicyHeaders, SignedIdentifierModel[]>;

// @public
export interface QueueGetPropertiesHeaders {
    approximateMessagesCount?: number;
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    // (undocumented)
    metadata?: {
        [propertyName: string]: string;
    };
    requestId?: string;
    version?: string;
}

// @public
export interface QueueGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueGetPropertiesResponse = WithResponse<QueueGetPropertiesHeaders, QueueGetPropertiesHeaders>;

// @public
export interface QueueItem {
    metadata?: {
        [propertyName: string]: string;
    };
    name: string;
}

// @public
export interface QueuePeekMessagesOptions extends MessagesPeekOptionalParams, CommonOptions {
}

// @public
export type QueuePeekMessagesResponse = WithResponse<{
    peekedMessageItems: PeekedMessageItem[];
} & MessagesPeekHeaders, MessagesPeekHeaders, PeekedMessageItem[]>;

// @public
export interface QueueReceiveMessageOptions extends MessagesDequeueOptionalParams, CommonOptions {
}

// @public
export type QueueReceiveMessageResponse = WithResponse<{
    receivedMessageItems: ReceivedMessageItem[];
} & MessagesDequeueHeaders, MessagesDequeueHeaders, ReceivedMessageItem[]>;

// @public
export class QueueSASPermissions {
    add: boolean;
    static parse(permissions: string): QueueSASPermissions;
    process: boolean;
    read: boolean;
    toString(): string;
    update: boolean;
}

// @public
export interface QueueSASSignatureValues {
    expiresOn?: Date;
    identifier?: string;
    ipRange?: SasIPRange;
    permissions?: QueueSASPermissions;
    protocol?: SASProtocol;
    queueName: string;
    startsOn?: Date;
    version?: string;
}

// @public
export interface QueueSendMessageOptions extends MessagesEnqueueOptionalParams, CommonOptions {
}

// @public
export type QueueSendMessageResponse = WithResponse<{
    messageId: string;
    popReceipt: string;
    insertedOn: Date;
    expiresOn: Date;
    nextVisibleOn: Date;
} & MessagesEnqueueHeaders, MessagesEnqueueHeaders, EnqueuedMessage[]>;

// @public
export class QueueServiceClient extends StorageClient {
    constructor(url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions);
    constructor(url: string, pipeline: Pipeline);
    createQueue(queueName: string, options?: QueueCreateOptions): Promise<QueueCreateResponse>;
    deleteQueue(queueName: string, options?: QueueDeleteOptions): Promise<QueueDeleteResponse>;
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): QueueServiceClient;
    generateAccountSasUrl(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    getQueueClient(queueName: string): QueueClient;
    getStatistics(options?: ServiceGetStatisticsOptions): Promise<ServiceGetStatisticsResponse>;
    listQueues(options?: ServiceListQueuesOptions): PagedAsyncIterableIterator<QueueItem, ServiceListQueuesSegmentResponse>;
    setProperties(properties: QueueServiceProperties, options?: ServiceGetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
}

// @public
export interface QueueServiceProperties {
    cors?: CorsRule[];
    hourMetrics?: Metrics;
    minuteMetrics?: Metrics;
    queueAnalyticsLogging?: Logging;
}

// @public
export interface QueueServiceStatistics {
    geoReplication?: GeoReplication;
}

// @public
export interface QueueSetAccessPolicyHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueSetAccessPolicyOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueSetAccessPolicyResponse = WithResponse<QueueSetAccessPolicyHeaders, QueueSetAccessPolicyHeaders>;

// @public
export interface QueueSetMetadataHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface QueueSetMetadataOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueSetMetadataResponse = WithResponse<QueueSetMetadataHeaders, QueueSetMetadataHeaders>;

// @public
export interface QueueUpdateMessageOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type QueueUpdateMessageResponse = MessageIdUpdateResponse;

// @public
export type ReceivedMessageItem = DequeuedMessageItem;

export { RequestPolicy as IHttpClient }
export { RequestPolicy }

export { RequestPolicyFactory }

export { RequestPolicyOptions }

// @public
export interface ResponseLike {
    _response: HttpResponse;
}

// @public
export interface ResponseWithBody<Headers, Body> {
    _response: HttpResponse & {
        parsedHeaders: Headers;
        bodyAsText: string;
        parsedBody: Body;
    };
}

// @public
export interface ResponseWithHeaders<Headers> {
    _response: HttpResponse & {
        parsedHeaders: Headers;
    };
}

export { RestError }

// @public
export interface RetentionPolicy {
    days?: number;
    enabled: boolean;
}

// @public
export interface SasIPRange {
    end?: string;
    start: string;
}

// @public
export enum SASProtocol {
    Https = "https",
    HttpsAndHttp = "https,http"
}

// @public
export class SASQueryParameters {
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string);
    readonly expiresOn?: Date;
    readonly identifier?: string;
    get ipRange(): SasIPRange | undefined;
    readonly permissions?: string;
    readonly protocol?: SASProtocol;
    readonly resource?: string;
    readonly resourceTypes?: string;
    readonly services?: string;
    readonly signature: string;
    readonly startsOn?: Date;
    toString(): string;
    readonly version: string;
}

// @public
export interface ServiceClientOptions {
    httpClient?: RequestPolicy;
    requestPolicyFactories?: RequestPolicyFactory[] | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);
}

// @public
export interface ServiceGenerateAccountSasUrlOptions {
    ipRange?: SasIPRange;
    protocol?: SASProtocol;
    startsOn?: Date;
    version?: string;
}

// @public
export interface ServiceGetPropertiesHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetPropertiesResponse = WithResponse<ServiceGetPropertiesHeaders & QueueServiceProperties, ServiceGetPropertiesHeaders, QueueServiceProperties>;

// @public
export interface ServiceGetStatisticsHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceGetStatisticsOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceGetStatisticsResponse = WithResponse<ServiceGetStatisticsHeaders & QueueServiceStatistics, ServiceGetStatisticsHeaders, QueueServiceStatistics>;

// @public
export interface ServiceListQueuesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
    includeMetadata?: boolean;
    prefix?: string;
}

// @public
export interface ServiceListQueuesSegmentHeaders {
    clientRequestId?: string;
    date?: Date;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export type ServiceListQueuesSegmentResponse = WithResponse<ServiceListQueuesSegmentHeaders & ListQueuesSegmentResponse, ServiceListQueuesSegmentHeaders, ListQueuesSegmentResponse>;

// @public
export interface ServiceSetPropertiesHeaders {
    clientRequestId?: string;
    errorCode?: string;
    requestId?: string;
    version?: string;
}

// @public
export interface ServiceSetPropertiesOptions extends CommonOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export type ServiceSetPropertiesResponse = WithResponse<ServiceSetPropertiesHeaders, ServiceSetPropertiesHeaders>;

// @public
export interface SignedIdentifier {
    accessPolicy: {
        startsOn?: Date;
        expiresOn?: Date;
        permissions?: string;
    };
    id: string;
}

// @public
export interface SignedIdentifierModel {
    accessPolicy: AccessPolicy;
    id: string;
}

// @public
export class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}

// @public
export class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}

// @public
export const StorageOAuthScopes: string | string[];

// @public
export interface StoragePipelineOptions {
    audience?: string;
    httpClient?: RequestPolicy;
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxySettings;
    retryOptions?: StorageRetryOptions;
    userAgentOptions?: UserAgentPolicyOptions;
}

// @public
export enum StorageQueueAudience {
    StorageOAuthScopes = "https://storage.azure.com/.default"
}

// @public
export interface StorageRetryOptions {
    readonly maxRetryDelayInMs?: number;
    readonly maxTries?: number;
    readonly retryDelayInMs?: number;
    readonly retryPolicyType?: StorageRetryPolicyType;
    readonly secondaryHost?: string;
    readonly tryTimeoutInMs?: number;
}

// @public
export class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions);
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
}

// @public
export class StorageRetryPolicyFactory implements RequestPolicyFactory {
    constructor(retryOptions?: StorageRetryOptions);
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
}

// @public
export enum StorageRetryPolicyType {
    EXPONENTIAL = 0,
    FIXED = 1
}

// @public
export class StorageSharedKeyCredential extends Credential_2 {
    constructor(accountName: string, accountKey: string);
    readonly accountName: string;
    computeHMACSHA256(stringToSign: string): string;
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
}

// @public
export class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    protected signRequest(request: WebResource): WebResource;
}

export { WebResource }

// @public
export type WithResponse<T, Headers = undefined, Body = undefined> = T & (Body extends object ? ResponseWithBody<Headers, Body> : Headers extends object ? ResponseWithHeaders<Headers> : ResponseLike);

// (No @packageDocumentation comment for this package)

```
