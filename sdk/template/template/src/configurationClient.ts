/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";
import { PipelineRequest, PipelineResponse, SendRequest, bearerTokenAuthenticationPolicy } from "@azure/core-rest-pipeline";
import { TracingClient, createTracingClient } from "@azure/core-tracing";
import { TokenCredential } from "@azure/identity";
import { SDK_VERSION } from "./constants";
import { logger } from "./logger";
import {
    CheckKeyValueOptionalParams,
    CheckKeyValueResponse,
    CheckKeyValuesOptionalParams,
    CheckKeyValuesResponse,
    CheckKeysOptionalParams,
    CheckKeysResponse,
    CheckLabelsOptionalParams,
    CheckLabelsResponse,
    CheckRevisionsOptionalParams,
    CheckRevisionsResponse,
    ConfigurationClientOptionalParams,
    ConfigurationSetting,
    DeleteKeyValueOptionalParams,
    DeleteKeyValueResponse,
    DeleteLockOptionalParams,
    DeleteLockResponse,
    GetKeyValueOptionalParams,
    GetKeyValueResponse,
    GetKeyValuesNextOptionalParams,
    GetKeyValuesNextResponse,
    GetKeyValuesOptionalParams,
    GetKeyValuesResponse,
    GetKeysNextOptionalParams,
    GetKeysNextResponse,
    GetKeysOptionalParams,
    GetKeysResponse,
    GetLabelsNextOptionalParams,
    GetLabelsNextResponse,
    GetLabelsOptionalParams,
    GetLabelsResponse,
    GetRevisionsNextOptionalParams,
    GetRevisionsNextResponse,
    GetRevisionsOptionalParams,
    GetRevisionsResponse,
    PutKeyValueOptionalParams,
    PutKeyValueResponse,
    PutLockOptionalParams,
    PutLockResponse
} from "./models";
import * as Mappers from "./models/mappers";
import * as Parameters from "./models/parameters";
import { quoteETag } from "./util";

// Operation Specifications
/**
 * Client options used to configure App Configuration API requests.
 */
export interface ConfigurationClientOptions extends coreClient.CommonClientOptions {
}

/**
 * Options for the `getConfigurationSetting` method of `ConfigurationClient`.
 */
export interface GetConfigurationSettingOptions extends coreClient.OperationOptions {
    /**
     * If set to `true`, the method will use entity tags to instruct the service
     * to send an updated value only if the value has changed.
     *
     * NOTE: This option is only supported if passing a full
     * `ConfigurationSetting` object with an `etag` as the first parameter to
     * `getConfigurationSetting`.
     */
    onlyIfChanged?: boolean;
}

/** @internal */
export class ConfigurationClient extends coreClient.ServiceClient {
    endpoint: string;
    syncToken?: string;
    apiVersion: string;
    private tracingClient: TracingClient;

    /**
     * Creates an instance of a ConfigurationClient.
     *
     * Example usage:
     * ```ts
     * import { ConfigurationClient} from "@azure/ai-text-analytics";
     * import { DefaultAzureCredential} from "@azure/identity";
     *
     * const client = new ConfigurationClient(
     *    "<app configuration endpoint>",
     *    new DefaultAzureCredential()
     * );
     * ```
     * @param endpointUrl - the URL to the App Configuration endpoint
     * @param credential - used to authenticate requests to the service
     * @param options - optional configuration used to send requests to the service
     */
    constructor(endpointUrl: string, credential: TokenCredential, options: ConfigurationClientOptions = {}) {
        const authPolicy = bearerTokenAuthenticationPolicy({
                                                credential,
                                                scopes: `${endpointUrl}/.default`,
                                              });
        options.additionalPolicies = options.additionalPolicies ?? [];
        options.additionalPolicies.push({ policy: authPolicy, position: "perCall" });
        const internalClientPipelineOptions: coreClient.InternalClientPipelineOptions = {
                                                ...options,
                                                deserializationOptions: {
                                                  expectedContentTypes: {
                                                    json: [
                                                      "application/vnd.microsoft.appconfig.kvset+json",
                                                      "application/vnd.microsoft.appconfig.kv+json",
                                                      "application/vnd.microsoft.appconfig.kvs+json",
                                                      "application/vnd.microsoft.appconfig.keyset+json",
                                                      "application/vnd.microsoft.appconfig.revs+json",
                                                    ],
                                                  },
                                                },
                                                ...{
                                                  loggingOptions: {
                                                    logger: logger.info,
                                                    // This array contains header names we want to log that are not already
                                                    // included as safe. Unknown/unsafe headers are logged as "<REDACTED>".
                                                    additionalAllowedHeaderNames: ["x-ms-correlation-request-id"],
                                                  },
                                                },
                                              };
        const ___endpoint: string = endpointUrl;
        let ___options: ConfigurationClientOptionalParams = internalClientPipelineOptions;
        if (___endpoint === undefined) {
        throw new Error("'endpoint' cannot be null");
        }

        if (!___options) {
        ___options = {};
        }

        const defaults: ConfigurationClientOptionalParams = {
                                                requestContentType: "application/json; charset=utf-8"
                                              };
        const packageDetails = `azsdk-js-template/1.0.11-beta.1`;
        const userAgentPrefix = ___options.userAgentOptions && ___options.userAgentOptions.userAgentPrefix
                                                  ? `${___options.userAgentOptions.userAgentPrefix} ${packageDetails}`
                                                  : `${packageDetails}`;
        const optionsWithDefaults = {
                                                ...defaults,
                                                ...___options,
                                                userAgentOptions: {
                                                  userAgentPrefix
                                                },
                                                endpoint: ___options.endpoint ?? ___options.baseUri ?? "{endpoint}"
                                              };
        super(optionsWithDefaults);
        this.endpoint = ___endpoint;
        this.apiVersion = ___options.apiVersion || "1.0";
        this.addCustomApiVersionPolicy(___options.apiVersion);
        this.tracingClient = createTracingClient({
        // The name of the resource provider requests are made against, as described in
        // https://github.com/Azure/azure-sdk/blob/main/docs/tracing/distributed-tracing-conventions.yml#L11-L15
        namespace: "Microsoft.Learn",
        // The package name and version
        packageName: "@azure/template",
        packageVersion: SDK_VERSION,
        });
    }

    /**
     * Gets a list of keys.
     * @param options The options parameters.
     */
    getKeys(options?: GetKeysOptionalParams): Promise<GetKeysResponse> {
        return this.sendOperationRequest({ options }, getKeysOperationSpec);
    }

    /**
     * Requests the headers and status of the given resource.
     * @param options The options parameters.
     */
    checkKeys(options?: CheckKeysOptionalParams): Promise<CheckKeysResponse> {
        return this.sendOperationRequest({ options }, checkKeysOperationSpec);
    }

    /**
     * Gets a list of key-values.
     * @param options The options parameters.
     */
    getKeyValues(options?: GetKeyValuesOptionalParams): Promise<GetKeyValuesResponse> {
        return this.sendOperationRequest({ options }, getKeyValuesOperationSpec);
    }

    /**
     * Requests the headers and status of the given resource.
     * @param options The options parameters.
     */
    checkKeyValues(options?: CheckKeyValuesOptionalParams): Promise<CheckKeyValuesResponse> {
        return this.sendOperationRequest({ options }, checkKeyValuesOperationSpec);
    }

    /**
     * Creates a key-value.
     * @param key The key of the key-value to create.
     * @param options The options parameters.
     */
    putKeyValue(key: string, options?: PutKeyValueOptionalParams): Promise<PutKeyValueResponse> {
        return this.sendOperationRequest(
          { key, options },
          putKeyValueOperationSpec
        );
    }

    /**
     * Deletes a key-value.
     * @param key The key of the key-value to delete.
     * @param options The options parameters.
     */
    deleteKeyValue(key: string, options?: DeleteKeyValueOptionalParams): Promise<DeleteKeyValueResponse> {
        return this.sendOperationRequest(
          { key, options },
          deleteKeyValueOperationSpec
        );
    }

    /**
     * Requests the headers and status of the given resource.
     * @param key The key of the key-value to retrieve.
     * @param options The options parameters.
     */
    checkKeyValue(key: string, options?: CheckKeyValueOptionalParams): Promise<CheckKeyValueResponse> {
        return this.sendOperationRequest(
          { key, options },
          checkKeyValueOperationSpec
        );
    }

    /**
     * Gets a list of labels.
     * @param options The options parameters.
     */
    getLabels(options?: GetLabelsOptionalParams): Promise<GetLabelsResponse> {
        return this.sendOperationRequest({ options }, getLabelsOperationSpec);
    }

    /**
     * Requests the headers and status of the given resource.
     * @param options The options parameters.
     */
    checkLabels(options?: CheckLabelsOptionalParams): Promise<CheckLabelsResponse> {
        return this.sendOperationRequest({ options }, checkLabelsOperationSpec);
    }

    /**
     * Locks a key-value.
     * @param key The key of the key-value to lock.
     * @param options The options parameters.
     */
    putLock(key: string, options?: PutLockOptionalParams): Promise<PutLockResponse> {
        return this.sendOperationRequest({ key, options }, putLockOperationSpec);
    }

    /**
     * Unlocks a key-value.
     * @param key The key of the key-value to unlock.
     * @param options The options parameters.
     */
    deleteLock(key: string, options?: DeleteLockOptionalParams): Promise<DeleteLockResponse> {
        return this.sendOperationRequest({ key, options }, deleteLockOperationSpec);
    }

    /**
     * Gets a list of key-value revisions.
     * @param options The options parameters.
     */
    getRevisions(options?: GetRevisionsOptionalParams): Promise<GetRevisionsResponse> {
        return this.sendOperationRequest({ options }, getRevisionsOperationSpec);
    }

    /**
     * Requests the headers and status of the given resource.
     * @param options The options parameters.
     */
    checkRevisions(options?: CheckRevisionsOptionalParams): Promise<CheckRevisionsResponse> {
        return this.sendOperationRequest({ options }, checkRevisionsOperationSpec);
    }

    /**
     * GetKeysNext
     * @param nextLink The nextLink from the previous successful call to the GetKeys method.
     * @param options The options parameters.
     */
    getKeysNext(nextLink: string, options?: GetKeysNextOptionalParams): Promise<GetKeysNextResponse> {
        return this.sendOperationRequest(
          { nextLink, options },
          getKeysNextOperationSpec
        );
    }

    /**
     * GetKeyValuesNext
     * @param nextLink The nextLink from the previous successful call to the GetKeyValues method.
     * @param options The options parameters.
     */
    getKeyValuesNext(nextLink: string, options?: GetKeyValuesNextOptionalParams): Promise<GetKeyValuesNextResponse> {
        return this.sendOperationRequest(
          { nextLink, options },
          getKeyValuesNextOperationSpec
        );
    }

    /**
     * GetLabelsNext
     * @param nextLink The nextLink from the previous successful call to the GetLabels method.
     * @param options The options parameters.
     */
    getLabelsNext(nextLink: string, options?: GetLabelsNextOptionalParams): Promise<GetLabelsNextResponse> {
        return this.sendOperationRequest(
          { nextLink, options },
          getLabelsNextOperationSpec
        );
    }

    /**
     * GetRevisionsNext
     * @param nextLink The nextLink from the previous successful call to the GetRevisions method.
     * @param options The options parameters.
     */
    getRevisionsNext(nextLink: string, options?: GetRevisionsNextOptionalParams): Promise<GetRevisionsNextResponse> {
        return this.sendOperationRequest(
          { nextLink, options },
          getRevisionsNextOperationSpec
        );
    }

    /**
     * Retrieve the contents of an App Configuration setting by name (key).
     *
     * @param key - the unique name of the setting to get
     * @param options - optional configuration for the operation
     */
    public async getKeyValue(key: string, options?: GetConfigurationSettingOptions): Promise<ConfigurationSetting>;
    /**
     * Retrieve an updated value of an App Configuration setting, allowing for
     * the use of entity tags to request the new value only if it has changed.
     *
     * @param setting - the setting to retrieve from the service
     * @param options - optional configuration for the operation
     */
    public async getKeyValue(setting: ConfigurationSetting, options?: GetConfigurationSettingOptions): Promise<ConfigurationSetting>;
    public async getKeyValue(keyOrSetting: string | ConfigurationSetting, options: GetConfigurationSettingOptions = {}): Promise<ConfigurationSetting> {
        let key: string;
        let ifNoneMatch: string | undefined;
        return this.tracingClient.withSpan(
                                    // Span names should take the form "<className>.<methodName>".
                                    "ConfigurationClient.getConfigurationSetting",
                                    options,
                                    (updatedOptions) => {
                                      if (typeof keyOrSetting === "string") {
                                        key = keyOrSetting;
                                        if (options.onlyIfChanged) {
                                          throw new RangeError(
                                            "You must pass a ConfigurationSetting instead of a key to perform a conditional fetch."
                                          );
                                        }
                                      } else {
                                        key = keyOrSetting.key;
                                        const etag = keyOrSetting.etag;
                                        return this.tracingClient.withSpan(
                                          // Span names should take the form "<className>.<methodName>".
                                          "ConfigurationClient.getConfigurationSetting",
                                          options,
                                          (updatedOptions) => {
                                            if (typeof keyOrSetting === "string") {
                                              key = keyOrSetting;
                                              if (options.onlyIfChanged) {
                                                throw new RangeError(
                                                  "You must pass a ConfigurationSetting instead of a key to perform a conditional fetch."
                                                );
                                              }
                                            } else {
                                              key = keyOrSetting.key;
                                              const etag = keyOrSetting.etag;
                                              if (options.onlyIfChanged) {
                                                ifNoneMatch = quoteETag(etag);
                                              }
                                            }

                                            // You must pass updatedOptions to any calls you make within the callback.
                                            return this._getKeyValue(key, { ...updatedOptions, ifNoneMatch });
                                          }
                                        );
                                      }
                                      // You must pass updatedOptions to any calls you make within the callback.
                                      return this._getKeyValue(key, { ...updatedOptions, ifNoneMatch });
                                    }
                                  );
    }

    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    private addCustomApiVersionPolicy(apiVersion?: string) {
        if (!apiVersion) {
          return;
        }

        const apiVersionPolicy = {
                              name: "CustomApiVersionPolicy",
                              async sendRequest(
                                request: PipelineRequest,
                                next: SendRequest
                              ): Promise<PipelineResponse> {
                                const param = request.url.split("?");
                                if (param.length > 1) {
                                  const newParams = param[1].split("&").map((item) => {
                                    if (item.indexOf("api-version") > -1) {
                                      return "api-version=" + apiVersion;
                                    } else {
                                      return item;
                                    }
                                  });
                                  request.url = param[0] + "?" + newParams.join("&");
                                }
                                return next(request);
                              }
                            };
        this.pipeline.addPolicy(apiVersionPolicy);
    }

    /**
     * Gets a single key-value.
     * @param key The key of the key-value to retrieve.
     * @param options The options parameters.
     */
    private _getKeyValue(key: string, options?: GetKeyValueOptionalParams): Promise<GetKeyValueResponse> {
        return this.sendOperationRequest(
          { key, options },
          getKeyValueOperationSpec
        );
    }
}

const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getKeysOperationSpec: coreClient.OperationSpec = {
      path: "/keys",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.KeyListResult,
          headersMapper: Mappers.ConfigurationClientGetKeysHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      queryParameters: [Parameters.name, Parameters.apiVersion, Parameters.after],
      urlParameters: [Parameters.endpoint],
      headerParameters: [
        Parameters.accept,
        Parameters.syncToken,
        Parameters.acceptDatetime
      ],
      serializer
    };
const checkKeysOperationSpec: coreClient.OperationSpec = {
      path: "/keys",
      httpMethod: "HEAD",
      responses: {
        200: {
          headersMapper: Mappers.ConfigurationClientCheckKeysHeaders
        },
        default: {}
      },
      queryParameters: [Parameters.name, Parameters.apiVersion, Parameters.after],
      urlParameters: [Parameters.endpoint],
      headerParameters: [Parameters.syncToken, Parameters.acceptDatetime],
      serializer
    };
const getKeyValuesOperationSpec: coreClient.OperationSpec = {
      path: "/kv",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.KeyValueListResult,
          headersMapper: Mappers.ConfigurationClientGetKeyValuesHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      queryParameters: [
        Parameters.apiVersion,
        Parameters.after,
        Parameters.key,
        Parameters.label,
        Parameters.select
      ],
      urlParameters: [Parameters.endpoint],
      headerParameters: [
        Parameters.syncToken,
        Parameters.acceptDatetime,
        Parameters.accept1
      ],
      serializer
    };
const checkKeyValuesOperationSpec: coreClient.OperationSpec = {
      path: "/kv",
      httpMethod: "HEAD",
      responses: {
        200: {
          headersMapper: Mappers.ConfigurationClientCheckKeyValuesHeaders
        },
        default: {}
      },
      queryParameters: [
        Parameters.apiVersion,
        Parameters.after,
        Parameters.key,
        Parameters.label,
        Parameters.select
      ],
      urlParameters: [Parameters.endpoint],
      headerParameters: [Parameters.syncToken, Parameters.acceptDatetime],
      serializer
    };
const getKeyValueOperationSpec: coreClient.OperationSpec = {
      path: "/kv/{key}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.ConfigurationSetting,
          headersMapper: Mappers.ConfigurationClientGetKeyValueHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      queryParameters: [Parameters.apiVersion, Parameters.label, Parameters.select],
      urlParameters: [Parameters.endpoint, Parameters.key1],
      headerParameters: [
        Parameters.syncToken,
        Parameters.acceptDatetime,
        Parameters.accept2,
        Parameters.ifMatch,
        Parameters.ifNoneMatch
      ],
      serializer
    };
const putKeyValueOperationSpec: coreClient.OperationSpec = {
      path: "/kv/{key}",
      httpMethod: "PUT",
      responses: {
        200: {
          bodyMapper: Mappers.ConfigurationSetting,
          headersMapper: Mappers.ConfigurationClientPutKeyValueHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      requestBody: Parameters.entity,
      queryParameters: [Parameters.apiVersion, Parameters.label],
      urlParameters: [Parameters.endpoint, Parameters.key1],
      headerParameters: [
        Parameters.syncToken,
        Parameters.accept2,
        Parameters.ifMatch,
        Parameters.ifNoneMatch,
        Parameters.contentType
      ],
      mediaType: "json",
      serializer
    };
const deleteKeyValueOperationSpec: coreClient.OperationSpec = {
      path: "/kv/{key}",
      httpMethod: "DELETE",
      responses: {
        200: {
          bodyMapper: Mappers.ConfigurationSetting,
          headersMapper: Mappers.ConfigurationClientDeleteKeyValueHeaders
        },
        204: {
          headersMapper: Mappers.ConfigurationClientDeleteKeyValueHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      queryParameters: [Parameters.apiVersion, Parameters.label],
      urlParameters: [Parameters.endpoint, Parameters.key1],
      headerParameters: [
        Parameters.syncToken,
        Parameters.accept2,
        Parameters.ifMatch
      ],
      serializer
    };
const checkKeyValueOperationSpec: coreClient.OperationSpec = {
      path: "/kv/{key}",
      httpMethod: "HEAD",
      responses: {
        200: {
          headersMapper: Mappers.ConfigurationClientCheckKeyValueHeaders
        },
        default: {}
      },
      queryParameters: [Parameters.apiVersion, Parameters.label, Parameters.select],
      urlParameters: [Parameters.endpoint, Parameters.key1],
      headerParameters: [
        Parameters.syncToken,
        Parameters.acceptDatetime,
        Parameters.ifMatch,
        Parameters.ifNoneMatch
      ],
      serializer
    };
const getLabelsOperationSpec: coreClient.OperationSpec = {
      path: "/labels",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.LabelListResult,
          headersMapper: Mappers.ConfigurationClientGetLabelsHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      queryParameters: [
        Parameters.name,
        Parameters.apiVersion,
        Parameters.after,
        Parameters.select1
      ],
      urlParameters: [Parameters.endpoint],
      headerParameters: [
        Parameters.syncToken,
        Parameters.acceptDatetime,
        Parameters.accept3
      ],
      serializer
    };
const checkLabelsOperationSpec: coreClient.OperationSpec = {
      path: "/labels",
      httpMethod: "HEAD",
      responses: {
        200: {
          headersMapper: Mappers.ConfigurationClientCheckLabelsHeaders
        },
        default: {}
      },
      queryParameters: [
        Parameters.name,
        Parameters.apiVersion,
        Parameters.after,
        Parameters.select1
      ],
      urlParameters: [Parameters.endpoint],
      headerParameters: [Parameters.syncToken, Parameters.acceptDatetime],
      serializer
    };
const putLockOperationSpec: coreClient.OperationSpec = {
      path: "/locks/{key}",
      httpMethod: "PUT",
      responses: {
        200: {
          bodyMapper: Mappers.ConfigurationSetting,
          headersMapper: Mappers.ConfigurationClientPutLockHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      queryParameters: [Parameters.apiVersion, Parameters.label],
      urlParameters: [Parameters.endpoint, Parameters.key1],
      headerParameters: [
        Parameters.syncToken,
        Parameters.accept2,
        Parameters.ifMatch,
        Parameters.ifNoneMatch
      ],
      serializer
    };
const deleteLockOperationSpec: coreClient.OperationSpec = {
      path: "/locks/{key}",
      httpMethod: "DELETE",
      responses: {
        200: {
          bodyMapper: Mappers.ConfigurationSetting,
          headersMapper: Mappers.ConfigurationClientDeleteLockHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      queryParameters: [Parameters.apiVersion, Parameters.label],
      urlParameters: [Parameters.endpoint, Parameters.key1],
      headerParameters: [
        Parameters.syncToken,
        Parameters.accept2,
        Parameters.ifMatch,
        Parameters.ifNoneMatch
      ],
      serializer
    };
const getRevisionsOperationSpec: coreClient.OperationSpec = {
      path: "/revisions",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.KeyValueListResult,
          headersMapper: Mappers.ConfigurationClientGetRevisionsHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      queryParameters: [
        Parameters.apiVersion,
        Parameters.after,
        Parameters.key,
        Parameters.label,
        Parameters.select
      ],
      urlParameters: [Parameters.endpoint],
      headerParameters: [
        Parameters.syncToken,
        Parameters.acceptDatetime,
        Parameters.accept1
      ],
      serializer
    };
const checkRevisionsOperationSpec: coreClient.OperationSpec = {
      path: "/revisions",
      httpMethod: "HEAD",
      responses: {
        200: {
          headersMapper: Mappers.ConfigurationClientCheckRevisionsHeaders
        },
        default: {}
      },
      queryParameters: [
        Parameters.apiVersion,
        Parameters.after,
        Parameters.key,
        Parameters.label,
        Parameters.select
      ],
      urlParameters: [Parameters.endpoint],
      headerParameters: [Parameters.syncToken, Parameters.acceptDatetime],
      serializer
    };
const getKeysNextOperationSpec: coreClient.OperationSpec = {
      path: "{nextLink}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.KeyListResult,
          headersMapper: Mappers.ConfigurationClientGetKeysNextHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      urlParameters: [Parameters.endpoint, Parameters.nextLink],
      headerParameters: [
        Parameters.accept,
        Parameters.syncToken,
        Parameters.acceptDatetime
      ],
      serializer
    };
const getKeyValuesNextOperationSpec: coreClient.OperationSpec = {
      path: "{nextLink}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.KeyValueListResult,
          headersMapper: Mappers.ConfigurationClientGetKeyValuesNextHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      urlParameters: [Parameters.endpoint, Parameters.nextLink],
      headerParameters: [
        Parameters.syncToken,
        Parameters.acceptDatetime,
        Parameters.accept1
      ],
      serializer
    };
const getLabelsNextOperationSpec: coreClient.OperationSpec = {
      path: "{nextLink}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.LabelListResult,
          headersMapper: Mappers.ConfigurationClientGetLabelsNextHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      urlParameters: [Parameters.endpoint, Parameters.nextLink],
      headerParameters: [
        Parameters.syncToken,
        Parameters.acceptDatetime,
        Parameters.accept3
      ],
      serializer
    };
const getRevisionsNextOperationSpec: coreClient.OperationSpec = {
      path: "{nextLink}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: Mappers.KeyValueListResult,
          headersMapper: Mappers.ConfigurationClientGetRevisionsNextHeaders
        },
        default: {
          bodyMapper: Mappers.ErrorModel
        }
      },
      urlParameters: [Parameters.endpoint, Parameters.nextLink],
      headerParameters: [
        Parameters.syncToken,
        Parameters.acceptDatetime,
        Parameters.accept1
      ],
      serializer
    };
