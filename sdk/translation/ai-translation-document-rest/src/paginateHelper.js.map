{"version":3,"file":"paginateHelper.js","sourceRoot":"","sources":["paginateHelper.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAElC,oDAI4B;AAC5B,yDAIiC;AAyCjC;;;;;;GAMG;AACH,SAAgB,QAAQ,CACtB,MAAc,EACd,eAA0B,EAC1B,UAAoC,EAAE;IAItC,IAAI,QAAQ,GAAG,IAAI,CAAC;IACpB,MAAM,QAAQ,GAAG,OAAO,CAAC;IACzB,MAAM,YAAY,GAAG,UAAU,CAAC;IAChC,MAAM,EAAE,aAAa,EAAE,GAAG,OAAO,CAAC;IAClC,MAAM,WAAW,GAA4B;QAC3C,aAAa,EAAE,EAAE;QACjB,OAAO,EACL,OAAO,aAAa,KAAK,UAAU;YACjC,CAAC,CAAC,aAAa;YACf,CAAC,CAAC,KAAK,EAAE,QAAgB,EAAE,EAAE;gBACzB,MAAM,MAAM,GAAG,QAAQ;oBACrB,CAAC,CAAC,eAAe;oBACjB,CAAC,CAAC,MAAM,MAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC,GAAG,EAAE,CAAC;gBAC/C,QAAQ,GAAG,KAAK,CAAC;gBACjB,kBAAkB,CAAC,MAAM,CAAC,CAAC;gBAC3B,MAAM,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;gBACxD,MAAM,MAAM,GAAG,WAAW,CAAW,MAAM,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;gBAC5D,OAAO;oBACL,IAAI,EAAE,MAAM;oBACZ,YAAY,EAAE,QAAQ;iBACvB,CAAC;YACJ,CAAC;KACR,CAAC;IAEF,OAAO,IAAA,mCAAqB,EAAC,WAAW,CAAC,CAAC;AAC5C,CAAC;AAhCD,4BAgCC;AAED;;GAEG;AACH,SAAS,WAAW,CAAC,IAAa,EAAE,YAAqB;IACvD,IAAI,CAAC,YAAY,EAAE,CAAC;QAClB,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,MAAM,QAAQ,GAAI,IAAgC,CAAC,YAAY,CAAC,CAAC;IAEjE,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;QACpE,MAAM,IAAI,KAAK,CACb,iBAAiB,YAAY,kCAAkC,CAChE,CAAC;IACJ,CAAC;IAED,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED;;GAEG;AACH,SAAS,WAAW,CAAc,IAAa,EAAE,QAAgB;IAC/D,MAAM,KAAK,GAAI,IAAgC,CAAC,QAAQ,CAAQ,CAAC;IAEjE,qEAAqE;IACrE,qEAAqE;IACrE,iDAAiD;IACjD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QAC1B,MAAM,IAAI,KAAK,CACb,kFAAkF,QAAQ,EAAE,CAC7F,CAAC;IACJ,CAAC;IAED,OAAO,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,EAAE,CAAC;AACrB,CAAC;AAED;;GAEG;AACH,SAAS,kBAAkB,CAAC,QAA+B;IACzD,MAAM,kBAAkB,GAAG;QACzB,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;KACN,CAAC;IACF,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;QAClD,MAAM,IAAA,6BAAe,EACnB,gDAAgD,QAAQ,CAAC,MAAM,EAAE,EACjE,QAAQ,CACT,CAAC;IACJ,CAAC;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  getPagedAsyncIterator,\n  PagedAsyncIterableIterator,\n  PagedResult,\n} from \"@azure/core-paging\";\nimport {\n  Client,\n  createRestError,\n  PathUncheckedResponse,\n} from \"@azure-rest/core-client\";\n\n/**\n * Helper type to extract the type of an array\n */\nexport type GetArrayType<T> = T extends Array<infer TData> ? TData : never;\n\n/**\n * The type of a custom function that defines how to get a page and a link to the next one if any.\n */\nexport type GetPage<TPage> = (\n  pageLink: string,\n  maxPageSize?: number,\n) => Promise<{\n  page: TPage;\n  nextPageLink?: string;\n}>;\n\n/**\n * Options for the paging helper\n */\nexport interface PagingOptions<TResponse> {\n  /**\n   * Custom function to extract pagination details for crating the PagedAsyncIterableIterator\n   */\n  customGetPage?: GetPage<PaginateReturn<TResponse>[]>;\n}\n\n/**\n * Helper type to infer the Type of the paged elements from the response type\n * This type is generated based on the swagger information for x-ms-pageable\n * specifically on the itemName property which indicates the property of the response\n * where the page items are found. The default value is `value`.\n * This type will allow us to provide strongly typed Iterator based on the response we get as second parameter\n */\nexport type PaginateReturn<TResult> = TResult extends {\n  body: { value?: infer TPage };\n}\n  ? GetArrayType<TPage>\n  : Array<unknown>;\n\n/**\n * Helper to paginate results from an initial response that follows the specification of Autorest `x-ms-pageable` extension\n * @param client - Client to use for sending the next page requests\n * @param initialResponse - Initial response containing the nextLink and current page of elements\n * @param customGetPage - Optional - Function to define how to extract the page and next link to be used to paginate the results\n * @returns - PagedAsyncIterableIterator to iterate the elements\n */\nexport function paginate<TResponse extends PathUncheckedResponse>(\n  client: Client,\n  initialResponse: TResponse,\n  options: PagingOptions<TResponse> = {},\n): PagedAsyncIterableIterator<PaginateReturn<TResponse>> {\n  // Extract element type from initial response\n  type TElement = PaginateReturn<TResponse>;\n  let firstRun = true;\n  const itemName = \"value\";\n  const nextLinkName = \"nextLink\";\n  const { customGetPage } = options;\n  const pagedResult: PagedResult<TElement[]> = {\n    firstPageLink: \"\",\n    getPage:\n      typeof customGetPage === \"function\"\n        ? customGetPage\n        : async (pageLink: string) => {\n            const result = firstRun\n              ? initialResponse\n              : await client.pathUnchecked(pageLink).get();\n            firstRun = false;\n            checkPagingRequest(result);\n            const nextLink = getNextLink(result.body, nextLinkName);\n            const values = getElements<TElement>(result.body, itemName);\n            return {\n              page: values,\n              nextPageLink: nextLink,\n            };\n          },\n  };\n\n  return getPagedAsyncIterator(pagedResult);\n}\n\n/**\n * Gets for the value of nextLink in the body\n */\nfunction getNextLink(body: unknown, nextLinkName?: string): string | undefined {\n  if (!nextLinkName) {\n    return undefined;\n  }\n\n  const nextLink = (body as Record<string, unknown>)[nextLinkName];\n\n  if (typeof nextLink !== \"string\" && typeof nextLink !== \"undefined\") {\n    throw new Error(\n      `Body Property ${nextLinkName} should be a string or undefined`,\n    );\n  }\n\n  return nextLink;\n}\n\n/**\n * Gets the elements of the current request in the body.\n */\nfunction getElements<T = unknown>(body: unknown, itemName: string): T[] {\n  const value = (body as Record<string, unknown>)[itemName] as T[];\n\n  // value has to be an array according to the x-ms-pageable extension.\n  // The fact that this must be an array is used above to calculate the\n  // type of elements in the page in PaginateReturn\n  if (!Array.isArray(value)) {\n    throw new Error(\n      `Couldn't paginate response\\n Body doesn't contain an array property with name: ${itemName}`,\n    );\n  }\n\n  return value ?? [];\n}\n\n/**\n * Checks if a request failed\n */\nfunction checkPagingRequest(response: PathUncheckedResponse): void {\n  const Http2xxStatusCodes = [\n    \"200\",\n    \"201\",\n    \"202\",\n    \"203\",\n    \"204\",\n    \"205\",\n    \"206\",\n    \"207\",\n    \"208\",\n    \"226\",\n  ];\n  if (!Http2xxStatusCodes.includes(response.status)) {\n    throw createRestError(\n      `Pagination failed with unexpected statusCode ${response.status}`,\n      response,\n    );\n  }\n}\n"]}