## API Report File for "@azure/arm-batch"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

// @public
export interface AccessRule {
    name?: string;
    properties?: AccessRuleProperties;
}

// @public
export type AccessRuleDirection = string;

// @public
export interface AccessRuleProperties {
    addressPrefixes?: string[];
    direction?: AccessRuleDirection;
    emailAddresses?: string[];
    fullyQualifiedDomainNames?: string[];
    networkSecurityPerimeters?: NetworkSecurityPerimeter[];
    phoneNumbers?: string[];
    subscriptions?: AccessRulePropertiesSubscriptionsItem[];
}

// @public
export interface AccessRulePropertiesSubscriptionsItem {
    id?: string;
}

// @public
export type AccountKeyType = "Primary" | "Secondary";

// @public
export interface ActivateApplicationPackageParameters {
    format: string;
}

// @public
export type AllocationState = "Steady" | "Resizing" | "Stopping";

// @public
export interface Application extends AzureProxyResource {
    allowUpdates?: boolean;
    defaultVersion?: string;
    displayName?: string;
}

// @public
export interface ApplicationCreateOptionalParams extends coreClient.OperationOptions {
    parameters?: Application;
}

// @public
export type ApplicationCreateResponse = Application;

// @public
export interface ApplicationDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ApplicationGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationGetResponse = Application;

// @public
export interface ApplicationListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationListNextResponse = ListApplicationsResult;

// @public
export interface ApplicationListOptionalParams extends coreClient.OperationOptions {
    maxresults?: number;
}

// @public
export type ApplicationListResponse = ListApplicationsResult;

// @public
export interface ApplicationOperations {
    create(resourceGroupName: string, accountName: string, applicationName: string, options?: ApplicationCreateOptionalParams): Promise<ApplicationCreateResponse>;
    delete(resourceGroupName: string, accountName: string, applicationName: string, options?: ApplicationDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, applicationName: string, options?: ApplicationGetOptionalParams): Promise<ApplicationGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: ApplicationListOptionalParams): PagedAsyncIterableIterator<Application>;
    update(resourceGroupName: string, accountName: string, applicationName: string, parameters: Application, options?: ApplicationUpdateOptionalParams): Promise<ApplicationUpdateResponse>;
}

// @public
export interface ApplicationPackage extends AzureProxyResource {
    readonly format?: string;
    readonly lastActivationTime?: Date;
    readonly state?: PackageState;
    readonly storageUrl?: string;
    readonly storageUrlExpiry?: Date;
}

// @public
export interface ApplicationPackageActivateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationPackageActivateResponse = ApplicationPackage;

// @public
export interface ApplicationPackageCreateOptionalParams extends coreClient.OperationOptions {
    parameters?: ApplicationPackage;
}

// @public
export type ApplicationPackageCreateResponse = ApplicationPackage;

// @public
export interface ApplicationPackageDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ApplicationPackageGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationPackageGetResponse = ApplicationPackage;

// @public
export interface ApplicationPackageListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationPackageListNextResponse = ListApplicationPackagesResult;

// @public
export interface ApplicationPackageListOptionalParams extends coreClient.OperationOptions {
    maxresults?: number;
}

// @public
export type ApplicationPackageListResponse = ListApplicationPackagesResult;

// @public
export interface ApplicationPackageOperations {
    activate(resourceGroupName: string, accountName: string, applicationName: string, versionName: string, parameters: ActivateApplicationPackageParameters, options?: ApplicationPackageActivateOptionalParams): Promise<ApplicationPackageActivateResponse>;
    create(resourceGroupName: string, accountName: string, applicationName: string, versionName: string, options?: ApplicationPackageCreateOptionalParams): Promise<ApplicationPackageCreateResponse>;
    delete(resourceGroupName: string, accountName: string, applicationName: string, versionName: string, options?: ApplicationPackageDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, applicationName: string, versionName: string, options?: ApplicationPackageGetOptionalParams): Promise<ApplicationPackageGetResponse>;
    list(resourceGroupName: string, accountName: string, applicationName: string, options?: ApplicationPackageListOptionalParams): PagedAsyncIterableIterator<ApplicationPackage>;
}

// @public
export interface ApplicationPackageReference {
    id: string;
    version?: string;
}

// @public
export interface ApplicationUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationUpdateResponse = Application;

// @public
export type AuthenticationMode = "SharedKey" | "AAD" | "TaskAuthenticationToken";

// @public
export interface AutomaticOSUpgradePolicy {
    disableAutomaticRollback?: boolean;
    enableAutomaticOSUpgrade?: boolean;
    osRollingUpgradeDeferral?: boolean;
    useRollingUpgradePolicy?: boolean;
}

// @public
export interface AutoScaleRun {
    error?: AutoScaleRunError;
    evaluationTime: Date;
    results?: string;
}

// @public
export interface AutoScaleRunError {
    code: string;
    details?: AutoScaleRunError[];
    message: string;
}

// @public
export interface AutoScaleSettings {
    evaluationInterval?: string;
    formula: string;
}

// @public
export type AutoStorageAuthenticationMode = "StorageKeys" | "BatchAccountManagedIdentity";

// @public
export interface AutoStorageBaseProperties {
    authenticationMode?: AutoStorageAuthenticationMode;
    nodeIdentityReference?: ComputeNodeIdentityReference;
    storageAccountId: string;
}

// @public
export interface AutoStorageProperties extends AutoStorageBaseProperties {
    lastKeySync: Date;
}

// @public
export type AutoUserScope = "Task" | "Pool";

// @public
export interface AutoUserSpecification {
    elevationLevel?: ElevationLevel;
    scope?: AutoUserScope;
}

// @public
export interface AzureBlobFileSystemConfiguration {
    accountKey?: string;
    accountName: string;
    blobfuseOptions?: string;
    containerName: string;
    identityReference?: ComputeNodeIdentityReference;
    relativeMountPath: string;
    sasKey?: string;
}

// @public
export interface AzureFileShareConfiguration {
    accountKey: string;
    accountName: string;
    azureFileUrl: string;
    mountOptions?: string;
    relativeMountPath: string;
}

// @public
export interface AzureProxyResource {
    readonly etag?: string;
    readonly id?: string;
    readonly name?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export interface AzureResource {
    readonly id?: string;
    readonly location?: string;
    readonly name?: string;
    readonly tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export interface BatchAccount extends AzureResource {
    readonly accountEndpoint?: string;
    readonly activeJobAndJobScheduleQuota?: number;
    readonly allowedAuthenticationModes?: AuthenticationMode[];
    readonly autoStorage?: AutoStorageProperties;
    readonly dedicatedCoreQuota?: number;
    readonly dedicatedCoreQuotaPerVMFamily?: VirtualMachineFamilyCoreQuota[];
    readonly dedicatedCoreQuotaPerVMFamilyEnforced?: boolean;
    readonly encryption?: EncryptionProperties;
    identity?: BatchAccountIdentity;
    readonly keyVaultReference?: KeyVaultReference;
    readonly lowPriorityCoreQuota?: number;
    networkProfile?: NetworkProfile;
    readonly nodeManagementEndpoint?: string;
    readonly poolAllocationMode?: PoolAllocationMode;
    readonly poolQuota?: number;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    readonly provisioningState?: ProvisioningState;
    publicNetworkAccess?: PublicNetworkAccessType;
}

// @public
export interface BatchAccountCreateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface BatchAccountCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BatchAccountCreateParameters {
    allowedAuthenticationModes?: AuthenticationMode[];
    autoStorage?: AutoStorageBaseProperties;
    encryption?: EncryptionProperties;
    identity?: BatchAccountIdentity;
    keyVaultReference?: KeyVaultReference;
    location: string;
    networkProfile?: NetworkProfile;
    poolAllocationMode?: PoolAllocationMode;
    publicNetworkAccess?: PublicNetworkAccessType;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type BatchAccountCreateResponse = BatchAccount;

// @public
export interface BatchAccountDeleteHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface BatchAccountDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BatchAccountGetDetectorOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountGetDetectorResponse = DetectorResponse;

// @public
export interface BatchAccountGetKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountGetKeysResponse = BatchAccountKeys;

// @public
export interface BatchAccountGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountGetResponse = BatchAccount;

// @public
export interface BatchAccountIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ResourceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentities;
    };
}

// @public
export interface BatchAccountKeys {
    readonly accountName?: string;
    readonly primary?: string;
    readonly secondary?: string;
}

// @public
export interface BatchAccountListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountListByResourceGroupNextResponse = BatchAccountListResult;

// @public
export interface BatchAccountListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountListByResourceGroupResponse = BatchAccountListResult;

// @public
export interface BatchAccountListDetectorsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountListDetectorsNextResponse = DetectorListResult;

// @public
export interface BatchAccountListDetectorsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountListDetectorsResponse = DetectorListResult;

// @public
export interface BatchAccountListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountListNextResponse = BatchAccountListResult;

// @public
export interface BatchAccountListOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface BatchAccountListOutboundNetworkDependenciesEndpointsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountListOutboundNetworkDependenciesEndpointsNextResponse = OutboundEnvironmentEndpointCollection;

// @public
export interface BatchAccountListOutboundNetworkDependenciesEndpointsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BatchAccountListOutboundNetworkDependenciesEndpointsResponse = OutboundEnvironmentEndpointCollection;

// @public
export type BatchAccountListResponse = BatchAccountListResult;

// @public
export interface BatchAccountListResult {
    nextLink?: string;
    value?: BatchAccount[];
}

// @public
export interface BatchAccountOperations {
    beginCreate(resourceGroupName: string, accountName: string, parameters: BatchAccountCreateParameters, options?: BatchAccountCreateOptionalParams): Promise<SimplePollerLike<OperationState<BatchAccountCreateResponse>, BatchAccountCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, parameters: BatchAccountCreateParameters, options?: BatchAccountCreateOptionalParams): Promise<BatchAccountCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, options?: BatchAccountDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, options?: BatchAccountDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, options?: BatchAccountGetOptionalParams): Promise<BatchAccountGetResponse>;
    getDetector(resourceGroupName: string, accountName: string, detectorId: string, options?: BatchAccountGetDetectorOptionalParams): Promise<BatchAccountGetDetectorResponse>;
    getKeys(resourceGroupName: string, accountName: string, options?: BatchAccountGetKeysOptionalParams): Promise<BatchAccountGetKeysResponse>;
    list(options?: BatchAccountListOptionalParams): PagedAsyncIterableIterator<BatchAccount>;
    listByResourceGroup(resourceGroupName: string, options?: BatchAccountListByResourceGroupOptionalParams): PagedAsyncIterableIterator<BatchAccount>;
    listDetectors(resourceGroupName: string, accountName: string, options?: BatchAccountListDetectorsOptionalParams): PagedAsyncIterableIterator<DetectorResponse>;
    listOutboundNetworkDependenciesEndpoints(resourceGroupName: string, accountName: string, options?: BatchAccountListOutboundNetworkDependenciesEndpointsOptionalParams): PagedAsyncIterableIterator<OutboundEnvironmentEndpoint>;
    regenerateKey(resourceGroupName: string, accountName: string, parameters: BatchAccountRegenerateKeyParameters, options?: BatchAccountRegenerateKeyOptionalParams): Promise<BatchAccountRegenerateKeyResponse>;
    synchronizeAutoStorageKeys(resourceGroupName: string, accountName: string, options?: BatchAccountSynchronizeAutoStorageKeysOptionalParams): Promise<void>;
    update(resourceGroupName: string, accountName: string, parameters: BatchAccountUpdateParameters, options?: BatchAccountUpdateOptionalParams): Promise<BatchAccountUpdateResponse>;
}

// @public
export interface BatchAccountRegenerateKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface BatchAccountRegenerateKeyParameters {
    keyName: AccountKeyType;
}

// @public
export type BatchAccountRegenerateKeyResponse = BatchAccountKeys;

// @public
export interface BatchAccountSynchronizeAutoStorageKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface BatchAccountUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface BatchAccountUpdateParameters {
    allowedAuthenticationModes?: AuthenticationMode[];
    autoStorage?: AutoStorageBaseProperties;
    encryption?: EncryptionProperties;
    identity?: BatchAccountIdentity;
    networkProfile?: NetworkProfile;
    publicNetworkAccess?: PublicNetworkAccessType;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type BatchAccountUpdateResponse = BatchAccount;

// @public
export interface BatchLocationQuota {
    readonly accountQuota?: number;
}

// @public (undocumented)
export class BatchManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: BatchManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    applicationOperations: ApplicationOperations;
    // (undocumented)
    applicationPackageOperations: ApplicationPackageOperations;
    // (undocumented)
    batchAccountOperations: BatchAccountOperations;
    // (undocumented)
    certificateOperations: CertificateOperations;
    // (undocumented)
    location: Location_2;
    // (undocumented)
    networkSecurityPerimeterOperations: NetworkSecurityPerimeterOperations;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    poolOperations: PoolOperations;
    // (undocumented)
    privateEndpointConnectionOperations: PrivateEndpointConnectionOperations;
    // (undocumented)
    privateLinkResourceOperations: PrivateLinkResourceOperations;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface BatchManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface BatchPoolIdentity {
    type: PoolIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentities;
    };
}

// @public
export type CachingType = "None" | "ReadOnly" | "ReadWrite";

// @public
export interface Certificate extends AzureProxyResource {
    readonly deleteCertificateError?: DeleteCertificateError;
    format?: CertificateFormat;
    readonly previousProvisioningState?: CertificateProvisioningState;
    readonly previousProvisioningStateTransitionTime?: Date;
    readonly provisioningState?: CertificateProvisioningState;
    readonly provisioningStateTransitionTime?: Date;
    readonly publicData?: string;
    thumbprint?: string;
    thumbprintAlgorithm?: string;
}

// @public
export interface CertificateBaseProperties {
    format?: CertificateFormat;
    thumbprint?: string;
    thumbprintAlgorithm?: string;
}

// @public
export interface CertificateCancelDeletionHeaders {
    eTag?: string;
}

// @public
export interface CertificateCancelDeletionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CertificateCancelDeletionResponse = CertificateCancelDeletionHeaders & Certificate;

// @public
export interface CertificateCreateHeaders {
    eTag?: string;
}

// @public
export interface CertificateCreateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export interface CertificateCreateOrUpdateParameters extends AzureProxyResource {
    data?: string;
    format?: CertificateFormat;
    password?: string;
    thumbprint?: string;
    thumbprintAlgorithm?: string;
}

// @public
export interface CertificateCreateOrUpdateProperties extends CertificateBaseProperties {
    data: string;
    password?: string;
}

// @public
export type CertificateCreateResponse = CertificateCreateHeaders & Certificate;

// @public
export interface CertificateDeleteHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface CertificateDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CertificateFormat = "Pfx" | "Cer";

// @public
export interface CertificateGetHeaders {
    eTag?: string;
}

// @public
export interface CertificateGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CertificateGetResponse = CertificateGetHeaders & Certificate;

// @public
export interface CertificateListByBatchAccountNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CertificateListByBatchAccountNextResponse = ListCertificatesResult;

// @public
export interface CertificateListByBatchAccountOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    maxresults?: number;
    select?: string;
}

// @public
export type CertificateListByBatchAccountResponse = ListCertificatesResult;

// @public
export interface CertificateOperations {
    beginDelete(resourceGroupName: string, accountName: string, certificateName: string, options?: CertificateDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, certificateName: string, options?: CertificateDeleteOptionalParams): Promise<void>;
    cancelDeletion(resourceGroupName: string, accountName: string, certificateName: string, options?: CertificateCancelDeletionOptionalParams): Promise<CertificateCancelDeletionResponse>;
    create(resourceGroupName: string, accountName: string, certificateName: string, parameters: CertificateCreateOrUpdateParameters, options?: CertificateCreateOptionalParams): Promise<CertificateCreateResponse>;
    get(resourceGroupName: string, accountName: string, certificateName: string, options?: CertificateGetOptionalParams): Promise<CertificateGetResponse>;
    listByBatchAccount(resourceGroupName: string, accountName: string, options?: CertificateListByBatchAccountOptionalParams): PagedAsyncIterableIterator<Certificate>;
    update(resourceGroupName: string, accountName: string, certificateName: string, parameters: CertificateCreateOrUpdateParameters, options?: CertificateUpdateOptionalParams): Promise<CertificateUpdateResponse>;
}

// @public
export interface CertificateProperties extends CertificateBaseProperties {
    readonly deleteCertificateError?: DeleteCertificateError;
    readonly previousProvisioningState?: CertificateProvisioningState;
    readonly previousProvisioningStateTransitionTime?: Date;
    readonly provisioningState?: CertificateProvisioningState;
    readonly provisioningStateTransitionTime?: Date;
    readonly publicData?: string;
}

// @public
export type CertificateProvisioningState = "Succeeded" | "Deleting" | "Failed";

// @public
export interface CertificateReference {
    id: string;
    storeLocation?: CertificateStoreLocation;
    storeName?: string;
    visibility?: CertificateVisibility[];
}

// @public
export type CertificateStoreLocation = "CurrentUser" | "LocalMachine";

// @public
export interface CertificateUpdateHeaders {
    eTag?: string;
}

// @public
export interface CertificateUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
}

// @public
export type CertificateUpdateResponse = CertificateUpdateHeaders & Certificate;

// @public
export type CertificateVisibility = "StartTask" | "Task" | "RemoteUser";

// @public
export interface CheckNameAvailabilityParameters {
    name: string;
    type: "Microsoft.Batch/batchAccounts";
}

// @public
export interface CheckNameAvailabilityResult {
    readonly message?: string;
    readonly nameAvailable?: boolean;
    readonly reason?: NameAvailabilityReason;
}

// @public
export interface CifsMountConfiguration {
    mountOptions?: string;
    password: string;
    relativeMountPath: string;
    source: string;
    userName: string;
}

// @public
export interface CloudError {
    error?: CloudErrorBody;
}

// @public
export interface CloudErrorBody {
    code?: string;
    details?: CloudErrorBody[];
    message?: string;
    target?: string;
}

// @public
export type ComputeNodeDeallocationOption = "Requeue" | "Terminate" | "TaskCompletion" | "RetainedData";

// @public
export type ComputeNodeFillType = "Spread" | "Pack";

// @public
export interface ComputeNodeIdentityReference {
    resourceId?: string;
}

// @public
export interface ContainerConfiguration {
    containerImageNames?: string[];
    containerRegistries?: ContainerRegistry[];
    type: ContainerType;
}

// @public
export interface ContainerHostBatchBindMountEntry {
    isReadOnly?: boolean;
    source?: ContainerHostDataPath;
}

// @public
export type ContainerHostDataPath = string;

// @public
export interface ContainerRegistry {
    identityReference?: ComputeNodeIdentityReference;
    password?: string;
    registryServer?: string;
    userName?: string;
}

// @public
export type ContainerType = string;

// @public
export type ContainerWorkingDirectory = "TaskWorkingDirectory" | "ContainerImageDefault";

// @public
export type CreatedByType = string;

// @public
export interface DataDisk {
    caching?: CachingType;
    diskSizeGB: number;
    lun: number;
    storageAccountType?: StorageAccountType;
}

// @public
export interface DeleteCertificateError {
    code: string;
    details?: DeleteCertificateError[];
    message: string;
    target?: string;
}

// @public
export interface DeploymentConfiguration {
    virtualMachineConfiguration?: VirtualMachineConfiguration;
}

// @public
export interface DetectorListResult {
    nextLink?: string;
    value?: DetectorResponse[];
}

// @public
export interface DetectorResponse extends AzureProxyResource {
    value?: string;
}

// @public
export interface DiffDiskSettings {
    placement?: "CacheDisk";
}

// @public
export interface DiskEncryptionConfiguration {
    targets?: DiskEncryptionTarget[];
}

// @public
export type DiskEncryptionTarget = "OsDisk" | "TemporaryDisk";

// @public
export type DynamicVNetAssignmentScope = "none" | "job";

// @public
export type ElevationLevel = "NonAdmin" | "Admin";

// @public
export interface EncryptionProperties {
    keySource?: KeySource;
    keyVaultProperties?: KeyVaultProperties;
}

// @public
export type EndpointAccessDefaultAction = "Allow" | "Deny";

// @public
export interface EndpointAccessProfile {
    defaultAction: EndpointAccessDefaultAction;
    ipRules?: IPRule[];
}

// @public
export interface EndpointDependency {
    readonly description?: string;
    readonly domainName?: string;
    readonly endpointDetails?: EndpointDetail[];
}

// @public
export interface EndpointDetail {
    readonly port?: number;
}

// @public
export interface EnvironmentSetting {
    name: string;
    value?: string;
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface FixedScaleSettings {
    nodeDeallocationOption?: ComputeNodeDeallocationOption;
    resizeTimeout?: string;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
}

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface ImageReference {
    communityGalleryImageId?: string;
    id?: string;
    offer?: string;
    publisher?: string;
    sharedGalleryImageId?: string;
    sku?: string;
    version?: string;
}

// @public
export type InboundEndpointProtocol = "TCP" | "UDP";

// @public
export interface InboundNatPool {
    backendPort: number;
    frontendPortRangeEnd: number;
    frontendPortRangeStart: number;
    name: string;
    networkSecurityGroupRules?: NetworkSecurityGroupRule[];
    protocol: InboundEndpointProtocol;
}

// @public
export type InterNodeCommunicationState = "Enabled" | "Disabled";

// @public
export type IPAddressProvisioningType = "BatchManaged" | "UserManaged" | "NoPublicIPAddresses";

// @public
export interface IPRule {
    action: "Allow";
    value: string;
}

// @public
export type IssueType = string;

// @public
export type KeySource = "Microsoft.Batch" | "Microsoft.KeyVault";

// @public
export interface KeyVaultProperties {
    keyIdentifier?: string;
}

// @public
export interface KeyVaultReference {
    id: string;
    url: string;
}

// @public
export enum KnownAccessRuleDirection {
    Inbound = "Inbound",
    Outbound = "Outbound"
}

// @public
export enum KnownContainerHostDataPath {
    Applications = "Applications",
    JobPrep = "JobPrep",
    Shared = "Shared",
    Startup = "Startup",
    Task = "Task",
    VfsMounts = "VfsMounts"
}

// @public
export enum KnownContainerType {
    CriCompatible = "CriCompatible",
    DockerCompatible = "DockerCompatible"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownIssueType {
    ConfigurationPropagationFailure = "ConfigurationPropagationFailure",
    MissingIdentityConfiguration = "MissingIdentityConfiguration",
    MissingPerimeterConfiguration = "MissingPerimeterConfiguration",
    Unknown = "Unknown"
}

// @public
export enum KnownNetworkSecurityPerimeterConfigurationProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownResourceAssociationAccessMode {
    Audit = "Audit",
    Enforced = "Enforced",
    Learning = "Learning"
}

// @public
export enum KnownSecurityEncryptionTypes {
    NonPersistedTPM = "NonPersistedTPM",
    VMGuestStateOnly = "VMGuestStateOnly"
}

// @public
export enum KnownSeverity {
    Error = "Error",
    Warning = "Warning"
}

// @public
export interface LinuxUserConfiguration {
    gid?: number;
    sshPrivateKey?: string;
    uid?: number;
}

// @public
export interface ListApplicationPackagesResult {
    nextLink?: string;
    value?: ApplicationPackage[];
}

// @public
export interface ListApplicationsResult {
    nextLink?: string;
    value?: Application[];
}

// @public
export interface ListCertificatesResult {
    nextLink?: string;
    value?: Certificate[];
}

// @public
export interface ListPoolsResult {
    nextLink?: string;
    value?: Pool[];
}

// @public
export interface ListPrivateEndpointConnectionsResult {
    nextLink?: string;
    value?: PrivateEndpointConnection[];
}

// @public
export interface ListPrivateLinkResourcesResult {
    nextLink?: string;
    value?: PrivateLinkResource[];
}

// @public
interface Location_2 {
    checkNameAvailability(locationName: string, parameters: CheckNameAvailabilityParameters, options?: LocationCheckNameAvailabilityOptionalParams): Promise<LocationCheckNameAvailabilityResponse>;
    getQuotas(locationName: string, options?: LocationGetQuotasOptionalParams): Promise<LocationGetQuotasResponse>;
    listSupportedVirtualMachineSkus(locationName: string, options?: LocationListSupportedVirtualMachineSkusOptionalParams): PagedAsyncIterableIterator<SupportedSku>;
}
export { Location_2 as Location }

// @public
export interface LocationCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationCheckNameAvailabilityResponse = CheckNameAvailabilityResult;

// @public
export interface LocationGetQuotasOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationGetQuotasResponse = BatchLocationQuota;

// @public
export interface LocationListSupportedVirtualMachineSkusNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationListSupportedVirtualMachineSkusNextResponse = SupportedSkusResult;

// @public
export interface LocationListSupportedVirtualMachineSkusOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    maxresults?: number;
}

// @public
export type LocationListSupportedVirtualMachineSkusResponse = SupportedSkusResult;

// @public
export type LoginMode = "Batch" | "Interactive";

// @public (undocumented)
export interface ManagedDisk {
    securityProfile?: VMDiskSecurityProfile;
    storageAccountType?: StorageAccountType;
}

// @public
export interface MetadataItem {
    name: string;
    value: string;
}

// @public
export interface MountConfiguration {
    azureBlobFileSystemConfiguration?: AzureBlobFileSystemConfiguration;
    azureFileShareConfiguration?: AzureFileShareConfiguration;
    cifsMountConfiguration?: CifsMountConfiguration;
    nfsMountConfiguration?: NFSMountConfiguration;
}

// @public
export type NameAvailabilityReason = "Invalid" | "AlreadyExists";

// @public
export interface NetworkConfiguration {
    dynamicVnetAssignmentScope?: DynamicVNetAssignmentScope;
    enableAcceleratedNetworking?: boolean;
    endpointConfiguration?: PoolEndpointConfiguration;
    publicIPAddressConfiguration?: PublicIPAddressConfiguration;
    subnetId?: string;
}

// @public
export interface NetworkProfile {
    accountAccess?: EndpointAccessProfile;
    nodeManagementAccess?: EndpointAccessProfile;
}

// @public
export interface NetworkSecurityGroupRule {
    access: NetworkSecurityGroupRuleAccess;
    priority: number;
    sourceAddressPrefix: string;
    sourcePortRanges?: string[];
}

// @public
export type NetworkSecurityGroupRuleAccess = "Allow" | "Deny";

// @public
export interface NetworkSecurityPerimeter {
    id?: string;
    location?: string;
    perimeterGuid?: string;
}

// @public
export interface NetworkSecurityPerimeterConfiguration extends ProxyResource {
    properties?: NetworkSecurityPerimeterConfigurationProperties;
}

// @public
export interface NetworkSecurityPerimeterConfigurationListResult {
    nextLink?: string;
    value?: NetworkSecurityPerimeterConfiguration[];
}

// @public
export interface NetworkSecurityPerimeterConfigurationProperties {
    networkSecurityPerimeter?: NetworkSecurityPerimeter;
    profile?: NetworkSecurityProfile;
    readonly provisioningIssues?: ProvisioningIssue[];
    readonly provisioningState?: NetworkSecurityPerimeterConfigurationProvisioningState;
    resourceAssociation?: ResourceAssociation;
}

// @public
export type NetworkSecurityPerimeterConfigurationProvisioningState = string;

// @public
export interface NetworkSecurityPerimeterGetConfigurationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkSecurityPerimeterGetConfigurationResponse = NetworkSecurityPerimeterConfiguration;

// @public
export interface NetworkSecurityPerimeterListConfigurationsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkSecurityPerimeterListConfigurationsNextResponse = NetworkSecurityPerimeterConfigurationListResult;

// @public
export interface NetworkSecurityPerimeterListConfigurationsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NetworkSecurityPerimeterListConfigurationsResponse = NetworkSecurityPerimeterConfigurationListResult;

// @public
export interface NetworkSecurityPerimeterOperations {
    beginReconcileConfiguration(resourceGroupName: string, accountName: string, networkSecurityPerimeterConfigurationName: string, options?: NetworkSecurityPerimeterReconcileConfigurationOptionalParams): Promise<SimplePollerLike<OperationState<NetworkSecurityPerimeterReconcileConfigurationResponse>, NetworkSecurityPerimeterReconcileConfigurationResponse>>;
    beginReconcileConfigurationAndWait(resourceGroupName: string, accountName: string, networkSecurityPerimeterConfigurationName: string, options?: NetworkSecurityPerimeterReconcileConfigurationOptionalParams): Promise<NetworkSecurityPerimeterReconcileConfigurationResponse>;
    getConfiguration(resourceGroupName: string, accountName: string, networkSecurityPerimeterConfigurationName: string, options?: NetworkSecurityPerimeterGetConfigurationOptionalParams): Promise<NetworkSecurityPerimeterGetConfigurationResponse>;
    listConfigurations(resourceGroupName: string, accountName: string, options?: NetworkSecurityPerimeterListConfigurationsOptionalParams): PagedAsyncIterableIterator<NetworkSecurityPerimeterConfiguration>;
}

// @public
export interface NetworkSecurityPerimeterReconcileConfigurationHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface NetworkSecurityPerimeterReconcileConfigurationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NetworkSecurityPerimeterReconcileConfigurationResponse = NetworkSecurityPerimeterReconcileConfigurationHeaders;

// @public
export interface NetworkSecurityProfile {
    accessRules?: AccessRule[];
    accessRulesVersion?: number;
    diagnosticSettingsVersion?: number;
    enabledLogCategories?: string[];
    name?: string;
}

// @public
export interface NFSMountConfiguration {
    mountOptions?: string;
    relativeMountPath: string;
    source: string;
}

// @public
export type NodeCommunicationMode = "Default" | "Classic" | "Simplified";

// @public
export interface NodePlacementConfiguration {
    policy?: NodePlacementPolicyType;
}

// @public
export type NodePlacementPolicyType = "Regional" | "Zonal";

// @public
export interface Operation {
    display?: OperationDisplay;
    isDataAction?: boolean;
    name?: string;
    origin?: string;
    properties?: Record<string, unknown>;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationListResult {
    nextLink?: string;
    value?: Operation[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = OperationListResult;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface OSDisk {
    caching?: CachingType;
    diskSizeGB?: number;
    ephemeralOSDiskSettings?: DiffDiskSettings;
    // (undocumented)
    managedDisk?: ManagedDisk;
    writeAcceleratorEnabled?: boolean;
}

// @public
export interface OutboundEnvironmentEndpoint {
    readonly category?: string;
    readonly endpoints?: EndpointDependency[];
}

// @public
export interface OutboundEnvironmentEndpointCollection {
    nextLink?: string;
    readonly value?: OutboundEnvironmentEndpoint[];
}

// @public
export type PackageState = "Pending" | "Active";

// @public
export interface Pool extends AzureProxyResource {
    readonly allocationState?: AllocationState;
    readonly allocationStateTransitionTime?: Date;
    applicationLicenses?: string[];
    applicationPackages?: ApplicationPackageReference[];
    readonly autoScaleRun?: AutoScaleRun;
    certificates?: CertificateReference[];
    readonly creationTime?: Date;
    readonly currentDedicatedNodes?: number;
    readonly currentLowPriorityNodes?: number;
    readonly currentNodeCommunicationMode?: NodeCommunicationMode;
    deploymentConfiguration?: DeploymentConfiguration;
    displayName?: string;
    identity?: BatchPoolIdentity;
    interNodeCommunication?: InterNodeCommunicationState;
    readonly lastModified?: Date;
    metadata?: MetadataItem[];
    mountConfiguration?: MountConfiguration[];
    networkConfiguration?: NetworkConfiguration;
    readonly provisioningState?: PoolProvisioningState;
    readonly provisioningStateTransitionTime?: Date;
    readonly resizeOperationStatus?: ResizeOperationStatus;
    resourceTags?: {
        [propertyName: string]: string;
    };
    scaleSettings?: ScaleSettings;
    startTask?: StartTask;
    targetNodeCommunicationMode?: NodeCommunicationMode;
    taskSchedulingPolicy?: TaskSchedulingPolicy;
    taskSlotsPerNode?: number;
    upgradePolicy?: UpgradePolicy;
    userAccounts?: UserAccount[];
    vmSize?: string;
}

// @public
export type PoolAllocationMode = "BatchService" | "UserSubscription";

// @public
export interface PoolCreateHeaders {
    eTag?: string;
}

// @public
export interface PoolCreateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export type PoolCreateResponse = PoolCreateHeaders & Pool;

// @public
export interface PoolDeleteHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface PoolDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PoolDisableAutoScaleHeaders {
    eTag?: string;
}

// @public
export interface PoolDisableAutoScaleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PoolDisableAutoScaleResponse = PoolDisableAutoScaleHeaders & Pool;

// @public
export interface PoolEndpointConfiguration {
    inboundNatPools: InboundNatPool[];
}

// @public
export interface PoolGetHeaders {
    eTag?: string;
}

// @public
export interface PoolGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PoolGetResponse = PoolGetHeaders & Pool;

// @public
export type PoolIdentityType = "UserAssigned" | "None";

// @public
export interface PoolListByBatchAccountNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PoolListByBatchAccountNextResponse = ListPoolsResult;

// @public
export interface PoolListByBatchAccountOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    maxresults?: number;
    select?: string;
}

// @public
export type PoolListByBatchAccountResponse = ListPoolsResult;

// @public
export interface PoolOperations {
    beginDelete(resourceGroupName: string, accountName: string, poolName: string, options?: PoolDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, poolName: string, options?: PoolDeleteOptionalParams): Promise<void>;
    create(resourceGroupName: string, accountName: string, poolName: string, parameters: Pool, options?: PoolCreateOptionalParams): Promise<PoolCreateResponse>;
    disableAutoScale(resourceGroupName: string, accountName: string, poolName: string, options?: PoolDisableAutoScaleOptionalParams): Promise<PoolDisableAutoScaleResponse>;
    get(resourceGroupName: string, accountName: string, poolName: string, options?: PoolGetOptionalParams): Promise<PoolGetResponse>;
    listByBatchAccount(resourceGroupName: string, accountName: string, options?: PoolListByBatchAccountOptionalParams): PagedAsyncIterableIterator<Pool>;
    stopResize(resourceGroupName: string, accountName: string, poolName: string, options?: PoolStopResizeOptionalParams): Promise<PoolStopResizeResponse>;
    update(resourceGroupName: string, accountName: string, poolName: string, parameters: Pool, options?: PoolUpdateOptionalParams): Promise<PoolUpdateResponse>;
}

// @public
export type PoolProvisioningState = "Succeeded" | "Deleting";

// @public
export interface PoolStopResizeHeaders {
    eTag?: string;
}

// @public
export interface PoolStopResizeOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PoolStopResizeResponse = PoolStopResizeHeaders & Pool;

// @public
export interface PoolUpdateHeaders {
    eTag?: string;
}

// @public
export interface PoolUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
}

// @public
export type PoolUpdateResponse = PoolUpdateHeaders & Pool;

// @public
export interface PrivateEndpoint {
    readonly id?: string;
}

// @public
export interface PrivateEndpointConnection extends AzureProxyResource {
    readonly groupIds?: string[];
    readonly privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
}

// @public
export interface PrivateEndpointConnectionDeleteHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface PrivateEndpointConnectionDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PrivateEndpointConnectionDeleteResponse = PrivateEndpointConnectionDeleteHeaders;

// @public
export interface PrivateEndpointConnectionGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionListByBatchAccountNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionListByBatchAccountNextResponse = ListPrivateEndpointConnectionsResult;

// @public
export interface PrivateEndpointConnectionListByBatchAccountOptionalParams extends coreClient.OperationOptions {
    maxresults?: number;
}

// @public
export type PrivateEndpointConnectionListByBatchAccountResponse = ListPrivateEndpointConnectionsResult;

// @public
export interface PrivateEndpointConnectionOperations {
    beginDelete(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionDeleteOptionalParams): Promise<SimplePollerLike<OperationState<PrivateEndpointConnectionDeleteResponse>, PrivateEndpointConnectionDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionDeleteOptionalParams): Promise<PrivateEndpointConnectionDeleteResponse>;
    beginUpdate(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionUpdateOptionalParams): Promise<SimplePollerLike<OperationState<PrivateEndpointConnectionUpdateResponse>, PrivateEndpointConnectionUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionUpdateOptionalParams): Promise<PrivateEndpointConnectionUpdateResponse>;
    get(resourceGroupName: string, accountName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionGetOptionalParams): Promise<PrivateEndpointConnectionGetResponse>;
    listByBatchAccount(resourceGroupName: string, accountName: string, options?: PrivateEndpointConnectionListByBatchAccountOptionalParams): PagedAsyncIterableIterator<PrivateEndpointConnection>;
}

// @public
export type PrivateEndpointConnectionProvisioningState = "Creating" | "Updating" | "Deleting" | "Succeeded" | "Failed" | "Cancelled";

// @public
export interface PrivateEndpointConnectionUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface PrivateEndpointConnectionUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PrivateEndpointConnectionUpdateResponse = PrivateEndpointConnection;

// @public
export interface PrivateLinkResource extends AzureProxyResource {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    readonly requiredZoneNames?: string[];
}

// @public
export interface PrivateLinkResourceGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourceGetResponse = PrivateLinkResource;

// @public
export interface PrivateLinkResourceListByBatchAccountNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourceListByBatchAccountNextResponse = ListPrivateLinkResourcesResult;

// @public
export interface PrivateLinkResourceListByBatchAccountOptionalParams extends coreClient.OperationOptions {
    maxresults?: number;
}

// @public
export type PrivateLinkResourceListByBatchAccountResponse = ListPrivateLinkResourcesResult;

// @public
export interface PrivateLinkResourceOperations {
    get(resourceGroupName: string, accountName: string, privateLinkResourceName: string, options?: PrivateLinkResourceGetOptionalParams): Promise<PrivateLinkResourceGetResponse>;
    listByBatchAccount(resourceGroupName: string, accountName: string, options?: PrivateLinkResourceListByBatchAccountOptionalParams): PagedAsyncIterableIterator<PrivateLinkResource>;
}

// @public
export interface PrivateLinkServiceConnectionState {
    readonly actionsRequired?: string;
    description?: string;
    status: PrivateLinkServiceConnectionStatus;
}

// @public
export type PrivateLinkServiceConnectionStatus = "Approved" | "Pending" | "Rejected" | "Disconnected";

// @public
export interface ProvisioningIssue {
    readonly name?: string;
    readonly properties?: ProvisioningIssueProperties;
}

// @public
export interface ProvisioningIssueProperties {
    readonly description?: string;
    readonly issueType?: IssueType;
    readonly severity?: Severity;
    readonly suggestedAccessRules?: AccessRule[];
    readonly suggestedResourceIds?: string[];
}

// @public
export type ProvisioningState = "Invalid" | "Creating" | "Deleting" | "Succeeded" | "Failed" | "Cancelled";

// @public
export interface ProxyResource extends Resource {
}

// @public
export interface PublicIPAddressConfiguration {
    ipAddressIds?: string[];
    provision?: IPAddressProvisioningType;
}

// @public
export type PublicNetworkAccessType = "Enabled" | "Disabled" | "SecuredByPerimeter";

// @public
export interface ResizeError {
    code: string;
    details?: ResizeError[];
    message: string;
}

// @public
export interface ResizeOperationStatus {
    errors?: ResizeError[];
    nodeDeallocationOption?: ComputeNodeDeallocationOption;
    resizeTimeout?: string;
    startTime?: Date;
    targetDedicatedNodes?: number;
    targetLowPriorityNodes?: number;
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceAssociation {
    accessMode?: ResourceAssociationAccessMode;
    name?: string;
}

// @public
export type ResourceAssociationAccessMode = string;

// @public
export interface ResourceFile {
    autoStorageContainerName?: string;
    blobPrefix?: string;
    fileMode?: string;
    filePath?: string;
    httpUrl?: string;
    identityReference?: ComputeNodeIdentityReference;
    storageContainerUrl?: string;
}

// @public
export type ResourceIdentityType = "SystemAssigned" | "UserAssigned" | "None";

// @public
export interface RollingUpgradePolicy {
    enableCrossZoneUpgrade?: boolean;
    maxBatchInstancePercent?: number;
    maxUnhealthyInstancePercent?: number;
    maxUnhealthyUpgradedInstancePercent?: number;
    pauseTimeBetweenBatches?: string;
    prioritizeUnhealthyInstances?: boolean;
    rollbackFailedInstancesOnPolicyBreach?: boolean;
}

// @public
export interface ScaleSettings {
    autoScale?: AutoScaleSettings;
    fixedScale?: FixedScaleSettings;
}

// @public
export type SecurityEncryptionTypes = string;

// @public
export interface SecurityProfile {
    encryptionAtHost?: boolean;
    securityType?: SecurityTypes;
    uefiSettings?: UefiSettings;
}

// @public
export type SecurityTypes = "trustedLaunch" | "confidentialVM";

// @public
export interface ServiceArtifactReference {
    id: string;
}

// @public
export type Severity = string;

// @public
export interface SkuCapability {
    readonly name?: string;
    readonly value?: string;
}

// @public
export interface StartTask {
    commandLine?: string;
    containerSettings?: TaskContainerSettings;
    environmentSettings?: EnvironmentSetting[];
    maxTaskRetryCount?: number;
    resourceFiles?: ResourceFile[];
    userIdentity?: UserIdentity;
    waitForSuccess?: boolean;
}

// @public
export type StorageAccountType = "Standard_LRS" | "Premium_LRS" | "StandardSSD_LRS";

// @public
export interface SupportedSku {
    readonly batchSupportEndOfLife?: Date;
    readonly capabilities?: SkuCapability[];
    readonly familyName?: string;
    readonly name?: string;
}

// @public
export interface SupportedSkusResult {
    readonly nextLink?: string;
    value: SupportedSku[];
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TaskContainerSettings {
    containerHostBatchBindMounts?: ContainerHostBatchBindMountEntry[];
    containerRunOptions?: string;
    imageName: string;
    registry?: ContainerRegistry;
    workingDirectory?: ContainerWorkingDirectory;
}

// @public
export interface TaskSchedulingPolicy {
    nodeFillType: ComputeNodeFillType;
}

// @public
export interface UefiSettings {
    secureBootEnabled?: boolean;
    vTpmEnabled?: boolean;
}

// @public
export type UpgradeMode = "automatic" | "manual" | "rolling";

// @public
export interface UpgradePolicy {
    automaticOSUpgradePolicy?: AutomaticOSUpgradePolicy;
    mode: UpgradeMode;
    rollingUpgradePolicy?: RollingUpgradePolicy;
}

// @public
export interface UserAccount {
    elevationLevel?: ElevationLevel;
    linuxUserConfiguration?: LinuxUserConfiguration;
    name: string;
    password: string;
    windowsUserConfiguration?: WindowsUserConfiguration;
}

// @public
export interface UserAssignedIdentities {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface UserIdentity {
    autoUser?: AutoUserSpecification;
    userName?: string;
}

// @public
export interface VirtualMachineConfiguration {
    containerConfiguration?: ContainerConfiguration;
    dataDisks?: DataDisk[];
    diskEncryptionConfiguration?: DiskEncryptionConfiguration;
    extensions?: VMExtension[];
    imageReference: ImageReference;
    licenseType?: string;
    nodeAgentSkuId: string;
    nodePlacementConfiguration?: NodePlacementConfiguration;
    osDisk?: OSDisk;
    securityProfile?: SecurityProfile;
    serviceArtifactReference?: ServiceArtifactReference;
    windowsConfiguration?: WindowsConfiguration;
}

// @public
export interface VirtualMachineFamilyCoreQuota {
    readonly coreQuota?: number;
    readonly name?: string;
}

// @public
export interface VMDiskSecurityProfile {
    securityEncryptionType?: SecurityEncryptionTypes;
}

// @public
export interface VMExtension {
    autoUpgradeMinorVersion?: boolean;
    enableAutomaticUpgrade?: boolean;
    name: string;
    protectedSettings?: Record<string, unknown>;
    provisionAfterExtensions?: string[];
    publisher: string;
    settings?: Record<string, unknown>;
    type: string;
    typeHandlerVersion?: string;
}

// @public
export interface WindowsConfiguration {
    enableAutomaticUpdates?: boolean;
}

// @public
export interface WindowsUserConfiguration {
    loginMode?: LoginMode;
}

// (No @packageDocumentation comment for this package)

```
