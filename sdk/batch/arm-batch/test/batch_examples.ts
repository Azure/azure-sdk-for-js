/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import {
  env,
  Recorder,
  RecorderStartOptions,
  delay,
  isPlaybackMode,
} from "@azure-tools/test-recorder";
import { createTestCredential } from "@azure-tools/test-credential";
import { assert } from "chai";
import { Context } from "mocha";
import { BatchManagementClient } from "../src/batchManagementClient";
import { fakeTestPasswordPlaceholder, fakeTestCertData } from "./fakeTestSecrets";
import { StorageManagementClient, StorageAccountCreateParameters } from "@azure/arm-storage";

const replaceableVariables: Record<string, string> = {
  SUBSCRIPTION_ID: "azure_subscription_id"
};

const recorderOptions: RecorderStartOptions = {
  envSetupForPlayback: replaceableVariables,
  removeCentralSanitizers: [
    "AZSDK3493", // .name in the body is not a secret and is listed below in the beforeEach section
    "AZSDK3430", // .id in the body is not a secret and is listed below in the beforeEach section
  ],
  sanitizerOptions: {
    bodySanitizers: [
      {
        regex: true,
        value: `"primary":"fakeKey"`,
        target: `"primary":"[^"]*"`
      },
      {
        regex: true,
        value: `"secondary":"fakeKey"`,
        target: `"secondary":"[^"]*"`
      }
    ],
  }
};

export const testPollingOptions = {
  updateIntervalInMs: isPlaybackMode() ? 0 : undefined,
};

describe("Batch test", () => {
  let recorder: Recorder;
  let subscriptionId: string;
  let client: BatchManagementClient;
  let storage_client: StorageManagementClient;
  let location: string;
  let resourceGroup: string;
  let accountName: string;
  let applicationName: string;
  let storageaccountName: string;
  let certificateName: string;
  let poolName: string;

  beforeEach(async function (this: Context) {
    recorder = new Recorder(this.currentTest);
    await recorder.start(recorderOptions);
    subscriptionId = env.SUBSCRIPTION_ID || '';
    // This is an example of how the environment variables are used
    const credential = createTestCredential();
    client = new BatchManagementClient(credential, subscriptionId, recorder.configureClientOptions({}));
    storage_client = new StorageManagementClient(credential, subscriptionId, recorder.configureClientOptions({}));
    location = "eastus";
    resourceGroup = "myjstest";
    accountName = "myaccountxxx";
    applicationName = "myapplicationxxx";
    storageaccountName = "myjsstorageaccount111";
    certificateName = "sha1-cff2ab63c8c955aaf71989efa641b906558d9fb7";
    poolName = "mypoolxxx";
  });

  afterEach(async function () {
    await recorder.stop();
  });

  async function storageAccounts_beginCreateAndWait() {
    const parameter: StorageAccountCreateParameters = {
      sku: {
        name: "Standard_GRS",
      },
      kind: "StorageV2",
      location: "westeurope",
      encryption: {
        services: {
          file: {
            keyType: "Account",
            enabled: true
          },
          blob: {
            keyType: "Account",
            enabled: true
          },
        },
        keySource: "Microsoft.Storage",
      },
      tags: {
        key1: "value1",
        key2: "value2",
      }
    }
    const res = await storage_client.storageAccounts.beginCreateAndWait(resourceGroup, storageaccountName, parameter, testPollingOptions);
  };

  it("batchAccountOperations create test", async function () {
    await storageAccounts_beginCreateAndWait();
    const res = await client.batchAccountOperations.beginCreateAndWait(resourceGroup, accountName, {
      location: location,
      autoStorage: {
        storageAccountId: "/subscriptions/" + subscriptionId + "/resourceGroups/" + resourceGroup + "/providers/Microsoft.Storage/storageAccounts/" + storageaccountName
      }
    }, testPollingOptions);
    assert.equal(res.name, accountName);
  });

  it("batchAccountOperations get test", async function () {
    const res = await client.batchAccountOperations.get(resourceGroup, accountName);
    assert.equal(res.name, accountName);
  });

  it("batchAccountOperations getkeys test", async function () {
    const res = await client.batchAccountOperations.getKeys(resourceGroup, accountName);
    assert.equal(res.accountName, accountName);
  });

  it("batchAccountOperations regenerateKey test", async function () {
    const res = await client.batchAccountOperations.regenerateKey(resourceGroup, accountName, { keyName: "Primary" });
    assert.equal(res.accountName, accountName);
  });

  it("batchAccountOperations list test", async function () {
    const resArray = new Array();
    for await (let item of client.batchAccountOperations.list()) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 1);
  });

  it("batchAccountOperations update test", async function () {
    const res = await client.batchAccountOperations.update(resourceGroup, accountName, { tags: { key1: "value1" } });
    assert.equal(res.type, "Microsoft.Batch/batchAccounts");
  });

  it("applicationOperations create test", async function () {
    const res = await client.applicationOperations.create(resourceGroup, accountName, applicationName, { parameters: { allowUpdates: false } });
    assert.equal(res.name, applicationName);
  });

  it("applicationOperations get test", async function () {
    const res = await client.applicationOperations.get(resourceGroup, accountName, applicationName);
    assert.equal(res.name, applicationName);
  });

  it("applicationOperations list test", async function () {
    const resArray = new Array();
    for await (let item of client.applicationOperations.list(resourceGroup, accountName)) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 1);
  });

  it("certificateOperations create test", async function () {
    const res = await client.certificateOperations.create(resourceGroup, accountName, certificateName, {
      thumbprint: 'cff2ab63c8c955aaf71989efa641b906558d9fb7',
      thumbprintAlgorithm: 'sha1',
      data: fakeTestCertData,
      format: "Pfx",
      password: fakeTestPasswordPlaceholder
    });
    assert.equal(res.name, certificateName);
  });

  it("certificateOperations get test", async function () {
    const res = await client.certificateOperations.get(resourceGroup, accountName, certificateName);
    assert.equal(res.name, certificateName);
  });

  it("certificateOperations list test", async function () {
    const resArray = new Array();
    for await (let item of client.certificateOperations.listByBatchAccount(resourceGroup, accountName)) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 1);
  });

  it("certificateOperations update test", async function () {
    const res = await client.certificateOperations.update(resourceGroup, accountName, certificateName, {
      data: fakeTestCertData,
      password: fakeTestPasswordPlaceholder
    });
    assert.equal(res.type, "Microsoft.Batch/batchAccounts/certificates");
  });

  it("certificateOperations cancelDeletion test", async function () {
    const res = await client.certificateOperations.cancelDeletion(resourceGroup, accountName, certificateName);
    assert.equal(res.name, certificateName);
  });

  it("location checkNameAvailability test", async function () {
    const res = await client.location.checkNameAvailability(location, { name: accountName, type: "Microsoft.Batch/batchAccounts" });
    assert.equal(res.reason, "AlreadyExists")
  });

  it("location getQuotas test", async function () {
    const res = await client.location.getQuotas(location);
    assert.equal(res.accountQuota, 3)
  });

  it("location listSupportedCloudServiceSkus test", async function () {
    const resArray = new Array();
    for await (let item of client.location.listSupportedCloudServiceSkus(location)) {
      resArray.push(item);
    }
    assert.notEqual(resArray.length, 0);
  });

  it("location listSupportedVirtualMachineSkus test", async function () {
    const resArray = new Array();
    for await (let item of client.location.listSupportedVirtualMachineSkus(location)) {
      resArray.push(item);
    }
    assert.notEqual(resArray.length, 0);
  });

  it("poolOperations create test", async function () {
    const res = await client.poolOperations.create(resourceGroup, accountName, poolName, {
      vmSize: "STANDARD_D4",
      deploymentConfiguration: {
        virtualMachineConfiguration: {
          imageReference: {
            publisher: "MicrosoftWindowsServer",
            offer: "WindowsServer",
            sku: "2016-Datacenter-SmallDisk",
            version: "latest"
          },
          nodeAgentSkuId: "batch.node.windows amd64",
        }
      },
      scaleSettings: {
        fixedScale: {
          targetDedicatedNodes: 3
        }
      }
    })
    assert.equal(res.name, poolName);
  });

  it("poolOperations get test", async function () {
    const res = await client.poolOperations.get(resourceGroup, accountName, poolName);
    console.log(res);
  });

  it("poolOperations listByBatchAccount test", async function () {
    const resArray = new Array();
    for await (let item of client.poolOperations.listByBatchAccount(resourceGroup, accountName)) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 1);
  });

  it("poolOperations update test", async function () {
    const res = await client.poolOperations.update(resourceGroup, accountName, poolName, {
      scaleSettings: {
        autoScale: {
          formula: "$TargetDedicatedNodes=34"
        }
      }
    });
    assert.equal(res.type, "Microsoft.Batch/batchAccounts/pools");
  });

  it("poolOperations disableAutoScale test", async function () {
    const res = await client.poolOperations.disableAutoScale(resourceGroup, accountName, poolName);
    assert.equal(res.name, poolName);
  });

  it("poolOperations stopResize test", async function () {
    const res = await client.poolOperations.stopResize(resourceGroup, accountName, poolName);
    assert.equal(res.name, poolName);
  });

  it("privateEndpointConnectionOperations listByBatchAccount test", async function () {
    const resArray = new Array();
    for await (let item of client.privateEndpointConnectionOperations.listByBatchAccount(resourceGroup, accountName)) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 0);
  });

  it("privateLinkResourceOperations listByBatchAccount test", async function () {
    const resArray = new Array();
    for await (let item of client.privateLinkResourceOperations.listByBatchAccount(resourceGroup, accountName)) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 2);
  });

  it("poolOperations delete test", async function () {
    const res = await client.poolOperations.beginDeleteAndWait(resourceGroup, accountName, poolName, testPollingOptions);
    const resArray = new Array();
    for await (let item of client.poolOperations.listByBatchAccount(resourceGroup, accountName)) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 0);
  });

  it("certificateOperations delete test", async function () {
    const res = await client.certificateOperations.beginDeleteAndWait(resourceGroup, accountName, certificateName, testPollingOptions);
    const resArray = new Array();
    for await (let item of client.certificateOperations.listByBatchAccount(resourceGroup, accountName)) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 0);
  });

  it("applicationOperations delete test", async function () {
    const res = await client.applicationOperations.delete(resourceGroup, accountName, applicationName);
    const resArray = new Array();
    for await (let item of client.applicationOperations.list(resourceGroup, accountName)) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 0);
  });

  it("batchAccountOperations delete test", async function () {
    const res = await client.batchAccountOperations.beginDeleteAndWait(resourceGroup, accountName, testPollingOptions);
    const resArray = new Array();
    for await (let item of client.batchAccountOperations.list()) {
      resArray.push(item);
    }
    assert.equal(resArray.length, 0);
    const res1 = await storage_client.storageAccounts.delete(resourceGroup, storageaccountName);
  });
});
