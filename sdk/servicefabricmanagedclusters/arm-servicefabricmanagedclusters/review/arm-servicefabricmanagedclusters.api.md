## API Report File for "@azure/arm-servicefabricmanagedclusters"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { ClientOptions } from '@azure-rest/core-client';
import { OperationOptions } from '@azure-rest/core-client';
import { OperationState } from '@azure/core-lro';
import { PathUncheckedResponse } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export type Access = string;

// @public
export interface AdditionalNetworkInterfaceConfiguration {
    dscpConfiguration?: SubResource;
    enableAcceleratedNetworking?: boolean;
    ipConfigurations: IpConfiguration[];
    name: string;
}

// @public
export interface AddRemoveIncrementalNamedPartitionScalingMechanism extends ScalingMechanism {
    kind: "AddRemoveIncrementalNamedPartition";
    maxPartitionCount: number;
    minPartitionCount: number;
    scaleIncrement: number;
}

// @public
export interface ApplicationHealthPolicy {
    considerWarningAsError: boolean;
    defaultServiceTypeHealthPolicy?: ServiceTypeHealthPolicy;
    maxPercentUnhealthyDeployedApplications: number;
    serviceTypeHealthPolicyMap?: Record<string, ServiceTypeHealthPolicy>;
}

// @public
export interface ApplicationResource extends ProxyResource {
    identity?: ManagedIdentity;
    location?: string;
    properties?: ApplicationResourceProperties;
    tags?: Record<string, string>;
}

// @public
export interface ApplicationResourceProperties {
    managedIdentities?: ApplicationUserAssignedIdentity[];
    parameters?: Record<string, string>;
    readonly provisioningState?: string;
    upgradePolicy?: ApplicationUpgradePolicy;
    version?: string;
}

// @public
export interface ApplicationsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationsGetOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationsListOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationsOperations {
    createOrUpdate: (resourceGroupName: string, clusterName: string, applicationName: string, parameters: ApplicationResource, options?: ApplicationsCreateOrUpdateOptionalParams) => PollerLike<OperationState<ApplicationResource>, ApplicationResource>;
    delete: (resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsGetOptionalParams) => Promise<ApplicationResource>;
    list: (resourceGroupName: string, clusterName: string, options?: ApplicationsListOptionalParams) => PagedAsyncIterableIterator<ApplicationResource>;
    readUpgrade: (resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsReadUpgradeOptionalParams) => PollerLike<OperationState<void>, void>;
    resumeUpgrade: (resourceGroupName: string, clusterName: string, applicationName: string, parameters: RuntimeResumeApplicationUpgradeParameters, options?: ApplicationsResumeUpgradeOptionalParams) => PollerLike<OperationState<void>, void>;
    startRollback: (resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsStartRollbackOptionalParams) => PollerLike<OperationState<void>, void>;
    update: (resourceGroupName: string, clusterName: string, applicationName: string, parameters: ApplicationUpdateParameters, options?: ApplicationsUpdateOptionalParams) => Promise<ApplicationResource>;
}

// @public
export interface ApplicationsReadUpgradeOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationsResumeUpgradeOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationsStartRollbackOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationsUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationTypeResource extends ProxyResource {
    location?: string;
    properties?: ApplicationTypeResourceProperties;
    tags?: Record<string, string>;
}

// @public
export interface ApplicationTypeResourceProperties {
    readonly provisioningState?: string;
}

// @public
export interface ApplicationTypesCreateOrUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationTypesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationTypesGetOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationTypesListOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationTypesOperations {
    createOrUpdate: (resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: ApplicationTypeResource, options?: ApplicationTypesCreateOrUpdateOptionalParams) => Promise<ApplicationTypeResource>;
    delete: (resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: ApplicationTypesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: ApplicationTypesGetOptionalParams) => Promise<ApplicationTypeResource>;
    list: (resourceGroupName: string, clusterName: string, options?: ApplicationTypesListOptionalParams) => PagedAsyncIterableIterator<ApplicationTypeResource>;
    update: (resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: ApplicationTypeUpdateParameters, options?: ApplicationTypesUpdateOptionalParams) => Promise<ApplicationTypeResource>;
}

// @public
export interface ApplicationTypesUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationTypeUpdateParameters {
    tags?: Record<string, string>;
}

// @public
export interface ApplicationTypeVersionResource extends ProxyResource {
    location?: string;
    properties?: ApplicationTypeVersionResourceProperties;
    tags?: Record<string, string>;
}

// @public
export interface ApplicationTypeVersionResourceProperties {
    appPackageUrl: string;
    readonly provisioningState?: string;
}

// @public
export interface ApplicationTypeVersionsCleanupPolicy {
    maxUnusedVersionsToKeep: number;
}

// @public
export interface ApplicationTypeVersionsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationTypeVersionsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationTypeVersionsGetOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationTypeVersionsListByApplicationTypesOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationTypeVersionsOperations {
    createOrUpdate: (resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: ApplicationTypeVersionResource, options?: ApplicationTypeVersionsCreateOrUpdateOptionalParams) => PollerLike<OperationState<ApplicationTypeVersionResource>, ApplicationTypeVersionResource>;
    delete: (resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: ApplicationTypeVersionsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: ApplicationTypeVersionsGetOptionalParams) => Promise<ApplicationTypeVersionResource>;
    listByApplicationTypes: (resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: ApplicationTypeVersionsListByApplicationTypesOptionalParams) => PagedAsyncIterableIterator<ApplicationTypeVersionResource>;
    update: (resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: ApplicationTypeVersionUpdateParameters, options?: ApplicationTypeVersionsUpdateOptionalParams) => Promise<ApplicationTypeVersionResource>;
}

// @public
export interface ApplicationTypeVersionsUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ApplicationTypeVersionUpdateParameters {
    tags?: Record<string, string>;
}

// @public
export interface ApplicationUpdateParameters {
    tags?: Record<string, string>;
}

// @public
export interface ApplicationUpgradePolicy {
    applicationHealthPolicy?: ApplicationHealthPolicy;
    forceRestart?: boolean;
    instanceCloseDelayDuration?: number;
    recreateApplication?: boolean;
    rollingUpgradeMonitoringPolicy?: RollingUpgradeMonitoringPolicy;
    upgradeMode?: RollingUpgradeMode;
    upgradeReplicaSetCheckTimeout?: number;
}

// @public
export interface ApplicationUserAssignedIdentity {
    name: string;
    principalId: string;
}

// @public
export type AutoGeneratedDomainNameLabelScope = string;

// @public
export interface AvailableOperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface AveragePartitionLoadScalingTrigger extends ScalingTrigger {
    kind: "AveragePartitionLoadTrigger";
    lowerLoadThreshold: number;
    metricName: string;
    scaleInterval: string;
    upperLoadThreshold: number;
}

// @public
export interface AverageServiceLoadScalingTrigger extends ScalingTrigger {
    kind: "AverageServiceLoadTrigger";
    lowerLoadThreshold: number;
    metricName: string;
    scaleInterval: string;
    upperLoadThreshold: number;
    useOnlyPrimaryLoad: boolean;
}

// @public
export interface AzureActiveDirectory {
    clientApplication?: string;
    clusterApplication?: string;
    tenantId?: string;
}

// @public
export interface ClientCertificate {
    commonName?: string;
    isAdmin: boolean;
    issuerThumbprint?: string;
    thumbprint?: string;
}

// @public
export interface ClusterHealthPolicy {
    maxPercentUnhealthyApplications: number;
    maxPercentUnhealthyNodes: number;
}

// @public
export interface ClusterMonitoringPolicy {
    healthCheckRetryTimeout: string;
    healthCheckStableDuration: string;
    healthCheckWaitDuration: string;
    upgradeDomainTimeout: string;
    upgradeTimeout: string;
}

// @public
export type ClusterState = string;

// @public
export type ClusterUpgradeCadence = string;

// @public
export interface ClusterUpgradeDeltaHealthPolicy {
    maxPercentDeltaUnhealthyApplications?: number;
    maxPercentDeltaUnhealthyNodes: number;
    maxPercentUpgradeDomainDeltaUnhealthyNodes?: number;
}

// @public
export type ClusterUpgradeMode = string;

// @public
export interface ClusterUpgradePolicy {
    deltaHealthPolicy?: ClusterUpgradeDeltaHealthPolicy;
    forceRestart?: boolean;
    healthPolicy?: ClusterHealthPolicy;
    monitoringPolicy?: ClusterMonitoringPolicy;
    upgradeReplicaSetCheckTimeout?: string;
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export type CreatedByType = string;

// @public
export type Direction = string;

// @public
export type DiskType = string;

// @public
export interface EndpointRangeDescription {
    endPort: number;
    startPort: number;
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, any>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorModelError {
    code?: string;
    message?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export type EvictionPolicyType = string;

// @public
export type FailureAction = string;

// @public
export type FaultKind = string;

// @public
export interface FaultSimulation {
    details?: FaultSimulationDetails;
    endTime?: Date;
    simulationId?: string;
    startTime?: Date;
    status?: FaultSimulationStatus;
}

// @public
export interface FaultSimulationConstraints {
    expirationTime?: Date;
}

// @public
export interface FaultSimulationContent {
    constraints?: FaultSimulationConstraints;
    faultKind: FaultKind;
    force?: boolean;
}

// @public
export type FaultSimulationContentUnion = ZoneFaultSimulationContent | FaultSimulationContent;

// @public
export interface FaultSimulationContentWrapper {
    parameters: FaultSimulationContentUnion;
}

// @public
export interface FaultSimulationDetails {
    clusterId?: string;
    nodeTypeFaultSimulation?: NodeTypeFaultSimulation[];
    operationId?: string;
    parameters?: FaultSimulationContentUnion;
}

// @public
export interface FaultSimulationIdContent {
    simulationId: string;
}

// @public
export type FaultSimulationStatus = string;

// @public
export interface FrontendConfiguration {
    applicationGatewayBackendAddressPoolId?: string;
    ipAddressType?: IPAddressType;
    loadBalancerBackendAddressPoolId?: string;
    loadBalancerInboundNatPoolId?: string;
}

// @public
export type IPAddressType = string;

// @public
export interface IpConfiguration {
    applicationGatewayBackendAddressPools?: SubResource[];
    loadBalancerBackendAddressPools?: SubResource[];
    loadBalancerInboundNatPools?: SubResource[];
    name: string;
    privateIPAddressVersion?: PrivateIPAddressVersion;
    publicIPAddressConfiguration?: IPConfigurationPublicIPAddressConfiguration;
    subnet?: SubResource;
}

// @public
export interface IPConfigurationPublicIPAddressConfiguration {
    ipTags?: IpTag[];
    name: string;
    publicIPAddressVersion?: PublicIPAddressVersion;
}

// @public
export interface IpTag {
    ipTagType: string;
    tag: string;
}

// @public
export enum KnownAccess {
    Allow = "allow",
    Deny = "deny"
}

// @public
export enum KnownAutoGeneratedDomainNameLabelScope {
    NoReuse = "NoReuse",
    ResourceGroupReuse = "ResourceGroupReuse",
    SubscriptionReuse = "SubscriptionReuse",
    TenantReuse = "TenantReuse"
}

// @public
export enum KnownClusterState {
    BaselineUpgrade = "BaselineUpgrade",
    Deploying = "Deploying",
    Ready = "Ready",
    UpgradeFailed = "UpgradeFailed",
    Upgrading = "Upgrading",
    WaitingForNodes = "WaitingForNodes"
}

// @public
export enum KnownClusterUpgradeCadence {
    Wave0 = "Wave0",
    Wave1 = "Wave1",
    Wave2 = "Wave2"
}

// @public
export enum KnownClusterUpgradeMode {
    Automatic = "Automatic",
    Manual = "Manual"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDirection {
    Inbound = "inbound",
    Outbound = "outbound"
}

// @public
export enum KnownDiskType {
    PremiumLRS = "Premium_LRS",
    PremiumV2LRS = "PremiumV2_LRS",
    PremiumZRS = "Premium_ZRS",
    StandardLRS = "Standard_LRS",
    StandardSSDLRS = "StandardSSD_LRS",
    StandardSSDZRS = "StandardSSD_ZRS"
}

// @public
export enum KnownEvictionPolicyType {
    Deallocate = "Deallocate",
    Delete = "Delete"
}

// @public
export enum KnownFailureAction {
    Manual = "Manual",
    Rollback = "Rollback"
}

// @public
export enum KnownFaultKind {
    Zone = "Zone"
}

// @public
export enum KnownFaultSimulationStatus {
    Active = "Active",
    Done = "Done",
    StartFailed = "StartFailed",
    Starting = "Starting",
    StopFailed = "StopFailed",
    Stopping = "Stopping"
}

// @public
export enum KnownIPAddressType {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownManagedClusterAddOnFeature {
    BackupRestoreService = "BackupRestoreService",
    DnsService = "DnsService",
    ResourceMonitorService = "ResourceMonitorService"
}

// @public
export enum KnownManagedClusterVersionEnvironment {
    Windows = "Windows"
}

// @public
export enum KnownManagedResourceProvisioningState {
    Canceled = "Canceled",
    Created = "Created",
    Creating = "Creating",
    Deleted = "Deleted",
    Deleting = "Deleting",
    Failed = "Failed",
    None = "None",
    Other = "Other",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownMoveCost {
    High = "High",
    Low = "Low",
    Medium = "Medium",
    Zero = "Zero"
}

// @public
export enum KnownNodeTypeSkuScaleType {
    Automatic = "Automatic",
    Manual = "Manual",
    None = "None"
}

// @public
export enum KnownNsgProtocol {
    Ah = "ah",
    Esp = "esp",
    Http = "http",
    Https = "https",
    Icmp = "icmp",
    Tcp = "tcp",
    Udp = "udp"
}

// @public
export enum KnownOsType {
    Windows = "Windows"
}

// @public
export enum KnownPartitionScheme {
    Named = "Named",
    Singleton = "Singleton",
    UniformInt64Range = "UniformInt64Range"
}

// @public
export enum KnownPrivateEndpointNetworkPolicies {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownPrivateIPAddressVersion {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownPrivateLinkServiceNetworkPolicies {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownProbeProtocol {
    Http = "http",
    Https = "https",
    Tcp = "tcp"
}

// @public
export enum KnownProtocol {
    Tcp = "tcp",
    Udp = "udp"
}

// @public
export enum KnownPublicIPAddressVersion {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownRollingUpgradeMode {
    Monitored = "Monitored",
    UnmonitoredAuto = "UnmonitoredAuto"
}

// @public
export enum KnownSecurityEncryptionType {
    DiskWithVMGuestState = "DiskWithVMGuestState",
    VMGuestStateOnly = "VMGuestStateOnly"
}

// @public
export enum KnownSecurityType {
    ConfidentialVM = "ConfidentialVM",
    Standard = "Standard",
    TrustedLaunch = "TrustedLaunch"
}

// @public
export enum KnownServiceCorrelationScheme {
    AlignedAffinity = "AlignedAffinity",
    NonAlignedAffinity = "NonAlignedAffinity"
}

// @public
export enum KnownServiceKind {
    Stateful = "Stateful",
    Stateless = "Stateless"
}

// @public
export enum KnownServiceLoadMetricWeight {
    High = "High",
    Low = "Low",
    Medium = "Medium",
    Zero = "Zero"
}

// @public
export enum KnownServicePackageActivationMode {
    ExclusiveProcess = "ExclusiveProcess",
    SharedProcess = "SharedProcess"
}

// @public
export enum KnownServicePlacementPolicyType {
    InvalidDomain = "InvalidDomain",
    NonPartiallyPlaceService = "NonPartiallyPlaceService",
    PreferredPrimaryDomain = "PreferredPrimaryDomain",
    RequiredDomain = "RequiredDomain",
    RequiredDomainDistribution = "RequiredDomainDistribution"
}

// @public
export enum KnownServiceScalingMechanismKind {
    AddRemoveIncrementalNamedPartition = "AddRemoveIncrementalNamedPartition",
    ScalePartitionInstanceCount = "ScalePartitionInstanceCount"
}

// @public
export enum KnownServiceScalingTriggerKind {
    AveragePartitionLoadTrigger = "AveragePartitionLoadTrigger",
    AverageServiceLoadTrigger = "AverageServiceLoadTrigger"
}

// @public
export enum KnownSfmcOperationStatus {
    Aborted = "Aborted",
    Canceled = "Canceled",
    Created = "Created",
    Failed = "Failed",
    Started = "Started",
    Succeeded = "Succeeded"
}

// @public
export enum KnownSkuName {
    Basic = "Basic",
    Standard = "Standard"
}

// @public
export enum KnownUpdateType {
    ByUpgradeDomain = "ByUpgradeDomain",
    Default = "Default"
}

// @public
export enum KnownVersions {
    V20241101Preview = "2024-11-01-preview",
    // (undocumented)
    V20250301Preview = "2025-03-01-preview"
}

// @public
export enum KnownVmSetupAction {
    EnableContainers = "EnableContainers",
    EnableHyperV = "EnableHyperV"
}

// @public
export enum KnownVmssExtensionSetupOrder {
    BeforeSFRuntime = "BeforeSFRuntime"
}

// @public
export enum KnownZonalUpdateMode {
    Fast = "Fast",
    Standard = "Standard"
}

// @public
export interface LoadBalancingRule {
    backendPort: number;
    frontendPort: number;
    loadDistribution?: string;
    probePort?: number;
    probeProtocol: ProbeProtocol;
    probeRequestPath?: string;
    protocol: Protocol;
}

// @public
export interface LongRunningOperationResult {
    endTime?: Date;
    error?: ErrorModelError;
    name?: string;
    percentComplete?: number;
    startTime?: Date;
    status?: string;
}

// @public
export interface ManagedApplyMaintenanceWindowOperations {
    post: (resourceGroupName: string, clusterName: string, options?: ManagedApplyMaintenanceWindowPostOptionalParams) => Promise<void>;
}

// @public
export interface ManagedApplyMaintenanceWindowPostOptionalParams extends OperationOptions {
}

// @public
export interface ManagedAzResiliencyStatus {
    baseResourceStatus?: ResourceAzStatus[];
    readonly isClusterZoneResilient?: boolean;
}

// @public
export interface ManagedAzResiliencyStatusGetOptionalParams extends OperationOptions {
}

// @public
export interface ManagedAzResiliencyStatusOperations {
    get: (resourceGroupName: string, clusterName: string, options?: ManagedAzResiliencyStatusGetOptionalParams) => Promise<ManagedAzResiliencyStatus>;
}

// @public
export interface ManagedCluster extends TrackedResource {
    readonly etag?: string;
    properties?: ManagedClusterProperties;
    sku: Sku;
}

// @public
export type ManagedClusterAddOnFeature = string;

// @public
export interface ManagedClusterCodeVersionResult {
    id?: string;
    name?: string;
    properties?: ManagedClusterVersionDetails;
    type?: string;
}

// @public
export interface ManagedClusterProperties {
    addonFeatures?: ManagedClusterAddOnFeature[];
    adminPassword?: string;
    adminUserName: string;
    allocatedOutboundPorts?: number;
    allowRdpAccess?: boolean;
    applicationTypeVersionsCleanupPolicy?: ApplicationTypeVersionsCleanupPolicy;
    autoGeneratedDomainNameLabelScope?: AutoGeneratedDomainNameLabelScope;
    auxiliarySubnets?: Subnet[];
    azureActiveDirectory?: AzureActiveDirectory;
    clientConnectionPort?: number;
    clients?: ClientCertificate[];
    readonly clusterCertificateThumbprints?: string[];
    clusterCodeVersion?: string;
    readonly clusterId?: string;
    readonly clusterState?: ClusterState;
    clusterUpgradeCadence?: ClusterUpgradeCadence;
    clusterUpgradeMode?: ClusterUpgradeMode;
    ddosProtectionPlanId?: string;
    dnsName: string;
    enableAutoOSUpgrade?: boolean;
    enableHttpGatewayExclusiveAuthMode?: boolean;
    enableIpv6?: boolean;
    enableServicePublicIP?: boolean;
    fabricSettings?: SettingsSectionDescription[];
    readonly fqdn?: string;
    httpGatewayConnectionPort?: number;
    httpGatewayTokenAuthConnectionPort?: number;
    ipTags?: IpTag[];
    readonly ipv4Address?: string;
    readonly ipv6Address?: string;
    loadBalancingRules?: LoadBalancingRule[];
    networkSecurityRules?: NetworkSecurityRule[];
    readonly provisioningState?: ManagedResourceProvisioningState;
    publicIPPrefixId?: string;
    publicIPv6PrefixId?: string;
    serviceEndpoints?: ServiceEndpoint[];
    subnetId?: string;
    upgradeDescription?: ClusterUpgradePolicy;
    useCustomVnet?: boolean;
    vmImage?: string;
    zonalResiliency?: boolean;
    zonalUpdateMode?: ZonalUpdateMode;
}

// @public
export interface ManagedClustersCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersGetFaultSimulationOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersGetOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListFaultSimulationOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersOperations {
    createOrUpdate: (resourceGroupName: string, clusterName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams) => PollerLike<OperationState<ManagedCluster>, ManagedCluster>;
    delete: (resourceGroupName: string, clusterName: string, options?: ManagedClustersDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, clusterName: string, options?: ManagedClustersGetOptionalParams) => Promise<ManagedCluster>;
    getFaultSimulation: (resourceGroupName: string, clusterName: string, parameters: FaultSimulationIdContent, options?: ManagedClustersGetFaultSimulationOptionalParams) => Promise<FaultSimulation>;
    listByResourceGroup: (resourceGroupName: string, options?: ManagedClustersListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<ManagedCluster>;
    listBySubscription: (options?: ManagedClustersListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<ManagedCluster>;
    listFaultSimulation: (resourceGroupName: string, clusterName: string, options?: ManagedClustersListFaultSimulationOptionalParams) => PagedAsyncIterableIterator<FaultSimulation>;
    startFaultSimulation: (resourceGroupName: string, clusterName: string, parameters: FaultSimulationContentWrapper, options?: ManagedClustersStartFaultSimulationOptionalParams) => PollerLike<OperationState<FaultSimulation>, FaultSimulation>;
    stopFaultSimulation: (resourceGroupName: string, clusterName: string, parameters: FaultSimulationIdContent, options?: ManagedClustersStopFaultSimulationOptionalParams) => PollerLike<OperationState<FaultSimulation>, FaultSimulation>;
    update: (resourceGroupName: string, clusterName: string, parameters: ManagedClusterUpdateParameters, options?: ManagedClustersUpdateOptionalParams) => Promise<ManagedCluster>;
}

// @public
export interface ManagedClustersStartFaultSimulationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersStopFaultSimulationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterUpdateParameters {
    tags?: Record<string, string>;
}

// @public
export interface ManagedClusterVersionDetails {
    clusterCodeVersion?: string;
    osType?: OsType;
    supportExpiryUtc?: Date;
}

// @public
export type ManagedClusterVersionEnvironment = string;

// @public
export interface ManagedClusterVersionGetByEnvironmentOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterVersionGetOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterVersionListByEnvironmentOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterVersionListOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterVersionOperations {
    get: (location: string, clusterVersion: string, options?: ManagedClusterVersionGetOptionalParams) => Promise<ManagedClusterCodeVersionResult>;
    getByEnvironment: (location: string, environment: ManagedClusterVersionEnvironment, clusterVersion: string, options?: ManagedClusterVersionGetByEnvironmentOptionalParams) => Promise<ManagedClusterCodeVersionResult>;
    list: (location: string, options?: ManagedClusterVersionListOptionalParams) => Promise<ManagedClusterCodeVersionResult[]>;
    listByEnvironment: (location: string, environment: ManagedClusterVersionEnvironment, options?: ManagedClusterVersionListByEnvironmentOptionalParams) => Promise<ManagedClusterCodeVersionResult[]>;
}

// @public
export interface ManagedIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ManagedIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentity>;
}

// @public
export type ManagedIdentityType = "None" | "SystemAssigned" | "UserAssigned" | "SystemAssigned, UserAssigned";

// @public
export interface ManagedMaintenanceWindowStatus {
    readonly canApplyUpdates?: boolean;
    readonly isRegionReady?: boolean;
    readonly isWindowActive?: boolean;
    readonly isWindowEnabled?: boolean;
    readonly lastWindowEndTimeUTC?: Date;
    readonly lastWindowStartTimeUTC?: Date;
    readonly lastWindowStatusUpdateAtUTC?: Date;
}

// @public
export interface ManagedMaintenanceWindowStatusGetOptionalParams extends OperationOptions {
}

// @public
export interface ManagedMaintenanceWindowStatusOperations {
    get: (resourceGroupName: string, clusterName: string, options?: ManagedMaintenanceWindowStatusGetOptionalParams) => Promise<ManagedMaintenanceWindowStatus>;
}

// @public
export type ManagedResourceProvisioningState = string;

// @public
export interface ManagedUnsupportedVMSizesGetOptionalParams extends OperationOptions {
}

// @public
export interface ManagedUnsupportedVMSizesListOptionalParams extends OperationOptions {
}

// @public
export interface ManagedUnsupportedVMSizesOperations {
    get: (location: string, vmSize: string, options?: ManagedUnsupportedVMSizesGetOptionalParams) => Promise<ManagedVMSize>;
    list: (location: string, options?: ManagedUnsupportedVMSizesListOptionalParams) => PagedAsyncIterableIterator<ManagedVMSize>;
}

// @public
export interface ManagedVMSize {
    readonly id?: string;
    readonly name?: string;
    readonly properties?: VMSize;
    readonly type?: string;
}

// @public
export type MoveCost = string;

// @public
export interface NamedPartitionScheme extends Partition {
    names: string[];
    partitionScheme: "Named";
}

// @public
export interface NetworkSecurityRule {
    access: Access;
    description?: string;
    destinationAddressPrefix?: string;
    destinationAddressPrefixes?: string[];
    destinationPortRange?: string;
    destinationPortRanges?: string[];
    direction: Direction;
    name: string;
    priority: number;
    protocol: NsgProtocol;
    sourceAddressPrefix?: string;
    sourceAddressPrefixes?: string[];
    sourcePortRange?: string;
    sourcePortRanges?: string[];
}

// @public
export interface NodeType extends ProxyResource {
    properties?: NodeTypeProperties;
    sku?: NodeTypeSku;
    tags?: Record<string, string>;
}

// @public
export interface NodeTypeActionParameters {
    force?: boolean;
    nodes?: string[];
    updateType?: UpdateType;
}

// @public
export interface NodeTypeAvailableSku {
    readonly capacity?: NodeTypeSkuCapacity;
    readonly resourceType?: string;
    readonly sku?: NodeTypeSupportedSku;
}

// @public
export interface NodeTypeFaultSimulation {
    nodeTypeName?: string;
    operationId?: string;
    operationStatus?: SfmcOperationStatus;
    status?: FaultSimulationStatus;
}

// @public
export interface NodeTypeNatConfig {
    backendPort?: number;
    frontendPortRangeEnd?: number;
    frontendPortRangeStart?: number;
}

// @public
export interface NodeTypeProperties {
    additionalDataDisks?: VmssDataDisk[];
    additionalNetworkInterfaceConfigurations?: AdditionalNetworkInterfaceConfiguration[];
    applicationPorts?: EndpointRangeDescription;
    capacities?: Record<string, string>;
    computerNamePrefix?: string;
    dataDiskLetter?: string;
    dataDiskSizeGB?: number;
    dataDiskType?: DiskType;
    dscpConfigurationId?: string;
    enableAcceleratedNetworking?: boolean;
    enableEncryptionAtHost?: boolean;
    enableNodePublicIP?: boolean;
    enableNodePublicIPv6?: boolean;
    enableOverProvisioning?: boolean;
    ephemeralPorts?: EndpointRangeDescription;
    evictionPolicy?: EvictionPolicyType;
    frontendConfigurations?: FrontendConfiguration[];
    hostGroupId?: string;
    isPrimary: boolean;
    isSpotVM?: boolean;
    isStateless?: boolean;
    multiplePlacementGroups?: boolean;
    natConfigurations?: NodeTypeNatConfig[];
    natGatewayId?: string;
    networkSecurityRules?: NetworkSecurityRule[];
    placementProperties?: Record<string, string>;
    readonly provisioningState?: ManagedResourceProvisioningState;
    secureBootEnabled?: boolean;
    securityEncryptionType?: SecurityEncryptionType;
    securityType?: SecurityType;
    serviceArtifactReferenceId?: string;
    spotRestoreTimeout?: string;
    subnetId?: string;
    useDefaultPublicLoadBalancer?: boolean;
    useEphemeralOSDisk?: boolean;
    useTempDataDisk?: boolean;
    vmApplications?: VmApplication[];
    vmExtensions?: VmssExtension[];
    vmImageOffer?: string;
    vmImagePlan?: VmImagePlan;
    vmImagePublisher?: string;
    vmImageResourceId?: string;
    vmImageSku?: string;
    vmImageVersion?: string;
    vmInstanceCount: number;
    vmManagedIdentity?: VmManagedIdentity;
    vmSecrets?: VaultSecretGroup[];
    vmSetupActions?: VmSetupAction[];
    vmSharedGalleryImageId?: string;
    vmSize?: string;
    zoneBalance?: boolean;
    zones?: string[];
}

// @public
export interface NodeTypesCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesDeallocateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesDeleteNodeOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesGetFaultSimulationOptionalParams extends OperationOptions {
}

// @public
export interface NodeTypesGetOptionalParams extends OperationOptions {
}

// @public
export interface NodeTypeSku {
    capacity: number;
    name?: string;
    tier?: string;
}

// @public
export interface NodeTypeSkuCapacity {
    readonly default?: number;
    readonly maximum?: number;
    readonly minimum?: number;
    readonly scaleType?: NodeTypeSkuScaleType;
}

// @public
export type NodeTypeSkuScaleType = string;

// @public
export interface NodeTypeSkusListOptionalParams extends OperationOptions {
}

// @public
export interface NodeTypeSkusOperations {
    list: (resourceGroupName: string, clusterName: string, nodeTypeName: string, options?: NodeTypeSkusListOptionalParams) => PagedAsyncIterableIterator<NodeTypeAvailableSku>;
}

// @public
export interface NodeTypesListByManagedClustersOptionalParams extends OperationOptions {
}

// @public
export interface NodeTypesListFaultSimulationOptionalParams extends OperationOptions {
}

// @public
export interface NodeTypesOperations {
    createOrUpdate: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeType, options?: NodeTypesCreateOrUpdateOptionalParams) => PollerLike<OperationState<NodeType>, NodeType>;
    deallocate: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesDeallocateOptionalParams) => PollerLike<OperationState<void>, void>;
    delete: (resourceGroupName: string, clusterName: string, nodeTypeName: string, options?: NodeTypesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    deleteNode: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesDeleteNodeOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, clusterName: string, nodeTypeName: string, options?: NodeTypesGetOptionalParams) => Promise<NodeType>;
    getFaultSimulation: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: FaultSimulationIdContent, options?: NodeTypesGetFaultSimulationOptionalParams) => Promise<FaultSimulation>;
    listByManagedClusters: (resourceGroupName: string, clusterName: string, options?: NodeTypesListByManagedClustersOptionalParams) => PagedAsyncIterableIterator<NodeType>;
    listFaultSimulation: (resourceGroupName: string, clusterName: string, nodeTypeName: string, options?: NodeTypesListFaultSimulationOptionalParams) => PagedAsyncIterableIterator<FaultSimulation>;
    redeploy: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesRedeployOptionalParams) => PollerLike<OperationState<void>, void>;
    reimage: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesReimageOptionalParams) => PollerLike<OperationState<void>, void>;
    restart: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesRestartOptionalParams) => PollerLike<OperationState<void>, void>;
    start: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesStartOptionalParams) => PollerLike<OperationState<void>, void>;
    startFaultSimulation: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: FaultSimulationContentWrapper, options?: NodeTypesStartFaultSimulationOptionalParams) => PollerLike<OperationState<FaultSimulation>, FaultSimulation>;
    stopFaultSimulation: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: FaultSimulationIdContent, options?: NodeTypesStopFaultSimulationOptionalParams) => PollerLike<OperationState<FaultSimulation>, FaultSimulation>;
    update: (resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeUpdateParameters, options?: NodeTypesUpdateOptionalParams) => PollerLike<OperationState<NodeType>, NodeType>;
}

// @public
export interface NodeTypesRedeployOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesReimageOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesRestartOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesStartFaultSimulationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesStartOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesStopFaultSimulationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypeSupportedSku {
    readonly name?: string;
    readonly tier?: string;
}

// @public
export interface NodeTypeUpdateParameters {
    sku?: NodeTypeSku;
    tags?: Record<string, string>;
}

// @public
export type NsgProtocol = string;

// @public
export interface OperationResult {
    display?: AvailableOperationDisplay;
    isDataAction?: boolean;
    name?: string;
    nextLink?: string;
    origin?: string;
}

// @public
export interface OperationResultsGetOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface OperationResultsOperations {
    get: (location: string, operationId: string, options?: OperationResultsGetOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export interface OperationsListOptionalParams extends OperationOptions {
}

// @public
export interface OperationsOperations {
    list: (options?: OperationsListOptionalParams) => PagedAsyncIterableIterator<OperationResult>;
}

// @public
export interface OperationStatusGetOptionalParams extends OperationOptions {
}

// @public
export interface OperationStatusOperations {
    get: (location: string, operationId: string, options?: OperationStatusGetOptionalParams) => Promise<LongRunningOperationResult>;
}

// @public
export type OsType = string;

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface Partition {
    // (undocumented)
    partitionScheme: PartitionScheme;
}

// @public
export interface PartitionInstanceCountScaleMechanism extends ScalingMechanism {
    kind: "ScalePartitionInstanceCount";
    maxInstanceCount: number;
    minInstanceCount: number;
    scaleIncrement: number;
}

// @public
export type PartitionScheme = string;

// @public
export type PartitionUnion = UniformInt64RangePartitionScheme | SingletonPartitionScheme | NamedPartitionScheme | Partition;

// @public
export type PrivateEndpointNetworkPolicies = string;

// @public
export type PrivateIPAddressVersion = string;

// @public
export type PrivateLinkServiceNetworkPolicies = string;

// @public
export type ProbeProtocol = string;

// @public
export type Protocol = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export type PublicIPAddressVersion = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceAzStatus {
    readonly details?: string;
    readonly isZoneResilient?: boolean;
    readonly resourceName?: string;
    readonly resourceType?: string;
}

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: ServiceFabricClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export type RollingUpgradeMode = string;

// @public
export interface RollingUpgradeMonitoringPolicy {
    failureAction: FailureAction;
    healthCheckRetryTimeout: string;
    healthCheckStableDuration: string;
    healthCheckWaitDuration: string;
    upgradeDomainTimeout: string;
    upgradeTimeout: string;
}

// @public
export interface RuntimeResumeApplicationUpgradeParameters {
    upgradeDomainName?: string;
}

// @public
export interface ScalingMechanism {
    // (undocumented)
    kind: ServiceScalingMechanismKind;
}

// @public
export type ScalingMechanismUnion = AddRemoveIncrementalNamedPartitionScalingMechanism | PartitionInstanceCountScaleMechanism | ScalingMechanism;

// @public
export interface ScalingPolicy {
    scalingMechanism: ScalingMechanismUnion;
    scalingTrigger: ScalingTriggerUnion;
}

// @public
export interface ScalingTrigger {
    // (undocumented)
    kind: ServiceScalingTriggerKind;
}

// @public
export type ScalingTriggerUnion = AveragePartitionLoadScalingTrigger | AverageServiceLoadScalingTrigger | ScalingTrigger;

// @public
export type SecurityEncryptionType = string;

// @public
export type SecurityType = string;

// @public
export interface ServiceCorrelation {
    scheme: ServiceCorrelationScheme;
    serviceName: string;
}

// @public
export type ServiceCorrelationScheme = string;

// @public
export interface ServiceEndpoint {
    locations?: string[];
    service: string;
}

// @public (undocumented)
export class ServiceFabricClient {
    constructor(credential: TokenCredential, subscriptionId: string, options?: ServiceFabricClientOptionalParams);
    readonly applications: ApplicationsOperations;
    readonly applicationTypes: ApplicationTypesOperations;
    readonly applicationTypeVersions: ApplicationTypeVersionsOperations;
    readonly managedApplyMaintenanceWindow: ManagedApplyMaintenanceWindowOperations;
    readonly managedAzResiliencyStatus: ManagedAzResiliencyStatusOperations;
    readonly managedClusters: ManagedClustersOperations;
    readonly managedClusterVersion: ManagedClusterVersionOperations;
    readonly managedMaintenanceWindowStatus: ManagedMaintenanceWindowStatusOperations;
    readonly managedUnsupportedVMSizes: ManagedUnsupportedVMSizesOperations;
    readonly nodeTypes: NodeTypesOperations;
    readonly nodeTypeSkus: NodeTypeSkusOperations;
    readonly operationResults: OperationResultsOperations;
    readonly operations: OperationsOperations;
    readonly operationStatus: OperationStatusOperations;
    readonly pipeline: Pipeline;
    readonly services: ServicesOperations;
}

// @public
export interface ServiceFabricClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export type ServiceKind = string;

// @public
export interface ServiceLoadMetric {
    defaultLoad?: number;
    name: string;
    primaryDefaultLoad?: number;
    secondaryDefaultLoad?: number;
    weight?: ServiceLoadMetricWeight;
}

// @public
export type ServiceLoadMetricWeight = string;

// @public
export type ServicePackageActivationMode = string;

// @public
export interface ServicePlacementInvalidDomainPolicy extends ServicePlacementPolicy {
    domainName: string;
    type: "InvalidDomain";
}

// @public
export interface ServicePlacementNonPartiallyPlaceServicePolicy extends ServicePlacementPolicy {
    // (undocumented)
    type: "NonPartiallyPlaceService";
}

// @public
export interface ServicePlacementPolicy {
    // (undocumented)
    type: ServicePlacementPolicyType;
}

// @public
export type ServicePlacementPolicyType = string;

// @public
export type ServicePlacementPolicyUnion = ServicePlacementInvalidDomainPolicy | ServicePlacementRequiredDomainPolicy | ServicePlacementPreferPrimaryDomainPolicy | ServicePlacementRequireDomainDistributionPolicy | ServicePlacementNonPartiallyPlaceServicePolicy | ServicePlacementPolicy;

// @public
export interface ServicePlacementPreferPrimaryDomainPolicy extends ServicePlacementPolicy {
    domainName: string;
    type: "PreferredPrimaryDomain";
}

// @public
export interface ServicePlacementRequiredDomainPolicy extends ServicePlacementPolicy {
    domainName: string;
    type: "RequiredDomain";
}

// @public
export interface ServicePlacementRequireDomainDistributionPolicy extends ServicePlacementPolicy {
    domainName: string;
    type: "RequiredDomainDistribution";
}

// @public
export interface ServiceResource extends ProxyResource {
    location?: string;
    properties?: ServiceResourcePropertiesUnion;
    tags?: Record<string, string>;
}

// @public
export interface ServiceResourceProperties extends ServiceResourcePropertiesBase {
    partitionDescription: PartitionUnion;
    readonly provisioningState?: string;
    serviceDnsName?: string;
    serviceKind: ServiceKind;
    servicePackageActivationMode?: ServicePackageActivationMode;
    serviceTypeName: string;
}

// @public
export interface ServiceResourcePropertiesBase {
    correlationScheme?: ServiceCorrelation[];
    defaultMoveCost?: MoveCost;
    placementConstraints?: string;
    scalingPolicies?: ScalingPolicy[];
    serviceLoadMetrics?: ServiceLoadMetric[];
    servicePlacementPolicies?: ServicePlacementPolicyUnion[];
}

// @public
export type ServiceResourcePropertiesUnion = StatefulServiceProperties | StatelessServiceProperties | ServiceResourceProperties;

// @public
export type ServiceScalingMechanismKind = string;

// @public
export type ServiceScalingTriggerKind = string;

// @public
export interface ServicesCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ServicesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ServicesGetOptionalParams extends OperationOptions {
}

// @public
export interface ServicesListByApplicationsOptionalParams extends OperationOptions {
}

// @public
export interface ServicesOperations {
    createOrUpdate: (resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: ServiceResource, options?: ServicesCreateOrUpdateOptionalParams) => PollerLike<OperationState<ServiceResource>, ServiceResource>;
    delete: (resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: ServicesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: ServicesGetOptionalParams) => Promise<ServiceResource>;
    listByApplications: (resourceGroupName: string, clusterName: string, applicationName: string, options?: ServicesListByApplicationsOptionalParams) => PagedAsyncIterableIterator<ServiceResource>;
    update: (resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: ServiceUpdateParameters, options?: ServicesUpdateOptionalParams) => Promise<ServiceResource>;
}

// @public
export interface ServicesUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ServiceTypeHealthPolicy {
    maxPercentUnhealthyPartitionsPerService: number;
    maxPercentUnhealthyReplicasPerPartition: number;
    maxPercentUnhealthyServices: number;
}

// @public
export interface ServiceUpdateParameters {
    tags?: Record<string, string>;
}

// @public
export interface SettingsParameterDescription {
    name: string;
    value: string;
}

// @public
export interface SettingsSectionDescription {
    name: string;
    parameters: SettingsParameterDescription[];
}

// @public
export type SfmcOperationStatus = string;

// @public
export interface SingletonPartitionScheme extends Partition {
    partitionScheme: "Singleton";
}

// @public
export interface Sku {
    name: SkuName;
}

// @public
export type SkuName = string;

// @public
export interface StatefulServiceProperties extends ServiceResourceProperties {
    hasPersistedState?: boolean;
    minReplicaSetSize?: number;
    quorumLossWaitDuration?: string;
    replicaRestartWaitDuration?: string;
    serviceKind: "Stateful";
    servicePlacementTimeLimit?: string;
    standByReplicaKeepDuration?: string;
    targetReplicaSetSize?: number;
}

// @public
export interface StatelessServiceProperties extends ServiceResourceProperties {
    instanceCount: number;
    minInstanceCount?: number;
    minInstancePercentage?: number;
    serviceKind: "Stateless";
}

// @public
export interface Subnet {
    enableIpv6?: boolean;
    name: string;
    networkSecurityGroupId?: string;
    privateEndpointNetworkPolicies?: PrivateEndpointNetworkPolicies;
    privateLinkServiceNetworkPolicies?: PrivateLinkServiceNetworkPolicies;
}

// @public
export interface SubResource {
    id?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export interface UniformInt64RangePartitionScheme extends Partition {
    count: number;
    highKey: number;
    lowKey: number;
    partitionScheme: "UniformInt64Range";
}

// @public
export type UpdateType = string;

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface VaultCertificate {
    certificateStore: string;
    certificateUrl: string;
}

// @public
export interface VaultSecretGroup {
    sourceVault: SubResource;
    vaultCertificates: VaultCertificate[];
}

// @public
export interface VmApplication {
    configurationReference?: string;
    enableAutomaticUpgrade?: boolean;
    order?: number;
    packageReferenceId: string;
    treatFailureAsDeploymentFailure?: boolean;
    vmGalleryTags?: string;
}

// @public
export interface VmImagePlan {
    name?: string;
    product?: string;
    promotionCode?: string;
    publisher?: string;
}

// @public
export interface VmManagedIdentity {
    userAssignedIdentities?: string[];
}

// @public
export type VmSetupAction = string;

// @public
export interface VMSize {
    readonly size?: string;
}

// @public
export interface VmssDataDisk {
    diskLetter: string;
    diskSizeGB: number;
    diskType: DiskType;
    lun: number;
}

// @public
export interface VmssExtension {
    name: string;
    properties: VmssExtensionProperties;
}

// @public
export interface VmssExtensionProperties {
    autoUpgradeMinorVersion?: boolean;
    enableAutomaticUpgrade?: boolean;
    forceUpdateTag?: string;
    protectedSettings?: Record<string, any>;
    provisionAfterExtensions?: string[];
    readonly provisioningState?: string;
    publisher: string;
    settings?: Record<string, any>;
    setupOrder?: VmssExtensionSetupOrder[];
    type: string;
    typeHandlerVersion: string;
}

// @public
export type VmssExtensionSetupOrder = string;

// @public
export type ZonalUpdateMode = string;

// @public
export interface ZoneFaultSimulationContent extends FaultSimulationContent {
    faultKind: "Zone";
    zones?: string[];
}

// (No @packageDocumentation comment for this package)

```
