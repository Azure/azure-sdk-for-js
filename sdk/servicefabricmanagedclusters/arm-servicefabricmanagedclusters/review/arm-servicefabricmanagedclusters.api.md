## API Report File for "@azure/arm-servicefabricmanagedclusters"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

// @public
export type Access = string;

// @public
export interface AdditionalNetworkInterfaceConfiguration {
    dscpConfiguration?: SubResource;
    enableAcceleratedNetworking?: boolean;
    ipConfigurations: IpConfiguration[];
    name: string;
}

// @public
export interface AddRemoveIncrementalNamedPartitionScalingMechanism extends ScalingMechanism {
    kind: "AddRemoveIncrementalNamedPartition";
    maxPartitionCount: number;
    minPartitionCount: number;
    scaleIncrement: number;
}

// @public
export interface ApplicationHealthPolicy {
    considerWarningAsError: boolean;
    defaultServiceTypeHealthPolicy?: ServiceTypeHealthPolicy;
    maxPercentUnhealthyDeployedApplications: number;
    serviceTypeHealthPolicyMap?: {
        [propertyName: string]: ServiceTypeHealthPolicy;
    };
}

// @public
export interface ApplicationResource extends ProxyResource {
    identity?: ManagedIdentity;
    managedIdentities?: ApplicationUserAssignedIdentity[];
    parameters?: {
        [propertyName: string]: string;
    };
    readonly provisioningState?: string;
    upgradePolicy?: ApplicationUpgradePolicy;
    version?: string;
}

// @public
export interface ApplicationResourceList {
    readonly nextLink?: string;
    // (undocumented)
    value?: ApplicationResource[];
}

// @public
export interface Applications {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, applicationName: string, parameters: ApplicationResource, options?: ApplicationsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ApplicationsCreateOrUpdateResponse>, ApplicationsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, applicationName: string, parameters: ApplicationResource, options?: ApplicationsCreateOrUpdateOptionalParams): Promise<ApplicationsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsDeleteOptionalParams): Promise<void>;
    beginReadUpgrade(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsReadUpgradeOptionalParams): Promise<SimplePollerLike<OperationState<ApplicationsReadUpgradeResponse>, ApplicationsReadUpgradeResponse>>;
    beginReadUpgradeAndWait(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsReadUpgradeOptionalParams): Promise<ApplicationsReadUpgradeResponse>;
    beginResumeUpgrade(resourceGroupName: string, clusterName: string, applicationName: string, parameters: RuntimeResumeApplicationUpgradeParameters, options?: ApplicationsResumeUpgradeOptionalParams): Promise<SimplePollerLike<OperationState<ApplicationsResumeUpgradeResponse>, ApplicationsResumeUpgradeResponse>>;
    beginResumeUpgradeAndWait(resourceGroupName: string, clusterName: string, applicationName: string, parameters: RuntimeResumeApplicationUpgradeParameters, options?: ApplicationsResumeUpgradeOptionalParams): Promise<ApplicationsResumeUpgradeResponse>;
    beginStartRollback(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsStartRollbackOptionalParams): Promise<SimplePollerLike<OperationState<ApplicationsStartRollbackResponse>, ApplicationsStartRollbackResponse>>;
    beginStartRollbackAndWait(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsStartRollbackOptionalParams): Promise<ApplicationsStartRollbackResponse>;
    get(resourceGroupName: string, clusterName: string, applicationName: string, options?: ApplicationsGetOptionalParams): Promise<ApplicationsGetResponse>;
    list(resourceGroupName: string, clusterName: string, options?: ApplicationsListOptionalParams): PagedAsyncIterableIterator<ApplicationResource>;
    update(resourceGroupName: string, clusterName: string, applicationName: string, parameters: ApplicationUpdateParameters, options?: ApplicationsUpdateOptionalParams): Promise<ApplicationsUpdateResponse>;
}

// @public
export interface ApplicationsCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ApplicationsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ApplicationsCreateOrUpdateResponse = ApplicationResource;

// @public
export interface ApplicationsDeleteHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ApplicationsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationsGetResponse = ApplicationResource;

// @public
export interface ApplicationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationsListNextResponse = ApplicationResourceList;

// @public
export interface ApplicationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationsListResponse = ApplicationResourceList;

// @public
export interface ApplicationsReadUpgradeHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ApplicationsReadUpgradeOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ApplicationsReadUpgradeResponse = ApplicationsReadUpgradeHeaders;

// @public
export interface ApplicationsResumeUpgradeHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ApplicationsResumeUpgradeOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ApplicationsResumeUpgradeResponse = ApplicationsResumeUpgradeHeaders;

// @public
export interface ApplicationsStartRollbackHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ApplicationsStartRollbackOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ApplicationsStartRollbackResponse = ApplicationsStartRollbackHeaders;

// @public
export interface ApplicationsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationsUpdateResponse = ApplicationResource;

// @public
export interface ApplicationTypeResource extends ProxyResource {
    readonly provisioningState?: string;
}

// @public
export interface ApplicationTypeResourceList {
    readonly nextLink?: string;
    // (undocumented)
    value?: ApplicationTypeResource[];
}

// @public
export interface ApplicationTypes {
    beginDelete(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: ApplicationTypesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: ApplicationTypesDeleteOptionalParams): Promise<void>;
    createOrUpdate(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: ApplicationTypeResource, options?: ApplicationTypesCreateOrUpdateOptionalParams): Promise<ApplicationTypesCreateOrUpdateResponse>;
    get(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: ApplicationTypesGetOptionalParams): Promise<ApplicationTypesGetResponse>;
    list(resourceGroupName: string, clusterName: string, options?: ApplicationTypesListOptionalParams): PagedAsyncIterableIterator<ApplicationTypeResource>;
    update(resourceGroupName: string, clusterName: string, applicationTypeName: string, parameters: ApplicationTypeUpdateParameters, options?: ApplicationTypesUpdateOptionalParams): Promise<ApplicationTypesUpdateResponse>;
}

// @public
export interface ApplicationTypesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypesCreateOrUpdateResponse = ApplicationTypeResource;

// @public
export interface ApplicationTypesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationTypesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypesGetResponse = ApplicationTypeResource;

// @public
export interface ApplicationTypesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypesListNextResponse = ApplicationTypeResourceList;

// @public
export interface ApplicationTypesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypesListResponse = ApplicationTypeResourceList;

// @public
export interface ApplicationTypesUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypesUpdateResponse = ApplicationTypeResource;

// @public
export interface ApplicationTypeUpdateParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface ApplicationTypeVersionResource extends ProxyResource {
    appPackageUrl?: string;
    readonly provisioningState?: string;
}

// @public
export interface ApplicationTypeVersionResourceList {
    readonly nextLink?: string;
    // (undocumented)
    value?: ApplicationTypeVersionResource[];
}

// @public
export interface ApplicationTypeVersions {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: ApplicationTypeVersionResource, options?: ApplicationTypeVersionsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ApplicationTypeVersionsCreateOrUpdateResponse>, ApplicationTypeVersionsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: ApplicationTypeVersionResource, options?: ApplicationTypeVersionsCreateOrUpdateOptionalParams): Promise<ApplicationTypeVersionsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: ApplicationTypeVersionsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: ApplicationTypeVersionsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, options?: ApplicationTypeVersionsGetOptionalParams): Promise<ApplicationTypeVersionsGetResponse>;
    listByApplicationTypes(resourceGroupName: string, clusterName: string, applicationTypeName: string, options?: ApplicationTypeVersionsListByApplicationTypesOptionalParams): PagedAsyncIterableIterator<ApplicationTypeVersionResource>;
    update(resourceGroupName: string, clusterName: string, applicationTypeName: string, version: string, parameters: ApplicationTypeVersionUpdateParameters, options?: ApplicationTypeVersionsUpdateOptionalParams): Promise<ApplicationTypeVersionsUpdateResponse>;
}

// @public
export interface ApplicationTypeVersionsCleanupPolicy {
    maxUnusedVersionsToKeep: number;
}

// @public
export interface ApplicationTypeVersionsCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ApplicationTypeVersionsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ApplicationTypeVersionsCreateOrUpdateResponse = ApplicationTypeVersionResource;

// @public
export interface ApplicationTypeVersionsDeleteHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ApplicationTypeVersionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ApplicationTypeVersionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypeVersionsGetResponse = ApplicationTypeVersionResource;

// @public
export interface ApplicationTypeVersionsListByApplicationTypesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypeVersionsListByApplicationTypesNextResponse = ApplicationTypeVersionResourceList;

// @public
export interface ApplicationTypeVersionsListByApplicationTypesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypeVersionsListByApplicationTypesResponse = ApplicationTypeVersionResourceList;

// @public
export interface ApplicationTypeVersionsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ApplicationTypeVersionsUpdateResponse = ApplicationTypeVersionResource;

// @public
export interface ApplicationTypeVersionUpdateParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface ApplicationUpdateParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface ApplicationUpgradePolicy {
    applicationHealthPolicy?: ApplicationHealthPolicy;
    forceRestart?: boolean;
    instanceCloseDelayDuration?: number;
    recreateApplication?: boolean;
    rollingUpgradeMonitoringPolicy?: RollingUpgradeMonitoringPolicy;
    upgradeMode?: RollingUpgradeMode;
    upgradeReplicaSetCheckTimeout?: number;
}

// @public (undocumented)
export interface ApplicationUserAssignedIdentity {
    name: string;
    principalId: string;
}

// @public
export type AutoGeneratedDomainNameLabelScope = string;

// @public
export interface AvailableOperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface AveragePartitionLoadScalingTrigger extends ScalingTrigger {
    kind: "AveragePartitionLoadTrigger";
    lowerLoadThreshold: number;
    metricName: string;
    scaleInterval: string;
    upperLoadThreshold: number;
}

// @public
export interface AverageServiceLoadScalingTrigger extends ScalingTrigger {
    kind: "AverageServiceLoadTrigger";
    lowerLoadThreshold: number;
    metricName: string;
    scaleInterval: string;
    upperLoadThreshold: number;
    useOnlyPrimaryLoad: boolean;
}

// @public
export interface AzureActiveDirectory {
    clientApplication?: string;
    clusterApplication?: string;
    tenantId?: string;
}

// @public
export interface ClientCertificate {
    commonName?: string;
    isAdmin: boolean;
    issuerThumbprint?: string;
    thumbprint?: string;
}

// @public
export interface ClusterHealthPolicy {
    maxPercentUnhealthyApplications: number;
    maxPercentUnhealthyNodes: number;
}

// @public
export interface ClusterMonitoringPolicy {
    healthCheckRetryTimeout: string;
    healthCheckStableDuration: string;
    healthCheckWaitDuration: string;
    upgradeDomainTimeout: string;
    upgradeTimeout: string;
}

// @public
export type ClusterState = string;

// @public
export type ClusterUpgradeCadence = string;

// @public
export interface ClusterUpgradeDeltaHealthPolicy {
    maxPercentDeltaUnhealthyApplications?: number;
    maxPercentDeltaUnhealthyNodes: number;
    maxPercentUpgradeDomainDeltaUnhealthyNodes?: number;
}

// @public
export type ClusterUpgradeMode = string;

// @public
export interface ClusterUpgradePolicy {
    deltaHealthPolicy?: ClusterUpgradeDeltaHealthPolicy;
    forceRestart?: boolean;
    healthPolicy?: ClusterHealthPolicy;
    monitoringPolicy?: ClusterMonitoringPolicy;
    upgradeReplicaSetCheckTimeout?: string;
}

// @public
export type Direction = string;

// @public
export type DiskType = string;

// @public
export interface EndpointRangeDescription {
    endPort: number;
    startPort: number;
}

// @public
export interface ErrorModel {
    error?: ErrorModelError;
}

// @public
export interface ErrorModelError {
    code?: string;
    message?: string;
}

// @public
export type EvictionPolicyType = string;

// @public
export type FailureAction = string;

// @public
export interface FrontendConfiguration {
    applicationGatewayBackendAddressPoolId?: string;
    ipAddressType?: IPAddressType;
    loadBalancerBackendAddressPoolId?: string;
    loadBalancerInboundNatPoolId?: string;
}

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export type IPAddressType = string;

// @public
export interface IpConfiguration {
    applicationGatewayBackendAddressPools?: SubResource[];
    loadBalancerBackendAddressPools?: SubResource[];
    loadBalancerInboundNatPools?: SubResource[];
    name: string;
    privateIPAddressVersion?: PrivateIPAddressVersion;
    publicIPAddressConfiguration?: IpConfigurationPublicIPAddressConfiguration;
    subnet?: SubResource;
}

// @public
export interface IpConfigurationPublicIPAddressConfiguration {
    ipTags?: IpTag[];
    name: string;
    publicIPAddressVersion?: PublicIPAddressVersion;
}

// @public
export interface IpTag {
    ipTagType: string;
    tag: string;
}

// @public
export enum KnownAccess {
    Allow = "allow",
    Deny = "deny"
}

// @public
export enum KnownAutoGeneratedDomainNameLabelScope {
    NoReuse = "NoReuse",
    ResourceGroupReuse = "ResourceGroupReuse",
    SubscriptionReuse = "SubscriptionReuse",
    TenantReuse = "TenantReuse"
}

// @public
export enum KnownClusterState {
    BaselineUpgrade = "BaselineUpgrade",
    Deploying = "Deploying",
    Ready = "Ready",
    UpgradeFailed = "UpgradeFailed",
    Upgrading = "Upgrading",
    WaitingForNodes = "WaitingForNodes"
}

// @public
export enum KnownClusterUpgradeCadence {
    Wave0 = "Wave0",
    Wave1 = "Wave1",
    Wave2 = "Wave2"
}

// @public
export enum KnownClusterUpgradeMode {
    Automatic = "Automatic",
    Manual = "Manual"
}

// @public
export enum KnownDirection {
    Inbound = "inbound",
    Outbound = "outbound"
}

// @public
export enum KnownDiskType {
    PremiumLRS = "Premium_LRS",
    StandardLRS = "Standard_LRS",
    StandardSSDLRS = "StandardSSD_LRS"
}

// @public
export enum KnownEvictionPolicyType {
    Deallocate = "Deallocate",
    Delete = "Delete"
}

// @public
export enum KnownFailureAction {
    Manual = "Manual",
    Rollback = "Rollback"
}

// @public
export enum KnownIPAddressType {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownManagedClusterAddOnFeature {
    BackupRestoreService = "BackupRestoreService",
    DnsService = "DnsService",
    ResourceMonitorService = "ResourceMonitorService"
}

// @public
export enum KnownManagedClusterVersionEnvironment {
    Windows = "Windows"
}

// @public
export enum KnownManagedResourceProvisioningState {
    Canceled = "Canceled",
    Created = "Created",
    Creating = "Creating",
    Deleted = "Deleted",
    Deleting = "Deleting",
    Failed = "Failed",
    None = "None",
    Other = "Other",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownMoveCost {
    High = "High",
    Low = "Low",
    Medium = "Medium",
    Zero = "Zero"
}

// @public
export enum KnownNodeTypeSkuScaleType {
    Automatic = "Automatic",
    Manual = "Manual",
    None = "None"
}

// @public
export enum KnownNsgProtocol {
    Ah = "ah",
    Esp = "esp",
    Http = "http",
    Https = "https",
    Icmp = "icmp",
    Tcp = "tcp",
    Udp = "udp"
}

// @public
export enum KnownOsType {
    Windows = "Windows"
}

// @public
export enum KnownPartitionScheme {
    Named = "Named",
    Singleton = "Singleton",
    UniformInt64Range = "UniformInt64Range"
}

// @public
export enum KnownPrivateEndpointNetworkPolicies {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownPrivateIPAddressVersion {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownPrivateLinkServiceNetworkPolicies {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownProbeProtocol {
    Http = "http",
    Https = "https",
    Tcp = "tcp"
}

// @public
export enum KnownProtocol {
    Tcp = "tcp",
    Udp = "udp"
}

// @public
export enum KnownPublicIPAddressVersion {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownRollingUpgradeMode {
    Monitored = "Monitored",
    UnmonitoredAuto = "UnmonitoredAuto"
}

// @public
export enum KnownSecurityType {
    Standard = "Standard",
    TrustedLaunch = "TrustedLaunch"
}

// @public
export enum KnownServiceCorrelationScheme {
    AlignedAffinity = "AlignedAffinity",
    NonAlignedAffinity = "NonAlignedAffinity"
}

// @public
export enum KnownServiceKind {
    Stateful = "Stateful",
    Stateless = "Stateless"
}

// @public
export enum KnownServiceLoadMetricWeight {
    High = "High",
    Low = "Low",
    Medium = "Medium",
    Zero = "Zero"
}

// @public
export enum KnownServicePackageActivationMode {
    ExclusiveProcess = "ExclusiveProcess",
    SharedProcess = "SharedProcess"
}

// @public
export enum KnownServicePlacementPolicyType {
    InvalidDomain = "InvalidDomain",
    NonPartiallyPlaceService = "NonPartiallyPlaceService",
    PreferredPrimaryDomain = "PreferredPrimaryDomain",
    RequiredDomain = "RequiredDomain",
    RequiredDomainDistribution = "RequiredDomainDistribution"
}

// @public
export enum KnownServiceScalingMechanismKind {
    AddRemoveIncrementalNamedPartition = "AddRemoveIncrementalNamedPartition",
    ScalePartitionInstanceCount = "ScalePartitionInstanceCount"
}

// @public
export enum KnownServiceScalingTriggerKind {
    AveragePartitionLoadTrigger = "AveragePartitionLoadTrigger",
    AverageServiceLoadTrigger = "AverageServiceLoadTrigger"
}

// @public
export enum KnownSkuName {
    Basic = "Basic",
    Standard = "Standard"
}

// @public
export enum KnownUpdateType {
    ByUpgradeDomain = "ByUpgradeDomain",
    Default = "Default"
}

// @public
export enum KnownUpgradeMode {
    Monitored = "Monitored",
    UnmonitoredAuto = "UnmonitoredAuto",
    UnmonitoredManual = "UnmonitoredManual"
}

// @public
export enum KnownVmSetupAction {
    EnableContainers = "EnableContainers",
    EnableHyperV = "EnableHyperV"
}

// @public
export enum KnownVmssExtensionSetupOrder {
    BeforeSFRuntime = "BeforeSFRuntime"
}

// @public
export enum KnownZonalUpdateMode {
    Fast = "Fast",
    Standard = "Standard"
}

// @public
export interface LoadBalancingRule {
    backendPort: number;
    frontendPort: number;
    loadDistribution?: string;
    probePort?: number;
    probeProtocol: ProbeProtocol;
    probeRequestPath?: string;
    protocol: Protocol;
}

// @public
export interface LongRunningOperationResult {
    endTime?: Date;
    error?: ErrorModelError;
    name?: string;
    percentComplete?: number;
    startTime?: Date;
    status?: string;
}

// @public
export interface ManagedApplyMaintenanceWindow {
    post(resourceGroupName: string, clusterName: string, options?: ManagedApplyMaintenanceWindowPostOptionalParams): Promise<void>;
}

// @public
export interface ManagedApplyMaintenanceWindowPostOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagedAzResiliencyStatus {
    baseResourceStatus?: ResourceAzStatus[];
    readonly isClusterZoneResilient?: boolean;
}

// @public
export interface ManagedAzResiliencyStatusGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedAzResiliencyStatusGetResponse = ManagedAzResiliencyStatus;

// @public
export interface ManagedAzResiliencyStatusOperations {
    get(resourceGroupName: string, clusterName: string, options?: ManagedAzResiliencyStatusGetOptionalParams): Promise<ManagedAzResiliencyStatusGetResponse>;
}

// @public
export interface ManagedCluster extends Resource {
    addonFeatures?: ManagedClusterAddOnFeature[];
    adminPassword?: string;
    adminUserName?: string;
    allowRdpAccess?: boolean;
    applicationTypeVersionsCleanupPolicy?: ApplicationTypeVersionsCleanupPolicy;
    autoGeneratedDomainNameLabelScope?: AutoGeneratedDomainNameLabelScope;
    auxiliarySubnets?: Subnet[];
    azureActiveDirectory?: AzureActiveDirectory;
    clientConnectionPort?: number;
    clients?: ClientCertificate[];
    readonly clusterCertificateThumbprints?: string[];
    clusterCodeVersion?: string;
    readonly clusterId?: string;
    readonly clusterState?: ClusterState;
    clusterUpgradeCadence?: ClusterUpgradeCadence;
    clusterUpgradeMode?: ClusterUpgradeMode;
    customFqdn?: string;
    ddosProtectionPlanId?: string;
    dnsName?: string;
    enableAutoOSUpgrade?: boolean;
    enableHttpGatewayExclusiveAuthMode?: boolean;
    enableIpv6?: boolean;
    enableServicePublicIP?: boolean;
    fabricSettings?: SettingsSectionDescription[];
    readonly fqdn?: string;
    httpGatewayConnectionPort?: number;
    httpGatewayTokenAuthConnectionPort?: number;
    ipTags?: IpTag[];
    readonly ipv4Address?: string;
    readonly ipv6Address?: string;
    loadBalancingRules?: LoadBalancingRule[];
    networkSecurityRules?: NetworkSecurityRule[];
    readonly provisioningState?: ManagedResourceProvisioningState;
    publicIPPrefixId?: string;
    publicIPv6PrefixId?: string;
    serviceEndpoints?: ServiceEndpoint[];
    sku: Sku;
    subnetId?: string;
    upgradeDescription?: ClusterUpgradePolicy;
    useCustomVnet?: boolean;
    zonalResiliency?: boolean;
    zonalUpdateMode?: ZonalUpdateMode;
}

// @public
export type ManagedClusterAddOnFeature = string;

// @public
export interface ManagedClusterCodeVersionResult {
    clusterCodeVersion?: string;
    id?: string;
    name?: string;
    osType?: OsType;
    supportExpiryUtc?: string;
    type?: string;
}

// @public
export interface ManagedClusterListResult {
    nextLink?: string;
    // (undocumented)
    value?: ManagedCluster[];
}

// @public
export interface ManagedClusters {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersCreateOrUpdateResponse>, ManagedClustersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams): Promise<ManagedClustersCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, options?: ManagedClustersDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, options?: ManagedClustersDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, options?: ManagedClustersGetOptionalParams): Promise<ManagedClustersGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: ManagedClustersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<ManagedCluster>;
    listBySubscription(options?: ManagedClustersListBySubscriptionOptionalParams): PagedAsyncIterableIterator<ManagedCluster>;
    update(resourceGroupName: string, clusterName: string, parameters: ManagedClusterUpdateParameters, options?: ManagedClustersUpdateOptionalParams): Promise<ManagedClustersUpdateResponse>;
}

// @public
export interface ManagedClustersCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ManagedClustersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersCreateOrUpdateResponse = ManagedCluster;

// @public
export interface ManagedClustersDeleteHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ManagedClustersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetResponse = ManagedCluster;

// @public
export interface ManagedClustersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListByResourceGroupNextResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListByResourceGroupResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListBySubscriptionNextResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListBySubscriptionResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersUpdateResponse = ManagedCluster;

// @public
export interface ManagedClusterUpdateParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface ManagedClusterVersion {
    get(location: string, clusterVersion: string, options?: ManagedClusterVersionGetOptionalParams): Promise<ManagedClusterVersionGetResponse>;
    getByEnvironment(location: string, environment: ManagedClusterVersionEnvironment, clusterVersion: string, options?: ManagedClusterVersionGetByEnvironmentOptionalParams): Promise<ManagedClusterVersionGetByEnvironmentResponse>;
    list(location: string, options?: ManagedClusterVersionListOptionalParams): Promise<ManagedClusterVersionListResponse>;
    listByEnvironment(location: string, environment: ManagedClusterVersionEnvironment, options?: ManagedClusterVersionListByEnvironmentOptionalParams): Promise<ManagedClusterVersionListByEnvironmentResponse>;
}

// @public
export type ManagedClusterVersionEnvironment = string;

// @public
export interface ManagedClusterVersionGetByEnvironmentOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClusterVersionGetByEnvironmentResponse = ManagedClusterCodeVersionResult;

// @public
export interface ManagedClusterVersionGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClusterVersionGetResponse = ManagedClusterCodeVersionResult;

// @public
export interface ManagedClusterVersionListByEnvironmentOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClusterVersionListByEnvironmentResponse = ManagedClusterCodeVersionResult[];

// @public
export interface ManagedClusterVersionListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClusterVersionListResponse = ManagedClusterCodeVersionResult[];

// @public
export interface ManagedIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ManagedIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentity;
    };
}

// @public
export type ManagedIdentityType = "None" | "SystemAssigned" | "UserAssigned" | "SystemAssigned, UserAssigned";

// @public
export interface ManagedMaintenanceWindowStatus {
    readonly canApplyUpdates?: boolean;
    readonly isRegionReady?: boolean;
    readonly isWindowActive?: boolean;
    readonly isWindowEnabled?: boolean;
    readonly lastWindowEndTimeUTC?: Date;
    readonly lastWindowStartTimeUTC?: Date;
    readonly lastWindowStatusUpdateAtUTC?: Date;
}

// @public
export interface ManagedMaintenanceWindowStatusGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedMaintenanceWindowStatusGetResponse = ManagedMaintenanceWindowStatus;

// @public
export interface ManagedMaintenanceWindowStatusOperations {
    get(resourceGroupName: string, clusterName: string, options?: ManagedMaintenanceWindowStatusGetOptionalParams): Promise<ManagedMaintenanceWindowStatusGetResponse>;
}

// @public
export interface ManagedProxyResource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export type ManagedResourceProvisioningState = string;

// @public
export interface ManagedUnsupportedVMSizes {
    get(location: string, vmSize: string, options?: ManagedUnsupportedVMSizesGetOptionalParams): Promise<ManagedUnsupportedVMSizesGetResponse>;
    list(location: string, options?: ManagedUnsupportedVMSizesListOptionalParams): PagedAsyncIterableIterator<ManagedVMSize>;
}

// @public
export interface ManagedUnsupportedVMSizesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedUnsupportedVMSizesGetResponse = ManagedVMSize;

// @public
export interface ManagedUnsupportedVMSizesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedUnsupportedVMSizesListNextResponse = ManagedVMSizesResult;

// @public
export interface ManagedUnsupportedVMSizesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedUnsupportedVMSizesListResponse = ManagedVMSizesResult;

// @public
export interface ManagedVMSize {
    readonly id?: string;
    readonly name?: string;
    readonly properties?: VMSize;
    readonly type?: string;
}

// @public
export interface ManagedVMSizesResult {
    readonly nextLink?: string;
    value?: ManagedVMSize[];
}

// @public
export type MoveCost = string;

// @public
export interface NamedPartitionScheme extends Partition {
    names: string[];
    partitionScheme: "Named";
}

// @public
export interface NetworkSecurityRule {
    access: Access;
    description?: string;
    destinationAddressPrefix?: string;
    destinationAddressPrefixes?: string[];
    destinationPortRange?: string;
    destinationPortRanges?: string[];
    direction: Direction;
    name: string;
    priority: number;
    protocol: NsgProtocol;
    sourceAddressPrefix?: string;
    sourceAddressPrefixes?: string[];
    sourcePortRange?: string;
    sourcePortRanges?: string[];
}

// @public
export interface NodeType extends ManagedProxyResource {
    additionalDataDisks?: VmssDataDisk[];
    additionalNetworkInterfaceConfigurations?: AdditionalNetworkInterfaceConfiguration[];
    applicationPorts?: EndpointRangeDescription;
    capacities?: {
        [propertyName: string]: string;
    };
    computerNamePrefix?: string;
    dataDiskLetter?: string;
    dataDiskSizeGB?: number;
    dataDiskType?: DiskType;
    dscpConfigurationId?: string;
    enableAcceleratedNetworking?: boolean;
    enableEncryptionAtHost?: boolean;
    enableNodePublicIP?: boolean;
    enableNodePublicIPv6?: boolean;
    enableOverProvisioning?: boolean;
    ephemeralPorts?: EndpointRangeDescription;
    evictionPolicy?: EvictionPolicyType;
    frontendConfigurations?: FrontendConfiguration[];
    hostGroupId?: string;
    isPrimary?: boolean;
    isSpotVM?: boolean;
    isStateless?: boolean;
    multiplePlacementGroups?: boolean;
    natConfigurations?: NodeTypeNatConfig[];
    natGatewayId?: string;
    networkSecurityRules?: NetworkSecurityRule[];
    placementProperties?: {
        [propertyName: string]: string;
    };
    readonly provisioningState?: ManagedResourceProvisioningState;
    secureBootEnabled?: boolean;
    securityType?: SecurityType;
    serviceArtifactReferenceId?: string;
    sku?: NodeTypeSku;
    spotRestoreTimeout?: string;
    subnetId?: string;
    useDefaultPublicLoadBalancer?: boolean;
    useEphemeralOSDisk?: boolean;
    useTempDataDisk?: boolean;
    vmApplications?: VmApplication[];
    vmExtensions?: VmssExtension[];
    vmImageOffer?: string;
    vmImagePlan?: VmImagePlan;
    vmImagePublisher?: string;
    vmImageResourceId?: string;
    vmImageSku?: string;
    vmImageVersion?: string;
    vmInstanceCount?: number;
    vmManagedIdentity?: VmManagedIdentity;
    vmSecrets?: VaultSecretGroup[];
    vmSetupActions?: VmSetupAction[];
    vmSharedGalleryImageId?: string;
    vmSize?: string;
    zones?: string[];
}

// @public
export interface NodeTypeActionParameters {
    force?: boolean;
    nodes?: string[];
    updateType?: UpdateType;
}

// @public
export interface NodeTypeAvailableSku {
    readonly capacity?: NodeTypeSkuCapacity;
    readonly resourceType?: string;
    readonly sku?: NodeTypeSupportedSku;
}

// @public
export interface NodeTypeListResult {
    nextLink?: string;
    value?: NodeType[];
}

// @public
export interface NodeTypeListSkuResult {
    nextLink?: string;
    value?: NodeTypeAvailableSku[];
}

// @public
export interface NodeTypeNatConfig {
    backendPort?: number;
    frontendPortRangeEnd?: number;
    frontendPortRangeStart?: number;
}

// @public
export interface NodeTypes {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeType, options?: NodeTypesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<NodeTypesCreateOrUpdateResponse>, NodeTypesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeType, options?: NodeTypesCreateOrUpdateOptionalParams): Promise<NodeTypesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, nodeTypeName: string, options?: NodeTypesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, nodeTypeName: string, options?: NodeTypesDeleteOptionalParams): Promise<void>;
    beginDeleteNode(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesDeleteNodeOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteNodeAndWait(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesDeleteNodeOptionalParams): Promise<void>;
    beginReimage(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesReimageOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginReimageAndWait(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesReimageOptionalParams): Promise<void>;
    beginRestart(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesRestartOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginRestartAndWait(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeActionParameters, options?: NodeTypesRestartOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, nodeTypeName: string, options?: NodeTypesGetOptionalParams): Promise<NodeTypesGetResponse>;
    listByManagedClusters(resourceGroupName: string, clusterName: string, options?: NodeTypesListByManagedClustersOptionalParams): PagedAsyncIterableIterator<NodeType>;
    update(resourceGroupName: string, clusterName: string, nodeTypeName: string, parameters: NodeTypeUpdateParameters, options?: NodeTypesUpdateOptionalParams): Promise<NodeTypesUpdateResponse>;
}

// @public
export interface NodeTypesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface NodeTypesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NodeTypesCreateOrUpdateResponse = NodeType;

// @public
export interface NodeTypesDeleteHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface NodeTypesDeleteNodeHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface NodeTypesDeleteNodeOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NodeTypesGetResponse = NodeType;

// @public
export interface NodeTypeSku {
    capacity: number;
    name?: string;
    tier?: string;
}

// @public
export interface NodeTypeSkuCapacity {
    readonly default?: number;
    readonly maximum?: number;
    readonly minimum?: number;
    readonly scaleType?: NodeTypeSkuScaleType;
}

// @public
export interface NodeTypeSkus {
    list(resourceGroupName: string, clusterName: string, nodeTypeName: string, options?: NodeTypeSkusListOptionalParams): PagedAsyncIterableIterator<NodeTypeAvailableSku>;
}

// @public
export type NodeTypeSkuScaleType = string;

// @public
export interface NodeTypeSkusListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NodeTypeSkusListNextResponse = NodeTypeListSkuResult;

// @public
export interface NodeTypeSkusListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NodeTypeSkusListResponse = NodeTypeListSkuResult;

// @public
export interface NodeTypesListByManagedClustersNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NodeTypesListByManagedClustersNextResponse = NodeTypeListResult;

// @public
export interface NodeTypesListByManagedClustersOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NodeTypesListByManagedClustersResponse = NodeTypeListResult;

// @public
export interface NodeTypesReimageHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface NodeTypesReimageOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesRestartHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface NodeTypesRestartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface NodeTypesUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NodeTypesUpdateResponse = NodeType;

// @public
export interface NodeTypeSupportedSku {
    readonly name?: string;
    readonly tier?: string;
}

// @public
export interface NodeTypeUpdateParameters {
    sku?: NodeTypeSku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type NsgProtocol = string;

// @public
export interface OperationListResult {
    readonly nextLink?: string;
    value?: OperationResult[];
}

// @public
export interface OperationResult {
    display?: AvailableOperationDisplay;
    isDataAction?: boolean;
    name?: string;
    nextLink?: string;
    origin?: string;
}

// @public
export interface OperationResults {
    get(location: string, operationId: string, options?: OperationResultsGetOptionalParams): Promise<OperationResultsGetResponse>;
}

// @public
export interface OperationResultsGetHeaders {
    location?: string;
}

// @public
export interface OperationResultsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationResultsGetResponse = OperationResultsGetHeaders;

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<OperationResult>;
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = OperationListResult;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface OperationStatus {
    get(location: string, operationId: string, options?: OperationStatusGetOptionalParams): Promise<OperationStatusGetResponse>;
}

// @public
export interface OperationStatusGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationStatusGetResponse = LongRunningOperationResult;

// @public
export type OsType = string;

// @public
export interface Partition {
    partitionScheme: "Named" | "Singleton" | "UniformInt64Range";
}

// @public
export interface PartitionInstanceCountScaleMechanism extends ScalingMechanism {
    kind: "ScalePartitionInstanceCount";
    maxInstanceCount: number;
    minInstanceCount: number;
    scaleIncrement: number;
}

// @public
export type PartitionScheme = string;

// @public (undocumented)
export type PartitionUnion = Partition | NamedPartitionScheme | SingletonPartitionScheme | UniformInt64RangePartitionScheme;

// @public
export type PrivateEndpointNetworkPolicies = string;

// @public
export type PrivateIPAddressVersion = string;

// @public
export type PrivateLinkServiceNetworkPolicies = string;

// @public
export type ProbeProtocol = string;

// @public
export type Protocol = string;

// @public
export interface ProxyResource {
    readonly id?: string;
    location?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export type PublicIPAddressVersion = string;

// @public
export interface Resource {
    readonly etag?: string;
    readonly id?: string;
    location: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export interface ResourceAzStatus {
    readonly details?: string;
    readonly isZoneResilient?: boolean;
    readonly resourceName?: string;
    readonly resourceType?: string;
}

// @public
export type RollingUpgradeMode = string;

// @public
export interface RollingUpgradeMonitoringPolicy {
    failureAction: FailureAction;
    healthCheckRetryTimeout: string;
    healthCheckStableDuration: string;
    healthCheckWaitDuration: string;
    upgradeDomainTimeout: string;
    upgradeTimeout: string;
}

// @public
export interface RuntimeResumeApplicationUpgradeParameters {
    upgradeDomainName?: string;
}

// @public
export interface ScalingMechanism {
    kind: "AddRemoveIncrementalNamedPartition" | "ScalePartitionInstanceCount";
}

// @public (undocumented)
export type ScalingMechanismUnion = ScalingMechanism | AddRemoveIncrementalNamedPartitionScalingMechanism | PartitionInstanceCountScaleMechanism;

// @public
export interface ScalingPolicy {
    scalingMechanism: ScalingMechanismUnion;
    scalingTrigger: ScalingTriggerUnion;
}

// @public
export interface ScalingTrigger {
    kind: "AveragePartitionLoadTrigger" | "AverageServiceLoadTrigger";
}

// @public (undocumented)
export type ScalingTriggerUnion = ScalingTrigger | AveragePartitionLoadScalingTrigger | AverageServiceLoadScalingTrigger;

// @public
export type SecurityType = string;

// @public
export interface ServiceCorrelation {
    scheme: ServiceCorrelationScheme;
    serviceName: string;
}

// @public
export type ServiceCorrelationScheme = string;

// @public
export interface ServiceEndpoint {
    locations?: string[];
    service: string;
}

// @public (undocumented)
export class ServiceFabricManagedClustersManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: ServiceFabricManagedClustersManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    applications: Applications;
    // (undocumented)
    applicationTypes: ApplicationTypes;
    // (undocumented)
    applicationTypeVersions: ApplicationTypeVersions;
    // (undocumented)
    managedApplyMaintenanceWindow: ManagedApplyMaintenanceWindow;
    // (undocumented)
    managedAzResiliencyStatusOperations: ManagedAzResiliencyStatusOperations;
    // (undocumented)
    managedClusters: ManagedClusters;
    // (undocumented)
    managedClusterVersion: ManagedClusterVersion;
    // (undocumented)
    managedMaintenanceWindowStatusOperations: ManagedMaintenanceWindowStatusOperations;
    // (undocumented)
    managedUnsupportedVMSizes: ManagedUnsupportedVMSizes;
    // (undocumented)
    nodeTypes: NodeTypes;
    // (undocumented)
    nodeTypeSkus: NodeTypeSkus;
    // (undocumented)
    operationResults: OperationResults;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    operationStatus: OperationStatus;
    // (undocumented)
    services: Services;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface ServiceFabricManagedClustersManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export type ServiceKind = string;

// @public
export interface ServiceLoadMetric {
    defaultLoad?: number;
    name: string;
    primaryDefaultLoad?: number;
    secondaryDefaultLoad?: number;
    weight?: ServiceLoadMetricWeight;
}

// @public
export type ServiceLoadMetricWeight = string;

// @public
export type ServicePackageActivationMode = string;

// @public
export interface ServicePlacementInvalidDomainPolicy extends ServicePlacementPolicy {
    domainName: string;
    type: "InvalidDomain";
}

// @public
export interface ServicePlacementNonPartiallyPlaceServicePolicy extends ServicePlacementPolicy {
    type: "NonPartiallyPlaceService";
}

// @public
export interface ServicePlacementPolicy {
    type: "InvalidDomain" | "NonPartiallyPlaceService" | "PreferredPrimaryDomain" | "RequiredDomain" | "RequiredDomainDistribution";
}

// @public
export type ServicePlacementPolicyType = string;

// @public (undocumented)
export type ServicePlacementPolicyUnion = ServicePlacementPolicy | ServicePlacementInvalidDomainPolicy | ServicePlacementNonPartiallyPlaceServicePolicy | ServicePlacementPreferPrimaryDomainPolicy | ServicePlacementRequiredDomainPolicy | ServicePlacementRequireDomainDistributionPolicy;

// @public
export interface ServicePlacementPreferPrimaryDomainPolicy extends ServicePlacementPolicy {
    domainName: string;
    type: "PreferredPrimaryDomain";
}

// @public
export interface ServicePlacementRequiredDomainPolicy extends ServicePlacementPolicy {
    domainName: string;
    type: "RequiredDomain";
}

// @public
export interface ServicePlacementRequireDomainDistributionPolicy extends ServicePlacementPolicy {
    domainName: string;
    type: "RequiredDomainDistribution";
}

// @public
export interface ServiceResource extends ProxyResource {
    properties?: ServiceResourcePropertiesUnion;
}

// @public
export interface ServiceResourceList {
    readonly nextLink?: string;
    // (undocumented)
    value?: ServiceResource[];
}

// @public
export interface ServiceResourceProperties extends ServiceResourcePropertiesBase {
    partitionDescription: PartitionUnion;
    readonly provisioningState?: string;
    serviceDnsName?: string;
    serviceKind: ServiceKind;
    servicePackageActivationMode?: ServicePackageActivationMode;
    serviceTypeName: string;
}

// @public
export interface ServiceResourcePropertiesBase {
    correlationScheme?: ServiceCorrelation[];
    defaultMoveCost?: MoveCost;
    placementConstraints?: string;
    scalingPolicies?: ScalingPolicy[];
    serviceLoadMetrics?: ServiceLoadMetric[];
    servicePlacementPolicies?: ServicePlacementPolicyUnion[];
}

// @public (undocumented)
export type ServiceResourcePropertiesUnion = ServiceResourceProperties | StatefulServiceProperties | StatelessServiceProperties;

// @public
export interface Services {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: ServiceResource, options?: ServicesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ServicesCreateOrUpdateResponse>, ServicesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: ServiceResource, options?: ServicesCreateOrUpdateOptionalParams): Promise<ServicesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: ServicesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: ServicesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, options?: ServicesGetOptionalParams): Promise<ServicesGetResponse>;
    listByApplications(resourceGroupName: string, clusterName: string, applicationName: string, options?: ServicesListByApplicationsOptionalParams): PagedAsyncIterableIterator<ServiceResource>;
    update(resourceGroupName: string, clusterName: string, applicationName: string, serviceName: string, parameters: ServiceUpdateParameters, options?: ServicesUpdateOptionalParams): Promise<ServicesUpdateResponse>;
}

// @public
export type ServiceScalingMechanismKind = string;

// @public
export type ServiceScalingTriggerKind = string;

// @public
export interface ServicesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ServicesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ServicesCreateOrUpdateResponse = ServiceResource;

// @public
export interface ServicesDeleteHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ServicesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ServicesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServicesGetResponse = ServiceResource;

// @public
export interface ServicesListByApplicationsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServicesListByApplicationsNextResponse = ServiceResourceList;

// @public
export interface ServicesListByApplicationsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServicesListByApplicationsResponse = ServiceResourceList;

// @public
export interface ServicesUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServicesUpdateResponse = ServiceResource;

// @public
export interface ServiceTypeHealthPolicy {
    maxPercentUnhealthyPartitionsPerService: number;
    maxPercentUnhealthyReplicasPerPartition: number;
    maxPercentUnhealthyServices: number;
}

// @public
export interface ServiceUpdateParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface SettingsParameterDescription {
    name: string;
    value: string;
}

// @public
export interface SettingsSectionDescription {
    name: string;
    parameters: SettingsParameterDescription[];
}

// @public
export interface SingletonPartitionScheme extends Partition {
    partitionScheme: "Singleton";
}

// @public
export interface Sku {
    name: SkuName;
}

// @public
export type SkuName = string;

// @public
export interface StatefulServiceProperties extends ServiceResourceProperties {
    hasPersistedState?: boolean;
    minReplicaSetSize?: number;
    quorumLossWaitDuration?: string;
    replicaRestartWaitDuration?: string;
    serviceKind: "Stateful";
    servicePlacementTimeLimit?: string;
    standByReplicaKeepDuration?: string;
    targetReplicaSetSize?: number;
}

// @public
export interface StatelessServiceProperties extends ServiceResourceProperties {
    instanceCount: number;
    minInstanceCount?: number;
    minInstancePercentage?: number;
    serviceKind: "Stateless";
}

// @public
export interface Subnet {
    enableIpv6?: boolean;
    name: string;
    networkSecurityGroupId?: string;
    privateEndpointNetworkPolicies?: PrivateEndpointNetworkPolicies;
    privateLinkServiceNetworkPolicies?: PrivateLinkServiceNetworkPolicies;
}

// @public
export interface SubResource {
    id?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: string;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: string;
}

// @public
export interface UniformInt64RangePartitionScheme extends Partition {
    count: number;
    highKey: number;
    lowKey: number;
    partitionScheme: "UniformInt64Range";
}

// @public
export type UpdateType = string;

// @public
export type UpgradeMode = string;

// @public (undocumented)
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface VaultCertificate {
    certificateStore: string;
    certificateUrl: string;
}

// @public
export interface VaultSecretGroup {
    sourceVault: SubResource;
    vaultCertificates: VaultCertificate[];
}

// @public
export interface VmApplication {
    configurationReference?: string;
    enableAutomaticUpgrade?: boolean;
    order?: number;
    packageReferenceId: string;
    treatFailureAsDeploymentFailure?: boolean;
    vmGalleryTags?: string;
}

// @public
export interface VmImagePlan {
    name?: string;
    product?: string;
    promotionCode?: string;
    publisher?: string;
}

// @public
export interface VmManagedIdentity {
    userAssignedIdentities?: string[];
}

// @public
export type VmSetupAction = string;

// @public
export interface VMSize {
    readonly size?: string;
}

// @public
export interface VmssDataDisk {
    diskLetter: string;
    diskSizeGB: number;
    diskType: DiskType;
    lun: number;
}

// @public
export interface VmssExtension {
    autoUpgradeMinorVersion?: boolean;
    enableAutomaticUpgrade?: boolean;
    forceUpdateTag?: string;
    name: string;
    protectedSettings?: Record<string, unknown>;
    provisionAfterExtensions?: string[];
    readonly provisioningState?: string;
    publisher: string;
    settings?: Record<string, unknown>;
    setupOrder?: VmssExtensionSetupOrder[];
    type: string;
    typeHandlerVersion: string;
}

// @public
export type VmssExtensionSetupOrder = string;

// @public
export type ZonalUpdateMode = string;

// (No @packageDocumentation comment for this package)

```
