"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AttestationClient = void 0;
const tslib_1 = require("tslib");
const generatedClient_js_1 = require("./generated/generatedClient.js");
const index_js_1 = require("./generated/models/index.js");
const logger_js_1 = require("./logger.js");
const Mappers = tslib_1.__importStar(require("./generated/models/mappers.js"));
const attestationResponse_js_1 = require("./models/attestationResponse.js");
const typeDeserializer_js_1 = require("./utils/typeDeserializer.js");
const core_auth_1 = require("@azure/core-auth");
const utf8_js_1 = require("./utils/utf8.js");
const attestationResult_js_1 = require("./models/attestationResult.js");
const attestationSigner_js_1 = require("./models/attestationSigner.js");
const attestationToken_js_1 = require("./models/attestationToken.js");
const buffer_js_1 = require("./utils/buffer.js");
const tracing_js_1 = require("./generated/tracing.js");
/**
 * Attestation Client class.
 *
 * The AttestationClient class enables access to the Attestation related APIs:
 *
 * - getOpenIdMetadata
 * - getAttestationSigners
 * - attestSgxEnclave
 * - attestOpenEnclave
 * - attestTpm
 */
class AttestationClient {
    constructor(endpoint, credentialsOrOptions, clientOptions = {}) {
        let credentialScopes = undefined;
        let credential = undefined;
        let options;
        if (credentialsOrOptions && (0, core_auth_1.isTokenCredential)(credentialsOrOptions)) {
            credential = credentialsOrOptions;
            credentialScopes = ["https://attest.azure.net/.default"];
            options = clientOptions;
        }
        else {
            options = credentialsOrOptions || {};
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            credentialScopes: credentialScopes,
            credential: credential,
            loggingOptions: {
                logger: logger_js_1.logger.info,
                allowedHeaderNames: ["x-ms-request-id", "x-ms-maa-service-version"],
            },
        });
        this._client = new generatedClient_js_1.GeneratedClient(endpoint, internalPipelineOptions);
        this._validationOptions = options.validationOptions;
    }
    /** Attests an OpenEnclave report generated from an SGX Enclave using the OpenEnclave SDK.
     *
     * @param report - An OpenEnclave report generated by an SGX enclave.
     * @param options - Operation options for the attestOpenEnclave API call.
     * @returns Returns an AttestationResponse whose body is an AttestationResult describing
     *    the claims returned by the attestation service.
     *
     * @throws {@link Error} if the `initTimeData` option and `initTimeJson` option is provided.
     * @throws {@link Error} if the `runTimeData` option and `runTimeJson` option is provided.
     * @throws {@link Error} if the `initTimeJson` option is provided and the value of `initTimeJson` is not JSON.
     * @throws {@link Error} if the `runTimeJson` option is provided and the value of `runTimeJson` is not JSON.
     */
    async attestOpenEnclave(report, options = {}) {
        return tracing_js_1.tracingClient.withSpan("AttestationClient-attestOpenEnclave", options, async (updatedOptions) => {
            var _a, _b, _c, _d;
            if (options.initTimeData !== undefined && options.initTimeJson !== undefined) {
                throw new Error("Cannot provide both initTimeData and initTimeJson.");
            }
            if (options.runTimeData !== undefined && options.runTimeJson !== undefined) {
                throw new Error("Cannot provide both runTimeData and runTimeJson.");
            }
            const initData = await (0, buffer_js_1.Uint8ArrayFromInput)((_a = options.initTimeData) !== null && _a !== void 0 ? _a : options.initTimeJson);
            const initTimeData = initData
                ? {
                    data: initData,
                    dataType: options.initTimeJson !== undefined ? index_js_1.KnownDataType.Json : index_js_1.KnownDataType.Binary,
                }
                : undefined;
            const runData = await (0, buffer_js_1.Uint8ArrayFromInput)((_b = options.runTimeData) !== null && _b !== void 0 ? _b : options.runTimeJson);
            const runTimeData = runData
                ? {
                    data: runData,
                    dataType: options.runTimeJson !== undefined ? index_js_1.KnownDataType.Json : index_js_1.KnownDataType.Binary,
                }
                : undefined;
            const attestationResponse = await this._client.attestation.attestOpenEnclave({
                report: await (0, buffer_js_1.Uint8ArrayFromInput)(report),
                initTimeData: initTimeData,
                runtimeData: runTimeData,
                draftPolicyForAttestation: (_c = options.draftPolicyForAttestation) !== null && _c !== void 0 ? _c : undefined,
            }, updatedOptions);
            const token = new attestationToken_js_1.AttestationTokenImpl(attestationResponse.token);
            const problems = token.getTokenProblems(await this._signingKeys(), (_d = options.validationOptions) !== null && _d !== void 0 ? _d : this._validationOptions);
            if (problems.length) {
                throw new Error(problems.join(";"));
            }
            const attestationResult = typeDeserializer_js_1.TypeDeserializer.deserialize(token.getBody(), {
                GeneratedAttestationResult: Mappers.GeneratedAttestationResult,
                JsonWebKey: Mappers.JsonWebKey,
            }, "GeneratedAttestationResult");
            return (0, attestationResponse_js_1.createAttestationResponse)(token, (0, attestationResult_js_1._attestationResultFromGenerated)(attestationResult));
        });
    }
    /** Attests a quote generated from SGX Enclave using the Intel SDK.
     *
     * @param quote - An SGX quote generated by an SGX enclave.
     * @param options - Operation options for the attestOpenEnclave API call.
     * @returns Returns an AttestationResponse whose body is an AttestationResult describing
     *    the claims returned by the attestation service.
     * @throws {@link Error} if the `initTimeData` option and `initTimeJson` option is provided.
     * @throws {@link Error} if the `runTimeData` option and `runTimeJson` option is provided.
     */
    async attestSgxEnclave(quote, options = {}) {
        return tracing_js_1.tracingClient.withSpan("AttestationClient-attestSgxEnclave", options, async (updatedOptions) => {
            var _a, _b, _c, _d;
            if (options.initTimeData !== undefined && options.initTimeJson !== undefined) {
                throw new Error("Cannot provide both initTimeData and initTimeJson.");
            }
            if (options.runTimeData !== undefined && options.runTimeJson !== undefined) {
                throw new Error("Cannot provide both runTimeData and runTimeJson.");
            }
            const initData = await (0, buffer_js_1.Uint8ArrayFromInput)((_a = options.initTimeData) !== null && _a !== void 0 ? _a : options.initTimeJson);
            const initTimeData = initData
                ? {
                    data: initData,
                    dataType: options.initTimeJson !== undefined ? index_js_1.KnownDataType.Json : index_js_1.KnownDataType.Binary,
                }
                : undefined;
            const runData = await (0, buffer_js_1.Uint8ArrayFromInput)((_b = options.runTimeData) !== null && _b !== void 0 ? _b : options.runTimeJson);
            const runTimeData = runData
                ? {
                    data: runData,
                    dataType: options.runTimeJson !== undefined ? index_js_1.KnownDataType.Json : index_js_1.KnownDataType.Binary,
                }
                : undefined;
            const attestationResponse = await this._client.attestation.attestSgxEnclave({
                quote: await (0, buffer_js_1.Uint8ArrayFromInput)(quote),
                initTimeData: initTimeData,
                runtimeData: runTimeData,
                draftPolicyForAttestation: (_c = options.draftPolicyForAttestation) !== null && _c !== void 0 ? _c : undefined,
            }, updatedOptions);
            const token = new attestationToken_js_1.AttestationTokenImpl(attestationResponse.token);
            const problems = token.getTokenProblems(await this._signingKeys(), (_d = options.validationOptions) !== null && _d !== void 0 ? _d : this._validationOptions);
            if (problems.length) {
                throw new Error(problems.join(";"));
            }
            const attestationResult = typeDeserializer_js_1.TypeDeserializer.deserialize(token.getBody(), {
                GeneratedAttestationResult: Mappers.GeneratedAttestationResult,
                JsonWebKey: Mappers.JsonWebKey,
            }, "GeneratedAttestationResult");
            return (0, attestationResponse_js_1.createAttestationResponse)(token, (0, attestationResult_js_1._attestationResultFromGenerated)(attestationResult));
        });
    }
    /** Attest a TPM based enclave.
  
     * See the  {@link https://learn.microsoft.com/en-us/azure/attestation/virtualization-based-security-protocol | TPM Attestation Protocol Reference} for more information.
     *
     * @param request - Incoming request to send to the TPM attestation service, Utf8 encoded.
     * @param options - Pipeline options for TPM attestation request.
     * @returns A structure containing the response from the TPM attestation, Utf8 encoded.
     *
     * @remarks
     *
     * The incoming requests to the TPM attestation API are stringified JSON objects.
     *
     * @example
     * For example, the initial call for a TPM attestation operation is:
     *
     * ```snippet:AttestationClient_AttestTpm
     * const encodedPayload = JSON.stringify({ payload: { type: "aikcert" } });
     * const result = await client.attestTpm(encodedPayload);
     * ```
     *
     * where stringToBytes converts the string to UTF8.
     *
     * Note that the attestTpm requires an attestation client which is configured with
     * authentication credentials.
     *
     */
    async attestTpm(request, options = {}) {
        return tracing_js_1.tracingClient.withSpan("AttestationClient-attestSgxEnclave", options, async (updatedOptions) => {
            const response = await this._client.attestation.attestTpm({ data: (0, utf8_js_1.stringToBytes)(request) }, updatedOptions);
            if (response.data) {
                return (0, utf8_js_1.bytesToString)(response.data);
            }
            else {
                throw Error("Internal error - response data cannot be undefined.");
            }
        });
    }
    /**
     * Returns the list of attestation signers which can be used to sign attestation
     * service tokens.
     *
     * @param options - Client operation options.
     * @returns the set of AttestationSigners which may be used to sign attestation tokens.
     */
    async getAttestationSigners(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return tracing_js_1.tracingClient.withSpan("AttestationClient-getAttestationSigners", options, async (updatedOptions) => {
            var _a;
            const signingCertificates = await this._client.signingCertificates.get(updatedOptions);
            const signers = new Array();
            (_a = signingCertificates.keys) === null || _a === void 0 ? void 0 : _a.forEach((element) => {
                signers.push((0, attestationSigner_js_1._attestationSignerFromGenerated)(element));
            });
            return signers;
        });
    }
    /**
     * Returns the OpenID Metadata discovery document for the attestation service instance.
     * @param options - Client operation options.
     * @returns The OpenID metadata discovery document for the attestation service.
     */
    async getOpenIdMetadata(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options = {}) {
        return tracing_js_1.tracingClient.withSpan("AttestationClient-getOpenIdMetadata", options, async (updatedOptions) => {
            const configs = await this._client.metadataConfiguration.get(updatedOptions);
            return configs;
        });
    }
    async _signingKeys() {
        var _a;
        if (this._signers !== undefined) {
            return this._signers;
        }
        const jwks = await this._client.signingCertificates.get();
        const signers = new Array();
        (_a = jwks.keys) === null || _a === void 0 ? void 0 : _a.forEach((element) => {
            signers.push((0, attestationSigner_js_1._attestationSignerFromGenerated)(element));
        });
        this._signers = signers;
        return this._signers;
    }
}
exports.AttestationClient = AttestationClient;
//# sourceMappingURL=attestationClient.js.map