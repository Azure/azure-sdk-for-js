## API Report File for "@azure/event-hubs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { AmqpError } from 'rhea-promise';
import { ConnectionContextBase } from '@azure/core-amqp';
import { DataTransformer } from '@azure/core-amqp';
import { DefaultDataTransformer } from '@azure/core-amqp';
import { delay } from '@azure/core-amqp';
import { Dictionary } from 'rhea-promise';
import { EventHubConnectionConfig } from '@azure/core-amqp';
import { MessagingError } from '@azure/core-amqp';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { RetryPolicy } from '@azure/core-amqp';
import { Sender } from 'rhea-promise';
import { SharedKeyCredential } from '@azure/core-amqp';
import { TokenCredential } from '@azure/core-amqp';
import { TokenType } from '@azure/core-amqp';
import { WebSocketImpl } from 'rhea-promise';

// @public
export interface BatchOptions {
    abortSignal?: AbortSignalLike;
    maxSizeInBytes?: number;
    partitionKey?: string;
}

// @public
export interface Checkpoint {
    consumerGroupName: string;
    eventHubName: string;
    instanceId: string;
    offset: number;
    partitionId: string;
    sequenceNumber: number;
}

// @public
export class CheckpointManager {
    // (undocumented)
    updateCheckpoint(eventData: EventData): Promise<void>;
    // (undocumented)
    updateCheckpoint(offset: string, sequenceNumber: number): Promise<void>;
}

// @public
export enum CloseReason {
    EventHubException = "EventHubException",
    OwnershipLost = "OwnershipLost",
    Shutdown = "Shutdown"
}

export { DataTransformer }

export { DefaultDataTransformer }

export { delay }

// @public
export interface EventData {
    body: any;
    properties?: {
        [key: string]: any;
    };
}

// @public
export class EventDataBatch {
    // Warning: (ae-forgotten-export) The symbol "ConnectionContext" needs to be exported by the entry point index.d.ts
    // 
    // @internal
    constructor(context: ConnectionContext, maxSizeInBytes: number, partitionKey?: string);
    readonly batchMessage: Buffer | undefined;
    readonly count: number;
    readonly partitionKey: string | undefined;
    readonly sizeInBytes: number;
    tryAdd(eventData: EventData): boolean;
}

// @public
export class EventHubClient {
    constructor(connectionString: string, options?: EventHubClientOptions);
    constructor(connectionString: string, eventHubPath: string, options?: EventHubClientOptions);
    constructor(host: string, eventHubPath: string, credential: TokenCredential, options?: EventHubClientOptions);
    close(): Promise<void>;
    createConsumer(consumerGroup: string, partitionId: string, eventPosition: EventPosition, options?: EventHubConsumerOptions): EventHubConsumer;
    static createFromIotHubConnectionString(iothubConnectionString: string, options?: EventHubClientOptions): Promise<EventHubClient>;
    createProducer(options?: EventHubProducerOptions): EventHubProducer;
    static defaultConsumerGroupName: string;
    readonly eventHubName: string;
    getPartitionIds(abortSignal?: AbortSignalLike): Promise<Array<string>>;
    getPartitionProperties(partitionId: string, abortSignal?: AbortSignalLike): Promise<PartitionProperties>;
    getProperties(abortSignal?: AbortSignalLike): Promise<EventHubProperties>;
}

// @public
export interface EventHubClientOptions {
    dataTransformer?: DataTransformer;
    retryOptions?: RetryOptions;
    userAgent?: string;
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
}

// @public
export class EventHubConsumer {
    // @internal
    constructor(context: ConnectionContext, consumerGroup: string, partitionId: string, eventPosition: EventPosition, options?: EventHubConsumerOptions);
    close(): Promise<void>;
    readonly consumerGroup: string;
    getEventIterator(options?: EventIteratorOptions): AsyncIterableIterator<ReceivedEventData>;
    readonly isClosed: boolean;
    readonly isReceivingMessages: boolean;
    readonly ownerLevel: number | undefined;
    readonly partitionId: string;
    receive(onMessage: OnMessage, onError: OnError, abortSignal?: AbortSignalLike): ReceiveHandler;
    receiveBatch(maxMessageCount: number, maxWaitTimeInSeconds?: number, abortSignal?: AbortSignalLike): Promise<ReceivedEventData[]>;
    }

// @public
export interface EventHubConsumerOptions {
    ownerLevel?: number;
    retryOptions?: RetryOptions;
}

// @public
export class EventHubProducer {
    // @internal
    constructor(context: ConnectionContext, options?: EventHubProducerOptions);
    close(): Promise<void>;
    createBatch(options?: BatchOptions): Promise<EventDataBatch>;
    readonly isClosed: boolean;
    send(eventData: EventData | EventData[] | EventDataBatch, options?: SendOptions): Promise<void>;
    }

// @public
export interface EventHubProducerOptions {
    partitionId?: string;
    retryOptions?: RetryOptions;
}

// @public
export interface EventHubProperties {
    createdAt: Date;
    partitionIds: string[];
    path: string;
}

// @public
export interface EventIteratorOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export class EventPosition {
    // Warning: (ae-forgotten-export) The symbol "EventPositionOptions" needs to be exported by the entry point index.d.ts
    // 
    // @internal
    constructor(options?: EventPositionOptions);
    static earliest(): EventPosition;
    enqueuedTime?: Date | number;
    static fromEnqueuedTime(enqueuedTime: Date | number): EventPosition;
    static fromOffset(offset: string, isInclusive?: boolean): EventPosition;
    static fromSequenceNumber(sequenceNumber: number, isInclusive?: boolean): EventPosition;
    isInclusive: boolean;
    static latest(): EventPosition;
    offset?: string;
    sequenceNumber?: number;
    }

// @public
export class EventProcessor {
    constructor(consumerGroupName: string, eventHubClient: EventHubClient, partitionProcessorFactory: PartitionProcessorFactory, partitionManager: PartitionManager, options?: EventProcessorOptions);
    start(): void;
    stop(): Promise<void>;
}

// @public (undocumented)
export interface EventProcessorOptions {
    // (undocumented)
    initialEventPosition?: EventPosition;
    // (undocumented)
    maxBatchSize?: number;
    // (undocumented)
    maxWaitTimeInSeconds?: number;
}

// @public
export class InMemoryPartitionManager implements PartitionManager {
    claimOwnerships(partitionOwnerships: PartitionOwnership[]): Promise<PartitionOwnership[]>;
    listOwnerships(eventHubName: string, consumerGroupName: string): Promise<PartitionOwnership[]>;
    updateCheckpoint(checkpoint: Checkpoint): Promise<void>;
}

export { MessagingError }

// @public
export type OnError = (error: MessagingError | Error) => void;

// @public
export type OnMessage = (eventData: ReceivedEventData) => void;

// @public
export interface PartitionContext {
    readonly consumerGroupName: string;
    readonly eventHubName: string;
    readonly partitionId: string;
}

// @public
export interface PartitionManager {
    claimOwnerships(partitionOwnerships: PartitionOwnership[]): Promise<PartitionOwnership[]>;
    listOwnerships(eventHubName: string, consumerGroupName: string): Promise<PartitionOwnership[]>;
    updateCheckpoint(checkpoint: Checkpoint): Promise<void>;
}

// @public
export interface PartitionOwnership {
    consumerGroupName: string;
    eTag?: string;
    eventHubName: string;
    instanceId: string;
    lastModifiedTimeInMS?: number;
    offset?: number;
    ownerLevel: number;
    partitionId: string;
    sequenceNumber?: number;
}

// @public (undocumented)
export interface PartitionProcessor {
    close?(reason: CloseReason): Promise<void>;
    initialize?(): Promise<void>;
    processError(error: Error): Promise<void>;
    processEvents(events: EventData[]): Promise<void>;
}

// @public
export interface PartitionProcessorFactory {
    // (undocumented)
    (context: PartitionContext, checkpointManager: CheckpointManager): PartitionProcessor;
}

// @public
export interface PartitionProperties {
    beginningSequenceNumber: number;
    eventHubPath: string;
    lastEnqueuedOffset: string;
    lastEnqueuedSequenceNumber: number;
    lastEnqueuedTimeUtc: Date;
    partitionId: string;
}

// @public
export interface ReceivedEventData {
    body: any;
    enqueuedTimeUtc: Date;
    offset: string;
    partitionKey: string | null;
    properties?: {
        [key: string]: any;
    };
    sequenceNumber: number;
}

// @public
export class ReceiveHandler {
    // Warning: (ae-forgotten-export) The symbol "EventHubReceiver" needs to be exported by the entry point index.d.ts
    // 
    // @internal
    constructor(receiver: EventHubReceiver);
    readonly consumerGroup: string | undefined;
    readonly isReceiverOpen: boolean;
    readonly partitionId: string | undefined;
    stop(): Promise<void>;
}

// @public
export interface RetryOptions {
    maxExponentialRetryDelayInMs?: number;
    maxRetries?: number;
    minExponentialRetryDelayInMs?: number;
    retryInterval?: number;
    retryPolicy?: RetryPolicy;
    timeoutInMs?: number;
}

// @public
export interface SendOptions {
    abortSignal?: AbortSignalLike;
    partitionKey?: string | null;
}

export { TokenCredential }

export { TokenType }

export { WebSocketImpl }


// (No @packageDocumentation comment for this package)

```
