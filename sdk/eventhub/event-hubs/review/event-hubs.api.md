## API Report File for "@azure/event-hubs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';
import { AmqpAnnotatedMessage } from '@azure/core-amqp';
import { AzureLogger } from '@azure/logger';
import { MessagingError } from '@azure/core-amqp';
import { NamedKeyCredential } from '@azure/core-auth';
import { OperationTracingOptions } from '@azure/core-tracing';
import { RetryMode } from '@azure/core-amqp';
import { RetryOptions } from '@azure/core-amqp';
import { SASCredential } from '@azure/core-auth';
import { TokenCredential } from '@azure/core-auth';
import { WebSocketImpl } from 'rhea-promise';
import { WebSocketOptions } from '@azure/core-amqp';

// @public
export interface BufferedCloseOptions extends OperationOptions {
    flush?: boolean;
}

// @public
export interface BufferedFlushOptions extends OperationOptions {
}

// @public
export interface Checkpoint {
    consumerGroup: string;
    eventHubName: string;
    fullyQualifiedNamespace: string;
    offset: number;
    partitionId: string;
    sequenceNumber: number;
}

// @public
export interface CheckpointStore {
    claimOwnership(partitionOwnership: PartitionOwnership[], options?: OperationOptions): Promise<PartitionOwnership[]>;
    listCheckpoints(fullyQualifiedNamespace: string, eventHubName: string, consumerGroup: string, options?: OperationOptions): Promise<Checkpoint[]>;
    listOwnership(fullyQualifiedNamespace: string, eventHubName: string, consumerGroup: string, options?: OperationOptions): Promise<PartitionOwnership[]>;
    updateCheckpoint(checkpoint: Checkpoint, options?: OperationOptions): Promise<void>;
}

// @public
export enum CloseReason {
    OwnershipLost = "OwnershipLost",
    Shutdown = "Shutdown"
}

// @public
export interface CreateBatchOptions extends OperationOptions {
    maxSizeInBytes?: number;
    partitionId?: string;
    partitionKey?: string;
}

// @public
export function createEventDataAdapter(params?: EventDataAdapterParameters): MessageAdapter<EventData>;

// @public
export const earliestEventPosition: EventPosition;

// @public
export interface EnqueueEventOptions extends SendBatchOptions {
}

// @public
export interface EventData {
    body: any;
    contentType?: string;
    correlationId?: string | number | Buffer;
    messageId?: string | number | Buffer;
    properties?: {
        [key: string]: any;
    };
}

// @public
export interface EventDataAdapterParameters {
    correlationId?: string | number | Buffer;
    messageId?: string | number | Buffer;
    properties?: {
        [key: string]: any;
    };
}

// @public
export interface EventDataBatch {
    readonly count: number;
    readonly maxSizeInBytes: number;
    // @internal
    readonly partitionId?: string;
    // @internal
    readonly partitionKey?: string;
    readonly sizeInBytes: number;
    tryAdd(eventData: EventData | AmqpAnnotatedMessage, options?: TryAddOptions): boolean;
}

// @public
export class EventHubBufferedProducerClient {
    constructor(connectionString: string, options: EventHubBufferedProducerClientOptions);
    constructor(connectionString: string, eventHubName: string, options: EventHubBufferedProducerClientOptions);
    constructor(fullyQualifiedNamespace: string, eventHubName: string, credential: TokenCredential | NamedKeyCredential | SASCredential, options: EventHubBufferedProducerClientOptions);
    close(options?: BufferedCloseOptions): Promise<void>;
    enqueueEvent(event: EventData | AmqpAnnotatedMessage, options?: EnqueueEventOptions): Promise<number>;
    enqueueEvents(events: EventData[] | AmqpAnnotatedMessage[], options?: EnqueueEventOptions): Promise<number>;
    get eventHubName(): string;
    flush(options?: BufferedFlushOptions): Promise<void>;
    get fullyQualifiedNamespace(): string;
    getEventHubProperties(options?: GetEventHubPropertiesOptions): Promise<EventHubProperties>;
    getPartitionIds(options?: GetPartitionIdsOptions): Promise<Array<string>>;
    getPartitionProperties(partitionId: string, options?: GetPartitionPropertiesOptions): Promise<PartitionProperties>;
}

// @public
export interface EventHubBufferedProducerClientOptions extends EventHubClientOptions {
    enableIdempotentPartitions?: boolean;
    maxEventBufferLengthPerPartition?: number;
    maxWaitTimeInMs?: number;
    onSendEventsErrorHandler: (ctx: OnSendEventsErrorContext) => Promise<void>;
    onSendEventsSuccessHandler?: (ctx: OnSendEventsSuccessContext) => Promise<void>;
}

// @public
export interface EventHubClientOptions {
    customEndpointAddress?: string;
    retryOptions?: RetryOptions;
    userAgent?: string;
    webSocketOptions?: WebSocketOptions;
}

// @public
export interface EventHubConnectionStringProperties {
    endpoint: string;
    eventHubName?: string;
    fullyQualifiedNamespace: string;
    sharedAccessKey?: string;
    sharedAccessKeyName?: string;
    sharedAccessSignature?: string;
}

// @public
export class EventHubConsumerClient {
    constructor(consumerGroup: string, connectionString: string, options?: EventHubConsumerClientOptions);
    constructor(consumerGroup: string, connectionString: string, checkpointStore: CheckpointStore, options?: EventHubConsumerClientOptions);
    constructor(consumerGroup: string, connectionString: string, eventHubName: string, options?: EventHubConsumerClientOptions);
    constructor(consumerGroup: string, connectionString: string, eventHubName: string, checkpointStore: CheckpointStore, options?: EventHubConsumerClientOptions);
    constructor(consumerGroup: string, fullyQualifiedNamespace: string, eventHubName: string, credential: TokenCredential | NamedKeyCredential | SASCredential, options?: EventHubConsumerClientOptions);
    constructor(consumerGroup: string, fullyQualifiedNamespace: string, eventHubName: string, credential: TokenCredential | NamedKeyCredential | SASCredential, checkpointStore: CheckpointStore, options?: EventHubConsumerClientOptions);
    close(): Promise<void>;
    static defaultConsumerGroupName: string;
    get eventHubName(): string;
    get fullyQualifiedNamespace(): string;
    getEventHubProperties(options?: GetEventHubPropertiesOptions): Promise<EventHubProperties>;
    getPartitionIds(options?: GetPartitionIdsOptions): Promise<Array<string>>;
    getPartitionProperties(partitionId: string, options?: GetPartitionPropertiesOptions): Promise<PartitionProperties>;
    subscribe(handlers: SubscriptionEventHandlers, options?: SubscribeOptions): Subscription;
    subscribe(partitionId: string, handlers: SubscriptionEventHandlers, options?: SubscribeOptions): Subscription;
}

// @public
export interface EventHubConsumerClientOptions extends EventHubClientOptions {
    loadBalancingOptions?: LoadBalancingOptions;
}

// @public
export class EventHubProducerClient {
    constructor(connectionString: string, options?: EventHubClientOptions);
    constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions);
    constructor(fullyQualifiedNamespace: string, eventHubName: string, credential: TokenCredential | NamedKeyCredential | SASCredential, options?: EventHubClientOptions);
    close(): Promise<void>;
    createBatch(options?: CreateBatchOptions): Promise<EventDataBatch>;
    get eventHubName(): string;
    get fullyQualifiedNamespace(): string;
    getEventHubProperties(options?: GetEventHubPropertiesOptions): Promise<EventHubProperties>;
    getPartitionIds(options?: GetPartitionIdsOptions): Promise<Array<string>>;
    getPartitionProperties(partitionId: string, options?: GetPartitionPropertiesOptions): Promise<PartitionProperties>;
    sendBatch(batch: EventData[] | AmqpAnnotatedMessage[], options?: SendBatchOptions): Promise<void>;
    sendBatch(batch: EventDataBatch, options?: OperationOptions): Promise<void>;
}

// @public
export interface EventHubProperties {
    createdOn: Date;
    name: string;
    partitionIds: string[];
}

// @public
export interface EventPosition {
    enqueuedOn?: Date | number;
    isInclusive?: boolean;
    offset?: number | "@latest";
    sequenceNumber?: number;
}

// @public
export interface GetEventHubPropertiesOptions extends OperationOptions {
}

// @public
export interface GetPartitionIdsOptions extends OperationOptions {
}

// @public
export interface GetPartitionPropertiesOptions extends OperationOptions {
}

// @public
export interface LastEnqueuedEventProperties {
    enqueuedOn?: Date;
    offset?: string;
    retrievedOn?: Date;
    sequenceNumber?: number;
}

// @public
export const latestEventPosition: EventPosition;

// @public
export interface LoadBalancingOptions {
    partitionOwnershipExpirationIntervalInMs?: number;
    strategy?: "balanced" | "greedy";
    updateIntervalInMs?: number;
}

// @public
export const logger: AzureLogger;

// @public
export interface MessageAdapter<MessageT> {
    consume: (message: MessageT) => MessageContent;
    produce: (MessageContent: MessageContent) => MessageT;
}

// @public
export interface MessageContent {
    contentType: string;
    data: Uint8Array;
}

export { MessagingError }

// @public
export interface OnSendEventsErrorContext {
    error: Error;
    events: Array<EventData | AmqpAnnotatedMessage>;
    partitionId: string;
}

// @public
export interface OnSendEventsSuccessContext {
    events: Array<EventData | AmqpAnnotatedMessage>;
    partitionId: string;
}

// @public
export interface OperationOptions {
    abortSignal?: AbortSignalLike;
    tracingOptions?: OperationTracingOptions;
}

// @public
export function parseEventHubConnectionString(connectionString: string): Readonly<EventHubConnectionStringProperties>;

// @public
export interface PartitionContext {
    readonly consumerGroup: string;
    readonly eventHubName: string;
    readonly fullyQualifiedNamespace: string;
    readonly lastEnqueuedEventProperties?: LastEnqueuedEventProperties;
    readonly partitionId: string;
    updateCheckpoint(eventData: ReceivedEventData): Promise<void>;
}

// @public
export interface PartitionOwnership {
    consumerGroup: string;
    etag?: string;
    eventHubName: string;
    fullyQualifiedNamespace: string;
    lastModifiedTimeInMs?: number;
    ownerId: string;
    partitionId: string;
}

// @public
export interface PartitionProperties {
    beginningSequenceNumber: number;
    eventHubName: string;
    isEmpty: boolean;
    lastEnqueuedOffset: number;
    lastEnqueuedOnUtc: Date;
    lastEnqueuedSequenceNumber: number;
    partitionId: string;
}

// @public
export type ProcessCloseHandler = (reason: CloseReason, context: PartitionContext) => Promise<void>;

// @public
export type ProcessErrorHandler = (error: Error | MessagingError, context: PartitionContext) => Promise<void>;

// @public
export type ProcessEventsHandler = (events: ReceivedEventData[], context: PartitionContext) => Promise<void>;

// @public
export type ProcessInitializeHandler = (context: PartitionContext) => Promise<void>;

// @public
export interface ReceivedEventData {
    body: any;
    contentType?: string;
    correlationId?: string | number | Buffer;
    enqueuedTimeUtc: Date;
    getRawAmqpMessage(): AmqpAnnotatedMessage;
    messageId?: string | number | Buffer;
    offset: number;
    partitionKey: string | null;
    properties?: {
        [key: string]: any;
    };
    sequenceNumber: number;
    systemProperties?: {
        [key: string]: any;
    };
}

export { RetryMode }

export { RetryOptions }

// @public
export interface SendBatchOptions extends OperationOptions {
    partitionId?: string;
    partitionKey?: string;
}

// @public
export interface SubscribeOptions {
    maxBatchSize?: number;
    maxWaitTimeInSeconds?: number;
    ownerLevel?: number;
    skipParsingBodyAsJson?: boolean;
    startPosition?: EventPosition | {
        [partitionId: string]: EventPosition;
    };
    tracingOptions?: OperationTracingOptions;
    trackLastEnqueuedEventProperties?: boolean;
}

// @public
export interface Subscription {
    close(): Promise<void>;
    isRunning: boolean;
}

// @public
export interface SubscriptionEventHandlers {
    processClose?: ProcessCloseHandler;
    processError: ProcessErrorHandler;
    processEvents: ProcessEventsHandler;
    processInitialize?: ProcessInitializeHandler;
}

export { TokenCredential }

// @public
export interface TryAddOptions {
    tracingOptions?: OperationTracingOptions;
}

export { WebSocketImpl }

export { WebSocketOptions }

// (No @packageDocumentation comment for this package)

```
