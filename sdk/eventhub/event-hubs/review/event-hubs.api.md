## API Report File for "@azure/event-hubs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AadTokenProvider } from '@azure/amqp-common';
import { AbortSignalLike } from '@azure/ms-rest-js';
import { AmqpError } from 'rhea-promise';
import { ApplicationTokenCredentials } from '@azure/ms-rest-nodeauth';
import { ConnectionContextBase } from '@azure/amqp-common';
import { DataTransformer } from '@azure/amqp-common';
import { DefaultDataTransformer } from '@azure/amqp-common';
import { delay } from '@azure/amqp-common';
import { DeviceTokenCredentials } from '@azure/ms-rest-nodeauth';
import { Dictionary } from 'rhea-promise';
import { EventHubConnectionConfig } from '@azure/amqp-common';
import { MessagingError } from '@azure/amqp-common';
import { MSITokenCredentials } from '@azure/ms-rest-nodeauth';
import { OnAmqpEvent } from 'rhea-promise';
import { Receiver as Receiver_2 } from 'rhea-promise';
import { ReceiverOptions as ReceiverOptions_2 } from 'rhea-promise';
import { SasTokenProvider } from '@azure/amqp-common';
import { Sender as Sender_2 } from 'rhea-promise';
import { TokenInfo } from '@azure/amqp-common';
import { TokenProvider } from '@azure/amqp-common';
import { TokenType } from '@azure/amqp-common';
import { UserTokenCredentials } from '@azure/ms-rest-nodeauth';
import { WebSocketImpl } from 'rhea-promise';

export { AadTokenProvider }

// @public
export interface BatchingOptions {
    batchLabel?: string | null;
    // Warning: (ae-forgotten-export) The symbol "Aborter" needs to be exported by the entry point index.d.ts
    cancellationToken?: Aborter;
}

export { DataTransformer }

export { DefaultDataTransformer }

export { delay }

// @public
export interface EventData {
    body: any;
    properties?: {
        [key: string]: any;
    };
}

// @public
export class EventHubClient {
    constructor(connectionString: string, options?: EventHubClientOptions);
    constructor(host: string, eventHubPath: string, tokenProvider: TokenProvider, options?: EventHubClientOptions);
    constructor(host: string, eventHubPath: string, credentials: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | MSITokenCredentials, options?: EventHubClientOptions);
    close(): Promise<void>;
    static createFromConnectionString(connectionString: string, entityPath?: string, options?: EventHubClientOptions): EventHubClient;
    static createFromIotHubConnectionString(iothubConnectionString: string, options?: EventHubClientOptions): Promise<EventHubClient>;
    createReceiver(partitionId: string, options?: ReceiverOptions): Receiver;
    createSender(options?: SenderOptions): Sender;
    readonly eventHubName: string;
    getPartitionIds(cancellationToken?: Aborter): Promise<Array<string>>;
    getPartitionInformation(partitionId: string, cancellationToken?: Aborter): Promise<PartitionProperties>;
    getProperties(cancellationToken?: Aborter): Promise<EventHubProperties>;
}

// @public
export interface EventHubClientOptions {
    dataTransformer?: DataTransformer;
    retryOptions?: RetryOptions;
    userAgent?: string;
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
}

// @public
export interface EventHubProperties {
    createdAt: Date;
    partitionIds: string[];
    path: string;
}

// @public
export interface EventIteratorOptions {
    cancellationToken?: Aborter;
    maxWaitTimePerIteration?: number;
    preFetchCount?: number;
}

// @public
export class EventPosition {
    constructor(options?: EventPositionOptions);
    static readonly endOfStream: string;
    enqueuedTime?: Date | number;
    static fromEnqueuedTime(enqueuedTime: Date | number): EventPosition;
    static fromFirstAvailableEvent(): EventPosition;
    static fromNewEventsOnly(): EventPosition;
    static fromOffset(offset: string, isInclusive?: boolean): EventPosition;
    static fromSequenceNumber(sequenceNumber: number, isInclusive?: boolean): EventPosition;
    isInclusive: boolean;
    offset?: string;
    sequenceNumber?: number;
    static readonly startOfStream: string;
}

// @public
export interface EventPositionOptions {
    enqueuedTime?: Date | number;
    isInclusive?: boolean;
    offset?: string;
    sequenceNumber?: number;
}

export { MessagingError }

// @public
export type OnError = (error: MessagingError | Error) => void;

// @public
export type OnMessage = (eventData: ReceivedEventData) => void;

// @public
export interface PartitionProperties {
    beginningSequenceNumber: number;
    eventHubPath: string;
    id: string;
    lastEnqueuedOffset: string;
    lastEnqueuedSequenceNumber: number;
    lastEnqueuedTimeUtc: Date;
}

// @public
export interface ReceivedEventData {
    body: any;
    enqueuedTimeUtc?: Date;
    offset?: string;
    partitionKey?: string | null;
    properties?: {
        [key: string]: any;
    };
    sequenceNumber?: number;
}

// @public
export class ReceiveHandler {
    // Warning: (ae-forgotten-export) The symbol "EventHubReceiver" needs to be exported by the entry point index.d.ts
    constructor(receiver: EventHubReceiver);
    readonly consumerGroup: string | undefined;
    readonly isReceiverOpen: boolean;
    readonly partitionId: string | number | undefined;
    stop(): Promise<void>;
}

// @public
export class Receiver {
    // Warning: (ae-forgotten-export) The symbol "ConnectionContext" needs to be exported by the entry point index.d.ts
    // 
    // @internal
    constructor(context: ConnectionContext, partitionId: string, options?: ReceiverOptions);
    close(): Promise<void>;
    readonly consumerGroup: string | undefined;
    readonly exclusiveReceiverPriority: number | undefined;
    getEventIterator(options: EventIteratorOptions): AsyncIterableIterator<ReceivedEventData>;
    readonly isClosed: boolean;
    isReceivingMessages(): boolean;
    readonly partitionId: string;
    receive(onMessage: OnMessage, onError: OnError, cancellationToken?: Aborter): ReceiveHandler;
    receiveBatch(maxMessageCount: number, maxWaitTimeInSeconds?: number, cancellationToken?: Aborter): Promise<ReceivedEventData[]>;
    }

// @public
export interface ReceiverOptions {
    consumerGroup?: string;
    eventPosition?: EventPosition;
    exclusiveReceiverPriority?: number;
    retryOptions?: RetryOptions;
}

// @public
export interface RetryOptions {
    retryCount?: number;
    retryInterval?: number;
}

export { SasTokenProvider }

// @public
export class Sender {
    // @internal
    constructor(context: ConnectionContext, options?: SenderOptions);
    close(): Promise<void>;
    readonly isClosed: boolean;
    send(events: EventData[], options?: BatchingOptions): Promise<void>;
    }

// @public
export interface SenderOptions {
    partitionId?: string;
    retryOptions?: RetryOptions;
}

export { TokenInfo }

export { TokenProvider }

export { TokenType }

export { WebSocketImpl }


// (No @packageDocumentation comment for this package)

```
