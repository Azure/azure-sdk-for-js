## API Report File for "@azure/event-hubs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { AbortSignalLike } from "@azure/abort-controller";
import { AmqpError } from "rhea-promise";
import { AwaitableSender } from "rhea-promise";
import { ConnectionContextBase } from "@azure/core-amqp";
import { DataTransformer } from "@azure/core-amqp";
import { DefaultDataTransformer } from "@azure/core-amqp";
import { delay } from "@azure/core-amqp";
import { Dictionary } from "rhea-promise";
import { EventHubConnectionConfig } from "@azure/core-amqp";
import { MessagingError } from "@azure/core-amqp";
import { Receiver } from "rhea-promise";
import { ReceiverOptions } from "rhea-promise";
import { RetryOptions } from "@azure/core-amqp";
import { SharedKeyCredential } from "@azure/core-amqp";
import { TokenCredential } from "@azure/core-amqp";
import { TokenType } from "@azure/core-amqp";
import { WebSocketImpl } from "rhea-promise";

// @public
export interface BatchOptions {
  abortSignal?: AbortSignalLike;
  maxSizeInBytes?: number;
  partitionKey?: string;
}

// @public
export interface Checkpoint {
  consumerGroupName: string;
  eTag: string;
  eventHubName: string;
  offset: number;
  ownerId: string;
  partitionId: string;
  sequenceNumber: number;
}

// @public
export enum CloseReason {
  EventHubException = "EventHubException",
  OwnershipLost = "OwnershipLost",
  Shutdown = "Shutdown"
}

export { DataTransformer };

export { DefaultDataTransformer };

export { delay };

// @public
export interface EventData {
  body: any;
  properties?: {
    [key: string]: any;
  };
}

// @public
export class EventDataBatch {
  // Warning: (ae-forgotten-export) The symbol "ConnectionContext" needs to be exported by the entry point index.d.ts
  //
  // @internal
  constructor(context: ConnectionContext, maxSizeInBytes: number, partitionKey?: string);
  readonly batchMessage: Buffer | undefined;
  readonly count: number;
  readonly partitionKey: string | undefined;
  readonly sizeInBytes: number;
  tryAdd(eventData: EventData): boolean;
}

// @public
export class EventHubClient {
  constructor(connectionString: string, options?: EventHubClientOptions);
  constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions);
  constructor(
    host: string,
    eventHubName: string,
    credential: TokenCredential,
    options?: EventHubClientOptions
  );
  close(): Promise<void>;
  createConsumer(
    consumerGroup: string,
    partitionId: string,
    eventPosition: EventPosition,
    options?: EventHubConsumerOptions
  ): EventHubConsumer;
  static createFromIotHubConnectionString(
    iothubConnectionString: string,
    options?: EventHubClientOptions
  ): Promise<EventHubClient>;
  createProducer(options?: EventHubProducerOptions): EventHubProducer;
  static defaultConsumerGroupName: string;
  readonly eventHubName: string;
  getPartitionIds(abortSignal?: AbortSignalLike): Promise<Array<string>>;
  getPartitionProperties(
    partitionId: string,
    abortSignal?: AbortSignalLike
  ): Promise<PartitionProperties>;
  getProperties(abortSignal?: AbortSignalLike): Promise<EventHubProperties>;
}

// @public
export interface EventHubClientOptions {
  dataTransformer?: DataTransformer;
  retryOptions?: RetryOptions;
  userAgent?: string;
  webSocket?: WebSocketImpl;
  webSocketConstructorOptions?: any;
}

// @public
export class EventHubConsumer {
  // @internal
  constructor(
    context: ConnectionContext,
    consumerGroup: string,
    partitionId: string,
    eventPosition: EventPosition,
    options?: EventHubConsumerOptions
  );
  close(): Promise<void>;
  readonly consumerGroup: string;
  getEventIterator(options?: EventIteratorOptions): AsyncIterableIterator<ReceivedEventData>;
  readonly isClosed: boolean;
  readonly isReceivingMessages: boolean;
  readonly lastEnqueuedEventInfo: LastEnqueuedEventInfo;
  readonly ownerLevel: number | undefined;
  readonly partitionId: string;
  receive(onMessage: OnMessage, onError: OnError, abortSignal?: AbortSignalLike): ReceiveHandler;
  receiveBatch(
    maxMessageCount: number,
    maxWaitTimeInSeconds?: number,
    abortSignal?: AbortSignalLike
  ): Promise<ReceivedEventData[]>;
}

// @public
export interface EventHubConsumerOptions {
  ownerLevel?: number;
  retryOptions?: RetryOptions;
  trackLastEnqueuedEventInfo?: boolean;
}

// @public
export class EventHubProducer {
  // @internal
  constructor(context: ConnectionContext, options?: EventHubProducerOptions);
  close(): Promise<void>;
  createBatch(options?: BatchOptions): Promise<EventDataBatch>;
  readonly isClosed: boolean;
  send(eventData: EventData | EventData[] | EventDataBatch, options?: SendOptions): Promise<void>;
}

// @public
export interface EventHubProducerOptions {
  partitionId?: string;
  retryOptions?: RetryOptions;
}

// @public
export interface EventHubProperties {
  createdAt: Date;
  partitionIds: string[];
  path: string;
}

// @public
export interface EventIteratorOptions {
  abortSignal?: AbortSignalLike;
}

// @public
export class EventPosition {
  // Warning: (ae-forgotten-export) The symbol "EventPositionOptions" needs to be exported by the entry point index.d.ts
  //
  // @internal
  constructor(options?: EventPositionOptions);
  static earliest(): EventPosition;
  enqueuedTime?: Date | number;
  static fromEnqueuedTime(enqueuedTime: Date | number): EventPosition;
  static fromOffset(offset: number, isInclusive?: boolean): EventPosition;
  static fromSequenceNumber(sequenceNumber: number, isInclusive?: boolean): EventPosition;
  isInclusive: boolean;
  static latest(): EventPosition;
  offset?: number | "@latest";
  sequenceNumber?: number;
}

// @public
export class EventProcessor {
  constructor(
    consumerGroupName: string,
    eventHubClient: EventHubClient,
    PartitionProcessorClass: typeof PartitionProcessor,
    partitionManager: PartitionManager,
    options?: EventProcessorOptions
  );
  readonly id: string;
  start(): void;
  stop(): Promise<void>;
}

// @public
export interface EventProcessorOptions {
  maxBatchSize?: number;
  maxWaitTimeInSeconds?: number;
}

// @public
export class InMemoryPartitionManager implements PartitionManager {
  claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;
  listOwnership(eventHubName: string, consumerGroupName: string): Promise<PartitionOwnership[]>;
  updateCheckpoint(checkpoint: Checkpoint): Promise<string>;
}

// @public
export interface LastEnqueuedEventInfo {
  enqueuedTime?: Date;
  offset?: string;
  retrievalTime?: Date;
  sequenceNumber?: number;
}

export { MessagingError };

// @public
export type OnError = (error: MessagingError | Error) => void;

// @public
export type OnMessage = (eventData: ReceivedEventData) => void;

// @public
export class PartitionContext {
  constructor(
    eventHubName: string,
    consumerGroupName: string,
    partitionId: string,
    partitionManager: PartitionManager,
    eventProcessorId: string
  );
  readonly consumerGroupName: string;
  readonly eventHubName: string;
  readonly partitionId: string;
  updateCheckpoint(eventData: ReceivedEventData): Promise<void>;
  updateCheckpoint(sequenceNumber: number, offset: number): Promise<void>;
}

// @public
export interface PartitionManager {
  claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;
  listOwnership(eventHubName: string, consumerGroupName: string): Promise<PartitionOwnership[]>;
  updateCheckpoint(checkpoint: Checkpoint): Promise<string>;
}

// @public
export interface PartitionOwnership {
  consumerGroupName: string;
  eTag?: string;
  eventHubName: string;
  lastModifiedTimeInMS?: number;
  offset?: number;
  ownerId: string;
  ownerLevel: number;
  partitionId: string;
  sequenceNumber?: number;
}

// @public
export class PartitionProcessor {
  close(reason: CloseReason, partitionContext: PartitionContext): Promise<void>;
  initialize(partitionContext: PartitionContext): Promise<void>;
  processError(error: Error, partitionContext: PartitionContext): Promise<void>;
  processEvents(events: ReceivedEventData[], partitionContext: PartitionContext): Promise<void>;
}

// @public
export interface PartitionProperties {
  beginningSequenceNumber: number;
  eventHubName: string;
  lastEnqueuedOffset: number;
  lastEnqueuedSequenceNumber: number;
  lastEnqueuedTimeUtc: Date;
  partitionId: string;
}

// @public
export interface ReceivedEventData {
  body: any;
  enqueuedTimeUtc: Date;
  offset: number;
  partitionKey: string | null;
  properties?: {
    [key: string]: any;
  };
  sequenceNumber: number;
  systemProperties?: {
    [key: string]: any;
  };
}

// @public
export class ReceiveHandler {
  // Warning: (ae-forgotten-export) The symbol "EventHubReceiver" needs to be exported by the entry point index.d.ts
  //
  // @internal
  constructor(receiver: EventHubReceiver);
  readonly consumerGroup: string | undefined;
  readonly isReceiverOpen: boolean;
  readonly partitionId: string | undefined;
  stop(): Promise<void>;
}

export { RetryOptions };

// @public
export interface SendOptions {
  abortSignal?: AbortSignalLike;
  partitionKey?: string | null;
}

export { TokenCredential };

export { TokenType };

export { WebSocketImpl };

// (No @packageDocumentation comment for this package)
```
