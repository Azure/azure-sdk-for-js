{"version":3,"file":"eventHubBufferedProducerClient.js","sourceRoot":"","sources":["../../src/eventHubBufferedProducerClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { EventData } from \"./eventData.js\";\nimport { EventHubProducerClient } from \"./eventHubProducerClient.js\";\nimport type { OperationOptions } from \"./util/operationOptions.js\";\nimport type {\n  EventHubClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  SendBatchOptions,\n} from \"./models/public.js\";\nimport type { EventHubProperties, PartitionProperties } from \"./managementClient.js\";\nimport type { NamedKeyCredential, SASCredential, TokenCredential } from \"@azure/core-auth\";\nimport { isDefined } from \"@azure/core-util\";\nimport { isCredential } from \"./util/typeGuards.js\";\nimport type { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { delay } from \"@azure/core-amqp\";\nimport { BatchingPartitionChannel } from \"./batchingPartitionChannel.js\";\nimport { PartitionAssigner } from \"./impl/partitionAssigner.js\";\nimport { logger } from \"./logger.js\";\nimport { getRandomName } from \"./util/utils.js\";\n\n/**\n * Contains the events that were successfully sent to the Event Hub,\n * and the partition they were assigned to.\n */\nexport interface OnSendEventsSuccessContext {\n  /**\n   * The partition each event was assigned.\n   */\n  partitionId: string;\n  /**\n   * The array of {@link EventData} and/or `AmqpAnnotatedMessage` that were successfully sent to the Event Hub.\n   */\n  events: Array<EventData | AmqpAnnotatedMessage>;\n}\n\n/**\n * Contains the events that were not successfully sent to the Event Hub,\n * the partition they were assigned to, and the error that was encountered while sending.\n */\nexport interface OnSendEventsErrorContext {\n  /**\n   * The partition each event was assigned.\n   */\n  partitionId: string;\n  /**\n   * The array of {@link EventData} and/or `AmqpAnnotatedMessage` that were not successfully sent to the Event Hub.\n   */\n  events: Array<EventData | AmqpAnnotatedMessage>;\n  /**\n   * The error that occurred when sending the associated events to the Event Hub.\n   */\n  error: Error;\n}\n\n/**\n * Describes the options that can be provided while creating the `EventHubBufferedProducerClient`.\n */\nexport interface EventHubBufferedProducerClientOptions extends EventHubClientOptions {\n  /**\n   * The total number of events that can be buffered for publishing at a given time for a given partition.\n   *\n   * Default: 1500\n   */\n  maxEventBufferLengthPerPartition?: number;\n  /**\n   * The amount of time to wait for a new event to be enqueued in the buffer before publishing a partially full batch.\n   *\n   * Default: 1 second.\n   */\n  maxWaitTimeInMs?: number;\n  /**\n   * The handler to call once a batch has successfully published.\n   */\n  onSendEventsSuccessHandler?: (ctx: OnSendEventsSuccessContext) => void;\n  /**\n   * The handler to call when a batch fails to publish.\n   */\n  onSendEventsErrorHandler: (ctx: OnSendEventsErrorContext) => void;\n  /**\n   * Indicates whether or not the EventHubProducerClient should enable idempotent publishing to Event Hub partitions.\n   * If enabled, the producer will only be able to publish directly to partitions;\n   * it will not be able to publish to the Event Hubs gateway for automatic partition routing\n   * nor will it be able to use a partition key.\n   * Default: false\n   */\n  enableIdempotentRetries?: boolean;\n}\n\n/**\n * Options to configure the `flush` method on the `EventHubBufferedProducerClient`.\n */\nexport interface BufferedFlushOptions extends OperationOptions {}\n\n/**\n * Options to configure the `close` method on the `EventHubBufferedProducerClient`.\n */\nexport interface BufferedCloseOptions extends OperationOptions {\n  /**\n   * When `true`, all buffered events that are pending should be sent before closing.\n   * When `false`, abandon all buffered events and close immediately.\n   * Defaults to `true`.\n   */\n  flush?: boolean;\n}\n\n/**\n * Options to configure the `enqueueEvents` method on the `EventHubBufferedProducerClient`.\n */\nexport interface EnqueueEventOptions extends SendBatchOptions {}\n\n/**\n * The `EventHubBufferedProducerClient`is used to publish events to a specific Event Hub.\n *\n * The `EventHubBufferedProducerClient` does not publish events immediately.\n * Instead, events are buffered so they can be efficiently batched and published\n * when the batch is full or the `maxWaitTimeInMs` has elapsed with no new events\n * enqueued.\n *\n * Depending on the options specified when events are enqueued, they may be\n * automatically assigned to a partition, grouped according to the specified partition key,\n * or assigned a specifically requested partition.\n *\n * This model is intended to shift the burden of batch management from callers, at the cost of\n * non-deterministic timing, for when events will be published. There are additional trade-offs\n * to consider, as well:\n * - If the application crashes, events in the buffer will not have been published. To prevent\n *   data loss, callers are encouraged to track publishing progress using the\n *   `onSendEventsSuccessHandler` and `onSendEventsErrorHandler` handlers.\n * - Events specifying a partition key may be assigned a different partition than those using\n *   the same key with other producers.\n * - In the unlikely event that a partition becomes temporarily unavailable, the\n *   `EventHubBufferedProducerClient` may take longer to recover than other producers.\n *\n * In scenarios where it is important to have events published immediately with a deterministic\n * outcome, ensure that partition keys are assigned to a partition consistent with other\n * publishers, or where maximizing availability is a requirement, using the\n * `EventHubProducerClient` is recommended.\n */\nexport class EventHubBufferedProducerClient {\n  /**\n   * Controls the `abortSignal` passed to each `BatchingPartitionChannel`.\n   * Used to signal when a channel should stop waiting for events.\n   */\n  private _abortController = new AbortController();\n\n  /**\n   * Indicates whether the client has been explicitly closed.\n   */\n  private _isClosed: boolean = false;\n\n  /**\n   * Handles assigning partitions.\n   */\n  private _partitionAssigner = new PartitionAssigner();\n\n  /**\n   * The known partitionIds that will be used when assigning events to partitions.\n   */\n  private _partitionIds: string[] = [];\n\n  /**\n   * The EventHubProducerClient to use when creating and sending batches to the Event Hub.\n   */\n  private _producer: EventHubProducerClient;\n\n  /**\n   * Mapping of partitionIds to `BatchingPartitionChannels`.\n   * Each `BatchingPartitionChannel` handles buffering events and backpressure independently.\n   */\n  private _partitionChannels = new Map<string, BatchingPartitionChannel>();\n\n  /**\n   * The options passed by the user when creating the EventHubBufferedProducerClient instance.\n   */\n  private _clientOptions: EventHubBufferedProducerClientOptions;\n\n  /**\n   * The interval at which the background management operation should run.\n   */\n  private _backgroundManagementInterval = 10000; // 10 seconds\n\n  /**\n   * Indicates whether the background management loop is running.\n   */\n  private _isBackgroundManagementRunning = false;\n\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._producer.eventHubName;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._producer.fullyQualifiedNamespace;\n  }\n\n  /**\n   * The name used to identify this EventHubBufferedProducerClient.\n   * If not specified or empty, a random unique one will be generated.\n   */\n  public readonly identifier: string;\n\n  /**\n   * The `EventHubBufferedProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(connectionString: string, options: EventHubBufferedProducerClientOptions);\n  /**\n   * The `EventHubBufferedProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    connectionString: string,\n    eventHubName: string,\n    options: EventHubBufferedProducerClientOptions,\n  );\n  /**\n   * The `EventHubBufferedProducerClient` class is used to send events to an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options: EventHubBufferedProducerClientOptions,\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    eventHubNameOrOptions2: string | EventHubBufferedProducerClientOptions,\n    credentialOrOptions3?:\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential\n      | EventHubBufferedProducerClientOptions,\n    options4?: EventHubBufferedProducerClientOptions,\n  ) {\n    if (typeof eventHubNameOrOptions2 !== \"string\") {\n      this.identifier = eventHubNameOrOptions2.identifier ?? getRandomName();\n      this._producer = new EventHubProducerClient(fullyQualifiedNamespaceOrConnectionString1, {\n        ...eventHubNameOrOptions2,\n        identifier: this.identifier,\n      });\n      this._clientOptions = { ...eventHubNameOrOptions2 };\n    } else if (!isCredential(credentialOrOptions3)) {\n      this.identifier = credentialOrOptions3?.identifier ?? getRandomName();\n      this._producer = new EventHubProducerClient(\n        fullyQualifiedNamespaceOrConnectionString1,\n        eventHubNameOrOptions2,\n        { ...credentialOrOptions3, identifier: this.identifier },\n      );\n      this._clientOptions = { ...credentialOrOptions3! };\n    } else {\n      this.identifier = options4?.identifier ?? getRandomName();\n      this._producer = new EventHubProducerClient(\n        fullyQualifiedNamespaceOrConnectionString1,\n        eventHubNameOrOptions2,\n        credentialOrOptions3,\n        { ...options4, identifier: this.identifier },\n      );\n      this._clientOptions = { ...options4! };\n    }\n    // setting internal idempotent publishing option on the standard producer.\n    (this._producer as any)._enableIdempotentRetries = this._clientOptions.enableIdempotentRetries;\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   *\n   * This will wait for enqueued events to be flushed to the service before closing\n   * the connection.\n   * To close without flushing, set the `flush` option to `false`.\n   *\n   * @param options - The set of options to apply to the operation call.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(options: BufferedCloseOptions = {}): Promise<void> {\n    logger.verbose(\"closing buffered producer client...\");\n    if (!isDefined(options.flush) || options.flush === true) {\n      await this.flush(options);\n    }\n    // Calling abort signals to the BatchingPartitionChannels that they\n    // should stop reading/sending events, and to the background management\n    // loop that it should stop periodic partition id updates.\n    this._abortController.abort();\n    await this._producer.close();\n    this._isClosed = true;\n  }\n\n  /**\n   * Enqueues an event into the buffer to be published to the Event Hub.\n   * If there is no capacity in the buffer when this method is invoked,\n   * it will wait for space to become available and ensure that the event\n   * has been enqueued.\n   *\n   * When this call returns, the event has been accepted into the buffer,\n   * but it may not have been published yet.\n   * Publishing will take place at a nondeterministic point in the future as the buffer is processed.\n   *\n   * @param events - An {@link EventData} or `AmqpAnnotatedMessage`.\n   * @param options - A set of options that can be specified to influence the way in which\n   * the event is sent to the associated Event Hub.\n   * - `abortSignal`  : A signal used to cancel the enqueueEvent operation.\n   * - `partitionId`  : The partition this set of events will be sent to. If set, `partitionKey` can not be set.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment. If set, `partitionId` can not be set.\n   * @returns The total number of events that are currently buffered and waiting to be published, across all partitions.\n   */\n  async enqueueEvent(\n    event: EventData | AmqpAnnotatedMessage,\n    options: EnqueueEventOptions = {},\n  ): Promise<number> {\n    if (this._isClosed) {\n      throw new Error(\n        `This EventHubBufferedProducerClient has already been closed. Create a new client to enqueue events.`,\n      );\n    }\n\n    if (!this._partitionIds.length) {\n      await this._updatePartitionIds();\n    }\n    if (!this._isBackgroundManagementRunning) {\n      this._startPartitionIdsUpdateLoop().catch((e) => {\n        logger.error(\n          `The following error occured during batch creation or sending: ${JSON.stringify(\n            e,\n            undefined,\n            \"  \",\n          )}`,\n        );\n      });\n      this._isBackgroundManagementRunning = true;\n    }\n\n    const partitionId = this._partitionAssigner.assignPartition({\n      partitionId: options.partitionId,\n      partitionKey: options.partitionKey,\n    });\n\n    const partitionChannel = this._getPartitionChannel(partitionId);\n    await partitionChannel.enqueueEvent(event);\n    return this._getTotalBufferedEventsCount();\n  }\n\n  /**\n   * Enqueues events into the buffer to be published to the Event Hub.\n   * If there is no capacity in the buffer when this method is invoked,\n   * it will wait for space to become available and ensure that the events\n   * have been enqueued.\n   *\n   * When this call returns, the events have been accepted into the buffer,\n   * but it may not have been published yet.\n   * Publishing will take place at a nondeterministic point in the future as the buffer is processed.\n   *\n   * @param events - An array of {@link EventData} or `AmqpAnnotatedMessage`.\n   * @param options - A set of options that can be specified to influence the way in which\n   * events are sent to the associated Event Hub.\n   * - `abortSignal`  : A signal used to cancel the enqueueEvents operation.\n   * - `partitionId`  : The partition this set of events will be sent to. If set, `partitionKey` can not be set.\n   * - `partitionKey` : A value that is hashed to produce a partition assignment. If set, `partitionId` can not be set.\n   * @returns The total number of events that are currently buffered and waiting to be published, across all partitions.\n   */\n  async enqueueEvents(\n    events: EventData[] | AmqpAnnotatedMessage[],\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options: EnqueueEventOptions = {},\n  ): Promise<number> {\n    for (const event of events) {\n      await this.enqueueEvent(event, options);\n    }\n\n    return this._getTotalBufferedEventsCount();\n  }\n\n  /**\n   * Attempts to publish all events in the buffer immediately.\n   * This may result in multiple batches being published,\n   * the outcome of each of which will be individually reported by\n   * the `onSendEventsSuccessHandler` and `onSendEventsErrorHandler` handlers.\n   *\n   * @param options - The set of options to apply to the operation call.\n   */\n  async flush(options: BufferedFlushOptions = {}): Promise<void> {\n    await Promise.all(\n      Array.from(this._partitionChannels.values()).map((channel) => channel.flush(options)),\n    );\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubBufferedProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._producer.getEventHubProperties(options);\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubBufferedProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._producer.getPartitionIds(options);\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubBufferedProducerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {},\n  ): Promise<PartitionProperties> {\n    return this._producer.getPartitionProperties(partitionId, options);\n  }\n\n  /**\n   * Gets the `BatchingPartitionChannel` associated with the partitionId.\n   *\n   * If one does not exist, it is created.\n   */\n  private _getPartitionChannel(partitionId: string): BatchingPartitionChannel {\n    const partitionChannel =\n      this._partitionChannels.get(partitionId) ??\n      new BatchingPartitionChannel({\n        loopAbortSignal: this._abortController.signal,\n        maxBufferSize: this._clientOptions.maxEventBufferLengthPerPartition || 1500,\n        maxWaitTimeInMs: this._clientOptions.maxWaitTimeInMs || 1000,\n        onSendEventsErrorHandler: this._clientOptions.onSendEventsErrorHandler,\n        onSendEventsSuccessHandler: this._clientOptions.onSendEventsSuccessHandler,\n        partitionId,\n        producer: this._producer,\n      });\n    this._partitionChannels.set(partitionId, partitionChannel);\n    return partitionChannel;\n  }\n\n  /**\n   * Returns the total number of buffered events across all partitions.\n   */\n  private _getTotalBufferedEventsCount(): number {\n    let total = 0;\n    for (const [_, channel] of this._partitionChannels) {\n      total += channel.getCurrentBufferedCount();\n    }\n\n    return total;\n  }\n\n  private async _updatePartitionIds(): Promise<void> {\n    logger.verbose(\"Checking for partition Id updates...\");\n    const queriedPartitionIds = await this.getPartitionIds();\n\n    if (this._partitionIds.length !== queriedPartitionIds.length) {\n      logger.verbose(\"Applying partition Id updates\");\n      this._partitionIds = queriedPartitionIds;\n      this._partitionAssigner.setPartitionIds(this._partitionIds);\n    }\n  }\n\n  private async _startPartitionIdsUpdateLoop(): Promise<void> {\n    logger.verbose(\"Starting a background loop to check and apply partition id updates...\");\n    while (!this._abortController.signal.aborted && !this._isClosed) {\n      await delay<void>(this._backgroundManagementInterval);\n      if (!this._isClosed) {\n        await this._updatePartitionIds();\n      }\n    }\n  }\n}\n"]}