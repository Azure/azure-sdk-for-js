{"version":3,"file":"partitionPump.js","sourceRoot":"","sources":["../../src/partitionPump.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { TracingSpanOptions, TracingSpanLink } from \"@azure/core-tracing\";\nimport { logErrorStackTrace, logger } from \"./logger.js\";\nimport { CloseReason } from \"./models/public.js\";\nimport type { CommonEventProcessorOptions } from \"./models/private.js\";\nimport type { ConnectionContext } from \"./connectionContext.js\";\nimport type { EventHubConnectionConfig } from \"./eventhubConnectionConfig.js\";\nimport type { PartitionReceiver } from \"./partitionReceiver.js\";\nimport { createReceiver } from \"./partitionReceiver.js\";\nimport type { EventPosition } from \"./eventPosition.js\";\nimport type { MessagingError } from \"@azure/core-amqp\";\nimport type { PartitionProcessor } from \"./partitionProcessor.js\";\nimport type { ReceivedEventData } from \"./eventData.js\";\nimport { toSpanOptions, tracingClient } from \"./diagnostics/tracing.js\";\nimport { extractSpanContextFromEventData } from \"./diagnostics/instrumentEventData.js\";\n\n/**\n * @internal\n */\nexport class PartitionPump {\n  private _partitionProcessor: PartitionProcessor;\n  private _processorOptions: CommonEventProcessorOptions;\n  private _receiver: PartitionReceiver | undefined;\n  private _isReceiving: boolean = false;\n  private _isStopped: boolean = false;\n  private _abortController: AbortController;\n  constructor(\n    private _context: ConnectionContext,\n    partitionProcessor: PartitionProcessor,\n    private readonly _startPosition: EventPosition,\n    options: CommonEventProcessorOptions,\n  ) {\n    this._partitionProcessor = partitionProcessor;\n    this._processorOptions = options;\n    this._abortController = new AbortController();\n  }\n\n  public get isReceiving(): boolean {\n    return this._isReceiving;\n  }\n\n  async start(): Promise<void> {\n    this._isReceiving = true;\n    try {\n      await this._partitionProcessor.initialize();\n    } catch (err) {\n      // swallow the error from the user-defined code\n      this._partitionProcessor.processError(err as Error);\n    }\n\n    // this is intentionally not await'd - the _receiveEvents loop will continue to\n    // execute and can be stopped by calling .stop()\n    this._receiveEvents(this._partitionProcessor.partitionId);\n    logger.info(\n      `Successfully started the receiver for partition \"${this._partitionProcessor.partitionId}\".`,\n    );\n  }\n\n  /**\n   * Creates a new `PartitionReceiver` and replaces any existing receiver.\n   * @param partitionId - The partition the receiver should read messages from.\n   * @param lastSeenSequenceNumber - The sequence number to begin receiving messages from (exclusive).\n   * If `-1`, then the PartitionPump's startPosition will be used instead.\n   */\n  private _setOrReplaceReceiver(\n    partitionId: string,\n    lastSeenSequenceNumber: number,\n  ): PartitionReceiver {\n    // Determine what the new EventPosition should be.\n    // If this PartitionPump has received events, we'll start from the last\n    // seen sequenceNumber (exclusive).\n    // Otherwise, use the `_startPosition`.\n    const currentEventPosition: EventPosition =\n      lastSeenSequenceNumber >= 0\n        ? {\n            sequenceNumber: lastSeenSequenceNumber,\n            isInclusive: false,\n          }\n        : this._startPosition;\n\n    // Set or replace the PartitionPump's receiver.\n    this._receiver = createReceiver(\n      this._context,\n      this._partitionProcessor.consumerGroup,\n      this._partitionProcessor.eventProcessorId,\n      partitionId,\n      currentEventPosition,\n      {\n        ownerLevel: this._processorOptions.ownerLevel,\n        trackLastEnqueuedEventProperties: this._processorOptions.trackLastEnqueuedEventProperties,\n        retryOptions: this._processorOptions.retryOptions,\n        skipParsingBodyAsJson: this._processorOptions.skipParsingBodyAsJson,\n        prefetchCount: this._processorOptions.prefetchCount,\n      },\n    );\n\n    return this._receiver;\n  }\n\n  private async _receiveEvents(partitionId: string): Promise<void> {\n    let lastSeenSequenceNumber = -1;\n    let receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n\n    while (this._isReceiving) {\n      try {\n        // Check if the receiver was closed so we can recreate it.\n        if (receiver.isClosed) {\n          receiver = this._setOrReplaceReceiver(partitionId, lastSeenSequenceNumber);\n        }\n\n        const receivedEvents = await receiver.receiveBatch(\n          this._processorOptions.maxBatchSize,\n          this._processorOptions.maxWaitTimeInSeconds,\n          this._abortController.signal,\n        );\n\n        if (\n          this._processorOptions.trackLastEnqueuedEventProperties &&\n          receiver.lastEnqueuedEventProperties\n        ) {\n          this._partitionProcessor.lastEnqueuedEventProperties =\n            receiver.lastEnqueuedEventProperties;\n        }\n        // avoid calling user's processEvents handler if the pump was stopped while receiving events\n        if (!this._isReceiving) {\n          return;\n        }\n\n        if (receivedEvents.length) {\n          lastSeenSequenceNumber = receivedEvents[receivedEvents.length - 1].sequenceNumber;\n        }\n\n        await tracingClient.withSpan(\n          \"PartitionPump.process\",\n          {},\n          () => this._partitionProcessor.processEvents(receivedEvents),\n          toProcessingSpanOptions(receivedEvents, this._context.config),\n        );\n      } catch (err: any) {\n        // check if this pump is still receiving\n        // it may not be if the EventProcessor was stopped during processEvents\n        if (!this._isReceiving) {\n          // no longer receiving, so close was called from somewhere else\n          return;\n        }\n\n        logger.warning(\n          `An error was thrown while receiving or processing events on partition \"${this._partitionProcessor.partitionId}\"`,\n        );\n        logErrorStackTrace(err);\n        // forward error to user's processError and swallow errors they may throw\n        try {\n          await this._partitionProcessor.processError(err as Error);\n        } catch (errorFromUser) {\n          // Using verbose over warning because this error is swallowed.\n          logger.verbose(\"An error was thrown by user's processError method: \", errorFromUser);\n        }\n\n        // close the partition processor if a non-retryable error was encountered\n        if (typeof err !== \"object\" || !(err as MessagingError).retryable) {\n          try {\n            // If the exception indicates that the partition was stolen (i.e some other consumer with same ownerlevel\n            // started consuming the partition), update the closeReason\n            if (err.code === \"ReceiverDisconnectedError\") {\n              return await this.stop(CloseReason.OwnershipLost);\n            }\n            // this will close the pump and will break us out of the while loop\n            return await this.stop(CloseReason.Shutdown);\n          } catch (errorFromStop) {\n            // Using verbose over warning because this error is swallowed.\n            logger.verbose(\n              `An error occurred while closing the receiver with reason ${CloseReason.Shutdown}: `,\n              errorFromStop,\n            );\n          }\n        }\n      }\n    }\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    if (this._isStopped) {\n      return;\n    }\n    this._isStopped = true;\n    this._isReceiving = false;\n    try {\n      // Trigger the cancellation before closing the receiver,\n      // otherwise the receiver will remove the listener on the abortSignal\n      // before it has a chance to be emitted.\n      this._abortController.abort();\n      await this._receiver?.close();\n      await this._partitionProcessor.close(reason);\n    } catch (err: any) {\n      logger.warning(`An error occurred while closing the receiver: ${err?.name}: ${err?.message}`);\n      logErrorStackTrace(err);\n      this._partitionProcessor.processError(err);\n      throw err;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function toProcessingSpanOptions(\n  receivedEvents: ReceivedEventData[],\n  eventHubProperties: Pick<EventHubConnectionConfig, \"entityPath\" | \"host\">,\n): TracingSpanOptions {\n  const spanLinks: TracingSpanLink[] = [];\n  for (const receivedEvent of receivedEvents) {\n    const tracingContext = extractSpanContextFromEventData(receivedEvent);\n    if (tracingContext) {\n      spanLinks.push({\n        tracingContext,\n        attributes: {\n          enqueuedTime: receivedEvent.enqueuedTimeUtc.getTime(),\n        },\n      });\n    }\n  }\n  return {\n    spanLinks,\n    spanKind: \"consumer\",\n    ...toSpanOptions(eventHubProperties, \"process\"),\n  };\n}\n"]}