{"version":3,"file":"dataTransformer.js","sourceRoot":"","sources":["../../src/dataTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { logErrorStackTrace, logger } from \"./logger.js\";\nimport { Buffer } from \"buffer\";\nimport isBuffer from \"is-buffer\";\nimport { message } from \"rhea-promise\";\n\n/**\n * The allowed AMQP message body types.\n * @internal\n */\nexport type BodyTypes = \"data\" | \"value\" | \"sequence\";\n\n/** @internal */\nexport const dataSectionTypeCode = 0x75 as const;\n/** @internal */\nexport const sequenceSectionTypeCode = 0x76 as const;\n/** @internal */\nexport const valueSectionTypeCode = 0x77 as const;\n\n/**\n * The default data transformer that will be used by the Azure SDK.\n * @internal\n */\nexport const defaultDataTransformer = {\n  /**\n   * A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   *\n   * @param body - The AMQP message body\n   * @param bodyType - The AMQP section to story the body in.\n   * @returns The encoded AMQP message body as an AMQP Data/Sequence/Value section.\n   */\n  encode(body: unknown, bodyType: BodyTypes): any {\n    let result: any;\n    // string, undefined, null, boolean, array, object, number should end up here\n    // coercing undefined to null as that will ensure that null value will be given to the\n    // customer on receive.\n    if (body === undefined) body = null;\n\n    if (bodyType === \"value\") {\n      // TODO: Expose value_section from `rhea` similar to the data_section and sequence_section.\n      // Right now there isn't a way to create a value section officially.\n      result = message.data_section(body);\n      result.typecode = valueSectionTypeCode;\n    } else if (bodyType === \"sequence\") {\n      result = message.sequence_section(body);\n    } else if (isBuffer(body) || body instanceof Uint8Array) {\n      result = message.data_section(body);\n    } else if (body === null && bodyType === \"data\") {\n      result = message.data_section(null);\n    } else {\n      try {\n        const bodyStr = JSON.stringify(body);\n        result = message.data_section(Buffer.from(bodyStr, \"utf8\"));\n      } catch (err: any) {\n        const msg =\n          `An error occurred while executing JSON.stringify() on the given body ` +\n          body +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        logger.warning(\"[encode] \" + msg);\n        logErrorStackTrace(err);\n        throw new Error(msg);\n      }\n    }\n    return result;\n  },\n\n  /**\n   * A function that takes the body property from an AMQP message, which can come from either\n   * the 'data', 'value' or 'sequence' sections of an AMQP message.\n   *\n   * If the body is not a JSON string the the raw contents will be returned, along with the bodyType\n   * indicating which part of the AMQP message the body was decoded from.\n   *\n   * @param body - The AMQP message body as received from rhea.\n   * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body when body type is `content`.\n   * @returns The decoded/raw body and the body type.\n   */\n  decode(\n    body: unknown | RheaAmqpSection,\n    skipParsingBodyAsJson: boolean,\n  ): { body: unknown; bodyType: BodyTypes } {\n    try {\n      if (isRheaAmqpSection(body)) {\n        switch (body.typecode) {\n          case dataSectionTypeCode:\n            return {\n              body: skipParsingBodyAsJson ? body.content : tryToJsonDecode(body.content),\n              bodyType: \"data\",\n            };\n          case sequenceSectionTypeCode:\n            return { body: body.content, bodyType: \"sequence\" };\n          case valueSectionTypeCode:\n            return { body: body.content, bodyType: \"value\" };\n        }\n      } else {\n        if (isBuffer(body)) {\n          return { body: skipParsingBodyAsJson ? body : tryToJsonDecode(body), bodyType: \"data\" };\n        }\n\n        return { body, bodyType: \"value\" };\n      }\n    } catch (err: any) {\n      logger.verbose(\n        \"[decode] An error occurred while decoding the received message body. The error is: %O\",\n        err,\n      );\n      throw err;\n    }\n  },\n};\n\n/**\n * Attempts to decode 'body' as a JSON string. If it fails it returns body\n * verbatim.\n *\n * @param body - An AMQP message body.\n * @returns A JSON decoded object, or body if body was not a JSON string.\n *\n * @internal\n */\nfunction tryToJsonDecode(body: unknown): unknown {\n  let processedBody: any = body;\n  try {\n    // Trying to stringify and JSON.parse() anything else will fail flat and we shall return\n    // the original type back\n    const bodyStr: string = processedBody.toString(\"utf8\");\n    processedBody = JSON.parse(bodyStr);\n  } catch (err: any) {\n    logger.verbose(\n      \"[decode] An error occurred while trying JSON.parse() on the received body. The error is %O\",\n      err,\n    );\n  }\n  return processedBody;\n}\n\n/**\n * Mirror of the internal Section interface in rhea.\n *\n * @internal\n */\nexport interface RheaAmqpSection {\n  typecode:\n    | typeof dataSectionTypeCode\n    | typeof sequenceSectionTypeCode\n    | typeof valueSectionTypeCode;\n  content: any;\n}\n\n/** @internal */\nexport function isRheaAmqpSection(\n  possibleSection: any | RheaAmqpSection,\n): possibleSection is RheaAmqpSection {\n  return (\n    possibleSection != null &&\n    typeof possibleSection.typecode === \"number\" &&\n    (possibleSection.typecode === dataSectionTypeCode ||\n      possibleSection.typecode === valueSectionTypeCode ||\n      possibleSection.typecode === sequenceSectionTypeCode)\n  );\n}\n"]}