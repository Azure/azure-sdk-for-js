{"version":3,"file":"eventHubConsumerClient.js","sourceRoot":"","sources":["../../src/eventHubConsumerClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { CheckpointStore, FullEventProcessorOptions } from \"./eventProcessor.js\";\nimport { EventProcessor } from \"./eventProcessor.js\";\nimport type { ConnectionContext } from \"./connectionContext.js\";\nimport { createConnectionContext } from \"./connectionContext.js\";\nimport type {\n  EventHubConsumerClientOptions,\n  GetEventHubPropertiesOptions,\n  GetPartitionIdsOptions,\n  GetPartitionPropertiesOptions,\n  LoadBalancingOptions,\n} from \"./models/public.js\";\nimport type { EventHubProperties, PartitionProperties } from \"./managementClient.js\";\nimport type { NamedKeyCredential, SASCredential, TokenCredential } from \"@azure/core-auth\";\nimport type {\n  SubscribeOptions,\n  Subscription,\n  SubscriptionEventHandlers,\n} from \"./eventHubConsumerClientModels.js\";\nimport { BalancedLoadBalancingStrategy } from \"./loadBalancerStrategies/balancedStrategy.js\";\nimport { Constants } from \"@azure/core-amqp\";\nimport { GreedyLoadBalancingStrategy } from \"./loadBalancerStrategies/greedyStrategy.js\";\nimport { InMemoryCheckpointStore } from \"./inMemoryCheckpointStore.js\";\nimport type { LoadBalancingStrategy } from \"./loadBalancerStrategies/loadBalancingStrategy.js\";\nimport { PartitionGate } from \"./impl/partitionGate.js\";\nimport { UnbalancedLoadBalancingStrategy } from \"./loadBalancerStrategies/unbalancedStrategy.js\";\nimport { isCredential } from \"./util/typeGuards.js\";\nimport { logger } from \"./logger.js\";\nimport { validateEventPositions } from \"./eventPosition.js\";\nimport { getRandomName } from \"./util/utils.js\";\n\nconst defaultConsumerClientOptions: Required<\n  Pick<FullEventProcessorOptions, \"maxWaitTimeInSeconds\" | \"maxBatchSize\">\n> = {\n  // to support our current \"process single event only\" workflow we'll also purposefully\n  // only request a single event at a time.\n  maxBatchSize: 1,\n  maxWaitTimeInSeconds: 60,\n};\n\n/**\n * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n *\n * There are multiple ways to create an `EventHubConsumerClient`\n * - Use the connection string from the SAS policy created for your Event Hub instance.\n * - Use the connection string from the SAS policy created for your Event Hub namespace,\n * and the name of the Event Hub instance\n * - Use the full namespace like `<yournamespace>.servicebus.windows.net`, and a credentials object.\n *\n * Optionally, you can also pass:\n * - An options bag to configure the retry policy or proxy settings.\n * - A checkpoint store that is used by the client to read checkpoints to determine the position from where it should\n * resume receiving events when your application gets restarted. The checkpoint store is also used by the client\n * to load balance multiple instances of your application.\n */\nexport class EventHubConsumerClient {\n  /**\n   * Describes the amqp connection context for the client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The options passed by the user when creating the EventHubClient instance.\n   */\n  private _clientOptions: EventHubConsumerClientOptions;\n  private _partitionGate = new PartitionGate();\n\n  /**\n   * The Subscriptions that were spawned by calling `subscribe()`.\n   * Subscriptions that have been stopped by the user will not\n   * be present in this set.\n   */\n  private _subscriptions = new Set<Subscription>();\n\n  /**\n   * The name of the default consumer group in the Event Hubs service.\n   */\n  static defaultConsumerGroupName: string = Constants.defaultConsumerGroup;\n\n  private _checkpointStore: CheckpointStore;\n  private _userChoseCheckpointStore: boolean;\n\n  /**\n   * Options for configuring load balancing.\n   */\n  private readonly _loadBalancingOptions: Required<LoadBalancingOptions>;\n\n  /**\n   * @readonly\n   * The name of the Event Hub instance for which this client is created.\n   */\n  get eventHubName(): string {\n    return this._context.config.entityPath;\n  }\n\n  /**\n   * @readonly\n   * The fully qualified namespace of the Event Hub instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  get fullyQualifiedNamespace(): string {\n    return this._context.config.host;\n  }\n\n  /**\n   * The name used to identify this EventHubConsumerClient.\n   * If not specified or empty, a random unique one will be generated.\n   */\n  public readonly identifier: string;\n\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    options?: EventHubConsumerClientOptions,\n  ); // #1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hub instance.\n   * It is expected that the shared key properties and the Event Hub path are contained in this connection string.\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;EntityPath=my-event-hub-name'.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions,\n  ); // #1.1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    options?: EventHubConsumerClientOptions,\n  ); // #2\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param connectionString - The connection string to use for connecting to the Event Hubs namespace.\n   * It is expected that the shared key properties are contained in this connection string, but not the Event Hub path,\n   * e.g. 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key;'.\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    connectionString: string,\n    eventHubName: string,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions,\n  ); // #2.1\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options?: EventHubConsumerClientOptions,\n  ); // #3\n  /**\n   * The `EventHubConsumerClient` class is used to consume events from an Event Hub.\n   * Use the `options` parmeter to configure retry policy or proxy settings.\n   * @param consumerGroup - The name of the consumer group from which you want to process events.\n   * @param fullyQualifiedNamespace - The full namespace which is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   * @param eventHubName - The name of the specific Event Hub to connect the client to.\n   * @param credential - An credential object used by the client to get the token to authenticate the connection\n   * with the Azure Event Hubs service.\n   * See &commat;azure/identity for creating credentials that support AAD auth.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param checkpointStore - A checkpoint store that is used by the client to read checkpoints to determine\n   * the position from where it should resume receiving events when your application gets restarted.\n   * It is also used by the client to load balance multiple instances of your application.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   * - `userAgent`      : A string to append to the built in user agent string that is passed to the service.\n   */\n  constructor(\n    consumerGroup: string,\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    checkpointStore: CheckpointStore,\n    options?: EventHubConsumerClientOptions,\n  ); // #3.1\n  constructor(\n    private _consumerGroup: string,\n    connectionStringOrFullyQualifiedNamespace2: string,\n    checkpointStoreOrEventHubNameOrOptions3?:\n      | CheckpointStore\n      | EventHubConsumerClientOptions\n      | string,\n    checkpointStoreOrCredentialOrOptions4?:\n      | CheckpointStore\n      | EventHubConsumerClientOptions\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential,\n    checkpointStoreOrOptions5?: CheckpointStore | EventHubConsumerClientOptions,\n    options6?: EventHubConsumerClientOptions,\n  ) {\n    if (isCredential(checkpointStoreOrCredentialOrOptions4)) {\n      // #3 or 3.1\n      logger.info(\"Creating EventHubConsumerClient with TokenCredential.\");\n\n      if (isCheckpointStore(checkpointStoreOrOptions5)) {\n        // 3.1\n        this._checkpointStore = checkpointStoreOrOptions5;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions = options6 || {};\n      } else {\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions = checkpointStoreOrOptions5 || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3 as string,\n        checkpointStoreOrCredentialOrOptions4,\n        this._clientOptions,\n      );\n    } else if (typeof checkpointStoreOrEventHubNameOrOptions3 === \"string\") {\n      // #2 or 2.1\n      logger.info(\"Creating EventHubConsumerClient with connection string and event hub name.\");\n\n      if (isCheckpointStore(checkpointStoreOrCredentialOrOptions4)) {\n        // 2.1\n        this._checkpointStore = checkpointStoreOrCredentialOrOptions4;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions = (checkpointStoreOrOptions5 as EventHubConsumerClientOptions) || {};\n      } else {\n        // 2\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions = checkpointStoreOrCredentialOrOptions4 || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        checkpointStoreOrEventHubNameOrOptions3,\n        this._clientOptions,\n      );\n    } else {\n      // #1 or 1.1\n      logger.info(\"Creating EventHubConsumerClient with connection string.\");\n\n      if (isCheckpointStore(checkpointStoreOrEventHubNameOrOptions3)) {\n        // 1.1\n        this._checkpointStore = checkpointStoreOrEventHubNameOrOptions3;\n        this._userChoseCheckpointStore = true;\n        this._clientOptions =\n          (checkpointStoreOrCredentialOrOptions4 as EventHubConsumerClientOptions) || {};\n      } else {\n        // 1\n        this._checkpointStore = new InMemoryCheckpointStore();\n        this._userChoseCheckpointStore = false;\n        this._clientOptions =\n          (checkpointStoreOrEventHubNameOrOptions3 as EventHubConsumerClientOptions) || {};\n      }\n\n      this._context = createConnectionContext(\n        connectionStringOrFullyQualifiedNamespace2,\n        this._clientOptions,\n      );\n    }\n    this.identifier = this._clientOptions.identifier ?? getRandomName();\n    this._loadBalancingOptions = {\n      // default options\n      strategy: \"balanced\",\n      updateIntervalInMs: 10000,\n      partitionOwnershipExpirationIntervalInMs: 60000,\n      // options supplied by user\n      ...this._clientOptions?.loadBalancingOptions,\n    };\n  }\n\n  /**\n   * Closes the AMQP connection to the Event Hub instance,\n   * returning a promise that will be resolved when disconnection is completed.\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  async close(): Promise<void> {\n    // Stop all the actively running subscriptions.\n    const activeSubscriptions = Array.from(this._subscriptions);\n    await Promise.all(\n      activeSubscriptions.map((subscription) => {\n        return subscription.close();\n      }),\n    );\n    // Close the connection via the connection context.\n    return this._context.close();\n  }\n\n  /**\n   * Provides the id for each partition associated with the Event Hub.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with an Array of strings representing the id for\n   * each partition associated with the Event Hub.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionIds(options: GetPartitionIdsOptions = {}): Promise<Array<string>> {\n    return this._context\n      .managementSession!.getEventHubProperties({\n        ...options,\n        retryOptions: this._clientOptions.retryOptions,\n      })\n      .then((eventHubProperties) => {\n        return eventHubProperties.partitionIds;\n      });\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The id of the partition for which information is required.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the state of the partition .\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getPartitionProperties(\n    partitionId: string,\n    options: GetPartitionPropertiesOptions = {},\n  ): Promise<PartitionProperties> {\n    return this._context.managementSession!.getPartitionProperties(partitionId, {\n      ...options,\n      retryOptions: this._clientOptions.retryOptions,\n    });\n  }\n\n  /**\n   * Provides the Event Hub runtime information.\n   * @param options - The set of options to apply to the operation call.\n   * @returns A promise that resolves with information about the Event Hub instance.\n   * @throws Error if the underlying connection has been closed, create a new EventHubConsumerClient.\n   * @throws AbortError if the operation is cancelled via the abortSignal.\n   */\n  getEventHubProperties(options: GetEventHubPropertiesOptions = {}): Promise<EventHubProperties> {\n    return this._context.managementSession!.getEventHubProperties({\n      ...options,\n      retryOptions: this._clientOptions.retryOptions,\n    });\n  }\n\n  /**\n   * Subscribe to events from all partitions.\n   *\n   * If checkpoint store is provided to the `EventHubConsumerClient` and there are multiple\n   * instances of your application, then each instance will subscribe to a subset of the\n   * partitions such that the load is balanced amongst them.\n   *\n   * Call close() on the returned object to stop receiving events.\n   *\n   * Example usage:\n   * ```ts snippet:EventHubConsumerClient_Subscribe\n   * import { EventHubConsumerClient, earliestEventPosition } from \"@azure/event-hubs\";\n   *\n   * const client = new EventHubConsumerClient(\"my-consumer-group\", \"connectionString\", \"eventHubName\");\n   *\n   * const subscription = client.subscribe(\n   *   {\n   *     processEvents: async (events, context) => {\n   *       console.log(\"Received event count: \", events.length);\n   *     },\n   *     processError: async (err, context) => {\n   *       console.log(\"Error: \", err);\n   *     },\n   *   },\n   *   { startPosition: earliestEventPosition },\n   * );\n   * ```\n   *\n   * @param handlers - Handlers for the lifecycle of the subscription - subscription initialization\n   *                 per partition, receiving events, handling errors and the closing\n   *                 of a subscription per partition.\n   * @param options - Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }`\n   */\n  subscribe(handlers: SubscriptionEventHandlers, options?: SubscribeOptions): Subscription; // #1\n  /**\n   * Subscribe to events from a single partition.\n   * Call close() on the returned object to stop receiving events.\n   *\n   * Example usage:\n   * ```ts snippet:EventHubConsumerClient_SubscribeSinglePartition\n   * import { EventHubConsumerClient, earliestEventPosition } from \"@azure/event-hubs\";\n   *\n   * const client = new EventHubConsumerClient(\"my-consumer-group\", \"connectionString\", \"eventHubName\");\n   *\n   * const partitionIds = await client.getPartitionIds();\n   *\n   * const subscription = client.subscribe(\n   *   partitionIds[0],\n   *   {\n   *     processEvents: async (events, context) => {\n   *       console.log(\"Received event count: \", events.length);\n   *     },\n   *     processError: async (err, context) => {\n   *       console.log(\"Error: \", err);\n   *     },\n   *   },\n   *   { startPosition: earliestEventPosition },\n   * );\n   * ```\n   *\n   * @param partitionId - The id of the partition to subscribe to.\n   * @param handlers - Handlers for the lifecycle of the subscription - subscription initialization\n   *                 of the partition, receiving events, handling errors and the closing\n   *                 of a subscription to the partition.\n   * @param options - Configures the way events are received.\n   * Most common are `maxBatchSize` and `maxWaitTimeInSeconds` that control the flow of\n   * events to the handler provided to receive events as well as the start position. For example,\n   * `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }`\n   */\n\n  subscribe(\n    partitionId: string,\n    handlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions,\n  ): Subscription; // #2\n  subscribe(\n    handlersOrPartitionId1?: SubscriptionEventHandlers | string,\n    optionsOrHandlers2?: SubscribeOptions | SubscriptionEventHandlers,\n    possibleOptions3?: SubscribeOptions,\n  ): Subscription {\n    let eventProcessor: EventProcessor;\n    let targetedPartitionId: string;\n\n    if (isSubscriptionEventHandlers(handlersOrPartitionId1)) {\n      // #1: subscribe overload - read from all partitions\n      const options = optionsOrHandlers2 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForAllPartitions(\n        handlersOrPartitionId1,\n        options,\n      ));\n    } else if (isSubscriptionEventHandlers(optionsOrHandlers2)) {\n      // #2: subscribe overload (read from specific partition IDs), don't coordinate\n      const options = possibleOptions3 as SubscribeOptions | undefined;\n      if (options && options.startPosition) {\n        validateEventPositions(options.startPosition);\n      }\n      ({ targetedPartitionId, eventProcessor } = this.createEventProcessorForSinglePartition(\n        // cast to string as downstream code expects partitionId to be string, but JS users could have given us anything.\n        // we don't validate the user input and instead rely on service throwing errors if any\n        String(handlersOrPartitionId1),\n        optionsOrHandlers2,\n        possibleOptions3,\n      ));\n    } else {\n      throw new TypeError(\"Unhandled subscribe() overload\");\n    }\n\n    eventProcessor.start();\n\n    const subscription = {\n      get isRunning() {\n        return eventProcessor.isRunning();\n      },\n      close: () => {\n        this._partitionGate.remove(targetedPartitionId);\n        this._subscriptions.delete(subscription);\n        return eventProcessor.stop();\n      },\n    };\n    this._subscriptions.add(subscription);\n    return subscription;\n  }\n\n  /**\n   * Gets the LoadBalancing strategy that should be used based on what the user provided.\n   */\n  private _getLoadBalancingStrategy(): LoadBalancingStrategy {\n    if (!this._userChoseCheckpointStore) {\n      // The default behavior when a checkpointstore isn't provided\n      // is to always grab all the partitions.\n      return new UnbalancedLoadBalancingStrategy();\n    }\n\n    const partitionOwnershipExpirationIntervalInMs =\n      this._loadBalancingOptions.partitionOwnershipExpirationIntervalInMs;\n    if (this._loadBalancingOptions?.strategy === \"greedy\") {\n      return new GreedyLoadBalancingStrategy(partitionOwnershipExpirationIntervalInMs);\n    }\n\n    // The default behavior when a checkpointstore is provided is\n    // to grab one partition at a time.\n    return new BalancedLoadBalancingStrategy(partitionOwnershipExpirationIntervalInMs);\n  }\n\n  private createEventProcessorForAllPartitions(\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions,\n  ): { targetedPartitionId: string; eventProcessor: EventProcessor } {\n    this._partitionGate.add(\"all\");\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        \"EventHubConsumerClient subscribing to all partitions, using a checkpoint store.\",\n      );\n    } else {\n      logger.verbose(\"EventHubConsumerClient subscribing to all partitions, no checkpoint store.\");\n    }\n\n    const loadBalancingStrategy = this._getLoadBalancingStrategy();\n    const eventProcessor = this._createEventProcessor(\n      this._context,\n      subscriptionEventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...(options as SubscribeOptions),\n        ownerLevel: getOwnerLevel(options, this._userChoseCheckpointStore),\n        // make it so all the event processors process work with the same overarching owner ID\n        // this allows the EventHubConsumer to unify all the work for any processors that it spawns\n        ownerId: this.identifier,\n        retryOptions: this._clientOptions.retryOptions,\n        loadBalancingStrategy,\n        loopIntervalInMs: this._loadBalancingOptions.updateIntervalInMs,\n      },\n    );\n\n    return { targetedPartitionId: \"all\", eventProcessor };\n  }\n\n  private createEventProcessorForSinglePartition(\n    partitionId: string,\n    eventHandlers: SubscriptionEventHandlers,\n    options?: SubscribeOptions,\n  ): { targetedPartitionId: string; eventProcessor: EventProcessor } {\n    this._partitionGate.add(partitionId);\n\n    const subscribeOptions = options as SubscribeOptions | undefined;\n\n    if (this._userChoseCheckpointStore) {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), using a checkpoint store.`,\n      );\n    } else {\n      logger.verbose(\n        `EventHubConsumerClient subscribing to specific partition (${partitionId}), no checkpoint store.`,\n      );\n    }\n\n    const eventProcessor = this._createEventProcessor(\n      this._context,\n      eventHandlers,\n      this._checkpointStore,\n      {\n        ...defaultConsumerClientOptions,\n        ...options,\n        processingTarget: partitionId,\n        ownerLevel: getOwnerLevel(subscribeOptions, this._userChoseCheckpointStore),\n        retryOptions: this._clientOptions.retryOptions,\n        loadBalancingStrategy: new UnbalancedLoadBalancingStrategy(),\n        loopIntervalInMs: this._loadBalancingOptions.updateIntervalInMs ?? 10000,\n      },\n    );\n\n    return { targetedPartitionId: partitionId, eventProcessor };\n  }\n\n  private _createEventProcessor(\n    connectionContext: ConnectionContext,\n    subscriptionEventHandlers: SubscriptionEventHandlers,\n    checkpointStore: CheckpointStore,\n    options: FullEventProcessorOptions,\n  ): EventProcessor {\n    return new EventProcessor(\n      this._consumerGroup,\n      connectionContext,\n      subscriptionEventHandlers,\n      checkpointStore,\n      options,\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport function isCheckpointStore(possible: CheckpointStore | any): possible is CheckpointStore {\n  if (!possible) {\n    return false;\n  }\n\n  const checkpointStore = possible as CheckpointStore;\n\n  return (\n    typeof checkpointStore.claimOwnership === \"function\" &&\n    typeof checkpointStore.listCheckpoints === \"function\" &&\n    typeof checkpointStore.listOwnership === \"function\" &&\n    typeof checkpointStore.updateCheckpoint === \"function\"\n  );\n}\n\n/**\n * @internal\n */\nfunction isSubscriptionEventHandlers(\n  possible: any | SubscriptionEventHandlers,\n): possible is SubscriptionEventHandlers {\n  return typeof (possible as SubscriptionEventHandlers).processEvents === \"function\";\n}\n\nfunction getOwnerLevel(\n  options: SubscribeOptions | undefined,\n  userChoseCheckpointStore: boolean,\n): number | undefined {\n  if (options && options.ownerLevel) {\n    return options.ownerLevel;\n  }\n\n  if (userChoseCheckpointStore) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n"]}