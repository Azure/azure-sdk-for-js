{"version":3,"file":"loadBalancingStrategy.js","sourceRoot":"","sources":["../../../src/loadBalancerStrategies/loadBalancingStrategy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PartitionOwnership } from \"../eventProcessor.js\";\nimport { logger } from \"../logger.js\";\n\n/**\n * Determines which partitions to claim as part of load balancing.\n * @internal\n */\nexport interface LoadBalancingStrategy {\n  /**\n   * Implements load balancing by taking into account current ownership and\n   * the full set of partitions in the Event Hub.\n   * @param ourOwnerId - The id we should assume is _our_ id when checking for ownership.\n   * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n   * @param partitionIds - Partitions to assign owners to.\n   * @returns Partition ids to claim.\n   */\n  getPartitionsToClaim(\n    ownerId: string,\n    claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n    partitionIds: string[],\n  ): string[];\n}\n\n/**\n * Counts of the EventProcessors that currently own partitions.\n * @internal\n */\ninterface EventProcessorCounts {\n  /**\n   * The # of EventProcessors that only own the required # of\n   * partitions.\n   */\n  haveRequiredPartitions: number;\n  /**\n   * The # of EventProcessors that currently own the required #\n   * of partitions + 1 additional (ie, handling the case where\n   * the number of partitions is not evenly divisible by the # of\n   * EventProcessors).\n   */\n  haveAdditionalPartition: number;\n  /**\n   * EventProcessors which have more than the required or even required + 1\n   * number of partitions. These will eventually be downsized by other\n   * EventProcessors as they acquire their required number of partitions.\n   */\n  haveTooManyPartitions: number;\n}\n\n/**\n * This method will create a new map of partition id and PartitionOwnership containing only those partitions\n * that are actively owned.\n * All entries in the original map that haven't been modified for a duration of time greater than the allowed\n * inactivity time limit are assumed to be owned by dead event processors.\n * These will not be included in the map returned by this method.\n *\n * @param partitionOwnershipMap - The existing PartitionOwnerships mapped by partition.\n * @param expirationIntervalInMs - The length of time a PartitionOwnership claim is valid.\n */\nfunction getActivePartitionOwnerships(\n  partitionOwnershipMap: Map<string, PartitionOwnership>,\n  expirationIntervalInMs: number,\n): Map<string, PartitionOwnership> {\n  const activePartitionOwnershipMap: Map<string, PartitionOwnership> = new Map();\n  partitionOwnershipMap.forEach((partitionOwnership: PartitionOwnership, partitionId: string) => {\n    // If lastModifiedtimeInMs is missing, assume it is inactive.\n    if (\n      typeof partitionOwnership.lastModifiedTimeInMs === \"undefined\" ||\n      partitionOwnership.lastModifiedTimeInMs === null\n    ) {\n      return;\n    }\n\n    const timeSincePartitionClaimed = Date.now() - partitionOwnership.lastModifiedTimeInMs;\n    if (timeSincePartitionClaimed < expirationIntervalInMs && partitionOwnership.ownerId) {\n      activePartitionOwnershipMap.set(partitionId, partitionOwnership);\n    }\n  });\n\n  return activePartitionOwnershipMap;\n}\n\n/**\n * Calculates the minimum number of partitions each EventProcessor should own,\n * and the number of EventProcessors that should have an extra partition assigned.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @param partitionIds - The full list of the Event Hub's partition ids.\n * @internal\n */\nfunction calculateBalancedLoadCounts(\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>,\n  partitionIds: string[],\n): { minPartitionsPerOwner: number; requiredNumberOfOwnersWithExtraPartition: number } {\n  // Calculate the minimum number of partitions every EventProcessor should own when the load\n  // is evenly distributed.\n  const minPartitionsPerOwner = Math.floor(partitionIds.length / ownerToOwnershipMap.size);\n\n  // If the number of partitions in the Event Hub is not evenly divisible by the number of active\n  // EventProcesrrors, some EventProcessors may own 1 partition in addition to the minimum when the\n  // load is balanced.\n  // Calculate the number of EventProcessors that can own an additional partition.\n  const requiredNumberOfOwnersWithExtraPartition = partitionIds.length % ownerToOwnershipMap.size;\n\n  return {\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n  };\n}\n\n/**\n * Counts the EventProcessors and tallies them by type.\n *\n * To be in balance we need to make sure that each EventProcessor is only consuming\n * their fair share.\n *\n * When the partitions are divvied up we will sometimes end up with some EventProcessors\n * that will have 1 more partition than others.\n * This can happen if the number of partitions is not evenly divisible by the number of EventProcessors.\n *\n * So this function largely exists to support isLoadBalanced() and\n * shouldOwnMorePartitions(), both of which depend on knowing if our current list\n * of EventProcessors is actually in the proper state.\n *\n * @param minPartitionsPerOwner - The number of required partitions per EventProcessor.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @internal\n */\nfunction getEventProcessorCounts(\n  minPartitionsPerOwner: number,\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>,\n): EventProcessorCounts {\n  const counts: EventProcessorCounts = {\n    haveRequiredPartitions: 0,\n    haveAdditionalPartition: 0,\n    haveTooManyPartitions: 0,\n  };\n\n  for (const ownershipList of ownerToOwnershipMap.values()) {\n    const numberOfPartitions = ownershipList.length;\n\n    // there are basically three kinds of partition counts\n    // for a processor:\n\n    if (numberOfPartitions === minPartitionsPerOwner) {\n      // 1. Has _exactly_ the required number of partitions\n      counts.haveRequiredPartitions++;\n    } else if (numberOfPartitions === minPartitionsPerOwner + 1) {\n      // 2. Has the required number plus one extra (correct in cases)\n      // where the # of partitions is not evenly divisible by the\n      // number of processors.\n      counts.haveAdditionalPartition++;\n    } else if (numberOfPartitions > minPartitionsPerOwner + 1) {\n      // 3. has more than the possible # of partitions required\n      counts.haveTooManyPartitions++;\n    }\n  }\n\n  return counts;\n}\n\n/**\n * Validates that we are currently in a balanced state - all EventProcessors own the\n * minimum required number of partitions (and additional partitions, if the # of partitions\n * is not evenly divisible by the # of EventProcessors).\n *\n * @param requiredNumberOfOwnersWithExtraPartition - The # of EventProcessors that process an additional partition, in addition to the required minimum.\n * @param totalExpectedProcessors - The total # of EventProcessors we expect.\n * @param eventProcessorCounts - EventProcessor counts, grouped by criteria.\n * @internal\n */\nfunction isLoadBalanced(\n  requiredNumberOfOwnersWithExtraPartition: number,\n  totalExpectedEventProcessors: number,\n  { haveAdditionalPartition, haveRequiredPartitions }: EventProcessorCounts,\n): boolean {\n  return (\n    haveAdditionalPartition === requiredNumberOfOwnersWithExtraPartition &&\n    haveRequiredPartitions + haveAdditionalPartition === totalExpectedEventProcessors\n  );\n}\n\n/**\n * Determines the number of new partitions to claim for this particular processor.\n *\n * @param minRequired - The minimum required number of partitions.\n * @param requiredNumberOfOwnersWithExtraPartition - The current number of processors that should have an additional partition.\n * @param numPartitionsOwnedByUs - The number of partitions we currently own.\n * @param eventProcessorCounts - Processors, grouped by criteria.\n * @internal\n */\nfunction getNumberOfPartitionsToClaim(\n  minRequiredPartitionCount: number,\n  requiredNumberOfOwnersWithExtraPartition: number,\n  numPartitionsOwnedByUs: number,\n  { haveAdditionalPartition, haveTooManyPartitions }: EventProcessorCounts,\n): number {\n  let actualRequiredPartitionCount = minRequiredPartitionCount;\n\n  if (\n    requiredNumberOfOwnersWithExtraPartition > 0 &&\n    // Eventually the `haveTooManyPartitions` will decay into `haveAdditionalPartition`\n    // EventProcessors as partitions are balanced to consumers that aren't at par.\n    // We can consider them to be `haveAdditionalPartition` EventProcessors for our purposes.\n    haveAdditionalPartition + haveTooManyPartitions < requiredNumberOfOwnersWithExtraPartition\n  ) {\n    // Overall we don't have enough EventProcessors that are taking on an additional partition\n    // so we should attempt to.\n    actualRequiredPartitionCount = minRequiredPartitionCount + 1;\n  }\n  return actualRequiredPartitionCount - numPartitionsOwnedByUs;\n}\n\n/**\n * Determines which partitions can be stolen from other owners while maintaining\n * a balanced state.\n * @param numberOfPartitionsToClaim - The number of partitions the owner needs to claim to reach a balanced state.\n * @param minPartitionsPerOwner - The minimum number of partitions each owner needs for the partition load to be balanced.\n * @param requiredNumberOfOwnersWithExtraPartition - The number of owners that should have 1 extra partition.\n * @param ourOwnerId - The id of _our_ owner.\n * @param ownerToOwnershipMap - The current ownerships for partitions.\n * @internal\n */\nfunction findPartitionsToSteal(\n  numberOfPartitionsToClaim: number,\n  minPartitionsPerOwner: number,\n  requiredNumberOfOwnersWithExtraPartition: number,\n  ourOwnerId: string,\n  ownerToOwnershipMap: Map<string, PartitionOwnership[]>,\n): string[] {\n  const partitionsToSteal: string[] = [];\n  // Create a list of PartitionOwnership lists that we can steal from.\n  const listOfPartitionOwnerships: Array<PartitionOwnership[]> = [];\n  ownerToOwnershipMap.forEach((partitionOwnerships, ownerId) => {\n    if (ownerId === ourOwnerId || partitionOwnerships.length <= minPartitionsPerOwner) return;\n    listOfPartitionOwnerships.push(partitionOwnerships);\n  });\n\n  // Sort the list in descending order based on the length of each element.\n  listOfPartitionOwnerships.sort((a, b) => {\n    if (a.length > b.length) return -1;\n    if (a.length < b.length) return 1;\n    return 0;\n  });\n\n  // Attempt to steal partitions from EventProcessors that have the most partitions 1st,\n  // then work our way down.\n  let ownersEncounteredWithExtraPartitions = 0;\n  let currentPartitionOwnershipList = listOfPartitionOwnerships.shift();\n  while (numberOfPartitionsToClaim > 0 && currentPartitionOwnershipList) {\n    let ownersExpectedPartitionCount = minPartitionsPerOwner;\n    // Determine if the current owner should be allowed to have an extra partition.\n    if (ownersEncounteredWithExtraPartitions < requiredNumberOfOwnersWithExtraPartition) {\n      ownersExpectedPartitionCount++;\n    }\n    ownersEncounteredWithExtraPartitions++;\n\n    let numberAvailableToSteal =\n      currentPartitionOwnershipList.length - ownersExpectedPartitionCount;\n    // Claim as many random partitions as possible.\n    while (Math.min(numberOfPartitionsToClaim, numberAvailableToSteal)) {\n      const indexToClaim = Math.floor(Math.random() * currentPartitionOwnershipList.length);\n      partitionsToSteal.push(currentPartitionOwnershipList.splice(indexToClaim, 1)[0].partitionId);\n      numberOfPartitionsToClaim--;\n      numberAvailableToSteal--;\n    }\n\n    // Move on to the next list of PartitionOwnership.\n    currentPartitionOwnershipList = listOfPartitionOwnerships.shift();\n  }\n\n  return partitionsToSteal;\n}\n\n/**\n * Identifies all of the partitions that can be claimed by the specified owner for\n * that owner to reach a balanced state.\n * @param OwnerId - The id we should assume is _our_ id when checking for ownership.\n * @param claimedPartitionOwnershipMap - The current claimed ownerships for partitions.\n * @param partitionIds - Partitions to assign owners to.\n * @param expirationIntervalInMs - The length of time a partition claim is valid.\n * @returns Partition ids that may be claimed.\n * @internal\n */\nexport function listAvailablePartitions(\n  ownerId: string,\n  claimedPartitionOwnershipMap: Map<string, PartitionOwnership>,\n  partitionIds: string[],\n  expirationIntervalInMs: number,\n): string[] {\n  if (!partitionIds.length) {\n    return [];\n  }\n\n  // Collect only the PartitionOwnership that have been updated within the expiration interval.\n  // Any PartitionOwnership that has been updated outside the expiration interval can be claimed.\n  const activePartitionOwnershipMap = getActivePartitionOwnerships(\n    claimedPartitionOwnershipMap,\n    expirationIntervalInMs,\n  );\n  logger.verbose(\n    `[${ownerId}] Number of active ownership records: ${activePartitionOwnershipMap.size}.`,\n  );\n\n  if (activePartitionOwnershipMap.size === 0) {\n    // All partitions in this Event Hub are available to claim.\n    return partitionIds;\n  }\n\n  // Map ownerIds to the partitions they own so that we can determine how many each owner has.\n  const ownerToOwnershipMap = new Map<string, PartitionOwnership[]>();\n  for (const activeOwnership of activePartitionOwnershipMap.values()) {\n    const partitionOwnershipList = ownerToOwnershipMap.get(activeOwnership.ownerId) || [];\n\n    partitionOwnershipList.push(activeOwnership);\n    ownerToOwnershipMap.set(activeOwnership.ownerId, partitionOwnershipList);\n  }\n\n  // Add the current EventProcessor to the map of owners to ownerships if it doesn't exist.\n  if (!ownerToOwnershipMap.has(ownerId)) {\n    ownerToOwnershipMap.set(ownerId, []);\n  }\n\n  logger.info(`[${ownerId}] Number of active event processors: ${ownerToOwnershipMap.size}.`);\n\n  const { minPartitionsPerOwner, requiredNumberOfOwnersWithExtraPartition } =\n    calculateBalancedLoadCounts(ownerToOwnershipMap, partitionIds);\n\n  logger.verbose(\n    `[${ownerId}] Expected minimum number of partitions per event processor: ${minPartitionsPerOwner},` +\n      `expected number of event processors with additional partition: ${requiredNumberOfOwnersWithExtraPartition}.`,\n  );\n\n  // Get some stats representing the current state the world with regards to how balanced the\n  // partitions are across EventProcessors.\n  const eventProcessorCounts = getEventProcessorCounts(minPartitionsPerOwner, ownerToOwnershipMap);\n\n  if (\n    isLoadBalanced(\n      requiredNumberOfOwnersWithExtraPartition,\n      ownerToOwnershipMap.size,\n      eventProcessorCounts,\n    )\n  ) {\n    // When the partitions are evenly distributed, no change required.\n    return [];\n  }\n\n  let numberOfPartitionsToClaim = getNumberOfPartitionsToClaim(\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n    ownerToOwnershipMap.get(ownerId)!.length,\n    eventProcessorCounts,\n  );\n\n  if (numberOfPartitionsToClaim <= 0) {\n    return [];\n  }\n\n  const partitionsToClaim: string[] = [];\n  const unclaimedPartitionIds = partitionIds.filter((id) => !activePartitionOwnershipMap.has(id));\n\n  // Prioritize getting unclaimed partitions first.\n  while (Math.min(numberOfPartitionsToClaim, unclaimedPartitionIds.length)) {\n    const indexToClaim = Math.floor(Math.random() * unclaimedPartitionIds.length);\n    partitionsToClaim.push(unclaimedPartitionIds.splice(indexToClaim, 1)[0]);\n    numberOfPartitionsToClaim--;\n  }\n\n  if (numberOfPartitionsToClaim === 0) {\n    return partitionsToClaim;\n  }\n\n  // Find partitions that can be stolen from other EventProcessors.\n  const partitionsToSteal = findPartitionsToSteal(\n    numberOfPartitionsToClaim,\n    minPartitionsPerOwner,\n    requiredNumberOfOwnersWithExtraPartition,\n    ownerId,\n    ownerToOwnershipMap,\n  );\n\n  return partitionsToClaim.concat(partitionsToSteal);\n}\n"]}