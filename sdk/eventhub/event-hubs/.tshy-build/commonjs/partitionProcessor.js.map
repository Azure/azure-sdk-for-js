{"version":3,"file":"partitionProcessor.js","sourceRoot":"","sources":["../../src/partitionProcessor.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAWlC,2CAAqC;AAyCrC;;;;;;;;;GASG;AACH,MAAa,kBAAkB;IAG7B,YACU,cAAyC,EACzC,gBAAiC,EACjC,QAEP;QAJO,mBAAc,GAAd,cAAc,CAA2B;QACzC,qBAAgB,GAAhB,gBAAgB,CAAiB;QACjC,aAAQ,GAAR,QAAQ,CAEf;IACA,CAAC;IAEJ;;;;;OAKG;IACH,IAAW,2BAA2B;QACpC,OAAO,IAAI,CAAC,4BAA6B,CAAC;IAC5C,CAAC;IAED;;;;OAIG;IACH,IAAW,2BAA2B,CAAC,UAAuC;QAC5E,IAAI,CAAC,4BAA4B,GAAG,UAAU,CAAC;IACjD,CAAC;IAED;;;OAGG;IACH,IAAW,uBAAuB;QAChC,OAAO,IAAI,CAAC,QAAQ,CAAC,uBAAuB,CAAC;IAC/C,CAAC;IAED;;;OAGG;IACH,IAAW,aAAa;QACtB,OAAO,IAAI,CAAC,QAAQ,CAAC,aAAc,CAAC;IACtC,CAAC;IAED;;;OAGG;IACH,IAAW,YAAY;QACrB,OAAO,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;IACpC,CAAC;IAED;;;OAGG;IACH,IAAW,WAAW;QACpB,OAAO,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;IACnC,CAAC;IAED;;OAEG;IACH,IAAW,gBAAgB;QACzB,OAAO,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC;IACxC,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU;;QACd,OAAO,MAAA,MAAA,IAAI,CAAC,cAAc,EAAC,iBAAiB,mDAAG,IAAI,CAAC,CAAC;IACvD,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,KAAK,CAAC,MAAmB;QAC7B,IAAI,IAAI,CAAC,cAAc,CAAC,YAAY,EAAE,CAAC;YACrC,MAAM,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QACvD,CAAC;IACH,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,aAAa,CAAC,MAA2B;QAC7C,MAAM,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IACxD,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,YAAY,CAAC,KAAY;QAC7B,IAAI,IAAI,CAAC,cAAc,CAAC,YAAY,EAAE,CAAC;YACrC,IAAI,CAAC;gBACH,MAAM,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;YACtD,CAAC;YAAC,OAAO,GAAQ,EAAE,CAAC;gBAClB,kBAAM,CAAC,OAAO,CAAC,mDAAmD,GAAG,EAAE,CAAC,CAAC;YAC3E,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;;;;OAOG;IACI,KAAK,CAAC,gBAAgB,CAAC,SAA4B;QACxD,MAAM,UAAU,GAAe;YAC7B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,uBAAuB;YAC9D,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;YACxC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,aAAa;YAC1C,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,WAAW;YACtC,cAAc,EAAE,SAAS,CAAC,cAAc;YACxC,MAAM,EAAE,SAAS,CAAC,MAAM;SACzB,CAAC;QAEF,MAAM,IAAI,CAAC,gBAAiB,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;IAC5D,CAAC;CACF;AAtID,gDAsIC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  BasicPartitionProperties,\n  PartitionContext,\n  SubscriptionEventHandlers,\n} from \"./eventHubConsumerClientModels.js\";\nimport type { CheckpointStore } from \"./eventProcessor.js\";\nimport type { CloseReason } from \"./models/public.js\";\nimport type { LastEnqueuedEventProperties } from \"./partitionReceiver.js\";\nimport type { ReceivedEventData } from \"./eventData.js\";\nimport { logger } from \"./logger.js\";\n\n/**\n * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n * partition of a consumer group in an Event Hub instance.\n *\n * When the `updateCheckpoint()` method on the `PartitionProcessor` class is called by the user, a\n * `Checkpoint` is created internally. It is then stored in the storage solution implemented by the\n * `CheckpointManager` chosen by the user when creating an `EventProcessor`.\n *\n * Users are never expected to interact with `Checkpoint` directly. This interface exists to support the\n * internal workings of `EventProcessor` and `CheckpointManager`.\n **/\nexport interface Checkpoint {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The event hub name\n   */\n  eventHubName: string;\n  /**\n   * The consumer group name\n   */\n  consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition\n   */\n  partitionId: string;\n  /**\n   * The sequence number of the event\n   */\n  sequenceNumber: number;\n  /**\n   * The offset of the event.\n   */\n  offset: string;\n}\n\n/**\n * The `PartitionProcessor` is responsible for processing events received from Event Hubs when using `EventProcessor`\n *\n * The EventProcessor creates a new instance of the PartitionProcessor for each partition of the event hub it starts processing. When you extend the `PartitionProcessor` in order to customize it as you see fit,\n * - Override the `processEvents()` method to add the code to process the received events. This is also a good place to update the checkpoints using the `updateCheckpoint()` method\n * - Optionally override the `processError()` method to handle any error that might have occurred when processing the events.\n * - Optionally override the `initialize()` method to implement any set up related tasks you would want to carry out before starting to receive events from the partition\n * - Optionally override the `close()` method to implement any tear down or clean up tasks you would want to carry out.\n * @internal\n */\nexport class PartitionProcessor implements PartitionContext {\n  private _lastEnqueuedEventProperties?: LastEnqueuedEventProperties;\n\n  constructor(\n    private _eventHandlers: SubscriptionEventHandlers,\n    private _checkpointStore: CheckpointStore,\n    private _context: BasicPartitionProperties & {\n      eventProcessorId: string;\n    },\n  ) {}\n\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   * @readonly\n   */\n  public get lastEnqueuedEventProperties(): LastEnqueuedEventProperties {\n    return this._lastEnqueuedEventProperties!;\n  }\n\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is updated by the `EventProcessor` if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor\n   */\n  public set lastEnqueuedEventProperties(properties: LastEnqueuedEventProperties) {\n    this._lastEnqueuedEventProperties = properties;\n  }\n\n  /**\n   * The fully qualified namespace from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get fullyQualifiedNamespace(): string {\n    return this._context.fullyQualifiedNamespace;\n  }\n\n  /**\n   * The name of the consumer group from where the current partition is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get consumerGroup(): string {\n    return this._context.consumerGroup!;\n  }\n\n  /**\n   * The name of the event hub to which the current partition belongs. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get eventHubName(): string {\n    return this._context.eventHubName;\n  }\n\n  /**\n   * The identifier of the Event Hub partition that is being processed. It is set by the `EventProcessor`\n   * @readonly\n   */\n  public get partitionId(): string {\n    return this._context.partitionId;\n  }\n\n  /**\n   * The unique identifier of the `EventProcessor` that has spawned the current instance of `PartitionProcessor`. This is set by the `EventProcessor`\n   */\n  public get eventProcessorId(): string {\n    return this._context.eventProcessorId;\n  }\n\n  /**\n   * This method is called when the `EventProcessor` takes ownership of a new partition and before any\n   * events are received.\n   */\n  async initialize(): Promise<void> {\n    return this._eventHandlers.processInitialize?.(this);\n  }\n\n  /**\n   * This method is called before the partition processor is closed by the EventProcessor.\n   *\n   * @param reason - The reason for closing this partition processor.\n   */\n  async close(reason: CloseReason): Promise<void> {\n    if (this._eventHandlers.processClose) {\n      await this._eventHandlers.processClose(reason, this);\n    }\n  }\n\n  /**\n   * This method is called when new events are received.\n   *\n   * This is also a good place to update checkpoints as appropriate.\n   *\n   * @param event - The received events to be processed.\n   */\n  async processEvents(events: ReceivedEventData[]): Promise<void> {\n    await this._eventHandlers.processEvents(events, this);\n  }\n\n  /**\n   * This method is called when an error occurs while receiving events from Event Hubs.\n   *\n   * @param error - The error to be processed.\n   */\n  async processError(error: Error): Promise<void> {\n    if (this._eventHandlers.processError) {\n      try {\n        await this._eventHandlers.processError(error, this);\n      } catch (err: any) {\n        logger.verbose(`Error thrown from user's processError handler : ${err}`);\n      }\n    }\n  }\n\n  /**\n   * Updates the checkpoint using the event data.\n   *\n   * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n   * partition of a consumer group in an Event Hub instance.\n   *\n   * @param eventData - The event that you want to update the checkpoint with.\n   */\n  public async updateCheckpoint(eventData: ReceivedEventData): Promise<void> {\n    const checkpoint: Checkpoint = {\n      fullyQualifiedNamespace: this._context.fullyQualifiedNamespace,\n      eventHubName: this._context.eventHubName,\n      consumerGroup: this._context.consumerGroup,\n      partitionId: this._context.partitionId,\n      sequenceNumber: eventData.sequenceNumber,\n      offset: eventData.offset,\n    };\n\n    await this._checkpointStore!.updateCheckpoint(checkpoint);\n  }\n}\n"]}