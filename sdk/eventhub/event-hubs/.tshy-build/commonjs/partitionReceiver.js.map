{"version":3,"file":"partitionReceiver.js","sourceRoot":"","sources":["../../src/partitionReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport type { MessagingError, RetryConfig } from \"@azure/core-amqp\";\nimport {\n  Constants,\n  RetryOperationType,\n  StandardAbortMessage,\n  retry,\n  translate,\n} from \"@azure/core-amqp\";\nimport type {\n  EventContext,\n  Receiver as Link,\n  ReceiverOptions as RheaReceiverOptions,\n  Source,\n} from \"rhea-promise\";\nimport { types } from \"rhea-promise\";\nimport type { EventDataInternal, ReceivedEventData } from \"./eventData.js\";\nimport { fromRheaMessage } from \"./eventData.js\";\nimport type { EventPosition } from \"./eventPosition.js\";\nimport { getEventPositionFilter } from \"./eventPosition.js\";\nimport type { SimpleLogger } from \"./logger.js\";\nimport {\n  createSimpleLogger,\n  logErrorStackTrace,\n  logObj,\n  logger as azureLogger,\n  createReceiverLogPrefix,\n} from \"./logger.js\";\nimport type { ConnectionContext } from \"./connectionContext.js\";\nimport type { PartitionReceiverOptions } from \"./models/private.js\";\nimport { getRetryAttemptTimeoutInMs } from \"./util/retries.js\";\nimport { createAbortablePromise } from \"@azure/core-util\";\nimport type { TimerLoop } from \"./util/timerLoop.js\";\nimport { getRandomName } from \"./util/utils.js\";\nimport { withAuth } from \"./withAuth.js\";\nimport { geoReplication, receiverIdPropertyName } from \"./util/constants.js\";\n\ntype Writable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n/** @internal */\nexport type WritableReceiver = Writable<PartitionReceiver>;\n\nconst abortLogMessage = \"operation has been cancelled by the user\";\n/** The time to wait in ms before attempting to read from the queue */\nconst qReadIntervalInMs = 20;\n\n/**\n * A set of information about the last enqueued event of a partition, as observed by the consumer as\n * events are received from the Event Hubs service\n */\nexport interface LastEnqueuedEventProperties {\n  /**\n   * The sequence number of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  sequenceNumber?: number;\n  /**\n   * The date and time, in UTC, that the last event was enqueued into the Event Hub partition from\n   * which this event was received.\n   */\n  enqueuedOn?: Date;\n  /**\n   * The offset of the event that was last enqueued into the Event Hub partition from which\n   * this event was received.\n   */\n  offset?: string;\n  /**\n   * The date and time, in UTC, that the last event was retrieved from the Event Hub partition.\n   */\n  retrievedOn?: Date;\n}\n\n/** @internal */\nexport interface PartitionReceiver {\n  readonly checkpoint: number;\n  readonly lastEnqueuedEventProperties: LastEnqueuedEventProperties;\n  readonly isClosed: boolean;\n  readonly close: () => Promise<void>;\n  readonly abort: () => Promise<void>;\n  readonly isOpen: () => boolean;\n  readonly receiveBatch: (\n    maxMessageCount: number,\n    maxWaitTimeInSeconds?: number,\n    abortSignal?: AbortSignalLike,\n  ) => Promise<ReceivedEventData[]>;\n  /** Needed for tests only */\n  readonly _onError?: (error: MessagingError | Error) => void;\n  readonly connect: (options: ConnectOptions) => Promise<void>;\n}\n\ninterface ConnectOptions {\n  abortSignal: AbortSignalLike | undefined;\n  timeoutInMs: number;\n}\n\ninterface ReceiverState {\n  link?: Link;\n  authLoop?: TimerLoop;\n  isConnecting: boolean;\n}\n\n/** @internal */\nexport function createReceiver(\n  ctx: ConnectionContext,\n  consumerGroup: string,\n  consumerId: string,\n  partitionId: string,\n  eventPosition: EventPosition,\n  options: PartitionReceiverOptions = {},\n): PartitionReceiver {\n  const address = ctx.config.getReceiverAddress(partitionId, consumerGroup);\n  const name = getRandomName(address);\n  const audience = ctx.config.getReceiverAudience(partitionId, consumerGroup);\n  const logPrefix = createReceiverLogPrefix(consumerId, ctx.connectionId, partitionId);\n  const logger = createSimpleLogger(azureLogger, logPrefix);\n  const queue: ReceivedEventData[] = [];\n  const state: ReceiverState = {\n    isConnecting: false,\n  };\n\n  const obj: WritableReceiver = {\n    _onError: undefined,\n    checkpoint: -1,\n    lastEnqueuedEventProperties: {},\n    isClosed: false,\n    close: async () => {\n      clearHandlers(obj);\n      delete ctx.receivers[name];\n      logger.verbose(\"deleted the receiver from the client cache\");\n      state.authLoop?.stop();\n      return state.link\n        ?.close()\n        .catch((err) => {\n          logger.warning(`an error occurred while closing: ${err?.name}: ${err?.message}`);\n          logErrorStackTrace(err);\n          throw err;\n        })\n        .finally(() => {\n          obj.isClosed = true;\n          logger.verbose(\"is closed\");\n          state.link = undefined;\n          state.authLoop = undefined;\n        });\n    },\n    abort: () => {\n      obj._onError?.(new AbortError(StandardAbortMessage));\n      logger.info(abortLogMessage);\n      return obj.close();\n    },\n    isOpen: () => {\n      const isOpen = !!state.link?.isOpen();\n      logger.verbose(`is open? -> ${isOpen}`);\n      return isOpen;\n    },\n    async connect({ abortSignal, timeoutInMs }: ConnectOptions): Promise<void> {\n      if (state.isConnecting || obj.isOpen()) {\n        return;\n      }\n      state.isConnecting = true;\n      logger.verbose(\"is trying to connect\");\n      try {\n        await ctx.readyToOpenLink({ abortSignal });\n        state.authLoop = await withAuth(\n          () =>\n            setupLink(\n              consumerId,\n              ctx,\n              name,\n              address,\n              obj,\n              state,\n              queue,\n              eventPosition,\n              logger,\n              options,\n              abortSignal,\n            ),\n          ctx,\n          audience,\n          timeoutInMs,\n          logger,\n          {\n            abortSignal,\n          },\n        );\n      } catch (err) {\n        state.isConnecting = false;\n        const error = translate(err);\n        logger.error(\n          `an error occurred while creating the receiver: ${error?.name}: ${error?.message}`,\n        );\n        logErrorStackTrace(err);\n        throw error;\n      }\n    },\n    receiveBatch: (\n      maxMessageCount: number,\n      maxWaitTimeInSeconds: number = 60,\n      abortSignal?: AbortSignalLike,\n    ) => {\n      const prefetchCount = options.prefetchCount ?? maxMessageCount * 3;\n      const cleanupBeforeAbort = (): Promise<void> => {\n        logger.info(abortLogMessage);\n        return obj.close();\n      };\n      const retrieveEvents = (): Promise<ReceivedEventData[]> => {\n        const eventsToRetrieveCount = Math.max(maxMessageCount - queue.length, 0);\n        logger.verbose(\n          `already has ${queue.length} events and wants to receive ${eventsToRetrieveCount} more events`,\n        );\n        if (abortSignal?.aborted) {\n          cleanupBeforeAbort();\n          return Promise.reject(new AbortError(StandardAbortMessage));\n        }\n        return obj.isClosed || ctx.wasConnectionCloseCalled || eventsToRetrieveCount === 0\n          ? Promise.resolve(queue.splice(0, maxMessageCount))\n          : new Promise<void>((resolve, reject) => {\n              obj._onError = reject;\n              obj // eslint-disable-line promise/catch-or-return\n                .connect({\n                  abortSignal,\n                  timeoutInMs: getRetryAttemptTimeoutInMs(options.retryOptions),\n                })\n                .then(() => {\n                  addCredits(state.link, Math.max(prefetchCount, maxMessageCount) - queue.length);\n                  logger.verbose(`setting the max wait time to ${maxWaitTimeInSeconds} seconds`);\n                  return waitForEvents(\n                    maxMessageCount,\n                    maxWaitTimeInSeconds * 1000,\n                    qReadIntervalInMs,\n                    queue,\n                    {\n                      abortSignal,\n                      cleanupBeforeAbort,\n                      receivedAfterWait: () =>\n                        logger.info(\n                          `${Math.min(\n                            maxMessageCount,\n                            queue.length,\n                          )} messages received within ${maxWaitTimeInSeconds} seconds`,\n                        ),\n                      receivedAlready: () =>\n                        logger.info(`${maxMessageCount} messages already received`),\n                      receivedNone: () =>\n                        logger.info(\n                          `no messages received when max wait time in seconds ${maxWaitTimeInSeconds} is over`,\n                        ),\n                    },\n                  );\n                })\n                .catch(reject)\n                .then(resolve);\n            })\n              .then(() => queue.splice(0, maxMessageCount))\n              .finally(() => clearHandlers(obj));\n      };\n      return retry(\n        Object.defineProperties(\n          {\n            operation: retrieveEvents,\n            operationType: RetryOperationType.receiveMessage,\n            abortSignal: abortSignal,\n            retryOptions: options.retryOptions ?? {},\n          },\n          {\n            connectionId: {\n              enumerable: true,\n              get: () => ctx.connectionId,\n            },\n            connectionHost: {\n              enumerable: true,\n              get: () => ctx.config.host,\n            },\n          },\n        ) as RetryConfig<ReceivedEventData[]>,\n      );\n    },\n  };\n  return obj;\n}\n\nfunction delay(\n  waitTimeInMs: number,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    abortErrorMsg?: string;\n  },\n): Promise<void> {\n  let token: ReturnType<typeof setTimeout>;\n  return createAbortablePromise<void>((resolve) => {\n    token = setTimeout(resolve, waitTimeInMs);\n  }, options).finally(() => clearTimeout(token));\n}\n\n/**\n * @internal\n */\nexport function checkOnInterval(\n  waitTimeInMs: number,\n  check: () => boolean,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    abortErrorMsg?: string;\n  },\n): Promise<void> {\n  let token: ReturnType<typeof setInterval>;\n  return createAbortablePromise<void>((resolve) => {\n    token = setInterval(() => {\n      if (check()) {\n        resolve();\n      }\n    }, waitTimeInMs);\n  }, options).finally(() => clearInterval(token));\n}\n\n/**\n * Returns a promise that will resolve when it is time to read from the queue\n * @param maxEventCount - The maximum number of events to receive.\n * @param maxWaitTimeInMs - The maximum time to wait in ms for the queue to contain any events.\n * @param readIntervalWaitTimeInMs - The time interval to wait in ms before checking the queue.\n * @param queue - The queue to read from.\n * @param options - The options bag.\n * @returns a promise that will resolve when it is time to read from the queue\n * @internal\n */\nexport function waitForEvents(\n  maxEventCount: number,\n  maxWaitTimeInMs: number,\n  readIntervalWaitTimeInMs: number,\n  queue: unknown[],\n  options: {\n    abortSignal?: AbortSignalLike;\n    cleanupBeforeAbort?: () => void;\n    receivedAfterWait?: () => void;\n    receivedAlready?: () => void;\n    receivedNone?: () => void;\n  } = {},\n): Promise<void> {\n  const {\n    abortSignal: clientAbortSignal,\n    cleanupBeforeAbort,\n    receivedNone,\n    receivedAfterWait,\n    receivedAlready,\n  } = options;\n\n  if (queue.length >= maxEventCount) {\n    return Promise.resolve().then(receivedAlready);\n  }\n\n  const aborter = new AbortController();\n  const abortListener = () => {\n    aborter.abort();\n  };\n  clientAbortSignal?.addEventListener(\"abort\", abortListener);\n  let cleanupBeforeAbortCalled = false;\n\n  const updatedOptions = {\n    abortSignal: aborter.signal,\n    abortErrorMsg: StandardAbortMessage,\n    cleanupBeforeAbort: () => {\n      if (clientAbortSignal?.aborted && !cleanupBeforeAbortCalled) {\n        cleanupBeforeAbort?.();\n        cleanupBeforeAbortCalled = true;\n      }\n    },\n  };\n  return Promise.race([\n    checkOnInterval(readIntervalWaitTimeInMs, () => queue.length > 0, updatedOptions)\n      .then(() => delay(readIntervalWaitTimeInMs, updatedOptions))\n      .then(receivedAfterWait),\n    delay(maxWaitTimeInMs, updatedOptions).then(receivedNone),\n  ]).finally(() => {\n    aborter.abort();\n    clientAbortSignal?.removeEventListener(\"abort\", abortListener);\n  });\n}\n\nfunction convertAMQPMesage(data: EventDataInternal): ReceivedEventData {\n  const rawMessage = data.getRawAmqpMessage();\n  const receivedEventData: ReceivedEventData = {\n    body: data.body,\n    properties: data.properties,\n    offset: data.offset!,\n    sequenceNumber: data.sequenceNumber!,\n    enqueuedTimeUtc: data.enqueuedTimeUtc!,\n    partitionKey: data.partitionKey!,\n    systemProperties: data.systemProperties,\n    getRawAmqpMessage() {\n      return rawMessage;\n    },\n  };\n  if (data.correlationId != null) {\n    receivedEventData.correlationId = data.correlationId;\n  }\n  if (data.contentType != null) {\n    receivedEventData.contentType = data.contentType;\n  }\n  if (data.messageId != null) {\n    receivedEventData.messageId = data.messageId;\n  }\n  return receivedEventData;\n}\n\nfunction setEventProps(eventProps: LastEnqueuedEventProperties, data: EventDataInternal): void {\n  eventProps.sequenceNumber = data.lastSequenceNumber;\n  eventProps.enqueuedOn = data.lastEnqueuedTime;\n  eventProps.offset = data.lastEnqueuedOffset;\n  eventProps.retrievedOn = data.retrievalTime;\n}\n\nfunction clearHandlers(obj: WritableReceiver): void {\n  obj._onError = undefined;\n}\n\nfunction onMessage(\n  context: EventContext,\n  obj: WritableReceiver,\n  queue: ReceivedEventData[],\n  options: PartitionReceiverOptions,\n): void {\n  if (!context.message) {\n    return;\n  }\n  const data = fromRheaMessage(context.message, !!options.skipParsingBodyAsJson);\n  const receivedEventData = convertAMQPMesage(data);\n  obj.checkpoint = receivedEventData.sequenceNumber;\n  if (options.trackLastEnqueuedEventProperties) {\n    setEventProps(obj.lastEnqueuedEventProperties, data);\n  }\n  queue.push(receivedEventData);\n}\n\nfunction onError(\n  context: EventContext,\n  obj: PartitionReceiver,\n  receiver: Link | undefined,\n  logger: SimpleLogger,\n): void {\n  const rheaReceiver = receiver || context.receiver;\n  const amqpError = rheaReceiver?.error;\n  logger.verbose(`'receiver_error' event occurred: ${logObj(amqpError)}`);\n  if (obj._onError && amqpError) {\n    const error = translate(amqpError);\n    logErrorStackTrace(error);\n    obj._onError(error);\n  }\n}\n\nfunction onSessionError(context: EventContext, obj: PartitionReceiver, logger: SimpleLogger): void {\n  const sessionError = context.session?.error;\n  logger.verbose(`'session_error' event occurred: ${logObj(sessionError)}`);\n  if (obj._onError && sessionError) {\n    const error = translate(sessionError);\n    logErrorStackTrace(error);\n    obj._onError(error);\n  }\n}\n\nasync function onClose(\n  context: EventContext,\n  state: ReceiverState,\n  logger: SimpleLogger,\n): Promise<void> {\n  const rheaReceiver = state.link || context.receiver;\n  logger.verbose(\n    `'receiver_close' event occurred. Value for isItselfClosed on the receiver is: '${rheaReceiver\n      ?.isItselfClosed()\n      .toString()}' Value for isConnecting on the session is: '${state.isConnecting}'`,\n  );\n  if (rheaReceiver && !state.isConnecting) {\n    return rheaReceiver.close().catch((err) => {\n      logger.verbose(`error when closing after 'receiver_close' event: ${logObj(err)}`);\n    });\n  }\n}\n\nasync function onSessionClose(\n  context: EventContext,\n  state: ReceiverState,\n  logger: SimpleLogger,\n): Promise<void> {\n  const rheaReceiver = state.link || context.receiver;\n  logger.verbose(\n    `'session_close' event occurred. Value for isSessionItselfClosed on the session is: '${rheaReceiver\n      ?.isSessionItselfClosed()\n      .toString()}' Value for isConnecting on the session is: '${state.isConnecting}'`,\n  );\n  if (rheaReceiver && !state.isConnecting) {\n    return rheaReceiver.close().catch((err) => {\n      logger.verbose(`error when closing after 'session_close' event: ${logObj(err)}`);\n    });\n  }\n}\n\nfunction createRheaOptions(\n  consumerId: string,\n  name: string,\n  address: string,\n  obj: PartitionReceiver,\n  state: ReceiverState,\n  queue: ReceivedEventData[],\n  eventPosition: EventPosition,\n  logger: SimpleLogger,\n  options: PartitionReceiverOptions,\n): RheaReceiverOptions {\n  const rheaOptions: RheaReceiverOptions & { source: Source; properties: Record<string, any> } = {\n    name,\n    autoaccept: true,\n    target: consumerId,\n    source: {\n      address,\n    },\n    credit_window: 0,\n    properties: {\n      [receiverIdPropertyName]: consumerId,\n    },\n    onClose: (context) => onClose(context, state, logger),\n    onSessionClose: (context) => onSessionClose(context, state, logger),\n    onError: (context) => onError(context, obj, state.link, logger),\n    onMessage: (context) => onMessage(context, obj, queue, options),\n    onSessionError: (context) => onSessionError(context, obj, logger),\n  };\n  const ownerLevel = options.ownerLevel;\n  if (typeof ownerLevel === \"number\") {\n    rheaOptions.properties[Constants.attachEpoch] = types.wrap_long(ownerLevel);\n  }\n  rheaOptions.desired_capabilities = [geoReplication];\n  if (options.trackLastEnqueuedEventProperties) {\n    rheaOptions.desired_capabilities.push(Constants.enableReceiverRuntimeMetricName);\n  }\n  const filterClause = getEventPositionFilter(\n    obj.checkpoint > -1 ? { sequenceNumber: obj.checkpoint } : eventPosition,\n  );\n  rheaOptions.source.filter = {\n    \"apache.org:selector-filter:string\": types.wrap_described(filterClause, 0x468c00000004),\n  };\n  return rheaOptions;\n}\n\nasync function setupLink(\n  consumerId: string,\n  ctx: ConnectionContext,\n  name: string,\n  address: string,\n  obj: PartitionReceiver,\n  state: ReceiverState,\n  queue: ReceivedEventData[],\n  eventPosition: EventPosition,\n  logger: SimpleLogger,\n  options: PartitionReceiverOptions,\n  abortSignal?: AbortSignalLike,\n): Promise<void> {\n  const rheaOptions = createRheaOptions(\n    consumerId,\n    name,\n    address,\n    obj,\n    state,\n    queue,\n    eventPosition,\n    logger,\n    options,\n  );\n  logger.verbose(`trying to be created with options ${logObj(rheaOptions)}`);\n  state.link = await ctx.connection.createReceiver({\n    ...rheaOptions,\n    abortSignal,\n  });\n  state.isConnecting = false;\n  logger.verbose(\"is created successfully\");\n  ctx.receivers[name] = obj;\n}\n\nfunction addCredits(receiver: Link | undefined, creditsToAdd: number): void {\n  if (creditsToAdd > 0) {\n    receiver?.addCredit(creditsToAdd);\n  }\n}\n"]}