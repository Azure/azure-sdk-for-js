{"version":3,"file":"eventDataBatch.js","sourceRoot":"","sources":["../../src/eventDataBatch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport type { EventData } from \"./eventData.js\";\nimport {\n  assertIsEventData,\n  isAmqpAnnotatedMessage,\n  populateIdempotentMessageAnnotations,\n  toRheaMessage,\n} from \"./eventData.js\";\nimport type { ConnectionContext } from \"./connectionContext.js\";\nimport type { MessageAnnotations, Message as RheaMessage } from \"rhea-promise\";\nimport { message } from \"rhea-promise\";\nimport { isDefined, isObjectWithProperties } from \"@azure/core-util\";\nimport type { OperationTracingOptions, TracingContext } from \"@azure/core-tracing\";\nimport { instrumentEventData } from \"./diagnostics/instrumentEventData.js\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error.js\";\nimport type { PartitionPublishingProperties } from \"./models/private.js\";\n\n/**\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * Checks if the provided eventDataBatch is an instance of `EventDataBatch`.\n * @param eventDataBatch - The instance of `EventDataBatch` to verify.\n * @internal\n */\nexport function isEventDataBatch(eventDataBatch: unknown): eventDataBatch is EventDataBatch {\n  return (\n    isObjectWithProperties(eventDataBatch, [\"count\", \"sizeInBytes\", \"tryAdd\"]) &&\n    typeof eventDataBatch.tryAdd === \"function\" &&\n    typeof eventDataBatch.count === \"number\" &&\n    typeof eventDataBatch.sizeInBytes === \"number\"\n  );\n}\n\n/**\n * Options to configure the behavior of the `tryAdd` method on the `EventDataBatch` class.\n */\nexport interface TryAddOptions {\n  /**\n   * The options to use when creating Spans for tracing.\n   */\n  tracingOptions?: OperationTracingOptions;\n}\n\n/**\n * An interface representing a batch of events which can be used to send events to Event Hub.\n *\n * To create the batch, use the `createBatch()` method on the `EventHubProducerClient`.\n * To send the batch, use the `sendBatch()` method on the same client.\n * To fill the batch, use the `tryAdd()` method on the batch itself.\n *\n */\nexport interface EventDataBatch {\n  /**\n   * A value that is hashed and used by the Azure Event Hubs service to determine the partition to\n   * which the events are sent. Use the `createBatch()` method on the `EventHubProducerClient` to\n   * set the partitionKey.\n   * @readonly\n   * @internal\n   */\n  readonly partitionKey?: string;\n\n  /**\n   * Id of the partition to which the batch of events are sent. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the partitionId.\n   * @readonly\n   * @internal\n   */\n  readonly partitionId?: string;\n\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of events added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAdd` function on the batch will return `false`\n   * if the event being added causes the size of the batch to exceed this limit. Use the `createBatch()` method on\n   * the `EventHubProducerClient` to set the maxSizeInBytes.\n   * @readonly\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds an event to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object or AmqpAnnotatedMessage.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  tryAdd(eventData: EventData | AmqpAnnotatedMessage, options?: TryAddOptions): boolean;\n}\n\n/**\n * An internal class representing a batch of events which can be used to send events to Event Hub.\n *\n * @internal\n */\nexport class EventDataBatchImpl implements EventDataBatch {\n  /**\n   * Describes the amqp connection context for the Client.\n   */\n  private _context: ConnectionContext;\n  /**\n   * The Id of the partition to which the batch is expected to be sent to.\n   * Specifying this will throw an error if the batch was created using a `partitionKey`.\n   */\n  private _partitionId?: string;\n  /**\n   * A value that is hashed to produce a partition assignment.\n   * It guarantees that messages with the same partitionKey end up in the same partition.\n   * Specifying this will throw an error if the batch was created using a `partitionId`.\n   */\n  private _partitionKey?: string;\n  /**\n   * The maximum size allowed for the batch.\n   */\n  private _maxSizeInBytes: number;\n  /**\n   * Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * Number of events in the batch.\n   */\n  private _count: number;\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: TracingContext[] = [];\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first event\n   * that was added to the batch.\n   * A common annotation is the partition key.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n  /**\n   * Indicates that the batch should be treated as idempotent.\n   */\n  private _isIdempotent: boolean;\n  /**\n   * The sequence number assigned to the first event in the batch while\n   * the batch is being sent to the service.\n   */\n  private _pendingStartingSequenceNumber?: number;\n  /**\n   * The publishing sequence number assigned to the first event in the batch at the time\n   * the batch was successfully published.\n   * If the producer was not configured to apply sequence numbering or if the batch\n   * has not yet been successfully published, the value will be `undefined`.\n   */\n  private _startingPublishSequenceNumber?: number;\n\n  /**\n   * EventDataBatch should not be constructed using `new EventDataBatch()`\n   * Use the `createBatch()` method on your `EventHubProducer` instead.\n   * @internal\n   */\n  constructor(\n    context: ConnectionContext,\n    maxSizeInBytes: number,\n    isIdempotent: boolean,\n    partitionKey?: string,\n    partitionId?: string,\n  ) {\n    this._context = context;\n    this._maxSizeInBytes = maxSizeInBytes;\n    this._isIdempotent = isIdempotent;\n    this._partitionKey = isDefined(partitionKey) ? String(partitionKey) : partitionKey;\n    this._partitionId = isDefined(partitionId) ? String(partitionId) : partitionId;\n    this._sizeInBytes = 0;\n    this._count = 0;\n  }\n\n  /**\n   * The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * The partitionKey set during `EventDataBatch` creation. This value is hashed to\n   * produce a partition assignment when the producer is created without a `partitionId`\n   * @readonly\n   */\n  get partitionKey(): string | undefined {\n    return this._partitionKey;\n  }\n\n  /**\n   * The partitionId set during `EventDataBatch` creation.\n   * If this value is set then partitionKey can not be set.\n   * @readonly\n   */\n  get partitionId(): string | undefined {\n    return this._partitionId;\n  }\n\n  /**\n   * Size of the `EventDataBatch` instance after the events added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * Number of events in the `EventDataBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * The publishing sequence number assigned to the first event in the batch at the time\n   * the batch was successfully published.\n   * If the producer was not configured to apply sequence numbering or if the batch\n   * has not yet been successfully published, the value will be `undefined`.\n   */\n  get startingPublishedSequenceNumber(): number | undefined {\n    return this._startingPublishSequenceNumber;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * @internal\n   */\n  get _messageSpanContexts(): TracingContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded events and annotations.\n   * @param encodedEvents - The already encoded events to include in the AMQP batch.\n   * @param annotations - The message annotations to set on the batch.\n   * @param publishingProps - Idempotent publishing properties used to decorate the events in the batch while sending.\n   */\n  private _generateBatch(\n    encodedEvents: Buffer[],\n    annotations: MessageAnnotations | undefined,\n    publishingProps?: PartitionPublishingProperties,\n  ): Buffer {\n    if (this._isIdempotent && publishingProps) {\n      // We need to decode the encoded events, add the idempotent annotations, and re-encode them.\n      // We can't lazily encode the events because we rely on `message.encode` to capture the\n      // byte length of anything not in `event.body`.\n      // Events can't be decorated ahead of time because the publishing properties aren't known\n      // until the events are being sent to the service.\n      const decodedEvents = encodedEvents.map(message.decode) as unknown as RheaMessage[];\n      const decoratedEvents = this._decorateRheaMessagesWithPublishingProps(\n        decodedEvents,\n        publishingProps,\n      );\n      encodedEvents = decoratedEvents.map(message.encode);\n    }\n\n    const batchEnvelope: RheaMessage = {\n      body: message.data_sections(encodedEvents),\n    };\n    if (annotations) {\n      batchEnvelope.message_annotations = annotations;\n    }\n    return message.encode(batchEnvelope);\n  }\n\n  /**\n   * Uses the publishingProps to add idempotent properties as message annotations to rhea messages.\n   */\n  private _decorateRheaMessagesWithPublishingProps(\n    events: RheaMessage[],\n    publishingProps: PartitionPublishingProperties,\n  ): RheaMessage[] {\n    if (!this._isIdempotent) {\n      return events;\n    }\n\n    const { lastPublishedSequenceNumber = 0, ownerLevel, producerGroupId } = publishingProps;\n    const startingSequenceNumber = lastPublishedSequenceNumber + 1;\n    for (let i = 0; i < events.length; i++) {\n      const event = events[i];\n      populateIdempotentMessageAnnotations(event, {\n        isIdempotentPublishingEnabled: this._isIdempotent,\n        ownerLevel,\n        producerGroupId,\n        publishSequenceNumber: startingSequenceNumber + i,\n      });\n    }\n\n    this._pendingStartingSequenceNumber = startingSequenceNumber;\n    return events;\n  }\n\n  /**\n   * Annotates a rhea message with placeholder idempotent properties if the batch is idempotent.\n   * This is necessary so that we can accurately calculate the size of the batch while adding events.\n   * Placeholder values are used because real values won't be known until we attempt to send the batch.\n   */\n  private _decorateRheaMessageWithPlaceholderIdempotencyProps(event: RheaMessage): RheaMessage {\n    if (!this._isIdempotent) {\n      return event;\n    }\n\n    if (!event.message_annotations) {\n      event.message_annotations = {};\n    }\n\n    // Set placeholder values for these annotations.\n    populateIdempotentMessageAnnotations(event, {\n      isIdempotentPublishingEnabled: this._isIdempotent,\n      ownerLevel: 0,\n      publishSequenceNumber: 0,\n      producerGroupId: 0,\n    });\n\n    return event;\n  }\n\n  /**\n   * Generates the single AMQP message which is the result of encoding all the events\n   * added into the `EventDataBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `EventDataBatch` instance is passed to the `send()` method on the `EventHubProducer`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(publishingProps?: PartitionPublishingProperties): Buffer {\n    return this._generateBatch(this._encodedMessages, this._batchAnnotations, publishingProps);\n  }\n\n  /**\n   * Sets startingPublishSequenceNumber to the pending publish sequence number.\n   */\n  _commitPublish(): void {\n    this._startingPublishSequenceNumber = this._pendingStartingSequenceNumber;\n  }\n\n  /**\n   * Tries to add an event data to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param eventData -  An individual event data object.\n   * @returns A boolean value indicating if the event data has been added to the batch or not.\n   */\n  public tryAdd(eventData: EventData | AmqpAnnotatedMessage, options: TryAddOptions = {}): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"tryAdd\", \"eventData\", eventData);\n    if (!isAmqpAnnotatedMessage(eventData)) {\n      assertIsEventData(eventData);\n    }\n\n    const { entityPath, host } = this._context.config;\n    const { event: instrumentedEvent, spanContext } = instrumentEventData(\n      eventData,\n      options,\n      entityPath,\n      host,\n    );\n\n    // Convert EventData to RheaMessage.\n    const amqpMessage = toRheaMessage(instrumentedEvent, this._partitionKey);\n    const originalAnnotations = amqpMessage.message_annotations && {\n      ...amqpMessage.message_annotations,\n    };\n    this._decorateRheaMessageWithPlaceholderIdempotencyProps(amqpMessage);\n    const encodedMessage = message.encode(amqpMessage);\n\n    let currentSize = this._sizeInBytes;\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations that are taken from the 1st message.\n    if (this.count === 0) {\n      if (originalAnnotations) {\n        this._batchAnnotations = originalAnnotations;\n      }\n\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch([], this._batchAnnotations).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The event will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    this._count++;\n    return true;\n  }\n}\n"]}