{"version":3,"file":"eventHubConsumerClientModels.js","sourceRoot":"","sources":["../../src/eventHubConsumerClientModels.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { CloseReason } from \"./models/public.js\";\nimport type { EventPosition } from \"./eventPosition.js\";\nimport type { LastEnqueuedEventProperties } from \"./partitionReceiver.js\";\nimport type { MessagingError } from \"@azure/core-amqp\";\nimport type { OperationTracingOptions } from \"@azure/core-tracing\";\nimport type { ReceivedEventData } from \"./eventData.js\";\n\n/**\n * @internal\n */\nexport interface BasicPartitionProperties {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The event hub name.\n   */\n  eventHubName: string;\n  /**\n   * The consumer group name.\n   */\n  consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition.\n   */\n  partitionId: string;\n}\n\n/**\n * Interface that describes the context passed to each of the functions that are a part\n * of the `SubscriptionEventHandlers`. When implementing any of these functions, use\n * the context object to get information about the partition as well as the\n * ability to checkpoint.\n */\nexport interface PartitionContext {\n  /**\n   * The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net\n   */\n  readonly fullyQualifiedNamespace: string;\n  /**\n   * The event hub name.\n   */\n  readonly eventHubName: string;\n  /**\n   * The consumer group name.\n   */\n  readonly consumerGroup: string;\n  /**\n   * The identifier of the Event Hub partition.\n   */\n  readonly partitionId: string;\n  /**\n   * Information on the last enqueued event in the partition that is being processed.\n   * This property is only updated if the `trackLastEnqueuedEventProperties` option is set to true\n   * when creating an instance of EventProcessor.\n   * @readonly\n   */\n  readonly lastEnqueuedEventProperties?: LastEnqueuedEventProperties;\n  /**\n   * Updates the checkpoint using the event data.\n   *\n   * A checkpoint is meant to represent the last successfully processed event by the user from a particular\n   * partition of a consumer group in an Event Hub instance.\n   *\n   * @param eventData - The event that you want to update the checkpoint with.\n   */\n  updateCheckpoint(eventData: ReceivedEventData): Promise<void>;\n}\n\n/**\n * Signature of the user provided function invoked by `EventHubConsumerClient` when a set of events is received.\n */\nexport type ProcessEventsHandler = (\n  events: ReceivedEventData[],\n  context: PartitionContext,\n) => Promise<void>;\n\n/**\n * Signature of the user provided function invoked by `EventHubConsumerClient` for errors that occur when\n * receiving events or when executing any of the user provided functions passed to the `subscribe()` method.\n */\nexport type ProcessErrorHandler = (\n  error: Error | MessagingError,\n  context: PartitionContext,\n) => Promise<void>;\n\n/**\n * Signature of the user provided function invoked by `EventHubConsumerClient` just before starting to receive\n * events from a partition.\n */\nexport type ProcessInitializeHandler = (context: PartitionContext) => Promise<void>;\n\n/**\n * Signature of the user provided function invoked by `EventHubConsumerClient` just after stopping to receive\n * events from a partition.\n */\nexport type ProcessCloseHandler = (reason: CloseReason, context: PartitionContext) => Promise<void>;\n\n/**\n * Interface that describes the functions to be implemented by the user which are invoked by\n * the `EventHubConsumerClient` when the `subscribe()` method is called to receive events\n * from Event Hub.\n */\nexport interface SubscriptionEventHandlers {\n  /**\n   * The function invoked by `EventHubConsumerClient` when a set of events is received. The\n   * `PartitionContext` passed to this function can be used to determine which partition is being read from.\n   *\n   * The `updateCheckpoint()` method on the context can be used to update checkpoints in the `CheckpointStore`\n   * (if one was provided to the client). Use this in frequent intervals to mark events that have been processed\n   * so that the client can restart from such checkpoints in the event of a restart or error recovery.\n   *\n   * Note: It is possible for received events to be an empty array.\n   * This can happen if there are no new events to receive\n   * in the `maxWaitTimeInSeconds`, which is defaulted to 60 seconds.\n   * The `maxWaitTimeInSeconds` can be changed by setting\n   * it in the `options` passed to `subscribe()`.\n   */\n  processEvents: ProcessEventsHandler;\n  /**\n   * The function invoked by `EventHubConsumerClient` for errors that occur when receiving events\n   * or when executing any of the user provided functions passed to the `subscribe()` method.\n   *\n   * The `PartitionContext` passed to this function will indicate the partition that was being processed\n   * when the error was thrown. In cases where an error is thrown outside of processing events from a\n   * partition(e.g. failure to perform load balancing), the `partitionId` on the context will be an empty string.\n   *\n   * After the client completes executing this function, the `partitionClose` function is invoked.\n   */\n  processError: ProcessErrorHandler;\n  /**\n   * The function invoked by `EventHubConsumerClient` each time the subscription is about to begin\n   * reading from a partition. The `PartitionContext` passed to this function can be used to determine\n   * which partition is about to be read from.\n   *\n   * The client will start receiving events for the partition only after completing the execution of\n   * this function (if provided). Therefore, use this function to carry out any setup work including\n   * async tasks.\n   */\n  processInitialize?: ProcessInitializeHandler;\n  /**\n   * The function invoked by `EventHubConsumerClient` each time the subscription stops reading events from\n   * a partition. The information on this partition will be available on the `PartitionContext` passed to the\n   * function `processClose`.\n   *\n   * If the `CloseReason` passed to this function is `OwnershipLost`, then another subscription has taken over\n   * reading from the same partition using the same consumer group. This is expected if you have multiple\n   * instances of your application running and have passed the `CheckpointStore` to the client to load balance.\n   *\n   * If the `CloseReason` is `Shutdown`, this indicates that either `subscription.close()` was called, or an\n   * error occured. Unless the subscription was explicitly closed via `subscription.close()`, the subscription\n   * will attempt to resume reading events from the last checkpoint for the partition.\n   */\n  processClose?: ProcessCloseHandler;\n}\n\n/**\n * Options to configure the `subscribe` method on the `EventHubConsumerClient`.\n * For example, `{ maxBatchSize: 20, maxWaitTimeInSeconds: 120, startPosition: { sequenceNumber: 123 } }`\n */\nexport interface SubscribeOptions {\n  /**\n   * The number of events to request per batch\n   */\n  maxBatchSize?: number;\n  /**\n   * The maximum amount of time to wait to build up the requested message count before\n   * passing the data to user code for processing. If not provided, it defaults to 60 seconds.\n   */\n  maxWaitTimeInSeconds?: number;\n  /**\n   * The event position in a partition to start receiving events from if no checkpoint is found.\n   * Pass a map of partition id to position if you would like to use different starting\n   * position for each partition.\n   */\n  startPosition?: EventPosition | { [partitionId: string]: EventPosition };\n  /**\n   * Indicates whether or not the consumer should request information on the last enqueued event on its\n   * associated partition, and track that information as events are received.\n\n   * When information about the partition's last enqueued event is being tracked, each event received\n   * from the Event Hubs service will carry metadata about the partition that it otherwise would not. This results in a small amount of\n   * additional network bandwidth consumption that is generally a favorable trade-off when considered\n   * against periodically making requests for partition properties using the Event Hub client.\n   */\n  trackLastEnqueuedEventProperties?: boolean;\n  /**\n   * The owner level to use as this subscription subscribes to partitions.\n   */\n  ownerLevel?: number;\n  /**\n   * Options for configuring tracing.\n   */\n  tracingOptions?: OperationTracingOptions;\n  /**\n   * Option to disable the client from running JSON.parse() on the message body when receiving the message.\n   * Not applicable if the message was sent with AMQP body type value or sequence. Use this option when you\n   * prefer to work directly with the bytes present in the message body than have the client attempt to parse it.\n   */\n  skipParsingBodyAsJson?: boolean;\n  /**\n   * The count of events requested eagerly and queued without regard to whether a read was requested.\n   */\n  prefetchCount?: number;\n}\n\n/**\n * Interface that describes the object returned by the `subscribe()` method on the `EventHubConsumerClient`.\n */\nexport interface Subscription {\n  /**\n   * Stops the subscription from receiving more messages.\n   *\n   * If a checkpoint store has been configured this will also mark this subscription's\n   * partitions as abandoned, freeing them up to be read by other consumers.\n   *\n   * @returns Promise<void>\n   * @throws Error if the underlying connection encounters an error while closing.\n   */\n  close(): Promise<void>;\n  /**\n   * Indicates whether the receiver is running.\n   * `true` - is running; `false` otherwise.\n   * @readonly\n   */\n  isRunning: boolean;\n}\n"]}