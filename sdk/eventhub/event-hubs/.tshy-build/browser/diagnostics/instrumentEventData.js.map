{"version":3,"file":"instrumentEventData.js","sourceRoot":"","sources":["../../../src/diagnostics/instrumentEventData.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAGlC,OAAO,EAAE,sBAAsB,EAAE,MAAM,iBAAiB,CAAC;AAKzD,OAAO,EAAE,aAAa,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAE5D;;GAEG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAAG,eAAe,CAAC;AAEpD;;;;;;;GAOG;AACH,MAAM,UAAU,mBAAmB,CACjC,SAA2C,EAC3C,OAAyB,EACzB,UAAkB,EAClB,IAAY,EACZ,SAAmC;;IAEnC,MAAM,KAAK,GAAG,sBAAsB,CAAC,SAAS,CAAC;QAC7C,CAAC,CAAC,SAAS,CAAC,qBAAqB;QACjC,CAAC,CAAC,SAAS,CAAC,UAAU,CAAC;IAEzB,mDAAmD;IACnD,MAAM,sBAAsB,GAAG,OAAO,CAAC,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAG,oBAAoB,CAAC,CAAC,CAAC;IAEtE,IAAI,sBAAsB,EAAE,CAAC;QAC3B,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,WAAW,EAAE,SAAS,EAAE,CAAC;IACtD,CAAC;IAED,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,cAAc,EAAE,GAAG,aAAa,CAAC,SAAS,CACnE,SAAS,EACT,OAAO,EACP,aAAa,CAAC,EAAE,UAAU,EAAE,IAAI,EAAE,EAAE,SAAS,EAAE,UAAU,CAAC,CAC3D,CAAC;IACF,IAAI,CAAC;QACH,IAAI,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE,CAAC;YAC/B,OAAO;gBACL,KAAK,EAAE,SAAS;gBAChB,WAAW,EAAE,SAAS;aACvB,CAAC;QACJ,CAAC;QAED,MAAM,WAAW,GAAG,aAAa,CAAC,oBAAoB,CACpD,MAAA,cAAc,CAAC,cAAc,0CAAE,cAAc,CAC9C,CAAC,aAAa,CAAC,CAAC;QACjB,IAAI,WAAW,EAAE,CAAC;YAChB,MAAM,WAAW,qBAAQ,KAAK,CAAE,CAAC;YAEjC,+CAA+C;YAC/C,IAAI,sBAAsB,CAAC,SAAS,CAAC,EAAE,CAAC;gBACtC,SAAS,mCAAQ,SAAS,KAAE,qBAAqB,EAAE,WAAW,GAAE,CAAC;YACnE,CAAC;iBAAM,CAAC;gBACN,SAAS,mCAAQ,SAAS,KAAE,UAAU,EAAE,WAAW,GAAE,CAAC;YACxD,CAAC;YACD,WAAW,CAAC,oBAAoB,CAAC,GAAG,WAAW,CAAC;QAClD,CAAC;QAED,OAAO;YACL,KAAK,EAAE,SAAS;YAChB,WAAW,EAAE,MAAA,cAAc,CAAC,cAAc,0CAAE,cAAc;SAC3D,CAAC;IACJ,CAAC;YAAS,CAAC;QACT,WAAW,CAAC,GAAG,EAAE,CAAC;IACpB,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,+BAA+B,CAAC,SAAoB;IAClE,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,oBAAoB,CAAC,EAAE,CAAC;QACzE,OAAO;IACT,CAAC;IAED,MAAM,YAAY,GAAG,SAAS,CAAC,UAAU,CAAC,oBAAoB,CAAC,CAAC;IAChE,OAAO,aAAa,CAAC,sBAAsB,CAAC,YAAY,CAAC,CAAC;AAC5D,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { EventData } from \"../eventData.js\";\nimport { isAmqpAnnotatedMessage } from \"../eventData.js\";\nimport type { TracingContext } from \"@azure/core-tracing\";\nimport type { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport type { OperationOptions } from \"../util/operationOptions.js\";\nimport type { MessagingOperationNames } from \"./tracing.js\";\nimport { toSpanOptions, tracingClient } from \"./tracing.js\";\n\n/**\n * @internal\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * Populates the `EventData` with `SpanContext` info to support trace propagation.\n * Creates and returns a copy of the passed in `EventData` unless the `EventData`\n * has already been instrumented.\n * @param eventData - The `EventData` or `AmqpAnnotatedMessage` to instrument.\n * @param span - The `Span` containing the context to propagate tracing information.\n * @param operation - The type of the operation being performed.\n */\nexport function instrumentEventData(\n  eventData: EventData | AmqpAnnotatedMessage,\n  options: OperationOptions,\n  entityPath: string,\n  host: string,\n  operation?: MessagingOperationNames,\n): { event: EventData; spanContext: TracingContext | undefined } {\n  const props = isAmqpAnnotatedMessage(eventData)\n    ? eventData.applicationProperties\n    : eventData.properties;\n\n  // check if the event has already been instrumented\n  const previouslyInstrumented = Boolean(props?.[TRACEPARENT_PROPERTY]);\n\n  if (previouslyInstrumented) {\n    return { event: eventData, spanContext: undefined };\n  }\n\n  const { span: messageSpan, updatedOptions } = tracingClient.startSpan(\n    \"message\",\n    options,\n    toSpanOptions({ entityPath, host }, operation, \"producer\"),\n  );\n  try {\n    if (!messageSpan.isRecording()) {\n      return {\n        event: eventData,\n        spanContext: undefined,\n      };\n    }\n\n    const traceParent = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions?.tracingContext,\n    )[\"traceparent\"];\n    if (traceParent) {\n      const copiedProps = { ...props };\n\n      // create a copy so the original isn't modified\n      if (isAmqpAnnotatedMessage(eventData)) {\n        eventData = { ...eventData, applicationProperties: copiedProps };\n      } else {\n        eventData = { ...eventData, properties: copiedProps };\n      }\n      copiedProps[TRACEPARENT_PROPERTY] = traceParent;\n    }\n\n    return {\n      event: eventData,\n      spanContext: updatedOptions.tracingOptions?.tracingContext,\n    };\n  } finally {\n    messageSpan.end();\n  }\n}\n\n/**\n * Extracts the `SpanContext` from an `EventData` if the context exists.\n * @param eventData - An individual `EventData` object.\n * @internal\n */\nexport function extractSpanContextFromEventData(eventData: EventData): TracingContext | undefined {\n  if (!eventData.properties || !eventData.properties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = eventData.properties[TRACEPARENT_PROPERTY];\n  return tracingClient.parseTraceparentHeader(diagnosticId);\n}\n"]}