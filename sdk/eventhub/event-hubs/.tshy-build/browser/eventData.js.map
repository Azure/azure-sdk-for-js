{"version":3,"file":"eventData.js","sourceRoot":"","sources":["../../src/eventData.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AmqpAnnotatedMessage, Constants } from \"@azure/core-amqp\";\nimport type { BodyTypes } from \"./dataTransformer.js\";\nimport { defaultDataTransformer } from \"./dataTransformer.js\";\nimport type { DeliveryAnnotations, MessageAnnotations, Message as RheaMessage } from \"rhea-promise\";\nimport { types } from \"rhea-promise\";\nimport { isDefined, isObjectWithProperties, objectHasProperty } from \"@azure/core-util\";\nimport type { PENDING_PUBLISH_SEQ_NUM_SYMBOL } from \"./util/constants.js\";\nimport { idempotentProducerAmqpPropertyNames } from \"./util/constants.js\";\nimport isBuffer from \"is-buffer\";\n\n/**\n * Describes the delivery annotations.\n * @internal\n */\nexport interface EventHubDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * Map containing message attributes that will be held in the message header.\n * @internal\n */\nexport interface EventHubMessageAnnotations extends MessageAnnotations {\n  /**\n   * Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * Annotation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * Any other annotation that can be added to the message.\n   */\n  [x: string]: any;\n}\n\n/**\n * Describes the structure of an event to be sent or received from the EventHub.\n * @internal\n */\nexport interface EventDataInternal {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc?: Date;\n  /**\n   * If specified EventHub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey?: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset?: string;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber?: number;\n  /**\n   * The application specific properties.\n   */\n  properties?: { [property: string]: any };\n  /**\n   * The last sequence number of the event within the partition stream of the Event Hub.\n   */\n  lastSequenceNumber?: number;\n  /**\n   * The offset of the last enqueued event.\n   */\n  lastEnqueuedOffset?: string;\n  /**\n   * The enqueued UTC time of the last event.\n   */\n  lastEnqueuedTime?: Date;\n  /**\n   * The time when the runtime info was retrieved\n   */\n  retrievalTime?: Date;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: { [property: string]: any };\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * Returns the underlying raw amqp message.\n   */\n  getRawAmqpMessage(): AmqpAnnotatedMessage;\n  /**\n   * The pending publish sequence number, set while the event\n   * is being published with idempotent partitions enabled.\n   */\n  [PENDING_PUBLISH_SEQ_NUM_SYMBOL]?: number;\n  /**\n   * The sequence number the event was published with\n   * when idempotent partitions are enabled.\n   */\n  _publishedSequenceNumber?: number;\n}\n\nconst messagePropertiesMap = {\n  message_id: \"messageId\",\n  user_id: \"userId\",\n  to: \"to\",\n  subject: \"subject\",\n  reply_to: \"replyTo\",\n  correlation_id: \"correlationId\",\n  content_type: \"contentType\",\n  content_encoding: \"contentEncoding\",\n  absolute_expiry_time: \"absoluteExpiryTime\",\n  creation_time: \"creationTime\",\n  group_id: \"groupId\",\n  group_sequence: \"groupSequence\",\n  reply_to_group_id: \"replyToGroupId\",\n} as const;\n\n/**\n * Converts the AMQP message to an EventData.\n * @param msg - The AMQP message that needs to be converted to EventData.\n * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body when body type is `content`.\n * @internal\n */\nexport function fromRheaMessage(\n  msg: RheaMessage,\n  skipParsingBodyAsJson: boolean,\n): EventDataInternal {\n  const rawMessage = AmqpAnnotatedMessage.fromRheaMessage(msg);\n  const { body, bodyType } = defaultDataTransformer.decode(msg.body, skipParsingBodyAsJson);\n  rawMessage.bodyType = bodyType;\n\n  const data: EventDataInternal = {\n    body,\n    getRawAmqpMessage() {\n      return rawMessage;\n    },\n  };\n\n  if (msg.message_annotations) {\n    for (const annotationKey of Object.keys(msg.message_annotations)) {\n      switch (annotationKey) {\n        case Constants.partitionKey:\n          data.partitionKey = msg.message_annotations[annotationKey];\n          break;\n        case Constants.sequenceNumber:\n          data.sequenceNumber = msg.message_annotations[annotationKey];\n          break;\n        case Constants.enqueuedTime:\n          data.enqueuedTimeUtc = new Date(msg.message_annotations[annotationKey]);\n          break;\n        case Constants.offset:\n          data.offset = msg.message_annotations[annotationKey];\n          break;\n        default:\n          if (!data.systemProperties) {\n            data.systemProperties = {};\n          }\n          data.systemProperties[annotationKey] = convertDatesToNumbers(\n            msg.message_annotations[annotationKey],\n          );\n          break;\n      }\n    }\n  }\n  if (msg.application_properties) {\n    data.properties = convertDatesToNumbers(msg.application_properties);\n  }\n  if (msg.delivery_annotations) {\n    data.lastEnqueuedOffset = msg.delivery_annotations.last_enqueued_offset;\n    data.lastSequenceNumber = msg.delivery_annotations.last_enqueued_sequence_number;\n    data.lastEnqueuedTime = new Date(msg.delivery_annotations.last_enqueued_time_utc as number);\n    data.retrievalTime = new Date(\n      msg.delivery_annotations.runtime_info_retrieval_time_utc as number,\n    );\n  }\n\n  const messageProperties = Object.keys(messagePropertiesMap) as Array<\n    keyof typeof messagePropertiesMap\n  >;\n  for (const messageProperty of messageProperties) {\n    if (!data.systemProperties) {\n      data.systemProperties = {};\n    }\n    if (msg[messageProperty] != null) {\n      data.systemProperties[messagePropertiesMap[messageProperty]] = convertDatesToNumbers(\n        msg[messageProperty],\n      );\n    }\n  }\n\n  if (msg.content_type != null) {\n    data.contentType = msg.content_type;\n  }\n  if (msg.correlation_id != null) {\n    data.correlationId = msg.correlation_id;\n  }\n  if (msg.message_id != null) {\n    data.messageId = msg.message_id;\n  }\n\n  return data;\n}\n\n/**\n * Converts an EventData object to an AMQP message.\n * @param data - The EventData object that needs to be converted to an AMQP message.\n * @param partitionKey - An optional key to determine the partition that this event should land in.\n * @internal\n */\nexport function toRheaMessage(\n  data: EventData | AmqpAnnotatedMessage,\n  partitionKey?: string,\n): RheaMessage {\n  let rheaMessage: RheaMessage;\n  if (isAmqpAnnotatedMessage(data)) {\n    rheaMessage = {\n      ...AmqpAnnotatedMessage.toRheaMessage(data),\n      body: defaultDataTransformer.encode(data.body, data.bodyType ?? \"data\"),\n    };\n  } else {\n    let bodyType: BodyTypes = \"data\";\n    if (typeof (data as EventDataInternal).getRawAmqpMessage === \"function\") {\n      /*\n        If the event is being round-tripped, then we respect the `bodyType` of the\n        underlying AMQP message.\n      */\n      bodyType = (data as EventDataInternal).getRawAmqpMessage().bodyType ?? \"data\";\n    }\n\n    rheaMessage = {\n      body: defaultDataTransformer.encode(data.body, bodyType),\n    };\n    // As per the AMQP 1.0 spec If the message-annotations or delivery-annotations section is omitted,\n    // it is equivalent to a message-annotations section containing empty map of annotations.\n    rheaMessage.message_annotations = {};\n\n    if (data.properties) {\n      rheaMessage.application_properties = data.properties;\n    }\n\n    if (isDefined(partitionKey)) {\n      rheaMessage.message_annotations[Constants.partitionKey] = partitionKey;\n      // Event Hub service cannot route messages to a specific partition based on the partition key\n      // if AMQP message header is an empty object. Hence we make sure that header is always present\n      // with atleast one property. Setting durable to true, helps us achieve that.\n      rheaMessage.durable = true;\n    }\n\n    if (data.contentType != null) {\n      rheaMessage.content_type = data.contentType;\n    }\n    if (data.correlationId != null) {\n      rheaMessage.correlation_id = data.correlationId;\n    }\n    if (data.messageId != null) {\n      if (\n        typeof data.messageId === \"string\" &&\n        data.messageId.length > Constants.maxMessageIdLength\n      ) {\n        throw new Error(\n          `Length of 'messageId' property on the event cannot be greater than ${Constants.maxMessageIdLength} characters.`,\n        );\n      }\n      rheaMessage.message_id = data.messageId;\n    }\n  }\n\n  return rheaMessage;\n}\n\n/**\n * The interface that describes the data to be sent to Event Hub.\n * Use this as a reference when creating the object to be sent when using the `EventHubProducerClient`.\n * For example, `{ body: \"your-data\" }` or\n * ```\n * {\n *    body: \"your-data\",\n *    properties: {\n *       propertyName: \"property value\"\n *    }\n * }\n * ```\n */\nexport interface EventData {\n  /**\n   * The message body that needs to be sent.\n   * If the application reading the events is not using this SDK,\n   * convert your body payload to a byte array or Buffer for better\n   * cross-language compatibility.\n   */\n  body: any;\n\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Set of key value pairs that can be used to set properties specific to user application.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n}\n\n/**\n * Asserts that the provided data conforms to the `EventData` interface.\n *\n * This function performs runtime checks on the `data` object to ensure it matches the expected\n * structure and types defined in the `EventData` interface. If any of the checks fail, it throws\n * an error with a descriptive message indicating the mismatch.\n *\n * @param data - The data object to validate as `EventData`.\n * @throws \\{Error\\} Throws an error if the data does not conform to the `EventData` interface.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function assertIsEventData(data: any): asserts data is EventData {\n  if (data.contentType != null && typeof data.contentType !== \"string\") {\n    throw new Error(\n      `Invalid 'contentType': expected 'string' or 'undefined', but received '${typeof data.contentType}'.`,\n    );\n  }\n\n  if (\n    data.correlationId != null &&\n    typeof data.correlationId !== \"string\" &&\n    typeof data.correlationId !== \"number\" &&\n    !isBuffer(data.correlationId)\n  ) {\n    throw new Error(\n      `Invalid 'correlationId': expected 'string', 'number', 'Buffer', or 'undefined', but received '${typeof data.correlationId}'.`,\n    );\n  }\n\n  if (\n    data.messageId != null &&\n    typeof data.messageId !== \"string\" &&\n    typeof data.messageId !== \"number\" &&\n    !isBuffer(data.messageId)\n  ) {\n    throw new Error(\n      `Invalid 'messageId': expected 'string', 'number', 'Buffer', or 'undefined', but received '${typeof data.messageId}'.`,\n    );\n  }\n\n  if (\n    data.properties !== undefined &&\n    (typeof data.properties !== \"object\" || Array.isArray(data.properties))\n  ) {\n    const actualType = Array.isArray(data.properties) ? \"array\" : typeof data.properties;\n    throw new Error(\n      `Invalid 'properties': expected an object or 'undefined', but received '${actualType}'.`,\n    );\n  }\n}\n\n/**\n * The interface that describes the structure of the event received from Event Hub.\n * Use this as a reference when creating the `processEvents` function to process the events\n * received from an Event Hub when using the `EventHubConsumerClient`.\n */\nexport interface ReceivedEventData {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The application specific properties.\n   */\n  properties?: {\n    [key: string]: any;\n  };\n  /**\n   * The enqueued time of the event.\n   */\n  enqueuedTimeUtc: Date;\n  /**\n   * When specified Event Hub will hash this to a partitionId.\n   * It guarantees that messages end up in a specific partition on the event hub.\n   */\n  partitionKey: string | null;\n  /**\n   * The offset of the event.\n   */\n  offset: string;\n  /**\n   * The sequence number of the event.\n   */\n  sequenceNumber: number;\n  /**\n   * The properties set by the service.\n   */\n  systemProperties?: {\n    [key: string]: any;\n  };\n\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   */\n  correlationId?: string | number | Buffer;\n\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   */\n  messageId?: string | number | Buffer;\n\n  /**\n   * Returns the underlying raw amqp message.\n   */\n  getRawAmqpMessage(): AmqpAnnotatedMessage;\n}\n\n/**\n * @internal\n */\nexport function isAmqpAnnotatedMessage(possible: unknown): possible is AmqpAnnotatedMessage {\n  return (\n    isObjectWithProperties(possible, [\"body\", \"bodyType\"]) &&\n    !objectHasProperty(possible, \"getRawAmqpMessage\")\n  );\n}\n\n/**\n * Converts any Date objects into a number representing date.getTime().\n * Recursively checks for any Date objects in arrays and objects.\n * @internal\n */\nfunction convertDatesToNumbers<T = unknown>(thing: T): T {\n  // fast exit\n  if (!isDefined(thing)) return thing;\n\n  // When 'thing' is a Date, return the number representation\n  if (\n    typeof thing === \"object\" &&\n    objectHasProperty(thing, \"getTime\") &&\n    typeof thing.getTime === \"function\"\n  ) {\n    return thing.getTime();\n  }\n\n  /*\n    Examples:\n    [0, 'foo', new Date(), { nested: new Date()}]\n  */\n  if (Array.isArray(thing)) {\n    return thing.map(convertDatesToNumbers) as unknown as T;\n  }\n\n  /*\n    Examples:\n    { foo: new Date(), children: { nested: new Date() }}\n  */\n  if (typeof thing === \"object\" && isDefined<object>(thing)) {\n    const thingShallowCopy = { ...thing };\n    for (const key of Object.keys(thingShallowCopy)) {\n      (thingShallowCopy as any)[key] = convertDatesToNumbers((thingShallowCopy as any)[key]);\n    }\n    return thingShallowCopy;\n  }\n\n  return thing;\n}\n\n/**\n * @internal\n */\nexport interface PopulateIdempotentMessageAnnotationsParameters {\n  isIdempotentPublishingEnabled: boolean;\n  ownerLevel?: number;\n  producerGroupId?: number;\n  publishSequenceNumber?: number;\n}\n\n/**\n * Populates a rhea message with idempotent producer properties.\n * @internal\n */\nexport function populateIdempotentMessageAnnotations(\n  rheaMessage: RheaMessage,\n  {\n    isIdempotentPublishingEnabled,\n    ownerLevel,\n    producerGroupId,\n    publishSequenceNumber,\n  }: PopulateIdempotentMessageAnnotationsParameters,\n): void {\n  if (!isIdempotentPublishingEnabled) {\n    return;\n  }\n\n  const messageAnnotations = rheaMessage.message_annotations || {};\n  if (!rheaMessage.message_annotations) {\n    rheaMessage.message_annotations = messageAnnotations;\n  }\n\n  if (isDefined(ownerLevel)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.epoch] = types.wrap_short(ownerLevel);\n  }\n  if (isDefined(producerGroupId)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.producerId] =\n      types.wrap_long(producerGroupId);\n  }\n  if (isDefined(publishSequenceNumber)) {\n    messageAnnotations[idempotentProducerAmqpPropertyNames.producerSequenceNumber] =\n      types.wrap_int(publishSequenceNumber);\n  }\n}\n"]}