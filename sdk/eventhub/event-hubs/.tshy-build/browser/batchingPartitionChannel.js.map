{"version":3,"file":"batchingPartitionChannel.js","sourceRoot":"","sources":["../../src/batchingPartitionChannel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { delay } from \"@azure/core-amqp\";\nimport type {\n  EventData,\n  EventDataBatch,\n  EventHubBufferedProducerClientOptions,\n  EventHubProducerClient,\n  OperationOptions,\n} from \"./index.js\";\nimport type { AbortOptions } from \"@azure/core-util\";\nimport { isDefined, isObjectWithProperties } from \"@azure/core-util\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AwaitableQueue } from \"./impl/awaitableQueue.js\";\nimport { getPromiseParts } from \"./util/getPromiseParts.js\";\nimport { logger } from \"./logger.js\";\nimport { cancelablePromiseRace } from \"@azure/core-util\";\n\nexport interface BatchingPartitionChannelProps {\n  loopAbortSignal: AbortSignalLike;\n  maxBufferSize: number;\n  maxWaitTimeInMs: number;\n  partitionId: string;\n  producer: EventHubProducerClient;\n  /**\n   * The handler to call once a batch has successfully published.\n   */\n  onSendEventsSuccessHandler?: EventHubBufferedProducerClientOptions[\"onSendEventsSuccessHandler\"];\n  /**\n   * The handler to call when a batch fails to publish.\n   */\n  onSendEventsErrorHandler: EventHubBufferedProducerClientOptions[\"onSendEventsErrorHandler\"];\n}\n\n/**\n * The `BatchingPartitionChannel` is responsible for accepting enqueued events\n * and optimally batching and sending them to an Event Hub.\n * @internal\n */\nexport class BatchingPartitionChannel {\n  private _eventQueue = new AwaitableQueue<EventData | AmqpAnnotatedMessage>();\n  private _batchedEvents: Array<EventData | AmqpAnnotatedMessage> = [];\n  private _bufferCount: number = 0;\n  private _readyQueue: Array<{\n    resolve: (value: void) => void;\n    reject: (reason?: any) => void;\n  }> = [];\n  private _flushState:\n    | { isFlushing: false }\n    | { isFlushing: true; currentPromise: Promise<void>; resolve: () => void } = {\n    isFlushing: false,\n  };\n  private _isRunning: boolean = false;\n  private _lastBatchCreationTime: number = 0;\n  private _loopAbortSignal: AbortSignalLike;\n  private _maxBufferSize: number;\n  private _maxWaitTimeInMs: number;\n  private _onSendEventsErrorHandler: EventHubBufferedProducerClientOptions[\"onSendEventsErrorHandler\"];\n  private _onSendEventsSuccessHandler?: EventHubBufferedProducerClientOptions[\"onSendEventsSuccessHandler\"];\n\n  private _partitionId: string;\n  private _producer: EventHubProducerClient;\n\n  constructor({\n    loopAbortSignal,\n    maxBufferSize,\n    maxWaitTimeInMs,\n    onSendEventsErrorHandler,\n    onSendEventsSuccessHandler,\n    partitionId,\n    producer,\n  }: BatchingPartitionChannelProps) {\n    this._loopAbortSignal = loopAbortSignal;\n    this._maxBufferSize = maxBufferSize;\n    this._maxWaitTimeInMs = maxWaitTimeInMs;\n    this._onSendEventsErrorHandler = onSendEventsErrorHandler;\n    this._onSendEventsSuccessHandler = onSendEventsSuccessHandler;\n    this._partitionId = partitionId;\n    this._producer = producer;\n  }\n\n  getCurrentBufferedCount(): number {\n    return this._bufferCount;\n  }\n\n  async enqueueEvent(event: EventData | AmqpAnnotatedMessage): Promise<void> {\n    await this._ready();\n    this._eventQueue.push(event);\n    this._bufferCount++;\n\n    if (!this._isRunning) {\n      this._isRunning = true;\n      this._startPublishLoop().catch((e) => {\n        logger.error(\n          `The following error occured during batch creation or sending: ${JSON.stringify(\n            e,\n            undefined,\n            \"  \",\n          )}`,\n        );\n      });\n    }\n  }\n\n  /**\n   * Sets the flush state so that no new events can be enqueued until\n   * all the currently buffered events are sent to the Event Hub.\n   *\n   * Returns a promise that resolves once flushing is complete.\n   */\n  async flush(_options: OperationOptions = {}): Promise<void> {\n    const state = this._flushState;\n    if (state.isFlushing) {\n      return state.currentPromise;\n    }\n\n    if (this.getCurrentBufferedCount() === 0) {\n      return Promise.resolve();\n    }\n\n    const { promise, resolve } = getPromiseParts<void>();\n    this._flushState = { isFlushing: true, currentPromise: promise, resolve };\n\n    return promise;\n  }\n\n  /**\n   * Returns a promise that resolves once there is room for events to be added\n   * to the buffer.\n   */\n  private _ready(): Promise<void> {\n    const currentBufferedCount = this.getCurrentBufferedCount();\n\n    // If the buffer isn't full and we don't have any pending `ready()` calls,\n    // then it's safe to return right away.\n    if (\n      currentBufferedCount < this._maxBufferSize &&\n      !this._readyQueue.length &&\n      !this._flushState.isFlushing\n    ) {\n      return Promise.resolve();\n    }\n\n    const { promise: readyPromise, reject, resolve } = getPromiseParts<void>();\n    this._readyQueue.push({ resolve, reject });\n\n    return readyPromise;\n  }\n\n  /**\n   * Starts the loop that creates batches and sends them to the Event Hub.\n   *\n   * The loop will run until the `_loopAbortSignal` is aborted.\n   */\n  private async _startPublishLoop() {\n    let batch: EventDataBatch | undefined;\n    // `eventToAddToBatch` is used to keep track of an event that has been removed\n    // from the queue, but has not yet been added to a batch.\n    // This prevents losing an event if a `sendBatch` or `createBatch` call fails\n    // before the event is added to a batch.\n    let eventToAddToBatch: EventData | AmqpAnnotatedMessage | undefined;\n    while (!this._loopAbortSignal.aborted) {\n      try {\n        if (!isDefined(batch)) {\n          batch = await this._createBatch();\n        }\n        const timeSinceLastBatchCreation = Date.now() - this._lastBatchCreationTime;\n        const maximumTimeToWaitForEvent = batch.count\n          ? Math.max(this._maxWaitTimeInMs - timeSinceLastBatchCreation, 0)\n          : this._maxWaitTimeInMs;\n\n        const event =\n          eventToAddToBatch ??\n          (await cancelablePromiseRace<[EventData | AmqpAnnotatedMessage, void]>(\n            [\n              (abortOptions: AbortOptions) => this._eventQueue.shift(abortOptions),\n              (abortOptions: AbortOptions) =>\n                delay<void>(\n                  maximumTimeToWaitForEvent,\n                  abortOptions.abortSignal,\n                  abortOptions.abortErrorMsg,\n                ),\n            ],\n            { abortSignal: this._loopAbortSignal },\n          ));\n\n        if (!event) {\n          // We didn't receive an event within the allotted time.\n          // Send the existing batch if it has events in it.\n          if (batch.count) {\n            await this._producer.sendBatch(batch);\n            this._reportSuccess();\n            batch = await this._createBatch();\n          }\n          continue;\n        } else if (!eventToAddToBatch) {\n          eventToAddToBatch = event;\n        }\n\n        const didAdd = batch.tryAdd(event);\n        if (didAdd) {\n          // This event will definitely make it to one of the user-provided handlers\n          // since it was added to a batch.\n          // Store it so we can return it in a handler later.\n          this._batchedEvents.push(event);\n          // Clear reference to existing event since it has been added to the batch.\n          eventToAddToBatch = undefined;\n        }\n\n        if (didAdd && batch.count >= this._maxBufferSize) {\n          // Whenever batch.count exceeds the max count of buffered events, send the batch.\n          await this._producer.sendBatch(batch);\n          this._reportSuccess();\n          batch = await this._createBatch();\n        } else if (!didAdd && batch.count) {\n          // If the event wasn't able to be added and the current batch isn't empty,\n          // attempt to send the current batch and add the event to a new batch.\n          await this._producer.sendBatch(batch);\n          this._reportSuccess();\n          batch = await this._createBatch();\n        }\n\n        if (!didAdd && !batch.tryAdd(event)) {\n          // TODO: Report MaxMesageSizeExceeded error. Mimic service's error.\n          this._reportFailure(new Error(\"Placeholder for max message size exceeded\"), event);\n        } else if (!didAdd) {\n          // Handles the case where the event _was_ successfull added to the new batch.\n          this._batchedEvents.push(event);\n        }\n        // Clear reference to existing event since it has been added to the batch.\n        eventToAddToBatch = undefined;\n      } catch (err: any) {\n        if (!isObjectWithProperties(err, [\"name\"]) || err.name !== \"AbortError\") {\n          this._reportFailure(err);\n          batch = undefined;\n          this._batchedEvents = [];\n        }\n      }\n    }\n  }\n\n  /**\n   * Helper method that returns an `EventDataBatch`.\n   * This also has the side effects of\n   *  - keeping track of batch creation time: needed for maxWaitTime calculations.\n   *  - clearing reference to batched events.\n   *  - incrementing the readiness: creating a new batch indicates the buffer\n   *    should have room, so we can resolve some pending `ready()` calls.\n   */\n  private async _createBatch(): Promise<EventDataBatch> {\n    this._lastBatchCreationTime = Date.now();\n    this._batchedEvents = [];\n    const batch = await this._producer.createBatch({\n      partitionId: this._partitionId,\n    });\n    this._incrementReadiness();\n    return batch;\n  }\n\n  /**\n   * This method will resolve as many pending `ready()` calls as it can\n   * based on how much space remains in the buffer.\n   *\n   * If the channel is currently flushing, this is a no-op. This prevents\n   * `enqueueEvent` calls from adding the event to the buffer until flushing\n   * completes.\n   */\n  private _incrementReadiness() {\n    if (this._flushState.isFlushing) {\n      return;\n    }\n    const currentBufferedCount = this.getCurrentBufferedCount();\n    const num = Math.min(this._maxBufferSize - currentBufferedCount, this._readyQueue.length);\n    for (let i = 0; i < num; i++) {\n      this._readyQueue.shift()?.resolve();\n    }\n  }\n\n  /**\n   * Calls the user-provided `onSendEventsSuccessHandler` with the events\n   * that were successfully sent.\n   */\n  private _reportSuccess() {\n    this._bufferCount = this._bufferCount - this._batchedEvents.length;\n    this._updateFlushState();\n    try {\n      this._onSendEventsSuccessHandler?.({\n        events: this._batchedEvents,\n        partitionId: this._partitionId,\n      });\n    } catch (e: unknown) {\n      logger.error(\n        `The following error occurred in the onSendEventsSuccessHandler: ${JSON.stringify(\n          e,\n          undefined,\n          \"  \",\n        )}`,\n      );\n    }\n  }\n\n  /**\n   * Calls the user-provided `onSendEventsErrorHandler` with an error and the events\n   * that were not successfully sent.\n   */\n  private _reportFailure(err: any, event?: EventData | AmqpAnnotatedMessage) {\n    this._bufferCount = this._bufferCount - (event ? 1 : this._batchedEvents.length);\n    this._updateFlushState();\n    try {\n      this._onSendEventsErrorHandler({\n        error: err,\n        events: event ? [event] : this._batchedEvents,\n        partitionId: this._partitionId,\n      });\n    } catch (e: unknown) {\n      logger.error(\n        `The following error occurred in the onSendEventsErrorHandler: ${JSON.stringify(\n          e,\n          undefined,\n          \"  \",\n        )}`,\n      );\n    }\n  }\n\n  /**\n   * Updates the channel's flush state once the size of the\n   * event buffer has decreased to 0.\n   */\n  private _updateFlushState() {\n    const state = this._flushState;\n    if (!state.isFlushing || this.getCurrentBufferedCount() !== 0) {\n      return;\n    }\n\n    state.resolve();\n\n    this._flushState = { isFlushing: false };\n    this._incrementReadiness();\n  }\n}\n"]}