{"version":3,"file":"messageStore.js","sourceRoot":"","sources":["../../../src/storage/messageStore.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/// <reference lib=\"ES2018.AsyncIterable\" />\n\nimport type { EventPosition } from \"../utils/eventPosition.js\";\nimport type { Message } from \"rhea\";\nimport { Queue } from \"./queue.js\";\n\nexport interface MessageRecord {\n  partitionKey?: string;\n  enqueuedTime: Date;\n  sequenceNumber: number;\n  offset: number;\n  message: Message;\n}\n\nexport interface PartitionInfo {\n  beginningSequenceNumber: number;\n  lastEnqueuedOffset: string;\n  lastEnqueuedTimeUtc: Date;\n  lastEnqueuedSequenceNumber: number;\n  partitionId: string;\n  isPartitionEmpty: boolean;\n}\n\n/**\n * The `MessageStore` stores events sent to the service.\n * It provides a method of pulling events from a partition via `getMessageIterator`,\n * and setting a `startPosition` that indicates which event in a partition to start reading from.\n */\nexport class MessageStore {\n  /**\n   * All messages are stored in a list specific to a partition.\n   *\n   * Key: partitionId\n   * Value: List of `MessageRecord`.\n   */\n  private _partitionRecordMap = new Map<string, MessageRecord[]>();\n\n  /**\n   * Each partition has any number of 'QueueViews' associated with it.\n   *\n   * QueueViews provide a way to have multiple senders stream events using the same\n   * backing `MessageStore`, even supporting different starting positions.\n   *\n   * Key: partitionId\n   * Value: A Set containing all the `QueueViews` for a partition.\n   */\n  private _partitionQueueViews = new Map<string, Set<Queue<MessageRecord>>>();\n\n  /**\n   * Gets the list of `MessageRecord` associated with the specified partition id.\n   * @param partitionId - The partition id to find message records for.\n   */\n  private _getPartitionStore(partitionId: string): MessageRecord[] {\n    const partitionStore = this._partitionRecordMap.get(partitionId) ?? [];\n    this._partitionRecordMap.set(partitionId, partitionStore);\n    return partitionStore;\n  }\n\n  /**\n   * Gets the full Set of 'QueueViews' associated with the specified partition id.\n   * @param partitionId -\n   */\n  private _getPartitionViews(partitionId: string): Set<Queue<MessageRecord>> {\n    const queueViews = this._partitionQueueViews.get(partitionId) ?? new Set();\n    this._partitionQueueViews.set(partitionId, queueViews);\n    return queueViews;\n  }\n\n  /**\n   * Returns the list of `MessageRecord` that appears on or after the specified `startPosition`.\n   * @param fullList - List of `MessageRecord`.\n   * @param startPosition - The `EventPosition` used to find which `MessageRecord` to start reading from.\n   */\n  private _getSubList(fullList: MessageRecord[], startPosition: EventPosition): MessageRecord[] {\n    if (startPosition.type === \"offset\" && startPosition.value === \"@latest\") {\n      return [];\n    }\n\n    const index = fullList.findIndex((record) => {\n      return this._isValidPositionedRecord(record, startPosition);\n    });\n\n    if (index === -1) {\n      return [];\n    }\n\n    return fullList.slice(index);\n  }\n\n  private _isValidPositionedRecord(record: MessageRecord, startPosition: EventPosition): boolean {\n    if (startPosition.type === \"offset\" && startPosition.value === \"@latest\") {\n      return true;\n    }\n    const type = startPosition.type;\n    if (startPosition.operator === \">\") {\n      return record[type] > startPosition.value;\n    } else {\n      return record[type] >= startPosition.value;\n    }\n  }\n\n  /**\n   * Provides information about the state of the specified partition.\n   * @param partitionId - The partition ID to find information about.\n   */\n  public getPartitionInfo(partitionId: string): PartitionInfo {\n    const partitionStore = this._getPartitionStore(partitionId);\n\n    const isEmpty = !partitionStore.length;\n\n    if (isEmpty) {\n      return {\n        beginningSequenceNumber: -1,\n        lastEnqueuedOffset: \"-1\",\n        lastEnqueuedTimeUtc: new Date(0),\n        lastEnqueuedSequenceNumber: -1,\n        partitionId,\n        isPartitionEmpty: isEmpty,\n      };\n    }\n\n    const firstMessage = partitionStore[0];\n    const lastMessage = partitionStore[partitionStore.length - 1];\n    return {\n      beginningSequenceNumber: firstMessage.sequenceNumber,\n      lastEnqueuedOffset: `${lastMessage.offset}`,\n      lastEnqueuedTimeUtc: lastMessage.enqueuedTime,\n      lastEnqueuedSequenceNumber: lastMessage.sequenceNumber,\n      partitionId,\n      isPartitionEmpty: isEmpty,\n    };\n  }\n\n  /**\n   * Associates the provided `Message` with a `partitionId` and stores it.\n   *\n   * This will also update any `MessageIterator`s that are waiting on this partitionId.\n   * @param partitionId - The partition id to associate the message with.\n   * @param message - The message to store.\n   * @param partitionKey - Optional partition key.\n   */\n  public storeMessage(partitionId: string, message: Message, partitionKey?: string): void {\n    const partitionStore = this._getPartitionStore(partitionId);\n    const record: MessageRecord = {\n      enqueuedTime: new Date(),\n      sequenceNumber: partitionStore.length + 1,\n      offset: partitionStore.length,\n      message,\n    };\n    if (partitionKey) {\n      record.partitionKey = partitionKey;\n    }\n    partitionStore.push(record);\n    const partitionViews = this._getPartitionViews(partitionId);\n    partitionViews.forEach((queue) => queue.push(record));\n  }\n\n  /**\n   * Returns an AsyncIterableIterator that yields `MessageRecord`.\n   *\n   * @param partitionId - The partition ID\n   * @param startPosition - Specifies which `MessageRecord` to start iterating from.\n   */\n  public async *getMessageIterator(\n    partitionId: string,\n    startPosition: EventPosition,\n  ): AsyncIterator<MessageRecord, void, boolean | undefined> {\n    const partitionStore = this._getPartitionStore(partitionId);\n    const partitionViews = this._getPartitionViews(partitionId);\n    const partitionStoreSubset = this._getSubList(partitionStore, startPosition);\n    const queueView = new Queue(partitionStoreSubset);\n    partitionViews.add(queueView);\n\n    let shouldStop = false;\n    do {\n      const nextItem = await queueView.shift();\n      if (this._isValidPositionedRecord(nextItem, startPosition)) {\n        shouldStop = Boolean(yield nextItem);\n      }\n    } while (!shouldStop);\n    partitionViews.delete(queueView);\n  }\n}\n"]}