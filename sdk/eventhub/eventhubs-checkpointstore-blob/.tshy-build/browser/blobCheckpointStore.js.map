{"version":3,"file":"blobCheckpointStore.js","sourceRoot":"","sources":["../../src/blobCheckpointStore.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  CheckpointStore,\n  PartitionOwnership,\n  Checkpoint,\n  OperationOptions,\n} from \"@azure/event-hubs\";\nimport type { Metadata, RestError, BlobSetMetadataResponse } from \"@azure/storage-blob\";\nimport { logger, logErrorStackTrace } from \"./log.js\";\nimport type { ContainerClientLike } from \"./storageBlobInterfaces.js\";\nimport { throwTypeErrorIfParameterMissing } from \"./util/error.js\";\n\n/**\n * An implementation of CheckpointStore that uses Azure Blob Storage to persist checkpoint data.\n */\nexport class BlobCheckpointStore implements CheckpointStore {\n  private _containerClient: ContainerClientLike;\n\n  /**\n   * Constructs a new instance of {@link BlobCheckpointStore}\n   * @param containerClient - An instance of a storage blob ContainerClient.\n   */\n  constructor(containerClient: ContainerClientLike) {\n    this._containerClient = containerClient;\n  }\n  /**\n   * Get the list of all existing partition ownership from the underlying data store. May return empty\n   * results if there are is no existing ownership information.\n   * Partition Ownership contains the information on which `EventHubConsumerClient` subscribe call is currently processing the partition.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns Partition ownership details of all the partitions that have had an owner.\n   */\n  async listOwnership(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string,\n    options: OperationOptions = {},\n  ): Promise<PartitionOwnership[]> {\n    const partitionOwnershipArray: PartitionOwnership[] = [];\n    const { abortSignal, tracingOptions } = options;\n\n    const blobPrefix = BlobCheckpointStore.getBlobPrefix({\n      type: \"ownership\",\n      fullyQualifiedNamespace,\n      eventHubName,\n      consumerGroup: consumerGroup,\n    });\n\n    try {\n      const blobs = this._containerClient.listBlobsFlat({\n        abortSignal,\n        includeMetadata: true,\n        prefix: blobPrefix,\n        tracingOptions,\n      });\n\n      for await (const blob of blobs) {\n        const blobPath = blob.name.split(\"/\");\n        const blobName = blobPath[blobPath.length - 1];\n\n        const ownershipMetadata = (blob.metadata as OwnershipMetadata) ?? {};\n\n        if (ownershipMetadata.ownerid == null) {\n          throw new Error(`Missing ownerid in metadata for blob ${blob.name}`);\n        }\n\n        const partitionOwnership: PartitionOwnership = {\n          fullyQualifiedNamespace,\n          eventHubName,\n          consumerGroup: consumerGroup,\n          ownerId: ownershipMetadata.ownerid,\n          partitionId: blobName,\n          lastModifiedTimeInMs:\n            blob.properties.lastModified && blob.properties.lastModified.getTime(),\n          etag: blob.properties.etag,\n        };\n        partitionOwnershipArray.push(partitionOwnership);\n      }\n      return partitionOwnershipArray;\n    } catch (err: any) {\n      logger.warning(`Error occurred while fetching the list of blobs`, err.message);\n      logErrorStackTrace(err);\n\n      if (err?.name === \"AbortError\") throw err;\n\n      throw new Error(`Error occurred while fetching the list of blobs. \\n${err}`);\n    }\n  }\n\n  /**\n   * Claim ownership of a list of partitions. This will return the list of partitions that were\n   * successfully claimed.\n   *\n   * @param partitionOwnership - The list of partition ownership this instance is claiming to own.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns A list partitions this instance successfully claimed ownership.\n   */\n  async claimOwnership(\n    partitionOwnership: PartitionOwnership[],\n    options: OperationOptions = {},\n  ): Promise<PartitionOwnership[]> {\n    const partitionOwnershipArray: PartitionOwnership[] = [];\n    for (const ownership of partitionOwnership) {\n      const blobName = BlobCheckpointStore.getBlobPrefix({ type: \"ownership\", ...ownership });\n      try {\n        const updatedBlobResponse = await this._setBlobMetadata(\n          blobName,\n          {\n            ownerid: ownership.ownerId,\n          },\n          ownership.etag,\n          options,\n        );\n\n        if (updatedBlobResponse.lastModified) {\n          ownership.lastModifiedTimeInMs = updatedBlobResponse.lastModified.getTime();\n        }\n\n        ownership.etag = updatedBlobResponse.etag;\n        partitionOwnershipArray.push(ownership);\n        logger.info(\n          `[${ownership.ownerId}] Claimed ownership successfully for partition: ${ownership.partitionId}`,\n          `LastModifiedTime: ${ownership.lastModifiedTimeInMs}, ETag: ${ownership.etag}`,\n        );\n      } catch (err: any) {\n        const restError = err as RestError;\n\n        if (restError.statusCode === 412) {\n          // etag failures (precondition not met) aren't fatal errors. They happen\n          // as multiple consumers attempt to claim the same partition (first one wins)\n          // and losers get this error.\n          logger.verbose(\n            `[${ownership.ownerId}] Did not claim partition ${ownership.partitionId}. Another processor has already claimed it.`,\n          );\n          continue;\n        }\n\n        logger.warning(\n          `Error occurred while claiming ownership for partition: ${ownership.partitionId}`,\n          err.message,\n        );\n        logErrorStackTrace(err);\n\n        throw err;\n      }\n    }\n    return partitionOwnershipArray;\n  }\n\n  /**\n   * Lists all the checkpoints in a data store for a given namespace, eventhub and consumer group.\n   *\n   * @param fullyQualifiedNamespace - The fully qualified Event Hubs namespace. This is likely to be similar to\n   * <yournamespace>.servicebus.windows.net.\n   * @param eventHubName - The event hub name.\n   * @param consumerGroup - The consumer group name.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   */\n  async listCheckpoints(\n    fullyQualifiedNamespace: string,\n    eventHubName: string,\n    consumerGroup: string,\n    options: OperationOptions = {},\n  ): Promise<Checkpoint[]> {\n    const { abortSignal, tracingOptions } = options;\n    const blobPrefix = BlobCheckpointStore.getBlobPrefix({\n      type: \"checkpoint\",\n      fullyQualifiedNamespace,\n      eventHubName,\n      consumerGroup,\n    });\n\n    const blobs = this._containerClient.listBlobsFlat({\n      abortSignal,\n      includeMetadata: true,\n      prefix: blobPrefix,\n      tracingOptions,\n    });\n\n    const checkpoints: Checkpoint[] = [];\n\n    for await (const blob of blobs) {\n      const blobPath = blob.name.split(\"/\");\n      const blobName = blobPath[blobPath.length - 1];\n\n      const checkpointMetadata = (blob.metadata as CheckpointMetadata) ?? {};\n\n      const offset = checkpointMetadata.offset;\n      if (offset == null) {\n        throw new Error(`Missing metadata property 'offset' on blob '${blob.name}'`);\n      }\n      const sequenceNumber = parseIntOrThrow(\n        blob.name,\n        \"sequencenumber\",\n        checkpointMetadata.sequencenumber,\n      );\n\n      checkpoints.push({\n        consumerGroup,\n        eventHubName,\n        fullyQualifiedNamespace,\n        partitionId: blobName,\n        offset,\n        sequenceNumber,\n      });\n    }\n\n    return checkpoints;\n  }\n\n  /**\n   * Updates the checkpoint in the data store for a partition.\n   *\n   * @param checkpoint - The checkpoint.\n   * @param options - A set of options that can be specified to influence the behavior of this method.\n   *  - `abortSignal`: A signal used to request operation cancellation.\n   *  - `tracingOptions`: Options for configuring tracing.\n   * @returns The new etag on successful update.\n   */\n  async updateCheckpoint(checkpoint: Checkpoint, options: OperationOptions = {}): Promise<void> {\n    throwTypeErrorIfParameterMissing(\n      \"updateCheckpoint\",\n      \"sequenceNumber\",\n      checkpoint.sequenceNumber,\n    );\n    throwTypeErrorIfParameterMissing(\"updateCheckpoint\", \"offset\", checkpoint.offset);\n\n    const blobName = BlobCheckpointStore.getBlobPrefix({ type: \"checkpoint\", ...checkpoint });\n    try {\n      const metadataResponse = await this._setBlobMetadata(\n        blobName,\n        {\n          sequencenumber: checkpoint.sequenceNumber.toString(),\n          offset: checkpoint.offset.toString(),\n        },\n        undefined,\n        options,\n      );\n\n      logger.verbose(\n        `Updated checkpoint successfully for partition: ${checkpoint.partitionId}`,\n        `LastModifiedTime: ${metadataResponse.lastModified!.toISOString()}, ETag: ${\n          metadataResponse.etag\n        }`,\n      );\n      return;\n    } catch (err: any) {\n      logger.warning(\n        `Error occurred while updating the checkpoint for partition: ${checkpoint.partitionId}.`,\n        err.message,\n      );\n      logErrorStackTrace(err);\n\n      if (err?.name === \"AbortError\") throw err;\n\n      throw err;\n    }\n  }\n\n  private static getBlobPrefix(params: {\n    type: \"ownership\" | \"checkpoint\";\n    fullyQualifiedNamespace: string;\n    eventHubName: string;\n    consumerGroup: string;\n    partitionId?: string;\n  }): string {\n    // none of these are case-sensitive in eventhubs so we need to make sure we don't accidentally allow\n    // the user to create a case-sensitive blob for their state!\n    const consumerGroupName = params.consumerGroup.toLowerCase();\n    const eventHubName = params.eventHubName.toLowerCase();\n    const fullyQualifiedNamespace = params.fullyQualifiedNamespace.toLowerCase();\n\n    if (params.partitionId) {\n      return `${fullyQualifiedNamespace}/${eventHubName}/${consumerGroupName}/${params.type}/${params.partitionId}`;\n    } else {\n      return `${fullyQualifiedNamespace}/${eventHubName}/${consumerGroupName}/${params.type}/`;\n    }\n  }\n\n  private async _setBlobMetadata(\n    blobName: string,\n    metadata: OwnershipMetadata | CheckpointMetadata,\n    etag: string | undefined,\n    options: OperationOptions = {},\n  ): Promise<BlobSetMetadataResponse> {\n    const { abortSignal, tracingOptions } = options;\n    const blockBlobClient = this._containerClient.getBlobClient(blobName).getBlockBlobClient();\n\n    // When we have an etag, we know the blob existed.\n    // If we encounter an error we should fail.\n    if (etag) {\n      return blockBlobClient.setMetadata(metadata as Metadata, {\n        abortSignal,\n        conditions: {\n          ifMatch: etag,\n        },\n        tracingOptions,\n      });\n    } else {\n      try {\n        // Attempt to set metadata, and fallback to upload if the blob doesn't already exist.\n        // This avoids poor performance in storage accounts with soft-delete or blob versioning enabled.\n        // https://github.com/Azure/azure-sdk-for-js/issues/10132\n        return await blockBlobClient.setMetadata(metadata as Metadata, {\n          abortSignal,\n          tracingOptions,\n        });\n      } catch (err: any) {\n        // Check if the error is `BlobNotFound` and fallback to `upload` if it is.\n        if (err?.name !== \"RestError\") {\n          throw err;\n        }\n        const errorDetails = (err as RestError).details as { [field: string]: string } | undefined;\n        const errorCode = errorDetails?.errorCode;\n        if (!errorCode || errorCode !== \"BlobNotFound\") {\n          throw err;\n        }\n\n        return blockBlobClient.upload(\"\", 0, {\n          abortSignal,\n          metadata: metadata as Metadata,\n          tracingOptions,\n        });\n      }\n    }\n  }\n}\n\ntype OwnershipMetadata = {\n  [k in \"ownerid\"]: string | undefined;\n};\n\ntype CheckpointMetadata = {\n  [k in \"sequencenumber\" | \"offset\"]: string | undefined;\n};\n\n/**\n * @internal\n */\nexport function parseIntOrThrow(\n  blobName: string,\n  fieldName: string,\n  numStr: string | undefined,\n): number {\n  if (numStr == null) {\n    throw new Error(`Missing metadata property '${fieldName}' on blob '${blobName}'`);\n  }\n\n  const num = parseInt(numStr, 10);\n\n  if (isNaN(num)) {\n    throw new Error(\n      `Failed to parse metadata property '${fieldName}' on blob '${blobName}' as a number`,\n    );\n  }\n\n  return num;\n}\n"]}