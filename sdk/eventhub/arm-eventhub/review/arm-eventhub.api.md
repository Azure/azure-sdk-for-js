## API Report File for "@azure/arm-eventhub"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export interface AccessKeys {
    readonly aliasPrimaryConnectionString?: string;
    readonly aliasSecondaryConnectionString?: string;
    readonly keyName?: string;
    readonly primaryConnectionString?: string;
    readonly primaryKey?: string;
    readonly secondaryConnectionString?: string;
    readonly secondaryKey?: string;
}

// @public
export type AccessRights = string;

// @public
export type ArmDisasterRecovery = Resource & {
    readonly provisioningState?: ProvisioningStateDR;
    partnerNamespace?: string;
    alternateName?: string;
    readonly role?: RoleDisasterRecovery;
    readonly pendingReplicationOperationsCount?: number;
};

// @public
export interface ArmDisasterRecoveryListResult {
    readonly nextLink?: string;
    value?: ArmDisasterRecovery[];
}

// @public
export type AuthorizationRule = Resource & {
    rights?: AccessRights[];
};

// @public
export interface AuthorizationRuleListResult {
    nextLink?: string;
    value?: AuthorizationRule[];
}

// @public
export interface AvailableCluster {
    location?: string;
}

// @public
export interface AvailableClustersList {
    value?: AvailableCluster[];
}

// @public
export interface CaptureDescription {
    destination?: Destination;
    enabled?: boolean;
    encoding?: EncodingCaptureDescription;
    intervalInSeconds?: number;
    sizeLimitInBytes?: number;
    skipEmptyArchives?: boolean;
}

// @public
export interface CheckNameAvailabilityParameter {
    name: string;
}

// @public
export interface CheckNameAvailabilityResult {
    readonly message?: string;
    nameAvailable?: boolean;
    reason?: UnavailableReason;
}

// @public
export type Cluster = TrackedResource & {
    sku?: ClusterSku;
    readonly createdAt?: string;
    readonly updatedAt?: string;
    readonly metricId?: string;
    readonly status?: string;
};

// @public
export interface ClusterListResult {
    nextLink?: string;
    value?: Cluster[];
}

// @public
export interface ClusterQuotaConfigurationProperties {
    settings?: {
        [propertyName: string]: string;
    };
}

// @public
export interface Clusters {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, parameters: Cluster, options?: ClustersCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<ClustersCreateOrUpdateResponse>, ClustersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, parameters: Cluster, options?: ClustersCreateOrUpdateOptionalParams): Promise<ClustersCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, options?: ClustersDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, options?: ClustersDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, clusterName: string, parameters: Cluster, options?: ClustersUpdateOptionalParams): Promise<PollerLike<PollOperationState<ClustersUpdateResponse>, ClustersUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, clusterName: string, parameters: Cluster, options?: ClustersUpdateOptionalParams): Promise<ClustersUpdateResponse>;
    get(resourceGroupName: string, clusterName: string, options?: ClustersGetOptionalParams): Promise<ClustersGetResponse>;
    listAvailableClusterRegion(options?: ClustersListAvailableClusterRegionOptionalParams): Promise<ClustersListAvailableClusterRegionResponse>;
    listByResourceGroup(resourceGroupName: string, options?: ClustersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Cluster>;
    listNamespaces(resourceGroupName: string, clusterName: string, options?: ClustersListNamespacesOptionalParams): Promise<ClustersListNamespacesResponse>;
}

// @public
export interface ClustersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersCreateOrUpdateResponse = Cluster;

// @public
export interface ClustersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ClustersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersGetResponse = Cluster;

// @public
export interface ClusterSku {
    capacity?: number;
    name: ClusterSkuName;
}

// @public
export type ClusterSkuName = string;

// @public
export interface ClustersListAvailableClusterRegionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListAvailableClusterRegionResponse = AvailableClustersList;

// @public
export interface ClustersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListByResourceGroupNextResponse = ClusterListResult;

// @public
export interface ClustersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListByResourceGroupResponse = ClusterListResult;

// @public
export interface ClustersListNamespacesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListNamespacesResponse = EHNamespaceIdListResult;

// @public
export interface ClustersUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersUpdateResponse = Cluster;

// @public
export interface Configuration {
    get(resourceGroupName: string, clusterName: string, options?: ConfigurationGetOptionalParams): Promise<ConfigurationGetResponse>;
    patch(resourceGroupName: string, clusterName: string, parameters: ClusterQuotaConfigurationProperties, options?: ConfigurationPatchOptionalParams): Promise<ConfigurationPatchResponse>;
}

// @public
export interface ConfigurationGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConfigurationGetResponse = ClusterQuotaConfigurationProperties;

// @public
export interface ConfigurationPatchOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConfigurationPatchResponse = ClusterQuotaConfigurationProperties;

// @public
export interface ConnectionState {
    description?: string;
    status?: PrivateLinkConnectionStatus;
}

// @public
export type ConsumerGroup = Resource & {
    readonly createdAt?: Date;
    readonly updatedAt?: Date;
    userMetadata?: string;
};

// @public
export interface ConsumerGroupListResult {
    nextLink?: string;
    value?: ConsumerGroup[];
}

// @public
export interface ConsumerGroups {
    createOrUpdate(resourceGroupName: string, namespaceName: string, eventHubName: string, consumerGroupName: string, parameters: ConsumerGroup, options?: ConsumerGroupsCreateOrUpdateOptionalParams): Promise<ConsumerGroupsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, namespaceName: string, eventHubName: string, consumerGroupName: string, options?: ConsumerGroupsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, namespaceName: string, eventHubName: string, consumerGroupName: string, options?: ConsumerGroupsGetOptionalParams): Promise<ConsumerGroupsGetResponse>;
    listByEventHub(resourceGroupName: string, namespaceName: string, eventHubName: string, options?: ConsumerGroupsListByEventHubOptionalParams): PagedAsyncIterableIterator<ConsumerGroup>;
}

// @public
export interface ConsumerGroupsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConsumerGroupsCreateOrUpdateResponse = ConsumerGroup;

// @public
export interface ConsumerGroupsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ConsumerGroupsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConsumerGroupsGetResponse = ConsumerGroup;

// @public
export interface ConsumerGroupsListByEventHubNextOptionalParams extends coreClient.OperationOptions {
    skip?: number;
    top?: number;
}

// @public
export type ConsumerGroupsListByEventHubNextResponse = ConsumerGroupListResult;

// @public
export interface ConsumerGroupsListByEventHubOptionalParams extends coreClient.OperationOptions {
    skip?: number;
    top?: number;
}

// @public
export type ConsumerGroupsListByEventHubResponse = ConsumerGroupListResult;

// @public
export type DefaultAction = string;

// @public
export interface Destination {
    archiveNameFormat?: string;
    blobContainer?: string;
    name?: string;
    storageAccountResourceId?: string;
}

// @public
export interface DisasterRecoveryConfigs {
    breakPairing(resourceGroupName: string, namespaceName: string, alias: string, options?: DisasterRecoveryConfigsBreakPairingOptionalParams): Promise<void>;
    checkNameAvailability(resourceGroupName: string, namespaceName: string, parameters: CheckNameAvailabilityParameter, options?: DisasterRecoveryConfigsCheckNameAvailabilityOptionalParams): Promise<DisasterRecoveryConfigsCheckNameAvailabilityResponse>;
    createOrUpdate(resourceGroupName: string, namespaceName: string, alias: string, parameters: ArmDisasterRecovery, options?: DisasterRecoveryConfigsCreateOrUpdateOptionalParams): Promise<DisasterRecoveryConfigsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, namespaceName: string, alias: string, options?: DisasterRecoveryConfigsDeleteOptionalParams): Promise<void>;
    failOver(resourceGroupName: string, namespaceName: string, alias: string, options?: DisasterRecoveryConfigsFailOverOptionalParams): Promise<void>;
    get(resourceGroupName: string, namespaceName: string, alias: string, options?: DisasterRecoveryConfigsGetOptionalParams): Promise<DisasterRecoveryConfigsGetResponse>;
    getAuthorizationRule(resourceGroupName: string, namespaceName: string, alias: string, authorizationRuleName: string, options?: DisasterRecoveryConfigsGetAuthorizationRuleOptionalParams): Promise<DisasterRecoveryConfigsGetAuthorizationRuleResponse>;
    list(resourceGroupName: string, namespaceName: string, options?: DisasterRecoveryConfigsListOptionalParams): PagedAsyncIterableIterator<ArmDisasterRecovery>;
    listAuthorizationRules(resourceGroupName: string, namespaceName: string, alias: string, options?: DisasterRecoveryConfigsListAuthorizationRulesOptionalParams): PagedAsyncIterableIterator<AuthorizationRule>;
    listKeys(resourceGroupName: string, namespaceName: string, alias: string, authorizationRuleName: string, options?: DisasterRecoveryConfigsListKeysOptionalParams): Promise<DisasterRecoveryConfigsListKeysResponse>;
}

// @public
export interface DisasterRecoveryConfigsBreakPairingOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DisasterRecoveryConfigsCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsCheckNameAvailabilityResponse = CheckNameAvailabilityResult;

// @public
export interface DisasterRecoveryConfigsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsCreateOrUpdateResponse = ArmDisasterRecovery;

// @public
export interface DisasterRecoveryConfigsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DisasterRecoveryConfigsFailOverOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DisasterRecoveryConfigsGetAuthorizationRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsGetAuthorizationRuleResponse = AuthorizationRule;

// @public
export interface DisasterRecoveryConfigsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsGetResponse = ArmDisasterRecovery;

// @public
export interface DisasterRecoveryConfigsListAuthorizationRulesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsListAuthorizationRulesNextResponse = AuthorizationRuleListResult;

// @public
export interface DisasterRecoveryConfigsListAuthorizationRulesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsListAuthorizationRulesResponse = AuthorizationRuleListResult;

// @public
export interface DisasterRecoveryConfigsListKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsListKeysResponse = AccessKeys;

// @public
export interface DisasterRecoveryConfigsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsListNextResponse = ArmDisasterRecoveryListResult;

// @public
export interface DisasterRecoveryConfigsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisasterRecoveryConfigsListResponse = ArmDisasterRecoveryListResult;

// @public
export type EHNamespace = TrackedResource & {
    sku?: Sku;
    identity?: Identity;
    readonly provisioningState?: string;
    readonly status?: string;
    readonly createdAt?: Date;
    readonly updatedAt?: Date;
    readonly serviceBusEndpoint?: string;
    clusterArmId?: string;
    readonly metricId?: string;
    isAutoInflateEnabled?: boolean;
    maximumThroughputUnits?: number;
    kafkaEnabled?: boolean;
    zoneRedundant?: boolean;
    encryption?: Encryption;
};

// @public
export interface EHNamespaceIdContainer {
    id?: string;
}

// @public
export interface EHNamespaceIdListResult {
    value?: EHNamespaceIdContainer[];
}

// @public
export interface EHNamespaceListResult {
    nextLink?: string;
    value?: EHNamespace[];
}

// @public
export type EncodingCaptureDescription = "Avro" | "AvroDeflate";

// @public
export interface Encryption {
    keySource?: "Microsoft.KeyVault";
    keyVaultProperties?: KeyVaultProperties[];
}

// @public
export type EndPointProvisioningState = string;

// @public
export type EntityStatus = "Active" | "Disabled" | "Restoring" | "SendDisabled" | "ReceiveDisabled" | "Creating" | "Deleting" | "Renaming" | "Unknown";

// @public
export interface ErrorResponse {
    code?: string;
    message?: string;
}

// @public
export type Eventhub = Resource & {
    readonly partitionIds?: string[];
    readonly createdAt?: Date;
    readonly updatedAt?: Date;
    messageRetentionInDays?: number;
    partitionCount?: number;
    status?: EntityStatus;
    captureDescription?: CaptureDescription;
};

// @public
export interface EventHubListResult {
    nextLink?: string;
    value?: Eventhub[];
}

// @public (undocumented)
export class EventHubManagementClient extends EventHubManagementClientContext {
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: EventHubManagementClientOptionalParams);
    // (undocumented)
    clusters: Clusters;
    // (undocumented)
    configuration: Configuration;
    // (undocumented)
    consumerGroups: ConsumerGroups;
    // (undocumented)
    disasterRecoveryConfigs: DisasterRecoveryConfigs;
    // (undocumented)
    eventHubs: EventHubs;
    // (undocumented)
    namespaces: Namespaces;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    regions: Regions;
}

// @public (undocumented)
export class EventHubManagementClientContext extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: EventHubManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface EventHubManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface EventHubs {
    createOrUpdate(resourceGroupName: string, namespaceName: string, eventHubName: string, parameters: Eventhub, options?: EventHubsCreateOrUpdateOptionalParams): Promise<EventHubsCreateOrUpdateResponse>;
    createOrUpdateAuthorizationRule(resourceGroupName: string, namespaceName: string, eventHubName: string, authorizationRuleName: string, parameters: AuthorizationRule, options?: EventHubsCreateOrUpdateAuthorizationRuleOptionalParams): Promise<EventHubsCreateOrUpdateAuthorizationRuleResponse>;
    delete(resourceGroupName: string, namespaceName: string, eventHubName: string, options?: EventHubsDeleteOptionalParams): Promise<void>;
    deleteAuthorizationRule(resourceGroupName: string, namespaceName: string, eventHubName: string, authorizationRuleName: string, options?: EventHubsDeleteAuthorizationRuleOptionalParams): Promise<void>;
    get(resourceGroupName: string, namespaceName: string, eventHubName: string, options?: EventHubsGetOptionalParams): Promise<EventHubsGetResponse>;
    getAuthorizationRule(resourceGroupName: string, namespaceName: string, eventHubName: string, authorizationRuleName: string, options?: EventHubsGetAuthorizationRuleOptionalParams): Promise<EventHubsGetAuthorizationRuleResponse>;
    listAuthorizationRules(resourceGroupName: string, namespaceName: string, eventHubName: string, options?: EventHubsListAuthorizationRulesOptionalParams): PagedAsyncIterableIterator<AuthorizationRule>;
    listByNamespace(resourceGroupName: string, namespaceName: string, options?: EventHubsListByNamespaceOptionalParams): PagedAsyncIterableIterator<Eventhub>;
    listKeys(resourceGroupName: string, namespaceName: string, eventHubName: string, authorizationRuleName: string, options?: EventHubsListKeysOptionalParams): Promise<EventHubsListKeysResponse>;
    regenerateKeys(resourceGroupName: string, namespaceName: string, eventHubName: string, authorizationRuleName: string, parameters: RegenerateAccessKeyParameters, options?: EventHubsRegenerateKeysOptionalParams): Promise<EventHubsRegenerateKeysResponse>;
}

// @public
export interface EventHubsCreateOrUpdateAuthorizationRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EventHubsCreateOrUpdateAuthorizationRuleResponse = AuthorizationRule;

// @public
export interface EventHubsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EventHubsCreateOrUpdateResponse = Eventhub;

// @public
export interface EventHubsDeleteAuthorizationRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface EventHubsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface EventHubsGetAuthorizationRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EventHubsGetAuthorizationRuleResponse = AuthorizationRule;

// @public
export interface EventHubsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EventHubsGetResponse = Eventhub;

// @public
export interface EventHubsListAuthorizationRulesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EventHubsListAuthorizationRulesNextResponse = AuthorizationRuleListResult;

// @public
export interface EventHubsListAuthorizationRulesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EventHubsListAuthorizationRulesResponse = AuthorizationRuleListResult;

// @public
export interface EventHubsListByNamespaceNextOptionalParams extends coreClient.OperationOptions {
    skip?: number;
    top?: number;
}

// @public
export type EventHubsListByNamespaceNextResponse = EventHubListResult;

// @public
export interface EventHubsListByNamespaceOptionalParams extends coreClient.OperationOptions {
    skip?: number;
    top?: number;
}

// @public
export type EventHubsListByNamespaceResponse = EventHubListResult;

// @public
export interface EventHubsListKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EventHubsListKeysResponse = AccessKeys;

// @public
export interface EventHubsRegenerateKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type EventHubsRegenerateKeysResponse = AccessKeys;

// @public
export interface Identity {
    principalId?: string;
    tenantId?: string;
    type?: "SystemAssigned";
}

// @public
export type IPAction = string;

// @public
export type IpFilterRule = Resource & {
    ipMask?: string;
    action?: IPAction;
    filterName?: string;
};

// @public
export interface IpFilterRuleListResult {
    nextLink?: string;
    value?: IpFilterRule[];
}

// @public
export type KeyType = "PrimaryKey" | "SecondaryKey";

// @public
export interface KeyVaultProperties {
    keyName?: string;
    keyVaultUri?: string;
    keyVersion?: string;
}

// @public
export enum KnownAccessRights {
    // (undocumented)
    Listen = "Listen",
    // (undocumented)
    Manage = "Manage",
    // (undocumented)
    Send = "Send"
}

// @public
export enum KnownClusterSkuName {
    // (undocumented)
    Dedicated = "Dedicated"
}

// @public
export enum KnownDefaultAction {
    // (undocumented)
    Allow = "Allow",
    // (undocumented)
    Deny = "Deny"
}

// @public
export enum KnownEndPointProvisioningState {
    // (undocumented)
    Canceled = "Canceled",
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    Succeeded = "Succeeded",
    // (undocumented)
    Updating = "Updating"
}

// @public
export enum KnownIPAction {
    // (undocumented)
    Accept = "Accept",
    // (undocumented)
    Reject = "Reject"
}

// @public
export enum KnownNetworkRuleIPAction {
    // (undocumented)
    Allow = "Allow"
}

// @public
export enum KnownPrivateLinkConnectionStatus {
    // (undocumented)
    Approved = "Approved",
    // (undocumented)
    Disconnected = "Disconnected",
    // (undocumented)
    Pending = "Pending",
    // (undocumented)
    Rejected = "Rejected"
}

// @public
export enum KnownSkuName {
    // (undocumented)
    Basic = "Basic",
    // (undocumented)
    Standard = "Standard"
}

// @public
export enum KnownSkuTier {
    // (undocumented)
    Basic = "Basic",
    // (undocumented)
    Standard = "Standard"
}

// @public
export type MessagingRegions = TrackedResource & {
    properties?: MessagingRegionsProperties;
};

// @public
export interface MessagingRegionsListResult {
    readonly nextLink?: string;
    value?: MessagingRegions[];
}

// @public
export interface MessagingRegionsProperties {
    readonly code?: string;
    readonly fullName?: string;
}

// @public
export interface Namespaces {
    beginCreateOrUpdate(resourceGroupName: string, namespaceName: string, parameters: EHNamespace, options?: NamespacesCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<NamespacesCreateOrUpdateResponse>, NamespacesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, namespaceName: string, parameters: EHNamespace, options?: NamespacesCreateOrUpdateOptionalParams): Promise<NamespacesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, namespaceName: string, options?: NamespacesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, namespaceName: string, options?: NamespacesDeleteOptionalParams): Promise<void>;
    checkNameAvailability(parameters: CheckNameAvailabilityParameter, options?: NamespacesCheckNameAvailabilityOptionalParams): Promise<NamespacesCheckNameAvailabilityResponse>;
    createOrUpdateAuthorizationRule(resourceGroupName: string, namespaceName: string, authorizationRuleName: string, parameters: AuthorizationRule, options?: NamespacesCreateOrUpdateAuthorizationRuleOptionalParams): Promise<NamespacesCreateOrUpdateAuthorizationRuleResponse>;
    createOrUpdateIpFilterRule(resourceGroupName: string, namespaceName: string, ipFilterRuleName: string, parameters: IpFilterRule, options?: NamespacesCreateOrUpdateIpFilterRuleOptionalParams): Promise<NamespacesCreateOrUpdateIpFilterRuleResponse>;
    createOrUpdateNetworkRuleSet(resourceGroupName: string, namespaceName: string, parameters: NetworkRuleSet, options?: NamespacesCreateOrUpdateNetworkRuleSetOptionalParams): Promise<NamespacesCreateOrUpdateNetworkRuleSetResponse>;
    createOrUpdateVirtualNetworkRule(resourceGroupName: string, namespaceName: string, virtualNetworkRuleName: string, parameters: VirtualNetworkRule, options?: NamespacesCreateOrUpdateVirtualNetworkRuleOptionalParams): Promise<NamespacesCreateOrUpdateVirtualNetworkRuleResponse>;
    deleteAuthorizationRule(resourceGroupName: string, namespaceName: string, authorizationRuleName: string, options?: NamespacesDeleteAuthorizationRuleOptionalParams): Promise<void>;
    deleteIpFilterRule(resourceGroupName: string, namespaceName: string, ipFilterRuleName: string, options?: NamespacesDeleteIpFilterRuleOptionalParams): Promise<void>;
    deleteVirtualNetworkRule(resourceGroupName: string, namespaceName: string, virtualNetworkRuleName: string, options?: NamespacesDeleteVirtualNetworkRuleOptionalParams): Promise<void>;
    get(resourceGroupName: string, namespaceName: string, options?: NamespacesGetOptionalParams): Promise<NamespacesGetResponse>;
    getAuthorizationRule(resourceGroupName: string, namespaceName: string, authorizationRuleName: string, options?: NamespacesGetAuthorizationRuleOptionalParams): Promise<NamespacesGetAuthorizationRuleResponse>;
    getIpFilterRule(resourceGroupName: string, namespaceName: string, ipFilterRuleName: string, options?: NamespacesGetIpFilterRuleOptionalParams): Promise<NamespacesGetIpFilterRuleResponse>;
    getNetworkRuleSet(resourceGroupName: string, namespaceName: string, options?: NamespacesGetNetworkRuleSetOptionalParams): Promise<NamespacesGetNetworkRuleSetResponse>;
    getVirtualNetworkRule(resourceGroupName: string, namespaceName: string, virtualNetworkRuleName: string, options?: NamespacesGetVirtualNetworkRuleOptionalParams): Promise<NamespacesGetVirtualNetworkRuleResponse>;
    list(options?: NamespacesListOptionalParams): PagedAsyncIterableIterator<EHNamespace>;
    listAuthorizationRules(resourceGroupName: string, namespaceName: string, options?: NamespacesListAuthorizationRulesOptionalParams): PagedAsyncIterableIterator<AuthorizationRule>;
    listByResourceGroup(resourceGroupName: string, options?: NamespacesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<EHNamespace>;
    listIPFilterRules(resourceGroupName: string, namespaceName: string, options?: NamespacesListIPFilterRulesOptionalParams): PagedAsyncIterableIterator<IpFilterRule>;
    listKeys(resourceGroupName: string, namespaceName: string, authorizationRuleName: string, options?: NamespacesListKeysOptionalParams): Promise<NamespacesListKeysResponse>;
    listVirtualNetworkRules(resourceGroupName: string, namespaceName: string, options?: NamespacesListVirtualNetworkRulesOptionalParams): PagedAsyncIterableIterator<VirtualNetworkRule>;
    regenerateKeys(resourceGroupName: string, namespaceName: string, authorizationRuleName: string, parameters: RegenerateAccessKeyParameters, options?: NamespacesRegenerateKeysOptionalParams): Promise<NamespacesRegenerateKeysResponse>;
    update(resourceGroupName: string, namespaceName: string, parameters: EHNamespace, options?: NamespacesUpdateOptionalParams): Promise<NamespacesUpdateResponse>;
}

// @public
export interface NamespacesCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesCheckNameAvailabilityResponse = CheckNameAvailabilityResult;

// @public
export interface NamespacesCreateOrUpdateAuthorizationRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesCreateOrUpdateAuthorizationRuleResponse = AuthorizationRule;

// @public
export interface NamespacesCreateOrUpdateIpFilterRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesCreateOrUpdateIpFilterRuleResponse = IpFilterRule;

// @public
export interface NamespacesCreateOrUpdateNetworkRuleSetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesCreateOrUpdateNetworkRuleSetResponse = NetworkRuleSet;

// @public
export interface NamespacesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type NamespacesCreateOrUpdateResponse = EHNamespace;

// @public
export interface NamespacesCreateOrUpdateVirtualNetworkRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesCreateOrUpdateVirtualNetworkRuleResponse = VirtualNetworkRule;

// @public
export interface NamespacesDeleteAuthorizationRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface NamespacesDeleteIpFilterRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface NamespacesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface NamespacesDeleteVirtualNetworkRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface NamespacesGetAuthorizationRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesGetAuthorizationRuleResponse = AuthorizationRule;

// @public
export interface NamespacesGetIpFilterRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesGetIpFilterRuleResponse = IpFilterRule;

// @public
export interface NamespacesGetNetworkRuleSetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesGetNetworkRuleSetResponse = NetworkRuleSet;

// @public
export interface NamespacesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesGetResponse = EHNamespace;

// @public
export interface NamespacesGetVirtualNetworkRuleOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesGetVirtualNetworkRuleResponse = VirtualNetworkRule;

// @public
export interface NamespacesListAuthorizationRulesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListAuthorizationRulesNextResponse = AuthorizationRuleListResult;

// @public
export interface NamespacesListAuthorizationRulesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListAuthorizationRulesResponse = AuthorizationRuleListResult;

// @public
export interface NamespacesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListByResourceGroupNextResponse = EHNamespaceListResult;

// @public
export interface NamespacesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListByResourceGroupResponse = EHNamespaceListResult;

// @public
export interface NamespacesListIPFilterRulesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListIPFilterRulesNextResponse = IpFilterRuleListResult;

// @public
export interface NamespacesListIPFilterRulesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListIPFilterRulesResponse = IpFilterRuleListResult;

// @public
export interface NamespacesListKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListKeysResponse = AccessKeys;

// @public
export interface NamespacesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListNextResponse = EHNamespaceListResult;

// @public
export interface NamespacesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListResponse = EHNamespaceListResult;

// @public
export interface NamespacesListVirtualNetworkRulesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListVirtualNetworkRulesNextResponse = VirtualNetworkRuleListResult;

// @public
export interface NamespacesListVirtualNetworkRulesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesListVirtualNetworkRulesResponse = VirtualNetworkRuleListResult;

// @public
export interface NamespacesRegenerateKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesRegenerateKeysResponse = AccessKeys;

// @public
export interface NamespacesUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type NamespacesUpdateResponse = EHNamespace;

// @public
export type NetworkRuleIPAction = string;

// @public
export type NetworkRuleSet = Resource & {
    trustedServiceAccessEnabled?: boolean;
    defaultAction?: DefaultAction;
    virtualNetworkRules?: NWRuleSetVirtualNetworkRules[];
    ipRules?: NWRuleSetIpRules[];
};

// @public
export interface NWRuleSetIpRules {
    action?: NetworkRuleIPAction;
    ipMask?: string;
}

// @public
export interface NWRuleSetVirtualNetworkRules {
    ignoreMissingVnetServiceEndpoint?: boolean;
    subnet?: Subnet;
}

// @public
export interface Operation {
    display?: OperationDisplay;
    readonly name?: string;
}

// @public
export interface OperationDisplay {
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationListResult {
    readonly nextLink?: string;
    readonly value?: Operation[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = OperationListResult;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface PrivateEndpoint {
    id?: string;
}

// @public
export type PrivateEndpointConnection = Resource & {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: ConnectionState;
    provisioningState?: EndPointProvisioningState;
};

// @public
export interface PrivateEndpointConnectionListResult {
    nextLink?: string;
    value?: PrivateEndpointConnection[];
}

// @public
export interface PrivateEndpointConnections {
    beginDelete(resourceGroupName: string, namespaceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, namespaceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<void>;
    createOrUpdate(resourceGroupName: string, namespaceName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionsCreateOrUpdateOptionalParams): Promise<PrivateEndpointConnectionsCreateOrUpdateResponse>;
    get(resourceGroupName: string, namespaceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams): Promise<PrivateEndpointConnectionsGetResponse>;
    list(resourceGroupName: string, namespaceName: string, options?: PrivateEndpointConnectionsListOptionalParams): PagedAsyncIterableIterator<PrivateEndpointConnection>;
}

// @public
export interface PrivateEndpointConnectionsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsCreateOrUpdateResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListNextResponse = PrivateEndpointConnectionListResult;

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult;

// @public
export type PrivateLinkConnectionStatus = string;

// @public
export interface PrivateLinkResource {
    groupId?: string;
    id?: string;
    name?: string;
    requiredMembers?: string[];
    requiredZoneNames?: string[];
    type?: string;
}

// @public
export interface PrivateLinkResources {
    get(resourceGroupName: string, namespaceName: string, options?: PrivateLinkResourcesGetOptionalParams): Promise<PrivateLinkResourcesGetResponse>;
}

// @public
export interface PrivateLinkResourcesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesGetResponse = PrivateLinkResourcesListResult;

// @public
export interface PrivateLinkResourcesListResult {
    nextLink?: string;
    value?: PrivateLinkResource[];
}

// @public
export type ProvisioningStateDR = "Accepted" | "Succeeded" | "Failed";

// @public
export interface RegenerateAccessKeyParameters {
    key?: string;
    keyType: KeyType;
}

// @public
export interface Regions {
    listBySku(sku: string, options?: RegionsListBySkuOptionalParams): PagedAsyncIterableIterator<MessagingRegions>;
}

// @public
export interface RegionsListBySkuNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegionsListBySkuNextResponse = MessagingRegionsListResult;

// @public
export interface RegionsListBySkuOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegionsListBySkuResponse = MessagingRegionsListResult;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export type RoleDisasterRecovery = "Primary" | "PrimaryNotReplicating" | "Secondary";

// @public
export interface Sku {
    capacity?: number;
    name: SkuName;
    tier?: SkuTier;
}

// @public
export type SkuName = string;

// @public
export type SkuTier = string;

// @public
export interface Subnet {
    id?: string;
}

// @public
export type TrackedResource = Resource & {
    location?: string;
    tags?: {
        [propertyName: string]: string;
    };
};

// @public
export type UnavailableReason = "None" | "InvalidName" | "SubscriptionIsDisabled" | "NameInUse" | "NameInLockdown" | "TooManyNamespaceInCurrentSubscription";

// @public
export type VirtualNetworkRule = Resource & {
    virtualNetworkSubnetId?: string;
};

// @public
export interface VirtualNetworkRuleListResult {
    nextLink?: string;
    value?: VirtualNetworkRule[];
}


// (No @packageDocumentation comment for this package)

```
