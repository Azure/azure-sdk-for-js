## API Report File for "@azure-tools/dtdl-parser-generator"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export class CodeWriter {
    constructor(filePath: string);
    // (undocumented)
    break(): void;
    // (undocumented)
    close(): void;
    // (undocumented)
    closeScope(): void;
    // (undocumented)
    openScope(suppressNewLine?: boolean): void;
    // (undocumented)
    writeLine(text: string, suppressNewLine?: boolean, suppressBreak?: boolean): void;
}

// @public (undocumented)
export class DependencyGraph {
    constructor();
    // (undocumented)
    addDirectedEdge(start: string, end: string): void;
    // (undocumented)
    addNode(name: string): void;
    // (undocumented)
    edges: {
        [key: string]: string[];
    };
    // (undocumented)
    nodes: string[];
    // (undocumented)
    topologicalSort(): Array<string>;
    // (undocumented)
    _topologicalSortHelper(node: string, explored: Set<string>, s: Array<string>): void;
}

// @public (undocumented)
export class ModelParserImpl {
    constructor();
    // Warning: (ae-forgotten-export) The symbol "DtmiResolver" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    dtmiResolver?: DtmiResolver;
    // (undocumented)
    getSupplementalTypeCollection(): SupplementalTypeCollectionImpl;
    // (undocumented)
    static graphKeyword: string;
    // (undocumented)
    static idKeyword: string;
    // (undocumented)
    maxDtdlVersion?: number;
    // (undocumented)
    options: ModelParsingOption;
    // Warning: (ae-forgotten-export) The symbol "ModelDict" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    parse(jsonTexts: string[]): Promise<ModelDict>;
    // Warning: (ae-forgotten-export) The symbol "Model" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ParsedObjectPropertyInfo" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ElementPropertyConstraint" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "AggregateContext" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ParsingError" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static _parseObject(_model: Model, _objectPropertyInfoList: ParsedObjectPropertyInfo[], _elementPropertyConstraints: ElementPropertyConstraint[], _aggregateContext: AggregateContext, _parsingErrors: ParsingError[], _obj: {
        [prop: string]: string;
    }): void;
    // (undocumented)
    static retrieveSupplementalTypeCollection(): SupplementalTypeCollectionImpl;
    // Warning: (ae-forgotten-export) The symbol "SupplementalTypeCollectionImpl" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static supplementalTypeCollection: SupplementalTypeCollectionImpl;
}

// @public (undocumented)
export enum ModelParsingOption {
    // (undocumented)
    MandateTopLevelPartition = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    ParseAllowsIdReferenceSyntax = 16,
    // (undocumented)
    PermitAnyTopLevelElement = 8,
    // (undocumented)
    RejectNonDtmiContexts = 2,
    // (undocumented)
    RejectUndefinedExtensions = 1,
    // (undocumented)
    ResolveAllowsIdReferenceSyntax = 32
}

// @public (undocumented)
export class ParserCodeGenerator {
    // (undocumented)
    static execute(inputDigest: string, outputDirectory: string, _dtdlVersion: string): void;
}

// @public (undocumented)
export function pascalToCamel(text: string): string;

// @public (undocumented)
export function pascalToSnake(text: string): string;

// @public
export enum TsAccess {
    // (undocumented)
    Private = "private",
    // (undocumented)
    Protected = "protected",
    // (undocumented)
    Public = "public"
}

// @public (undocumented)
export class TsCatch extends TsScope {
    constructor(err: string, nestingScope: TsScope);
    // (undocumented)
    finally(): TsFinally;
    // (undocumented)
    line(text: string): this;
}

// @public
export class TsClass extends TsDeclaration {
    constructor({ name, exports, abstract, inheritance }: TsClassParams);
    // (undocumented)
    get ctor(): TsConstructor;
    // (undocumented)
    field(input: TsFieldParams): TsClass;
    // (undocumented)
    fields: TsField[];
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    getter({ name, returnType, access }: {
        name: string;
        returnType?: string;
        access?: TsAccess;
    }): TsFunction;
    // (undocumented)
    hasField(fieldName: string): boolean;
    // (undocumented)
    hasMethod(methodName: string): boolean;
    // (undocumented)
    inheritance?: TsInheritanceType[];
    // (undocumented)
    inline(filepath: string, identifier: string): void;
    // (undocumented)
    method({ name, returnType, abstract, access, isStatic }: {
        name: string;
        returnType?: string;
        abstract?: boolean;
        access?: TsAccess;
        isStatic?: boolean;
    }): TsFunction;
    // (undocumented)
    setter({ name, returnType, access }: {
        name: string;
        returnType?: string;
        access?: TsAccess;
    }): TsFunction;
    // (undocumented)
    get staticCtor(): TsConstructor;
    // (undocumented)
    get suffixCode(): TsMultiLine;
    // (undocumented)
    get tsConstructor(): TsConstructor | undefined;
}

// @public (undocumented)
export interface TsClassParams {
    // (undocumented)
    abstract?: boolean;
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    inheritance?: TsInheritanceType[];
    // (undocumented)
    name: string;
}

// @public (undocumented)
export class TsConstructor extends TsFunction {
    constructor(isStatic: boolean);
    // (undocumented)
    parameter(input: TsParameterParams): TsConstructor;
    // (undocumented)
    super(inputs: string[]): TsScope;
}

// @public (undocumented)
export class TsDeclaration {
    constructor({ name, type, exports }: TsDeclarationParams);
    // (undocumented)
    get docString(): TsMultiLineDocString;
    // (undocumented)
    protected _exports: boolean;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    get header(): TsMultiLine;
    // (undocumented)
    import(text: string): TsDeclaration;
    // (undocumented)
    name: string;
    // (undocumented)
    get prefixCode(): TsMultiLine;
    // (undocumented)
    protected _type: TsDeclarationType;
}

// @public (undocumented)
export interface TsDeclarationParams {
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    type: TsDeclarationType;
}

// @public (undocumented)
export enum TsDeclarationType {
    // (undocumented)
    Class = "class",
    // (undocumented)
    Enum = "enum",
    // (undocumented)
    Function = "function",
    // (undocumented)
    Interface = "interface",
    // (undocumented)
    TypeAlias = "typealias"
}

// @public (undocumented)
export class TsElse extends TsScope {
    constructor();
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsElseIf extends TsScope {
    constructor(text: string, nestingScope: TsScope);
    // (undocumented)
    else(): TsElse;
    // (undocumented)
    elseIf(text: string): TsElseIf;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsEnum {
    constructor({ name, exports }: TsEnumParams);
    // (undocumented)
    enum(input: {
        name: string;
        value?: string;
    }): TsEnum;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export interface TsEnumParams {
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    name: string;
}

// @public
export class TsField {
    constructor({ name, type, access, readonly, isStatic, summary, value, optional }: TsFieldParams);
    // (undocumented)
    access?: TsAccess;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    isStatic?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    readonly?: boolean;
    // (undocumented)
    summary?: string;
    // (undocumented)
    type: string;
    // (undocumented)
    value?: string;
}

// @public (undocumented)
export interface TsFieldParams {
    // (undocumented)
    access?: TsAccess;
    // (undocumented)
    isStatic?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    readonly?: boolean;
    // (undocumented)
    summary?: string;
    // (undocumented)
    type: string;
    // (undocumented)
    value?: any;
}

// @public (undocumented)
export class TsFinally extends TsScope {
    constructor();
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsFor extends TsScope {
    constructor(text: string);
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsForEach extends TsScope {
    constructor(text: string, parameters: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsFunction implements TsStatement {
    constructor({ name, returnType, functionType, abstract, access, exports, isStatic }: TsFunctionParams);
    // (undocumented)
    get access(): TsAccess | undefined;
    // (undocumented)
    get body(): TsScope;
    // (undocumented)
    get exports(): boolean | undefined;
    // (undocumented)
    get funcName(): string;
    // (undocumented)
    get functionType(): TsFunctionType | undefined;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    import(text: string): this;
    // (undocumented)
    get isAbstract(): boolean | undefined;
    // (undocumented)
    get isStatic(): boolean | undefined;
    // (undocumented)
    get name(): string;
    // (undocumented)
    parameter({ name, type, description, initializer, optional }: TsParameterParams): TsFunction;
    // (undocumented)
    get parameters(): TsParameter[];
    // (undocumented)
    get returnType(): string | undefined;
    // (undocumented)
    summary(text: string): this;
    // (undocumented)
    get summaryLines(): TsMultiLineDocString | undefined;
}

// @public (undocumented)
export interface TsFunctionParams {
    // (undocumented)
    abstract?: boolean;
    // (undocumented)
    access?: TsAccess;
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    functionType?: TsFunctionType;
    // (undocumented)
    isStatic?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    returnType?: string;
}

// @public (undocumented)
export enum TsFunctionType {
    // (undocumented)
    Function = "function",
    // (undocumented)
    Getter = "get",
    // (undocumented)
    Method = "method",
    // (undocumented)
    Setter = "set"
}

// @public (undocumented)
export class TsIf extends TsScope {
    constructor(text: string, nestingScope: TsScope);
    // (undocumented)
    else(): TsElse;
    // (undocumented)
    elseIf(text: string): TsElseIf;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsImport {
    constructor();
    // (undocumented)
    addTsImport(text: string): void;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsImportGeneric {
    constructor(text: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsImportObjectES6 {
    constructor(location: string, objectName?: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsImportStatementES6 {
    constructor(location: string, importStatement: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export interface TsInheritanceType {
    // (undocumented)
    name: string | string[];
    // (undocumented)
    type: TsDeclarationType;
}

// @public (undocumented)
export class TsInline implements TsStatement {
    constructor(filepath: string, identifier: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsInterface extends TsDeclaration {
    constructor({ name, exports, thingToExtend }: TsInterfaceParams);
    // (undocumented)
    get extends(): string | undefined;
    // (undocumented)
    field(input: TsFieldParams): TsInterface;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    inline(filepath: string, identifier: string): void;
    // (undocumented)
    method({ name, returnType }: {
        name: string;
        returnType?: string;
    }): TsFunction;
}

// @public (undocumented)
export interface TsInterfaceParams {
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    thingToExtend?: string;
}

// @public
export class TsLibrary {
    constructor(outputDir: string);
    // (undocumented)
    class(input: TsClassParams): TsClass;
    // (undocumented)
    enum(input: TsEnumParams): TsEnum;
    // (undocumented)
    function(input: TsFunctionParams): TsFunction;
    // (undocumented)
    generateFiles(generateInternal?: boolean): string[];
    // (undocumented)
    generateIndexForGenerated(): string;
    // (undocumented)
    generateInternalFile(): string;
    // (undocumented)
    interface(input: TsInterfaceParams): TsInterface;
    // (undocumented)
    libraryHeader(text: string): TsMultiLine;
    // (undocumented)
    sortedDependencies(): string[];
    // (undocumented)
    typeAlias(input: TsTypeAliasParams): TsTypeAlias;
}

// @public (undocumented)
export class TsLine implements TsStatement {
    constructor(text: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    get text(): string;
}

// @public (undocumented)
export class TsMultiLine implements TsStatement {
    constructor(text?: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsMultiLineDocString extends TsMultiLine {
    constructor();
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsParameter {
    constructor({ name, type, description, initializer, optional }: TsParameterParams);
    // (undocumented)
    get description(): string | undefined;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    get name(): string;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): string | undefined;
}

// @public (undocumented)
export interface TsParameterParams {
    // (undocumented)
    description?: string;
    // (undocumented)
    initializer?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    optional?: boolean;
    // (undocumented)
    type?: string;
}

// @public (undocumented)
export class TsRequireCommonJS {
    constructor(location: string, importName: string);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsScope implements TsStatement {
    constructor(firstLine?: string, suppressBreak?: boolean);
    // (undocumented)
    protected _firstLine?: string;
    // (undocumented)
    for(text: string): TsFor;
    // (undocumented)
    forEach(object: string, cbParams: string): TsForEach;
    // (undocumented)
    function({ name, returnType, functionType, abstract, access, isStatic }: TsFunctionParams): TsFunction;
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
    // (undocumented)
    if(ifText: string): TsIf;
    // (undocumented)
    inline(filepath: string, identifier: string): void;
    // (undocumented)
    protected _inlines: TsInline[];
    // (undocumented)
    line(text: string): TsScope;
    // (undocumented)
    multiLine(text: string): TsScope;
    // (undocumented)
    scope(firstLine: string): TsScope;
    // (undocumented)
    statement(tsStatement: TsStatement): void;
    // (undocumented)
    protected _statements: TsStatement[];
    // (undocumented)
    protected _suppressBreak: boolean;
    // (undocumented)
    try(): TsTry;
    // (undocumented)
    while(whileText: string): TsScope;
}

// @public (undocumented)
export interface TsStatement {
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export class TsTry extends TsScope {
    constructor(nestingScope: TsScope);
    // (undocumented)
    catch(text: string): TsCatch;
    // (undocumented)
    finally(): TsFinally;
    // (undocumented)
    line(text: string): this;
}

// @public (undocumented)
export class TsTypeAlias extends TsDeclaration {
    constructor({ name, typeToBeAliased, exports }: TsTypeAliasParams);
    // (undocumented)
    generateCode(codeWriter: CodeWriter): void;
}

// @public (undocumented)
export interface TsTypeAliasParams {
    // (undocumented)
    exports?: boolean;
    // (undocumented)
    name: string;
    // (undocumented)
    typeToBeAliased: string;
}

// @public (undocumented)
export class TsWhile extends TsScope {
    constructor(text: string);
    // (undocumented)
    line(text: string): this;
}

// (No @packageDocumentation comment for this package)

```
