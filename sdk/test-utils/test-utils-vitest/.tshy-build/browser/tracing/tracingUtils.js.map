{"version":3,"file":"tracingUtils.js","sourceRoot":"","sources":["../../../src/tracing/tracingUtils.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAKlC;;;;GAIG;AACH,MAAM,UAAU,YAAY,CAAC,OAAe,EAAE,YAA8B;;IAC1E,MAAM,UAAU,GAAG,YAAY,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE;QAC3D,OAAO,IAAI,CAAC,OAAO,KAAK,OAAO,CAAC;IAClC,CAAC,CAAC,CAAC;IAEH,MAAM,KAAK,GAAoB,EAAE,CAAC;IAClC,MAAM,OAAO,GAA+B,IAAI,GAAG,EAAyB,CAAC;IAE7E,KAAK,MAAM,IAAI,IAAI,UAAU,EAAE,CAAC;QAC9B,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC;QAC3B,MAAM,IAAI,GAAkB;YAC1B,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,QAAQ,EAAE,EAAE;SACb,CAAC;QACF,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAE1B,IAAI,MAAA,IAAI,CAAC,UAAU,EAAE,0CAAE,MAAM,EAAE,CAAC;YAC9B,MAAM,UAAU,GAAG,MAAA,IAAI,CAAC,UAAU,EAAE,0CAAE,MAAM,CAAC;YAC7C,MAAM,MAAM,GAAG,OAAO,CAAC,GAAG,CAAC,UAAW,CAAC,CAAC;YACxC,IAAI,CAAC,MAAM,EAAE,CAAC;gBACZ,MAAM,IAAI,KAAK,CACb,kBAAkB,IAAI,CAAC,IAAI,sCAAsC,UAAU,EAAE,CAC9E,CAAC;YACJ,CAAC;YACD,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC7B,CAAC;aAAM,CAAC;YACN,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnB,CAAC;IACH,CAAC;IAED,OAAO;QACL,KAAK;KACN,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,gBAAgB,CAAI,QAAa,EAAE,MAAW;IAC5D,QAAQ,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;IAC3B,MAAM,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC;IACvB,IAAI,QAAQ,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM,EAAE,CAAC;QACtC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,KAAK,MAAM,IAAI,IAAI,QAAQ,EAAE,CAAC;QAC5B,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;YAC3B,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { SpanGraph, SpanGraphNode } from \"./spanGraphModel.js\";\nimport { MockInstrumenter } from \"./mockInstrumenter.js\";\n\n/**\n * Return all Spans for a particular trace, grouped by their\n * parent Span in a tree-like structure\n * @param traceId - The traceId to return the graph for\n */\nexport function getSpanGraph(traceId: string, instrumenter: MockInstrumenter): SpanGraph {\n  const traceSpans = instrumenter.startedSpans.filter((span) => {\n    return span.traceId === traceId;\n  });\n\n  const roots: SpanGraphNode[] = [];\n  const nodeMap: Map<string, SpanGraphNode> = new Map<string, SpanGraphNode>();\n\n  for (const span of traceSpans) {\n    const spanId = span.spanId;\n    const node: SpanGraphNode = {\n      name: span.name,\n      children: [],\n    };\n    nodeMap.set(spanId, node);\n\n    if (span.parentSpan()?.spanId) {\n      const parentSpan = span.parentSpan()?.spanId;\n      const parent = nodeMap.get(parentSpan!);\n      if (!parent) {\n        throw new Error(\n          `Span with name ${node.name} has an unknown parentSpan with id ${parentSpan}`,\n        );\n      }\n      parent.children.push(node);\n    } else {\n      roots.push(node);\n    }\n  }\n\n  return {\n    roots,\n  };\n}\n\nexport function sameArrayMembers<T>(expected: T[], actual: T[]): boolean {\n  expected = expected.sort();\n  actual = actual.sort();\n  if (expected.length !== actual.length) {\n    return false;\n  }\n\n  for (const item of expected) {\n    if (!actual.includes(item)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"]}