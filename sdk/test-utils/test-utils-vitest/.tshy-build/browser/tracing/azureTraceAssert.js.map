{"version":3,"file":"azureTraceAssert.js","sourceRoot":"","sources":["../../../src/tracing/azureTraceAssert.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAA2B,eAAe,EAAE,MAAM,qBAAqB,CAAC;AAC/E,OAAO,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAC;AAEzD,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACjD,OAAO,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAC;AAEhC,MAAM,YAAY,GAAG,IAAI,gBAAgB,EAAE,CAAC;AAE5C;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,eAAe,CAInC,QAAkB,EAClB,iBAA2B,EAC3B,OAAiB,EACjB,OAAqC;IAErC,eAAe,CAAC,YAAY,CAAC,CAAC;IAC9B,YAAY,CAAC,KAAK,EAAE,CAAC;IACrB,IAAI,CAAC;QACH,MAAM,gBAAgB,mBACpB,WAAW,EAAE,MAAM,IAChB,OAAO,CACX,CAAC;QACF,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,cAAc,EAAE,GAAG,YAAY,CAAC,SAAS,CAAC,MAAM,EAAE,gBAAgB,CAAC,CAAC;QAE5F,MAAM,UAAU,GAAG,gCACd,OAAO,KACV,cAAc,EAAE;gBACd,cAAc,EAAE,cAAc;aAC/B,GACS,CAAC;QACb,MAAM,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;QACzC,QAAQ,CAAC,GAAG,EAAE,CAAC;QACf,MAAM,SAAS,GAAG,YAAY,CAAE,QAA4B,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;QACpF,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,oCAAoC,CAAC,CAAC;QAC9E,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;QAC9C,MAAM,CAAC,WAAW,CAChB,QAAQ,EACR,YAAY,CAAC,YAAY,CAAC,CAAC,CAAC,EAC5B,gDAAgD,CACjD,CAAC;QAEF,MAAM,cAAc,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC9E,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,cAAc,CAAC,CAAC,EAAE,iBAAiB,CAAC,CAAC;QAC3E,QAAQ,CAAC,GAAG,EAAE,CAAC;QACf,MAAM,SAAS,GAAG,YAAY,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QACxE,MAAM,CAAC,KAAK,CACV,SAAS,CAAC,MAAM,EAChB,CAAC,EACD,gDAAgD,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAC3F,CAAC;IACJ,CAAC;YAAS,CAAC;QACT,wFAAwF;QACxF,iDAAiD;QACjD,8DAA8D;QAC9D,eAAe,CAAM,SAAS,CAAC,CAAC;IAClC,CAAC;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { OperationTracingOptions, useInstrumenter } from \"@azure/core-tracing\";\nimport { MockInstrumenter } from \"./mockInstrumenter.js\";\nimport { MockTracingSpan } from \"./mockTracingSpan.js\";\nimport { getSpanGraph } from \"./tracingUtils.js\";\nimport { assert } from \"vitest\";\n\nconst instrumenter = new MockInstrumenter();\n\n/**\n * The supports Tracing function does the verification of whether the core-tracing is supported correctly with the client method\n * This function verifies the root span, if all the correct spans are called as expected and if they are closed.\n * @param callback - Callback function of the client that should be invoked\n * @param expectedSpanNames - List of span names that are expected to be generated\n * @param options - Options for either Core HTTP operations or custom options for the callback\n * @param thisArg - optional this parameter for the callback\n */\nexport async function supportsTracing<\n  Options extends { tracingOptions?: OperationTracingOptions },\n  Callback extends (options: Options) => Promise<unknown>,\n>(\n  callback: Callback,\n  expectedSpanNames: string[],\n  options?: Options,\n  thisArg?: ThisParameterType<Callback>,\n): Promise<void> {\n  useInstrumenter(instrumenter);\n  instrumenter.reset();\n  try {\n    const startSpanOptions = {\n      packageName: \"test\",\n      ...options,\n    };\n    const { span: rootSpan, tracingContext } = instrumenter.startSpan(\"root\", startSpanOptions);\n\n    const newOptions = {\n      ...options,\n      tracingOptions: {\n        tracingContext: tracingContext,\n      },\n    } as Options;\n    await callback.call(thisArg, newOptions);\n    rootSpan.end();\n    const spanGraph = getSpanGraph((rootSpan as MockTracingSpan).traceId, instrumenter);\n    assert.equal(spanGraph.roots.length, 1, \"There should be just one root span\");\n    assert.equal(spanGraph.roots[0].name, \"root\");\n    assert.strictEqual(\n      rootSpan,\n      instrumenter.startedSpans[0],\n      \"The root span should match what was passed in.\",\n    );\n\n    const directChildren = spanGraph.roots[0].children.map((child) => child.name);\n    assert.sameMembers(Array.from(new Set(directChildren)), expectedSpanNames);\n    rootSpan.end();\n    const openSpans = instrumenter.startedSpans.filter((s) => !s.endCalled);\n    assert.equal(\n      openSpans.length,\n      0,\n      `All spans should have been closed, but found ${openSpans.map((s) => s.name)} open spans.`,\n    );\n  } finally {\n    // By resetting the instrumenter to undefined, we force the next call to instantiate the\n    // no-op instrumenter and prevent test pollution.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    useInstrumenter(<any>undefined);\n  }\n}\n"]}