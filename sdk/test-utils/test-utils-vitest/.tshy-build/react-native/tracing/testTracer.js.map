{"version":3,"file":"testTracer.js","sourceRoot":"","sources":["../../../src/tracing/testTracer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { TestSpan } from \"./testSpan.js\";\nimport {\n  SpanContext,\n  SpanKind,\n  SpanOptions,\n  TraceFlags,\n  Context as OTContext,\n  context as otContext,\n  Tracer,\n  trace as otTrace,\n} from \"@opentelemetry/api\";\nimport { SpanGraph, SpanGraphNode } from \"./spanGraphModel.js\";\n\n/**\n * A mock tracer useful for testing\n */\nexport class TestTracer implements Tracer {\n  constructor(\n    public name?: string,\n    public version?: string,\n  ) {}\n  private traceIdCounter = 0;\n  private getNextTraceId(): string {\n    this.traceIdCounter++;\n    return this.traceIdCounter.toString().padStart(32, \"0\");\n  }\n\n  private spanIdCounter = 0;\n  private getNextSpanId(): string {\n    this.spanIdCounter++;\n    return this.spanIdCounter.toString().padStart(16, \"0\");\n  }\n\n  private rootSpans: TestSpan[] = [];\n  private knownSpans: TestSpan[] = [];\n\n  /**\n   * Returns all Spans that were created without a parent\n   */\n  getRootSpans(): TestSpan[] {\n    return this.rootSpans;\n  }\n\n  /**\n   * Returns all Spans this Tracer knows about\n   */\n  getKnownSpans(): TestSpan[] {\n    return this.knownSpans;\n  }\n\n  /**\n   * Returns all Spans where end() has not been called\n   */\n  getActiveSpans(): TestSpan[] {\n    return this.knownSpans.filter((span) => {\n      return !span.endCalled;\n    });\n  }\n\n  /**\n   * Return all Spans for a particular trace, grouped by their\n   * parent Span in a tree-like structure\n   * @param traceId - The traceId to return the graph for\n   */\n  getSpanGraph(traceId: string): SpanGraph {\n    const traceSpans = this.knownSpans.filter((span) => {\n      return span.spanContext().traceId === traceId;\n    });\n\n    const roots: SpanGraphNode[] = [];\n    const nodeMap: Map<string, SpanGraphNode> = new Map<string, SpanGraphNode>();\n\n    for (const span of traceSpans) {\n      const spanId = span.spanContext().spanId;\n      const node: SpanGraphNode = {\n        name: span.name,\n        children: [],\n      };\n      nodeMap.set(spanId, node);\n      if (span.parentSpanId) {\n        const parent = nodeMap.get(span.parentSpanId);\n        if (!parent) {\n          throw new Error(\n            `Span with name ${node.name} has an unknown parentSpan with id ${span.parentSpanId}`,\n          );\n        }\n        parent.children.push(node);\n      } else {\n        roots.push(node);\n      }\n    }\n\n    return {\n      roots,\n    };\n  }\n\n  /**\n   * Starts a new Span.\n   * @param name - The name of the span.\n   * @param options - The SpanOptions used during Span creation.\n   */\n  startSpan(name: string, options?: SpanOptions, context?: OTContext): TestSpan {\n    const parentContext = getSpanContext(context || otContext.active());\n\n    let traceId: string;\n    let isRootSpan = false;\n\n    if (parentContext && parentContext.traceId) {\n      traceId = parentContext.traceId;\n    } else {\n      traceId = this.getNextTraceId();\n      isRootSpan = true;\n    }\n\n    const spanContext: SpanContext = {\n      traceId,\n      spanId: this.getNextSpanId(),\n      traceFlags: TraceFlags.NONE,\n    };\n    const span = new TestSpan(\n      this,\n      name,\n      spanContext,\n      options?.kind || SpanKind.INTERNAL,\n      parentContext ? parentContext.spanId : undefined,\n      options?.startTime,\n      options?.attributes,\n    );\n    this.knownSpans.push(span);\n    if (isRootSpan) {\n      this.rootSpans.push(span);\n    }\n    return span;\n  }\n\n  /**\n   * Added to support testing. We do not support `startActiveSpan` in general because it uses async_hooks\n   * which is experimental. Only added to support TestTracerProvider compatibility with OTel Tracers.\n   */\n  startActiveSpan(): never {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context - context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return otTrace.getSpanContext(context);\n}\n\n/**\n * OpenTelemetry compatible interface for Context\n */\nexport interface Context {\n  /**\n   * Get a value from the context.\n   *\n   * @param key - key which identifies a context value\n   */\n  getValue(key: symbol): unknown;\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key - context key for which to set the value\n   * @param value - value to set for the given key\n   */\n  setValue(key: symbol, value: unknown): Context;\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key - context key for which to clear a value\n   */\n  deleteValue(key: symbol): Context;\n}\n"]}