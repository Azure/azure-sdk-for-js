{"version":3,"file":"connectionStringHelpers.js","sourceRoot":"","sources":["../../../src/utils/connectionStringHelpers.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC;;GAEG;AACH,SAAS,mBAAmB,CAAC,gBAAwB;IACnD,MAAM,aAAa,GAA2B,EAAE,CAAC;IACjD,MAAM,QAAQ,GAAG,gBAAgB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;IACvE,KAAK,MAAM,OAAO,IAAI,QAAQ,EAAE,CAAC;QAC/B,MAAM,cAAc,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;QACtC,MAAM,CAAC,UAAU,EAAE,KAAK,CAAC,GAAG,eAAe,CAAC,cAAc,CAAC,CAAC;QAC5D,aAAa,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC;IACpC,CAAC;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAED;;;;GAIG;AACH,SAAS,eAAe,CAAC,GAAW;IAClC,yEAAyE;IACzE,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;QACpC,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,OAAO,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACxC,CAAC;AAED;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,UAAU,mBAAmB,CACjC,gBAAwB,EACxB,cAAsB;IAEtB,MAAM,gBAAgB,GAA2B,EAAE,CAAC;IACpD,MAAM,UAAU,GAAG,mBAAmB,CAAC,cAAc,CAAC,CAAC;IACvD,MAAM,UAAU,GAAG,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;IACzD,KAAK,MAAM,GAAG,IAAI,UAAU,EAAE,CAAC;QAC7B,gBAAgB,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,8BAA8B;IACrF,CAAC;IACD,OAAO,gBAAgB,CAAC;AAC1B,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * Returns the connection string parsed as JSON object.\n */\nfunction getConnStringAsJSON(connectionString: string): Record<string, string> {\n  const keyValuePairs: Record<string, string> = {};\n  const elements = connectionString.split(\";\").filter((e) => Boolean(e));\n  for (const element of elements) {\n    const trimmedElement = element.trim();\n    const [elementKey, value] = getKeyValuePair(trimmedElement);\n    keyValuePairs[elementKey] = value;\n  }\n  return keyValuePairs;\n}\n\n/**\n * Returns the key and value from `<key>=<value>` string.\n *\n * `a=b=c` => [\"a\", \"b=c\"]\n */\nfunction getKeyValuePair(kvp: string): string[] {\n  // If the string is not in kvp format <key>=<value> return an empty array\n  if (!kvp || kvp.indexOf(\"=\") === -1) {\n    return [];\n  }\n\n  return kvp.split(/=(.*)/).slice(0, 2);\n}\n\n/**\n * Get real and fake values mapped from the provided connection strings.\n *\n * Example:\n *  connectionString = \"endpoint=secretive.azure.io;token=a1b2c3d4;secret=totally_secret\"\n *  fakeConnString   = \"endpoint=randomval.azure.io;token=mask_tok;secret=totally_faked\"\n *\n *  // Ordering/spaces are not important\n *\n * Returns\n * ```\n * {\n *   \"secretive.azure.io\": \"randomval.azure.io\",\n *   \"a1b2c3d4\"          : \"mask_tok\",\n *   \"totally_secret\"    : \"totally_faked\"\n * }\n * ```\n */\nexport function getRealAndFakePairs(\n  connectionString: string,\n  fakeConnString: string,\n): Record<string, string> {\n  const realAndFakePairs: Record<string, string> = {};\n  const fakeValues = getConnStringAsJSON(fakeConnString);\n  const realValues = getConnStringAsJSON(connectionString);\n  for (const key in fakeValues) {\n    realAndFakePairs[realValues[key]] = fakeValues[key]; // \"real value\" : \"fake value\"\n  }\n  return realAndFakePairs;\n}\n"]}