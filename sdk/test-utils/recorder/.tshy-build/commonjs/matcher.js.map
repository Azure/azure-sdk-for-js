{"version":3,"file":"matcher.js","sourceRoot":"","sources":["../../src/matcher.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;AA4ClC,gCA+BC;AAzED,kEAA8E;AAC9E,qCAAkC;AAClC,+CAAyC;AACzC,+CAAiD;AAuC1C,KAAK,UAAU,UAAU,CAC9B,WAAmB,EACnB,UAAsB,EACtB,OAAgB,EAChB,WAAoB,EACpB,cAA4C,EAAE,aAAa,EAAE,IAAI,EAAE,mBAAmB,EAAE,KAAK,EAAE;;IAE/F,MAAM,GAAG,GAAG,GAAG,WAAW,GAAG,gBAAK,CAAC,KAAK,GAAG,gBAAK,CAAC,UAAU,EAAE,CAAC;IAE9D,MAAM,OAAO,GAAG,IAAA,0CAAqB,EAAC,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,uBAAuB,EAAE,IAAI,EAAE,CAAC,CAAC;IAC9F,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,0BAA0B,EAAE,OAAO,CAAC,CAAC;IACzD,IAAI,WAAW,EAAE,CAAC;QAChB,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;IACrD,CAAC;IACD,IAAI,WAAW,EAAE,CAAC;QAChB,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC;YAC5B,aAAa,EAAE,WAAW,CAAC,aAAa;YACxC,eAAe,EAAE,MAAA,WAAW,CAAC,eAAe,0CAAE,QAAQ,EAAE;YACxD,cAAc,EAAE,MAAA,WAAW,CAAC,cAAc,0CAAE,QAAQ,EAAE;YACtD,mBAAmB,EAAE,WAAW,CAAC,mBAAmB;SACrD,CAAC,CAAC;IACL,CAAC;IAED,eAAM,CAAC,IAAI,CAAC,8BAA8B,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;IAClE,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IACvD,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,QAAQ,CAAC;IAExC,IAAI,MAAM,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,EAAE,CAAC;QACjC,eAAM,CAAC,KAAK,CAAC,gCAAgC,EAAE,QAAQ,CAAC,CAAC;QACzD,MAAM,IAAI,wBAAa,CAAC,sBAAsB,UAAU,EAAE,EAAE,MAAM,CAAC,CAAC;IACtE,CAAC;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { createPipelineRequest, HttpClient } from \"@azure/core-rest-pipeline\";\nimport { logger } from \"./log.js\";\nimport { paths } from \"./utils/paths.js\";\nimport { RecorderError } from \"./utils/utils.js\";\n\nexport type Matcher = \"HeaderlessMatcher\" | \"BodilessMatcher\" | \"CustomDefaultMatcher\";\n\n/**\n * Body the customer matcher expects.\n */\nexport interface CustomMatcherOptions {\n  /**\n   * Should the body value be compared during lookup operations?\n   */\n  compareBodies?: boolean;\n  /**\n   * Array of additional headers that should be excluded during matching.\n   */\n  excludedHeaders?: string[];\n  /**\n   * By default, the test-proxy does not sort query params before matching. Setting true will sort query params alphabetically before comparing URI.\n   */\n  ignoreQueryOrdering?: boolean;\n}\n\n/**\n * Body the customer matcher expects.\n *\n * // Ignored Headers option is not exposed to the users as of now.\n * // If needed, this can be moved into CustomMatcherOptions.\n */\ninterface InternalCustomMatcherOptions extends CustomMatcherOptions {\n  /**\n   * Array of additional headers that should be ignored during matching.\n   * Any headers that are \"ignored\" will not do value comparison when matching.\n   * This means that if the recording has a header that isn't in the request, a test mismatch exception will be thrown noting the lack of header in the request.\n   *\n   * This also applies if the header is present in the request but not recording.\n   */\n  ignoredHeaders?: string[];\n}\n\nexport async function setMatcher(\n  recorderUrl: string,\n  httpClient: HttpClient,\n  matcher: Matcher,\n  recordingId?: string,\n  matcherBody: InternalCustomMatcherOptions = { compareBodies: true, ignoreQueryOrdering: false },\n): Promise<void> {\n  const url = `${recorderUrl}${paths.admin}${paths.setMatcher}`;\n\n  const request = createPipelineRequest({ url, method: \"POST\", allowInsecureConnection: true });\n  request.headers.set(\"x-abstraction-identifier\", matcher);\n  if (recordingId) {\n    request.headers.set(\"x-recording-id\", recordingId);\n  }\n  if (matcherBody) {\n    request.body = JSON.stringify({\n      compareBodies: matcherBody.compareBodies,\n      excludedHeaders: matcherBody.excludedHeaders?.toString(),\n      ignoredHeaders: matcherBody.ignoredHeaders?.toString(),\n      ignoreQueryOrdering: matcherBody.ignoreQueryOrdering,\n    });\n  }\n\n  logger.info(\"[setMatcher] Setting matcher\", matcher, matcherBody);\n  const response = await httpClient.sendRequest(request);\n  const { status, bodyAsText } = response;\n\n  if (status < 200 || status > 299) {\n    logger.error(\"[setMatcher] setMatcher failed\", response);\n    throw new RecorderError(`setMatcher failed: ${bodyAsText}`, status);\n  }\n}\n"]}