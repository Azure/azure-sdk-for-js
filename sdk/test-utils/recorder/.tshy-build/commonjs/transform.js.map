{"version":3,"file":"transform.js","sourceRoot":"","sources":["../../src/transform.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;AA2BlC,oCA2BC;AApDD,kEAA8E;AAC9E,+CAAyC;AACzC,+CAAiD;AACjD,qCAAkC;AAsB3B,KAAK,UAAU,YAAY,CAChC,WAAmB,EACnB,UAAsB,EACtB,SAAoB,EACpB,WAAmB;;IAEnB,MAAM,GAAG,GAAG,GAAG,WAAW,GAAG,gBAAK,CAAC,KAAK,GAAG,gBAAK,CAAC,YAAY,EAAE,CAAC;IAEhE,MAAM,OAAO,GAAG,IAAA,0CAAqB,EAAC,EAAE,GAAG,EAAE,MAAM,EAAE,MAAM,EAAE,uBAAuB,EAAE,IAAI,EAAE,CAAC,CAAC;IAC9F,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,0BAA0B,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC;IAChE,IAAI,WAAW,EAAE,CAAC;QAChB,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,EAAE,WAAW,CAAC,CAAC;IACrD,CAAC;IAED,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,iCACxB,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,cAAc,EAAE,SAAS,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,GAC9E,CAAC,MAAC,SAAkD,CAAC,MAAM,mCAAI,EAAE,CAAC,EACrE,CAAC;IAEH,eAAM,CAAC,IAAI,CAAC,iCAAiC,EAAE,SAAS,CAAC,CAAC;IAC1D,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IACvD,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG,QAAQ,CAAC;IAExC,IAAI,MAAM,GAAG,GAAG,IAAI,MAAM,GAAG,GAAG,EAAE,CAAC;QACjC,eAAM,CAAC,KAAK,CAAC,oCAAoC,EAAE,QAAQ,CAAC,CAAC;QAC7D,MAAM,IAAI,wBAAa,CAAC,wBAAwB,UAAU,EAAE,EAAE,MAAM,CAAC,CAAC;IACxE,CAAC;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { createPipelineRequest, HttpClient } from \"@azure/core-rest-pipeline\";\nimport { paths } from \"./utils/paths.js\";\nimport { RecorderError } from \"./utils/utils.js\";\nimport { logger } from \"./log.js\";\n\ninterface ApplyCondition {\n  uriRegex: string;\n}\n\ntype TransformType<TType extends string, TParams = undefined> = {\n  type: TType;\n  applyCondition?: ApplyCondition;\n} & (TParams extends undefined ? unknown : { params: TParams });\n\ninterface HeaderTransformParams {\n  key: string;\n  value: string;\n}\n\nexport type Transform =\n  | TransformType<\"ApiVersionTransform\">\n  | TransformType<\"ClientIdTransform\">\n  | TransformType<\"StorageRequestIdTransform\">\n  | TransformType<\"HeaderTransform\", HeaderTransformParams>;\n\nexport async function addTransform(\n  recorderUrl: string,\n  httpClient: HttpClient,\n  transform: Transform,\n  recordingId: string,\n): Promise<void> {\n  const url = `${recorderUrl}${paths.admin}${paths.addTransform}`;\n\n  const request = createPipelineRequest({ url, method: \"POST\", allowInsecureConnection: true });\n  request.headers.set(\"x-abstraction-identifier\", transform.type);\n  if (recordingId) {\n    request.headers.set(\"x-recording-id\", recordingId);\n  }\n\n  request.body = JSON.stringify({\n    ...(transform.applyCondition ? { applyCondition: transform.applyCondition } : {}),\n    ...((transform as { params?: Record<string, unknown> }).params ?? {}),\n  });\n\n  logger.info(\"[addTransform] Adding transform\", transform);\n  const response = await httpClient.sendRequest(request);\n  const { status, bodyAsText } = response;\n\n  if (status < 200 || status > 299) {\n    logger.error(\"[addTransform] addTransform failed\", response);\n    throw new RecorderError(`addTransform failed: ${bodyAsText}`, status);\n  }\n}\n"]}