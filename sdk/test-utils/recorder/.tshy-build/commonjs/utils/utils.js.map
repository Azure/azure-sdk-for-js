{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/utils/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { env } from \"./env.js\";\n\n/**\n * A custom error type for failed pipeline requests.\n */\nexport class RecorderError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n  ) {\n    super(message);\n    this.name = \"RecorderError\";\n    this.statusCode = statusCode;\n  }\n}\n\nexport type RecordingState = \"started\" | \"stopped\";\n/**\n * Helper class to manage the recording state to make sure the proxy-tool is not flooded with unintended requests.\n */\nexport class RecordingStateManager {\n  private currentState: RecordingState = \"stopped\";\n\n  /**\n   * validateState\n   */\n  private validateState(nextState: RecordingState): void {\n    if (nextState === \"started\") {\n      if (this.state === \"started\") {\n        throw new RecorderError(\"Already started, should not have called start again.\");\n      }\n    }\n    if (nextState === \"stopped\") {\n      if (this.state === \"stopped\") {\n        throw new RecorderError(\"Already stopped, should not have called stop again.\");\n      }\n    }\n  }\n\n  public get state(): RecordingState {\n    return this.currentState;\n  }\n\n  public set state(nextState: RecordingState) {\n    // Validate state transition\n    this.validateState(nextState);\n    this.currentState = nextState;\n  }\n}\n\n/**\n * Keywords that should be passed as part of the headers(except for \"Reset\") to the proxy-tool to be able to leverage the sanitizer.\n *\n * \"x-abstraction-identifier\" - header\n */\nexport type ProxyToolSanitizers =\n  | \"GeneralRegexSanitizer\"\n  | \"GeneralStringSanitizer\"\n  | \"RemoveHeaderSanitizer\"\n  | \"BodyKeySanitizer\"\n  | \"BodyRegexSanitizer\"\n  | \"BodyStringSanitizer\"\n  | \"ContinuationSanitizer\"\n  | \"HeaderRegexSanitizer\"\n  | \"HeaderStringSanitizer\"\n  | \"OAuthResponseSanitizer\"\n  | \"UriRegexSanitizer\"\n  | \"UriStringSanitizer\"\n  | \"UriSubscriptionIdSanitizer\"\n  | \"Reset\";\n\n/**\n * This sanitizer offers a general regex replace across request/response Body, Headers, and URI. For the body, this means regex applying to the raw JSON.\n */\nexport interface RegexSanitizer {\n  /**\n   * Set to true to show that regex replacement is to be used.\n   */\n  regex: true;\n\n  /**\n   * The substitution value.\n   */\n  value: string;\n\n  /**\n   * A regex. Can be defined as a simple regex replace OR if groupForReplace is set, a substitution operation.\n   */\n  target: string;\n  /**\n   * The capture group that needs to be operated upon. Do not set if you're invoking a simple replacement operation.\n   */\n  groupForReplace?: string;\n}\n\n/**\n * A sanitizer that performs a simple find/replace based on a plain string.\n */\nexport interface StringSanitizer {\n  /**\n   * If regex is set to false or is not specified, plain-text matching will be performed.\n   */\n  regex?: false;\n\n  /**\n   * The string to be replaced.\n   */\n  target: string;\n\n  /**\n   * The value that the string should be replaced with.\n   */\n  value: string;\n}\n\nexport type FindReplaceSanitizer = RegexSanitizer | StringSanitizer;\n\nexport function isStringSanitizer(sanitizer: FindReplaceSanitizer): sanitizer is StringSanitizer {\n  return !sanitizer.regex;\n}\n\n/**\n * This sanitizer offers regex update of a specific JTokenPath.\n *\n * EG: \"TableName\" within a json response body having its value replaced by whatever substitution is offered.\n * This simply means that if you are attempting to replace a specific key wholesale, this sanitizer will be simpler\n * than configuring a BodyRegexSanitizer that has to match against the full \"KeyName\": \"Value\" that is part of the json structure.\n *\n * Further reading is available [here](https://www.newtonsoft.com/json/help/html/SelectToken.htm#SelectTokenJSONPath).\n *\n * If the body is NOT a JSON object, this sanitizer will NOT be applied.\n */\nexport type BodyKeySanitizer = {\n  regex?: string;\n\n  value?: string;\n\n  groupForReplace?: string;\n\n  /**\n   * The SelectToken path (which could possibly match multiple entries) that will be used to select JTokens for value replacement.\n   */\n  jsonPath: string;\n};\n\n/**\n * Can be used for multiple purposes:\n *\n * 1) To replace a key with a specific value, do not set \"regex\" value.\n * 2) To do a simple regex replace operation, define arguments \"key\", \"value\", and \"regex\"\n * 3) To do a targeted substitution of a specific group, define all arguments \"key\", \"value\", and \"regex\"\n */\nexport interface HeaderSanitizer {\n  key: string;\n\n  regex?: boolean;\n  target?: string;\n  value?: string;\n  groupForReplace?: string;\n}\n\n/**\n * Internally,\n * - connection strings are parsed and\n * - each part of the connection string is mapped with its corresponding fake value\n * - `generalRegexSanitizer` is applied for each of the parts with the real and fake values that are parsed\n */\nexport interface ConnectionStringSanitizer {\n  /**\n   * Real connection string with all the secrets\n   */\n  actualConnString?: string;\n  /**\n   * Fake connection string - with all the parts of the connection string mapped to fake values\n   */\n  fakeConnString: string;\n}\n\nexport interface ContinuationSanitizer {\n  key: string;\n  method?: string;\n  resetAfterFirst: boolean;\n}\n\nexport interface RemoveHeaderSanitizer {\n  headersForRemoval: string[];\n}\n\n/**\n * Test-proxy tool supports \"extensions\" or \"customizations\" to the recording experience.\n * This means that non-default sanitizations such as the generalized regex find/replace on different parts of the recordings in various ways are possible.\n */\nexport interface SanitizerOptions {\n  /**\n   * This sanitizer offers a general regex replace across request/response Body, Headers, and URI. For the body, this means regex applying to the raw JSON.\n   */\n  generalSanitizers?: FindReplaceSanitizer[];\n\n  /**\n   * This sanitizer offers regex replace within a returned body.\n   *\n   * Specifically, this means regex applying to the raw JSON.\n   * If you are attempting to simply replace a specific key, the BodyKeySanitizer is probably the way to go.\n   *\n   * Regardless, there are examples present in `recorder/test/testProxyTests.spec.ts`.\n   */\n  bodySanitizers?: FindReplaceSanitizer[];\n  /**\n   * Can be used for multiple purposes:\n   *\n   * 1) To replace a key with a specific value, do not set \"regex\" value.\n   * 2) To do a simple regex replace operation, define arguments \"key\", \"value\", and \"regex\"\n   * 3) To do a targeted substitution of a specific group, define all arguments \"key\", \"value\", and \"regex\"\n   */\n  headerSanitizers?: HeaderSanitizer[];\n  /**\n   * General use sanitizer for cleaning URIs via regex. Runs a regex replace on the member of your choice.\n   */\n  uriSanitizers?: FindReplaceSanitizer[];\n  /**\n   * Internally,\n   * - connection strings are parsed and\n   * - each part of the connection string is mapped with its corresponding fake value\n   * - `generalRegexSanitizer` is applied for each of the parts with the real and fake values that are parsed\n   */\n  connectionStringSanitizers?: ConnectionStringSanitizer[];\n\n  /**\n   * This sanitizer offers regex update of a specific JTokenPath.\n   *\n   * EG: \"TableName\" within a json response body having its value replaced by whatever substitution is offered.\n   * This simply means that if you are attempting to replace a specific key wholesale, this sanitizer will be simpler\n   * than configuring a BodyRegexSanitizer that has to match against the full \"KeyName\": \"Value\" that is part of the json structure.\n   *\n   * Further reading is available [here](https://www.newtonsoft.com/json/help/html/SelectToken.htm#SelectTokenJSONPath).\n   *\n   * If the body is NOT a JSON object, this sanitizer will NOT be applied.\n   */\n  bodyKeySanitizers?: BodyKeySanitizer[];\n\n  /**\n   * TODO\n   * Has a bug, not implemented fully.\n   */\n  continuationSanitizers?: ContinuationSanitizer[];\n\n  /**\n   * A simple sanitizer that should be used to clean out one or multiple headers by their key.\n   * Removes headers from before saving a recording.\n   */\n  removeHeaderSanitizer?: RemoveHeaderSanitizer;\n\n  /**\n   * TODO: To be tested with scenarios, not to be used yet.\n   */\n  oAuthResponseSanitizer?: boolean;\n\n  /**\n   * This sanitizer relies on UriRegexSanitizer to replace real subscriptionIds within a URI w/ a default or configured fake value.\n   * This sanitizer is targeted using the regex \"/subscriptions/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\". This is not a setting that can be changed for this sanitizer. For full regex support, take a look at UriRegexSanitizer. You CAN modify the value that the subscriptionId is replaced WITH however.\n   */\n  uriSubscriptionIdSanitizer?: {\n    /**\n     * The fake subscriptionId that will be placed where the real one is in the real request. The default replacement value is \"00000000-0000-0000-0000-000000000000\".\n     */\n    value: string;\n  };\n\n  /**\n   * This clears the sanitizers that are added.\n   */\n  resetSanitizer?: boolean;\n}\n\n/**\n * Used in record and playback modes. No effect in live mode.\n *\n * Options to be provided as part of the `recorder.start()` call.\n */\nexport interface RecorderStartOptions {\n  /**\n   * Used in record and playback modes. No effect in live mode.\n   *\n   *  1. The key-value pairs will be used as the environment variables in playback mode.\n   *  2. If the env variables are present in the recordings as plain strings, they will be replaced with the provided values in record mode\n   */\n  envSetupForPlayback: Record<string, string>;\n  /**\n   * Used in record mode. No effect in playback and live modes.\n   *\n   * Generated recordings are updated by the \"proxy-tool\" based on the sanitizer options provided.\n   */\n  sanitizerOptions?: SanitizerOptions;\n  /**\n   * When a service uses a custom SSL certificate to communicate with the client.\n   */\n  tlsValidationCert?: string;\n  /**\n   * Central test-proxy sanitizers to be disabled\n   *\n   * More info:\n   *\n   *  https://github.com/Azure/azure-sdk-tools/pull/8142/\n   *  https://github.com/Azure/azure-sdk-tools/blob/main/tools/test-proxy/Azure.Sdk.Tools.TestProxy/Common/SanitizerDictionary.cs\n   */\n  removeCentralSanitizers?: string[];\n}\n\n/**\n * Throws error message when the `label` is not defined when it should have been defined in the given mode.\n *\n * Returns true if the param exists.\n */\nexport function ensureExistence<T>(thing: T | undefined, label: string): thing is T {\n  if (!thing) {\n    throw new RecorderError(\n      `Something went wrong, ${label} should not have been undefined in \"${getTestMode()}\" mode.`,\n    );\n  }\n  return true; // Since we would throw error if undefined\n}\n\nexport type TestMode = \"record\" | \"playback\" | \"live\";\n\n/**\n * Returns the test mode.\n *\n * If TEST_MODE is not defined, defaults to playback.\n */\nexport function getTestMode(): TestMode {\n  if (isPlaybackMode()) {\n    return \"playback\";\n  }\n  return env.TEST_MODE?.toLowerCase() as \"record\" | \"live\";\n}\n\n/** Make a lazy value that can be deferred and only computed once. */\nexport const once = <T>(make: () => T): (() => T) => {\n  let value: T;\n  return () => (value = value ?? make());\n};\n\nexport function isRecordMode(): boolean {\n  return env.TEST_MODE?.toLowerCase() === \"record\";\n}\n\nexport function isLiveMode(): boolean {\n  return env.TEST_MODE?.toLowerCase() === \"live\";\n}\n\nexport function isPlaybackMode(): boolean {\n  return !isRecordMode() && !isLiveMode();\n}\n\n/**\n * Loads the environment variables in both node and browser modes corresponding to the key-value pairs provided.\n *\n * Example-\n *\n * Suppose `variables` is { ACCOUNT_NAME: \"my_account_name\", ACCOUNT_KEY: \"fake_secret\" },\n * `setEnvironmentVariables` loads the ACCOUNT_NAME and ACCOUNT_KEY in the environment accordingly.\n */\nexport function setEnvironmentVariables(variables: { [key: string]: string }): void {\n  for (const [key, value] of Object.entries(variables)) {\n    env[key] = value;\n  }\n}\n\n/**\n * Returns the environment variable. Throws error if not defined.\n */\nexport function assertEnvironmentVariable(variable: string): string {\n  const value = env[variable];\n  if (!value) throw new Error(`${variable} is not defined`);\n  return value;\n}\n\n/**\n * Polling options that don't wait in playback mode.\n */\nexport const testPollingOptions = {\n  updateIntervalInMs: isPlaybackMode() ? 0 : undefined,\n};\n"]}