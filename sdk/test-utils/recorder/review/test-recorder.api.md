## API Report File for "@azure-tools/test-recorder"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AdditionalPolicyConfig } from '@azure/core-client';
import { HttpClient } from '@azure/core-http';
import { Test } from 'mocha';

// @public
export function assertEnvironmentVariable(variable: string): string;

// @public
export type BodyKeySanitizer = {
    regex?: string;
    value?: string;
    groupForReplace?: string;
    jsonPath: string;
};

// @public
export interface ConnectionStringSanitizer {
    actualConnString?: string;
    fakeConnString: string;
}

// @public (undocumented)
export interface ContinuationSanitizer {
    // (undocumented)
    key: string;
    // (undocumented)
    method?: string;
    // (undocumented)
    resetAfterFirst: boolean;
}

// @public
export interface CustomMatcherOptions {
    compareBodies?: boolean;
    excludedHeaders?: string[];
    ignoreQueryOrdering?: boolean;
}

// @public
export function delay(milliseconds: number): Promise<void> | void;

// @public (undocumented)
export const env: Record<string, string | undefined>;

// @public (undocumented)
export type FindReplaceSanitizer = RegexSanitizer | StringSanitizer;

// @public
export interface HeaderSanitizer {
    // (undocumented)
    groupForReplace?: string;
    // (undocumented)
    key: string;
    // (undocumented)
    regex?: boolean;
    // (undocumented)
    target?: string;
    // (undocumented)
    value?: string;
}

// @public (undocumented)
export interface HeaderTransformParams {
    // (undocumented)
    key: string;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export function isLiveMode(): boolean;

// @public (undocumented)
export function isPlaybackMode(): boolean;

// @public (undocumented)
export function isRecordMode(): boolean;

// @public
export class Recorder {
    constructor(testContext?: Test | undefined);
    addSanitizers(options: SanitizerOptions, mode?: ("record" | "playback")[]): Promise<void>;
    // (undocumented)
    addTransform(transform: Transform): Promise<void>;
    configureClientOptions<T>(options: T & {
        additionalPolicies?: AdditionalPolicyConfig[];
    }): T & {
        additionalPolicies?: AdditionalPolicyConfig[];
    };
    configureClientOptionsCoreV1<T>(options: T & {
        httpClient?: HttpClient;
    }): T & {
        httpClient?: HttpClient;
    };
    // (undocumented)
    recordingId?: string;
    setMatcher(matcher: "HeaderlessMatcher" | "BodilessMatcher"): Promise<void>;
    setMatcher(matcher: "CustomDefaultMatcher", options?: CustomMatcherOptions): Promise<void>;
    start(options: RecorderStartOptions): Promise<void>;
    stop(): Promise<void>;
    // (undocumented)
    transformsInfo(): Promise<string | null | undefined>;
    variable(name: string, value: string): string;
    variable(name: string): string;
}

// @public
export interface RecorderStartOptions {
    envSetupForPlayback: Record<string, string>;
    sanitizerOptions?: SanitizerOptions;
}

// @public
export interface RegexSanitizer {
    groupForReplace?: string;
    regex: true;
    target: string;
    value: string;
}

// @public
export function relativeRecordingsPath(): string;

// @public (undocumented)
export interface RemoveHeaderSanitizer {
    // (undocumented)
    headersForRemoval: string[];
}

// @public
export interface SanitizerOptions {
    bodyKeySanitizers?: BodyKeySanitizer[];
    bodySanitizers?: FindReplaceSanitizer[];
    connectionStringSanitizers?: ConnectionStringSanitizer[];
    continuationSanitizers?: ContinuationSanitizer[];
    generalSanitizers?: FindReplaceSanitizer[];
    headerSanitizers?: HeaderSanitizer[];
    oAuthResponseSanitizer?: boolean;
    removeHeaderSanitizer?: RemoveHeaderSanitizer;
    resetSanitizer?: boolean;
    uriSanitizers?: FindReplaceSanitizer[];
    uriSubscriptionIdSanitizer?: {
        value: string;
    };
}

// @public
export interface StringSanitizer {
    regex?: false;
    target: string;
    value: string;
}

// @public (undocumented)
export type Transform = TransformType<"ApiVersionTransform"> | TransformType<"ClientIdTransform"> | TransformType<"StorageRequestIdTransform"> | TransformType<"HeaderTransform", HeaderTransformParams>;

// @public (undocumented)
export type TransformType<TType extends string, TParams = undefined> = {
    type: TType;
    applyCondition?: {
        uriRegex: string;
    };
} & (TParams extends undefined ? unknown : {
    params: TParams;
});

// (No @packageDocumentation comment for this package)

```
