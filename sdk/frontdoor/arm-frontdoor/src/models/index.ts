/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError, AzureServiceClientOptions } from "@azure/ms-rest-azure-js";
import * as msRest from "@azure/ms-rest-js";

export { BaseResource, CloudError };

/**
 * An interface representing ErrorDetails.
 */
export interface ErrorDetails {
  code?: string;
  target?: string;
  message?: string;
}

/**
 * An interface representing ErrorModel.
 */
export interface ErrorModel {
  code?: string;
  message?: string;
  target?: string;
  details?: ErrorDetails[];
  innerError?: string;
}

/**
 * The response body contains the status of the specified asynchronous operation, indicating
 * whether it has succeeded, is in progress, or has failed. Note that this status is distinct from
 * the HTTP status code returned for the Get Operation Status operation itself. If the asynchronous
 * operation succeeded, the response body includes the HTTP status code for the successful request.
 * If the asynchronous operation failed, the response body includes the HTTP status code for the
 * failed request and error information regarding the failure.
 */
export interface AzureAsyncOperationResult {
  /**
   * Status of the Azure async operation. Possible values are: 'InProgress', 'Succeeded', and
   * 'Failed'. Possible values include: 'InProgress', 'Succeeded', 'Failed'
   */
  status?: NetworkOperationStatus;
  error?: ErrorModel;
}

/**
 * Common resource representation.
 */
export interface Resource extends BaseResource {
  /**
   * Resource ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
  /**
   * Resource name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * Resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
  /**
   * Resource location.
   */
  location?: string;
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Reference to another subresource.
 */
export interface SubResource extends BaseResource {
  /**
   * Resource ID.
   */
  id?: string;
}

/**
 * Tags object for patch operations.
 */
export interface TagsObject {
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Defines an Network Experiment Profile and lists of Experiments
 */
export interface Profile extends Resource {
  /**
   * Resource status. Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling',
   * 'Disabled', 'Deleting'
   */
  resourceState?: NetworkExperimentResourceState;
  /**
   * The state of the Experiment. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: State;
  /**
   * Gets a unique read-only string that changes whenever the resource is updated.
   */
  etag?: string;
}

/**
 * Defines the endpoint properties
 */
export interface Endpoint {
  /**
   * The name of the endpoint
   */
  name?: string;
  /**
   * The endpoint URL
   */
  endpoint?: string;
}

/**
 * Defines modifiable attributes of a Profile
 */
export interface ProfileUpdateModel {
  /**
   * The enabled state of the Profile. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: State;
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Defines modifiable attributes of an Experiment
 */
export interface ExperimentUpdateModel {
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * The description of the intent or details of the Experiment
   */
  description?: string;
  /**
   * The state of the Experiment. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: State;
}

/**
 * Defines the properties of an Experiment
 */
export interface Experiment extends Resource {
  /**
   * The description of the details or intents of the Experiment
   */
  description?: string;
  /**
   * The endpoint A of an experiment
   */
  endpointA?: Endpoint;
  /**
   * The endpoint B of an experiment
   */
  endpointB?: Endpoint;
  /**
   * The state of the Experiment. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: State;
  /**
   * Resource status. Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling',
   * 'Disabled', 'Deleting'
   */
  resourceState?: NetworkExperimentResourceState;
  /**
   * The description of Experiment status from the server side
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: string;
  /**
   * The uri to the Script used in the Experiment
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly scriptFileUri?: string;
}

/**
 * Defines the properties of a latency metric used in the latency scorecard
 */
export interface LatencyMetric {
  /**
   * The name of the Latency Metric
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The end time of the Latency Scorecard in UTC
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly endDateTimeUTC?: string;
  /**
   * The metric value of the A endpoint
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly aValue?: number;
  /**
   * The metric value of the B endpoint
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly bValue?: number;
  /**
   * The difference in value between endpoint A and B
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly delta?: number;
  /**
   * The percent difference between endpoint A and B
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deltaPercent?: number;
  /**
   * The lower end of the 95% confidence interval for endpoint A
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly aCLower95CI?: number;
  /**
   * The upper end of the 95% confidence interval for endpoint A
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly aHUpper95CI?: number;
  /**
   * The lower end of the 95% confidence interval for endpoint B
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly bCLower95CI?: number;
  /**
   * The upper end of the 95% confidence interval for endpoint B
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly bUpper95CI?: number;
}

/**
 * Defines the LatencyScorecard
 */
export interface LatencyScorecard extends Resource {
  /**
   * The unique identifier of the Latency Scorecard
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly latencyScorecardId?: string;
  /**
   * The name of the Latency Scorecard
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly latencyScorecardName?: string;
  /**
   * The description of the Latency Scorecard
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly description?: string;
  /**
   * The A endpoint in the scorecard
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly endpointA?: string;
  /**
   * The B endpoint in the scorecard
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly endpointB?: string;
  /**
   * The start time of the Latency Scorecard in UTC
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly startDateTimeUTC?: Date;
  /**
   * The end time of the Latency Scorecard in UTC
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly endDateTimeUTC?: Date;
  /**
   * The country associated with the Latency Scorecard. Values are country ISO codes as specified
   * here- https://www.iso.org/iso-3166-country-codes.html
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly country?: string;
  /**
   * The latency metrics of the Latency Scorecard
   */
  latencyMetrics?: LatencyMetric[];
}

/**
 * Defines a timeseries datapoint used in a timeseries
 */
export interface TimeseriesDataPoint {
  /**
   * The DateTime of the Timeseries data point in UTC
   */
  dateTimeUTC?: string;
  /**
   * The Value of the Timeseries data point
   */
  value?: number;
}

/**
 * Defines the Timeseries
 */
export interface Timeseries extends Resource {
  /**
   * The endpoint associated with the Timeseries data point
   */
  endpoint?: string;
  /**
   * The start DateTime of the Timeseries in UTC
   */
  startDateTimeUTC?: string;
  /**
   * The end DateTime of the Timeseries in UTC
   */
  endDateTimeUTC?: string;
  /**
   * The aggregation interval of the Timeseries. Possible values include: 'Hourly', 'Daily'
   */
  aggregationInterval?: AggregationInterval;
  /**
   * The type of Timeseries. Possible values include: 'MeasurementCounts', 'LatencyP50',
   * 'LatencyP75', 'LatencyP95'
   */
  timeseriesType?: TimeseriesType;
  /**
   * The country associated with the Timeseries. Values are country ISO codes as specified here-
   * https://www.iso.org/iso-3166-country-codes.html
   */
  country?: string;
  /**
   * The set of data points for the timeseries
   */
  timeseriesData?: TimeseriesDataPoint[];
}

/**
 * Defines the properties of a preconfigured endpoint
 */
export interface PreconfiguredEndpoint extends Resource {
  /**
   * The description of the endpoint
   */
  description?: string;
  /**
   * The endpoint that is preconfigured
   */
  endpoint?: string;
  /**
   * The type of endpoint. Possible values include: 'AFD', 'AzureRegion', 'CDN', 'ATM'
   */
  endpointType?: EndpointType;
  /**
   * The preconfigured endpoint backend
   */
  backend?: string;
}

/**
 * Error response indicates Front Door service is not able to process the incoming request. The
 * reason is provided in the error message.
 */
export interface ErrorResponse {
  /**
   * Error code.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly code?: string;
  /**
   * Error message indicating why the operation failed.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
}

/**
 * A rules engine configuration containing a list of rules that will run to modify the runtime
 * behavior of the request and response.
 */
export interface RulesEngine extends BaseResource {
  /**
   * A list of rules that define a particular Rules Engine Configuration.
   */
  rules?: RulesEngineRule[];
  /**
   * Resource status. Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling',
   * 'Disabled', 'Deleting'
   */
  resourceState?: FrontDoorResourceState;
  /**
   * Resource name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * Resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
  /**
   * Resource ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
}

/**
 * Front Door represents a collection of backend endpoints to route traffic to along with rules
 * that specify how traffic is sent there.
 */
export interface FrontDoor extends Resource {
  /**
   * A friendly name for the frontDoor
   */
  friendlyName?: string;
  /**
   * Routing rules associated with this Front Door.
   */
  routingRules?: RoutingRule[];
  /**
   * Load balancing settings associated with this Front Door instance.
   */
  loadBalancingSettings?: LoadBalancingSettingsModel[];
  /**
   * Health probe settings associated with this Front Door instance.
   */
  healthProbeSettings?: HealthProbeSettingsModel[];
  /**
   * Backend pools available to routing rules.
   */
  backendPools?: BackendPool[];
  /**
   * Frontend endpoints available to routing rules.
   */
  frontendEndpoints?: FrontendEndpoint[];
  /**
   * Settings for all backendPools
   */
  backendPoolsSettings?: BackendPoolsSettings;
  /**
   * Operational status of the Front Door load balancer. Permitted values are 'Enabled' or
   * 'Disabled'. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: FrontDoorEnabledState;
  /**
   * Resource status of the Front Door. Possible values include: 'Creating', 'Enabling', 'Enabled',
   * 'Disabling', 'Disabled', 'Deleting'
   */
  resourceState?: FrontDoorResourceState;
  /**
   * Provisioning state of the Front Door.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The host that each frontendEndpoint must CNAME to.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly cname?: string;
  /**
   * The Id of the frontdoor.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly frontdoorId?: string;
  /**
   * Rules Engine Configurations available to routing rules.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly rulesEngines?: RulesEngine[];
}

/**
 * A routing rule represents a specification for traffic to treat and where to send it, along with
 * health probe information.
 */
export interface RoutingRule extends SubResource {
  /**
   * Frontend endpoints associated with this rule
   */
  frontendEndpoints?: SubResource[];
  /**
   * Protocol schemes to match for this rule
   */
  acceptedProtocols?: FrontDoorProtocol[];
  /**
   * The route patterns of the rule.
   */
  patternsToMatch?: string[];
  /**
   * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'. Possible
   * values include: 'Enabled', 'Disabled'
   */
  enabledState?: RoutingRuleEnabledState;
  /**
   * A reference to the routing configuration.
   */
  routeConfiguration?: RouteConfigurationUnion;
  /**
   * A reference to a specific Rules Engine Configuration to apply to this route.
   */
  rulesEngine?: SubResource;
  /**
   * Resource status. Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling',
   * 'Disabled', 'Deleting'
   */
  resourceState?: FrontDoorResourceState;
  /**
   * Resource name.
   */
  name?: string;
  /**
   * Resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
}

/**
 * Load balancing settings for a backend pool
 */
export interface LoadBalancingSettingsModel extends SubResource {
  /**
   * The number of samples to consider for load balancing decisions
   */
  sampleSize?: number;
  /**
   * The number of samples within the sample period that must succeed
   */
  successfulSamplesRequired?: number;
  /**
   * The additional latency in milliseconds for probes to fall into the lowest latency bucket
   */
  additionalLatencyMilliseconds?: number;
  /**
   * Resource status. Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling',
   * 'Disabled', 'Deleting'
   */
  resourceState?: FrontDoorResourceState;
  /**
   * Resource name.
   */
  name?: string;
  /**
   * Resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
}

/**
 * Load balancing settings for a backend pool
 */
export interface HealthProbeSettingsModel extends SubResource {
  /**
   * The path to use for the health probe. Default is /
   */
  path?: string;
  /**
   * Protocol scheme to use for this probe. Possible values include: 'Http', 'Https'
   */
  protocol?: FrontDoorProtocol;
  /**
   * The number of seconds between health probes.
   */
  intervalInSeconds?: number;
  /**
   * Configures which HTTP method to use to probe the backends defined under backendPools. Possible
   * values include: 'GET', 'HEAD'. Default value: 'HEAD'.
   */
  healthProbeMethod?: FrontDoorHealthProbeMethod;
  /**
   * Whether to enable health probes to be made against backends defined under backendPools. Health
   * probes can only be disabled if there is a single enabled backend in single enabled backend
   * pool. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: HealthProbeEnabled;
  /**
   * Resource status. Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling',
   * 'Disabled', 'Deleting'
   */
  resourceState?: FrontDoorResourceState;
  /**
   * Resource name.
   */
  name?: string;
  /**
   * Resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
}

/**
 * A backend pool is a collection of backends that can be routed to.
 */
export interface BackendPool extends SubResource {
  /**
   * The set of backends for this pool
   */
  backends?: Backend[];
  /**
   * Load balancing settings for a backend pool
   */
  loadBalancingSettings?: SubResource;
  /**
   * L7 health probe settings for a backend pool
   */
  healthProbeSettings?: SubResource;
  /**
   * Resource status. Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling',
   * 'Disabled', 'Deleting'
   */
  resourceState?: FrontDoorResourceState;
  /**
   * Resource name.
   */
  name?: string;
  /**
   * Resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
}

/**
 * The Key Vault containing the SSL certificate
 */
export interface KeyVaultCertificateSourceParametersVault {
  /**
   * Resource ID.
   */
  id?: string;
}

/**
 * Https settings for a domain
 */
export interface CustomHttpsConfiguration {
  /**
   * Defines the source of the SSL certificate. Possible values include: 'AzureKeyVault',
   * 'FrontDoor'
   */
  certificateSource: FrontDoorCertificateSource;
  /**
   * The minimum TLS version required from the clients to establish an SSL handshake with Front
   * Door. Possible values include: '1.0', '1.2'
   */
  minimumTlsVersion: MinimumTLSVersion;
  /**
   * The Key Vault containing the SSL certificate
   */
  vault?: KeyVaultCertificateSourceParametersVault;
  /**
   * The name of the Key Vault secret representing the full certificate PFX
   */
  secretName?: string;
  /**
   * The version of the Key Vault secret representing the full certificate PFX
   */
  secretVersion?: string;
  /**
   * Defines the type of the certificate used for secure connections to a frontendEndpoint.
   * Possible values include: 'Dedicated'
   */
  certificateType?: FrontDoorCertificateType;
}

/**
 * A frontend endpoint used for routing.
 */
export interface FrontendEndpoint extends SubResource {
  /**
   * The host name of the frontendEndpoint. Must be a domain name.
   */
  hostName?: string;
  /**
   * Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'.
   * Possible values include: 'Enabled', 'Disabled'
   */
  sessionAffinityEnabledState?: SessionAffinityEnabledState;
  /**
   * UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if
   * applicable.
   */
  sessionAffinityTtlSeconds?: number;
  /**
   * Defines the Web Application Firewall policy for each host (if applicable)
   */
  webApplicationFirewallPolicyLink?: FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink;
  /**
   * Resource status. Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling',
   * 'Disabled', 'Deleting'
   */
  resourceState?: FrontDoorResourceState;
  /**
   * Provisioning status of Custom Https of the frontendEndpoint. Possible values include:
   * 'Enabling', 'Enabled', 'Disabling', 'Disabled', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly customHttpsProvisioningState?: CustomHttpsProvisioningState;
  /**
   * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by
   * step. Possible values include: 'SubmittingDomainControlValidationRequest',
   * 'PendingDomainControlValidationREquestApproval', 'DomainControlValidationRequestApproved',
   * 'DomainControlValidationRequestRejected', 'DomainControlValidationRequestTimedOut',
   * 'IssuingCertificate', 'DeployingCertificate', 'CertificateDeployed', 'DeletingCertificate',
   * 'CertificateDeleted'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly customHttpsProvisioningSubstate?: CustomHttpsProvisioningSubstate;
  /**
   * The configuration specifying how to enable HTTPS
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly customHttpsConfiguration?: CustomHttpsConfiguration;
  /**
   * Resource name.
   */
  name?: string;
  /**
   * Resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
}

/**
 * Settings that apply to all backend pools.
 */
export interface BackendPoolsSettings {
  /**
   * Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on
   * non-HTTPS requests. Possible values include: 'Enabled', 'Disabled'. Default value: 'Enabled'.
   */
  enforceCertificateNameCheck?: EnforceCertificateNameCheckEnabledState;
  /**
   * Send and receive timeout on forwarding request to the backend. When timeout is reached, the
   * request fails and returns.
   */
  sendRecvTimeoutSeconds?: number;
}

/**
 * The properties needed to update a Front Door
 */
export interface FrontDoorUpdateParameters {
  /**
   * A friendly name for the frontDoor
   */
  friendlyName?: string;
  /**
   * Routing rules associated with this Front Door.
   */
  routingRules?: RoutingRule[];
  /**
   * Load balancing settings associated with this Front Door instance.
   */
  loadBalancingSettings?: LoadBalancingSettingsModel[];
  /**
   * Health probe settings associated with this Front Door instance.
   */
  healthProbeSettings?: HealthProbeSettingsModel[];
  /**
   * Backend pools available to routing rules.
   */
  backendPools?: BackendPool[];
  /**
   * Frontend endpoints available to routing rules.
   */
  frontendEndpoints?: FrontendEndpoint[];
  /**
   * Settings for all backendPools
   */
  backendPoolsSettings?: BackendPoolsSettings;
  /**
   * Operational status of the Front Door load balancer. Permitted values are 'Enabled' or
   * 'Disabled'. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: FrontDoorEnabledState;
}

/**
 * Parameters required for content purge.
 */
export interface PurgeParameters {
  /**
   * The path to the content to be purged. Can describe a file path or a wild card directory.
   */
  contentPaths: string[];
}

/**
 * Result of the request to list Routing Rules. It contains a list of Routing Rule objects and a
 * URL link to get the next set of results.
 */
export interface RoutingRuleListResult {
  /**
   * List of Routing Rules within a Front Door.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly value?: RoutingRule[];
  /**
   * URL to get the next set of RoutingRule objects if there are any.
   */
  nextLink?: string;
}

/**
 * Contains the possible cases for RouteConfiguration.
 */
export type RouteConfigurationUnion = RouteConfiguration | ForwardingConfiguration | RedirectConfiguration;

/**
 * Base class for all types of Route.
 */
export interface RouteConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "RouteConfiguration";
}

/**
 * Routing rules to apply to an endpoint
 */
export interface RoutingRuleUpdateParameters {
  /**
   * Frontend endpoints associated with this rule
   */
  frontendEndpoints?: SubResource[];
  /**
   * Protocol schemes to match for this rule
   */
  acceptedProtocols?: FrontDoorProtocol[];
  /**
   * The route patterns of the rule.
   */
  patternsToMatch?: string[];
  /**
   * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'. Possible
   * values include: 'Enabled', 'Disabled'
   */
  enabledState?: RoutingRuleEnabledState;
  /**
   * A reference to the routing configuration.
   */
  routeConfiguration?: RouteConfigurationUnion;
  /**
   * A reference to a specific Rules Engine Configuration to apply to this route.
   */
  rulesEngine?: SubResource;
}

/**
 * Caching settings for a caching-type route. To disable caching, do not provide a
 * cacheConfiguration object.
 */
export interface CacheConfiguration {
  /**
   * Treatment of URL query terms when forming the cache key. Possible values include: 'StripNone',
   * 'StripAll', 'StripOnly', 'StripAllExcept'
   */
  queryParameterStripDirective?: FrontDoorQuery;
  /**
   * query parameters to include or exclude (comma separated).
   */
  queryParameters?: string;
  /**
   * Whether to use dynamic compression for cached content. Possible values include: 'Enabled',
   * 'Disabled'
   */
  dynamicCompression?: DynamicCompressionEnabled;
  /**
   * The duration for which the content needs to be cached. Allowed format is in ISO 8601 format
   * (http://en.wikipedia.org/wiki/ISO_8601#Durations). HTTP requires the value to be no more than
   * a year
   */
  cacheDuration?: string;
}

/**
 * Describes Forwarding Route.
 */
export interface ForwardingConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration";
  /**
   * A custom path used to rewrite resource paths matched by this rule. Leave empty to use incoming
   * path.
   */
  customForwardingPath?: string;
  /**
   * Protocol this rule will use when forwarding traffic to backends. Possible values include:
   * 'HttpOnly', 'HttpsOnly', 'MatchRequest'
   */
  forwardingProtocol?: FrontDoorForwardingProtocol;
  /**
   * The caching configuration associated with this rule.
   */
  cacheConfiguration?: CacheConfiguration;
  /**
   * A reference to the BackendPool which this rule routes to.
   */
  backendPool?: SubResource;
}

/**
 * Describes Redirect Route.
 */
export interface RedirectConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration";
  /**
   * The redirect type the rule will use when redirecting traffic. Possible values include:
   * 'Moved', 'Found', 'TemporaryRedirect', 'PermanentRedirect'
   */
  redirectType?: FrontDoorRedirectType;
  /**
   * The protocol of the destination to where the traffic is redirected. Possible values include:
   * 'HttpOnly', 'HttpsOnly', 'MatchRequest'
   */
  redirectProtocol?: FrontDoorRedirectProtocol;
  /**
   * Host to redirect. Leave empty to use the incoming host as the destination host.
   */
  customHost?: string;
  /**
   * The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the
   * incoming path as destination path.
   */
  customPath?: string;
  /**
   * Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do
   * not include the #.
   */
  customFragment?: string;
  /**
   * The set of query strings to be placed in the redirect URL. Setting this value would replace
   * any existing query string; leave empty to preserve the incoming query string. Query string
   * must be in <key>=<value> format. The first ? and & will be added automatically so do not
   * include them in the front, but do separate multiple query strings with &.
   */
  customQueryString?: string;
}

/**
 * Backend address of a frontDoor load balancer.
 */
export interface Backend {
  /**
   * Location of the backend (IP address or FQDN)
   */
  address?: string;
  /**
   * The Alias of the Private Link resource. Populating this optional field indicates that this
   * backend is 'Private'
   */
  privateLinkAlias?: string;
  /**
   * The Approval status for the connection to the Private Link. Possible values include:
   * 'Pending', 'Approved', 'Rejected', 'Disconnected', 'Timeout'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly privateEndpointStatus?: PrivateEndpointStatus;
  /**
   * A custom message to be included in the approval request to connect to the Private Link
   */
  privateLinkApprovalMessage?: string;
  /**
   * The HTTP TCP port number. Must be between 1 and 65535.
   */
  httpPort?: number;
  /**
   * The HTTPS TCP port number. Must be between 1 and 65535.
   */
  httpsPort?: number;
  /**
   * Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled'. Possible
   * values include: 'Enabled', 'Disabled'
   */
  enabledState?: BackendEnabledState;
  /**
   * Priority to use for load balancing. Higher priorities will not be used for load balancing if
   * any lower priority backend is healthy.
   */
  priority?: number;
  /**
   * Weight of this endpoint for load balancing purposes.
   */
  weight?: number;
  /**
   * The value to use as the host header sent to the backend. If blank or unspecified, this
   * defaults to the incoming host.
   */
  backendHostHeader?: string;
}

/**
 * Result of the request to list load balancing settings. It contains a list of load balancing
 * settings objects and a URL link to get the next set of results.
 */
export interface LoadBalancingSettingsListResult {
  /**
   * List of Backend Pools within a Front Door.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly value?: LoadBalancingSettingsModel[];
  /**
   * URL to get the next set of LoadBalancingSettings objects if there are any.
   */
  nextLink?: string;
}

/**
 * Round-Robin load balancing settings for a backend pool
 */
export interface LoadBalancingSettingsUpdateParameters {
  /**
   * The number of samples to consider for load balancing decisions
   */
  sampleSize?: number;
  /**
   * The number of samples within the sample period that must succeed
   */
  successfulSamplesRequired?: number;
  /**
   * The additional latency in milliseconds for probes to fall into the lowest latency bucket
   */
  additionalLatencyMilliseconds?: number;
}

/**
 * Result of the request to list HealthProbeSettings. It contains a list of HealthProbeSettings
 * objects and a URL link to get the next set of results.
 */
export interface HealthProbeSettingsListResult {
  /**
   * List of HealthProbeSettings within a Front Door.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly value?: HealthProbeSettingsModel[];
  /**
   * URL to get the next set of HealthProbeSettings objects if there are any.
   */
  nextLink?: string;
}

/**
 * L7 health probe settings for a backend pool
 */
export interface HealthProbeSettingsUpdateParameters {
  /**
   * The path to use for the health probe. Default is /
   */
  path?: string;
  /**
   * Protocol scheme to use for this probe. Possible values include: 'Http', 'Https'
   */
  protocol?: FrontDoorProtocol;
  /**
   * The number of seconds between health probes.
   */
  intervalInSeconds?: number;
  /**
   * Configures which HTTP method to use to probe the backends defined under backendPools. Possible
   * values include: 'GET', 'HEAD'. Default value: 'HEAD'.
   */
  healthProbeMethod?: FrontDoorHealthProbeMethod;
  /**
   * Whether to enable health probes to be made against backends defined under backendPools. Health
   * probes can only be disabled if there is a single enabled backend in single enabled backend
   * pool. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: HealthProbeEnabled;
}

/**
 * A collection of backends that can be routed to.
 */
export interface BackendPoolUpdateParameters {
  /**
   * The set of backends for this pool
   */
  backends?: Backend[];
  /**
   * Load balancing settings for a backend pool
   */
  loadBalancingSettings?: SubResource;
  /**
   * L7 health probe settings for a backend pool
   */
  healthProbeSettings?: SubResource;
}

/**
 * Result of the request to list Backend Pools. It contains a list of Backend Pools objects and a
 * URL link to get the next set of results.
 */
export interface BackendPoolListResult {
  /**
   * List of Backend Pools within a Front Door.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly value?: BackendPool[];
  /**
   * URL to get the next set of BackendPool objects if there are any.
   */
  nextLink?: string;
}

/**
 * Defines the Web Application Firewall policy for each host (if applicable)
 */
export interface FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink {
  /**
   * Resource ID.
   */
  id?: string;
}

/**
 * Frontend endpoint used in routing rule
 */
export interface FrontendEndpointUpdateParameters {
  /**
   * The host name of the frontendEndpoint. Must be a domain name.
   */
  hostName?: string;
  /**
   * Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'.
   * Possible values include: 'Enabled', 'Disabled'
   */
  sessionAffinityEnabledState?: SessionAffinityEnabledState;
  /**
   * UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if
   * applicable.
   */
  sessionAffinityTtlSeconds?: number;
  /**
   * Defines the Web Application Firewall policy for each host (if applicable)
   */
  webApplicationFirewallPolicyLink?: FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink;
}

/**
 * An action that can manipulate an http header.
 */
export interface HeaderAction {
  /**
   * Which type of manipulation to apply to the header. Possible values include: 'Append',
   * 'Delete', 'Overwrite'
   */
  headerActionType: HeaderActionType;
  /**
   * The name of the header this action will apply to.
   */
  headerName: string;
  /**
   * The value to update the given header name with. This value is not used if the actionType is
   * Delete.
   */
  value?: string;
}

/**
 * Define a match condition
 */
export interface RulesEngineMatchCondition {
  /**
   * Match Variable. Possible values include: 'IsMobile', 'RemoteAddr', 'RequestMethod',
   * 'QueryString', 'PostArgs', 'RequestUri', 'RequestPath', 'RequestFilename',
   * 'RequestFilenameExtension', 'RequestHeader', 'RequestBody', 'RequestScheme'
   */
  rulesEngineMatchVariable: RulesEngineMatchVariable;
  /**
   * Name of selector in RequestHeader or RequestBody to be matched
   */
  selector?: string;
  /**
   * Describes operator to apply to the match condition. Possible values include: 'Any', 'IPMatch',
   * 'GeoMatch', 'Equal', 'Contains', 'LessThan', 'GreaterThan', 'LessThanOrEqual',
   * 'GreaterThanOrEqual', 'BeginsWith', 'EndsWith'
   */
  rulesEngineOperator: RulesEngineOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * Match values to match against. The operator will apply to each value in here with OR
   * semantics. If any of them match the variable with the given operator this match condition is
   * considered a match.
   */
  rulesEngineMatchValue: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * One or more actions that will execute, modifying the request and/or response.
 */
export interface RulesEngineAction {
  /**
   * A list of header actions to apply from the request from AFD to the origin.
   */
  requestHeaderActions?: HeaderAction[];
  /**
   * A list of header actions to apply from the response from AFD to the client.
   */
  responseHeaderActions?: HeaderAction[];
  /**
   * Override the route configuration.
   */
  routeConfigurationOverride?: RouteConfigurationUnion;
}

/**
 * Contains a list of match conditions, and an action on how to modify the request/response. If
 * multiple rules match, the actions from one rule that conflict with a previous rule overwrite for
 * a singular action, or append in the case of headers manipulation.
 */
export interface RulesEngineRule {
  /**
   * A name to refer to this specific rule.
   */
  name: string;
  /**
   * A priority assigned to this rule.
   */
  priority: number;
  /**
   * Actions to perform on the request and response if all of the match conditions are met.
   */
  action: RulesEngineAction;
  /**
   * A list of match conditions that must meet in order for the actions of this rule to run. Having
   * no match conditions means the actions will always run.
   */
  matchConditions?: RulesEngineMatchCondition[];
  /**
   * If this rule is a match should the rules engine continue running the remaining rules or stop.
   * If not present, defaults to Continue. Possible values include: 'Continue', 'Stop'
   */
  matchProcessingBehavior?: MatchProcessingBehavior;
}

/**
 * Rules Engine Configuration to apply to a Routing Rule.
 */
export interface RulesEngineUpdateParameters {
  /**
   * A list of rules that define a particular Rules Engine Configuration.
   */
  rules?: RulesEngineRule[];
}

/**
 * Input of the custom domain to be validated for DNS mapping.
 */
export interface ValidateCustomDomainInput {
  /**
   * The host name of the custom domain. Must be a domain name.
   */
  hostName: string;
}

/**
 * Output of custom domain validation.
 */
export interface ValidateCustomDomainOutput {
  /**
   * Indicates whether the custom domain is valid or not.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly customDomainValidated?: boolean;
  /**
   * The reason why the custom domain is not valid.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly reason?: string;
  /**
   * Error message describing why the custom domain is not valid.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
}

/**
 * Input of CheckNameAvailability API.
 */
export interface CheckNameAvailabilityInput {
  /**
   * The resource name to validate.
   */
  name: string;
  /**
   * The type of the resource whose name is to be validated. Possible values include:
   * 'Microsoft.Network/frontDoors', 'Microsoft.Network/frontDoors/frontendEndpoints'
   */
  type: ResourceType;
}

/**
 * Output of check name availability API.
 */
export interface CheckNameAvailabilityOutput {
  /**
   * Indicates whether the name is available. Possible values include: 'Available', 'Unavailable'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nameAvailability?: Availability;
  /**
   * The reason why the name is not available.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly reason?: string;
  /**
   * The detailed error message describing why the name is not available.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
}

/**
 * Defines top-level WebApplicationFirewallPolicy configuration settings.
 */
export interface PolicySettings {
  /**
   * Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified.
   * Possible values include: 'Disabled', 'Enabled'
   */
  enabledState?: PolicyEnabledState;
  /**
   * Describes if it is in detection mode or prevention mode at policy level. Possible values
   * include: 'Prevention', 'Detection'
   */
  mode?: PolicyMode;
  /**
   * If action type is redirect, this field represents redirect URL for the client.
   */
  redirectUrl?: string;
  /**
   * If the action type is block, customer can override the response status code.
   */
  customBlockResponseStatusCode?: number;
  /**
   * If the action type is block, customer can override the response body. The body must be
   * specified in base64 encoding.
   */
  customBlockResponseBody?: string;
}

/**
 * Define a match condition.
 */
export interface MatchCondition {
  /**
   * Request variable to compare with. Possible values include: 'RemoteAddr', 'RequestMethod',
   * 'QueryString', 'PostArgs', 'RequestUri', 'RequestHeader', 'RequestBody', 'Cookies',
   * 'SocketAddr'
   */
  matchVariable: MatchVariable;
  /**
   * Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies
   * variables. Default is null.
   */
  selector?: string;
  /**
   * Comparison type to use for matching with the variable value. Possible values include: 'Any',
   * 'IPMatch', 'GeoMatch', 'Equal', 'Contains', 'LessThan', 'GreaterThan', 'LessThanOrEqual',
   * 'GreaterThanOrEqual', 'BeginsWith', 'EndsWith', 'RegEx'
   */
  operator: Operator;
  /**
   * Describes if the result of this condition should be negated.
   */
  negateCondition?: boolean;
  /**
   * List of possible match values.
   */
  matchValue: string[];
  /**
   * List of transforms.
   */
  transforms?: TransformType[];
}

/**
 * Defines contents of a web application rule
 */
export interface CustomRule {
  /**
   * Describes the name of the rule.
   */
  name?: string;
  /**
   * Describes priority of the rule. Rules with a lower value will be evaluated before rules with a
   * higher value.
   */
  priority: number;
  /**
   * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not
   * specified. Possible values include: 'Disabled', 'Enabled'
   */
  enabledState?: CustomRuleEnabledState;
  /**
   * Describes type of rule. Possible values include: 'MatchRule', 'RateLimitRule'
   */
  ruleType: RuleType;
  /**
   * Time window for resetting the rate limit count. Default is 1 minute.
   */
  rateLimitDurationInMinutes?: number;
  /**
   * Number of allowed requests per client within the time window.
   */
  rateLimitThreshold?: number;
  /**
   * List of match conditions.
   */
  matchConditions: MatchCondition[];
  /**
   * Describes what action to be applied when rule matches. Possible values include: 'Allow',
   * 'Block', 'Log', 'Redirect'
   */
  action: ActionType;
}

/**
 * Defines contents of custom rules
 */
export interface CustomRuleList {
  /**
   * List of rules
   */
  rules?: CustomRule[];
}

/**
 * Exclude variables from managed rule evaluation.
 */
export interface ManagedRuleExclusion {
  /**
   * The variable type to be excluded. Possible values include: 'RequestHeaderNames',
   * 'RequestCookieNames', 'QueryStringArgNames', 'RequestBodyPostArgNames'
   */
  matchVariable: ManagedRuleExclusionMatchVariable;
  /**
   * Comparison operator to apply to the selector when specifying which elements in the collection
   * this exclusion applies to. Possible values include: 'Equals', 'Contains', 'StartsWith',
   * 'EndsWith', 'EqualsAny'
   */
  selectorMatchOperator: ManagedRuleExclusionSelectorMatchOperator;
  /**
   * Selector value for which elements in the collection this exclusion applies to.
   */
  selector: string;
}

/**
 * Defines a managed rule group override setting.
 */
export interface ManagedRuleOverride {
  /**
   * Identifier for the managed rule.
   */
  ruleId: string;
  /**
   * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not
   * specified. Possible values include: 'Disabled', 'Enabled'
   */
  enabledState?: ManagedRuleEnabledState;
  /**
   * Describes the override action to be applied when rule matches. Possible values include:
   * 'Allow', 'Block', 'Log', 'Redirect'
   */
  action?: ActionType;
  /**
   * Describes the exclusions that are applied to this specific rule.
   */
  exclusions?: ManagedRuleExclusion[];
}

/**
 * Defines a managed rule group override setting.
 */
export interface ManagedRuleGroupOverride {
  /**
   * Describes the managed rule group to override.
   */
  ruleGroupName: string;
  /**
   * Describes the exclusions that are applied to all rules in the group.
   */
  exclusions?: ManagedRuleExclusion[];
  /**
   * List of rules that will be disabled. If none specified, all rules in the group will be
   * disabled.
   */
  rules?: ManagedRuleOverride[];
}

/**
 * Defines a managed rule set.
 */
export interface ManagedRuleSet {
  /**
   * Defines the rule set type to use.
   */
  ruleSetType: string;
  /**
   * Defines the version of the rule set to use.
   */
  ruleSetVersion: string;
  /**
   * Describes the exclusions that are applied to all rules in the set.
   */
  exclusions?: ManagedRuleExclusion[];
  /**
   * Defines the rule group overrides to apply to the rule set.
   */
  ruleGroupOverrides?: ManagedRuleGroupOverride[];
}

/**
 * Defines the list of managed rule sets for the policy.
 */
export interface ManagedRuleSetList {
  /**
   * List of rule sets.
   */
  managedRuleSets?: ManagedRuleSet[];
}

/**
 * Defines the Resource ID for a Frontend Endpoint.
 */
export interface FrontendEndpointLink {
  /**
   * Resource ID.
   */
  id?: string;
}

/**
 * Defines web application firewall policy.
 */
export interface WebApplicationFirewallPolicy extends Resource {
  /**
   * Describes settings for the policy.
   */
  policySettings?: PolicySettings;
  /**
   * Describes custom rules inside the policy.
   */
  customRules?: CustomRuleList;
  /**
   * Describes managed rules inside the policy.
   */
  managedRules?: ManagedRuleSetList;
  /**
   * Describes Frontend Endpoints associated with this Web Application Firewall policy.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly frontendEndpointLinks?: FrontendEndpointLink[];
  /**
   * Provisioning state of the policy.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * Resource status of the policy. Possible values include: 'Creating', 'Enabling', 'Enabled',
   * 'Disabling', 'Disabled', 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: PolicyResourceState;
  /**
   * Gets a unique read-only string that changes whenever the resource is updated.
   */
  etag?: string;
}

/**
 * Describes a managed rule definition.
 */
export interface ManagedRuleDefinition {
  /**
   * Identifier for the managed rule.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleId?: string;
  /**
   * Describes the default state for the managed rule. Possible values include: 'Disabled',
   * 'Enabled'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly defaultState?: ManagedRuleEnabledState;
  /**
   * Describes the default action to be applied when the managed rule matches. Possible values
   * include: 'Allow', 'Block', 'Log', 'Redirect'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly defaultAction?: ActionType;
  /**
   * Describes the functionality of the managed rule.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly description?: string;
}

/**
 * Describes a managed rule group.
 */
export interface ManagedRuleGroupDefinition {
  /**
   * Name of the managed rule group.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleGroupName?: string;
  /**
   * Description of the managed rule group.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly description?: string;
  /**
   * List of rules within the managed rule group.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly rules?: ManagedRuleDefinition[];
}

/**
 * Describes the a managed rule set definition.
 */
export interface ManagedRuleSetDefinition extends Resource {
  /**
   * Provisioning state of the managed rule set.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * Id of the managed rule set.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleSetId?: string;
  /**
   * Type of the managed rule set.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleSetType?: string;
  /**
   * Version of the managed rule set type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleSetVersion?: string;
  /**
   * Rule groups of the managed rule set.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleGroups?: ManagedRuleGroupDefinition[];
}

/**
 * Optional Parameters.
 */
export interface ReportsGetLatencyScorecardsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The end DateTime of the Latency Scorecard in UTC
   */
  endDateTimeUTC?: string;
  /**
   * The country associated with the Latency Scorecard. Values are country ISO codes as specified
   * here- https://www.iso.org/iso-3166-country-codes.html
   */
  country?: string;
}

/**
 * Optional Parameters.
 */
export interface ReportsGetTimeseriesOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The specific endpoint
   */
  endpoint?: string;
  /**
   * The country associated with the Timeseries. Values are country ISO codes as specified here-
   * https://www.iso.org/iso-3166-country-codes.html
   */
  country?: string;
}

/**
 * An interface representing FrontDoorManagementClientOptions.
 */
export interface FrontDoorManagementClientOptions extends AzureServiceClientOptions {
  baseUri?: string;
}

/**
 * @interface
 * Defines a list of Profiles. It contains a list of Profile objects and a URL link to get the next
 * set of results.
 * @extends Array<Profile>
 */
export interface ProfileList extends Array<Profile> {
  /**
   * URL to get the next set of Profile objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Defines a list of preconfigured endpoints.
 * @extends Array<PreconfiguredEndpoint>
 */
export interface PreconfiguredEndpointList extends Array<PreconfiguredEndpoint> {
  /**
   * URL to get the next set of PreconfiguredEndpoints if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Defines a list of Experiments. It contains a list of Experiment objects and a URL link to get
 * the next set of results.
 * @extends Array<Experiment>
 */
export interface ExperimentList extends Array<Experiment> {
  /**
   * URL to get the next set of Experiment objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list Front Doors. It contains a list of Front Door objects and a URL
 * link to get the next set of results.
 * @extends Array<FrontDoor>
 */
export interface FrontDoorListResult extends Array<FrontDoor> {
  /**
   * URL to get the next set of Front Door objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list frontend endpoints. It contains a list of Frontend endpoint
 * objects and a URL link to get the next set of results.
 * @extends Array<FrontendEndpoint>
 */
export interface FrontendEndpointsListResult extends Array<FrontendEndpoint> {
  /**
   * URL to get the next set of frontend endpoints if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list Rules Engine Configurations. It contains a list of RulesEngine
 * objects and a URL link to get the next set of results.
 * @extends Array<RulesEngine>
 */
export interface RulesEngineListResult extends Array<RulesEngine> {
  /**
   * URL to get the next set of RulesEngine objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Defines a list of WebApplicationFirewallPolicies. It contains a list of
 * WebApplicationFirewallPolicy objects and a URL link to get the next set of results.
 * @extends Array<WebApplicationFirewallPolicy>
 */
export interface WebApplicationFirewallPolicyList extends Array<WebApplicationFirewallPolicy> {
  /**
   * URL to get the next set of WebApplicationFirewallPolicy objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * List of managed rule set definitions available for use in a policy.
 * @extends Array<ManagedRuleSetDefinition>
 */
export interface ManagedRuleSetDefinitionList extends Array<ManagedRuleSetDefinition> {
  /**
   * URL to retrieve next set of managed rule set definitions.
   */
  nextLink?: string;
}

/**
 * Defines values for NetworkOperationStatus.
 * Possible values include: 'InProgress', 'Succeeded', 'Failed'
 * @readonly
 * @enum {string}
 */
export type NetworkOperationStatus = 'InProgress' | 'Succeeded' | 'Failed';

/**
 * Defines values for NetworkExperimentResourceState.
 * Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling', 'Disabled', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type NetworkExperimentResourceState = 'Creating' | 'Enabling' | 'Enabled' | 'Disabling' | 'Disabled' | 'Deleting';

/**
 * Defines values for State.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type State = 'Enabled' | 'Disabled';

/**
 * Defines values for AggregationInterval.
 * Possible values include: 'Hourly', 'Daily'
 * @readonly
 * @enum {string}
 */
export type AggregationInterval = 'Hourly' | 'Daily';

/**
 * Defines values for TimeseriesType.
 * Possible values include: 'MeasurementCounts', 'LatencyP50', 'LatencyP75', 'LatencyP95'
 * @readonly
 * @enum {string}
 */
export type TimeseriesType = 'MeasurementCounts' | 'LatencyP50' | 'LatencyP75' | 'LatencyP95';

/**
 * Defines values for EndpointType.
 * Possible values include: 'AFD', 'AzureRegion', 'CDN', 'ATM'
 * @readonly
 * @enum {string}
 */
export type EndpointType = 'AFD' | 'AzureRegion' | 'CDN' | 'ATM';

/**
 * Defines values for FrontDoorResourceState.
 * Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling', 'Disabled', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type FrontDoorResourceState = 'Creating' | 'Enabling' | 'Enabled' | 'Disabling' | 'Disabled' | 'Deleting';

/**
 * Defines values for CustomHttpsProvisioningState.
 * Possible values include: 'Enabling', 'Enabled', 'Disabling', 'Disabled', 'Failed'
 * @readonly
 * @enum {string}
 */
export type CustomHttpsProvisioningState = 'Enabling' | 'Enabled' | 'Disabling' | 'Disabled' | 'Failed';

/**
 * Defines values for CustomHttpsProvisioningSubstate.
 * Possible values include: 'SubmittingDomainControlValidationRequest',
 * 'PendingDomainControlValidationREquestApproval', 'DomainControlValidationRequestApproved',
 * 'DomainControlValidationRequestRejected', 'DomainControlValidationRequestTimedOut',
 * 'IssuingCertificate', 'DeployingCertificate', 'CertificateDeployed', 'DeletingCertificate',
 * 'CertificateDeleted'
 * @readonly
 * @enum {string}
 */
export type CustomHttpsProvisioningSubstate = 'SubmittingDomainControlValidationRequest' | 'PendingDomainControlValidationREquestApproval' | 'DomainControlValidationRequestApproved' | 'DomainControlValidationRequestRejected' | 'DomainControlValidationRequestTimedOut' | 'IssuingCertificate' | 'DeployingCertificate' | 'CertificateDeployed' | 'DeletingCertificate' | 'CertificateDeleted';

/**
 * Defines values for FrontDoorCertificateSource.
 * Possible values include: 'AzureKeyVault', 'FrontDoor'
 * @readonly
 * @enum {string}
 */
export type FrontDoorCertificateSource = 'AzureKeyVault' | 'FrontDoor';

/**
 * Defines values for MinimumTLSVersion.
 * Possible values include: '1.0', '1.2'
 * @readonly
 * @enum {string}
 */
export type MinimumTLSVersion = '1.0' | '1.2';

/**
 * Defines values for FrontDoorCertificateType.
 * Possible values include: 'Dedicated'
 * @readonly
 * @enum {string}
 */
export type FrontDoorCertificateType = 'Dedicated';

/**
 * Defines values for EnforceCertificateNameCheckEnabledState.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type EnforceCertificateNameCheckEnabledState = 'Enabled' | 'Disabled';

/**
 * Defines values for FrontDoorEnabledState.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type FrontDoorEnabledState = 'Enabled' | 'Disabled';

/**
 * Defines values for FrontDoorProtocol.
 * Possible values include: 'Http', 'Https'
 * @readonly
 * @enum {string}
 */
export type FrontDoorProtocol = 'Http' | 'Https';

/**
 * Defines values for RoutingRuleEnabledState.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type RoutingRuleEnabledState = 'Enabled' | 'Disabled';

/**
 * Defines values for FrontDoorForwardingProtocol.
 * Possible values include: 'HttpOnly', 'HttpsOnly', 'MatchRequest'
 * @readonly
 * @enum {string}
 */
export type FrontDoorForwardingProtocol = 'HttpOnly' | 'HttpsOnly' | 'MatchRequest';

/**
 * Defines values for FrontDoorQuery.
 * Possible values include: 'StripNone', 'StripAll', 'StripOnly', 'StripAllExcept'
 * @readonly
 * @enum {string}
 */
export type FrontDoorQuery = 'StripNone' | 'StripAll' | 'StripOnly' | 'StripAllExcept';

/**
 * Defines values for DynamicCompressionEnabled.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type DynamicCompressionEnabled = 'Enabled' | 'Disabled';

/**
 * Defines values for FrontDoorRedirectType.
 * Possible values include: 'Moved', 'Found', 'TemporaryRedirect', 'PermanentRedirect'
 * @readonly
 * @enum {string}
 */
export type FrontDoorRedirectType = 'Moved' | 'Found' | 'TemporaryRedirect' | 'PermanentRedirect';

/**
 * Defines values for FrontDoorRedirectProtocol.
 * Possible values include: 'HttpOnly', 'HttpsOnly', 'MatchRequest'
 * @readonly
 * @enum {string}
 */
export type FrontDoorRedirectProtocol = 'HttpOnly' | 'HttpsOnly' | 'MatchRequest';

/**
 * Defines values for PrivateEndpointStatus.
 * Possible values include: 'Pending', 'Approved', 'Rejected', 'Disconnected', 'Timeout'
 * @readonly
 * @enum {string}
 */
export type PrivateEndpointStatus = 'Pending' | 'Approved' | 'Rejected' | 'Disconnected' | 'Timeout';

/**
 * Defines values for BackendEnabledState.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type BackendEnabledState = 'Enabled' | 'Disabled';

/**
 * Defines values for FrontDoorHealthProbeMethod.
 * Possible values include: 'GET', 'HEAD'
 * @readonly
 * @enum {string}
 */
export type FrontDoorHealthProbeMethod = 'GET' | 'HEAD';

/**
 * Defines values for HealthProbeEnabled.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type HealthProbeEnabled = 'Enabled' | 'Disabled';

/**
 * Defines values for SessionAffinityEnabledState.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type SessionAffinityEnabledState = 'Enabled' | 'Disabled';

/**
 * Defines values for HeaderActionType.
 * Possible values include: 'Append', 'Delete', 'Overwrite'
 * @readonly
 * @enum {string}
 */
export type HeaderActionType = 'Append' | 'Delete' | 'Overwrite';

/**
 * Defines values for RulesEngineMatchVariable.
 * Possible values include: 'IsMobile', 'RemoteAddr', 'RequestMethod', 'QueryString', 'PostArgs',
 * 'RequestUri', 'RequestPath', 'RequestFilename', 'RequestFilenameExtension', 'RequestHeader',
 * 'RequestBody', 'RequestScheme'
 * @readonly
 * @enum {string}
 */
export type RulesEngineMatchVariable = 'IsMobile' | 'RemoteAddr' | 'RequestMethod' | 'QueryString' | 'PostArgs' | 'RequestUri' | 'RequestPath' | 'RequestFilename' | 'RequestFilenameExtension' | 'RequestHeader' | 'RequestBody' | 'RequestScheme';

/**
 * Defines values for RulesEngineOperator.
 * Possible values include: 'Any', 'IPMatch', 'GeoMatch', 'Equal', 'Contains', 'LessThan',
 * 'GreaterThan', 'LessThanOrEqual', 'GreaterThanOrEqual', 'BeginsWith', 'EndsWith'
 * @readonly
 * @enum {string}
 */
export type RulesEngineOperator = 'Any' | 'IPMatch' | 'GeoMatch' | 'Equal' | 'Contains' | 'LessThan' | 'GreaterThan' | 'LessThanOrEqual' | 'GreaterThanOrEqual' | 'BeginsWith' | 'EndsWith';

/**
 * Defines values for Transform.
 * Possible values include: 'Lowercase', 'Uppercase', 'Trim', 'UrlDecode', 'UrlEncode',
 * 'RemoveNulls'
 * @readonly
 * @enum {string}
 */
export type Transform = 'Lowercase' | 'Uppercase' | 'Trim' | 'UrlDecode' | 'UrlEncode' | 'RemoveNulls';

/**
 * Defines values for MatchProcessingBehavior.
 * Possible values include: 'Continue', 'Stop'
 * @readonly
 * @enum {string}
 */
export type MatchProcessingBehavior = 'Continue' | 'Stop';

/**
 * Defines values for ResourceType.
 * Possible values include: 'Microsoft.Network/frontDoors',
 * 'Microsoft.Network/frontDoors/frontendEndpoints'
 * @readonly
 * @enum {string}
 */
export type ResourceType = 'Microsoft.Network/frontDoors' | 'Microsoft.Network/frontDoors/frontendEndpoints';

/**
 * Defines values for Availability.
 * Possible values include: 'Available', 'Unavailable'
 * @readonly
 * @enum {string}
 */
export type Availability = 'Available' | 'Unavailable';

/**
 * Defines values for PolicyEnabledState.
 * Possible values include: 'Disabled', 'Enabled'
 * @readonly
 * @enum {string}
 */
export type PolicyEnabledState = 'Disabled' | 'Enabled';

/**
 * Defines values for PolicyMode.
 * Possible values include: 'Prevention', 'Detection'
 * @readonly
 * @enum {string}
 */
export type PolicyMode = 'Prevention' | 'Detection';

/**
 * Defines values for CustomRuleEnabledState.
 * Possible values include: 'Disabled', 'Enabled'
 * @readonly
 * @enum {string}
 */
export type CustomRuleEnabledState = 'Disabled' | 'Enabled';

/**
 * Defines values for RuleType.
 * Possible values include: 'MatchRule', 'RateLimitRule'
 * @readonly
 * @enum {string}
 */
export type RuleType = 'MatchRule' | 'RateLimitRule';

/**
 * Defines values for MatchVariable.
 * Possible values include: 'RemoteAddr', 'RequestMethod', 'QueryString', 'PostArgs', 'RequestUri',
 * 'RequestHeader', 'RequestBody', 'Cookies', 'SocketAddr'
 * @readonly
 * @enum {string}
 */
export type MatchVariable = 'RemoteAddr' | 'RequestMethod' | 'QueryString' | 'PostArgs' | 'RequestUri' | 'RequestHeader' | 'RequestBody' | 'Cookies' | 'SocketAddr';

/**
 * Defines values for Operator.
 * Possible values include: 'Any', 'IPMatch', 'GeoMatch', 'Equal', 'Contains', 'LessThan',
 * 'GreaterThan', 'LessThanOrEqual', 'GreaterThanOrEqual', 'BeginsWith', 'EndsWith', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type Operator = 'Any' | 'IPMatch' | 'GeoMatch' | 'Equal' | 'Contains' | 'LessThan' | 'GreaterThan' | 'LessThanOrEqual' | 'GreaterThanOrEqual' | 'BeginsWith' | 'EndsWith' | 'RegEx';

/**
 * Defines values for TransformType.
 * Possible values include: 'Lowercase', 'Uppercase', 'Trim', 'UrlDecode', 'UrlEncode',
 * 'RemoveNulls'
 * @readonly
 * @enum {string}
 */
export type TransformType = 'Lowercase' | 'Uppercase' | 'Trim' | 'UrlDecode' | 'UrlEncode' | 'RemoveNulls';

/**
 * Defines values for ActionType.
 * Possible values include: 'Allow', 'Block', 'Log', 'Redirect'
 * @readonly
 * @enum {string}
 */
export type ActionType = 'Allow' | 'Block' | 'Log' | 'Redirect';

/**
 * Defines values for ManagedRuleExclusionMatchVariable.
 * Possible values include: 'RequestHeaderNames', 'RequestCookieNames', 'QueryStringArgNames',
 * 'RequestBodyPostArgNames'
 * @readonly
 * @enum {string}
 */
export type ManagedRuleExclusionMatchVariable = 'RequestHeaderNames' | 'RequestCookieNames' | 'QueryStringArgNames' | 'RequestBodyPostArgNames';

/**
 * Defines values for ManagedRuleExclusionSelectorMatchOperator.
 * Possible values include: 'Equals', 'Contains', 'StartsWith', 'EndsWith', 'EqualsAny'
 * @readonly
 * @enum {string}
 */
export type ManagedRuleExclusionSelectorMatchOperator = 'Equals' | 'Contains' | 'StartsWith' | 'EndsWith' | 'EqualsAny';

/**
 * Defines values for ManagedRuleEnabledState.
 * Possible values include: 'Disabled', 'Enabled'
 * @readonly
 * @enum {string}
 */
export type ManagedRuleEnabledState = 'Disabled' | 'Enabled';

/**
 * Defines values for PolicyResourceState.
 * Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling', 'Disabled', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type PolicyResourceState = 'Creating' | 'Enabling' | 'Enabled' | 'Disabling' | 'Disabled' | 'Deleting';

/**
 * Defines values for LatencyScorecardAggregationInterval.
 * Possible values include: 'Daily', 'Weekly', 'Monthly'
 * @readonly
 * @enum {string}
 */
export type LatencyScorecardAggregationInterval = 'Daily' | 'Weekly' | 'Monthly';

/**
 * Defines values for TimeseriesAggregationInterval.
 * Possible values include: 'Hourly', 'Daily'
 * @readonly
 * @enum {string}
 */
export type TimeseriesAggregationInterval = 'Hourly' | 'Daily';

/**
 * Contains response data for the list operation.
 */
export type NetworkExperimentProfilesListResponse = ProfileList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ProfileList;
    };
};

/**
 * Contains response data for the listByResourceGroup operation.
 */
export type NetworkExperimentProfilesListByResourceGroupResponse = ProfileList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ProfileList;
    };
};

/**
 * Contains response data for the get operation.
 */
export type NetworkExperimentProfilesGetResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type NetworkExperimentProfilesCreateOrUpdateResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the update operation.
 */
export type NetworkExperimentProfilesUpdateResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type NetworkExperimentProfilesBeginCreateOrUpdateResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type NetworkExperimentProfilesBeginUpdateResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type NetworkExperimentProfilesListNextResponse = ProfileList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ProfileList;
    };
};

/**
 * Contains response data for the listByResourceGroupNext operation.
 */
export type NetworkExperimentProfilesListByResourceGroupNextResponse = ProfileList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ProfileList;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PreconfiguredEndpointsListResponse = PreconfiguredEndpointList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PreconfiguredEndpointList;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type PreconfiguredEndpointsListNextResponse = PreconfiguredEndpointList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PreconfiguredEndpointList;
    };
};

/**
 * Contains response data for the listByProfile operation.
 */
export type ExperimentsListByProfileResponse = ExperimentList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ExperimentList;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ExperimentsGetResponse = Experiment & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Experiment;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ExperimentsCreateOrUpdateResponse = Experiment & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Experiment;
    };
};

/**
 * Contains response data for the update operation.
 */
export type ExperimentsUpdateResponse = Experiment & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Experiment;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type ExperimentsBeginCreateOrUpdateResponse = Experiment & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Experiment;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type ExperimentsBeginUpdateResponse = Experiment & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Experiment;
    };
};

/**
 * Contains response data for the listByProfileNext operation.
 */
export type ExperimentsListByProfileNextResponse = ExperimentList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ExperimentList;
    };
};

/**
 * Contains response data for the getLatencyScorecards operation.
 */
export type ReportsGetLatencyScorecardsResponse = LatencyScorecard & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LatencyScorecard;
    };
};

/**
 * Contains response data for the getTimeseries operation.
 */
export type ReportsGetTimeseriesResponse = Timeseries & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Timeseries;
    };
};

/**
 * Contains response data for the checkFrontDoorNameAvailability operation.
 */
export type CheckFrontDoorNameAvailabilityResponse = CheckNameAvailabilityOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CheckNameAvailabilityOutput;
    };
};

/**
 * Contains response data for the checkFrontDoorNameAvailabilityWithSubscription operation.
 */
export type CheckFrontDoorNameAvailabilityWithSubscriptionResponse = CheckNameAvailabilityOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CheckNameAvailabilityOutput;
    };
};

/**
 * Contains response data for the list operation.
 */
export type FrontDoorsListResponse = FrontDoorListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontDoorListResult;
    };
};

/**
 * Contains response data for the listByResourceGroup operation.
 */
export type FrontDoorsListByResourceGroupResponse = FrontDoorListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontDoorListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type FrontDoorsGetResponse = FrontDoor & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontDoor;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type FrontDoorsCreateOrUpdateResponse = FrontDoor & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontDoor;
    };
};

/**
 * Contains response data for the validateCustomDomain operation.
 */
export type FrontDoorsValidateCustomDomainResponse = ValidateCustomDomainOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ValidateCustomDomainOutput;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type FrontDoorsBeginCreateOrUpdateResponse = FrontDoor & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontDoor;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type FrontDoorsListNextResponse = FrontDoorListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontDoorListResult;
    };
};

/**
 * Contains response data for the listByResourceGroupNext operation.
 */
export type FrontDoorsListByResourceGroupNextResponse = FrontDoorListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontDoorListResult;
    };
};

/**
 * Contains response data for the listByFrontDoor operation.
 */
export type FrontendEndpointsListByFrontDoorResponse = FrontendEndpointsListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontendEndpointsListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type FrontendEndpointsGetResponse = FrontendEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontendEndpoint;
    };
};

/**
 * Contains response data for the listByFrontDoorNext operation.
 */
export type FrontendEndpointsListByFrontDoorNextResponse = FrontendEndpointsListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FrontendEndpointsListResult;
    };
};

/**
 * Contains response data for the listByFrontDoor operation.
 */
export type RulesEnginesListByFrontDoorResponse = RulesEngineListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RulesEngineListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type RulesEnginesGetResponse = RulesEngine & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RulesEngine;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type RulesEnginesCreateOrUpdateResponse = RulesEngine & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RulesEngine;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type RulesEnginesBeginCreateOrUpdateResponse = RulesEngine & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RulesEngine;
    };
};

/**
 * Contains response data for the listByFrontDoorNext operation.
 */
export type RulesEnginesListByFrontDoorNextResponse = RulesEngineListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RulesEngineListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PoliciesListResponse = WebApplicationFirewallPolicyList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: WebApplicationFirewallPolicyList;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PoliciesGetResponse = WebApplicationFirewallPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: WebApplicationFirewallPolicy;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type PoliciesCreateOrUpdateResponse = WebApplicationFirewallPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: WebApplicationFirewallPolicy;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type PoliciesBeginCreateOrUpdateResponse = WebApplicationFirewallPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: WebApplicationFirewallPolicy;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type PoliciesListNextResponse = WebApplicationFirewallPolicyList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: WebApplicationFirewallPolicyList;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ManagedRuleSetsListResponse = ManagedRuleSetDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedRuleSetDefinitionList;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type ManagedRuleSetsListNextResponse = ManagedRuleSetDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedRuleSetDefinitionList;
    };
};
