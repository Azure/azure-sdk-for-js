/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";

export type RouteConfigurationUnion =
  | RouteConfiguration
  | ForwardingConfiguration
  | RedirectConfiguration;

/** Defines a list of Profiles. It contains a list of Profile objects and a URL link to get the next set of results. */
export interface ProfileList {
  /**
   * List of Profiles within a resource group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: Profile[];
  /** URL to get the next set of Profile objects if there are any. */
  nextLink?: string;
}

/** Common resource representation. */
export interface Resource {
  /**
   * Resource ID.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /**
   * Resource name.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /** Resource location. */
  location?: string;
  /** Resource tags. */
  tags?: { [propertyName: string]: string };
}

/** Error response indicates Front Door service is not able to process the incoming request. The reason is provided in the error message. */
export interface ErrorResponse {
  /**
   * Error code.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly code?: string;
  /**
   * Error message indicating why the operation failed.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message?: string;
}

/** Defines modifiable attributes of a Profile */
export interface ProfileUpdateModel {
  /** Resource tags. */
  tags?: { [propertyName: string]: string };
  /** The enabled state of the Profile */
  enabledState?: State;
}

/** Defines a list of preconfigured endpoints. */
export interface PreconfiguredEndpointList {
  /**
   * List of PreconfiguredEndpoints supported by NetworkExperiment.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: PreconfiguredEndpoint[];
  /** URL to get the next set of PreconfiguredEndpoints if there are any. */
  nextLink?: string;
}

/** Defines a list of Experiments. It contains a list of Experiment objects and a URL link to get the next set of results. */
export interface ExperimentList {
  /**
   * List of Experiments within a resource group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: Experiment[];
  /** URL to get the next set of Experiment objects if there are any. */
  nextLink?: string;
}

/** Defines the endpoint properties */
export interface Endpoint {
  /** The name of the endpoint */
  name?: string;
  /** The endpoint URL */
  endpoint?: string;
}

/** Defines modifiable attributes of an Experiment */
export interface ExperimentUpdateModel {
  /** Resource tags. */
  tags?: { [propertyName: string]: string };
  /** The description of the intent or details of the Experiment */
  description?: string;
  /** The state of the Experiment */
  enabledState?: State;
}

/** Defines the properties of a latency metric used in the latency scorecard */
export interface LatencyMetric {
  /**
   * The name of the Latency Metric
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * The end time of the Latency Scorecard in UTC
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly endDateTimeUTC?: string;
  /**
   * The metric value of the A endpoint
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly aValue?: number;
  /**
   * The metric value of the B endpoint
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly bValue?: number;
  /**
   * The difference in value between endpoint A and B
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly delta?: number;
  /**
   * The percent difference between endpoint A and B
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly deltaPercent?: number;
  /**
   * The lower end of the 95% confidence interval for endpoint A
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly aCLower95CI?: number;
  /**
   * The upper end of the 95% confidence interval for endpoint A
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly aHUpper95CI?: number;
  /**
   * The lower end of the 95% confidence interval for endpoint B
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly bCLower95CI?: number;
  /**
   * The upper end of the 95% confidence interval for endpoint B
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly bUpper95CI?: number;
}

/** Defines a timeseries datapoint used in a timeseries */
export interface TimeseriesDataPoint {
  /** The DateTime of the Timeseries data point in UTC */
  dateTimeUTC?: string;
  /** The Value of the Timeseries data point */
  value?: number;
}

/** Input of CheckNameAvailability API. */
export interface CheckNameAvailabilityInput {
  /** The resource name to validate. */
  name: string;
  /** The type of the resource whose name is to be validated. */
  type: ResourceType;
}

/** Output of check name availability API. */
export interface CheckNameAvailabilityOutput {
  /**
   * Indicates whether the name is available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly nameAvailability?: Availability;
  /**
   * The reason why the name is not available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly reason?: string;
  /**
   * The detailed error message describing why the name is not available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message?: string;
}

/** Result of the request to list Front Doors. It contains a list of Front Door objects and a URL link to get the next set of results. */
export interface FrontDoorListResult {
  /**
   * List of Front Doors within a resource group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: FrontDoor[];
  /** URL to get the next set of Front Door objects if there are any. */
  nextLink?: string;
}

/** A rules engine configuration containing a list of rules that will run to modify the runtime behavior of the request and response. */
export interface RulesEngine {
  /**
   * Resource name.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /**
   * Resource ID.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** A list of rules that define a particular Rules Engine Configuration. */
  rules?: RulesEngineRule[];
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
}

/** Rules Engine Configuration to apply to a Routing Rule. */
export interface RulesEngineUpdateParameters {
  /** A list of rules that define a particular Rules Engine Configuration. */
  rules?: RulesEngineRule[];
}

/** Contains a list of match conditions, and an action on how to modify the request/response. If multiple rules match, the actions from one rule that conflict with a previous rule overwrite for a singular action, or append in the case of headers manipulation. */
export interface RulesEngineRule {
  /** A name to refer to this specific rule. */
  name: string;
  /** A priority assigned to this rule. */
  priority: number;
  /** Actions to perform on the request and response if all of the match conditions are met. */
  action: RulesEngineAction;
  /** A list of match conditions that must meet in order for the actions of this rule to run. Having no match conditions means the actions will always run. */
  matchConditions?: RulesEngineMatchCondition[];
  /** If this rule is a match should the rules engine continue running the remaining rules or stop. If not present, defaults to Continue. */
  matchProcessingBehavior?: MatchProcessingBehavior;
}

/** One or more actions that will execute, modifying the request and/or response. */
export interface RulesEngineAction {
  /** A list of header actions to apply from the request from AFD to the origin. */
  requestHeaderActions?: HeaderAction[];
  /** A list of header actions to apply from the response from AFD to the client. */
  responseHeaderActions?: HeaderAction[];
  /** Override the route configuration. */
  routeConfigurationOverride?: RouteConfigurationUnion;
}

/** An action that can manipulate an http header. */
export interface HeaderAction {
  /** Which type of manipulation to apply to the header. */
  headerActionType: HeaderActionType;
  /** The name of the header this action will apply to. */
  headerName: string;
  /** The value to update the given header name with. This value is not used if the actionType is Delete. */
  value?: string;
}

/** Base class for all types of Route. */
export interface RouteConfiguration {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odataType:
    | "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration"
    | "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration";
}

/** Define a match condition */
export interface RulesEngineMatchCondition {
  /** Match Variable */
  rulesEngineMatchVariable: RulesEngineMatchVariable;
  /** Name of selector in RequestHeader or RequestBody to be matched */
  selector?: string;
  /** Describes operator to apply to the match condition. */
  rulesEngineOperator: RulesEngineOperator;
  /** Describes if this is negate condition or not */
  negateCondition?: boolean;
  /** Match values to match against. The operator will apply to each value in here with OR semantics. If any of them match the variable with the given operator this match condition is considered a match. */
  rulesEngineMatchValue: string[];
  /** List of transforms */
  transforms?: Transform[];
}

/** The properties needed to update a Front Door */
export interface FrontDoorUpdateParameters {
  /** A friendly name for the frontDoor */
  friendlyName?: string;
  /** Routing rules associated with this Front Door. */
  routingRules?: RoutingRule[];
  /** Load balancing settings associated with this Front Door instance. */
  loadBalancingSettings?: LoadBalancingSettingsModel[];
  /** Health probe settings associated with this Front Door instance. */
  healthProbeSettings?: HealthProbeSettingsModel[];
  /** Backend pools available to routing rules. */
  backendPools?: BackendPool[];
  /** Frontend endpoints available to routing rules. */
  frontendEndpoints?: FrontendEndpoint[];
  /** Settings for all backendPools */
  backendPoolsSettings?: BackendPoolsSettings;
  /** Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled' */
  enabledState?: FrontDoorEnabledState;
}

/** Routing rules to apply to an endpoint */
export interface RoutingRuleUpdateParameters {
  /** Frontend endpoints associated with this rule */
  frontendEndpoints?: SubResource[];
  /** Protocol schemes to match for this rule */
  acceptedProtocols?: FrontDoorProtocol[];
  /** The route patterns of the rule. */
  patternsToMatch?: string[];
  /** Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled' */
  enabledState?: RoutingRuleEnabledState;
  /** A reference to the routing configuration. */
  routeConfiguration?: RouteConfigurationUnion;
  /** A reference to a specific Rules Engine Configuration to apply to this route. */
  rulesEngine?: SubResource;
  /** Defines the Web Application Firewall policy for each routing rule (if applicable) */
  webApplicationFirewallPolicyLink?: RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink;
}

/** Reference to another subresource. */
export interface SubResource {
  /** Resource ID. */
  id?: string;
}

/** Defines the Web Application Firewall policy for each routing rule (if applicable) */
export interface RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink {
  /** Resource ID. */
  id?: string;
}

/** Round-Robin load balancing settings for a backend pool */
export interface LoadBalancingSettingsUpdateParameters {
  /** The number of samples to consider for load balancing decisions */
  sampleSize?: number;
  /** The number of samples within the sample period that must succeed */
  successfulSamplesRequired?: number;
  /** The additional latency in milliseconds for probes to fall into the lowest latency bucket */
  additionalLatencyMilliseconds?: number;
}

/** L7 health probe settings for a backend pool */
export interface HealthProbeSettingsUpdateParameters {
  /** The path to use for the health probe. Default is / */
  path?: string;
  /** Protocol scheme to use for this probe */
  protocol?: FrontDoorProtocol;
  /** The number of seconds between health probes. */
  intervalInSeconds?: number;
  /** Configures which HTTP method to use to probe the backends defined under backendPools. */
  healthProbeMethod?: FrontDoorHealthProbeMethod;
  /** Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool. */
  enabledState?: HealthProbeEnabled;
}

/** A collection of backends that can be routed to. */
export interface BackendPoolUpdateParameters {
  /** The set of backends for this pool */
  backends?: Backend[];
  /** Load balancing settings for a backend pool */
  loadBalancingSettings?: SubResource;
  /** L7 health probe settings for a backend pool */
  healthProbeSettings?: SubResource;
}

/** Backend address of a frontDoor load balancer. */
export interface Backend {
  /** Location of the backend (IP address or FQDN) */
  address?: string;
  /** The Alias of the Private Link resource. Populating this optional field indicates that this backend is 'Private' */
  privateLinkAlias?: string;
  /** The Resource Id of the Private Link resource. Populating this optional field indicates that this backend is 'Private' */
  privateLinkResourceId?: string;
  /** The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated */
  privateLinkLocation?: string;
  /**
   * The Approval status for the connection to the Private Link
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly privateEndpointStatus?: PrivateEndpointStatus;
  /** A custom message to be included in the approval request to connect to the Private Link */
  privateLinkApprovalMessage?: string;
  /** The HTTP TCP port number. Must be between 1 and 65535. */
  httpPort?: number;
  /** The HTTPS TCP port number. Must be between 1 and 65535. */
  httpsPort?: number;
  /** Whether to enable use of this backend. Permitted values are 'Enabled' or 'Disabled' */
  enabledState?: BackendEnabledState;
  /** Priority to use for load balancing. Higher priorities will not be used for load balancing if any lower priority backend is healthy. */
  priority?: number;
  /** Weight of this endpoint for load balancing purposes. */
  weight?: number;
  /** The value to use as the host header sent to the backend. If blank or unspecified, this defaults to the incoming host. */
  backendHostHeader?: string;
}

/** Https settings for a domain */
export interface CustomHttpsConfiguration {
  /** Defines the source of the SSL certificate */
  certificateSource: FrontDoorCertificateSource;
  /** Defines the TLS extension protocol that is used for secure delivery */
  protocolType: FrontDoorTlsProtocolType;
  /** The minimum TLS version required from the clients to establish an SSL handshake with Front Door. */
  minimumTlsVersion: MinimumTLSVersion;
  /** Defines the type of the certificate used for secure connections to a frontendEndpoint */
  certificateType?: FrontDoorCertificateType;
  /** The Key Vault containing the SSL certificate */
  vault?: KeyVaultCertificateSourceParametersVault;
  /** The name of the Key Vault secret representing the full certificate PFX */
  secretName?: string;
  /** The version of the Key Vault secret representing the full certificate PFX */
  secretVersion?: string;
}

/** The Key Vault containing the SSL certificate */
export interface KeyVaultCertificateSourceParametersVault {
  /** Resource ID. */
  id?: string;
}

/** Frontend endpoint used in routing rule */
export interface FrontendEndpointUpdateParameters {
  /** The host name of the frontendEndpoint. Must be a domain name. */
  hostName?: string;
  /** Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled' */
  sessionAffinityEnabledState?: SessionAffinityEnabledState;
  /** UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable. */
  sessionAffinityTtlSeconds?: number;
  /** Defines the Web Application Firewall policy for each host (if applicable) */
  webApplicationFirewallPolicyLink?: FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink;
}

/** Defines the Web Application Firewall policy for each host (if applicable) */
export interface FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink {
  /** Resource ID. */
  id?: string;
}

/** Settings that apply to all backend pools. */
export interface BackendPoolsSettings {
  /** Whether to enforce certificate name check on HTTPS requests to all backend pools. No effect on non-HTTPS requests. */
  enforceCertificateNameCheck?: EnforceCertificateNameCheckEnabledState;
  /** Send and receive timeout on forwarding request to the backend. When timeout is reached, the request fails and returns. */
  sendRecvTimeoutSeconds?: number;
}

/** Result of the request to list frontend endpoints. It contains a list of Frontend endpoint objects and a URL link to get the next set of results. */
export interface FrontendEndpointsListResult {
  /**
   * List of Frontend endpoints within a Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: FrontendEndpoint[];
  /** URL to get the next set of frontend endpoints if there are any. */
  nextLink?: string;
}

/** Parameters required for content purge. */
export interface PurgeParameters {
  /** The path to the content to be purged. Can describe a file path or a wild card directory. */
  contentPaths: string[];
}

/** Input of the custom domain to be validated for DNS mapping. */
export interface ValidateCustomDomainInput {
  /** The host name of the custom domain. Must be a domain name. */
  hostName: string;
}

/** Output of custom domain validation. */
export interface ValidateCustomDomainOutput {
  /**
   * Indicates whether the custom domain is valid or not.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly customDomainValidated?: boolean;
  /**
   * The reason why the custom domain is not valid.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly reason?: string;
  /**
   * Error message describing why the custom domain is not valid.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message?: string;
}

/** Result of the request to list Rules Engine Configurations. It contains a list of RulesEngine objects and a URL link to get the next set of results. */
export interface RulesEngineListResult {
  /**
   * List of rulesEngines within a Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: RulesEngine[];
  /** URL to get the next set of RulesEngine objects if there are any. */
  nextLink?: string;
}

/** Defines a list of WebApplicationFirewallPolicies. It contains a list of WebApplicationFirewallPolicy objects and a URL link to get the next set of results. */
export interface WebApplicationFirewallPolicyList {
  /**
   * List of WebApplicationFirewallPolicies within a resource group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: WebApplicationFirewallPolicy[];
  /** URL to get the next set of WebApplicationFirewallPolicy objects if there are any. */
  nextLink?: string;
}

/** Defines top-level WebApplicationFirewallPolicy configuration settings. */
export interface PolicySettings {
  /** Describes if the policy is in enabled or disabled state. Defaults to Enabled if not specified. */
  enabledState?: PolicyEnabledState;
  /** Describes if it is in detection mode or prevention mode at policy level. */
  mode?: PolicyMode;
  /** If action type is redirect, this field represents redirect URL for the client. */
  redirectUrl?: string;
  /** If the action type is block, customer can override the response status code. */
  customBlockResponseStatusCode?: number;
  /** If the action type is block, customer can override the response body. The body must be specified in base64 encoding. */
  customBlockResponseBody?: string;
  /** Describes if policy managed rules will inspect the request body content. */
  requestBodyCheck?: PolicyRequestBodyCheck;
}

/** Defines contents of custom rules */
export interface CustomRuleList {
  /** List of rules */
  rules?: CustomRule[];
}

/** Defines contents of a web application rule */
export interface CustomRule {
  /** Describes the name of the rule. */
  name?: string;
  /** Describes priority of the rule. Rules with a lower value will be evaluated before rules with a higher value. */
  priority: number;
  /** Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified. */
  enabledState?: CustomRuleEnabledState;
  /** Describes type of rule. */
  ruleType: RuleType;
  /** Time window for resetting the rate limit count. Default is 1 minute. */
  rateLimitDurationInMinutes?: number;
  /** Number of allowed requests per client within the time window. */
  rateLimitThreshold?: number;
  /** List of match conditions. */
  matchConditions: MatchCondition[];
  /** Describes what action to be applied when rule matches. */
  action: ActionType;
}

/** Define a match condition. */
export interface MatchCondition {
  /** Request variable to compare with. */
  matchVariable: MatchVariable;
  /** Match against a specific key from the QueryString, PostArgs, RequestHeader or Cookies variables. Default is null. */
  selector?: string;
  /** Comparison type to use for matching with the variable value. */
  operator: Operator;
  /** Describes if the result of this condition should be negated. */
  negateCondition?: boolean;
  /** List of possible match values. */
  matchValue: string[];
  /** List of transforms. */
  transforms?: TransformType[];
}

/** Defines the list of managed rule sets for the policy. */
export interface ManagedRuleSetList {
  /** List of rule sets. */
  managedRuleSets?: ManagedRuleSet[];
}

/** Defines a managed rule set. */
export interface ManagedRuleSet {
  /** Defines the rule set type to use. */
  ruleSetType: string;
  /** Defines the version of the rule set to use. */
  ruleSetVersion: string;
  /** Defines the action to take when a managed rule set score threshold is met. */
  ruleSetAction?: ManagedRuleSetActionType;
  /** Describes the exclusions that are applied to all rules in the set. */
  exclusions?: ManagedRuleExclusion[];
  /** Defines the rule group overrides to apply to the rule set. */
  ruleGroupOverrides?: ManagedRuleGroupOverride[];
}

/** Exclude variables from managed rule evaluation. */
export interface ManagedRuleExclusion {
  /** The variable type to be excluded. */
  matchVariable: ManagedRuleExclusionMatchVariable;
  /** Comparison operator to apply to the selector when specifying which elements in the collection this exclusion applies to. */
  selectorMatchOperator: ManagedRuleExclusionSelectorMatchOperator;
  /** Selector value for which elements in the collection this exclusion applies to. */
  selector: string;
}

/** Defines a managed rule group override setting. */
export interface ManagedRuleGroupOverride {
  /** Describes the managed rule group to override. */
  ruleGroupName: string;
  /** Describes the exclusions that are applied to all rules in the group. */
  exclusions?: ManagedRuleExclusion[];
  /** List of rules that will be disabled. If none specified, all rules in the group will be disabled. */
  rules?: ManagedRuleOverride[];
}

/** Defines a managed rule group override setting. */
export interface ManagedRuleOverride {
  /** Identifier for the managed rule. */
  ruleId: string;
  /** Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not specified. */
  enabledState?: ManagedRuleEnabledState;
  /** Describes the override action to be applied when rule matches. */
  action?: ActionType;
  /** Describes the exclusions that are applied to this specific rule. */
  exclusions?: ManagedRuleExclusion[];
}

/** Defines the Resource ID for a Frontend Endpoint. */
export interface FrontendEndpointLink {
  /** Resource ID. */
  id?: string;
}

/** Defines the Resource ID for a Routing Rule. */
export interface RoutingRuleLink {
  /** Resource ID. */
  id?: string;
}

/** Defines the Resource ID for a Security Policy. */
export interface SecurityPolicyLink {
  /** Resource ID. */
  id?: string;
}

/** The pricing tier of the web application firewall policy. */
export interface Sku {
  /** Name of the pricing tier. */
  name?: SkuName;
}

/** List of managed rule set definitions available for use in a policy. */
export interface ManagedRuleSetDefinitionList {
  /**
   * List of managed rule set definitions.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: ManagedRuleSetDefinition[];
  /** URL to retrieve next set of managed rule set definitions. */
  nextLink?: string;
}

/** Describes a managed rule group. */
export interface ManagedRuleGroupDefinition {
  /**
   * Name of the managed rule group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly ruleGroupName?: string;
  /**
   * Description of the managed rule group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly description?: string;
  /**
   * List of rules within the managed rule group.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly rules?: ManagedRuleDefinition[];
}

/** Describes a managed rule definition. */
export interface ManagedRuleDefinition {
  /**
   * Identifier for the managed rule.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly ruleId?: string;
  /**
   * Describes the default state for the managed rule.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly defaultState?: ManagedRuleEnabledState;
  /**
   * Describes the default action to be applied when the managed rule matches.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly defaultAction?: ActionType;
  /**
   * Describes the functionality of the managed rule.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly description?: string;
}

export interface ErrorDetails {
  code?: string;
  target?: string;
  message?: string;
}

export interface ErrorModel {
  code?: string;
  message?: string;
  target?: string;
  details?: ErrorDetails[];
  innerError?: string;
}

/** The response body contains the status of the specified asynchronous operation, indicating whether it has succeeded, is in progress, or has failed. Note that this status is distinct from the HTTP status code returned for the Get Operation Status operation itself. If the asynchronous operation succeeded, the response body includes the HTTP status code for the successful request. If the asynchronous operation failed, the response body includes the HTTP status code for the failed request and error information regarding the failure. */
export interface AzureAsyncOperationResult {
  /** Status of the Azure async operation. Possible values are: 'InProgress', 'Succeeded', and 'Failed'. */
  status?: NetworkOperationStatus;
  error?: ErrorModel;
}

/** Tags object for patch operations. */
export interface TagsObject {
  /** Resource tags. */
  tags?: { [propertyName: string]: string };
}

/** Result of the request to list Routing Rules. It contains a list of Routing Rule objects and a URL link to get the next set of results. */
export interface RoutingRuleListResult {
  /**
   * List of Routing Rules within a Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: RoutingRule[];
  /** URL to get the next set of RoutingRule objects if there are any. */
  nextLink?: string;
}

/** Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object. */
export interface CacheConfiguration {
  /** Treatment of URL query terms when forming the cache key. */
  queryParameterStripDirective?: FrontDoorQuery;
  /** query parameters to include or exclude (comma separated). */
  queryParameters?: string;
  /** Whether to use dynamic compression for cached content */
  dynamicCompression?: DynamicCompressionEnabled;
  /** The duration for which the content needs to be cached. Allowed format is in ISO 8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations). HTTP requires the value to be no more than a year */
  cacheDuration?: string;
}

/** Result of the request to list load balancing settings. It contains a list of load balancing settings objects and a URL link to get the next set of results. */
export interface LoadBalancingSettingsListResult {
  /**
   * List of Backend Pools within a Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: LoadBalancingSettingsModel[];
  /** URL to get the next set of LoadBalancingSettings objects if there are any. */
  nextLink?: string;
}

/** Result of the request to list HealthProbeSettings. It contains a list of HealthProbeSettings objects and a URL link to get the next set of results. */
export interface HealthProbeSettingsListResult {
  /**
   * List of HealthProbeSettings within a Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: HealthProbeSettingsModel[];
  /** URL to get the next set of HealthProbeSettings objects if there are any. */
  nextLink?: string;
}

/** Result of the request to list Backend Pools. It contains a list of Backend Pools objects and a URL link to get the next set of results. */
export interface BackendPoolListResult {
  /**
   * List of Backend Pools within a Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly value?: BackendPool[];
  /** URL to get the next set of BackendPool objects if there are any. */
  nextLink?: string;
}

/** Defines an Network Experiment Profile and lists of Experiments */
export type Profile = Resource & {
  /** Gets a unique read-only string that changes whenever the resource is updated. */
  etag?: string;
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: NetworkExperimentResourceState;
  /** The state of the Experiment */
  enabledState?: State;
};

/** Defines the properties of a preconfigured endpoint */
export type PreconfiguredEndpoint = Resource & {
  /** The description of the endpoint */
  description?: string;
  /** The endpoint that is preconfigured */
  endpoint?: string;
  /** The type of endpoint */
  endpointType?: EndpointType;
  /** The preconfigured endpoint backend */
  backend?: string;
};

/** Defines the properties of an Experiment */
export type Experiment = Resource & {
  /** The description of the details or intents of the Experiment */
  description?: string;
  /** The endpoint A of an experiment */
  endpointA?: Endpoint;
  /** The endpoint B of an experiment */
  endpointB?: Endpoint;
  /** The state of the Experiment */
  enabledState?: State;
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: NetworkExperimentResourceState;
  /**
   * The description of Experiment status from the server side
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly status?: string;
  /**
   * The uri to the Script used in the Experiment
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly scriptFileUri?: string;
};

/** Defines the LatencyScorecard */
export type LatencyScorecard = Resource & {
  /**
   * The unique identifier of the Latency Scorecard
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly idPropertiesId?: string;
  /**
   * The name of the Latency Scorecard
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly namePropertiesName?: string;
  /**
   * The description of the Latency Scorecard
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly description?: string;
  /**
   * The A endpoint in the scorecard
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly endpointA?: string;
  /**
   * The B endpoint in the scorecard
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly endpointB?: string;
  /**
   * The start time of the Latency Scorecard in UTC
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly startDateTimeUTC?: Date;
  /**
   * The end time of the Latency Scorecard in UTC
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly endDateTimeUTC?: Date;
  /**
   * The country associated with the Latency Scorecard. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly country?: string;
  /** The latency metrics of the Latency Scorecard */
  latencyMetrics?: LatencyMetric[];
};

/** Defines the Timeseries */
export type Timeseries = Resource & {
  /** The endpoint associated with the Timeseries data point */
  endpoint?: string;
  /** The start DateTime of the Timeseries in UTC */
  startDateTimeUTC?: string;
  /** The end DateTime of the Timeseries in UTC */
  endDateTimeUTC?: string;
  /** The aggregation interval of the Timeseries */
  aggregationInterval?: AggregationInterval;
  /** The type of Timeseries */
  timeseriesType?: TimeseriesType;
  /** The country associated with the Timeseries. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html */
  country?: string;
  /** The set of data points for the timeseries */
  timeseriesData?: TimeseriesDataPoint[];
};

/** Front Door represents a collection of backend endpoints to route traffic to along with rules that specify how traffic is sent there. */
export type FrontDoor = Resource & {
  /** A friendly name for the frontDoor */
  friendlyName?: string;
  /** Routing rules associated with this Front Door. */
  routingRules?: RoutingRule[];
  /** Load balancing settings associated with this Front Door instance. */
  loadBalancingSettings?: LoadBalancingSettingsModel[];
  /** Health probe settings associated with this Front Door instance. */
  healthProbeSettings?: HealthProbeSettingsModel[];
  /** Backend pools available to routing rules. */
  backendPools?: BackendPool[];
  /** Frontend endpoints available to routing rules. */
  frontendEndpoints?: FrontendEndpoint[];
  /** Settings for all backendPools */
  backendPoolsSettings?: BackendPoolsSettings;
  /** Operational status of the Front Door load balancer. Permitted values are 'Enabled' or 'Disabled' */
  enabledState?: FrontDoorEnabledState;
  /**
   * Resource status of the Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
  /**
   * Provisioning state of the Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: string;
  /**
   * The host that each frontendEndpoint must CNAME to.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly cname?: string;
  /**
   * The Id of the frontdoor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly frontdoorId?: string;
  /**
   * Rules Engine Configurations available to routing rules.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly rulesEngines?: RulesEngine[];
};

/** Defines web application firewall policy. */
export type WebApplicationFirewallPolicy = Resource & {
  /** Gets a unique read-only string that changes whenever the resource is updated. */
  etag?: string;
  /** The pricing tier of web application firewall policy. Defaults to Classic_AzureFrontDoor if not specified. */
  sku?: Sku;
  /** Describes settings for the policy. */
  policySettings?: PolicySettings;
  /** Describes custom rules inside the policy. */
  customRules?: CustomRuleList;
  /** Describes managed rules inside the policy. */
  managedRules?: ManagedRuleSetList;
  /**
   * Describes Frontend Endpoints associated with this Web Application Firewall policy.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly frontendEndpointLinks?: FrontendEndpointLink[];
  /**
   * Describes Routing Rules associated with this Web Application Firewall policy.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly routingRuleLinks?: RoutingRuleLink[];
  /**
   * Describes Security Policy associated with this Web Application Firewall policy.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly securityPolicyLinks?: SecurityPolicyLink[];
  /**
   * Provisioning state of the policy.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: string;
  /**
   * Resource status of the policy.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: PolicyResourceState;
};

/** Describes the a managed rule set definition. */
export type ManagedRuleSetDefinition = Resource & {
  /**
   * Provisioning state of the managed rule set.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: string;
  /**
   * Id of the managed rule set.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly ruleSetId?: string;
  /**
   * Type of the managed rule set.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly ruleSetType?: string;
  /**
   * Version of the managed rule set type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly ruleSetVersion?: string;
  /**
   * Rule groups of the managed rule set.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly ruleGroups?: ManagedRuleGroupDefinition[];
};

/** The JSON object that contains the properties required to create a Rules Engine Configuration. */
export type RulesEngineProperties = RulesEngineUpdateParameters & {
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** Describes Forwarding Route. */
export type ForwardingConfiguration = RouteConfiguration & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odataType: "#Microsoft.Azure.FrontDoor.Models.FrontdoorForwardingConfiguration";
  /** A custom path used to rewrite resource paths matched by this rule. Leave empty to use incoming path. */
  customForwardingPath?: string;
  /** Protocol this rule will use when forwarding traffic to backends. */
  forwardingProtocol?: FrontDoorForwardingProtocol;
  /** The caching configuration associated with this rule. */
  cacheConfiguration?: CacheConfiguration;
  /** A reference to the BackendPool which this rule routes to. */
  backendPool?: SubResource;
};

/** Describes Redirect Route. */
export type RedirectConfiguration = RouteConfiguration & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odataType: "#Microsoft.Azure.FrontDoor.Models.FrontdoorRedirectConfiguration";
  /** The redirect type the rule will use when redirecting traffic. */
  redirectType?: FrontDoorRedirectType;
  /** The protocol of the destination to where the traffic is redirected */
  redirectProtocol?: FrontDoorRedirectProtocol;
  /** Host to redirect. Leave empty to use the incoming host as the destination host. */
  customHost?: string;
  /** The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path as destination path. */
  customPath?: string;
  /** Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include the #. */
  customFragment?: string;
  /** The set of query strings to be placed in the redirect URL. Setting this value would replace any existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format. The first ? and & will be added automatically so do not include them in the front, but do separate multiple query strings with &. */
  customQueryString?: string;
};

/** The JSON object that contains the properties required to create an endpoint. */
export type FrontDoorProperties = FrontDoorUpdateParameters & {
  /**
   * Resource status of the Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
  /**
   * Provisioning state of the Front Door.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly provisioningState?: string;
  /**
   * The host that each frontendEndpoint must CNAME to.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly cname?: string;
  /**
   * The Id of the frontdoor.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly frontdoorId?: string;
  /**
   * Rules Engine Configurations available to routing rules.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly rulesEngines?: RulesEngine[];
};

/** The JSON object that contains the properties required to create a routing rule. */
export type RoutingRuleProperties = RoutingRuleUpdateParameters & {
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** A routing rule represents a specification for traffic to treat and where to send it, along with health probe information. */
export type RoutingRule = SubResource & {
  /** Resource name. */
  name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /** Frontend endpoints associated with this rule */
  frontendEndpoints?: SubResource[];
  /** Protocol schemes to match for this rule */
  acceptedProtocols?: FrontDoorProtocol[];
  /** The route patterns of the rule. */
  patternsToMatch?: string[];
  /** Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled' */
  enabledState?: RoutingRuleEnabledState;
  /** A reference to the routing configuration. */
  routeConfiguration?: RouteConfigurationUnion;
  /** A reference to a specific Rules Engine Configuration to apply to this route. */
  rulesEngine?: SubResource;
  /** Defines the Web Application Firewall policy for each routing rule (if applicable) */
  webApplicationFirewallPolicyLink?: RoutingRuleUpdateParametersWebApplicationFirewallPolicyLink;
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** Load balancing settings for a backend pool */
export type LoadBalancingSettingsModel = SubResource & {
  /** Resource name. */
  name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /** The number of samples to consider for load balancing decisions */
  sampleSize?: number;
  /** The number of samples within the sample period that must succeed */
  successfulSamplesRequired?: number;
  /** The additional latency in milliseconds for probes to fall into the lowest latency bucket */
  additionalLatencyMilliseconds?: number;
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** Load balancing settings for a backend pool */
export type HealthProbeSettingsModel = SubResource & {
  /** Resource name. */
  name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /** The path to use for the health probe. Default is / */
  path?: string;
  /** Protocol scheme to use for this probe */
  protocol?: FrontDoorProtocol;
  /** The number of seconds between health probes. */
  intervalInSeconds?: number;
  /** Configures which HTTP method to use to probe the backends defined under backendPools. */
  healthProbeMethod?: FrontDoorHealthProbeMethod;
  /** Whether to enable health probes to be made against backends defined under backendPools. Health probes can only be disabled if there is a single enabled backend in single enabled backend pool. */
  enabledState?: HealthProbeEnabled;
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** A backend pool is a collection of backends that can be routed to. */
export type BackendPool = SubResource & {
  /** Resource name. */
  name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /** The set of backends for this pool */
  backends?: Backend[];
  /** Load balancing settings for a backend pool */
  loadBalancingSettings?: SubResource;
  /** L7 health probe settings for a backend pool */
  healthProbeSettings?: SubResource;
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** A frontend endpoint used for routing. */
export type FrontendEndpoint = SubResource & {
  /** Resource name. */
  name?: string;
  /**
   * Resource type.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly type?: string;
  /** The host name of the frontendEndpoint. Must be a domain name. */
  hostName?: string;
  /** Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled' */
  sessionAffinityEnabledState?: SessionAffinityEnabledState;
  /** UNUSED. This field will be ignored. The TTL to use in seconds for session affinity, if applicable. */
  sessionAffinityTtlSeconds?: number;
  /** Defines the Web Application Firewall policy for each host (if applicable) */
  webApplicationFirewallPolicyLink?: FrontendEndpointUpdateParametersWebApplicationFirewallPolicyLink;
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
  /**
   * Provisioning status of Custom Https of the frontendEndpoint.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly customHttpsProvisioningState?: CustomHttpsProvisioningState;
  /**
   * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly customHttpsProvisioningSubstate?: CustomHttpsProvisioningSubstate;
  /**
   * The configuration specifying how to enable HTTPS
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly customHttpsConfiguration?: CustomHttpsConfiguration;
};

/** The JSON object that contains the properties required to create load balancing settings */
export type LoadBalancingSettingsProperties = LoadBalancingSettingsUpdateParameters & {
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** The JSON object that contains the properties required to create a health probe settings. */
export type HealthProbeSettingsProperties = HealthProbeSettingsUpdateParameters & {
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** The JSON object that contains the properties required to create a Backend Pool. */
export type BackendPoolProperties = BackendPoolUpdateParameters & {
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
};

/** The JSON object that contains the properties required to create a frontend endpoint. */
export type FrontendEndpointProperties = FrontendEndpointUpdateParameters & {
  /**
   * Resource status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly resourceState?: FrontDoorResourceState;
  /**
   * Provisioning status of Custom Https of the frontendEndpoint.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly customHttpsProvisioningState?: CustomHttpsProvisioningState;
  /**
   * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly customHttpsProvisioningSubstate?: CustomHttpsProvisioningSubstate;
  /**
   * The configuration specifying how to enable HTTPS
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly customHttpsConfiguration?: CustomHttpsConfiguration;
};

/** Known values of {@link NetworkExperimentResourceState} that the service accepts. */
export enum KnownNetworkExperimentResourceState {
  Creating = "Creating",
  Enabling = "Enabling",
  Enabled = "Enabled",
  Disabling = "Disabling",
  Disabled = "Disabled",
  Deleting = "Deleting"
}

/**
 * Defines values for NetworkExperimentResourceState. \
 * {@link KnownNetworkExperimentResourceState} can be used interchangeably with NetworkExperimentResourceState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Creating** \
 * **Enabling** \
 * **Enabled** \
 * **Disabling** \
 * **Disabled** \
 * **Deleting**
 */
export type NetworkExperimentResourceState = string;

/** Known values of {@link State} that the service accepts. */
export enum KnownState {
  Enabled = "Enabled",
  Disabled = "Disabled"
}

/**
 * Defines values for State. \
 * {@link KnownState} can be used interchangeably with State,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export type State = string;

/** Known values of {@link EndpointType} that the service accepts. */
export enum KnownEndpointType {
  AFD = "AFD",
  AzureRegion = "AzureRegion",
  CDN = "CDN",
  ATM = "ATM"
}

/**
 * Defines values for EndpointType. \
 * {@link KnownEndpointType} can be used interchangeably with EndpointType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **AFD** \
 * **AzureRegion** \
 * **CDN** \
 * **ATM**
 */
export type EndpointType = string;

/** Known values of {@link LatencyScorecardAggregationInterval} that the service accepts. */
export enum KnownLatencyScorecardAggregationInterval {
  Daily = "Daily",
  Weekly = "Weekly",
  Monthly = "Monthly"
}

/**
 * Defines values for LatencyScorecardAggregationInterval. \
 * {@link KnownLatencyScorecardAggregationInterval} can be used interchangeably with LatencyScorecardAggregationInterval,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Daily** \
 * **Weekly** \
 * **Monthly**
 */
export type LatencyScorecardAggregationInterval = string;

/** Known values of {@link TimeseriesAggregationInterval} that the service accepts. */
export enum KnownTimeseriesAggregationInterval {
  Hourly = "Hourly",
  Daily = "Daily"
}

/**
 * Defines values for TimeseriesAggregationInterval. \
 * {@link KnownTimeseriesAggregationInterval} can be used interchangeably with TimeseriesAggregationInterval,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Hourly** \
 * **Daily**
 */
export type TimeseriesAggregationInterval = string;

/** Known values of {@link TimeseriesType} that the service accepts. */
export enum KnownTimeseriesType {
  MeasurementCounts = "MeasurementCounts",
  LatencyP50 = "LatencyP50",
  LatencyP75 = "LatencyP75",
  LatencyP95 = "LatencyP95"
}

/**
 * Defines values for TimeseriesType. \
 * {@link KnownTimeseriesType} can be used interchangeably with TimeseriesType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **MeasurementCounts** \
 * **LatencyP50** \
 * **LatencyP75** \
 * **LatencyP95**
 */
export type TimeseriesType = string;

/** Known values of {@link AggregationInterval} that the service accepts. */
export enum KnownAggregationInterval {
  Hourly = "Hourly",
  Daily = "Daily"
}

/**
 * Defines values for AggregationInterval. \
 * {@link KnownAggregationInterval} can be used interchangeably with AggregationInterval,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Hourly** \
 * **Daily**
 */
export type AggregationInterval = string;

/** Known values of {@link Availability} that the service accepts. */
export enum KnownAvailability {
  Available = "Available",
  Unavailable = "Unavailable"
}

/**
 * Defines values for Availability. \
 * {@link KnownAvailability} can be used interchangeably with Availability,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Available** \
 * **Unavailable**
 */
export type Availability = string;

/** Known values of {@link FrontDoorResourceState} that the service accepts. */
export enum KnownFrontDoorResourceState {
  Creating = "Creating",
  Enabling = "Enabling",
  Enabled = "Enabled",
  Disabling = "Disabling",
  Disabled = "Disabled",
  Deleting = "Deleting"
}

/**
 * Defines values for FrontDoorResourceState. \
 * {@link KnownFrontDoorResourceState} can be used interchangeably with FrontDoorResourceState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Creating** \
 * **Enabling** \
 * **Enabled** \
 * **Disabling** \
 * **Disabled** \
 * **Deleting**
 */
export type FrontDoorResourceState = string;

/** Known values of {@link HeaderActionType} that the service accepts. */
export enum KnownHeaderActionType {
  Append = "Append",
  Delete = "Delete",
  Overwrite = "Overwrite"
}

/**
 * Defines values for HeaderActionType. \
 * {@link KnownHeaderActionType} can be used interchangeably with HeaderActionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Append** \
 * **Delete** \
 * **Overwrite**
 */
export type HeaderActionType = string;

/** Known values of {@link RulesEngineMatchVariable} that the service accepts. */
export enum KnownRulesEngineMatchVariable {
  IsMobile = "IsMobile",
  RemoteAddr = "RemoteAddr",
  RequestMethod = "RequestMethod",
  QueryString = "QueryString",
  PostArgs = "PostArgs",
  RequestUri = "RequestUri",
  RequestPath = "RequestPath",
  RequestFilename = "RequestFilename",
  RequestFilenameExtension = "RequestFilenameExtension",
  RequestHeader = "RequestHeader",
  RequestBody = "RequestBody",
  RequestScheme = "RequestScheme"
}

/**
 * Defines values for RulesEngineMatchVariable. \
 * {@link KnownRulesEngineMatchVariable} can be used interchangeably with RulesEngineMatchVariable,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **IsMobile** \
 * **RemoteAddr** \
 * **RequestMethod** \
 * **QueryString** \
 * **PostArgs** \
 * **RequestUri** \
 * **RequestPath** \
 * **RequestFilename** \
 * **RequestFilenameExtension** \
 * **RequestHeader** \
 * **RequestBody** \
 * **RequestScheme**
 */
export type RulesEngineMatchVariable = string;

/** Known values of {@link RulesEngineOperator} that the service accepts. */
export enum KnownRulesEngineOperator {
  Any = "Any",
  IPMatch = "IPMatch",
  GeoMatch = "GeoMatch",
  Equal = "Equal",
  Contains = "Contains",
  LessThan = "LessThan",
  GreaterThan = "GreaterThan",
  LessThanOrEqual = "LessThanOrEqual",
  GreaterThanOrEqual = "GreaterThanOrEqual",
  BeginsWith = "BeginsWith",
  EndsWith = "EndsWith"
}

/**
 * Defines values for RulesEngineOperator. \
 * {@link KnownRulesEngineOperator} can be used interchangeably with RulesEngineOperator,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Any** \
 * **IPMatch** \
 * **GeoMatch** \
 * **Equal** \
 * **Contains** \
 * **LessThan** \
 * **GreaterThan** \
 * **LessThanOrEqual** \
 * **GreaterThanOrEqual** \
 * **BeginsWith** \
 * **EndsWith**
 */
export type RulesEngineOperator = string;

/** Known values of {@link Transform} that the service accepts. */
export enum KnownTransform {
  Lowercase = "Lowercase",
  Uppercase = "Uppercase",
  Trim = "Trim",
  UrlDecode = "UrlDecode",
  UrlEncode = "UrlEncode",
  RemoveNulls = "RemoveNulls"
}

/**
 * Defines values for Transform. \
 * {@link KnownTransform} can be used interchangeably with Transform,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Lowercase** \
 * **Uppercase** \
 * **Trim** \
 * **UrlDecode** \
 * **UrlEncode** \
 * **RemoveNulls**
 */
export type Transform = string;

/** Known values of {@link MatchProcessingBehavior} that the service accepts. */
export enum KnownMatchProcessingBehavior {
  Continue = "Continue",
  Stop = "Stop"
}

/**
 * Defines values for MatchProcessingBehavior. \
 * {@link KnownMatchProcessingBehavior} can be used interchangeably with MatchProcessingBehavior,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Continue** \
 * **Stop**
 */
export type MatchProcessingBehavior = string;

/** Known values of {@link FrontDoorProtocol} that the service accepts. */
export enum KnownFrontDoorProtocol {
  Http = "Http",
  Https = "Https"
}

/**
 * Defines values for FrontDoorProtocol. \
 * {@link KnownFrontDoorProtocol} can be used interchangeably with FrontDoorProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Http** \
 * **Https**
 */
export type FrontDoorProtocol = string;

/** Known values of {@link RoutingRuleEnabledState} that the service accepts. */
export enum KnownRoutingRuleEnabledState {
  Enabled = "Enabled",
  Disabled = "Disabled"
}

/**
 * Defines values for RoutingRuleEnabledState. \
 * {@link KnownRoutingRuleEnabledState} can be used interchangeably with RoutingRuleEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export type RoutingRuleEnabledState = string;

/** Known values of {@link FrontDoorHealthProbeMethod} that the service accepts. */
export enum KnownFrontDoorHealthProbeMethod {
  GET = "GET",
  Head = "HEAD"
}

/**
 * Defines values for FrontDoorHealthProbeMethod. \
 * {@link KnownFrontDoorHealthProbeMethod} can be used interchangeably with FrontDoorHealthProbeMethod,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **GET** \
 * **HEAD**
 */
export type FrontDoorHealthProbeMethod = string;

/** Known values of {@link HealthProbeEnabled} that the service accepts. */
export enum KnownHealthProbeEnabled {
  Enabled = "Enabled",
  Disabled = "Disabled"
}

/**
 * Defines values for HealthProbeEnabled. \
 * {@link KnownHealthProbeEnabled} can be used interchangeably with HealthProbeEnabled,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export type HealthProbeEnabled = string;

/** Known values of {@link PrivateEndpointStatus} that the service accepts. */
export enum KnownPrivateEndpointStatus {
  Pending = "Pending",
  Approved = "Approved",
  Rejected = "Rejected",
  Disconnected = "Disconnected",
  Timeout = "Timeout"
}

/**
 * Defines values for PrivateEndpointStatus. \
 * {@link KnownPrivateEndpointStatus} can be used interchangeably with PrivateEndpointStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Pending** \
 * **Approved** \
 * **Rejected** \
 * **Disconnected** \
 * **Timeout**
 */
export type PrivateEndpointStatus = string;

/** Known values of {@link BackendEnabledState} that the service accepts. */
export enum KnownBackendEnabledState {
  Enabled = "Enabled",
  Disabled = "Disabled"
}

/**
 * Defines values for BackendEnabledState. \
 * {@link KnownBackendEnabledState} can be used interchangeably with BackendEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export type BackendEnabledState = string;

/** Known values of {@link CustomHttpsProvisioningState} that the service accepts. */
export enum KnownCustomHttpsProvisioningState {
  Enabling = "Enabling",
  Enabled = "Enabled",
  Disabling = "Disabling",
  Disabled = "Disabled",
  Failed = "Failed"
}

/**
 * Defines values for CustomHttpsProvisioningState. \
 * {@link KnownCustomHttpsProvisioningState} can be used interchangeably with CustomHttpsProvisioningState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabling** \
 * **Enabled** \
 * **Disabling** \
 * **Disabled** \
 * **Failed**
 */
export type CustomHttpsProvisioningState = string;

/** Known values of {@link CustomHttpsProvisioningSubstate} that the service accepts. */
export enum KnownCustomHttpsProvisioningSubstate {
  SubmittingDomainControlValidationRequest = "SubmittingDomainControlValidationRequest",
  PendingDomainControlValidationREquestApproval = "PendingDomainControlValidationREquestApproval",
  DomainControlValidationRequestApproved = "DomainControlValidationRequestApproved",
  DomainControlValidationRequestRejected = "DomainControlValidationRequestRejected",
  DomainControlValidationRequestTimedOut = "DomainControlValidationRequestTimedOut",
  IssuingCertificate = "IssuingCertificate",
  DeployingCertificate = "DeployingCertificate",
  CertificateDeployed = "CertificateDeployed",
  DeletingCertificate = "DeletingCertificate",
  CertificateDeleted = "CertificateDeleted"
}

/**
 * Defines values for CustomHttpsProvisioningSubstate. \
 * {@link KnownCustomHttpsProvisioningSubstate} can be used interchangeably with CustomHttpsProvisioningSubstate,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **SubmittingDomainControlValidationRequest** \
 * **PendingDomainControlValidationREquestApproval** \
 * **DomainControlValidationRequestApproved** \
 * **DomainControlValidationRequestRejected** \
 * **DomainControlValidationRequestTimedOut** \
 * **IssuingCertificate** \
 * **DeployingCertificate** \
 * **CertificateDeployed** \
 * **DeletingCertificate** \
 * **CertificateDeleted**
 */
export type CustomHttpsProvisioningSubstate = string;

/** Known values of {@link FrontDoorCertificateSource} that the service accepts. */
export enum KnownFrontDoorCertificateSource {
  AzureKeyVault = "AzureKeyVault",
  FrontDoor = "FrontDoor"
}

/**
 * Defines values for FrontDoorCertificateSource. \
 * {@link KnownFrontDoorCertificateSource} can be used interchangeably with FrontDoorCertificateSource,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **AzureKeyVault** \
 * **FrontDoor**
 */
export type FrontDoorCertificateSource = string;

/** Known values of {@link FrontDoorTlsProtocolType} that the service accepts. */
export enum KnownFrontDoorTlsProtocolType {
  ServerNameIndication = "ServerNameIndication"
}

/**
 * Defines values for FrontDoorTlsProtocolType. \
 * {@link KnownFrontDoorTlsProtocolType} can be used interchangeably with FrontDoorTlsProtocolType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **ServerNameIndication**
 */
export type FrontDoorTlsProtocolType = string;

/** Known values of {@link MinimumTLSVersion} that the service accepts. */
export enum KnownMinimumTLSVersion {
  One0 = "1.0",
  One2 = "1.2"
}

/**
 * Defines values for MinimumTLSVersion. \
 * {@link KnownMinimumTLSVersion} can be used interchangeably with MinimumTLSVersion,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **1.0** \
 * **1.2**
 */
export type MinimumTLSVersion = string;

/** Known values of {@link FrontDoorCertificateType} that the service accepts. */
export enum KnownFrontDoorCertificateType {
  Dedicated = "Dedicated"
}

/**
 * Defines values for FrontDoorCertificateType. \
 * {@link KnownFrontDoorCertificateType} can be used interchangeably with FrontDoorCertificateType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Dedicated**
 */
export type FrontDoorCertificateType = string;

/** Known values of {@link SessionAffinityEnabledState} that the service accepts. */
export enum KnownSessionAffinityEnabledState {
  Enabled = "Enabled",
  Disabled = "Disabled"
}

/**
 * Defines values for SessionAffinityEnabledState. \
 * {@link KnownSessionAffinityEnabledState} can be used interchangeably with SessionAffinityEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export type SessionAffinityEnabledState = string;

/** Known values of {@link EnforceCertificateNameCheckEnabledState} that the service accepts. */
export enum KnownEnforceCertificateNameCheckEnabledState {
  Enabled = "Enabled",
  Disabled = "Disabled"
}

/**
 * Defines values for EnforceCertificateNameCheckEnabledState. \
 * {@link KnownEnforceCertificateNameCheckEnabledState} can be used interchangeably with EnforceCertificateNameCheckEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export type EnforceCertificateNameCheckEnabledState = string;

/** Known values of {@link FrontDoorEnabledState} that the service accepts. */
export enum KnownFrontDoorEnabledState {
  Enabled = "Enabled",
  Disabled = "Disabled"
}

/**
 * Defines values for FrontDoorEnabledState. \
 * {@link KnownFrontDoorEnabledState} can be used interchangeably with FrontDoorEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export type FrontDoorEnabledState = string;

/** Known values of {@link PolicyEnabledState} that the service accepts. */
export enum KnownPolicyEnabledState {
  Disabled = "Disabled",
  Enabled = "Enabled"
}

/**
 * Defines values for PolicyEnabledState. \
 * {@link KnownPolicyEnabledState} can be used interchangeably with PolicyEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled** \
 * **Enabled**
 */
export type PolicyEnabledState = string;

/** Known values of {@link PolicyMode} that the service accepts. */
export enum KnownPolicyMode {
  Prevention = "Prevention",
  Detection = "Detection"
}

/**
 * Defines values for PolicyMode. \
 * {@link KnownPolicyMode} can be used interchangeably with PolicyMode,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Prevention** \
 * **Detection**
 */
export type PolicyMode = string;

/** Known values of {@link PolicyRequestBodyCheck} that the service accepts. */
export enum KnownPolicyRequestBodyCheck {
  Disabled = "Disabled",
  Enabled = "Enabled"
}

/**
 * Defines values for PolicyRequestBodyCheck. \
 * {@link KnownPolicyRequestBodyCheck} can be used interchangeably with PolicyRequestBodyCheck,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled** \
 * **Enabled**
 */
export type PolicyRequestBodyCheck = string;

/** Known values of {@link CustomRuleEnabledState} that the service accepts. */
export enum KnownCustomRuleEnabledState {
  Disabled = "Disabled",
  Enabled = "Enabled"
}

/**
 * Defines values for CustomRuleEnabledState. \
 * {@link KnownCustomRuleEnabledState} can be used interchangeably with CustomRuleEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled** \
 * **Enabled**
 */
export type CustomRuleEnabledState = string;

/** Known values of {@link RuleType} that the service accepts. */
export enum KnownRuleType {
  MatchRule = "MatchRule",
  RateLimitRule = "RateLimitRule"
}

/**
 * Defines values for RuleType. \
 * {@link KnownRuleType} can be used interchangeably with RuleType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **MatchRule** \
 * **RateLimitRule**
 */
export type RuleType = string;

/** Known values of {@link MatchVariable} that the service accepts. */
export enum KnownMatchVariable {
  RemoteAddr = "RemoteAddr",
  RequestMethod = "RequestMethod",
  QueryString = "QueryString",
  PostArgs = "PostArgs",
  RequestUri = "RequestUri",
  RequestHeader = "RequestHeader",
  RequestBody = "RequestBody",
  Cookies = "Cookies",
  SocketAddr = "SocketAddr"
}

/**
 * Defines values for MatchVariable. \
 * {@link KnownMatchVariable} can be used interchangeably with MatchVariable,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **RemoteAddr** \
 * **RequestMethod** \
 * **QueryString** \
 * **PostArgs** \
 * **RequestUri** \
 * **RequestHeader** \
 * **RequestBody** \
 * **Cookies** \
 * **SocketAddr**
 */
export type MatchVariable = string;

/** Known values of {@link Operator} that the service accepts. */
export enum KnownOperator {
  Any = "Any",
  IPMatch = "IPMatch",
  GeoMatch = "GeoMatch",
  Equal = "Equal",
  Contains = "Contains",
  LessThan = "LessThan",
  GreaterThan = "GreaterThan",
  LessThanOrEqual = "LessThanOrEqual",
  GreaterThanOrEqual = "GreaterThanOrEqual",
  BeginsWith = "BeginsWith",
  EndsWith = "EndsWith",
  RegEx = "RegEx"
}

/**
 * Defines values for Operator. \
 * {@link KnownOperator} can be used interchangeably with Operator,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Any** \
 * **IPMatch** \
 * **GeoMatch** \
 * **Equal** \
 * **Contains** \
 * **LessThan** \
 * **GreaterThan** \
 * **LessThanOrEqual** \
 * **GreaterThanOrEqual** \
 * **BeginsWith** \
 * **EndsWith** \
 * **RegEx**
 */
export type Operator = string;

/** Known values of {@link TransformType} that the service accepts. */
export enum KnownTransformType {
  Lowercase = "Lowercase",
  Uppercase = "Uppercase",
  Trim = "Trim",
  UrlDecode = "UrlDecode",
  UrlEncode = "UrlEncode",
  RemoveNulls = "RemoveNulls"
}

/**
 * Defines values for TransformType. \
 * {@link KnownTransformType} can be used interchangeably with TransformType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Lowercase** \
 * **Uppercase** \
 * **Trim** \
 * **UrlDecode** \
 * **UrlEncode** \
 * **RemoveNulls**
 */
export type TransformType = string;

/** Known values of {@link ActionType} that the service accepts. */
export enum KnownActionType {
  Allow = "Allow",
  Block = "Block",
  Log = "Log",
  Redirect = "Redirect"
}

/**
 * Defines values for ActionType. \
 * {@link KnownActionType} can be used interchangeably with ActionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Allow** \
 * **Block** \
 * **Log** \
 * **Redirect**
 */
export type ActionType = string;

/** Known values of {@link ManagedRuleSetActionType} that the service accepts. */
export enum KnownManagedRuleSetActionType {
  Block = "Block",
  Log = "Log",
  Redirect = "Redirect"
}

/**
 * Defines values for ManagedRuleSetActionType. \
 * {@link KnownManagedRuleSetActionType} can be used interchangeably with ManagedRuleSetActionType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Block** \
 * **Log** \
 * **Redirect**
 */
export type ManagedRuleSetActionType = string;

/** Known values of {@link ManagedRuleExclusionMatchVariable} that the service accepts. */
export enum KnownManagedRuleExclusionMatchVariable {
  RequestHeaderNames = "RequestHeaderNames",
  RequestCookieNames = "RequestCookieNames",
  QueryStringArgNames = "QueryStringArgNames",
  RequestBodyPostArgNames = "RequestBodyPostArgNames",
  RequestBodyJsonArgNames = "RequestBodyJsonArgNames"
}

/**
 * Defines values for ManagedRuleExclusionMatchVariable. \
 * {@link KnownManagedRuleExclusionMatchVariable} can be used interchangeably with ManagedRuleExclusionMatchVariable,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **RequestHeaderNames** \
 * **RequestCookieNames** \
 * **QueryStringArgNames** \
 * **RequestBodyPostArgNames** \
 * **RequestBodyJsonArgNames**
 */
export type ManagedRuleExclusionMatchVariable = string;

/** Known values of {@link ManagedRuleExclusionSelectorMatchOperator} that the service accepts. */
export enum KnownManagedRuleExclusionSelectorMatchOperator {
  Equals = "Equals",
  Contains = "Contains",
  StartsWith = "StartsWith",
  EndsWith = "EndsWith",
  EqualsAny = "EqualsAny"
}

/**
 * Defines values for ManagedRuleExclusionSelectorMatchOperator. \
 * {@link KnownManagedRuleExclusionSelectorMatchOperator} can be used interchangeably with ManagedRuleExclusionSelectorMatchOperator,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Equals** \
 * **Contains** \
 * **StartsWith** \
 * **EndsWith** \
 * **EqualsAny**
 */
export type ManagedRuleExclusionSelectorMatchOperator = string;

/** Known values of {@link ManagedRuleEnabledState} that the service accepts. */
export enum KnownManagedRuleEnabledState {
  Disabled = "Disabled",
  Enabled = "Enabled"
}

/**
 * Defines values for ManagedRuleEnabledState. \
 * {@link KnownManagedRuleEnabledState} can be used interchangeably with ManagedRuleEnabledState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Disabled** \
 * **Enabled**
 */
export type ManagedRuleEnabledState = string;

/** Known values of {@link PolicyResourceState} that the service accepts. */
export enum KnownPolicyResourceState {
  Creating = "Creating",
  Enabling = "Enabling",
  Enabled = "Enabled",
  Disabling = "Disabling",
  Disabled = "Disabled",
  Deleting = "Deleting"
}

/**
 * Defines values for PolicyResourceState. \
 * {@link KnownPolicyResourceState} can be used interchangeably with PolicyResourceState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Creating** \
 * **Enabling** \
 * **Enabled** \
 * **Disabling** \
 * **Disabled** \
 * **Deleting**
 */
export type PolicyResourceState = string;

/** Known values of {@link SkuName} that the service accepts. */
export enum KnownSkuName {
  ClassicAzureFrontDoor = "Classic_AzureFrontDoor",
  StandardAzureFrontDoor = "Standard_AzureFrontDoor",
  PremiumAzureFrontDoor = "Premium_AzureFrontDoor"
}

/**
 * Defines values for SkuName. \
 * {@link KnownSkuName} can be used interchangeably with SkuName,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Classic_AzureFrontDoor** \
 * **Standard_AzureFrontDoor** \
 * **Premium_AzureFrontDoor**
 */
export type SkuName = string;

/** Known values of {@link NetworkOperationStatus} that the service accepts. */
export enum KnownNetworkOperationStatus {
  InProgress = "InProgress",
  Succeeded = "Succeeded",
  Failed = "Failed"
}

/**
 * Defines values for NetworkOperationStatus. \
 * {@link KnownNetworkOperationStatus} can be used interchangeably with NetworkOperationStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **InProgress** \
 * **Succeeded** \
 * **Failed**
 */
export type NetworkOperationStatus = string;

/** Known values of {@link FrontDoorForwardingProtocol} that the service accepts. */
export enum KnownFrontDoorForwardingProtocol {
  HttpOnly = "HttpOnly",
  HttpsOnly = "HttpsOnly",
  MatchRequest = "MatchRequest"
}

/**
 * Defines values for FrontDoorForwardingProtocol. \
 * {@link KnownFrontDoorForwardingProtocol} can be used interchangeably with FrontDoorForwardingProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **HttpOnly** \
 * **HttpsOnly** \
 * **MatchRequest**
 */
export type FrontDoorForwardingProtocol = string;

/** Known values of {@link FrontDoorQuery} that the service accepts. */
export enum KnownFrontDoorQuery {
  StripNone = "StripNone",
  StripAll = "StripAll",
  StripOnly = "StripOnly",
  StripAllExcept = "StripAllExcept"
}

/**
 * Defines values for FrontDoorQuery. \
 * {@link KnownFrontDoorQuery} can be used interchangeably with FrontDoorQuery,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **StripNone** \
 * **StripAll** \
 * **StripOnly** \
 * **StripAllExcept**
 */
export type FrontDoorQuery = string;

/** Known values of {@link DynamicCompressionEnabled} that the service accepts. */
export enum KnownDynamicCompressionEnabled {
  Enabled = "Enabled",
  Disabled = "Disabled"
}

/**
 * Defines values for DynamicCompressionEnabled. \
 * {@link KnownDynamicCompressionEnabled} can be used interchangeably with DynamicCompressionEnabled,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Enabled** \
 * **Disabled**
 */
export type DynamicCompressionEnabled = string;

/** Known values of {@link FrontDoorRedirectType} that the service accepts. */
export enum KnownFrontDoorRedirectType {
  Moved = "Moved",
  Found = "Found",
  TemporaryRedirect = "TemporaryRedirect",
  PermanentRedirect = "PermanentRedirect"
}

/**
 * Defines values for FrontDoorRedirectType. \
 * {@link KnownFrontDoorRedirectType} can be used interchangeably with FrontDoorRedirectType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Moved** \
 * **Found** \
 * **TemporaryRedirect** \
 * **PermanentRedirect**
 */
export type FrontDoorRedirectType = string;

/** Known values of {@link FrontDoorRedirectProtocol} that the service accepts. */
export enum KnownFrontDoorRedirectProtocol {
  HttpOnly = "HttpOnly",
  HttpsOnly = "HttpsOnly",
  MatchRequest = "MatchRequest"
}

/**
 * Defines values for FrontDoorRedirectProtocol. \
 * {@link KnownFrontDoorRedirectProtocol} can be used interchangeably with FrontDoorRedirectProtocol,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **HttpOnly** \
 * **HttpsOnly** \
 * **MatchRequest**
 */
export type FrontDoorRedirectProtocol = string;
/** Defines values for ResourceType. */
export type ResourceType =
  | "Microsoft.Network/frontDoors"
  | "Microsoft.Network/frontDoors/frontendEndpoints";

/** Optional parameters. */
export interface NetworkExperimentProfilesListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type NetworkExperimentProfilesListResponse = ProfileList;

/** Optional parameters. */
export interface NetworkExperimentProfilesListByResourceGroupOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByResourceGroup operation. */
export type NetworkExperimentProfilesListByResourceGroupResponse = ProfileList;

/** Optional parameters. */
export interface NetworkExperimentProfilesGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type NetworkExperimentProfilesGetResponse = Profile;

/** Optional parameters. */
export interface NetworkExperimentProfilesCreateOrUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type NetworkExperimentProfilesCreateOrUpdateResponse = Profile;

/** Optional parameters. */
export interface NetworkExperimentProfilesUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the update operation. */
export type NetworkExperimentProfilesUpdateResponse = Profile;

/** Optional parameters. */
export interface NetworkExperimentProfilesDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface NetworkExperimentProfilesListNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listNext operation. */
export type NetworkExperimentProfilesListNextResponse = ProfileList;

/** Optional parameters. */
export interface NetworkExperimentProfilesListByResourceGroupNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByResourceGroupNext operation. */
export type NetworkExperimentProfilesListByResourceGroupNextResponse = ProfileList;

/** Optional parameters. */
export interface PreconfiguredEndpointsListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type PreconfiguredEndpointsListResponse = PreconfiguredEndpointList;

/** Optional parameters. */
export interface PreconfiguredEndpointsListNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listNext operation. */
export type PreconfiguredEndpointsListNextResponse = PreconfiguredEndpointList;

/** Optional parameters. */
export interface ExperimentsListByProfileOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByProfile operation. */
export type ExperimentsListByProfileResponse = ExperimentList;

/** Optional parameters. */
export interface ExperimentsGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type ExperimentsGetResponse = Experiment;

/** Optional parameters. */
export interface ExperimentsCreateOrUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type ExperimentsCreateOrUpdateResponse = Experiment;

/** Optional parameters. */
export interface ExperimentsUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the update operation. */
export type ExperimentsUpdateResponse = Experiment;

/** Optional parameters. */
export interface ExperimentsDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface ExperimentsListByProfileNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByProfileNext operation. */
export type ExperimentsListByProfileNextResponse = ExperimentList;

/** Optional parameters. */
export interface ReportsGetLatencyScorecardsOptionalParams
  extends coreClient.OperationOptions {
  /** The end DateTime of the Latency Scorecard in UTC */
  endDateTimeUTC?: string;
  /** The country associated with the Latency Scorecard. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html */
  country?: string;
}

/** Contains response data for the getLatencyScorecards operation. */
export type ReportsGetLatencyScorecardsResponse = LatencyScorecard;

/** Optional parameters. */
export interface ReportsGetTimeseriesOptionalParams
  extends coreClient.OperationOptions {
  /** The country associated with the Timeseries. Values are country ISO codes as specified here- https://www.iso.org/iso-3166-country-codes.html */
  country?: string;
  /** The specific endpoint */
  endpoint?: string;
}

/** Contains response data for the getTimeseries operation. */
export type ReportsGetTimeseriesResponse = Timeseries;

/** Optional parameters. */
export interface FrontDoorNameAvailabilityCheckOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the check operation. */
export type FrontDoorNameAvailabilityCheckResponse = CheckNameAvailabilityOutput;

/** Optional parameters. */
export interface FrontDoorNameAvailabilityWithSubscriptionCheckOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the check operation. */
export type FrontDoorNameAvailabilityWithSubscriptionCheckResponse = CheckNameAvailabilityOutput;

/** Optional parameters. */
export interface FrontDoorsListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type FrontDoorsListResponse = FrontDoorListResult;

/** Optional parameters. */
export interface FrontDoorsListByResourceGroupOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByResourceGroup operation. */
export type FrontDoorsListByResourceGroupResponse = FrontDoorListResult;

/** Optional parameters. */
export interface FrontDoorsGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type FrontDoorsGetResponse = FrontDoor;

/** Optional parameters. */
export interface FrontDoorsCreateOrUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type FrontDoorsCreateOrUpdateResponse = FrontDoor;

/** Optional parameters. */
export interface FrontDoorsDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface FrontDoorsValidateCustomDomainOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the validateCustomDomain operation. */
export type FrontDoorsValidateCustomDomainResponse = ValidateCustomDomainOutput;

/** Optional parameters. */
export interface FrontDoorsListNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listNext operation. */
export type FrontDoorsListNextResponse = FrontDoorListResult;

/** Optional parameters. */
export interface FrontDoorsListByResourceGroupNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByResourceGroupNext operation. */
export type FrontDoorsListByResourceGroupNextResponse = FrontDoorListResult;

/** Optional parameters. */
export interface FrontendEndpointsListByFrontDoorOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByFrontDoor operation. */
export type FrontendEndpointsListByFrontDoorResponse = FrontendEndpointsListResult;

/** Optional parameters. */
export interface FrontendEndpointsGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type FrontendEndpointsGetResponse = FrontendEndpoint;

/** Optional parameters. */
export interface FrontendEndpointsEnableHttpsOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface FrontendEndpointsDisableHttpsOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface FrontendEndpointsListByFrontDoorNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByFrontDoorNext operation. */
export type FrontendEndpointsListByFrontDoorNextResponse = FrontendEndpointsListResult;

/** Optional parameters. */
export interface EndpointsPurgeContentOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface RulesEnginesListByFrontDoorOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByFrontDoor operation. */
export type RulesEnginesListByFrontDoorResponse = RulesEngineListResult;

/** Optional parameters. */
export interface RulesEnginesGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type RulesEnginesGetResponse = RulesEngine;

/** Optional parameters. */
export interface RulesEnginesCreateOrUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type RulesEnginesCreateOrUpdateResponse = RulesEngine;

/** Optional parameters. */
export interface RulesEnginesDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface RulesEnginesListByFrontDoorNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listByFrontDoorNext operation. */
export type RulesEnginesListByFrontDoorNextResponse = RulesEngineListResult;

/** Optional parameters. */
export interface PoliciesListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type PoliciesListResponse = WebApplicationFirewallPolicyList;

/** Optional parameters. */
export interface PoliciesGetOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the get operation. */
export type PoliciesGetResponse = WebApplicationFirewallPolicy;

/** Optional parameters. */
export interface PoliciesCreateOrUpdateOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type PoliciesCreateOrUpdateResponse = WebApplicationFirewallPolicy;

/** Optional parameters. */
export interface PoliciesDeleteOptionalParams
  extends coreClient.OperationOptions {
  /** Delay to wait until next poll, in milliseconds. */
  updateIntervalInMs?: number;
  /** A serialized poller which can be used to resume an existing paused Long-Running-Operation. */
  resumeFrom?: string;
}

/** Optional parameters. */
export interface PoliciesListNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listNext operation. */
export type PoliciesListNextResponse = WebApplicationFirewallPolicyList;

/** Optional parameters. */
export interface ManagedRuleSetsListOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the list operation. */
export type ManagedRuleSetsListResponse = ManagedRuleSetDefinitionList;

/** Optional parameters. */
export interface ManagedRuleSetsListNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listNext operation. */
export type ManagedRuleSetsListNextResponse = ManagedRuleSetDefinitionList;

/** Optional parameters. */
export interface FrontDoorManagementClientOptionalParams
  extends coreClient.ServiceClientOptions {
  /** server parameter */
  $host?: string;
  /** Overrides client endpoint. */
  endpoint?: string;
}
