/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
import * as coreClient from "@azure/core-client";
import * as coreRestPipeline from "@azure/core-rest-pipeline";
import { setContinuationToken } from "./pagingHelper.js";
import { createHttpPoller, } from "@azure/core-lro";
import { createLroSpec } from "./lroImpl.js";
import { ApplicationGatewaysImpl, ApplicationGatewayPrivateLinkResourcesImpl, ApplicationGatewayPrivateEndpointConnectionsImpl, ApplicationGatewayWafDynamicManifestsDefaultImpl, ApplicationGatewayWafDynamicManifestsImpl, ApplicationSecurityGroupsImpl, AvailableDelegationsImpl, AvailableResourceGroupDelegationsImpl, AvailableServiceAliasesImpl, AzureFirewallsImpl, AzureFirewallFqdnTagsImpl, WebCategoriesImpl, BastionHostsImpl, NetworkInterfacesImpl, PublicIPAddressesImpl, VipSwapImpl, CustomIPPrefixesImpl, DdosCustomPoliciesImpl, DdosProtectionPlansImpl, DscpConfigurationOperationsImpl, AvailableEndpointServicesImpl, ExpressRouteCircuitAuthorizationsImpl, ExpressRouteCircuitPeeringsImpl, ExpressRouteCircuitConnectionsImpl, PeerExpressRouteCircuitConnectionsImpl, ExpressRouteCircuitsImpl, ExpressRouteServiceProvidersImpl, ExpressRouteCrossConnectionsImpl, ExpressRouteCrossConnectionPeeringsImpl, ExpressRoutePortsLocationsImpl, ExpressRoutePortsImpl, ExpressRouteLinksImpl, ExpressRoutePortAuthorizationsImpl, ExpressRouteProviderPortsLocationImpl, FirewallPoliciesImpl, FirewallPolicyRuleCollectionGroupsImpl, FirewallPolicyIdpsSignaturesImpl, FirewallPolicyIdpsSignaturesOverridesImpl, FirewallPolicyIdpsSignaturesFilterValuesImpl, FirewallPolicyDraftsImpl, FirewallPolicyDeploymentsImpl, FirewallPolicyRuleCollectionGroupDraftsImpl, IpamPoolsImpl, StaticCidrsImpl, IpAllocationsImpl, IpGroupsImpl, LoadBalancersImpl, LoadBalancerBackendAddressPoolsImpl, LoadBalancerFrontendIPConfigurationsImpl, InboundNatRulesImpl, LoadBalancerLoadBalancingRulesImpl, LoadBalancerOutboundRulesImpl, LoadBalancerNetworkInterfacesImpl, LoadBalancerProbesImpl, NatGatewaysImpl, NetworkInterfaceIPConfigurationsImpl, NetworkInterfaceLoadBalancersImpl, NetworkInterfaceTapConfigurationsImpl, NetworkManagersImpl, NetworkManagerCommitsImpl, NetworkManagerDeploymentStatusOperationsImpl, SubscriptionNetworkManagerConnectionsImpl, ManagementGroupNetworkManagerConnectionsImpl, ConnectivityConfigurationsImpl, NetworkGroupsImpl, StaticMembersImpl, NetworkManagerRoutingConfigurationsImpl, RoutingRuleCollectionsImpl, RoutingRulesImpl, ScopeConnectionsImpl, SecurityAdminConfigurationsImpl, AdminRuleCollectionsImpl, AdminRulesImpl, SecurityUserConfigurationsImpl, SecurityUserRuleCollectionsImpl, SecurityUserRulesImpl, NetworkProfilesImpl, NetworkSecurityGroupsImpl, SecurityRulesImpl, DefaultSecurityRulesImpl, ReachabilityAnalysisIntentsImpl, ReachabilityAnalysisRunsImpl, VerifierWorkspacesImpl, NetworkVirtualAppliancesImpl, VirtualApplianceSitesImpl, VirtualApplianceSkusImpl, InboundSecurityRuleOperationsImpl, NetworkWatchersImpl, PacketCapturesImpl, ConnectionMonitorsImpl, FlowLogsImpl, OperationsImpl, PrivateEndpointsImpl, AvailablePrivateEndpointTypesImpl, PrivateDnsZoneGroupsImpl, PrivateLinkServicesImpl, PublicIPPrefixesImpl, RouteFiltersImpl, RouteFilterRulesImpl, RouteTablesImpl, RoutesImpl, SecurityPartnerProvidersImpl, BgpServiceCommunitiesImpl, ServiceEndpointPoliciesImpl, ServiceEndpointPolicyDefinitionsImpl, ServiceTagsImpl, ServiceTagInformationOperationsImpl, UsagesImpl, VirtualNetworksImpl, SubnetsImpl, ResourceNavigationLinksImpl, ServiceAssociationLinksImpl, VirtualNetworkPeeringsImpl, VirtualNetworkGatewaysImpl, VirtualNetworkGatewayConnectionsImpl, LocalNetworkGatewaysImpl, VirtualNetworkGatewayNatRulesImpl, VirtualNetworkTapsImpl, VirtualRoutersImpl, VirtualRouterPeeringsImpl, VirtualWansImpl, VpnSitesImpl, VpnSiteLinksImpl, VpnSitesConfigurationImpl, VpnServerConfigurationsImpl, ConfigurationPolicyGroupsImpl, VirtualHubsImpl, RouteMapsImpl, HubVirtualNetworkConnectionsImpl, VpnGatewaysImpl, VpnLinkConnectionsImpl, VpnConnectionsImpl, VpnSiteLinkConnectionsImpl, NatRulesImpl, P2SVpnGatewaysImpl, VpnServerConfigurationsAssociatedWithVirtualWanImpl, VirtualHubRouteTableV2SImpl, ExpressRouteGatewaysImpl, ExpressRouteConnectionsImpl, NetworkVirtualApplianceConnectionsImpl, VirtualHubBgpConnectionImpl, VirtualHubBgpConnectionsImpl, VirtualHubIpConfigurationImpl, HubRouteTablesImpl, RoutingIntentOperationsImpl, WebApplicationFirewallPoliciesImpl, } from "./operations/index.js";
import * as Parameters from "./models/parameters.js";
import * as Mappers from "./models/mappers.js";
/// <reference lib="esnext.asynciterable" />
export class NetworkManagementClient extends coreClient.ServiceClient {
    constructor(credentials, subscriptionIdOrOptions, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        let subscriptionId;
        if (typeof subscriptionIdOrOptions === "string") {
            subscriptionId = subscriptionIdOrOptions;
        }
        else if (typeof subscriptionIdOrOptions === "object") {
            options = subscriptionIdOrOptions;
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials,
        };
        const packageDetails = `azsdk-js-arm-network/33.5.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline.bearerTokenAuthenticationPolicyName,
            });
            this.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient.authorizeRequestOnClaimChallenge,
                },
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.applicationGateways = new ApplicationGatewaysImpl(this);
        this.applicationGatewayPrivateLinkResources =
            new ApplicationGatewayPrivateLinkResourcesImpl(this);
        this.applicationGatewayPrivateEndpointConnections =
            new ApplicationGatewayPrivateEndpointConnectionsImpl(this);
        this.applicationGatewayWafDynamicManifestsDefault =
            new ApplicationGatewayWafDynamicManifestsDefaultImpl(this);
        this.applicationGatewayWafDynamicManifests =
            new ApplicationGatewayWafDynamicManifestsImpl(this);
        this.applicationSecurityGroups = new ApplicationSecurityGroupsImpl(this);
        this.availableDelegations = new AvailableDelegationsImpl(this);
        this.availableResourceGroupDelegations =
            new AvailableResourceGroupDelegationsImpl(this);
        this.availableServiceAliases = new AvailableServiceAliasesImpl(this);
        this.azureFirewalls = new AzureFirewallsImpl(this);
        this.azureFirewallFqdnTags = new AzureFirewallFqdnTagsImpl(this);
        this.webCategories = new WebCategoriesImpl(this);
        this.bastionHosts = new BastionHostsImpl(this);
        this.networkInterfaces = new NetworkInterfacesImpl(this);
        this.publicIPAddresses = new PublicIPAddressesImpl(this);
        this.vipSwap = new VipSwapImpl(this);
        this.customIPPrefixes = new CustomIPPrefixesImpl(this);
        this.ddosCustomPolicies = new DdosCustomPoliciesImpl(this);
        this.ddosProtectionPlans = new DdosProtectionPlansImpl(this);
        this.dscpConfigurationOperations = new DscpConfigurationOperationsImpl(this);
        this.availableEndpointServices = new AvailableEndpointServicesImpl(this);
        this.expressRouteCircuitAuthorizations =
            new ExpressRouteCircuitAuthorizationsImpl(this);
        this.expressRouteCircuitPeerings = new ExpressRouteCircuitPeeringsImpl(this);
        this.expressRouteCircuitConnections =
            new ExpressRouteCircuitConnectionsImpl(this);
        this.peerExpressRouteCircuitConnections =
            new PeerExpressRouteCircuitConnectionsImpl(this);
        this.expressRouteCircuits = new ExpressRouteCircuitsImpl(this);
        this.expressRouteServiceProviders = new ExpressRouteServiceProvidersImpl(this);
        this.expressRouteCrossConnections = new ExpressRouteCrossConnectionsImpl(this);
        this.expressRouteCrossConnectionPeerings =
            new ExpressRouteCrossConnectionPeeringsImpl(this);
        this.expressRoutePortsLocations = new ExpressRoutePortsLocationsImpl(this);
        this.expressRoutePorts = new ExpressRoutePortsImpl(this);
        this.expressRouteLinks = new ExpressRouteLinksImpl(this);
        this.expressRoutePortAuthorizations =
            new ExpressRoutePortAuthorizationsImpl(this);
        this.expressRouteProviderPortsLocation =
            new ExpressRouteProviderPortsLocationImpl(this);
        this.firewallPolicies = new FirewallPoliciesImpl(this);
        this.firewallPolicyRuleCollectionGroups =
            new FirewallPolicyRuleCollectionGroupsImpl(this);
        this.firewallPolicyIdpsSignatures = new FirewallPolicyIdpsSignaturesImpl(this);
        this.firewallPolicyIdpsSignaturesOverrides =
            new FirewallPolicyIdpsSignaturesOverridesImpl(this);
        this.firewallPolicyIdpsSignaturesFilterValues =
            new FirewallPolicyIdpsSignaturesFilterValuesImpl(this);
        this.firewallPolicyDrafts = new FirewallPolicyDraftsImpl(this);
        this.firewallPolicyDeployments = new FirewallPolicyDeploymentsImpl(this);
        this.firewallPolicyRuleCollectionGroupDrafts =
            new FirewallPolicyRuleCollectionGroupDraftsImpl(this);
        this.ipamPools = new IpamPoolsImpl(this);
        this.staticCidrs = new StaticCidrsImpl(this);
        this.ipAllocations = new IpAllocationsImpl(this);
        this.ipGroups = new IpGroupsImpl(this);
        this.loadBalancers = new LoadBalancersImpl(this);
        this.loadBalancerBackendAddressPools =
            new LoadBalancerBackendAddressPoolsImpl(this);
        this.loadBalancerFrontendIPConfigurations =
            new LoadBalancerFrontendIPConfigurationsImpl(this);
        this.inboundNatRules = new InboundNatRulesImpl(this);
        this.loadBalancerLoadBalancingRules =
            new LoadBalancerLoadBalancingRulesImpl(this);
        this.loadBalancerOutboundRules = new LoadBalancerOutboundRulesImpl(this);
        this.loadBalancerNetworkInterfaces = new LoadBalancerNetworkInterfacesImpl(this);
        this.loadBalancerProbes = new LoadBalancerProbesImpl(this);
        this.natGateways = new NatGatewaysImpl(this);
        this.networkInterfaceIPConfigurations =
            new NetworkInterfaceIPConfigurationsImpl(this);
        this.networkInterfaceLoadBalancers = new NetworkInterfaceLoadBalancersImpl(this);
        this.networkInterfaceTapConfigurations =
            new NetworkInterfaceTapConfigurationsImpl(this);
        this.networkManagers = new NetworkManagersImpl(this);
        this.networkManagerCommits = new NetworkManagerCommitsImpl(this);
        this.networkManagerDeploymentStatusOperations =
            new NetworkManagerDeploymentStatusOperationsImpl(this);
        this.subscriptionNetworkManagerConnections =
            new SubscriptionNetworkManagerConnectionsImpl(this);
        this.managementGroupNetworkManagerConnections =
            new ManagementGroupNetworkManagerConnectionsImpl(this);
        this.connectivityConfigurations = new ConnectivityConfigurationsImpl(this);
        this.networkGroups = new NetworkGroupsImpl(this);
        this.staticMembers = new StaticMembersImpl(this);
        this.networkManagerRoutingConfigurations =
            new NetworkManagerRoutingConfigurationsImpl(this);
        this.routingRuleCollections = new RoutingRuleCollectionsImpl(this);
        this.routingRules = new RoutingRulesImpl(this);
        this.scopeConnections = new ScopeConnectionsImpl(this);
        this.securityAdminConfigurations = new SecurityAdminConfigurationsImpl(this);
        this.adminRuleCollections = new AdminRuleCollectionsImpl(this);
        this.adminRules = new AdminRulesImpl(this);
        this.securityUserConfigurations = new SecurityUserConfigurationsImpl(this);
        this.securityUserRuleCollections = new SecurityUserRuleCollectionsImpl(this);
        this.securityUserRules = new SecurityUserRulesImpl(this);
        this.networkProfiles = new NetworkProfilesImpl(this);
        this.networkSecurityGroups = new NetworkSecurityGroupsImpl(this);
        this.securityRules = new SecurityRulesImpl(this);
        this.defaultSecurityRules = new DefaultSecurityRulesImpl(this);
        this.reachabilityAnalysisIntents = new ReachabilityAnalysisIntentsImpl(this);
        this.reachabilityAnalysisRuns = new ReachabilityAnalysisRunsImpl(this);
        this.verifierWorkspaces = new VerifierWorkspacesImpl(this);
        this.networkVirtualAppliances = new NetworkVirtualAppliancesImpl(this);
        this.virtualApplianceSites = new VirtualApplianceSitesImpl(this);
        this.virtualApplianceSkus = new VirtualApplianceSkusImpl(this);
        this.inboundSecurityRuleOperations = new InboundSecurityRuleOperationsImpl(this);
        this.networkWatchers = new NetworkWatchersImpl(this);
        this.packetCaptures = new PacketCapturesImpl(this);
        this.connectionMonitors = new ConnectionMonitorsImpl(this);
        this.flowLogs = new FlowLogsImpl(this);
        this.operations = new OperationsImpl(this);
        this.privateEndpoints = new PrivateEndpointsImpl(this);
        this.availablePrivateEndpointTypes = new AvailablePrivateEndpointTypesImpl(this);
        this.privateDnsZoneGroups = new PrivateDnsZoneGroupsImpl(this);
        this.privateLinkServices = new PrivateLinkServicesImpl(this);
        this.publicIPPrefixes = new PublicIPPrefixesImpl(this);
        this.routeFilters = new RouteFiltersImpl(this);
        this.routeFilterRules = new RouteFilterRulesImpl(this);
        this.routeTables = new RouteTablesImpl(this);
        this.routes = new RoutesImpl(this);
        this.securityPartnerProviders = new SecurityPartnerProvidersImpl(this);
        this.bgpServiceCommunities = new BgpServiceCommunitiesImpl(this);
        this.serviceEndpointPolicies = new ServiceEndpointPoliciesImpl(this);
        this.serviceEndpointPolicyDefinitions =
            new ServiceEndpointPolicyDefinitionsImpl(this);
        this.serviceTags = new ServiceTagsImpl(this);
        this.serviceTagInformationOperations =
            new ServiceTagInformationOperationsImpl(this);
        this.usages = new UsagesImpl(this);
        this.virtualNetworks = new VirtualNetworksImpl(this);
        this.subnets = new SubnetsImpl(this);
        this.resourceNavigationLinks = new ResourceNavigationLinksImpl(this);
        this.serviceAssociationLinks = new ServiceAssociationLinksImpl(this);
        this.virtualNetworkPeerings = new VirtualNetworkPeeringsImpl(this);
        this.virtualNetworkGateways = new VirtualNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayConnections =
            new VirtualNetworkGatewayConnectionsImpl(this);
        this.localNetworkGateways = new LocalNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayNatRules = new VirtualNetworkGatewayNatRulesImpl(this);
        this.virtualNetworkTaps = new VirtualNetworkTapsImpl(this);
        this.virtualRouters = new VirtualRoutersImpl(this);
        this.virtualRouterPeerings = new VirtualRouterPeeringsImpl(this);
        this.virtualWans = new VirtualWansImpl(this);
        this.vpnSites = new VpnSitesImpl(this);
        this.vpnSiteLinks = new VpnSiteLinksImpl(this);
        this.vpnSitesConfiguration = new VpnSitesConfigurationImpl(this);
        this.vpnServerConfigurations = new VpnServerConfigurationsImpl(this);
        this.configurationPolicyGroups = new ConfigurationPolicyGroupsImpl(this);
        this.virtualHubs = new VirtualHubsImpl(this);
        this.routeMaps = new RouteMapsImpl(this);
        this.hubVirtualNetworkConnections = new HubVirtualNetworkConnectionsImpl(this);
        this.vpnGateways = new VpnGatewaysImpl(this);
        this.vpnLinkConnections = new VpnLinkConnectionsImpl(this);
        this.vpnConnections = new VpnConnectionsImpl(this);
        this.vpnSiteLinkConnections = new VpnSiteLinkConnectionsImpl(this);
        this.natRules = new NatRulesImpl(this);
        this.p2SVpnGateways = new P2SVpnGatewaysImpl(this);
        this.vpnServerConfigurationsAssociatedWithVirtualWan =
            new VpnServerConfigurationsAssociatedWithVirtualWanImpl(this);
        this.virtualHubRouteTableV2S = new VirtualHubRouteTableV2SImpl(this);
        this.expressRouteGateways = new ExpressRouteGatewaysImpl(this);
        this.expressRouteConnections = new ExpressRouteConnectionsImpl(this);
        this.networkVirtualApplianceConnections =
            new NetworkVirtualApplianceConnectionsImpl(this);
        this.virtualHubBgpConnection = new VirtualHubBgpConnectionImpl(this);
        this.virtualHubBgpConnections = new VirtualHubBgpConnectionsImpl(this);
        this.virtualHubIpConfiguration = new VirtualHubIpConfigurationImpl(this);
        this.hubRouteTables = new HubRouteTablesImpl(this);
        this.routingIntentOperations = new RoutingIntentOperationsImpl(this);
        this.webApplicationFirewallPolicies =
            new WebApplicationFirewallPoliciesImpl(this);
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginListPutBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings);
            },
        };
    }
    putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings) {
        return __asyncGenerator(this, arguments, function* putBastionShareableLinkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield __await(this._putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
                result = yield __await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return __asyncGenerator(this, arguments, function* putBastionShareableLinkPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    listBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings);
            },
        };
    }
    getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings) {
        return __asyncGenerator(this, arguments, function* getBastionShareableLinkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return __asyncGenerator(this, arguments, function* getBastionShareableLinkPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginListActiveSessionsAndWait(resourceGroupName, bastionHostName, options) {
        const iter = this.getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options, settings);
            },
        };
    }
    getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options, settings) {
        return __asyncGenerator(this, arguments, function* getActiveSessionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield __await(this._getActiveSessions(resourceGroupName, bastionHostName, options));
                result = yield __await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._getActiveSessionsNext(resourceGroupName, bastionHostName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options) {
        return __asyncGenerator(this, arguments, function* getActiveSessionsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    listDisconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        const iter = this.disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options, settings);
            },
        };
    }
    disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options, settings) {
        return __asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options) {
        return __asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    async _putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, bastionHostName, bslRequest, options },
            spec: putBastionShareableLinkOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    async beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, bastionHostName, bslRequest, options },
            spec: deleteBastionShareableLinkOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    async beginDeleteBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        const poller = await this.beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options);
        return poller.pollUntilDone();
    }
    /**
     * Deletes the Bastion Shareable Links for all the tokens specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslTokenRequest Post request for Delete Bastion Shareable Link By Token endpoint.
     * @param options The options parameters.
     */
    async beginDeleteBastionShareableLinkByToken(resourceGroupName, bastionHostName, bslTokenRequest, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, bastionHostName, bslTokenRequest, options },
            spec: deleteBastionShareableLinkByTokenOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Deletes the Bastion Shareable Links for all the tokens specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslTokenRequest Post request for Delete Bastion Shareable Link By Token endpoint.
     * @param options The options parameters.
     */
    async beginDeleteBastionShareableLinkByTokenAndWait(resourceGroupName, bastionHostName, bslTokenRequest, options) {
        const poller = await this.beginDeleteBastionShareableLinkByToken(resourceGroupName, bastionHostName, bslTokenRequest, options);
        return poller.pollUntilDone();
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    _getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, options }, getBastionShareableLinkOperationSpec);
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    async _getActiveSessions(resourceGroupName, bastionHostName, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, bastionHostName, options },
            spec: getActiveSessionsOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    _disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, options }, disconnectActiveSessionsOperationSpec);
    }
    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular
     *                        expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param options The options parameters.
     */
    checkDnsNameAvailability(location, domainNameLabel, options) {
        return this.sendOperationRequest({ location, domainNameLabel, options }, checkDnsNameAvailabilityOperationSpec);
    }
    /**
     * Retrieves detail of a provider port.
     * @param providerport The name of the provider port.
     * @param options The options parameters.
     */
    expressRouteProviderPort(providerport, options) {
        return this.sendOperationRequest({ providerport, options }, expressRouteProviderPortOperationSpec);
    }
    /**
     * Lists active connectivity configurations in a network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Active Configuration Parameter.
     * @param options The options parameters.
     */
    listActiveConnectivityConfigurations(resourceGroupName, networkManagerName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, listActiveConnectivityConfigurationsOperationSpec);
    }
    /**
     * Lists active security admin rules in a network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Active Configuration Parameter.
     * @param options The options parameters.
     */
    listActiveSecurityAdminRules(resourceGroupName, networkManagerName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, listActiveSecurityAdminRulesOperationSpec);
    }
    /**
     * List all effective connectivity configurations applied on a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to list correct page.
     * @param options The options parameters.
     */
    listNetworkManagerEffectiveConnectivityConfigurations(resourceGroupName, virtualNetworkName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualNetworkName, parameters, options }, listNetworkManagerEffectiveConnectivityConfigurationsOperationSpec);
    }
    /**
     * List all effective security admin rules applied on a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to list correct page.
     * @param options The options parameters.
     */
    listNetworkManagerEffectiveSecurityAdminRules(resourceGroupName, virtualNetworkName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualNetworkName, parameters, options }, listNetworkManagerEffectiveSecurityAdminRulesOperationSpec);
    }
    /**
     * Gives the supported security providers for the virtual wan.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which supported security providers are needed.
     * @param options The options parameters.
     */
    supportedSecurityProviders(resourceGroupName, virtualWANName, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualWANName, options }, supportedSecurityProvidersOperationSpec);
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    async beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = createLroSpec({
            sendOperationFn,
            args: { resourceGroupName, virtualWANName, vpnClientParams, options },
            spec: generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec,
        });
        const poller = await createHttpPoller(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    async beginGeneratevirtualwanvpnserverconfigurationvpnprofileAndWait(resourceGroupName, virtualWANName, vpnClientParams, options) {
        const poller = await this.beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options);
        return poller.pollUntilDone();
    }
    /**
     * PutBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the PutBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, putBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the GetBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, getBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param nextLink The nextLink from the previous successful call to the GetActiveSessions method.
     * @param options The options parameters.
     */
    _getActiveSessionsNext(resourceGroupName, bastionHostName, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, nextLink, options }, getActiveSessionsNextOperationSpec);
    }
    /**
     * DisconnectActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param nextLink The nextLink from the previous successful call to the DisconnectActiveSessions
     *                 method.
     * @param options The options parameters.
     */
    _disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, nextLink, options }, disconnectActiveSessionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const putBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/createShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        201: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        202: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        204: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const deleteBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const deleteBastionShareableLinkByTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinksByToken",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: Mappers.NetworkManagementClientDeleteBastionShareableLinkByTokenHeaders,
        },
        201: {
            headersMapper: Mappers.NetworkManagementClientDeleteBastionShareableLinkByTokenHeaders,
        },
        202: {
            headersMapper: Mappers.NetworkManagementClientDeleteBastionShareableLinkByTokenHeaders,
        },
        204: {
            headersMapper: Mappers.NetworkManagementClientDeleteBastionShareableLinkByTokenHeaders,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.bslTokenRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        201: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        202: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        204: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const disconnectActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/disconnectActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionSessionDeleteResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.sessionIds,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const checkDnsNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DnsNameAvailabilityResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion, Parameters.domainNameLabel],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.location,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const expressRouteProviderPortOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteProviderPorts/{providerport}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ExpressRouteProviderPort,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.providerport,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listActiveConnectivityConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/listActiveConnectivityConfigurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ActiveConnectivityConfigurationsListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters7,
    queryParameters: [Parameters.apiVersion, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.networkManagerName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listActiveSecurityAdminRulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/listActiveSecurityAdminRules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ActiveSecurityAdminRulesListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters7,
    queryParameters: [Parameters.apiVersion, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.networkManagerName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listNetworkManagerEffectiveConnectivityConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/listNetworkManagerEffectiveConnectivityConfigurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.NetworkManagerEffectiveConnectivityConfigurationListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters8,
    queryParameters: [Parameters.apiVersion, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualNetworkName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listNetworkManagerEffectiveSecurityAdminRulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/listNetworkManagerEffectiveSecurityAdminRules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.NetworkManagerEffectiveSecurityAdminRulesListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters8,
    queryParameters: [Parameters.apiVersion, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualNetworkName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const supportedSecurityProvidersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/supportedSecurityProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.VirtualWanSecurityProviders,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualWANName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/GenerateVpnProfile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.VpnProfileResponse,
        },
        201: {
            bodyMapper: Mappers.VpnProfileResponse,
        },
        202: {
            bodyMapper: Mappers.VpnProfileResponse,
        },
        204: {
            bodyMapper: Mappers.VpnProfileResponse,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.vpnClientParams,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualWANName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const putBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        202: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        202: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const disconnectActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionSessionDeleteResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
//# sourceMappingURL=networkManagementClient.js.map