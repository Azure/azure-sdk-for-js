"use strict";
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkManagementClient = void 0;
const tslib_1 = require("tslib");
const coreClient = tslib_1.__importStar(require("@azure/core-client"));
const coreRestPipeline = tslib_1.__importStar(require("@azure/core-rest-pipeline"));
const pagingHelper_js_1 = require("./pagingHelper.js");
const core_lro_1 = require("@azure/core-lro");
const lroImpl_js_1 = require("./lroImpl.js");
const index_js_1 = require("./operations/index.js");
const Parameters = tslib_1.__importStar(require("./models/parameters.js"));
const Mappers = tslib_1.__importStar(require("./models/mappers.js"));
/// <reference lib="esnext.asynciterable" />
class NetworkManagementClient extends coreClient.ServiceClient {
    constructor(credentials, subscriptionIdOrOptions, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        let subscriptionId;
        if (typeof subscriptionIdOrOptions === "string") {
            subscriptionId = subscriptionIdOrOptions;
        }
        else if (typeof subscriptionIdOrOptions === "object") {
            options = subscriptionIdOrOptions;
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials,
        };
        const packageDetails = `azsdk-js-arm-network/33.5.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline.bearerTokenAuthenticationPolicyName,
            });
            this.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient.authorizeRequestOnClaimChallenge,
                },
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.applicationGateways = new index_js_1.ApplicationGatewaysImpl(this);
        this.applicationGatewayPrivateLinkResources =
            new index_js_1.ApplicationGatewayPrivateLinkResourcesImpl(this);
        this.applicationGatewayPrivateEndpointConnections =
            new index_js_1.ApplicationGatewayPrivateEndpointConnectionsImpl(this);
        this.applicationGatewayWafDynamicManifestsDefault =
            new index_js_1.ApplicationGatewayWafDynamicManifestsDefaultImpl(this);
        this.applicationGatewayWafDynamicManifests =
            new index_js_1.ApplicationGatewayWafDynamicManifestsImpl(this);
        this.applicationSecurityGroups = new index_js_1.ApplicationSecurityGroupsImpl(this);
        this.availableDelegations = new index_js_1.AvailableDelegationsImpl(this);
        this.availableResourceGroupDelegations =
            new index_js_1.AvailableResourceGroupDelegationsImpl(this);
        this.availableServiceAliases = new index_js_1.AvailableServiceAliasesImpl(this);
        this.azureFirewalls = new index_js_1.AzureFirewallsImpl(this);
        this.azureFirewallFqdnTags = new index_js_1.AzureFirewallFqdnTagsImpl(this);
        this.webCategories = new index_js_1.WebCategoriesImpl(this);
        this.bastionHosts = new index_js_1.BastionHostsImpl(this);
        this.networkInterfaces = new index_js_1.NetworkInterfacesImpl(this);
        this.publicIPAddresses = new index_js_1.PublicIPAddressesImpl(this);
        this.vipSwap = new index_js_1.VipSwapImpl(this);
        this.customIPPrefixes = new index_js_1.CustomIPPrefixesImpl(this);
        this.ddosCustomPolicies = new index_js_1.DdosCustomPoliciesImpl(this);
        this.ddosProtectionPlans = new index_js_1.DdosProtectionPlansImpl(this);
        this.dscpConfigurationOperations = new index_js_1.DscpConfigurationOperationsImpl(this);
        this.availableEndpointServices = new index_js_1.AvailableEndpointServicesImpl(this);
        this.expressRouteCircuitAuthorizations =
            new index_js_1.ExpressRouteCircuitAuthorizationsImpl(this);
        this.expressRouteCircuitPeerings = new index_js_1.ExpressRouteCircuitPeeringsImpl(this);
        this.expressRouteCircuitConnections =
            new index_js_1.ExpressRouteCircuitConnectionsImpl(this);
        this.peerExpressRouteCircuitConnections =
            new index_js_1.PeerExpressRouteCircuitConnectionsImpl(this);
        this.expressRouteCircuits = new index_js_1.ExpressRouteCircuitsImpl(this);
        this.expressRouteServiceProviders = new index_js_1.ExpressRouteServiceProvidersImpl(this);
        this.expressRouteCrossConnections = new index_js_1.ExpressRouteCrossConnectionsImpl(this);
        this.expressRouteCrossConnectionPeerings =
            new index_js_1.ExpressRouteCrossConnectionPeeringsImpl(this);
        this.expressRoutePortsLocations = new index_js_1.ExpressRoutePortsLocationsImpl(this);
        this.expressRoutePorts = new index_js_1.ExpressRoutePortsImpl(this);
        this.expressRouteLinks = new index_js_1.ExpressRouteLinksImpl(this);
        this.expressRoutePortAuthorizations =
            new index_js_1.ExpressRoutePortAuthorizationsImpl(this);
        this.expressRouteProviderPortsLocation =
            new index_js_1.ExpressRouteProviderPortsLocationImpl(this);
        this.firewallPolicies = new index_js_1.FirewallPoliciesImpl(this);
        this.firewallPolicyRuleCollectionGroups =
            new index_js_1.FirewallPolicyRuleCollectionGroupsImpl(this);
        this.firewallPolicyIdpsSignatures = new index_js_1.FirewallPolicyIdpsSignaturesImpl(this);
        this.firewallPolicyIdpsSignaturesOverrides =
            new index_js_1.FirewallPolicyIdpsSignaturesOverridesImpl(this);
        this.firewallPolicyIdpsSignaturesFilterValues =
            new index_js_1.FirewallPolicyIdpsSignaturesFilterValuesImpl(this);
        this.firewallPolicyDrafts = new index_js_1.FirewallPolicyDraftsImpl(this);
        this.firewallPolicyDeployments = new index_js_1.FirewallPolicyDeploymentsImpl(this);
        this.firewallPolicyRuleCollectionGroupDrafts =
            new index_js_1.FirewallPolicyRuleCollectionGroupDraftsImpl(this);
        this.ipamPools = new index_js_1.IpamPoolsImpl(this);
        this.staticCidrs = new index_js_1.StaticCidrsImpl(this);
        this.ipAllocations = new index_js_1.IpAllocationsImpl(this);
        this.ipGroups = new index_js_1.IpGroupsImpl(this);
        this.loadBalancers = new index_js_1.LoadBalancersImpl(this);
        this.loadBalancerBackendAddressPools =
            new index_js_1.LoadBalancerBackendAddressPoolsImpl(this);
        this.loadBalancerFrontendIPConfigurations =
            new index_js_1.LoadBalancerFrontendIPConfigurationsImpl(this);
        this.inboundNatRules = new index_js_1.InboundNatRulesImpl(this);
        this.loadBalancerLoadBalancingRules =
            new index_js_1.LoadBalancerLoadBalancingRulesImpl(this);
        this.loadBalancerOutboundRules = new index_js_1.LoadBalancerOutboundRulesImpl(this);
        this.loadBalancerNetworkInterfaces = new index_js_1.LoadBalancerNetworkInterfacesImpl(this);
        this.loadBalancerProbes = new index_js_1.LoadBalancerProbesImpl(this);
        this.natGateways = new index_js_1.NatGatewaysImpl(this);
        this.networkInterfaceIPConfigurations =
            new index_js_1.NetworkInterfaceIPConfigurationsImpl(this);
        this.networkInterfaceLoadBalancers = new index_js_1.NetworkInterfaceLoadBalancersImpl(this);
        this.networkInterfaceTapConfigurations =
            new index_js_1.NetworkInterfaceTapConfigurationsImpl(this);
        this.networkManagers = new index_js_1.NetworkManagersImpl(this);
        this.networkManagerCommits = new index_js_1.NetworkManagerCommitsImpl(this);
        this.networkManagerDeploymentStatusOperations =
            new index_js_1.NetworkManagerDeploymentStatusOperationsImpl(this);
        this.subscriptionNetworkManagerConnections =
            new index_js_1.SubscriptionNetworkManagerConnectionsImpl(this);
        this.managementGroupNetworkManagerConnections =
            new index_js_1.ManagementGroupNetworkManagerConnectionsImpl(this);
        this.connectivityConfigurations = new index_js_1.ConnectivityConfigurationsImpl(this);
        this.networkGroups = new index_js_1.NetworkGroupsImpl(this);
        this.staticMembers = new index_js_1.StaticMembersImpl(this);
        this.networkManagerRoutingConfigurations =
            new index_js_1.NetworkManagerRoutingConfigurationsImpl(this);
        this.routingRuleCollections = new index_js_1.RoutingRuleCollectionsImpl(this);
        this.routingRules = new index_js_1.RoutingRulesImpl(this);
        this.scopeConnections = new index_js_1.ScopeConnectionsImpl(this);
        this.securityAdminConfigurations = new index_js_1.SecurityAdminConfigurationsImpl(this);
        this.adminRuleCollections = new index_js_1.AdminRuleCollectionsImpl(this);
        this.adminRules = new index_js_1.AdminRulesImpl(this);
        this.securityUserConfigurations = new index_js_1.SecurityUserConfigurationsImpl(this);
        this.securityUserRuleCollections = new index_js_1.SecurityUserRuleCollectionsImpl(this);
        this.securityUserRules = new index_js_1.SecurityUserRulesImpl(this);
        this.networkProfiles = new index_js_1.NetworkProfilesImpl(this);
        this.networkSecurityGroups = new index_js_1.NetworkSecurityGroupsImpl(this);
        this.securityRules = new index_js_1.SecurityRulesImpl(this);
        this.defaultSecurityRules = new index_js_1.DefaultSecurityRulesImpl(this);
        this.reachabilityAnalysisIntents = new index_js_1.ReachabilityAnalysisIntentsImpl(this);
        this.reachabilityAnalysisRuns = new index_js_1.ReachabilityAnalysisRunsImpl(this);
        this.verifierWorkspaces = new index_js_1.VerifierWorkspacesImpl(this);
        this.networkVirtualAppliances = new index_js_1.NetworkVirtualAppliancesImpl(this);
        this.virtualApplianceSites = new index_js_1.VirtualApplianceSitesImpl(this);
        this.virtualApplianceSkus = new index_js_1.VirtualApplianceSkusImpl(this);
        this.inboundSecurityRuleOperations = new index_js_1.InboundSecurityRuleOperationsImpl(this);
        this.networkWatchers = new index_js_1.NetworkWatchersImpl(this);
        this.packetCaptures = new index_js_1.PacketCapturesImpl(this);
        this.connectionMonitors = new index_js_1.ConnectionMonitorsImpl(this);
        this.flowLogs = new index_js_1.FlowLogsImpl(this);
        this.operations = new index_js_1.OperationsImpl(this);
        this.privateEndpoints = new index_js_1.PrivateEndpointsImpl(this);
        this.availablePrivateEndpointTypes = new index_js_1.AvailablePrivateEndpointTypesImpl(this);
        this.privateDnsZoneGroups = new index_js_1.PrivateDnsZoneGroupsImpl(this);
        this.privateLinkServices = new index_js_1.PrivateLinkServicesImpl(this);
        this.publicIPPrefixes = new index_js_1.PublicIPPrefixesImpl(this);
        this.routeFilters = new index_js_1.RouteFiltersImpl(this);
        this.routeFilterRules = new index_js_1.RouteFilterRulesImpl(this);
        this.routeTables = new index_js_1.RouteTablesImpl(this);
        this.routes = new index_js_1.RoutesImpl(this);
        this.securityPartnerProviders = new index_js_1.SecurityPartnerProvidersImpl(this);
        this.bgpServiceCommunities = new index_js_1.BgpServiceCommunitiesImpl(this);
        this.serviceEndpointPolicies = new index_js_1.ServiceEndpointPoliciesImpl(this);
        this.serviceEndpointPolicyDefinitions =
            new index_js_1.ServiceEndpointPolicyDefinitionsImpl(this);
        this.serviceTags = new index_js_1.ServiceTagsImpl(this);
        this.serviceTagInformationOperations =
            new index_js_1.ServiceTagInformationOperationsImpl(this);
        this.usages = new index_js_1.UsagesImpl(this);
        this.virtualNetworks = new index_js_1.VirtualNetworksImpl(this);
        this.subnets = new index_js_1.SubnetsImpl(this);
        this.resourceNavigationLinks = new index_js_1.ResourceNavigationLinksImpl(this);
        this.serviceAssociationLinks = new index_js_1.ServiceAssociationLinksImpl(this);
        this.virtualNetworkPeerings = new index_js_1.VirtualNetworkPeeringsImpl(this);
        this.virtualNetworkGateways = new index_js_1.VirtualNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayConnections =
            new index_js_1.VirtualNetworkGatewayConnectionsImpl(this);
        this.localNetworkGateways = new index_js_1.LocalNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayNatRules = new index_js_1.VirtualNetworkGatewayNatRulesImpl(this);
        this.virtualNetworkTaps = new index_js_1.VirtualNetworkTapsImpl(this);
        this.virtualRouters = new index_js_1.VirtualRoutersImpl(this);
        this.virtualRouterPeerings = new index_js_1.VirtualRouterPeeringsImpl(this);
        this.virtualWans = new index_js_1.VirtualWansImpl(this);
        this.vpnSites = new index_js_1.VpnSitesImpl(this);
        this.vpnSiteLinks = new index_js_1.VpnSiteLinksImpl(this);
        this.vpnSitesConfiguration = new index_js_1.VpnSitesConfigurationImpl(this);
        this.vpnServerConfigurations = new index_js_1.VpnServerConfigurationsImpl(this);
        this.configurationPolicyGroups = new index_js_1.ConfigurationPolicyGroupsImpl(this);
        this.virtualHubs = new index_js_1.VirtualHubsImpl(this);
        this.routeMaps = new index_js_1.RouteMapsImpl(this);
        this.hubVirtualNetworkConnections = new index_js_1.HubVirtualNetworkConnectionsImpl(this);
        this.vpnGateways = new index_js_1.VpnGatewaysImpl(this);
        this.vpnLinkConnections = new index_js_1.VpnLinkConnectionsImpl(this);
        this.vpnConnections = new index_js_1.VpnConnectionsImpl(this);
        this.vpnSiteLinkConnections = new index_js_1.VpnSiteLinkConnectionsImpl(this);
        this.natRules = new index_js_1.NatRulesImpl(this);
        this.p2SVpnGateways = new index_js_1.P2SVpnGatewaysImpl(this);
        this.vpnServerConfigurationsAssociatedWithVirtualWan =
            new index_js_1.VpnServerConfigurationsAssociatedWithVirtualWanImpl(this);
        this.virtualHubRouteTableV2S = new index_js_1.VirtualHubRouteTableV2SImpl(this);
        this.expressRouteGateways = new index_js_1.ExpressRouteGatewaysImpl(this);
        this.expressRouteConnections = new index_js_1.ExpressRouteConnectionsImpl(this);
        this.networkVirtualApplianceConnections =
            new index_js_1.NetworkVirtualApplianceConnectionsImpl(this);
        this.virtualHubBgpConnection = new index_js_1.VirtualHubBgpConnectionImpl(this);
        this.virtualHubBgpConnections = new index_js_1.VirtualHubBgpConnectionsImpl(this);
        this.virtualHubIpConfiguration = new index_js_1.VirtualHubIpConfigurationImpl(this);
        this.hubRouteTables = new index_js_1.HubRouteTablesImpl(this);
        this.routingIntentOperations = new index_js_1.RoutingIntentOperationsImpl(this);
        this.webApplicationFirewallPolicies =
            new index_js_1.WebApplicationFirewallPoliciesImpl(this);
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginListPutBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings);
            },
        };
    }
    putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings) {
        return tslib_1.__asyncGenerator(this, arguments, function* putBastionShareableLinkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield tslib_1.__await(this._putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
                result = yield tslib_1.__await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                (0, pagingHelper_js_1.setContinuationToken)(page, continuationToken);
                yield yield tslib_1.__await(page);
            }
            while (continuationToken) {
                result = yield tslib_1.__await(this._putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                (0, pagingHelper_js_1.setContinuationToken)(page, continuationToken);
                yield yield tslib_1.__await(page);
            }
        });
    }
    putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib_1.__asyncGenerator(this, arguments, function* putBastionShareableLinkPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib_1.__asyncValues(this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _f; _f = yield tslib_1.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib_1.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    listBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings);
            },
        };
    }
    getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings) {
        return tslib_1.__asyncGenerator(this, arguments, function* getBastionShareableLinkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib_1.__await(this._getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                (0, pagingHelper_js_1.setContinuationToken)(page, continuationToken);
                yield yield tslib_1.__await(page);
            }
            while (continuationToken) {
                result = yield tslib_1.__await(this._getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                (0, pagingHelper_js_1.setContinuationToken)(page, continuationToken);
                yield yield tslib_1.__await(page);
            }
        });
    }
    getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib_1.__asyncGenerator(this, arguments, function* getBastionShareableLinkPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib_1.__asyncValues(this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _f; _f = yield tslib_1.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib_1.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginListActiveSessionsAndWait(resourceGroupName, bastionHostName, options) {
        const iter = this.getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options, settings);
            },
        };
    }
    getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options, settings) {
        return tslib_1.__asyncGenerator(this, arguments, function* getActiveSessionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield tslib_1.__await(this._getActiveSessions(resourceGroupName, bastionHostName, options));
                result = yield tslib_1.__await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                (0, pagingHelper_js_1.setContinuationToken)(page, continuationToken);
                yield yield tslib_1.__await(page);
            }
            while (continuationToken) {
                result = yield tslib_1.__await(this._getActiveSessionsNext(resourceGroupName, bastionHostName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                (0, pagingHelper_js_1.setContinuationToken)(page, continuationToken);
                yield yield tslib_1.__await(page);
            }
        });
    }
    getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options) {
        return tslib_1.__asyncGenerator(this, arguments, function* getActiveSessionsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib_1.__asyncValues(this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options)), _f; _f = yield tslib_1.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib_1.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    listDisconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        const iter = this.disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options, settings);
            },
        };
    }
    disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options, settings) {
        return tslib_1.__asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib_1.__await(this._disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                (0, pagingHelper_js_1.setContinuationToken)(page, continuationToken);
                yield yield tslib_1.__await(page);
            }
            while (continuationToken) {
                result = yield tslib_1.__await(this._disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                (0, pagingHelper_js_1.setContinuationToken)(page, continuationToken);
                yield yield tslib_1.__await(page);
            }
        });
    }
    disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options) {
        return tslib_1.__asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib_1.__asyncValues(this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options)), _f; _f = yield tslib_1.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib_1.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    async _putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = (0, lroImpl_js_1.createLroSpec)({
            sendOperationFn,
            args: { resourceGroupName, bastionHostName, bslRequest, options },
            spec: putBastionShareableLinkOperationSpec,
        });
        const poller = await (0, core_lro_1.createHttpPoller)(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    async beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = (0, lroImpl_js_1.createLroSpec)({
            sendOperationFn,
            args: { resourceGroupName, bastionHostName, bslRequest, options },
            spec: deleteBastionShareableLinkOperationSpec,
        });
        const poller = await (0, core_lro_1.createHttpPoller)(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    async beginDeleteBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        const poller = await this.beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options);
        return poller.pollUntilDone();
    }
    /**
     * Deletes the Bastion Shareable Links for all the tokens specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslTokenRequest Post request for Delete Bastion Shareable Link By Token endpoint.
     * @param options The options parameters.
     */
    async beginDeleteBastionShareableLinkByToken(resourceGroupName, bastionHostName, bslTokenRequest, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = (0, lroImpl_js_1.createLroSpec)({
            sendOperationFn,
            args: { resourceGroupName, bastionHostName, bslTokenRequest, options },
            spec: deleteBastionShareableLinkByTokenOperationSpec,
        });
        const poller = await (0, core_lro_1.createHttpPoller)(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Deletes the Bastion Shareable Links for all the tokens specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslTokenRequest Post request for Delete Bastion Shareable Link By Token endpoint.
     * @param options The options parameters.
     */
    async beginDeleteBastionShareableLinkByTokenAndWait(resourceGroupName, bastionHostName, bslTokenRequest, options) {
        const poller = await this.beginDeleteBastionShareableLinkByToken(resourceGroupName, bastionHostName, bslTokenRequest, options);
        return poller.pollUntilDone();
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    _getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, options }, getBastionShareableLinkOperationSpec);
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    async _getActiveSessions(resourceGroupName, bastionHostName, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = (0, lroImpl_js_1.createLroSpec)({
            sendOperationFn,
            args: { resourceGroupName, bastionHostName, options },
            spec: getActiveSessionsOperationSpec,
        });
        const poller = await (0, core_lro_1.createHttpPoller)(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    _disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, options }, disconnectActiveSessionsOperationSpec);
    }
    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular
     *                        expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param options The options parameters.
     */
    checkDnsNameAvailability(location, domainNameLabel, options) {
        return this.sendOperationRequest({ location, domainNameLabel, options }, checkDnsNameAvailabilityOperationSpec);
    }
    /**
     * Retrieves detail of a provider port.
     * @param providerport The name of the provider port.
     * @param options The options parameters.
     */
    expressRouteProviderPort(providerport, options) {
        return this.sendOperationRequest({ providerport, options }, expressRouteProviderPortOperationSpec);
    }
    /**
     * Lists active connectivity configurations in a network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Active Configuration Parameter.
     * @param options The options parameters.
     */
    listActiveConnectivityConfigurations(resourceGroupName, networkManagerName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, listActiveConnectivityConfigurationsOperationSpec);
    }
    /**
     * Lists active security admin rules in a network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Active Configuration Parameter.
     * @param options The options parameters.
     */
    listActiveSecurityAdminRules(resourceGroupName, networkManagerName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, listActiveSecurityAdminRulesOperationSpec);
    }
    /**
     * List all effective connectivity configurations applied on a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to list correct page.
     * @param options The options parameters.
     */
    listNetworkManagerEffectiveConnectivityConfigurations(resourceGroupName, virtualNetworkName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualNetworkName, parameters, options }, listNetworkManagerEffectiveConnectivityConfigurationsOperationSpec);
    }
    /**
     * List all effective security admin rules applied on a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to list correct page.
     * @param options The options parameters.
     */
    listNetworkManagerEffectiveSecurityAdminRules(resourceGroupName, virtualNetworkName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualNetworkName, parameters, options }, listNetworkManagerEffectiveSecurityAdminRulesOperationSpec);
    }
    /**
     * Gives the supported security providers for the virtual wan.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which supported security providers are needed.
     * @param options The options parameters.
     */
    supportedSecurityProviders(resourceGroupName, virtualWANName, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualWANName, options }, supportedSecurityProvidersOperationSpec);
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    async beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options) {
        const directSendOperation = async (args, spec) => {
            return this.sendOperationRequest(args, spec);
        };
        const sendOperationFn = async (args, spec) => {
            var _a;
            let currentRawResponse = undefined;
            const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
            const callback = (rawResponse, flatResponse) => {
                currentRawResponse = rawResponse;
                providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
            };
            const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
            const flatResponse = await directSendOperation(updatedArgs, spec);
            return {
                flatResponse,
                rawResponse: {
                    statusCode: currentRawResponse.status,
                    body: currentRawResponse.parsedBody,
                    headers: currentRawResponse.headers.toJSON(),
                },
            };
        };
        const lro = (0, lroImpl_js_1.createLroSpec)({
            sendOperationFn,
            args: { resourceGroupName, virtualWANName, vpnClientParams, options },
            spec: generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec,
        });
        const poller = await (0, core_lro_1.createHttpPoller)(lro, {
            restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
            intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
            resourceLocationConfig: "location",
        });
        await poller.poll();
        return poller;
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    async beginGeneratevirtualwanvpnserverconfigurationvpnprofileAndWait(resourceGroupName, virtualWANName, vpnClientParams, options) {
        const poller = await this.beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options);
        return poller.pollUntilDone();
    }
    /**
     * PutBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the PutBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, putBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for Create/Delete/Get Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the GetBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, getBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param nextLink The nextLink from the previous successful call to the GetActiveSessions method.
     * @param options The options parameters.
     */
    _getActiveSessionsNext(resourceGroupName, bastionHostName, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, nextLink, options }, getActiveSessionsNextOperationSpec);
    }
    /**
     * DisconnectActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param nextLink The nextLink from the previous successful call to the DisconnectActiveSessions
     *                 method.
     * @param options The options parameters.
     */
    _disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, nextLink, options }, disconnectActiveSessionsNextOperationSpec);
    }
}
exports.NetworkManagementClient = NetworkManagementClient;
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const putBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/createShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        201: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        202: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        204: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const deleteBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const deleteBastionShareableLinkByTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinksByToken",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: Mappers.NetworkManagementClientDeleteBastionShareableLinkByTokenHeaders,
        },
        201: {
            headersMapper: Mappers.NetworkManagementClientDeleteBastionShareableLinkByTokenHeaders,
        },
        202: {
            headersMapper: Mappers.NetworkManagementClientDeleteBastionShareableLinkByTokenHeaders,
        },
        204: {
            headersMapper: Mappers.NetworkManagementClientDeleteBastionShareableLinkByTokenHeaders,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.bslTokenRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.bslRequest,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        201: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        202: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        204: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const disconnectActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/disconnectActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.BastionSessionDeleteResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.sessionIds,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const checkDnsNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.DnsNameAvailabilityResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion, Parameters.domainNameLabel],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.location,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const expressRouteProviderPortOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteProviderPorts/{providerport}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ExpressRouteProviderPort,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.providerport,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const listActiveConnectivityConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/listActiveConnectivityConfigurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ActiveConnectivityConfigurationsListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters7,
    queryParameters: [Parameters.apiVersion, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.networkManagerName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listActiveSecurityAdminRulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/listActiveSecurityAdminRules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.ActiveSecurityAdminRulesListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters7,
    queryParameters: [Parameters.apiVersion, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.networkManagerName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listNetworkManagerEffectiveConnectivityConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/listNetworkManagerEffectiveConnectivityConfigurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.NetworkManagerEffectiveConnectivityConfigurationListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters8,
    queryParameters: [Parameters.apiVersion, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualNetworkName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const listNetworkManagerEffectiveSecurityAdminRulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/listNetworkManagerEffectiveSecurityAdminRules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.NetworkManagerEffectiveSecurityAdminRulesListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.parameters8,
    queryParameters: [Parameters.apiVersion, Parameters.top],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualNetworkName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const supportedSecurityProvidersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/supportedSecurityProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.VirtualWanSecurityProviders,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualWANName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/GenerateVpnProfile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Mappers.VpnProfileResponse,
        },
        201: {
            bodyMapper: Mappers.VpnProfileResponse,
        },
        202: {
            bodyMapper: Mappers.VpnProfileResponse,
        },
        204: {
            bodyMapper: Mappers.VpnProfileResponse,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    requestBody: Parameters.vpnClientParams,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.virtualWANName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const putBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        202: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionShareableLinkListResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
const getActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionActiveSessionListResult,
        },
        202: {},
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
};
const disconnectActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.BastionSessionDeleteResult,
        },
        default: {
            bodyMapper: Mappers.CloudError,
        },
    },
    urlParameters: [
        Parameters.$host,
        Parameters.resourceGroupName,
        Parameters.subscriptionId,
        Parameters.nextLink,
        Parameters.bastionHostName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
};
//# sourceMappingURL=networkManagementClient.js.map