/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError, AzureServiceClientOptions } from "@azure/ms-rest-azure-js";
import * as msRest from "@azure/ms-rest-js";

export { BaseResource, CloudError };

/**
 * The pricing tier (defines a CDN provider, feature list and rate) of the CDN profile.
 */
export interface Sku {
  /**
   * Name of the pricing tier. Possible values include: 'Standard_Verizon', 'Premium_Verizon',
   * 'Custom_Verizon', 'Standard_Akamai', 'Standard_ChinaCdn', 'Standard_Microsoft',
   * 'Premium_ChinaCdn', 'Standard_AzureFrontDoor', 'Premium_AzureFrontDoor',
   * 'Standard_955BandWidth_ChinaCdn', 'Standard_AvgBandWidth_ChinaCdn', 'StandardPlus_ChinaCdn',
   * 'StandardPlus_955BandWidth_ChinaCdn', 'StandardPlus_AvgBandWidth_ChinaCdn'
   */
  name?: SkuName;
}

/**
 * The core properties of ARM resources
 */
export interface Resource extends BaseResource {
  /**
   * Resource ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
  /**
   * Resource name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * Resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
}

/**
 * The resource model definition for a ARM tracked top level resource.
 */
export interface TrackedResource extends Resource {
  /**
   * Resource location.
   */
  location: string;
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * CDN profile is a logical grouping of endpoints that share the same settings, such as CDN
 * provider and pricing tier.
 */
export interface Profile extends TrackedResource {
  /**
   * The pricing tier (defines a CDN provider, feature list and rate) of the CDN profile.
   */
  sku: Sku;
  /**
   * Resource status of the profile. Possible values include: 'Creating', 'Active', 'Deleting',
   * 'Disabled'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: ProfileResourceState;
  /**
   * Provisioning status of the profile.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The Id of the frontdoor.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly frontdoorId?: string;
}

/**
 * Properties required to update a profile.
 */
export interface ProfileUpdateParameters extends BaseResource {
  /**
   * Profile tags
   */
  tags?: { [propertyName: string]: string };
}

/**
 * The URI required to login to the supplemental portal from the Azure portal.
 */
export interface SsoUri {
  /**
   * The URI used to login to the supplemental portal.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ssoUriValue?: string;
}

/**
 * The result of the GetSupportedOptimizationTypes API
 */
export interface SupportedOptimizationTypesListResult {
  /**
   * Supported optimization types for a profile.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly supportedOptimizationTypes?: OptimizationType[];
}

/**
 * The main origin of CDN content which is added when creating a CDN endpoint.
 */
export interface DeepCreatedOrigin extends BaseResource {
  /**
   * Origin name which must be unique within the endpoint.
   */
  name: string;
  /**
   * The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should
   * be unique across all origins in an endpoint.
   */
  hostName: string;
  /**
   * The value of the HTTP port. Must be between 1 and 65535.
   */
  httpPort?: number;
  /**
   * The value of the HTTPS port. Must be between 1 and 65535.
   */
  httpsPort?: number;
  /**
   * The host header value sent to the origin with each request. If you leave this blank, the
   * request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and
   * Cloud Services require this host header value to match the origin hostname by default.
   */
  originHostHeader?: string;
  /**
   * Priority of origin in given origin group for load balancing. Higher priorities will not be
   * used for load balancing if any lower priority origin is healthy.Must be between 1 and 5.
   */
  priority?: number;
  /**
   * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
   */
  weight?: number;
  /**
   * Origin is enabled for load balancing or not. By default, origin is always enabled.
   */
  enabled?: boolean;
  /**
   * The Alias of the Private Link resource. Populating this optional field indicates that this
   * origin is 'Private'
   */
  privateLinkAlias?: string;
  /**
   * The Resource Id of the Private Link resource. Populating this optional field indicates that
   * this backend is 'Private'
   */
  privateLinkResourceId?: string;
  /**
   * The location of the Private Link resource. Required only if 'privateLinkResourceId' is
   * populated
   */
  privateLinkLocation?: string;
  /**
   * A custom message to be included in the approval request to connect to the Private Link.
   */
  privateLinkApprovalMessage?: string;
}

/**
 * The JSON object that contains the properties to send health probes to origin.
 */
export interface HealthProbeParameters {
  /**
   * The path relative to the origin that is used to determine the health of the origin.
   */
  probePath?: string;
  /**
   * The type of health probe request that is made. Possible values include: 'NotSet', 'GET',
   * 'HEAD'
   */
  probeRequestType?: HealthProbeRequestType;
  /**
   * Protocol to use for health probe. Possible values include: 'NotSet', 'Http', 'Https'
   */
  probeProtocol?: ProbeProtocol;
  /**
   * The number of seconds between health probes.Default is 240sec.
   */
  probeIntervalInSeconds?: number;
}

/**
 * Reference to another resource.
 */
export interface ResourceReference extends BaseResource {
  /**
   * Resource ID.
   */
  id?: string;
}

/**
 * The JSON object that represents the range for http status codes
 */
export interface HttpErrorRangeParameters {
  /**
   * The inclusive start of the http status code range.
   */
  begin?: number;
  /**
   * The inclusive end of the http status code range.
   */
  end?: number;
}

/**
 * The JSON object that contains the properties to determine origin health using real
 * requests/responses.
 */
export interface ResponseBasedOriginErrorDetectionParameters {
  /**
   * Type of response errors for real user requests for which origin will be deemed unhealthy.
   * Possible values include: 'None', 'TcpErrorsOnly', 'TcpAndHttpErrors'
   */
  responseBasedDetectedErrorTypes?: ResponseBasedDetectedErrorTypes;
  /**
   * The percentage of failed requests in the sample where failover should trigger.
   */
  responseBasedFailoverThresholdPercentage?: number;
  /**
   * The list of Http status code ranges that are considered as server errors for origin and it is
   * marked as unhealthy.
   */
  httpErrorRanges?: HttpErrorRangeParameters[];
}

/**
 * The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to
 * the origins within the origin group based on origin health.
 */
export interface DeepCreatedOriginGroup extends BaseResource {
  /**
   * Origin group name which must be unique within the endpoint.
   */
  name: string;
  /**
   * Health probe settings to the origin that is used to determine the health of the origin.
   */
  healthProbeSettings?: HealthProbeParameters;
  /**
   * The source of the content being delivered via CDN within given origin group.
   */
  origins: ResourceReference[];
  /**
   * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint
   * comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
   * supported.
   */
  trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
  /**
   * The JSON object that contains the properties to determine origin health using real
   * requests/responses.This property is currently not supported.
   */
  responseBasedOriginErrorDetectionSettings?: ResponseBasedOriginErrorDetectionParameters;
}

/**
 * CDN endpoint is the entity within a CDN profile containing configuration information such as
 * origin, protocol, content caching and delivery behavior. The CDN endpoint uses the URL format
 * <endpointname>.azureedge.net.
 */
export interface Endpoint extends TrackedResource {
  /**
   * A directory path on the origin that CDN can use to retrieve content from, e.g.
   * contoso.cloudapp.net/originpath.
   */
  originPath?: string;
  /**
   * List of content types on which compression applies. The value should be a valid MIME type.
   */
  contentTypesToCompress?: string[];
  /**
   * The host header value sent to the origin with each request. This property at Endpoint is only
   * allowed when endpoint uses single origin and can be overridden by the same property specified
   * at origin.If you leave this blank, the request hostname determines this value. Azure CDN
   * origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to
   * match the origin hostname by default.
   */
  originHostHeader?: string;
  /**
   * Indicates whether content compression is enabled on CDN. Default value is false. If
   * compression is enabled, content will be served as compressed if user requests for a compressed
   * version. Content won't be compressed on CDN when requested content is smaller than 1 byte or
   * larger than 1 MB.
   */
  isCompressionEnabled?: boolean;
  /**
   * Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one
   * protocol (HTTP or HTTPS) must be allowed.
   */
  isHttpAllowed?: boolean;
  /**
   * Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least
   * one protocol (HTTP or HTTPS) must be allowed.
   */
  isHttpsAllowed?: boolean;
  /**
   * Defines how CDN caches requests that include query strings. You can ignore any query strings
   * when caching, bypass caching to prevent requests that contain query strings from being cached,
   * or cache every request with a unique URL. Possible values include: 'IgnoreQueryString',
   * 'BypassCaching', 'UseQueryString', 'NotSet'
   */
  queryStringCachingBehavior?: QueryStringCachingBehavior;
  /**
   * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download,
   * Media services. With this information, CDN can apply scenario driven optimization. Possible
   * values include: 'GeneralWebDelivery', 'GeneralMediaStreaming', 'VideoOnDemandMediaStreaming',
   * 'LargeFileDownload', 'DynamicSiteAcceleration'
   */
  optimizationType?: OptimizationType;
  /**
   * Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and
   * calculate the most optimal routes for the CDN. This is relative to the origin path. This
   * property is only relevant when using a single origin.
   */
  probePath?: string;
  /**
   * List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an
   * access rule to a specified path or content, e.g. block APAC for path /pictures/
   */
  geoFilters?: GeoFilter[];
  /**
   * A reference to the origin group.
   */
  defaultOriginGroup?: ResourceReference;
  /**
   * List of keys used to validate the signed URL hashes.
   */
  urlSigningKeys?: UrlSigningKey[];
  /**
   * A policy that specifies the delivery rules to be used for an endpoint.
   */
  deliveryPolicy?: EndpointPropertiesUpdateParametersDeliveryPolicy;
  /**
   * Defines the Web Application Firewall policy for the endpoint (if applicable)
   */
  webApplicationFirewallPolicyLink?: EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink;
  /**
   * The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g.
   * contoso.azureedge.net
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly hostName?: string;
  /**
   * The source of the content being delivered via CDN.
   */
  origins: DeepCreatedOrigin[];
  /**
   * The origin groups comprising of origins that are used for load balancing the traffic based on
   * availability.
   */
  originGroups?: DeepCreatedOriginGroup[];
  /**
   * Resource status of the endpoint. Possible values include: 'Creating', 'Deleting', 'Running',
   * 'Starting', 'Stopped', 'Stopping'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: EndpointResourceState;
  /**
   * Provisioning status of the endpoint.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
}

/**
 * Rules defining user's geo access within a CDN endpoint.
 */
export interface GeoFilter {
  /**
   * Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
   */
  relativePath: string;
  /**
   * Action of the geo filter, i.e. allow or block access. Possible values include: 'Block',
   * 'Allow'
   */
  action: GeoFilterActions;
  /**
   * Two letter country codes defining user country access in a geo filter, e.g. AU, MX, US.
   */
  countryCodes: string[];
}

/**
 * Describes the parameters for using a user's KeyVault for URL Signing Key.
 */
export interface KeyVaultSigningKeyParameters {
  /**
   * Subscription Id of the user's Key Vault containing the secret
   */
  subscriptionId: string;
  /**
   * Resource group of the user's Key Vault containing the secret
   */
  resourceGroupName: string;
  /**
   * The name of the user's Key Vault containing the secret
   */
  vaultName: string;
  /**
   * The name of secret in Key Vault.
   */
  secretName: string;
  /**
   * The version(GUID) of secret in Key Vault.
   */
  secretVersion: string;
}

/**
 * Url signing key
 */
export interface UrlSigningKey {
  /**
   * Defines the customer defined key Id. This id will exist in the incoming request to indicate
   * the key used to form the hash.
   */
  keyId: string;
  /**
   * Defines the parameters for using customer key vault for Url Signing Key.
   */
  keySourceParameters: KeyVaultSigningKeyParameters;
}

/**
 * Contains the possible cases for DeliveryRuleCondition.
 */
export type DeliveryRuleConditionUnion = DeliveryRuleCondition | DeliveryRuleRemoteAddressCondition | DeliveryRuleRequestMethodCondition | DeliveryRuleQueryStringCondition | DeliveryRulePostArgsCondition | DeliveryRuleRequestUriCondition | DeliveryRuleRequestHeaderCondition | DeliveryRuleRequestBodyCondition | DeliveryRuleRequestSchemeCondition | DeliveryRuleUrlPathCondition | DeliveryRuleUrlFileExtensionCondition | DeliveryRuleUrlFileNameCondition | DeliveryRuleHttpVersionCondition | DeliveryRuleCookiesCondition | DeliveryRuleIsDeviceCondition;

/**
 * A condition for the delivery rule.
 */
export interface DeliveryRuleCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "DeliveryRuleCondition";
}

/**
 * Contains the possible cases for DeliveryRuleAction.
 */
export type DeliveryRuleActionUnion = DeliveryRuleAction | UrlRedirectAction | UrlSigningAction | OriginGroupOverrideAction | UrlRewriteAction | DeliveryRuleRequestHeaderAction | DeliveryRuleResponseHeaderAction | DeliveryRuleCacheExpirationAction | DeliveryRuleCacheKeyQueryStringAction;

/**
 * An action for the delivery rule.
 */
export interface DeliveryRuleAction {
  /**
   * Polymorphic Discriminator
   */
  name: "DeliveryRuleAction";
}

/**
 * A rule that specifies a set of actions and conditions
 */
export interface DeliveryRule {
  /**
   * Name of the rule
   */
  name?: string;
  /**
   * The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A
   * rule with a lesser order will be applied before a rule with a greater order. Rule with order 0
   * is a special rule. It does not require any condition and actions listed in it will always be
   * applied.
   */
  order: number;
  /**
   * A list of conditions that must be matched for the actions to be executed
   */
  conditions?: DeliveryRuleConditionUnion[];
  /**
   * A list of actions that are executed when all the conditions of a rule are satisfied.
   */
  actions: DeliveryRuleActionUnion[];
}

/**
 * A policy that specifies the delivery rules to be used for an endpoint.
 */
export interface EndpointPropertiesUpdateParametersDeliveryPolicy {
  /**
   * User-friendly description of the policy.
   */
  description?: string;
  /**
   * A list of the delivery rules.
   */
  rules: DeliveryRule[];
}

/**
 * Defines the Web Application Firewall policy for the endpoint (if applicable)
 */
export interface EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink {
  /**
   * Resource ID.
   */
  id?: string;
}

/**
 * Properties required to create or update an endpoint.
 */
export interface EndpointUpdateParameters extends BaseResource {
  /**
   * Endpoint tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * A directory path on the origin that CDN can use to retrieve content from, e.g.
   * contoso.cloudapp.net/originpath.
   */
  originPath?: string;
  /**
   * List of content types on which compression applies. The value should be a valid MIME type.
   */
  contentTypesToCompress?: string[];
  /**
   * The host header value sent to the origin with each request. This property at Endpoint is only
   * allowed when endpoint uses single origin and can be overridden by the same property specified
   * at origin.If you leave this blank, the request hostname determines this value. Azure CDN
   * origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to
   * match the origin hostname by default.
   */
  originHostHeader?: string;
  /**
   * Indicates whether content compression is enabled on CDN. Default value is false. If
   * compression is enabled, content will be served as compressed if user requests for a compressed
   * version. Content won't be compressed on CDN when requested content is smaller than 1 byte or
   * larger than 1 MB.
   */
  isCompressionEnabled?: boolean;
  /**
   * Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one
   * protocol (HTTP or HTTPS) must be allowed.
   */
  isHttpAllowed?: boolean;
  /**
   * Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least
   * one protocol (HTTP or HTTPS) must be allowed.
   */
  isHttpsAllowed?: boolean;
  /**
   * Defines how CDN caches requests that include query strings. You can ignore any query strings
   * when caching, bypass caching to prevent requests that contain query strings from being cached,
   * or cache every request with a unique URL. Possible values include: 'IgnoreQueryString',
   * 'BypassCaching', 'UseQueryString', 'NotSet'
   */
  queryStringCachingBehavior?: QueryStringCachingBehavior;
  /**
   * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download,
   * Media services. With this information, CDN can apply scenario driven optimization. Possible
   * values include: 'GeneralWebDelivery', 'GeneralMediaStreaming', 'VideoOnDemandMediaStreaming',
   * 'LargeFileDownload', 'DynamicSiteAcceleration'
   */
  optimizationType?: OptimizationType;
  /**
   * Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and
   * calculate the most optimal routes for the CDN. This is relative to the origin path. This
   * property is only relevant when using a single origin.
   */
  probePath?: string;
  /**
   * List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an
   * access rule to a specified path or content, e.g. block APAC for path /pictures/
   */
  geoFilters?: GeoFilter[];
  /**
   * A reference to the origin group.
   */
  defaultOriginGroup?: ResourceReference;
  /**
   * List of keys used to validate the signed URL hashes.
   */
  urlSigningKeys?: UrlSigningKey[];
  /**
   * A policy that specifies the delivery rules to be used for an endpoint.
   */
  deliveryPolicy?: EndpointPropertiesUpdateParametersDeliveryPolicy;
  /**
   * Defines the Web Application Firewall policy for the endpoint (if applicable)
   */
  webApplicationFirewallPolicyLink?: EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink;
}

/**
 * Defines the parameters for RemoteAddress match conditions
 */
export interface RemoteAddressMatchConditionParameters {
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'IPMatch', 'GeoMatch'
   */
  operator: RemoteAddressOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * Match values to match against. The operator will apply to each value in here with OR
   * semantics. If any of them match the variable with the given operator this match condition is
   * considered a match.
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the RemoteAddress condition for the delivery rule.
 */
export interface DeliveryRuleRemoteAddressCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "RemoteAddress";
  /**
   * Defines the parameters for the condition.
   */
  parameters: RemoteAddressMatchConditionParameters;
}

/**
 * Defines the parameters for RequestMethod match conditions
 */
export interface RequestMethodMatchConditionParameters {
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
}

/**
 * Defines the RequestMethod condition for the delivery rule.
 */
export interface DeliveryRuleRequestMethodCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "RequestMethod";
  /**
   * Defines the parameters for the condition.
   */
  parameters: RequestMethodMatchConditionParameters;
}

/**
 * Defines the parameters for QueryString match conditions
 */
export interface QueryStringMatchConditionParameters {
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'RegEx'
   */
  operator: QueryStringOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the QueryString condition for the delivery rule.
 */
export interface DeliveryRuleQueryStringCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "QueryString";
  /**
   * Defines the parameters for the condition.
   */
  parameters: QueryStringMatchConditionParameters;
}

/**
 * Defines the parameters for PostArgs match conditions
 */
export interface PostArgsMatchConditionParameters {
  /**
   * Name of PostArg to be matched
   */
  selector?: string;
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'RegEx'
   */
  operator: PostArgsOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the PostArgs condition for the delivery rule.
 */
export interface DeliveryRulePostArgsCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "PostArgs";
  /**
   * Defines the parameters for the condition.
   */
  parameters: PostArgsMatchConditionParameters;
}

/**
 * Defines the parameters for RequestUri match conditions
 */
export interface RequestUriMatchConditionParameters {
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'RegEx'
   */
  operator: RequestUriOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the RequestUri condition for the delivery rule.
 */
export interface DeliveryRuleRequestUriCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "RequestUri";
  /**
   * Defines the parameters for the condition.
   */
  parameters: RequestUriMatchConditionParameters;
}

/**
 * Defines the parameters for RequestHeader match conditions
 */
export interface RequestHeaderMatchConditionParameters {
  /**
   * Name of Header to be matched
   */
  selector?: string;
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'RegEx'
   */
  operator: RequestHeaderOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the RequestHeader condition for the delivery rule.
 */
export interface DeliveryRuleRequestHeaderCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "RequestHeader";
  /**
   * Defines the parameters for the condition.
   */
  parameters: RequestHeaderMatchConditionParameters;
}

/**
 * Defines the parameters for RequestBody match conditions
 */
export interface RequestBodyMatchConditionParameters {
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'RegEx'
   */
  operator: RequestBodyOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the RequestBody condition for the delivery rule.
 */
export interface DeliveryRuleRequestBodyCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "RequestBody";
  /**
   * Defines the parameters for the condition.
   */
  parameters: RequestBodyMatchConditionParameters;
}

/**
 * Defines the parameters for RequestScheme match conditions
 */
export interface RequestSchemeMatchConditionParameters {
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
}

/**
 * Defines the RequestScheme condition for the delivery rule.
 */
export interface DeliveryRuleRequestSchemeCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "RequestScheme";
  /**
   * Defines the parameters for the condition.
   */
  parameters: RequestSchemeMatchConditionParameters;
}

/**
 * Defines the parameters for UrlPath match conditions
 */
export interface UrlPathMatchConditionParameters {
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'Wildcard', 'RegEx'
   */
  operator: UrlPathOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the UrlPath condition for the delivery rule.
 */
export interface DeliveryRuleUrlPathCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "UrlPath";
  /**
   * Defines the parameters for the condition.
   */
  parameters: UrlPathMatchConditionParameters;
}

/**
 * Defines the parameters for UrlFileExtension match conditions
 */
export interface UrlFileExtensionMatchConditionParameters {
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'RegEx'
   */
  operator: UrlFileExtensionOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the UrlFileExtension condition for the delivery rule.
 */
export interface DeliveryRuleUrlFileExtensionCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "UrlFileExtension";
  /**
   * Defines the parameters for the condition.
   */
  parameters: UrlFileExtensionMatchConditionParameters;
}

/**
 * Defines the parameters for UrlFilename match conditions
 */
export interface UrlFileNameMatchConditionParameters {
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'RegEx'
   */
  operator: UrlFileNameOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the UrlFileName condition for the delivery rule.
 */
export interface DeliveryRuleUrlFileNameCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "UrlFileName";
  /**
   * Defines the parameters for the condition.
   */
  parameters: UrlFileNameMatchConditionParameters;
}

/**
 * Defines the parameters for HttpVersion match conditions
 */
export interface HttpVersionMatchConditionParameters {
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
}

/**
 * Defines the HttpVersion condition for the delivery rule.
 */
export interface DeliveryRuleHttpVersionCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "HttpVersion";
  /**
   * Defines the parameters for the condition.
   */
  parameters: HttpVersionMatchConditionParameters;
}

/**
 * Defines the parameters for Cookies match conditions
 */
export interface CookiesMatchConditionParameters {
  /**
   * Name of Cookies to be matched
   */
  selector?: string;
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'Equal', 'Contains',
   * 'BeginsWith', 'EndsWith', 'LessThan', 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual',
   * 'RegEx'
   */
  operator: CookiesOperator;
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the Cookies condition for the delivery rule.
 */
export interface DeliveryRuleCookiesCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "Cookies";
  /**
   * Defines the parameters for the condition.
   */
  parameters: CookiesMatchConditionParameters;
}

/**
 * Defines the parameters for IsDevice match conditions
 */
export interface IsDeviceMatchConditionParameters {
  /**
   * Describes if this is negate condition or not
   */
  negateCondition?: boolean;
  /**
   * The match value for the condition of the delivery rule
   */
  matchValues?: string[];
  /**
   * List of transforms
   */
  transforms?: Transform[];
}

/**
 * Defines the IsDevice condition for the delivery rule.
 */
export interface DeliveryRuleIsDeviceCondition {
  /**
   * Polymorphic Discriminator
   */
  name: "IsDevice";
  /**
   * Defines the parameters for the condition.
   */
  parameters: IsDeviceMatchConditionParameters;
}

/**
 * Defines the parameters for the url redirect action.
 */
export interface UrlRedirectActionParameters {
  /**
   * The redirect type the rule will use when redirecting traffic. Possible values include:
   * 'Moved', 'Found', 'TemporaryRedirect', 'PermanentRedirect'
   */
  redirectType: RedirectType;
  /**
   * Protocol to use for the redirect. The default value is MatchRequest. Possible values include:
   * 'MatchRequest', 'Http', 'Https'
   */
  destinationProtocol?: DestinationProtocol;
  /**
   * The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the
   * incoming path as destination path.
   */
  customPath?: string;
  /**
   * Host to redirect. Leave empty to use the incoming host as the destination host.
   */
  customHostname?: string;
  /**
   * The set of query strings to be placed in the redirect URL. Setting this value would replace
   * any existing query string; leave empty to preserve the incoming query string. Query string
   * must be in <key>=<value> format. ? and & will be added automatically so do not include them.
   */
  customQueryString?: string;
  /**
   * Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do
   * not include the #.
   */
  customFragment?: string;
}

/**
 * Defines the url redirect action for the delivery rule.
 */
export interface UrlRedirectAction {
  /**
   * Polymorphic Discriminator
   */
  name: "UrlRedirect";
  /**
   * Defines the parameters for the action.
   */
  parameters: UrlRedirectActionParameters;
}

/**
 * Defines how to identify a parameter for a specific purpose e.g. expires
 */
export interface UrlSigningParamIdentifier {
  /**
   * Indicates the purpose of the parameter. Possible values include: 'Expires', 'KeyId',
   * 'Signature'
   */
  paramIndicator: ParamIndicator;
  /**
   * Parameter name
   */
  paramName: string;
}

/**
 * Defines the parameters for the Url Signing action.
 */
export interface UrlSigningActionParameters {
  /**
   * Algorithm to use for URL signing. Possible values include: 'SHA256'
   */
  algorithm?: Algorithm;
  /**
   * Defines which query string parameters in the url to be considered for expires, key id etc.
   */
  parameterNameOverride?: UrlSigningParamIdentifier[];
}

/**
 * Defines the url signing action for the delivery rule.
 */
export interface UrlSigningAction {
  /**
   * Polymorphic Discriminator
   */
  name: "UrlSigning";
  /**
   * Defines the parameters for the action.
   */
  parameters: UrlSigningActionParameters;
}

/**
 * Defines the parameters for the origin group override action.
 */
export interface OriginGroupOverrideActionParameters {
  /**
   * defines the OriginGroup that would override the DefaultOriginGroup.
   */
  originGroup: ResourceReference;
}

/**
 * Defines the origin group override action for the delivery rule.
 */
export interface OriginGroupOverrideAction {
  /**
   * Polymorphic Discriminator
   */
  name: "OriginGroupOverride";
  /**
   * Defines the parameters for the action.
   */
  parameters: OriginGroupOverrideActionParameters;
}

/**
 * Defines the parameters for the url rewrite action.
 */
export interface UrlRewriteActionParameters {
  /**
   * define a request URI pattern that identifies the type of requests that may be rewritten. If
   * value is blank, all strings are matched.
   */
  sourcePattern: string;
  /**
   * Define the relative URL to which the above requests will be rewritten by.
   */
  destination: string;
  /**
   * Whether to preserve unmatched path. Default value is true.
   */
  preserveUnmatchedPath?: boolean;
}

/**
 * Defines the url rewrite action for the delivery rule.
 */
export interface UrlRewriteAction {
  /**
   * Polymorphic Discriminator
   */
  name: "UrlRewrite";
  /**
   * Defines the parameters for the action.
   */
  parameters: UrlRewriteActionParameters;
}

/**
 * Defines the parameters for the request header action.
 */
export interface HeaderActionParameters {
  /**
   * Action to perform. Possible values include: 'Append', 'Overwrite', 'Delete'
   */
  headerAction: HeaderAction;
  /**
   * Name of the header to modify
   */
  headerName: string;
  /**
   * Value for the specified action
   */
  value?: string;
}

/**
 * Defines the request header action for the delivery rule.
 */
export interface DeliveryRuleRequestHeaderAction {
  /**
   * Polymorphic Discriminator
   */
  name: "ModifyRequestHeader";
  /**
   * Defines the parameters for the action.
   */
  parameters: HeaderActionParameters;
}

/**
 * Defines the response header action for the delivery rule.
 */
export interface DeliveryRuleResponseHeaderAction {
  /**
   * Polymorphic Discriminator
   */
  name: "ModifyResponseHeader";
  /**
   * Defines the parameters for the action.
   */
  parameters: HeaderActionParameters;
}

/**
 * Defines the parameters for the cache expiration action.
 */
export interface CacheExpirationActionParameters {
  /**
   * Caching behavior for the requests. Possible values include: 'BypassCache', 'Override',
   * 'SetIfMissing'
   */
  cacheBehavior: CacheBehavior;
  /**
   * The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
   */
  cacheDuration?: string;
}

/**
 * Defines the cache expiration action for the delivery rule.
 */
export interface DeliveryRuleCacheExpirationAction {
  /**
   * Polymorphic Discriminator
   */
  name: "CacheExpiration";
  /**
   * Defines the parameters for the action.
   */
  parameters: CacheExpirationActionParameters;
}

/**
 * Defines the parameters for the cache-key query string action.
 */
export interface CacheKeyQueryStringActionParameters {
  /**
   * Caching behavior for the requests. Possible values include: 'Include', 'IncludeAll',
   * 'Exclude', 'ExcludeAll'
   */
  queryStringBehavior: QueryStringBehavior;
  /**
   * query parameters to include or exclude (comma separated).
   */
  queryParameters?: string;
}

/**
 * Defines the cache-key query string action for the delivery rule.
 */
export interface DeliveryRuleCacheKeyQueryStringAction {
  /**
   * Polymorphic Discriminator
   */
  name: "CacheKeyQueryString";
  /**
   * Defines the parameters for the action.
   */
  parameters: CacheKeyQueryStringActionParameters;
}

/**
 * Parameters required for content purge.
 */
export interface PurgeParameters {
  /**
   * The path to the content to be purged. Can describe a file path or a wild card directory.
   */
  contentPaths: string[];
}

/**
 * Parameters required for content load.
 */
export interface LoadParameters {
  /**
   * The path to the content to be loaded. Path should be a relative file URL of the origin.
   */
  contentPaths: string[];
}

/**
 * The resource model definition for a ARM proxy resource. It will have everything other than
 * required location and tags
 */
export interface ProxyResource extends Resource {
  /**
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * CDN origin is the source of the content being delivered via CDN. When the edge nodes represented
 * by an endpoint do not have the requested content cached, they attempt to fetch it from one or
 * more of the configured origins.
 */
export interface Origin extends ProxyResource {
  /**
   * The address of the origin. Domain names, IPv4 addresses, and IPv6 addresses are supported.This
   * should be unique across all origins in an endpoint.
   */
  hostName?: string;
  /**
   * The value of the HTTP port. Must be between 1 and 65535.
   */
  httpPort?: number;
  /**
   * The value of the HTTPS port. Must be between 1 and 65535.
   */
  httpsPort?: number;
  /**
   * The host header value sent to the origin with each request. If you leave this blank, the
   * request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and
   * Cloud Services require this host header value to match the origin hostname by default. This
   * overrides the host header defined at Endpoint
   */
  originHostHeader?: string;
  /**
   * Priority of origin in given origin group for load balancing. Higher priorities will not be
   * used for load balancing if any lower priority origin is healthy.Must be between 1 and 5
   */
  priority?: number;
  /**
   * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
   */
  weight?: number;
  /**
   * Origin is enabled for load balancing or not
   */
  enabled?: boolean;
  /**
   * The Alias of the Private Link resource. Populating this optional field indicates that this
   * origin is 'Private'
   */
  privateLinkAlias?: string;
  /**
   * The Resource Id of the Private Link resource. Populating this optional field indicates that
   * this backend is 'Private'
   */
  privateLinkResourceId?: string;
  /**
   * The location of the Private Link resource. Required only if 'privateLinkResourceId' is
   * populated
   */
  privateLinkLocation?: string;
  /**
   * A custom message to be included in the approval request to connect to the Private Link.
   */
  privateLinkApprovalMessage?: string;
  /**
   * Resource status of the origin. Possible values include: 'Creating', 'Active', 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: OriginResourceState;
  /**
   * Provisioning status of the origin.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The approval status for the connection to the Private Link. Possible values include:
   * 'Pending', 'Approved', 'Rejected', 'Disconnected', 'Timeout'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly privateEndpointStatus?: PrivateEndpointStatus;
}

/**
 * Origin properties needed for origin update.
 */
export interface OriginUpdateParameters extends BaseResource {
  /**
   * The address of the origin. Domain names, IPv4 addresses, and IPv6 addresses are supported.This
   * should be unique across all origins in an endpoint.
   */
  hostName?: string;
  /**
   * The value of the HTTP port. Must be between 1 and 65535.
   */
  httpPort?: number;
  /**
   * The value of the HTTPS port. Must be between 1 and 65535.
   */
  httpsPort?: number;
  /**
   * The host header value sent to the origin with each request. If you leave this blank, the
   * request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and
   * Cloud Services require this host header value to match the origin hostname by default. This
   * overrides the host header defined at Endpoint
   */
  originHostHeader?: string;
  /**
   * Priority of origin in given origin group for load balancing. Higher priorities will not be
   * used for load balancing if any lower priority origin is healthy.Must be between 1 and 5
   */
  priority?: number;
  /**
   * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
   */
  weight?: number;
  /**
   * Origin is enabled for load balancing or not
   */
  enabled?: boolean;
  /**
   * The Alias of the Private Link resource. Populating this optional field indicates that this
   * origin is 'Private'
   */
  privateLinkAlias?: string;
  /**
   * The Resource Id of the Private Link resource. Populating this optional field indicates that
   * this backend is 'Private'
   */
  privateLinkResourceId?: string;
  /**
   * The location of the Private Link resource. Required only if 'privateLinkResourceId' is
   * populated
   */
  privateLinkLocation?: string;
  /**
   * A custom message to be included in the approval request to connect to the Private Link.
   */
  privateLinkApprovalMessage?: string;
}

/**
 * Origin group comprising of origins is used for load balancing to origins when the content cannot
 * be served from CDN.
 */
export interface OriginGroup extends ProxyResource {
  /**
   * Health probe settings to the origin that is used to determine the health of the origin.
   */
  healthProbeSettings?: HealthProbeParameters;
  /**
   * The source of the content being delivered via CDN within given origin group.
   */
  origins?: ResourceReference[];
  /**
   * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint
   * comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
   * supported.
   */
  trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
  /**
   * The JSON object that contains the properties to determine origin health using real
   * requests/responses. This property is currently not supported.
   */
  responseBasedOriginErrorDetectionSettings?: ResponseBasedOriginErrorDetectionParameters;
  /**
   * Resource status of the origin group. Possible values include: 'Creating', 'Active', 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: OriginGroupResourceState;
  /**
   * Provisioning status of the origin group.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
}

/**
 * Origin group properties needed for origin group creation or update.
 */
export interface OriginGroupUpdateParameters extends BaseResource {
  /**
   * Health probe settings to the origin that is used to determine the health of the origin.
   */
  healthProbeSettings?: HealthProbeParameters;
  /**
   * The source of the content being delivered via CDN within given origin group.
   */
  origins?: ResourceReference[];
  /**
   * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint
   * comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
   * supported.
   */
  trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
  /**
   * The JSON object that contains the properties to determine origin health using real
   * requests/responses. This property is currently not supported.
   */
  responseBasedOriginErrorDetectionSettings?: ResponseBasedOriginErrorDetectionParameters;
}

/**
 * Friendly domain name mapping to the endpoint hostname that the customer provides for branding
 * purposes, e.g. www.contoso.com.
 */
export interface CustomDomain extends ProxyResource {
  /**
   * The host name of the custom domain. Must be a domain name.
   */
  hostName: string;
  /**
   * Resource status of the custom domain. Possible values include: 'Creating', 'Active',
   * 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: CustomDomainResourceState;
  /**
   * Provisioning status of Custom Https of the custom domain. Possible values include: 'Enabling',
   * 'Enabled', 'Disabling', 'Disabled', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly customHttpsProvisioningState?: CustomHttpsProvisioningState;
  /**
   * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by
   * step. Possible values include: 'SubmittingDomainControlValidationRequest',
   * 'PendingDomainControlValidationREquestApproval', 'DomainControlValidationRequestApproved',
   * 'DomainControlValidationRequestRejected', 'DomainControlValidationRequestTimedOut',
   * 'IssuingCertificate', 'DeployingCertificate', 'CertificateDeployed', 'DeletingCertificate',
   * 'CertificateDeleted'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly customHttpsProvisioningSubstate?: CustomHttpsProvisioningSubstate;
  /**
   * Special validation or data may be required when delivering CDN to some regions due to local
   * compliance reasons. E.g. ICP license number of a custom domain is required to deliver content
   * in China.
   */
  validationData?: string;
  /**
   * Provisioning status of the custom domain.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
}

/**
 * The customDomain JSON object required for custom domain creation or update.
 */
export interface CustomDomainParameters {
  /**
   * The host name of the custom domain. Must be a domain name.
   */
  hostName: string;
}

/**
 * Contains the possible cases for CustomDomainHttpsParameters.
 */
export type CustomDomainHttpsParametersUnion = CustomDomainHttpsParameters | CdnManagedHttpsParameters | UserManagedHttpsParameters;

/**
 * The JSON object that contains the properties to secure a custom domain.
 */
export interface CustomDomainHttpsParameters {
  /**
   * Polymorphic Discriminator
   */
  certificateSource: "CustomDomainHttpsParameters";
  /**
   * Defines the TLS extension protocol that is used for secure delivery. Possible values include:
   * 'ServerNameIndication', 'IPBased'
   */
  protocolType: ProtocolType;
  /**
   * TLS protocol version that will be used for Https. Possible values include: 'None', 'TLS10',
   * 'TLS12'
   */
  minimumTlsVersion?: MinimumTlsVersion;
}

/**
 * Defines the parameters for using CDN managed certificate for securing custom domain.
 */
export interface CdnCertificateSourceParameters {
  /**
   * Type of certificate used. Possible values include: 'Shared', 'Dedicated'
   */
  certificateType: CertificateType;
}

/**
 * Defines the certificate source parameters using CDN managed certificate for enabling SSL.
 */
export interface CdnManagedHttpsParameters {
  /**
   * Polymorphic Discriminator
   */
  certificateSource: "Cdn";
  /**
   * Defines the TLS extension protocol that is used for secure delivery. Possible values include:
   * 'ServerNameIndication', 'IPBased'
   */
  protocolType: ProtocolType;
  /**
   * TLS protocol version that will be used for Https. Possible values include: 'None', 'TLS10',
   * 'TLS12'
   */
  minimumTlsVersion?: MinimumTlsVersion;
  /**
   * Defines the certificate source parameters using CDN managed certificate for enabling SSL.
   */
  certificateSourceParameters: CdnCertificateSourceParameters;
}

/**
 * Describes the parameters for using a user's KeyVault certificate for securing custom domain.
 */
export interface KeyVaultCertificateSourceParameters {
  /**
   * Subscription Id of the user's Key Vault containing the SSL certificate
   */
  subscriptionId: string;
  /**
   * Resource group of the user's Key Vault containing the SSL certificate
   */
  resourceGroupName: string;
  /**
   * The name of the user's Key Vault containing the SSL certificate
   */
  vaultName: string;
  /**
   * The name of Key Vault Secret (representing the full certificate PFX) in Key Vault.
   */
  secretName: string;
  /**
   * The version(GUID) of Key Vault Secret in Key Vault.
   */
  secretVersion?: string;
}

/**
 * Defines the certificate source parameters using user's keyvault certificate for enabling SSL.
 */
export interface UserManagedHttpsParameters {
  /**
   * Polymorphic Discriminator
   */
  certificateSource: "AzureKeyVault";
  /**
   * Defines the TLS extension protocol that is used for secure delivery. Possible values include:
   * 'ServerNameIndication', 'IPBased'
   */
  protocolType: ProtocolType;
  /**
   * TLS protocol version that will be used for Https. Possible values include: 'None', 'TLS10',
   * 'TLS12'
   */
  minimumTlsVersion?: MinimumTlsVersion;
  /**
   * Defines the certificate source parameters using user's keyvault certificate for enabling SSL.
   */
  certificateSourceParameters: KeyVaultCertificateSourceParameters;
}

/**
 * Input of the custom domain to be validated for DNS mapping.
 */
export interface ValidateCustomDomainInput {
  /**
   * The host name of the custom domain. Must be a domain name.
   */
  hostName: string;
}

/**
 * Output of custom domain validation.
 */
export interface ValidateCustomDomainOutput {
  /**
   * Indicates whether the custom domain is valid or not.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly customDomainValidated?: boolean;
  /**
   * The reason why the custom domain is not valid.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly reason?: string;
  /**
   * Error message describing why the custom domain is not valid.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
}

/**
 * Input of CheckNameAvailability API.
 */
export interface CheckNameAvailabilityInput {
  /**
   * The resource name to validate.
   */
  name: string;
}

/**
 * Output of check name availability API.
 */
export interface CheckNameAvailabilityOutput {
  /**
   * Indicates whether the name is available.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nameAvailable?: boolean;
  /**
   * The reason why the name is not available.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly reason?: string;
  /**
   * The detailed error message describing why the name is not available.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
}

/**
 * Input of the validate probe API.
 */
export interface ValidateProbeInput {
  /**
   * The probe URL to validate.
   */
  probeURL: string;
}

/**
 * Output of the validate probe API.
 */
export interface ValidateProbeOutput {
  /**
   * Indicates whether the probe URL is accepted or not.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly isValid?: boolean;
  /**
   * Specifies the error code when the probe url is not accepted.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly errorCode?: string;
  /**
   * The detailed error message describing why the probe URL is not accepted.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
}

/**
 * Output of check resource usage API.
 */
export interface ResourceUsage {
  /**
   * Resource type for which the usage is provided.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceType?: string;
  /**
   * Unit of the usage. e.g. Count.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly unit?: string;
  /**
   * Actual value of usage on the specified resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly currentValue?: number;
  /**
   * Quota of the specified resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly limit?: number;
}

/**
 * The object that represents the operation.
 */
export interface OperationDisplay {
  /**
   * Service provider: Microsoft.Cdn
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provider?: string;
  /**
   * Resource on which the operation is performed: Profile, endpoint, etc.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resource?: string;
  /**
   * Operation type: Read, write, delete, etc.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly operation?: string;
}

/**
 * CDN REST API operation
 */
export interface Operation {
  /**
   * Operation name: {provider}/{resource}/{operation}
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The object that represents the operation.
   */
  display?: OperationDisplay;
}

/**
 * CIDR Ip address
 */
export interface CidrIpAddress {
  /**
   * Ip address itself.
   */
  baseIpAddress?: string;
  /**
   * The length of the prefix of the ip address.
   */
  prefixLength?: number;
}

/**
 * CDN Ip address group
 */
export interface IpAddressGroup {
  /**
   * The delivery region of the ip address group
   */
  deliveryRegion?: string;
  /**
   * The list of ip v4 addresses.
   */
  ipv4Addresses?: CidrIpAddress[];
  /**
   * The list of ip v6 addresses.
   */
  ipv6Addresses?: CidrIpAddress[];
}

/**
 * Edgenode is a global Point of Presence (POP) location used to deliver CDN content to end users.
 */
export interface EdgeNode extends ProxyResource {
  /**
   * List of ip address groups.
   */
  ipAddressGroups: IpAddressGroup[];
}

/**
 * Read only system data
 */
export interface SystemData {
  /**
   * An identifier for the identity that created the resource
   */
  createdBy?: string;
  /**
   * The type of identity that created the resource. Possible values include: 'user',
   * 'application', 'managedIdentity', 'key'
   */
  createdByType?: IdentityType;
  /**
   * The timestamp of resource creation (UTC)
   */
  createdAt?: Date;
  /**
   * An identifier for the identity that last modified the resource
   */
  lastModifiedBy?: string;
  /**
   * The type of identity that last modified the resource. Possible values include: 'user',
   * 'application', 'managedIdentity', 'key'
   */
  lastModifiedByType?: IdentityType;
  /**
   * The timestamp of resource last modification (UTC)
   */
  lastModifiedAt?: Date;
}

/**
 * Error response indicates CDN service is not able to process the incoming request. The reason is
 * provided in the error message.
 */
export interface ErrorResponse {
  /**
   * Error code.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly code?: string;
  /**
   * Error message indicating why the operation failed.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
}

/**
 * Parameters required for content purge.
 */
export interface AfdPurgeParameters {
  /**
   * The path to the content to be purged. Can describe a file path or a wild card directory.
   */
  contentPaths: string[];
  /**
   * List of domains.
   */
  domains?: string[];
}

/**
 * Certificate used for https
 */
export interface Certificate {
  /**
   * Subject name in the certificate.
   */
  subject?: string;
  /**
   * Certificate expiration date.
   */
  expirationDate?: string;
  /**
   * Certificate thumbprint.
   */
  thumbprint?: string;
}

/**
 * Managed Certificate used for https
 */
export interface ManagedCertificate extends Certificate {
}

/**
 * Customer Certificate used for https
 */
export interface CustomerCertificate extends Certificate {
  /**
   * Certificate version.
   */
  version?: string;
  /**
   * Certificate issuing authority.
   */
  certificateAuthority?: string;
  /**
   * Complete Url to the certificate
   */
  certificateUrl: string;
  /**
   * Whether to use the latest version for the certificate
   */
  useLatestVersion?: boolean;
  /**
   * The list of SANs.
   */
  subjectAlternativeNames?: string[];
}

/**
 * Input of the secret to be validated.
 */
export interface ValidateSecretInput {
  /**
   * The secret source.
   */
  secretSource: ResourceReference;
  /**
   * The secret type. Possible values include: 'UrlSigningKey', 'ManagedCertificate',
   * 'CustomerCertificate'
   */
  secretType: ValidateSecretType;
}

/**
 * Output of the validated secret.
 */
export interface ValidateSecretOutput {
  /**
   * The validation status. Possible values include: 'Valid', 'Invalid', 'AccessDenied',
   * 'CertificateExpired'
   */
  status?: Status;
  /**
   * Detailed error message
   */
  message?: string;
}

/**
 * The JSON object that contains the properties to secure a domain.
 */
export interface AFDDomainHttpsParameters {
  /**
   * Defines the source of the SSL certificate. Possible values include: 'CustomerCertificate',
   * 'ManagedCertificate'
   */
  certificateType: AfdCertificateType;
  /**
   * TLS protocol version that will be used for Https. Possible values include: 'TLS10', 'TLS12'
   */
  minimumTlsVersion?: AfdMinimumTlsVersion;
  /**
   * Resource reference to the secret. ie. subs/rg/profile/secret
   */
  secret?: ResourceReference;
}

/**
 * The JSON object that contains the properties to validate a domain.
 */
export interface DomainValidationProperties {
  /**
   * Challenge used for DNS TXT record or file based validation
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly validationToken?: string;
  /**
   * The date time that the token expires
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly expirationDate?: string;
}

/**
 * Friendly domain name mapping to the endpoint hostname that the customer provides for branding
 * purposes, e.g. www.contoso.com.
 */
export interface AFDDomain extends ProxyResource {
  /**
   * The configuration specifying how to enable HTTPS for the domain - using AzureFrontDoor managed
   * certificate or user's own certificate. If not specified, enabling ssl uses AzureFrontDoor
   * managed certificate by default.
   */
  tlsSettings?: AFDDomainHttpsParameters;
  /**
   * Resource reference to the Azure DNS zone
   */
  azureDnsZone?: ResourceReference;
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
  /**
   * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by
   * step. DCV stands for DomainControlValidation. Possible values include: 'Unknown',
   * 'Submitting', 'Pending', 'TimedOut', 'PendingRevalidation', 'Approved'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly domainValidationState?: DomainValidationState;
  /**
   * The host name of the domain. Must be a domain name.
   */
  hostName: string;
  /**
   * Values the customer needs to validate domain ownership
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly validationProperties?: DomainValidationProperties;
}

/**
 * The domain JSON object required for domain creation or update.
 */
export interface AFDDomainUpdateParameters {
  /**
   * The configuration specifying how to enable HTTPS for the domain - using AzureFrontDoor managed
   * certificate or user's own certificate. If not specified, enabling ssl uses AzureFrontDoor
   * managed certificate by default.
   */
  tlsSettings?: AFDDomainHttpsParameters;
  /**
   * Resource reference to the Azure DNS zone
   */
  azureDnsZone?: ResourceReference;
}

/**
 * settings for security policy patterns to match
 */
export interface SecurityPolicyWebApplicationFirewallAssociation {
  /**
   * List of domains.
   */
  domains?: ResourceReference[];
  /**
   * List of paths
   */
  patternsToMatch?: string[];
}

/**
 * Contains the possible cases for SecurityPolicyParameters.
 */
export type SecurityPolicyParametersUnion = SecurityPolicyParameters | SecurityPolicyWebApplicationFirewallParameters;

/**
 * The json object containing security policy parameters
 */
export interface SecurityPolicyParameters {
  /**
   * Polymorphic Discriminator
   */
  type: "SecurityPolicyParameters";
}

/**
 * The json object containing security policy waf parameters
 */
export interface SecurityPolicyWebApplicationFirewallParameters {
  /**
   * Polymorphic Discriminator
   */
  type: "WebApplicationFirewall";
  /**
   * Resource ID.
   */
  wafPolicy?: ResourceReference;
  /**
   * Waf associations
   */
  associations?: SecurityPolicyWebApplicationFirewallAssociation[];
}

/**
 * SecurityPolicy association for AzureFrontDoor profile
 */
export interface SecurityPolicy extends ProxyResource {
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
  /**
   * object which contains security policy parameters
   */
  parameters?: SecurityPolicyWebApplicationFirewallParameters;
}

/**
 * CDN endpoint is the entity within a CDN profile containing configuration information such as
 * origin, protocol, content caching and delivery behavior. The AzureFrontDoor endpoint uses the
 * URL format <endpointname>.azureedge.net.
 */
export interface AFDEndpoint extends TrackedResource {
  /**
   * Send and receive timeout on forwarding request to the origin. When timeout is reached, the
   * request fails and returns.
   */
  originResponseTimeoutSeconds?: number;
  /**
   * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'. Possible
   * values include: 'Enabled', 'Disabled'
   */
  enabledState?: EnabledState;
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
  /**
   * The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g.
   * contoso.azureedge.net
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly hostName?: string;
}

/**
 * Properties required to create or update an endpoint.
 */
export interface AFDEndpointUpdateParameters extends BaseResource {
  /**
   * Endpoint tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * Send and receive timeout on forwarding request to the origin. When timeout is reached, the
   * request fails and returns.
   */
  originResponseTimeoutSeconds?: number;
  /**
   * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'. Possible
   * values include: 'Enabled', 'Disabled'
   */
  enabledState?: EnabledState;
}

/**
 * settings for compression.
 */
export interface CompressionSettings {
  /**
   * List of content types on which compression applies. The value should be a valid MIME type.
   */
  contentTypesToCompress?: string[];
  /**
   * Indicates whether content compression is enabled on AzureFrontDoor. Default value is false. If
   * compression is enabled, content will be served as compressed if user requests for a compressed
   * version. Content won't be compressed on AzureFrontDoor when requested content is smaller than
   * 1 byte or larger than 1 MB.
   */
  isCompressionEnabled?: boolean;
}

/**
 * Contains the possible cases for SecretParameters.
 */
export type SecretParametersUnion = SecretParameters | UrlSigningKeyParameters;

/**
 * The json object containing secret parameters
 */
export interface SecretParameters {
  /**
   * Polymorphic Discriminator
   */
  type: "SecretParameters";
}

/**
 * The tracking states for afd resources.
 */
export interface AFDStateProperties {
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
}

/**
 * The JSON object that contains the properties of the Secret to create.
 */
export interface SecretProperties extends AFDStateProperties {
  /**
   * object which contains secret parameters
   */
  parameters?: SecretParametersUnion;
}

/**
 * Friendly Secret name mapping to the any Secret or secret related information.
 */
export interface Secret extends ProxyResource {
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
  /**
   * object which contains secret parameters
   */
  parameters?: SecretParametersUnion;
}

/**
 * Url signing key parameters
 */
export interface UrlSigningKeyParameters {
  /**
   * Polymorphic Discriminator
   */
  type: "UrlSigningKey";
  /**
   * Defines the customer defined key Id. This id will exist in the incoming request to indicate
   * the key used to form the hash.
   */
  keyId: string;
  /**
   * Resource reference to the KV secret
   */
  secretSource: ResourceReference;
  /**
   * Version of the secret to be used
   */
  secretVersion?: string;
}

/**
 * Managed Certificate used for https
 */
export interface ManagedCertificateParameters {
  /**
   * The type of the Secret to create. Possible values include: 'UrlSigningKey',
   * 'CustomerCertificate', 'ManagedCertificate'
   */
  type: SecretType;
  /**
   * Subject name in the certificate.
   */
  subject?: string;
  /**
   * Certificate expiration date.
   */
  expirationDate?: string;
  /**
   * Certificate thumbprint.
   */
  thumbprint?: string;
}

/**
 * Customer Certificate used for https
 */
export interface CustomerCertificateParameters {
  /**
   * The type of the Secret to create. Possible values include: 'UrlSigningKey',
   * 'CustomerCertificate', 'ManagedCertificate'
   */
  type: SecretType;
  /**
   * Subject name in the certificate.
   */
  subject?: string;
  /**
   * Certificate expiration date.
   */
  expirationDate?: string;
  /**
   * Certificate thumbprint.
   */
  thumbprint?: string;
  /**
   * Resource reference to the KV secret
   */
  secretSource: ResourceReference;
  /**
   * Version of the secret to be used
   */
  secretVersion?: string;
  /**
   * Certificate issuing authority.
   */
  certificateAuthority?: string;
  /**
   * Whether to use the latest version for the certificate
   */
  useLatestVersion?: boolean;
  /**
   * The list of SANs.
   */
  subjectAlternativeNames?: string[];
}

/**
 * Friendly RuleSet name mapping to the any RuleSet or secret related information.
 */
export interface RuleSet extends ProxyResource {
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
}

/**
 * CDN origin is the source of the content being delivered via CDN. When the edge nodes represented
 * by an endpoint do not have the requested content cached, they attempt to fetch it from one or
 * more of the configured origins.
 */
export interface AFDOrigin extends ProxyResource {
  /**
   * Resource reference to the Azure origin resource.
   */
  azureOrigin?: ResourceReference;
  /**
   * The address of the origin. Domain names, IPv4 addresses, and IPv6 addresses are supported.This
   * should be unique across all origins in an endpoint.
   */
  hostName: string;
  /**
   * The value of the HTTP port. Must be between 1 and 65535.
   */
  httpPort?: number;
  /**
   * The value of the HTTPS port. Must be between 1 and 65535.
   */
  httpsPort?: number;
  /**
   * The host header value sent to the origin with each request. If you leave this blank, the
   * request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and
   * Cloud Services require this host header value to match the origin hostname by default. This
   * overrides the host header defined at Endpoint
   */
  originHostHeader?: string;
  /**
   * Priority of origin in given origin group for load balancing. Higher priorities will not be
   * used for load balancing if any lower priority origin is healthy.Must be between 1 and 5
   */
  priority?: number;
  /**
   * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
   */
  weight?: number;
  /**
   * The properties of the private link resource for private origin.
   */
  sharedPrivateLinkResource?: any;
  /**
   * Whether to enable health probes to be made against backends defined under backendPools. Health
   * probes can only be disabled if there is a single enabled backend in single enabled backend
   * pool. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: EnabledState;
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
}

/**
 * AFDOrigin properties needed for origin update.
 */
export interface AFDOriginUpdateParameters extends BaseResource {
  /**
   * Resource reference to the Azure origin resource.
   */
  azureOrigin?: ResourceReference;
  /**
   * The address of the origin. Domain names, IPv4 addresses, and IPv6 addresses are supported.This
   * should be unique across all origins in an endpoint.
   */
  hostName?: string;
  /**
   * The value of the HTTP port. Must be between 1 and 65535.
   */
  httpPort?: number;
  /**
   * The value of the HTTPS port. Must be between 1 and 65535.
   */
  httpsPort?: number;
  /**
   * The host header value sent to the origin with each request. If you leave this blank, the
   * request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and
   * Cloud Services require this host header value to match the origin hostname by default. This
   * overrides the host header defined at Endpoint
   */
  originHostHeader?: string;
  /**
   * Priority of origin in given origin group for load balancing. Higher priorities will not be
   * used for load balancing if any lower priority origin is healthy.Must be between 1 and 5
   */
  priority?: number;
  /**
   * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
   */
  weight?: number;
  /**
   * The properties of the private link resource for private origin.
   */
  sharedPrivateLinkResource?: any;
  /**
   * Whether to enable health probes to be made against backends defined under backendPools. Health
   * probes can only be disabled if there is a single enabled backend in single enabled backend
   * pool. Possible values include: 'Enabled', 'Disabled'
   */
  enabledState?: EnabledState;
}

/**
 * Describes the properties of an existing Shared Private Link Resource to use when connecting to a
 * private origin.
 */
export interface SharedPrivateLinkResourceProperties {
  /**
   * The resource id of the resource the shared private link resource is for.
   */
  privateLink?: ResourceReference;
  /**
   * The location of the shared private link resource
   */
  privateLinkLocation?: string;
  /**
   * The group id from the provider of resource the shared private link resource is for.
   */
  groupId?: string;
  /**
   * The request message for requesting approval of the shared private link resource.
   */
  requestMessage?: string;
  /**
   * Status of the shared private link resource. Can be Pending, Approved, Rejected, Disconnected,
   * or Timeout. Possible values include: 'Pending', 'Approved', 'Rejected', 'Disconnected',
   * 'Timeout'
   */
  status?: SharedPrivateLinkResourceStatus;
}

/**
 * Round-Robin load balancing settings for a backend pool
 */
export interface LoadBalancingSettingsParameters {
  /**
   * The number of samples to consider for load balancing decisions
   */
  sampleSize?: number;
  /**
   * The number of samples within the sample period that must succeed
   */
  successfulSamplesRequired?: number;
  /**
   * The additional latency in milliseconds for probes to fall into the lowest latency bucket
   */
  additionalLatencyInMilliseconds?: number;
}

/**
 * AFDOrigin group comprising of origins is used for load balancing to origins when the content
 * cannot be served from CDN.
 */
export interface AFDOriginGroup extends ProxyResource {
  /**
   * Load balancing settings for a backend pool
   */
  loadBalancingSettings?: LoadBalancingSettingsParameters;
  /**
   * Health probe settings to the origin that is used to determine the health of the origin.
   */
  healthProbeSettings?: HealthProbeParameters;
  /**
   * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint
   * comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
   * supported.
   */
  trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
  /**
   * The JSON object that contains the properties to determine origin health using real
   * requests/responses. This property is currently not supported.
   */
  responseBasedAfdOriginErrorDetectionSettings?: ResponseBasedOriginErrorDetectionParameters;
  /**
   * Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'.
   * Possible values include: 'Enabled', 'Disabled'
   */
  sessionAffinityState?: EnabledState;
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
}

/**
 * AFDOrigin group properties needed for origin group creation or update.
 */
export interface AFDOriginGroupUpdateParameters extends BaseResource {
  /**
   * Load balancing settings for a backend pool
   */
  loadBalancingSettings?: LoadBalancingSettingsParameters;
  /**
   * Health probe settings to the origin that is used to determine the health of the origin.
   */
  healthProbeSettings?: HealthProbeParameters;
  /**
   * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint
   * comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
   * supported.
   */
  trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
  /**
   * The JSON object that contains the properties to determine origin health using real
   * requests/responses. This property is currently not supported.
   */
  responseBasedAfdOriginErrorDetectionSettings?: ResponseBasedOriginErrorDetectionParameters;
  /**
   * Whether to allow session affinity on this host. Valid options are 'Enabled' or 'Disabled'.
   * Possible values include: 'Enabled', 'Disabled'
   */
  sessionAffinityState?: EnabledState;
}

/**
 * Friendly Routes name mapping to the any Routes or secret related information.
 */
export interface Route extends ProxyResource {
  /**
   * Domains referenced by this endpoint.
   */
  customDomains?: ResourceReference[];
  /**
   * A reference to the origin group.
   */
  originGroup: ResourceReference;
  /**
   * A directory path on the origin that AzureFrontDoor can use to retrieve content from, e.g.
   * contoso.cloudapp.net/originpath.
   */
  originPath?: string;
  /**
   * rule sets referenced by this endpoint.
   */
  ruleSets?: ResourceReference[];
  /**
   * List of supported protocols for this route.
   */
  supportedProtocols?: AFDEndpointProtocols[];
  /**
   * The route patterns of the rule.
   */
  patternsToMatch?: string[];
  /**
   * compression settings.
   */
  compressionSettings?: any;
  /**
   * Defines how AzureFrontDoor caches requests that include query strings. You can ignore any
   * query strings when caching, bypass caching to prevent requests that contain query strings from
   * being cached, or cache every request with a unique URL. Possible values include:
   * 'IgnoreQueryString', 'BypassCaching', 'UseQueryString', 'NotSet'
   */
  queryStringCachingBehavior?: QueryStringCachingBehavior;
  /**
   * Specifies what scenario the customer wants this AzureFrontDoor endpoint to optimize for, e.g.
   * Download, Media services. With this information, AzureFrontDoor can apply scenario driven
   * optimization. Possible values include: 'GeneralWebDelivery', 'GeneralMediaStreaming',
   * 'VideoOnDemandMediaStreaming', 'LargeFileDownload', 'DynamicSiteAcceleration'
   */
  optimizationType?: OptimizationType;
  /**
   * Protocol this rule will use when forwarding traffic to backends. Possible values include:
   * 'HttpOnly', 'HttpsOnly', 'MatchRequest'
   */
  forwardingProtocol?: ForwardingProtocol;
  /**
   * whether this route will be linked to the default endpoint domain. Possible values include:
   * 'Enabled', 'Disabled'
   */
  linkToDefaultDomain?: LinkToDefaultDomain;
  /**
   * Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way
   * to set up this rule and it will be the first rule that gets executed. Possible values include:
   * 'Enabled', 'Disabled'
   */
  httpsRedirect?: HttpsRedirect;
  /**
   * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'. Possible
   * values include: 'Enabled', 'Disabled'
   */
  enabledState?: EnabledState;
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
}

/**
 * The domain JSON object required for domain creation or update.
 */
export interface RouteUpdateParameters {
  /**
   * Domains referenced by this endpoint.
   */
  customDomains?: ResourceReference[];
  /**
   * A reference to the origin group.
   */
  originGroup?: ResourceReference;
  /**
   * A directory path on the origin that AzureFrontDoor can use to retrieve content from, e.g.
   * contoso.cloudapp.net/originpath.
   */
  originPath?: string;
  /**
   * rule sets referenced by this endpoint.
   */
  ruleSets?: ResourceReference[];
  /**
   * List of supported protocols for this route.
   */
  supportedProtocols?: AFDEndpointProtocols[];
  /**
   * The route patterns of the rule.
   */
  patternsToMatch?: string[];
  /**
   * compression settings.
   */
  compressionSettings?: any;
  /**
   * Defines how AzureFrontDoor caches requests that include query strings. You can ignore any
   * query strings when caching, bypass caching to prevent requests that contain query strings from
   * being cached, or cache every request with a unique URL. Possible values include:
   * 'IgnoreQueryString', 'BypassCaching', 'UseQueryString', 'NotSet'
   */
  queryStringCachingBehavior?: QueryStringCachingBehavior;
  /**
   * Specifies what scenario the customer wants this AzureFrontDoor endpoint to optimize for, e.g.
   * Download, Media services. With this information, AzureFrontDoor can apply scenario driven
   * optimization. Possible values include: 'GeneralWebDelivery', 'GeneralMediaStreaming',
   * 'VideoOnDemandMediaStreaming', 'LargeFileDownload', 'DynamicSiteAcceleration'
   */
  optimizationType?: OptimizationType;
  /**
   * Protocol this rule will use when forwarding traffic to backends. Possible values include:
   * 'HttpOnly', 'HttpsOnly', 'MatchRequest'
   */
  forwardingProtocol?: ForwardingProtocol;
  /**
   * whether this route will be linked to the default endpoint domain. Possible values include:
   * 'Enabled', 'Disabled'
   */
  linkToDefaultDomain?: LinkToDefaultDomain;
  /**
   * Whether to automatically redirect HTTP traffic to HTTPS traffic. Note that this is a easy way
   * to set up this rule and it will be the first rule that gets executed. Possible values include:
   * 'Enabled', 'Disabled'
   */
  httpsRedirect?: HttpsRedirect;
  /**
   * Whether to enable use of this rule. Permitted values are 'Enabled' or 'Disabled'. Possible
   * values include: 'Enabled', 'Disabled'
   */
  enabledState?: EnabledState;
}

/**
 * Friendly Rules name mapping to the any Rules or secret related information.
 */
export interface Rule extends ProxyResource {
  /**
   * The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A
   * rule with a lesser order will be applied before a rule with a greater order. Rule with order 0
   * is a special rule. It does not require any condition and actions listed in it will always be
   * applied.
   */
  order: number;
  /**
   * A list of conditions that must be matched for the actions to be executed
   */
  conditions?: DeliveryRuleConditionUnion[];
  /**
   * A list of actions that are executed when all the conditions of a rule are satisfied.
   */
  actions: DeliveryRuleActionUnion[];
  /**
   * If this rule is a match should the rules engine continue running the remaining rules or stop.
   * If not present, defaults to Continue. Possible values include: 'Continue', 'Stop'
   */
  matchProcessingBehavior?: MatchProcessingBehavior;
  /**
   * Provisioning status. Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting',
   * 'Creating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: AfdProvisioningState;
  /**
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly deploymentStatus?: DeploymentStatus;
}

/**
 * The domain JSON object required for domain creation or update.
 */
export interface RuleUpdateParameters {
  /**
   * The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A
   * rule with a lesser order will be applied before a rule with a greater order. Rule with order 0
   * is a special rule. It does not require any condition and actions listed in it will always be
   * applied.
   */
  order?: number;
  /**
   * A list of conditions that must be matched for the actions to be executed
   */
  conditions?: DeliveryRuleConditionUnion[];
  /**
   * A list of actions that are executed when all the conditions of a rule are satisfied.
   */
  actions?: DeliveryRuleActionUnion[];
  /**
   * If this rule is a match should the rules engine continue running the remaining rules or stop.
   * If not present, defaults to Continue. Possible values include: 'Continue', 'Stop'
   */
  matchProcessingBehavior?: MatchProcessingBehavior;
}

/**
 * The validation token.
 */
export interface ValidationToken {
  /**
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly token?: string;
}

/**
 * Common error response for all Azure Resource Manager APIs to return error details for failed
 * operations. (This also follows the OData error response format.).
 * @summary Error response
 */
export interface AfdErrorResponse {
  /**
   * The error object.
   */
  error?: ErrorResponse;
}

/**
 * An interface representing MetricsResponseSeriesItemGroupsItem.
 */
export interface MetricsResponseSeriesItemGroupsItem {
  name?: string;
  value?: string;
}

/**
 * An interface representing MetricsResponseSeriesItemDataItem.
 */
export interface MetricsResponseSeriesItemDataItem {
  dateTime?: Date;
  value?: number;
}

/**
 * An interface representing MetricsResponseSeriesItem.
 */
export interface MetricsResponseSeriesItem {
  metric?: string;
  /**
   * Possible values include: 'count', 'bytes', 'bitsPerSecond'
   */
  unit?: Unit;
  groups?: MetricsResponseSeriesItemGroupsItem[];
  data?: MetricsResponseSeriesItemDataItem[];
}

/**
 * Metrics Response
 */
export interface MetricsResponse {
  dateTimeBegin?: Date;
  dateTimeEnd?: Date;
  /**
   * Possible values include: 'PT5M', 'PT1H', 'P1D'
   */
  granularity?: Granularity;
  series?: MetricsResponseSeriesItem[];
}

/**
 * An interface representing RankingsResponseTablesItemDataItemMetricsItem.
 */
export interface RankingsResponseTablesItemDataItemMetricsItem {
  metric?: string;
  value?: number;
  percentage?: number;
}

/**
 * An interface representing RankingsResponseTablesItemDataItem.
 */
export interface RankingsResponseTablesItemDataItem {
  name?: string;
  metrics?: RankingsResponseTablesItemDataItemMetricsItem[];
}

/**
 * An interface representing RankingsResponseTablesItem.
 */
export interface RankingsResponseTablesItem {
  ranking?: string;
  data?: RankingsResponseTablesItemDataItem[];
}

/**
 * Rankings Response
 */
export interface RankingsResponse {
  dateTimeBegin?: Date;
  dateTimeEnd?: Date;
  tables?: RankingsResponseTablesItem[];
}

/**
 * An interface representing ContinentsResponseContinentsItem.
 */
export interface ContinentsResponseContinentsItem {
  id?: string;
}

/**
 * An interface representing ContinentsResponseCountryOrRegionsItem.
 */
export interface ContinentsResponseCountryOrRegionsItem {
  id?: string;
  continentId?: string;
}

/**
 * Continents Response
 */
export interface ContinentsResponse {
  continents?: ContinentsResponseContinentsItem[];
  countryOrRegions?: ContinentsResponseCountryOrRegionsItem[];
}

/**
 * An interface representing ResourcesResponseEndpointsItemCustomDomainsItem.
 */
export interface ResourcesResponseEndpointsItemCustomDomainsItem {
  id?: string;
  name?: string;
  endpointId?: string;
  history?: boolean;
}

/**
 * An interface representing ResourcesResponseEndpointsItem.
 */
export interface ResourcesResponseEndpointsItem {
  id?: string;
  name?: string;
  history?: boolean;
  customDomains?: ResourcesResponseEndpointsItemCustomDomainsItem[];
}

/**
 * An interface representing ResourcesResponseCustomDomainsItem.
 */
export interface ResourcesResponseCustomDomainsItem {
  id?: string;
  name?: string;
  endpointId?: string;
  history?: boolean;
}

/**
 * Resources Response
 */
export interface ResourcesResponse {
  endpoints?: ResourcesResponseEndpointsItem[];
  customDomains?: ResourcesResponseCustomDomainsItem[];
}

/**
 * An interface representing WafMetricsResponseSeriesItemGroupsItem.
 */
export interface WafMetricsResponseSeriesItemGroupsItem {
  name?: string;
  value?: string;
}

/**
 * An interface representing WafMetricsResponseSeriesItemDataItem.
 */
export interface WafMetricsResponseSeriesItemDataItem {
  dateTime?: Date;
  value?: number;
}

/**
 * An interface representing WafMetricsResponseSeriesItem.
 */
export interface WafMetricsResponseSeriesItem {
  metric?: string;
  /**
   * Possible values include: 'count'
   */
  unit?: Unit1;
  groups?: WafMetricsResponseSeriesItemGroupsItem[];
  data?: WafMetricsResponseSeriesItemDataItem[];
}

/**
 * Waf Metrics Response
 */
export interface WafMetricsResponse {
  dateTimeBegin?: Date;
  dateTimeEnd?: Date;
  /**
   * Possible values include: 'PT5M', 'PT1H', 'P1D'
   */
  granularity?: Granularity1;
  series?: WafMetricsResponseSeriesItem[];
}

/**
 * An interface representing WafRankingsResponseDataItemMetricsItem.
 */
export interface WafRankingsResponseDataItemMetricsItem {
  metric?: string;
  value?: number;
  percentage?: number;
}

/**
 * An interface representing WafRankingsResponseDataItem.
 */
export interface WafRankingsResponseDataItem {
  groupValues?: string[];
  metrics?: WafRankingsResponseDataItemMetricsItem[];
}

/**
 * Waf Rankings Response
 */
export interface WafRankingsResponse {
  dateTimeBegin?: Date;
  dateTimeEnd?: Date;
  groups?: string[];
  data?: WafRankingsResponseDataItem[];
}

/**
 * The usage names.
 */
export interface UsageName {
  /**
   * A string describing the resource name.
   */
  value?: string;
  /**
   * A localized string describing the resource name.
   */
  localizedValue?: string;
}

/**
 * Describes resource usage.
 */
export interface Usage {
  /**
   * Resource identifier.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
  /**
   * The current value of the usage.
   */
  currentValue: number;
  /**
   * The limit of usage.
   */
  limit: number;
  /**
   * The name of the type of usage.
   */
  name: UsageName;
}

/**
 * Defines contents of a web application firewall global configuration
 */
export interface PolicySettings {
  /**
   * describes if the policy is in enabled state or disabled state. Possible values include:
   * 'Disabled', 'Enabled'
   */
  enabledState?: PolicyEnabledState;
  /**
   * Describes if it is in detection mode or prevention mode at policy level. Possible values
   * include: 'Prevention', 'Detection'
   */
  mode?: PolicyMode;
  /**
   * If action type is redirect, this field represents the default redirect URL for the client.
   */
  defaultRedirectUrl?: string;
  /**
   * If the action type is block, this field defines the default customer overridable http response
   * status code.
   */
  defaultCustomBlockResponseStatusCode?: number;
  /**
   * If the action type is block, customer can override the response body. The body must be
   * specified in base64 encoding.
   */
  defaultCustomBlockResponseBody?: string;
}

/**
 * Defines the common attributes for a custom rule that can be included in a waf policy
 */
export interface CustomRule {
  /**
   * Defines the name of the custom rule
   */
  name: string;
  /**
   * Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not
   * specified. Possible values include: 'Disabled', 'Enabled'
   */
  enabledState?: CustomRuleEnabledState;
  /**
   * Defines in what order this rule be evaluated in the overall list of custom rules
   */
  priority: number;
  /**
   * List of match conditions.
   */
  matchConditions: MatchCondition[];
  /**
   * Describes what action to be applied when rule matches. Possible values include: 'Allow',
   * 'Block', 'Log', 'Redirect'
   */
  action: ActionType;
}

/**
 * Defines a rate limiting rule that can be included in a waf policy
 */
export interface RateLimitRule extends CustomRule {
  /**
   * Defines rate limit threshold.
   */
  rateLimitThreshold: number;
  /**
   * Defines rate limit duration. Default is 1 minute.
   */
  rateLimitDurationInMinutes: number;
}

/**
 * Defines contents of rate limit rules
 */
export interface RateLimitRuleList {
  /**
   * List of rules
   */
  rules?: RateLimitRule[];
}

/**
 * Define match conditions
 */
export interface MatchCondition {
  /**
   * Match variable to compare against. Possible values include: 'RemoteAddr', 'SocketAddr',
   * 'RequestMethod', 'RequestHeader', 'RequestUri', 'QueryString', 'RequestBody', 'Cookies',
   * 'PostArgs'
   */
  matchVariable: MatchVariable;
  /**
   * Selector can used to match a specific key for QueryString, Cookies, RequestHeader or PostArgs.
   */
  selector?: string;
  /**
   * Describes operator to be matched. Possible values include: 'Any', 'IPMatch', 'GeoMatch',
   * 'Equal', 'Contains', 'LessThan', 'GreaterThan', 'LessThanOrEqual', 'GreaterThanOrEqual',
   * 'BeginsWith', 'EndsWith', 'RegEx'
   */
  operator: Operator;
  /**
   * Describes if the result of this condition should be negated.
   */
  negateCondition?: boolean;
  /**
   * List of possible match values.
   */
  matchValue: string[];
  /**
   * List of transforms.
   */
  transforms?: TransformType[];
}

/**
 * Defines contents of custom rules
 */
export interface CustomRuleList {
  /**
   * List of rules
   */
  rules?: CustomRule[];
}

/**
 * Defines a managed rule group override setting.
 */
export interface ManagedRuleOverride {
  /**
   * Identifier for the managed rule.
   */
  ruleId: string;
  /**
   * Describes if the managed rule is in enabled or disabled state. Defaults to Disabled if not
   * specified. Possible values include: 'Disabled', 'Enabled'
   */
  enabledState?: ManagedRuleEnabledState;
  /**
   * Describes the override action to be applied when rule matches. Possible values include:
   * 'Allow', 'Block', 'Log', 'Redirect'
   */
  action?: ActionType;
}

/**
 * Defines a managed rule group override setting.
 */
export interface ManagedRuleGroupOverride {
  /**
   * Describes the managed rule group within the rule set to override
   */
  ruleGroupName: string;
  /**
   * List of rules that will be disabled. If none specified, all rules in the group will be
   * disabled.
   */
  rules?: ManagedRuleOverride[];
}

/**
 * Defines a managed rule set.
 */
export interface ManagedRuleSet {
  /**
   * Defines the rule set type to use.
   */
  ruleSetType: string;
  /**
   * Defines the version of the rule set to use.
   */
  ruleSetVersion: string;
  /**
   * Verizon only : If the rule set supports anomaly detection mode, this describes the threshold
   * for blocking requests.
   */
  anomalyScore?: number;
  /**
   * Defines the rule overrides to apply to the rule set.
   */
  ruleGroupOverrides?: ManagedRuleGroupOverride[];
}

/**
 * Defines the list of managed rule sets for the policy.
 */
export interface ManagedRuleSetList {
  /**
   * List of rule sets.
   */
  managedRuleSets?: ManagedRuleSet[];
}

/**
 * Defines the ARM Resource ID for the linked endpoints
 */
export interface CdnEndpoint {
  /**
   * ARM Resource ID string.
   */
  id?: string;
}

/**
 * Defines web application firewall policy for Azure CDN.
 */
export interface CdnWebApplicationFirewallPolicy extends TrackedResource {
  /**
   * Describes  policySettings for policy
   */
  policySettings?: PolicySettings;
  /**
   * Describes rate limit rules inside the policy.
   */
  rateLimitRules?: RateLimitRuleList;
  /**
   * Describes custom rules inside the policy.
   */
  customRules?: CustomRuleList;
  /**
   * Describes managed rules inside the policy.
   */
  managedRules?: ManagedRuleSetList;
  /**
   * Describes Azure CDN endpoints associated with this Web Application Firewall policy.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly endpointLinks?: CdnEndpoint[];
  /**
   * Provisioning state of the WebApplicationFirewallPolicy. Possible values include: 'Creating',
   * 'Succeeded', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: ProvisioningState;
  /**
   * Resource status of the policy. Possible values include: 'Creating', 'Enabling', 'Enabled',
   * 'Disabling', 'Disabled', 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: PolicyResourceState;
  /**
   * Gets a unique read-only string that changes whenever the resource is updated.
   */
  etag?: string;
  /**
   * The pricing tier (defines a CDN provider, feature list and rate) of the
   * CdnWebApplicationFirewallPolicy.
   */
  sku: Sku;
}

/**
 * Properties required to update a CdnWebApplicationFirewallPolicy.
 */
export interface CdnWebApplicationFirewallPolicyPatchParameters extends BaseResource {
  /**
   * CdnWebApplicationFirewallPolicy tags
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Describes a managed rule definition.
 */
export interface ManagedRuleDefinition {
  /**
   * Identifier for the managed rule.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleId?: string;
  /**
   * Describes the functionality of the managed rule.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly description?: string;
}

/**
 * Describes a managed rule group.
 */
export interface ManagedRuleGroupDefinition {
  /**
   * Name of the managed rule group.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleGroupName?: string;
  /**
   * Description of the managed rule group.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly description?: string;
  /**
   * List of rules within the managed rule group.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly rules?: ManagedRuleDefinition[];
}

/**
 * Describes a managed rule set definition.
 */
export interface ManagedRuleSetDefinition extends Resource {
  /**
   * Provisioning state of the managed rule set.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * Type of the managed rule set.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleSetType?: string;
  /**
   * Version of the managed rule set type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleSetVersion?: string;
  /**
   * Rule groups of the managed rule set.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ruleGroups?: ManagedRuleGroupDefinition[];
  /**
   * The pricing tier (defines a CDN provider, feature list and rate) of the
   * CdnWebApplicationFirewallPolicy.
   */
  sku?: Sku;
}

/**
 * Optional Parameters.
 */
export interface ProfilesUpdateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Profile tags
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Optional Parameters.
 */
export interface ProfilesBeginUpdateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Profile tags
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Optional Parameters.
 */
export interface CustomDomainsEnableCustomHttpsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The configuration specifying how to enable HTTPS for the custom domain - using CDN managed
   * certificate or user's own certificate. If not specified, enabling ssl uses CDN managed
   * certificate by default.
   */
  customDomainHttpsParameters?: CustomDomainHttpsParametersUnion;
}

/**
 * Optional Parameters.
 */
export interface AFDCustomDomainsUpdateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The configuration specifying how to enable HTTPS for the domain - using AzureFrontDoor managed
   * certificate or user's own certificate. If not specified, enabling ssl uses AzureFrontDoor
   * managed certificate by default.
   */
  tlsSettings?: AFDDomainHttpsParameters;
  /**
   * Resource reference to the Azure DNS zone
   */
  azureDnsZone?: ResourceReference;
}

/**
 * Optional Parameters.
 */
export interface AFDCustomDomainsBeginUpdateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The configuration specifying how to enable HTTPS for the domain - using AzureFrontDoor managed
   * certificate or user's own certificate. If not specified, enabling ssl uses AzureFrontDoor
   * managed certificate by default.
   */
  tlsSettings?: AFDDomainHttpsParameters;
  /**
   * Resource reference to the Azure DNS zone
   */
  azureDnsZone?: ResourceReference;
}

/**
 * Optional Parameters.
 */
export interface AFDEndpointsPurgeContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * List of domains.
   */
  domains?: string[];
}

/**
 * Optional Parameters.
 */
export interface AFDEndpointsBeginPurgeContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * List of domains.
   */
  domains?: string[];
}

/**
 * Optional Parameters.
 */
export interface SecurityPoliciesCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * object which contains security policy parameters
   */
  parameters?: SecurityPolicyWebApplicationFirewallParameters;
}

/**
 * Optional Parameters.
 */
export interface SecurityPoliciesBeginCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * object which contains security policy parameters
   */
  parameters?: SecurityPolicyWebApplicationFirewallParameters;
}

/**
 * Optional Parameters.
 */
export interface SecretsCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * object which contains secret parameters
   */
  parameters?: SecretParametersUnion;
}

/**
 * Optional Parameters.
 */
export interface SecretsUpdateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * object which contains secret parameters
   */
  parameters?: SecretParametersUnion;
}

/**
 * Optional Parameters.
 */
export interface SecretsBeginCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * object which contains secret parameters
   */
  parameters?: SecretParametersUnion;
}

/**
 * Optional Parameters.
 */
export interface SecretsBeginUpdateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * object which contains secret parameters
   */
  parameters?: SecretParametersUnion;
}

/**
 * Optional Parameters.
 */
export interface LogAnalyticsGetLogAnalyticsMetricsOptionalParams extends msRest.RequestOptionsBase {
  groupBy?: string[];
  continents?: string[];
  countryOrRegions?: string[];
  customDomains?: string[];
  protocols?: string[];
}

/**
 * Optional Parameters.
 */
export interface LogAnalyticsGetLogAnalyticsRankingsOptionalParams extends msRest.RequestOptionsBase {
  customDomains?: string[];
}

/**
 * Optional Parameters.
 */
export interface LogAnalyticsGetWafLogAnalyticsMetricsOptionalParams extends msRest.RequestOptionsBase {
  actions?: string[];
  groupBy?: string[];
  ruleTypes?: string[];
}

/**
 * Optional Parameters.
 */
export interface LogAnalyticsGetWafLogAnalyticsRankingsOptionalParams extends msRest.RequestOptionsBase {
  actions?: string[];
  ruleTypes?: string[];
}

/**
 * Optional Parameters.
 */
export interface PoliciesUpdateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * CdnWebApplicationFirewallPolicy tags
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Optional Parameters.
 */
export interface PoliciesBeginUpdateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * CdnWebApplicationFirewallPolicy tags
   */
  tags?: { [propertyName: string]: string };
}

/**
 * An interface representing CdnManagementClientOptions.
 */
export interface CdnManagementClientOptions extends AzureServiceClientOptions {
  baseUri?: string;
}

/**
 * @interface
 * Result of the request to list profiles. It contains a list of profile objects and a URL link to
 * get the next set of results.
 * @extends Array<Profile>
 */
export interface ProfileListResult extends Array<Profile> {
  /**
   * URL to get the next set of profile objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Output of check resource usage API.
 * @extends Array<ResourceUsage>
 */
export interface ResourceUsageListResult extends Array<ResourceUsage> {
  /**
   * URL to get the next set of custom domain objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list endpoints. It contains a list of endpoint objects and a URL link
 * to get the next set of results.
 * @extends Array<Endpoint>
 */
export interface EndpointListResult extends Array<Endpoint> {
  /**
   * URL to get the next set of endpoint objects if there is any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list origins. It contains a list of origin objects and a URL link to
 * get the next set of results.
 * @extends Array<Origin>
 */
export interface OriginListResult extends Array<Origin> {
  /**
   * URL to get the next set of origin objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list origin groups. It contains a list of origin groups objects and a
 * URL link to get the next set of results.
 * @extends Array<OriginGroup>
 */
export interface OriginGroupListResult extends Array<OriginGroup> {
  /**
   * URL to get the next set of origin objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list custom domains. It contains a list of custom domain objects and a
 * URL link to get the next set of results.
 * @extends Array<CustomDomain>
 */
export interface CustomDomainListResult extends Array<CustomDomain> {
  /**
   * URL to get the next set of custom domain objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list CDN operations. It contains a list of operations and a URL link to
 * get the next set of results.
 * @extends Array<Operation>
 */
export interface OperationsListResult extends Array<Operation> {
  /**
   * URL to get the next set of operation list results if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list CDN edgenodes. It contains a list of ip address group and a URL
 * link to get the next set of results.
 * @extends Array<EdgeNode>
 */
export interface EdgenodeResult extends Array<EdgeNode> {
  /**
   * URL to get the next set of edgenode list results if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * The list usages operation response.
 * @extends Array<Usage>
 */
export interface UsagesListResult extends Array<Usage> {
  /**
   * URL to get the next set of results.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list domains. It contains a list of domain objects and a URL link to
 * get the next set of results.
 * @extends Array<AFDDomain>
 */
export interface AFDDomainListResult extends Array<AFDDomain> {
  /**
   * URL to get the next set of domain objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list endpoints. It contains a list of endpoint objects and a URL link
 * to get the next set of results.
 * @extends Array<AFDEndpoint>
 */
export interface AFDEndpointListResult extends Array<AFDEndpoint> {
  /**
   * URL to get the next set of endpoint objects if there is any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list origin groups. It contains a list of origin groups objects and a
 * URL link to get the next set of results.
 * @extends Array<AFDOriginGroup>
 */
export interface AFDOriginGroupListResult extends Array<AFDOriginGroup> {
  /**
   * URL to get the next set of origin objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list origins. It contains a list of origin objects and a URL link to
 * get the next set of results.
 * @extends Array<AFDOrigin>
 */
export interface AFDOriginListResult extends Array<AFDOrigin> {
  /**
   * URL to get the next set of origin objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list routes. It contains a list of route objects and a URL link to get
 * the next set of results.
 * @extends Array<Route>
 */
export interface RouteListResult extends Array<Route> {
  /**
   * URL to get the next set of route objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list rule sets. It contains a list of rule set objects and a URL link
 * to get the next set of results.
 * @extends Array<RuleSet>
 */
export interface RuleSetListResult extends Array<RuleSet> {
  /**
   * URL to get the next set of rule set objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list rules. It contains a list of rule objects and a URL link to get
 * the next set of results.
 * @extends Array<Rule>
 */
export interface RuleListResult extends Array<Rule> {
  /**
   * URL to get the next set of rule objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list security policies. It contains a list of security policy objects
 * and a URL link to get the next set of results.
 * @extends Array<SecurityPolicy>
 */
export interface SecurityPolicyListResult extends Array<SecurityPolicy> {
  /**
   * URL to get the next set of security policy objects if there is any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Result of the request to list secrets. It contains a list of Secret objects and a URL link to
 * get the next set of results.
 * @extends Array<Secret>
 */
export interface SecretListResult extends Array<Secret> {
  /**
   * URL to get the next set of Secret objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * Defines a list of WebApplicationFirewallPolicies for Azure CDN. It contains a list of
 * WebApplicationFirewallPolicy objects and a URL link to get the next set of results.
 * @extends Array<CdnWebApplicationFirewallPolicy>
 */
export interface CdnWebApplicationFirewallPolicyList extends Array<CdnWebApplicationFirewallPolicy> {
  /**
   * URL to get the next set of WebApplicationFirewallPolicy objects if there are any.
   */
  nextLink?: string;
}

/**
 * @interface
 * List of managed rule set definitions available for use in a policy.
 * @extends Array<ManagedRuleSetDefinition>
 */
export interface ManagedRuleSetDefinitionList extends Array<ManagedRuleSetDefinition> {
  /**
   * URL to retrieve next set of managed rule set definitions.
   */
  nextLink?: string;
}

/**
 * Defines values for SkuName.
 * Possible values include: 'Standard_Verizon', 'Premium_Verizon', 'Custom_Verizon',
 * 'Standard_Akamai', 'Standard_ChinaCdn', 'Standard_Microsoft', 'Premium_ChinaCdn',
 * 'Standard_AzureFrontDoor', 'Premium_AzureFrontDoor', 'Standard_955BandWidth_ChinaCdn',
 * 'Standard_AvgBandWidth_ChinaCdn', 'StandardPlus_ChinaCdn', 'StandardPlus_955BandWidth_ChinaCdn',
 * 'StandardPlus_AvgBandWidth_ChinaCdn'
 * @readonly
 * @enum {string}
 */
export type SkuName = 'Standard_Verizon' | 'Premium_Verizon' | 'Custom_Verizon' | 'Standard_Akamai' | 'Standard_ChinaCdn' | 'Standard_Microsoft' | 'Premium_ChinaCdn' | 'Standard_AzureFrontDoor' | 'Premium_AzureFrontDoor' | 'Standard_955BandWidth_ChinaCdn' | 'Standard_AvgBandWidth_ChinaCdn' | 'StandardPlus_ChinaCdn' | 'StandardPlus_955BandWidth_ChinaCdn' | 'StandardPlus_AvgBandWidth_ChinaCdn';

/**
 * Defines values for ProfileResourceState.
 * Possible values include: 'Creating', 'Active', 'Deleting', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type ProfileResourceState = 'Creating' | 'Active' | 'Deleting' | 'Disabled';

/**
 * Defines values for OptimizationType.
 * Possible values include: 'GeneralWebDelivery', 'GeneralMediaStreaming',
 * 'VideoOnDemandMediaStreaming', 'LargeFileDownload', 'DynamicSiteAcceleration'
 * @readonly
 * @enum {string}
 */
export type OptimizationType = 'GeneralWebDelivery' | 'GeneralMediaStreaming' | 'VideoOnDemandMediaStreaming' | 'LargeFileDownload' | 'DynamicSiteAcceleration';

/**
 * Defines values for HealthProbeRequestType.
 * Possible values include: 'NotSet', 'GET', 'HEAD'
 * @readonly
 * @enum {string}
 */
export type HealthProbeRequestType = 'NotSet' | 'GET' | 'HEAD';

/**
 * Defines values for ProbeProtocol.
 * Possible values include: 'NotSet', 'Http', 'Https'
 * @readonly
 * @enum {string}
 */
export type ProbeProtocol = 'NotSet' | 'Http' | 'Https';

/**
 * Defines values for ResponseBasedDetectedErrorTypes.
 * Possible values include: 'None', 'TcpErrorsOnly', 'TcpAndHttpErrors'
 * @readonly
 * @enum {string}
 */
export type ResponseBasedDetectedErrorTypes = 'None' | 'TcpErrorsOnly' | 'TcpAndHttpErrors';

/**
 * Defines values for EndpointResourceState.
 * Possible values include: 'Creating', 'Deleting', 'Running', 'Starting', 'Stopped', 'Stopping'
 * @readonly
 * @enum {string}
 */
export type EndpointResourceState = 'Creating' | 'Deleting' | 'Running' | 'Starting' | 'Stopped' | 'Stopping';

/**
 * Defines values for QueryStringCachingBehavior.
 * Possible values include: 'IgnoreQueryString', 'BypassCaching', 'UseQueryString', 'NotSet'
 * @readonly
 * @enum {string}
 */
export type QueryStringCachingBehavior = 'IgnoreQueryString' | 'BypassCaching' | 'UseQueryString' | 'NotSet';

/**
 * Defines values for GeoFilterActions.
 * Possible values include: 'Block', 'Allow'
 * @readonly
 * @enum {string}
 */
export type GeoFilterActions = 'Block' | 'Allow';

/**
 * Defines values for RemoteAddressOperator.
 * Possible values include: 'Any', 'IPMatch', 'GeoMatch'
 * @readonly
 * @enum {string}
 */
export type RemoteAddressOperator = 'Any' | 'IPMatch' | 'GeoMatch';

/**
 * Defines values for Transform.
 * Possible values include: 'Lowercase', 'Uppercase'
 * @readonly
 * @enum {string}
 */
export type Transform = 'Lowercase' | 'Uppercase';

/**
 * Defines values for QueryStringOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type QueryStringOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'RegEx';

/**
 * Defines values for PostArgsOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type PostArgsOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'RegEx';

/**
 * Defines values for RequestUriOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type RequestUriOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'RegEx';

/**
 * Defines values for RequestHeaderOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type RequestHeaderOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'RegEx';

/**
 * Defines values for RequestBodyOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type RequestBodyOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'RegEx';

/**
 * Defines values for UrlPathOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'Wildcard', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type UrlPathOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'Wildcard' | 'RegEx';

/**
 * Defines values for UrlFileExtensionOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type UrlFileExtensionOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'RegEx';

/**
 * Defines values for UrlFileNameOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type UrlFileNameOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'RegEx';

/**
 * Defines values for CookiesOperator.
 * Possible values include: 'Any', 'Equal', 'Contains', 'BeginsWith', 'EndsWith', 'LessThan',
 * 'LessThanOrEqual', 'GreaterThan', 'GreaterThanOrEqual', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type CookiesOperator = 'Any' | 'Equal' | 'Contains' | 'BeginsWith' | 'EndsWith' | 'LessThan' | 'LessThanOrEqual' | 'GreaterThan' | 'GreaterThanOrEqual' | 'RegEx';

/**
 * Defines values for RedirectType.
 * Possible values include: 'Moved', 'Found', 'TemporaryRedirect', 'PermanentRedirect'
 * @readonly
 * @enum {string}
 */
export type RedirectType = 'Moved' | 'Found' | 'TemporaryRedirect' | 'PermanentRedirect';

/**
 * Defines values for DestinationProtocol.
 * Possible values include: 'MatchRequest', 'Http', 'Https'
 * @readonly
 * @enum {string}
 */
export type DestinationProtocol = 'MatchRequest' | 'Http' | 'Https';

/**
 * Defines values for Algorithm.
 * Possible values include: 'SHA256'
 * @readonly
 * @enum {string}
 */
export type Algorithm = 'SHA256';

/**
 * Defines values for ParamIndicator.
 * Possible values include: 'Expires', 'KeyId', 'Signature'
 * @readonly
 * @enum {string}
 */
export type ParamIndicator = 'Expires' | 'KeyId' | 'Signature';

/**
 * Defines values for HeaderAction.
 * Possible values include: 'Append', 'Overwrite', 'Delete'
 * @readonly
 * @enum {string}
 */
export type HeaderAction = 'Append' | 'Overwrite' | 'Delete';

/**
 * Defines values for CacheBehavior.
 * Possible values include: 'BypassCache', 'Override', 'SetIfMissing'
 * @readonly
 * @enum {string}
 */
export type CacheBehavior = 'BypassCache' | 'Override' | 'SetIfMissing';

/**
 * Defines values for QueryStringBehavior.
 * Possible values include: 'Include', 'IncludeAll', 'Exclude', 'ExcludeAll'
 * @readonly
 * @enum {string}
 */
export type QueryStringBehavior = 'Include' | 'IncludeAll' | 'Exclude' | 'ExcludeAll';

/**
 * Defines values for OriginResourceState.
 * Possible values include: 'Creating', 'Active', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type OriginResourceState = 'Creating' | 'Active' | 'Deleting';

/**
 * Defines values for PrivateEndpointStatus.
 * Possible values include: 'Pending', 'Approved', 'Rejected', 'Disconnected', 'Timeout'
 * @readonly
 * @enum {string}
 */
export type PrivateEndpointStatus = 'Pending' | 'Approved' | 'Rejected' | 'Disconnected' | 'Timeout';

/**
 * Defines values for OriginGroupResourceState.
 * Possible values include: 'Creating', 'Active', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type OriginGroupResourceState = 'Creating' | 'Active' | 'Deleting';

/**
 * Defines values for CustomDomainResourceState.
 * Possible values include: 'Creating', 'Active', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type CustomDomainResourceState = 'Creating' | 'Active' | 'Deleting';

/**
 * Defines values for CustomHttpsProvisioningState.
 * Possible values include: 'Enabling', 'Enabled', 'Disabling', 'Disabled', 'Failed'
 * @readonly
 * @enum {string}
 */
export type CustomHttpsProvisioningState = 'Enabling' | 'Enabled' | 'Disabling' | 'Disabled' | 'Failed';

/**
 * Defines values for CustomHttpsProvisioningSubstate.
 * Possible values include: 'SubmittingDomainControlValidationRequest',
 * 'PendingDomainControlValidationREquestApproval', 'DomainControlValidationRequestApproved',
 * 'DomainControlValidationRequestRejected', 'DomainControlValidationRequestTimedOut',
 * 'IssuingCertificate', 'DeployingCertificate', 'CertificateDeployed', 'DeletingCertificate',
 * 'CertificateDeleted'
 * @readonly
 * @enum {string}
 */
export type CustomHttpsProvisioningSubstate = 'SubmittingDomainControlValidationRequest' | 'PendingDomainControlValidationREquestApproval' | 'DomainControlValidationRequestApproved' | 'DomainControlValidationRequestRejected' | 'DomainControlValidationRequestTimedOut' | 'IssuingCertificate' | 'DeployingCertificate' | 'CertificateDeployed' | 'DeletingCertificate' | 'CertificateDeleted';

/**
 * Defines values for ProtocolType.
 * Possible values include: 'ServerNameIndication', 'IPBased'
 * @readonly
 * @enum {string}
 */
export type ProtocolType = 'ServerNameIndication' | 'IPBased';

/**
 * Defines values for MinimumTlsVersion.
 * Possible values include: 'None', 'TLS10', 'TLS12'
 * @readonly
 * @enum {string}
 */
export type MinimumTlsVersion = 'None' | 'TLS10' | 'TLS12';

/**
 * Defines values for CertificateType.
 * Possible values include: 'Shared', 'Dedicated'
 * @readonly
 * @enum {string}
 */
export type CertificateType = 'Shared' | 'Dedicated';

/**
 * Defines values for ResourceType.
 * Possible values include: 'Microsoft.Cdn/Profiles/Endpoints'
 * @readonly
 * @enum {string}
 */
export type ResourceType = 'Microsoft.Cdn/Profiles/Endpoints';

/**
 * Defines values for IdentityType.
 * Possible values include: 'user', 'application', 'managedIdentity', 'key'
 * @readonly
 * @enum {string}
 */
export type IdentityType = 'user' | 'application' | 'managedIdentity' | 'key';

/**
 * Defines values for ValidateSecretType.
 * Possible values include: 'UrlSigningKey', 'ManagedCertificate', 'CustomerCertificate'
 * @readonly
 * @enum {string}
 */
export type ValidateSecretType = 'UrlSigningKey' | 'ManagedCertificate' | 'CustomerCertificate';

/**
 * Defines values for Status.
 * Possible values include: 'Valid', 'Invalid', 'AccessDenied', 'CertificateExpired'
 * @readonly
 * @enum {string}
 */
export type Status = 'Valid' | 'Invalid' | 'AccessDenied' | 'CertificateExpired';

/**
 * Defines values for AfdCertificateType.
 * Possible values include: 'CustomerCertificate', 'ManagedCertificate'
 * @readonly
 * @enum {string}
 */
export type AfdCertificateType = 'CustomerCertificate' | 'ManagedCertificate';

/**
 * Defines values for AfdMinimumTlsVersion.
 * Possible values include: 'TLS10', 'TLS12'
 * @readonly
 * @enum {string}
 */
export type AfdMinimumTlsVersion = 'TLS10' | 'TLS12';

/**
 * Defines values for AfdProvisioningState.
 * Possible values include: 'Succeeded', 'Failed', 'Updating', 'Deleting', 'Creating'
 * @readonly
 * @enum {string}
 */
export type AfdProvisioningState = 'Succeeded' | 'Failed' | 'Updating' | 'Deleting' | 'Creating';

/**
 * Defines values for DeploymentStatus.
 * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Failed'
 * @readonly
 * @enum {string}
 */
export type DeploymentStatus = 'NotStarted' | 'InProgress' | 'Succeeded' | 'Failed';

/**
 * Defines values for DomainValidationState.
 * Possible values include: 'Unknown', 'Submitting', 'Pending', 'TimedOut', 'PendingRevalidation',
 * 'Approved'
 * @readonly
 * @enum {string}
 */
export type DomainValidationState = 'Unknown' | 'Submitting' | 'Pending' | 'TimedOut' | 'PendingRevalidation' | 'Approved';

/**
 * Defines values for EnabledState.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type EnabledState = 'Enabled' | 'Disabled';

/**
 * Defines values for AFDEndpointProtocols.
 * Possible values include: 'Http', 'Https'
 * @readonly
 * @enum {string}
 */
export type AFDEndpointProtocols = 'Http' | 'Https';

/**
 * Defines values for SecretType.
 * Possible values include: 'UrlSigningKey', 'CustomerCertificate', 'ManagedCertificate'
 * @readonly
 * @enum {string}
 */
export type SecretType = 'UrlSigningKey' | 'CustomerCertificate' | 'ManagedCertificate';

/**
 * Defines values for SharedPrivateLinkResourceStatus.
 * Possible values include: 'Pending', 'Approved', 'Rejected', 'Disconnected', 'Timeout'
 * @readonly
 * @enum {string}
 */
export type SharedPrivateLinkResourceStatus = 'Pending' | 'Approved' | 'Rejected' | 'Disconnected' | 'Timeout';

/**
 * Defines values for ForwardingProtocol.
 * Possible values include: 'HttpOnly', 'HttpsOnly', 'MatchRequest'
 * @readonly
 * @enum {string}
 */
export type ForwardingProtocol = 'HttpOnly' | 'HttpsOnly' | 'MatchRequest';

/**
 * Defines values for LinkToDefaultDomain.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type LinkToDefaultDomain = 'Enabled' | 'Disabled';

/**
 * Defines values for HttpsRedirect.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type HttpsRedirect = 'Enabled' | 'Disabled';

/**
 * Defines values for MatchProcessingBehavior.
 * Possible values include: 'Continue', 'Stop'
 * @readonly
 * @enum {string}
 */
export type MatchProcessingBehavior = 'Continue' | 'Stop';

/**
 * Defines values for PolicyEnabledState.
 * Possible values include: 'Disabled', 'Enabled'
 * @readonly
 * @enum {string}
 */
export type PolicyEnabledState = 'Disabled' | 'Enabled';

/**
 * Defines values for PolicyMode.
 * Possible values include: 'Prevention', 'Detection'
 * @readonly
 * @enum {string}
 */
export type PolicyMode = 'Prevention' | 'Detection';

/**
 * Defines values for CustomRuleEnabledState.
 * Possible values include: 'Disabled', 'Enabled'
 * @readonly
 * @enum {string}
 */
export type CustomRuleEnabledState = 'Disabled' | 'Enabled';

/**
 * Defines values for MatchVariable.
 * Possible values include: 'RemoteAddr', 'SocketAddr', 'RequestMethod', 'RequestHeader',
 * 'RequestUri', 'QueryString', 'RequestBody', 'Cookies', 'PostArgs'
 * @readonly
 * @enum {string}
 */
export type MatchVariable = 'RemoteAddr' | 'SocketAddr' | 'RequestMethod' | 'RequestHeader' | 'RequestUri' | 'QueryString' | 'RequestBody' | 'Cookies' | 'PostArgs';

/**
 * Defines values for Operator.
 * Possible values include: 'Any', 'IPMatch', 'GeoMatch', 'Equal', 'Contains', 'LessThan',
 * 'GreaterThan', 'LessThanOrEqual', 'GreaterThanOrEqual', 'BeginsWith', 'EndsWith', 'RegEx'
 * @readonly
 * @enum {string}
 */
export type Operator = 'Any' | 'IPMatch' | 'GeoMatch' | 'Equal' | 'Contains' | 'LessThan' | 'GreaterThan' | 'LessThanOrEqual' | 'GreaterThanOrEqual' | 'BeginsWith' | 'EndsWith' | 'RegEx';

/**
 * Defines values for TransformType.
 * Possible values include: 'Lowercase', 'Uppercase', 'Trim', 'UrlDecode', 'UrlEncode',
 * 'RemoveNulls'
 * @readonly
 * @enum {string}
 */
export type TransformType = 'Lowercase' | 'Uppercase' | 'Trim' | 'UrlDecode' | 'UrlEncode' | 'RemoveNulls';

/**
 * Defines values for ActionType.
 * Possible values include: 'Allow', 'Block', 'Log', 'Redirect'
 * @readonly
 * @enum {string}
 */
export type ActionType = 'Allow' | 'Block' | 'Log' | 'Redirect';

/**
 * Defines values for ManagedRuleEnabledState.
 * Possible values include: 'Disabled', 'Enabled'
 * @readonly
 * @enum {string}
 */
export type ManagedRuleEnabledState = 'Disabled' | 'Enabled';

/**
 * Defines values for ProvisioningState.
 * Possible values include: 'Creating', 'Succeeded', 'Failed'
 * @readonly
 * @enum {string}
 */
export type ProvisioningState = 'Creating' | 'Succeeded' | 'Failed';

/**
 * Defines values for PolicyResourceState.
 * Possible values include: 'Creating', 'Enabling', 'Enabled', 'Disabling', 'Disabled', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type PolicyResourceState = 'Creating' | 'Enabling' | 'Enabled' | 'Disabling' | 'Disabled' | 'Deleting';

/**
 * Defines values for Unit.
 * Possible values include: 'count', 'bytes', 'bitsPerSecond'
 * @readonly
 * @enum {string}
 */
export type Unit = 'count' | 'bytes' | 'bitsPerSecond';

/**
 * Defines values for Granularity.
 * Possible values include: 'PT5M', 'PT1H', 'P1D'
 * @readonly
 * @enum {string}
 */
export type Granularity = 'PT5M' | 'PT1H' | 'P1D';

/**
 * Defines values for Unit1.
 * Possible values include: 'count'
 * @readonly
 * @enum {string}
 */
export type Unit1 = 'count';

/**
 * Defines values for Granularity1.
 * Possible values include: 'PT5M', 'PT1H', 'P1D'
 * @readonly
 * @enum {string}
 */
export type Granularity1 = 'PT5M' | 'PT1H' | 'P1D';

/**
 * Defines values for Granularity2.
 * Possible values include: 'PT5M', 'PT1H', 'P1D'
 * @readonly
 * @enum {string}
 */
export type Granularity2 = 'PT5M' | 'PT1H' | 'P1D';

/**
 * Defines values for Granularity3.
 * Possible values include: 'PT5M', 'PT1H', 'P1D'
 * @readonly
 * @enum {string}
 */
export type Granularity3 = 'PT5M' | 'PT1H' | 'P1D';

/**
 * Contains response data for the list operation.
 */
export type ProfilesListResponse = ProfileListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ProfileListResult;
    };
};

/**
 * Contains response data for the listByResourceGroup operation.
 */
export type ProfilesListByResourceGroupResponse = ProfileListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ProfileListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ProfilesGetResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the create operation.
 */
export type ProfilesCreateResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the update operation.
 */
export type ProfilesUpdateResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the generateSsoUri operation.
 */
export type ProfilesGenerateSsoUriResponse = SsoUri & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SsoUri;
    };
};

/**
 * Contains response data for the listSupportedOptimizationTypes operation.
 */
export type ProfilesListSupportedOptimizationTypesResponse = SupportedOptimizationTypesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SupportedOptimizationTypesListResult;
    };
};

/**
 * Contains response data for the listResourceUsage operation.
 */
export type ProfilesListResourceUsageResponse = ResourceUsageListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResourceUsageListResult;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type ProfilesBeginCreateResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type ProfilesBeginUpdateResponse = Profile & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Profile;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type ProfilesListNextResponse = ProfileListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ProfileListResult;
    };
};

/**
 * Contains response data for the listByResourceGroupNext operation.
 */
export type ProfilesListByResourceGroupNextResponse = ProfileListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ProfileListResult;
    };
};

/**
 * Contains response data for the listResourceUsageNext operation.
 */
export type ProfilesListResourceUsageNextResponse = ResourceUsageListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResourceUsageListResult;
    };
};

/**
 * Contains response data for the listByProfile operation.
 */
export type EndpointsListByProfileResponse = EndpointListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EndpointListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type EndpointsGetResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the create operation.
 */
export type EndpointsCreateResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the update operation.
 */
export type EndpointsUpdateResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the start operation.
 */
export type EndpointsStartResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the stop operation.
 */
export type EndpointsStopResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the validateCustomDomain operation.
 */
export type EndpointsValidateCustomDomainResponse = ValidateCustomDomainOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ValidateCustomDomainOutput;
    };
};

/**
 * Contains response data for the listResourceUsage operation.
 */
export type EndpointsListResourceUsageResponse = ResourceUsageListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResourceUsageListResult;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type EndpointsBeginCreateResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type EndpointsBeginUpdateResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the beginStart operation.
 */
export type EndpointsBeginStartResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the beginStop operation.
 */
export type EndpointsBeginStopResponse = Endpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Endpoint;
    };
};

/**
 * Contains response data for the listByProfileNext operation.
 */
export type EndpointsListByProfileNextResponse = EndpointListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EndpointListResult;
    };
};

/**
 * Contains response data for the listResourceUsageNext operation.
 */
export type EndpointsListResourceUsageNextResponse = ResourceUsageListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResourceUsageListResult;
    };
};

/**
 * Contains response data for the listByEndpoint operation.
 */
export type OriginsListByEndpointResponse = OriginListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type OriginsGetResponse = Origin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Origin;
    };
};

/**
 * Contains response data for the create operation.
 */
export type OriginsCreateResponse = Origin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Origin;
    };
};

/**
 * Contains response data for the update operation.
 */
export type OriginsUpdateResponse = Origin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Origin;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type OriginsBeginCreateResponse = Origin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Origin;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type OriginsBeginUpdateResponse = Origin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Origin;
    };
};

/**
 * Contains response data for the listByEndpointNext operation.
 */
export type OriginsListByEndpointNextResponse = OriginListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginListResult;
    };
};

/**
 * Contains response data for the listByEndpoint operation.
 */
export type OriginGroupsListByEndpointResponse = OriginGroupListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginGroupListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type OriginGroupsGetResponse = OriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginGroup;
    };
};

/**
 * Contains response data for the create operation.
 */
export type OriginGroupsCreateResponse = OriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginGroup;
    };
};

/**
 * Contains response data for the update operation.
 */
export type OriginGroupsUpdateResponse = OriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginGroup;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type OriginGroupsBeginCreateResponse = OriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginGroup;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type OriginGroupsBeginUpdateResponse = OriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginGroup;
    };
};

/**
 * Contains response data for the listByEndpointNext operation.
 */
export type OriginGroupsListByEndpointNextResponse = OriginGroupListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OriginGroupListResult;
    };
};

/**
 * Contains response data for the listByEndpoint operation.
 */
export type CustomDomainsListByEndpointResponse = CustomDomainListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomainListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type CustomDomainsGetResponse = CustomDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomain;
    };
};

/**
 * Contains response data for the create operation.
 */
export type CustomDomainsCreateResponse = CustomDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomain;
    };
};

/**
 * Contains response data for the deleteMethod operation.
 */
export type CustomDomainsDeleteMethodResponse = CustomDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomain;
    };
};

/**
 * Contains response data for the disableCustomHttps operation.
 */
export type CustomDomainsDisableCustomHttpsResponse = CustomDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomain;
    };
};

/**
 * Contains response data for the enableCustomHttps operation.
 */
export type CustomDomainsEnableCustomHttpsResponse = CustomDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomain;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type CustomDomainsBeginCreateResponse = CustomDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomain;
    };
};

/**
 * Contains response data for the beginDeleteMethod operation.
 */
export type CustomDomainsBeginDeleteMethodResponse = CustomDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomain;
    };
};

/**
 * Contains response data for the listByEndpointNext operation.
 */
export type CustomDomainsListByEndpointNextResponse = CustomDomainListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CustomDomainListResult;
    };
};

/**
 * Contains response data for the checkNameAvailability operation.
 */
export type CheckNameAvailabilityResponse = CheckNameAvailabilityOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CheckNameAvailabilityOutput;
    };
};

/**
 * Contains response data for the checkNameAvailabilityWithSubscription operation.
 */
export type CheckNameAvailabilityWithSubscriptionResponse = CheckNameAvailabilityOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CheckNameAvailabilityOutput;
    };
};

/**
 * Contains response data for the validateProbe operation.
 */
export type ValidateProbeResponse = ValidateProbeOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ValidateProbeOutput;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ResourceUsageListResponse = ResourceUsageListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResourceUsageListResult;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type ResourceUsageListNextResponse = ResourceUsageListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResourceUsageListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type OperationsListResponse = OperationsListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationsListResult;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type OperationsListNextResponse = OperationsListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationsListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type EdgeNodesListResponse = EdgenodeResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EdgenodeResult;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type EdgeNodesListNextResponse = EdgenodeResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EdgenodeResult;
    };
};

/**
 * Contains response data for the listResourceUsage operation.
 */
export type AFDProfilesListResourceUsageResponse = UsagesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UsagesListResult;
    };
};

/**
 * Contains response data for the checkHostNameAvailability operation.
 */
export type AFDProfilesCheckHostNameAvailabilityResponse = ValidateCustomDomainOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ValidateCustomDomainOutput;
    };
};

/**
 * Contains response data for the listResourceUsageNext operation.
 */
export type AFDProfilesListResourceUsageNextResponse = UsagesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UsagesListResult;
    };
};

/**
 * Contains response data for the listByProfile operation.
 */
export type AFDCustomDomainsListByProfileResponse = AFDDomainListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDDomainListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AFDCustomDomainsGetResponse = AFDDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDDomain;
    };
};

/**
 * Contains response data for the create operation.
 */
export type AFDCustomDomainsCreateResponse = AFDDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDDomain;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AFDCustomDomainsUpdateResponse = AFDDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDDomain;
    };
};

/**
 * Contains response data for the refreshValidationToken operation.
 */
export type AFDCustomDomainsRefreshValidationTokenResponse = ValidationToken & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ValidationToken;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type AFDCustomDomainsBeginCreateResponse = AFDDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDDomain;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type AFDCustomDomainsBeginUpdateResponse = AFDDomain & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDDomain;
    };
};

/**
 * Contains response data for the beginRefreshValidationToken operation.
 */
export type AFDCustomDomainsBeginRefreshValidationTokenResponse = ValidationToken & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ValidationToken;
    };
};

/**
 * Contains response data for the listByProfileNext operation.
 */
export type AFDCustomDomainsListByProfileNextResponse = AFDDomainListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDDomainListResult;
    };
};

/**
 * Contains response data for the listByProfile operation.
 */
export type AFDEndpointsListByProfileResponse = AFDEndpointListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDEndpointListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AFDEndpointsGetResponse = AFDEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDEndpoint;
    };
};

/**
 * Contains response data for the create operation.
 */
export type AFDEndpointsCreateResponse = AFDEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDEndpoint;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AFDEndpointsUpdateResponse = AFDEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDEndpoint;
    };
};

/**
 * Contains response data for the listResourceUsage operation.
 */
export type AFDEndpointsListResourceUsageResponse = UsagesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UsagesListResult;
    };
};

/**
 * Contains response data for the validateCustomDomain operation.
 */
export type AFDEndpointsValidateCustomDomainResponse = ValidateCustomDomainOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ValidateCustomDomainOutput;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type AFDEndpointsBeginCreateResponse = AFDEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDEndpoint;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type AFDEndpointsBeginUpdateResponse = AFDEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDEndpoint;
    };
};

/**
 * Contains response data for the listByProfileNext operation.
 */
export type AFDEndpointsListByProfileNextResponse = AFDEndpointListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDEndpointListResult;
    };
};

/**
 * Contains response data for the listResourceUsageNext operation.
 */
export type AFDEndpointsListResourceUsageNextResponse = UsagesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UsagesListResult;
    };
};

/**
 * Contains response data for the listByProfile operation.
 */
export type AFDOriginGroupsListByProfileResponse = AFDOriginGroupListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginGroupListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AFDOriginGroupsGetResponse = AFDOriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginGroup;
    };
};

/**
 * Contains response data for the create operation.
 */
export type AFDOriginGroupsCreateResponse = AFDOriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginGroup;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AFDOriginGroupsUpdateResponse = AFDOriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginGroup;
    };
};

/**
 * Contains response data for the listResourceUsage operation.
 */
export type AFDOriginGroupsListResourceUsageResponse = UsagesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UsagesListResult;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type AFDOriginGroupsBeginCreateResponse = AFDOriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginGroup;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type AFDOriginGroupsBeginUpdateResponse = AFDOriginGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginGroup;
    };
};

/**
 * Contains response data for the listByProfileNext operation.
 */
export type AFDOriginGroupsListByProfileNextResponse = AFDOriginGroupListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginGroupListResult;
    };
};

/**
 * Contains response data for the listResourceUsageNext operation.
 */
export type AFDOriginGroupsListResourceUsageNextResponse = UsagesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UsagesListResult;
    };
};

/**
 * Contains response data for the listByOriginGroup operation.
 */
export type AFDOriginsListByOriginGroupResponse = AFDOriginListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AFDOriginsGetResponse = AFDOrigin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOrigin;
    };
};

/**
 * Contains response data for the create operation.
 */
export type AFDOriginsCreateResponse = AFDOrigin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOrigin;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AFDOriginsUpdateResponse = AFDOrigin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOrigin;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type AFDOriginsBeginCreateResponse = AFDOrigin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOrigin;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type AFDOriginsBeginUpdateResponse = AFDOrigin & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOrigin;
    };
};

/**
 * Contains response data for the listByOriginGroupNext operation.
 */
export type AFDOriginsListByOriginGroupNextResponse = AFDOriginListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AFDOriginListResult;
    };
};

/**
 * Contains response data for the listByEndpoint operation.
 */
export type RoutesListByEndpointResponse = RouteListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RouteListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type RoutesGetResponse = Route & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Route;
    };
};

/**
 * Contains response data for the create operation.
 */
export type RoutesCreateResponse = Route & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Route;
    };
};

/**
 * Contains response data for the update operation.
 */
export type RoutesUpdateResponse = Route & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Route;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type RoutesBeginCreateResponse = Route & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Route;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type RoutesBeginUpdateResponse = Route & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Route;
    };
};

/**
 * Contains response data for the listByEndpointNext operation.
 */
export type RoutesListByEndpointNextResponse = RouteListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RouteListResult;
    };
};

/**
 * Contains response data for the listByProfile operation.
 */
export type RuleSetsListByProfileResponse = RuleSetListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RuleSetListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type RuleSetsGetResponse = RuleSet & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RuleSet;
    };
};

/**
 * Contains response data for the create operation.
 */
export type RuleSetsCreateResponse = RuleSet & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RuleSet;
    };
};

/**
 * Contains response data for the listResourceUsage operation.
 */
export type RuleSetsListResourceUsageResponse = UsagesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UsagesListResult;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type RuleSetsBeginCreateResponse = RuleSet & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RuleSet;
    };
};

/**
 * Contains response data for the listByProfileNext operation.
 */
export type RuleSetsListByProfileNextResponse = RuleSetListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RuleSetListResult;
    };
};

/**
 * Contains response data for the listResourceUsageNext operation.
 */
export type RuleSetsListResourceUsageNextResponse = UsagesListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UsagesListResult;
    };
};

/**
 * Contains response data for the listByRuleSet operation.
 */
export type RulesListByRuleSetResponse = RuleListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RuleListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type RulesGetResponse = Rule & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Rule;
    };
};

/**
 * Contains response data for the create operation.
 */
export type RulesCreateResponse = Rule & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Rule;
    };
};

/**
 * Contains response data for the update operation.
 */
export type RulesUpdateResponse = Rule & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Rule;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type RulesBeginCreateResponse = Rule & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Rule;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type RulesBeginUpdateResponse = Rule & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Rule;
    };
};

/**
 * Contains response data for the listByRuleSetNext operation.
 */
export type RulesListByRuleSetNextResponse = RuleListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RuleListResult;
    };
};

/**
 * Contains response data for the listByProfile operation.
 */
export type SecurityPoliciesListByProfileResponse = SecurityPolicyListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecurityPolicyListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type SecurityPoliciesGetResponse = SecurityPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecurityPolicy;
    };
};

/**
 * Contains response data for the create operation.
 */
export type SecurityPoliciesCreateResponse = SecurityPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecurityPolicy;
    };
};

/**
 * Contains response data for the patch operation.
 */
export type SecurityPoliciesPatchResponse = SecurityPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecurityPolicy;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type SecurityPoliciesBeginCreateResponse = SecurityPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecurityPolicy;
    };
};

/**
 * Contains response data for the beginPatch operation.
 */
export type SecurityPoliciesBeginPatchResponse = SecurityPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecurityPolicy;
    };
};

/**
 * Contains response data for the listByProfileNext operation.
 */
export type SecurityPoliciesListByProfileNextResponse = SecurityPolicyListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecurityPolicyListResult;
    };
};

/**
 * Contains response data for the listByProfile operation.
 */
export type SecretsListByProfileResponse = SecretListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecretListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type SecretsGetResponse = Secret & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Secret;
    };
};

/**
 * Contains response data for the create operation.
 */
export type SecretsCreateResponse = Secret & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Secret;
    };
};

/**
 * Contains response data for the update operation.
 */
export type SecretsUpdateResponse = Secret & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Secret;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type SecretsBeginCreateResponse = Secret & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Secret;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type SecretsBeginUpdateResponse = Secret & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Secret;
    };
};

/**
 * Contains response data for the listByProfileNext operation.
 */
export type SecretsListByProfileNextResponse = SecretListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecretListResult;
    };
};

/**
 * Contains response data for the secretMethod operation.
 */
export type ValidateSecretMethodResponse = ValidateSecretOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ValidateSecretOutput;
    };
};

/**
 * Contains response data for the getLogAnalyticsMetrics operation.
 */
export type LogAnalyticsGetLogAnalyticsMetricsResponse = MetricsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MetricsResponse;
    };
};

/**
 * Contains response data for the getLogAnalyticsRankings operation.
 */
export type LogAnalyticsGetLogAnalyticsRankingsResponse = RankingsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RankingsResponse;
    };
};

/**
 * Contains response data for the getLogAnalyticsLocations operation.
 */
export type LogAnalyticsGetLogAnalyticsLocationsResponse = ContinentsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContinentsResponse;
    };
};

/**
 * Contains response data for the getLogAnalyticsResources operation.
 */
export type LogAnalyticsGetLogAnalyticsResourcesResponse = ResourcesResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResourcesResponse;
    };
};

/**
 * Contains response data for the getWafLogAnalyticsMetrics operation.
 */
export type LogAnalyticsGetWafLogAnalyticsMetricsResponse = WafMetricsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: WafMetricsResponse;
    };
};

/**
 * Contains response data for the getWafLogAnalyticsRankings operation.
 */
export type LogAnalyticsGetWafLogAnalyticsRankingsResponse = WafRankingsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: WafRankingsResponse;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PoliciesListResponse = CdnWebApplicationFirewallPolicyList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CdnWebApplicationFirewallPolicyList;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PoliciesGetResponse = CdnWebApplicationFirewallPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CdnWebApplicationFirewallPolicy;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type PoliciesCreateOrUpdateResponse = CdnWebApplicationFirewallPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CdnWebApplicationFirewallPolicy;
    };
};

/**
 * Contains response data for the update operation.
 */
export type PoliciesUpdateResponse = CdnWebApplicationFirewallPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CdnWebApplicationFirewallPolicy;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type PoliciesBeginCreateOrUpdateResponse = CdnWebApplicationFirewallPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CdnWebApplicationFirewallPolicy;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type PoliciesBeginUpdateResponse = CdnWebApplicationFirewallPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CdnWebApplicationFirewallPolicy;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type PoliciesListNextResponse = CdnWebApplicationFirewallPolicyList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CdnWebApplicationFirewallPolicyList;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ManagedRuleSetsListResponse = ManagedRuleSetDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedRuleSetDefinitionList;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type ManagedRuleSetsListNextResponse = ManagedRuleSetDefinitionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedRuleSetDefinitionList;
    };
};
