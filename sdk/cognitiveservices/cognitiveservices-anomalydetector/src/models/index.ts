/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */


import * as msRest from "@azure/ms-rest-js";

/**
 * Error information returned by the API.
 */
export interface AnomalyDetectorError {
  /**
   * The error code.
   */
  code?: any;
  /**
   * A message explaining the error reported by the service.
   */
  message?: string;
}

/**
 * An interface representing TimeSeriesPoint.
 */
export interface TimeSeriesPoint {
  /**
   * Optional argument, timestamp of a data point (ISO8601 format).
   */
  timestamp?: Date;
  /**
   * The measurement of that point, should be float.
   */
  value: number;
}

/**
 * An interface representing DetectRequest.
 */
export interface DetectRequest {
  /**
   * Time series data points. Points should be sorted by timestamp in ascending order to match the
   * anomaly detection result. If the data is not sorted correctly or there is duplicated
   * timestamp, the API will not work. In such case, an error message will be returned.
   */
  series: TimeSeriesPoint[];
  /**
   * Possible values include: 'yearly', 'monthly', 'weekly', 'daily', 'hourly', 'perMinute',
   * 'perSecond', 'microsecond', 'none'
   */
  granularity?: TimeGranularity;
  /**
   * Custom Interval is used to set non-standard time interval, for example, if the series is 5
   * minutes, request can be set as {"granularity":"minutely", "customInterval":5}.
   */
  customInterval?: number;
  /**
   * Optional argument, periodic value of a time series. If the value is null or does not present,
   * the API will determine the period automatically.
   */
  period?: number;
  /**
   * Optional argument, advanced model parameter, max anomaly ratio in a time series.
   */
  maxAnomalyRatio?: number;
  /**
   * Optional argument, advanced model parameter, between 0-99, the lower the value is, the larger
   * the margin value will be which means less anomalies will be accepted.
   */
  sensitivity?: number;
}

/**
 * An interface representing EntireDetectResponse.
 */
export interface EntireDetectResponse {
  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   */
  period: number;
  /**
   * ExpectedValues contain expected value for each input point. The index of the array is
   * consistent with the input series.
   */
  expectedValues: number[];
  /**
   * UpperMargins contain upper margin of each input point. UpperMargin is used to calculate
   * upperBoundary, which equals to expectedValue + (100 - marginScale)*upperMargin. Anomalies in
   * response can be filtered by upperBoundary and lowerBoundary. By adjusting marginScale value,
   * less significant anomalies can be filtered in client side. The index of the array is
   * consistent with the input series.
   */
  upperMargins: number[];
  /**
   * LowerMargins contain lower margin of each input point. LowerMargin is used to calculate
   * lowerBoundary, which equals to expectedValue - (100 - marginScale)*lowerMargin. Points between
   * the boundary can be marked as normal ones in client side. The index of the array is consistent
   * with the input series.
   */
  lowerMargins: number[];
  /**
   * IsAnomaly contains anomaly properties for each input point. True means an anomaly either
   * negative or positive has been detected. The index of the array is consistent with the input
   * series.
   */
  isAnomaly: boolean[];
  /**
   * IsNegativeAnomaly contains anomaly status in negative direction for each input point. True
   * means a negative anomaly has been detected. A negative anomaly means the point is detected as
   * an anomaly and its real value is smaller than the expected one. The index of the array is
   * consistent with the input series.
   */
  isNegativeAnomaly: boolean[];
  /**
   * IsPositiveAnomaly contain anomaly status in positive direction for each input point. True
   * means a positive anomaly has been detected. A positive anomaly means the point is detected as
   * an anomaly and its real value is larger than the expected one. The index of the array is
   * consistent with the input series.
   */
  isPositiveAnomaly: boolean[];
}

/**
 * An interface representing LastDetectResponse.
 */
export interface LastDetectResponse {
  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   */
  period: number;
  /**
   * Suggested input series points needed for detecting the latest point.
   */
  suggestedWindow: number;
  /**
   * Expected value of the latest point.
   */
  expectedValue: number;
  /**
   * Upper margin of the latest point. UpperMargin is used to calculate upperBoundary, which equals
   * to expectedValue + (100 - marginScale)*upperMargin. If the value of latest point is between
   * upperBoundary and lowerBoundary, it should be treated as normal value. By adjusting
   * marginScale value, anomaly status of latest point can be changed.
   */
  upperMargin: number;
  /**
   * Lower margin of the latest point. LowerMargin is used to calculate lowerBoundary, which equals
   * to expectedValue - (100 - marginScale)*lowerMargin.
   */
  lowerMargin: number;
  /**
   * Anomaly status of the latest point, true means the latest point is an anomaly either in
   * negative direction or positive direction.
   */
  isAnomaly: boolean;
  /**
   * Anomaly status in negative direction of the latest point. True means the latest point is an
   * anomaly and its real value is smaller than the expected one.
   */
  isNegativeAnomaly: boolean;
  /**
   * Anomaly status in positive direction of the latest point. True means the latest point is an
   * anomaly and its real value is larger than the expected one.
   */
  isPositiveAnomaly: boolean;
}

/**
 * An interface representing ChangePointDetectRequest.
 */
export interface ChangePointDetectRequest {
  /**
   * Time series data points. Points should be sorted by timestamp in ascending order to match the
   * change point detection result.
   */
  series: TimeSeriesPoint[];
  /**
   * Can only be one of yearly, monthly, weekly, daily, hourly, minutely or secondly. Granularity
   * is used for verify whether input series is valid. Possible values include: 'yearly',
   * 'monthly', 'weekly', 'daily', 'hourly', 'perMinute', 'perSecond', 'microsecond', 'none'
   */
  granularity: TimeGranularity;
  /**
   * Custom Interval is used to set non-standard time interval, for example, if the series is 5
   * minutes, request can be set as {"granularity":"minutely", "customInterval":5}.
   */
  customInterval?: number;
  /**
   * Optional argument, periodic value of a time series. If the value is null or does not present,
   * the API will determine the period automatically.
   */
  period?: number;
  /**
   * Optional argument, advanced model parameter, a default stableTrendWindow will be used in
   * detection.
   */
  stableTrendWindow?: number;
  /**
   * Optional argument, advanced model parameter, between 0.0-1.0, the lower the value is, the
   * larger the trend error will be which means less change point will be accepted.
   */
  threshold?: number;
}

/**
 * An interface representing ChangePointDetectResponse.
 */
export interface ChangePointDetectResponse {
  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly period?: number;
  /**
   * isChangePoint contains change point properties for each input point. True means an anomaly
   * either negative or positive has been detected. The index of the array is consistent with the
   * input series.
   */
  isChangePoint?: boolean[];
  /**
   * the change point confidence of each point
   */
  confidenceScores?: number[];
}

/**
 * An interface representing AlignPolicy.
 */
export interface AlignPolicy {
  /**
   * An optional field, indicates how we align different variables into the same time-range which
   * is required by the model.{Inner, Outer}. Possible values include: 'Inner', 'Outer'
   */
  alignMode?: AlignMode;
  /**
   * An optional field, indicates how missed values will be filled with. Can not be set to NotFill,
   * when alignMode is Outer.{Previous, Subsequent, Linear, Zero, Fix, NotFill}. Possible values
   * include: 'Previous', 'Subsequent', 'Linear', 'Zero', 'Pad', 'NotFill'
   */
  fillNAMethod?: FillNAMethod;
  /**
   * optional field, only be useful if FillNAMethod is set to Pad.
   */
  paddingValue?: number;
}

/**
 * An interface representing ErrorResponse.
 */
export interface ErrorResponse {
  /**
   * The error Code
   */
  code: string;
  /**
   * A message explaining the error reported by the service.
   */
  message: string;
}

/**
 * An interface representing ModelState.
 */
export interface ModelState {
  /**
   * Epoch id
   */
  epochIds?: number[];
  trainLosses?: number[];
  validationLosses?: number[];
  latenciesInSeconds?: number[];
}

/**
 * An interface representing VariableState.
 */
export interface VariableState {
  /**
   * Variable name.
   */
  variable?: string;
  /**
   * Merged NA ratio of a variable.
   */
  filledNARatio?: number;
  /**
   * Effective time-series points count.
   */
  effectiveCount?: number;
  /**
   * Start time of a variable
   */
  startTime?: Date;
  /**
   * End time of a variable
   */
  endTime?: Date;
  /**
   * Error message when parse variable
   */
  errors?: ErrorResponse[];
}

/**
 * An interface representing DiagnosticsInfo.
 */
export interface DiagnosticsInfo {
  modelState?: ModelState;
  variableStates?: VariableState[];
}

/**
 * Train result of a model including status, errors and diagnose info for model and variables.
 */
export interface ModelInfo {
  /**
   * An optional field, indicates how many history points will be used to determine the anomaly
   * score of one subsequent point.
   */
  slidingWindow?: number;
  /**
   * An optional field, since those multivariate need to be aligned in the same timestamp before
   * starting the detection.
   */
  alignPolicy?: AlignPolicy;
  /**
   * source file link of the input variables, each variable will be a csv with two columns, the
   * first column will be timestamp, the second column will be value.Besides these variable csv
   * files, an extra meta.json can be included in th zip file if you would like to rename a
   * variable.Be default, the file name of the variable will be used as the variable name.
   */
  source: string;
  /**
   * require field, start time of data be used for generating multivariate anomaly detection model,
   * should be data-time
   */
  startTime: Date;
  /**
   * require field, end time of data be used for generating multivariate anomaly detection model,
   * should be data-time
   */
  endTime: Date;
  /**
   * optional field, name of the model
   */
  displayName?: string;
  /**
   * Possible values include: 'CREATED', 'RUNNING', 'READY', 'FAILED'
   */
  status?: ModelStatus;
  /**
   * Error message when fails to create a model.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly errors?: ErrorResponse[];
  /**
   * Used for deep analysis model and variables
   */
  diagnosticsInfo?: DiagnosticsInfo;
}

/**
 * Response of get model.
 */
export interface Model {
  /**
   * Model identifier.
   */
  modelId: string;
  /**
   * Date and time (UTC) when the model was created.
   */
  createdTime: Date;
  /**
   * Date and time (UTC) when the model was last updated.
   */
  lastUpdatedTime: Date;
  /**
   * Training Status of the model.
   */
  modelInfo?: ModelInfo;
}

/**
 * An interface representing ModelSnapshot.
 */
export interface ModelSnapshot {
  /**
   * Model identifier.
   */
  modelId: string;
  /**
   * Date and time (UTC) when the model was created.
   */
  createdTime: Date;
  /**
   * Date and time (UTC) when the model was last updated.
   */
  lastUpdatedTime: Date;
  /**
   * Possible values include: 'CREATED', 'RUNNING', 'READY', 'FAILED'
   */
  status: ModelStatus;
  displayName?: string;
  /**
   * Count of variables
   */
  variablesCount: number;
}

/**
 * Response to the list models operation.
 */
export interface ModelList {
  /**
   * List of models
   */
  modelsProperty: ModelSnapshot[];
  /**
   * Current count of trained multivariate models.
   */
  currentCount: number;
  /**
   * Max number of models that can be trained for this subscription.
   */
  maxCount: number;
  /**
   * next link to fetch more models
   */
  nextLink?: string;
}

/**
 * Request to submit a detection.
 */
export interface DetectionRequest {
  /**
   * source file link of the input variables, each variable will be a csv with two columns, the
   * first column will be timestamp, the second column will be value.Besides these variable csv
   * files, a extra meta.json can be included in th zip file if you would like to rename a
   * variable.Be default, the file name of the variable will be used as the variable name. The
   * variables used in detection should be consistent with variables in the model used for
   * detection.
   */
  source: string;
  /**
   * A require field, start time of data be used for detection, should be date-time.
   */
  startTime: Date;
  /**
   * A require field, end time of data be used for detection, should be date-time.
   */
  endTime: Date;
}

/**
 * An interface representing DetectionResultSummary.
 */
export interface DetectionResultSummary {
  /**
   * Multivariate anomaly detection status. Possible values include: 'CREATED', 'RUNNING', 'READY',
   * 'FAILED'
   */
  status: DetectionStatus;
  /**
   * Error message when creating or training model fails.
   */
  errors?: ErrorResponse[];
  variableStates?: VariableState[];
  /**
   * Request when creating the model.
   */
  setupInfo: DetectionRequest;
}

/**
 * An interface representing AnomalyContributor.
 */
export interface AnomalyContributor {
  /**
   * The higher the contribution score is, the more likely the variable to be the root cause of a
   * anomaly.
   */
  contributionScore?: number;
  /**
   * Variable name of a contributor
   */
  variable?: string;
}

/**
 * An interface representing AnomalyValue.
 */
export interface AnomalyValue {
  /**
   * If current timestamp is an anomaly, contributors will show potential root cause for thus
   * anomaly. Contributors can help us understand why current timestamp has been detected as an
   * anomaly.
   */
  contributors?: AnomalyContributor[];
  /**
   * To indicate whether current timestamp is anomaly or not
   */
  isAnomaly: boolean;
  /**
   * anomaly score of the current timestamp, the more significant an anomaly is, the higher the
   * score will be
   */
  severity: number;
  /**
   * anomaly score of the current timestamp, the more significant an anomaly is, the higher the
   * score will be, score measures global significance
   */
  score?: number;
}

/**
 * An interface representing AnomalyState.
 */
export interface AnomalyState {
  /**
   * timestamp
   */
  timestamp: Date;
  value?: AnomalyValue;
  /**
   * Error message when inference this timestamp
   */
  errors?: ErrorResponse[];
}

/**
 * Anomaly Response of one detection corresponds to a resultId.
 */
export interface DetectionResult {
  resultId: string;
  /**
   * Multivariate anomaly detection status
   */
  summary: DetectionResultSummary;
  /**
   * anomaly status of each timestamp
   */
  results: AnomalyState[];
}

/**
 * Optional Parameters.
 */
export interface AnomalyDetectorClientListMultivariateModelOptionalParams extends msRest.RequestOptionsBase {
  /**
   * $skip indicates how many models will be skipped. Default value: 0.
   */
  skip?: number;
  /**
   * $top indicates how many models will be fetched. Default value: 5.
   */
  top?: number;
}

/**
 * Defines headers for TrainMultivariateModel operation.
 */
export interface TrainMultivariateModelHeaders {
  /**
   * Location and ID of the model being saved.
   */
  location: string;
}

/**
 * Defines headers for DetectAnomaly operation.
 */
export interface DetectAnomalyHeaders {
  /**
   * Location and ID of the detection result being saved.
   */
  location: string;
}

/**
 * Defines headers for ExportModel operation.
 */
export interface ExportModelHeaders {
  /**
   * application/zip
   */
  contentType: string;
}

/**
 * Defines values for TimeGranularity.
 * Possible values include: 'yearly', 'monthly', 'weekly', 'daily', 'hourly', 'perMinute',
 * 'perSecond', 'microsecond', 'none'
 * @readonly
 * @enum {string}
 */
export type TimeGranularity = 'yearly' | 'monthly' | 'weekly' | 'daily' | 'hourly' | 'minutely' | 'secondly' | 'microsecond' | 'none';

/**
 * Defines values for AlignMode.
 * Possible values include: 'Inner', 'Outer'
 * @readonly
 * @enum {string}
 */
export type AlignMode = 'Inner' | 'Outer';

/**
 * Defines values for FillNAMethod.
 * Possible values include: 'Previous', 'Subsequent', 'Linear', 'Zero', 'Pad', 'NotFill'
 * @readonly
 * @enum {string}
 */
export type FillNAMethod = 'Previous' | 'Subsequent' | 'Linear' | 'Zero' | 'Pad' | 'NotFill';

/**
 * Defines values for ModelStatus.
 * Possible values include: 'CREATED', 'RUNNING', 'READY', 'FAILED'
 * @readonly
 * @enum {string}
 */
export type ModelStatus = 'CREATED' | 'RUNNING' | 'READY' | 'FAILED';

/**
 * Defines values for DetectionStatus.
 * Possible values include: 'CREATED', 'RUNNING', 'READY', 'FAILED'
 * @readonly
 * @enum {string}
 */
export type DetectionStatus = 'CREATED' | 'RUNNING' | 'READY' | 'FAILED';

/**
 * Contains response data for the detectEntireSeries operation.
 */
export type DetectEntireSeriesResponse = EntireDetectResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EntireDetectResponse;
    };
};

/**
 * Contains response data for the detectLastPoint operation.
 */
export type DetectLastPointResponse = LastDetectResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LastDetectResponse;
    };
};

/**
 * Contains response data for the detectChangePoint operation.
 */
export type DetectChangePointResponse = ChangePointDetectResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ChangePointDetectResponse;
    };
};

/**
 * Contains response data for the trainMultivariateModel operation.
 */
export type TrainMultivariateModelResponse = TrainMultivariateModelHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: TrainMultivariateModelHeaders;
    };
};

/**
 * Contains response data for the getMultivariateModel operation.
 */
export type GetMultivariateModelResponse = Model & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Model;
    };
};

/**
 * Contains response data for the detectAnomaly operation.
 */
export type DetectAnomalyResponse = DetectAnomalyHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: DetectAnomalyHeaders;
    };
};

/**
 * Contains response data for the getDetectionResult operation.
 */
export type GetDetectionResultResponse = DetectionResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DetectionResult;
    };
};

/**
 * Contains response data for the exportModel operation.
 */
export type ExportModelResponse = ExportModelHeaders & {
  /**
   * BROWSER ONLY
   *
   * The response body as a browser Blob.
   * Always undefined in node.js.
   */
  blobBody?: Promise<Blob>;

  /**
   * NODEJS ONLY
   *
   * The response body as a node.js Readable stream.
   * Always undefined in the browser.
   */
  readableStreamBody?: NodeJS.ReadableStream;

  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: ExportModelHeaders;
    };
};

/**
 * Contains response data for the listMultivariateModel operation.
 */
export type ListMultivariateModelResponse = ModelList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ModelList;
    };
};
