/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */


import * as msRest from "@azure/ms-rest-js";

/**
 * Error information returned by the API.
 */
export interface APIError {
  /**
   * The error code.
   */
  code?: any;
  /**
   * A message explaining the error reported by the service.
   */
  message?: string;
}

/**
 * An interface representing Point.
 */
export interface Point {
  /**
   * Timestamp of a data point (ISO8601 format).
   */
  timestamp: Date;
  /**
   * The measurement of that point, should be float.
   */
  value: number;
}

/**
 * An interface representing Request.
 */
export interface Request {
  /**
   * Time series data points. Points should be sorted by timestamp in ascending order to match the
   * anomaly detection result. If the data is not sorted correctly or there is duplicated
   * timestamp, the API will not work. In such case, an error message will be returned.
   */
  series: Point[];
  /**
   * Possible values include: 'yearly', 'monthly', 'weekly', 'daily', 'hourly', 'minutely'
   */
  granularity: Granularity;
  /**
   * Custom Interval is used to set non-standard time interval, for example, if the series is 5
   * minutes, request can be set as {"granularity":"minutely", "customInterval":5}.
   */
  customInterval?: number;
  /**
   * Optional argument, periodic value of a time series. If the value is null or does not present,
   * the API will determine the period automatically.
   */
  period?: number;
  /**
   * Optional argument, advanced model parameter, max anomaly ratio in a time series.
   */
  maxAnomalyRatio?: number;
  /**
   * Optional argument, advanced model parameter, between 0-99, the lower the value is, the larger
   * the margin value will be which means less anomalies will be accepted.
   */
  sensitivity?: number;
}

/**
 * An interface representing EntireDetectResponse.
 */
export interface EntireDetectResponse {
  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   */
  period: number;
  /**
   * ExpectedValues contain expected value for each input point. The index of the array is
   * consistent with the input series.
   */
  expectedValues: number[];
  /**
   * UpperMargins contain upper margin of each input point. UpperMargin is used to calculate
   * upperBoundary, which equals to expectedValue + (100 - marginScale)*upperMargin. Anomalies in
   * response can be filtered by upperBoundary and lowerBoundary. By adjusting marginScale value,
   * less significant anomalies can be filtered in client side. The index of the array is
   * consistent with the input series.
   */
  upperMargins: number[];
  /**
   * LowerMargins contain lower margin of each input point. LowerMargin is used to calculate
   * lowerBoundary, which equals to expectedValue - (100 - marginScale)*lowerMargin. Points between
   * the boundary can be marked as normal ones in client side. The index of the array is consistent
   * with the input series.
   */
  lowerMargins: number[];
  /**
   * IsAnomaly contains anomaly properties for each input point. True means an anomaly either
   * negative or positive has been detected. The index of the array is consistent with the input
   * series.
   */
  isAnomaly: boolean[];
  /**
   * IsNegativeAnomaly contains anomaly status in negative direction for each input point. True
   * means a negative anomaly has been detected. A negative anomaly means the point is detected as
   * an anomaly and its real value is smaller than the expected one. The index of the array is
   * consistent with the input series.
   */
  isNegativeAnomaly: boolean[];
  /**
   * IsPositiveAnomaly contain anomaly status in positive direction for each input point. True
   * means a positive anomaly has been detected. A positive anomaly means the point is detected as
   * an anomaly and its real value is larger than the expected one. The index of the array is
   * consistent with the input series.
   */
  isPositiveAnomaly: boolean[];
}

/**
 * An interface representing LastDetectResponse.
 */
export interface LastDetectResponse {
  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   */
  period: number;
  /**
   * Suggested input series points needed for detecting the latest point.
   */
  suggestedWindow: number;
  /**
   * Expected value of the latest point.
   */
  expectedValue: number;
  /**
   * Upper margin of the latest point. UpperMargin is used to calculate upperBoundary, which equals
   * to expectedValue + (100 - marginScale)*upperMargin. If the value of latest point is between
   * upperBoundary and lowerBoundary, it should be treated as normal value. By adjusting
   * marginScale value, anomaly status of latest point can be changed.
   */
  upperMargin: number;
  /**
   * Lower margin of the latest point. LowerMargin is used to calculate lowerBoundary, which equals
   * to expectedValue - (100 - marginScale)*lowerMargin.
   */
  lowerMargin: number;
  /**
   * Anomaly status of the latest point, true means the latest point is an anomaly either in
   * negative direction or positive direction.
   */
  isAnomaly: boolean;
  /**
   * Anomaly status in negative direction of the latest point. True means the latest point is an
   * anomaly and its real value is smaller than the expected one.
   */
  isNegativeAnomaly: boolean;
  /**
   * Anomaly status in positive direction of the latest point. True means the latest point is an
   * anomaly and its real value is larger than the expected one.
   */
  isPositiveAnomaly: boolean;
}

/**
 * An interface representing TimeSeries.
 */
export interface TimeSeries {
  /**
   * Unique id for time series.
   */
  seriesId: string;
  /**
   * Can only be one of yearly, monthly, weekly, daily, hourly or minutely. Granularity is used for
   * verify whether input series is valid. Possible values include: 'yearly', 'monthly', 'weekly',
   * 'daily', 'hourly', 'minutely'
   */
  granularity: Granularity;
  /**
   * Property of a time series
   */
  dimensions?: { [propertyName: string]: string };
  /**
   * Custom Interval is used to set non-standard time interval, for example, if the series is 5
   * minutes, request can be set as {"granularity":"minutely", "customInterval":5}.
   */
  customInterval?: number;
  /**
   * Hours that the data is kept.
   */
  retentionDurationInHours?: number;
  /**
   * Description for the time series.
   */
  description?: string;
  /**
   * Name of the time series.
   */
  name?: string;
}

/**
 * An interface representing TimeSeriesCreateRequest.
 */
export interface TimeSeriesCreateRequest {
  /**
   * Can only be one of yearly, monthly, weekly, daily, hourly or minutely. Granularity is used for
   * verify whether input series is valid. Possible values include: 'yearly', 'monthly', 'weekly',
   * 'daily', 'hourly', 'minutely'
   */
  granularity: Granularity;
  /**
   * Property of a time series
   */
  dimensions?: { [propertyName: string]: string };
  /**
   * Custom Interval is used to set non-standard time interval, for example, if the series is 5
   * minutes, request can be set as {"granularity":"minutely", "customInterval":5}.
   */
  customInterval?: number;
  /**
   * Hours that the data is kept.
   */
  retentionDurationInHours?: number;
  /**
   * Description for the time series.
   */
  description?: string;
  /**
   * Name of the time series.
   */
  name?: string;
}

/**
 * An interface representing TimeSeriesList.
 */
export interface TimeSeriesList {
  /**
   * Array of TimeSeries objects.
   */
  series: TimeSeries[];
  next?: string;
}

/**
 * An interface representing TimeSeriesGroup.
 */
export interface TimeSeriesGroup {
  /**
   * Unique id for time series group.
   */
  groupId: string;
  /**
   * Description of the time series group
   */
  description?: string;
  /**
   * Name of the time series group
   */
  name?: string;
  /**
   * Can only be one of yearly, monthly, weekly, daily, hourly or minutely. Granularity is used for
   * verify whether input series is valid. Possible values include: 'yearly', 'monthly', 'weekly',
   * 'daily', 'hourly', 'minutely'
   */
  granularity: Granularity;
  /**
   * Custom Interval is used to set non-standard time interval, for example, if the series is 5
   * minutes, request can be set as {"granularity":"minutely", "customInterval":5}.
   */
  customInterval?: number;
}

/**
 * An interface representing TimeSeriesGroupCreateRequest.
 */
export interface TimeSeriesGroupCreateRequest {
  /**
   * Description of the time series group
   */
  description?: string;
  /**
   * Name of the time series group
   */
  name?: string;
  /**
   * Can only be one of yearly, monthly, weekly, daily, hourly or minutely. Granularity is used for
   * verify whether input series is valid. Possible values include: 'yearly', 'monthly', 'weekly',
   * 'daily', 'hourly', 'minutely'
   */
  granularity: Granularity;
  /**
   * Custom Interval is used to set non-standard time interval, for example, if the series is 5
   * minutes, request can be set as {"granularity":"minutely", "customInterval":5}.
   */
  customInterval?: number;
}

/**
 * An interface representing TimeSeriesGroupList.
 */
export interface TimeSeriesGroupList {
  /**
   * A list of TimeSeriesGroup.
   */
  groups: TimeSeriesGroup[];
  next?: string;
}

/**
 * An interface representing InconsistencyDetectRequest.
 */
export interface InconsistencyDetectRequest {
  /**
   * Inconsistency detect timestamp.
   */
  timestamp: Date;
  /**
   * Parameter to be tuned to get inconsistency.
   */
  epsilon?: number;
}

/**
 * An interface representing Inconsistency.
 */
export interface Inconsistency {
  /**
   * IDs of inconsistent series in the time series group.
   */
  inconsistentSeriesIds: string[];
  /**
   * Scores of inconsistent series in the time series group.
   */
  confidenceScores: number[];
  /**
   * Inconsistency detect timestamp.
   */
  timestamp?: Date;
  /**
   * Parameter to be tuned to get inconsistency.
   */
  epsilon?: number;
}

/**
 * An interface representing InconsistencyQueryRequest.
 */
export interface InconsistencyQueryRequest {
  /**
   * Start time of the time series group.
   */
  begin: Date;
  /**
   * End time of the time series group.
   */
  end: Date;
}

/**
 * An interface representing ChangePointDetectRequest.
 */
export interface ChangePointDetectRequest {
  /**
   * Time series data points. Points should be sorted by timestamp in ascending order to match the
   * change point detection result.
   */
  series: Point[];
  /**
   * Can only be one of yearly, monthly, weekly, daily, hourly or minutely. Granularity is used for
   * verify whether input series is valid. Possible values include: 'yearly', 'monthly', 'weekly',
   * 'daily', 'hourly', 'minutely'
   */
  granularity: Granularity;
  /**
   * Custom Interval is used to set non-standard time interval, for example, if the series is 5
   * minutes, request can be set as {"granularity":"minutely", "customInterval":5}.
   */
  customInterval?: number;
  /**
   * Optional argument, periodic value of a time series. If the value is null or does not present,
   * the API will determine the period automatically.
   */
  period?: number;
  /**
   * Optional argument, advanced model parameter, a default stableTrendWindow will be used in
   * detection.
   */
  stableTrendWindow?: number;
  /**
   * Optional argument, advanced model parameter, between 0.0-1.0, the lower the value is, the
   * larger the trend error will be which means less change point will be accepted.
   */
  threshold?: number;
}

/**
 * An interface representing ChangePointDetectResponse.
 */
export interface ChangePointDetectResponse {
  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   */
  period: number;
  /**
   * isChangePoint contains change point properties for each input point. True means an anomaly
   * either negative or positive has been detected. The index of the array is consistent with the
   * input series.
   */
  isChangePoint: boolean[];
  /**
   * the change point confidence of each point
   */
  confidenceScores: number[];
}

/**
 * An interface representing ChangePointDetectOnTimestampRequest.
 */
export interface ChangePointDetectOnTimestampRequest {
  /**
   * The timestamp of a data point.
   */
  timestamp?: Date;
  /**
   * Optional argument, periodic value of a time series. If the value is null or does not present,
   * the API will determine the period automatically.
   */
  period?: number;
  /**
   * Optional argument, advanced model parameter, a default stableTrendWindow will be used in
   * detection.
   */
  stableTrendWindow?: number;
  /**
   * Optional argument, advanced model parameter, between 0.0-1.0, the lower the value is, the
   * larger the trend error will be which means less change point will be accepted.
   */
  threshold?: number;
}

/**
 * An interface representing ChangePointDetectOnTimestampResponse.
 */
export interface ChangePointDetectOnTimestampResponse {
  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   */
  period: number;
  /**
   * Change point property. True means a change point has been detected.
   */
  isChangePoint: boolean;
  /**
   * The change point confidence score.
   */
  confidenceScore: number;
  /**
   * Timestamp of a data point (ISO8601 format).
   */
  timestamp: Date;
}

/**
 * An interface representing TimeSeriesQueryRequest.
 */
export interface TimeSeriesQueryRequest {
  /**
   * Timestamp of begin time (ISO8601 format).
   */
  begin: Date;
  /**
   * Timestamp of end time (ISO8601 format).
   */
  end: Date;
  /**
   * Array of timeseries field.
   */
  fields: TimeSeriesField[];
}

/**
 * An interface representing TimeSeriesQueryResponse.
 */
export interface TimeSeriesQueryResponse {
  /**
   * Timestamps of data points (ISO8601 format).
   */
  timestamps: Date[] | string[];
  /**
   * Values of queried timeseries field.
   */
  fieldValues: any[][];
}

/**
 * An interface representing AnomalyDetectOnTimestampRequest.
 */
export interface AnomalyDetectOnTimestampRequest {
  /**
   * Timestamp of a data point
   */
  timestamp: Date;
  /**
   * Optional argument, periodic value of a time series. If the value is null or does not present,
   * the API will determine the period automatically.
   */
  period?: number;
  /**
   * Optional argument, advanced model parameter, max anomaly ratio in a time series.
   */
  maxAnomalyRatio?: number;
  /**
   * Optional argument, advanced model parameter, between 0-99, the lower the value is, the larger
   * the margin value will be which means less anomalies will be accepted.
   */
  sensitivity?: number;
}

/**
 * An interface representing AnomalyDetectOnTimestampResponse.
 */
export interface AnomalyDetectOnTimestampResponse {
  /**
   * Frequency extracted from the series, zero means no recurrent pattern has been found.
   */
  period: number;
  /**
   * Timestamp of a point.
   */
  timestamp: Date;
  /**
   * Value of a point.
   */
  value: number;
  /**
   * ExpectedValue of a point on the timestamp.
   */
  expectedValue: number;
  /**
   * UpperMargin of a point on the timestamp. UpperMargin is used to calculate upperBoundary, which
   * equals to expectedValue + (100 - marginScale)*upperMargin. Anomalies in response can be
   * filtered by upperBoundary and lowerBoundary. By adjusting marginScale value, less significant
   * anomalies can be filtered in client side.
   */
  upperMargin: number;
  /**
   * LowerMargin of a point on the timestamp. LowerMargin is used to calculate lowerBoundary, which
   * equals to expectedValue - (100 - marginScale)*lowerMargin. Points between the boundary can be
   * marked as normal ones in client side.
   */
  lowerMargin: number;
  /**
   * Anomaly property of a point on the timestamp. True means an anomaly either negative or
   * positive has been detected.
   */
  isAnomaly: boolean;
  /**
   * Anomaly status in negative direction on the timestamp. True means a negative anomaly has been
   * detected. A negative anomaly means the point is detected as an anomaly and its real value is
   * smaller than the expected one.
   */
  isNegativeAnomaly: boolean;
  /**
   * Anomaly status in positive direction on the timestamp. True means a positive anomaly has been
   * detected. A positive anomaly means the point is detected as an anomaly and its real value is
   * larger than the expected one.
   */
  isPositiveAnomaly: boolean;
}

/**
 * An interface representing LabelRequest.
 */
export interface LabelRequest {
  /**
   * begin of a detection time range
   */
  begin: Date;
  /**
   * end of a detection time range
   */
  end: Date;
  /**
   * Possible values include: 'changePoint', 'anomaly'
   */
  type: LabelType;
  /**
   * Possible values include: 'true', 'false'
   */
  value: LabelValue;
}

/**
 * Optional Parameters.
 */
export interface TimeSeriesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Use "next" as query parameter to get next page data.
   */
  next?: string;
}

/**
 * Optional Parameters.
 */
export interface TimeSeriesListGroupsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Use "next" as query parameter to get next page data.
   */
  next?: string;
}

/**
 * Optional Parameters.
 */
export interface TimeSeriesGroupListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Use "next" as query parameter to get next page data.
   */
  next?: string;
}

/**
 * Optional Parameters.
 */
export interface TimeSeriesGroupListSeriesOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Use "next" as query parameter to get next page data.
   */
  next?: string;
}

/**
 * Defines values for Granularity.
 * Possible values include: 'yearly', 'monthly', 'weekly', 'daily', 'hourly', 'minutely'
 * @readonly
 * @enum {string}
 */
export type Granularity = 'yearly' | 'monthly' | 'weekly' | 'daily' | 'hourly' | 'minutely';

/**
 * Defines values for TimeSeriesField.
 * Possible values include: 'isAnomaly', 'isChangePoint', 'isPositiveAnomaly', 'isNegativeAnomaly',
 * 'value', 'expectedValue', 'upperMargin', 'lowerMargin', 'period'
 * @readonly
 * @enum {string}
 */
export type TimeSeriesField = 'isAnomaly' | 'isChangePoint' | 'isPositiveAnomaly' | 'isNegativeAnomaly' | 'value' | 'expectedValue' | 'upperMargin' | 'lowerMargin' | 'period';

/**
 * Defines values for LabelType.
 * Possible values include: 'changePoint', 'anomaly'
 * @readonly
 * @enum {string}
 */
export type LabelType = 'changePoint' | 'anomaly';

/**
 * Defines values for LabelValue.
 * Possible values include: 'true', 'false'
 * @readonly
 * @enum {string}
 */
export type LabelValue = 'true' | 'false';

/**
 * Contains response data for the entireDetect operation.
 */
export type EntireDetectResponse2 = EntireDetectResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EntireDetectResponse;
    };
};

/**
 * Contains response data for the lastDetect operation.
 */
export type LastDetectResponse2 = LastDetectResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LastDetectResponse;
    };
};

/**
 * Contains response data for the changePointDetect operation.
 */
export type ChangePointDetectResponse2 = ChangePointDetectResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ChangePointDetectResponse;
    };
};

/**
 * Contains response data for the get operation.
 */
export type TimeSeriesGetResponse = TimeSeries & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TimeSeries;
    };
};

/**
 * Contains response data for the list operation.
 */
export type TimeSeriesListResponse = TimeSeriesList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TimeSeriesList;
    };
};

/**
 * Contains response data for the detectOnTimestamp operation.
 */
export type TimeSeriesDetectOnTimestampResponse = AnomalyDetectOnTimestampResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AnomalyDetectOnTimestampResponse;
    };
};

/**
 * Contains response data for the changePointDetectOnTimestamp operation.
 */
export type TimeSeriesChangePointDetectOnTimestampResponse = ChangePointDetectOnTimestampResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ChangePointDetectOnTimestampResponse;
    };
};

/**
 * Contains response data for the query operation.
 */
export type TimeSeriesQueryResponse2 = TimeSeriesQueryResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TimeSeriesQueryResponse;
    };
};

/**
 * Contains response data for the listGroups operation.
 */
export type TimeSeriesListGroupsResponse = TimeSeriesGroupList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TimeSeriesGroupList;
    };
};

/**
 * Contains response data for the get operation.
 */
export type TimeSeriesGroupGetResponse = TimeSeriesGroup & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TimeSeriesGroup;
    };
};

/**
 * Contains response data for the list operation.
 */
export type TimeSeriesGroupListResponse = TimeSeriesGroupList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TimeSeriesGroupList;
    };
};

/**
 * Contains response data for the inconsistencyDetect operation.
 */
export type TimeSeriesGroupInconsistencyDetectResponse = Inconsistency & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Inconsistency;
    };
};

/**
 * Contains response data for the inconsistencyQuery operation.
 */
export type TimeSeriesGroupInconsistencyQueryResponse = Array<Inconsistency> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Inconsistency[];
    };
};

/**
 * Contains response data for the listSeries operation.
 */
export type TimeSeriesGroupListSeriesResponse = TimeSeriesList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TimeSeriesList;
    };
};
