/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";
import * as coreAuth from "@azure/core-auth";
import { PagedAsyncIterableIterator } from "@azure/core-paging";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
import {
  AnomalyDetectorClientOptionalParams,
  ModelSnapshot,
  ListMultivariateModelNextOptionalParams,
  ListMultivariateModelOptionalParams,
  DetectRequest,
  DetectEntireSeriesOptionalParams,
  DetectEntireSeriesResponse,
  DetectLastPointOptionalParams,
  DetectLastPointResponse,
  ChangePointDetectRequest,
  DetectChangePointOptionalParams,
  DetectChangePointResponse,
  ModelInfo,
  TrainMultivariateModelOptionalParams,
  TrainMultivariateModelResponse,
  ListMultivariateModelResponse,
  GetMultivariateModelOptionalParams,
  GetMultivariateModelResponse,
  DeleteMultivariateModelOptionalParams,
  DetectionRequest,
  DetectAnomalyOptionalParams,
  DetectAnomalyResponse,
  GetDetectionResultOptionalParams,
  GetDetectionResultResponse,
  ExportModelOptionalParams,
  ExportModelResponse,
  LastDetectionRequest,
  LastDetectAnomalyOptionalParams,
  LastDetectAnomalyResponse,
  ListMultivariateModelNextResponse
} from "./models";

/// <reference lib="esnext.asynciterable" />
export class AnomalyDetectorClient extends coreClient.ServiceClient {
  endpoint: string;
  apiVersion: string;

  /**
   * Initializes a new instance of the AnomalyDetectorClient class.
   * @param credentials Subscription credentials which uniquely identify client subscription.
   * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
   *                 https://westus2.api.cognitive.microsoft.com).
   * @param options The parameter options
   */
  constructor(
    credentials: coreAuth.TokenCredential,
    endpoint: string,
    options?: AnomalyDetectorClientOptionalParams
  ) {
    if (credentials === undefined) {
      throw new Error("'credentials' cannot be null");
    }
    if (endpoint === undefined) {
      throw new Error("'endpoint' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults: AnomalyDetectorClientOptionalParams = {
      requestContentType: "application/json; charset=utf-8",
      credential: credentials
    };

    const packageDetails = `azsdk-js-cognitiveservices-anomalydetector/1.0.0-beta.1`;
    const userAgentPrefix =
      options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
        : `${packageDetails}`;

    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      baseUri: options.endpoint || "{Endpoint}/anomalydetector/{ApiVersion}"
    };
    super(optionsWithDefaults);
    // Parameter assignments
    this.endpoint = endpoint;

    // Assigning values to Constant parameters
    this.apiVersion = options.apiVersion || "v1.1-preview.1";
  }

  /**
   * List models of a subscription
   * @param options The options parameters.
   */
  public listMultivariateModel(
    options?: ListMultivariateModelOptionalParams
  ): PagedAsyncIterableIterator<ModelSnapshot> {
    const iter = this.listMultivariateModelPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listMultivariateModelPagingPage(options);
      }
    };
  }

  private async *listMultivariateModelPagingPage(
    options?: ListMultivariateModelOptionalParams
  ): AsyncIterableIterator<ModelSnapshot[]> {
    let result = await this._listMultivariateModel(options);
    yield result.models || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listMultivariateModelNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.models || [];
    }
  }

  private async *listMultivariateModelPagingAll(
    options?: ListMultivariateModelOptionalParams
  ): AsyncIterableIterator<ModelSnapshot> {
    for await (const page of this.listMultivariateModelPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * This operation generates a model with an entire series, each point is detected with the same model.
   * With this method, points before and after a certain point are used to determine whether it is an
   * anomaly. The entire detection can give user an overall status of the time series.
   * @param body Time series points and period if needed. Advanced model parameters can also be set in
   *             the request.
   * @param options The options parameters.
   */
  detectEntireSeries(
    body: DetectRequest,
    options?: DetectEntireSeriesOptionalParams
  ): Promise<DetectEntireSeriesResponse> {
    return this.sendOperationRequest(
      { body, options },
      detectEntireSeriesOperationSpec
    );
  }

  /**
   * This operation generates a model using points before the latest one. With this method, only
   * historical points are used to determine whether the target point is an anomaly. The latest point
   * detecting operation matches the scenario of real-time monitoring of business metrics.
   * @param body Time series points and period if needed. Advanced model parameters can also be set in
   *             the request.
   * @param options The options parameters.
   */
  detectLastPoint(
    body: DetectRequest,
    options?: DetectLastPointOptionalParams
  ): Promise<DetectLastPointResponse> {
    return this.sendOperationRequest(
      { body, options },
      detectLastPointOperationSpec
    );
  }

  /**
   * Evaluate change point score of every series point
   * @param body Time series points and granularity is needed. Advanced model parameters can also be set
   *             in the request if needed.
   * @param options The options parameters.
   */
  detectChangePoint(
    body: ChangePointDetectRequest,
    options?: DetectChangePointOptionalParams
  ): Promise<DetectChangePointResponse> {
    return this.sendOperationRequest(
      { body, options },
      detectChangePointOperationSpec
    );
  }

  /**
   * Create and train a multivariate anomaly detection model. The request must include a source parameter
   * to indicate an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri).
   * All time-series used in generate the model must be zipped into one single file. Each time-series
   * will be in a single CSV file in which the first column is timestamp and the second column is value.
   * @param body Training request
   * @param options The options parameters.
   */
  trainMultivariateModel(
    body: ModelInfo,
    options?: TrainMultivariateModelOptionalParams
  ): Promise<TrainMultivariateModelResponse> {
    return this.sendOperationRequest(
      { body, options },
      trainMultivariateModelOperationSpec
    );
  }

  /**
   * List models of a subscription
   * @param options The options parameters.
   */
  private _listMultivariateModel(
    options?: ListMultivariateModelOptionalParams
  ): Promise<ListMultivariateModelResponse> {
    return this.sendOperationRequest(
      { options },
      listMultivariateModelOperationSpec
    );
  }

  /**
   * Get detailed information of multivariate model, including the training status and variables used in
   * the model.
   * @param modelId Model identifier.
   * @param options The options parameters.
   */
  getMultivariateModel(
    modelId: string,
    options?: GetMultivariateModelOptionalParams
  ): Promise<GetMultivariateModelResponse> {
    return this.sendOperationRequest(
      { modelId, options },
      getMultivariateModelOperationSpec
    );
  }

  /**
   * Delete an existing multivariate model according to the modelId
   * @param modelId Model identifier.
   * @param options The options parameters.
   */
  deleteMultivariateModel(
    modelId: string,
    options?: DeleteMultivariateModelOptionalParams
  ): Promise<void> {
    return this.sendOperationRequest(
      { modelId, options },
      deleteMultivariateModelOperationSpec
    );
  }

  /**
   * Submit detection multivariate anomaly task with the trained model of modelId, the input schema
   * should be the same with the training request. Thus request will be complete asynchronously and will
   * return a resultId for querying the detection result.The request should be a source link to indicate
   * an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri). All
   * time-series used in generate the model must be zipped into one single file. Each time-series will be
   * as follows: the first column is timestamp and the second column is value.
   * @param modelId Model identifier.
   * @param body Detect anomaly request
   * @param options The options parameters.
   */
  detectAnomaly(
    modelId: string,
    body: DetectionRequest,
    options?: DetectAnomalyOptionalParams
  ): Promise<DetectAnomalyResponse> {
    return this.sendOperationRequest(
      { modelId, body, options },
      detectAnomalyOperationSpec
    );
  }

  /**
   * Get multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync api
   * @param resultId Result identifier.
   * @param options The options parameters.
   */
  getDetectionResult(
    resultId: string,
    options?: GetDetectionResultOptionalParams
  ): Promise<GetDetectionResultResponse> {
    return this.sendOperationRequest(
      { resultId, options },
      getDetectionResultOperationSpec
    );
  }

  /**
   * Export multivariate anomaly detection model based on modelId
   * @param modelId Model identifier.
   * @param options The options parameters.
   */
  exportModel(
    modelId: string,
    options?: ExportModelOptionalParams
  ): Promise<ExportModelResponse> {
    return this.sendOperationRequest(
      { modelId, options },
      exportModelOperationSpec
    );
  }

  /**
   * Synchronized API for anomaly detection.
   * @param modelId Model identifier.
   * @param body Request for last detection.
   * @param options The options parameters.
   */
  lastDetectAnomaly(
    modelId: string,
    body: LastDetectionRequest,
    options?: LastDetectAnomalyOptionalParams
  ): Promise<LastDetectAnomalyResponse> {
    return this.sendOperationRequest(
      { modelId, body, options },
      lastDetectAnomalyOperationSpec
    );
  }

  /**
   * ListMultivariateModelNext
   * @param nextLink The nextLink from the previous successful call to the ListMultivariateModel method.
   * @param options The options parameters.
   */
  private _listMultivariateModelNext(
    nextLink: string,
    options?: ListMultivariateModelNextOptionalParams
  ): Promise<ListMultivariateModelNextResponse> {
    return this.sendOperationRequest(
      { nextLink, options },
      listMultivariateModelNextOperationSpec
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const detectEntireSeriesOperationSpec: coreClient.OperationSpec = {
  path: "/timeseries/entire/detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.EntireDetectResponse
    },
    default: {
      bodyMapper: Mappers.AnomalyDetectorError,
      headersMapper:
        Mappers.AnomalyDetectorClientDetectEntireSeriesExceptionHeaders
    }
  },
  requestBody: Parameters.body,
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const detectLastPointOperationSpec: coreClient.OperationSpec = {
  path: "/timeseries/last/detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.LastDetectResponse
    },
    default: {
      bodyMapper: Mappers.AnomalyDetectorError,
      headersMapper:
        Mappers.AnomalyDetectorClientDetectLastPointExceptionHeaders
    }
  },
  requestBody: Parameters.body,
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const detectChangePointOperationSpec: coreClient.OperationSpec = {
  path: "/timeseries/changepoint/detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ChangePointDetectResponse
    },
    default: {
      bodyMapper: Mappers.AnomalyDetectorError,
      headersMapper:
        Mappers.AnomalyDetectorClientDetectChangePointExceptionHeaders
    }
  },
  requestBody: Parameters.body1,
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const trainMultivariateModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models",
  httpMethod: "POST",
  responses: {
    201: {
      headersMapper: Mappers.AnomalyDetectorClientTrainMultivariateModelHeaders
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorClientTrainMultivariateModelExceptionHeaders
    }
  },
  requestBody: Parameters.body2,
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listMultivariateModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ModelList
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorClientListMultivariateModelExceptionHeaders
    }
  },
  queryParameters: [Parameters.skip, Parameters.top],
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.accept],
  serializer
};
const getMultivariateModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.Model
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorClientGetMultivariateModelExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteMultivariateModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorClientDeleteMultivariateModelExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const detectAnomalyOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}/detect",
  httpMethod: "POST",
  responses: {
    201: {
      headersMapper: Mappers.AnomalyDetectorClientDetectAnomalyHeaders
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.AnomalyDetectorClientDetectAnomalyExceptionHeaders
    }
  },
  requestBody: Parameters.body3,
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getDetectionResultOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/results/{resultId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DetectionResult
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorClientGetDetectionResultExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.resultId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const exportModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}/export",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.AnomalyDetectorClientExportModelExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.accept1],
  serializer
};
const lastDetectAnomalyOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}/last/detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.LastDetectionResult
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorClientLastDetectAnomalyExceptionHeaders
    }
  },
  requestBody: Parameters.body4,
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listMultivariateModelNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ModelList
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorClientListMultivariateModelNextExceptionHeaders
    }
  },
  queryParameters: [Parameters.skip, Parameters.top],
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.nextLink
  ],
  headerParameters: [Parameters.accept],
  serializer
};
