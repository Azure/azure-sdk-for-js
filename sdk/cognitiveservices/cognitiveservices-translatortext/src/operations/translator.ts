/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "@azure/ms-rest-js";
import * as Models from "../models";
import * as Mappers from "../models/translatorMappers";
import * as Parameters from "../models/parameters";
import { TranslatorTextClientContext } from "../translatorTextClientContext";

/** Class representing a Translator. */
export class Translator {
  private readonly client: TranslatorTextClientContext;

  /**
   * Create a Translator.
   * @param {TranslatorTextClientContext} client Reference to the service client.
   */
  constructor(client: TranslatorTextClientContext) {
    this.client = client;
  }

  /**
   * Identifies the position of sentence boundaries in a piece of text.
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named Text. Sentence boundaries are computed for the value of the Text property.
   *
   * The following limitations apply:
   * * The array can have at most 100 elements.
   * * The text value of an array element cannot exceed 10,000 characters including spaces.
   * * The entire text included in the request cannot exceed 50,000 characters including spaces.
   * * If the `language` query parameter is specified, then all array elements must be in the same
   * language. Otherwise, language auto-detection is applied to each array element independently.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `sentLen`- An array of integers representing the lengths of the sentences in the text element.
   * The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * * `detectedLanguage`- An object describing the detected language through the following
   * properties
   * * `language`- Code of the detected language.
   * * `score`- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * * Note that the `detectedLanguage` property is only present in the result object when language
   * auto-detection is requested.
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param [options] The optional parameters
   * @returns Promise<Models.TranslatorBreakSentenceResponse>
   */
  breakSentence(text: Models.BreakSentenceTextInput[], options?: Models.TranslatorBreakSentenceOptionalParams): Promise<Models.TranslatorBreakSentenceResponse>;
  /**
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named Text. Sentence boundaries are computed for the value of the Text property.
   *
   * The following limitations apply:
   * * The array can have at most 100 elements.
   * * The text value of an array element cannot exceed 10,000 characters including spaces.
   * * The entire text included in the request cannot exceed 50,000 characters including spaces.
   * * If the `language` query parameter is specified, then all array elements must be in the same
   * language. Otherwise, language auto-detection is applied to each array element independently.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `sentLen`- An array of integers representing the lengths of the sentences in the text element.
   * The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * * `detectedLanguage`- An object describing the detected language through the following
   * properties
   * * `language`- Code of the detected language.
   * * `score`- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * * Note that the `detectedLanguage` property is only present in the result object when language
   * auto-detection is requested.
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param callback The callback
   */
  breakSentence(text: Models.BreakSentenceTextInput[], callback: msRest.ServiceCallback<Models.BreakSentenceResultItem[]>): void;
  /**
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named Text. Sentence boundaries are computed for the value of the Text property.
   *
   * The following limitations apply:
   * * The array can have at most 100 elements.
   * * The text value of an array element cannot exceed 10,000 characters including spaces.
   * * The entire text included in the request cannot exceed 50,000 characters including spaces.
   * * If the `language` query parameter is specified, then all array elements must be in the same
   * language. Otherwise, language auto-detection is applied to each array element independently.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `sentLen`- An array of integers representing the lengths of the sentences in the text element.
   * The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * * `detectedLanguage`- An object describing the detected language through the following
   * properties
   * * `language`- Code of the detected language.
   * * `score`- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * * Note that the `detectedLanguage` property is only present in the result object when language
   * auto-detection is requested.
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param options The optional parameters
   * @param callback The callback
   */
  breakSentence(text: Models.BreakSentenceTextInput[], options: Models.TranslatorBreakSentenceOptionalParams, callback: msRest.ServiceCallback<Models.BreakSentenceResultItem[]>): void;
  breakSentence(text: Models.BreakSentenceTextInput[], options?: Models.TranslatorBreakSentenceOptionalParams | msRest.ServiceCallback<Models.BreakSentenceResultItem[]>, callback?: msRest.ServiceCallback<Models.BreakSentenceResultItem[]>): Promise<Models.TranslatorBreakSentenceResponse> {
    return this.client.sendOperationRequest(
      {
        text,
        options
      },
      breakSentenceOperationSpec,
      callback) as Promise<Models.TranslatorBreakSentenceResponse>;
  }

  /**
   * Identifies the language of a string of text.
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named Text. Language detection is applied to the value of the Text property.
   * The following limitations apply:
   * * The array can have at most 100 elements.
   * * The text value of an array element cannot exceed 10,000 characters including spaces.
   * * The entire text included in the request cannot exceed 50,000 characters including spaces.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * language- Code of the detected language.
   * * score- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * * isTranslationSupported- A boolean value which is true if the detected language is one of the
   * languages supported for text translation. Not all detected languages can be translated by the
   * API.
   * * isTransliterationSupported- A boolean value which is true if the detected language is one of
   * the languages supported for transliteration.
   * * alternatives- An array of other possible languages. Each element of the array is another
   * object with the same properties listed above- language, score, isTranslationSupported and
   * isTransliterationSupported.
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param [options] The optional parameters
   * @returns Promise<Models.TranslatorDetectResponse>
   */
  detect(text: Models.DetectTextInput[], options?: Models.TranslatorDetectOptionalParams): Promise<Models.TranslatorDetectResponse>;
  /**
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named Text. Language detection is applied to the value of the Text property.
   * The following limitations apply:
   * * The array can have at most 100 elements.
   * * The text value of an array element cannot exceed 10,000 characters including spaces.
   * * The entire text included in the request cannot exceed 50,000 characters including spaces.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * language- Code of the detected language.
   * * score- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * * isTranslationSupported- A boolean value which is true if the detected language is one of the
   * languages supported for text translation. Not all detected languages can be translated by the
   * API.
   * * isTransliterationSupported- A boolean value which is true if the detected language is one of
   * the languages supported for transliteration.
   * * alternatives- An array of other possible languages. Each element of the array is another
   * object with the same properties listed above- language, score, isTranslationSupported and
   * isTransliterationSupported.
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param callback The callback
   */
  detect(text: Models.DetectTextInput[], callback: msRest.ServiceCallback<Models.DetectResultItem[]>): void;
  /**
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named Text. Language detection is applied to the value of the Text property.
   * The following limitations apply:
   * * The array can have at most 100 elements.
   * * The text value of an array element cannot exceed 10,000 characters including spaces.
   * * The entire text included in the request cannot exceed 50,000 characters including spaces.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * language- Code of the detected language.
   * * score- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * * isTranslationSupported- A boolean value which is true if the detected language is one of the
   * languages supported for text translation. Not all detected languages can be translated by the
   * API.
   * * isTransliterationSupported- A boolean value which is true if the detected language is one of
   * the languages supported for transliteration.
   * * alternatives- An array of other possible languages. Each element of the array is another
   * object with the same properties listed above- language, score, isTranslationSupported and
   * isTransliterationSupported.
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param options The optional parameters
   * @param callback The callback
   */
  detect(text: Models.DetectTextInput[], options: Models.TranslatorDetectOptionalParams, callback: msRest.ServiceCallback<Models.DetectResultItem[]>): void;
  detect(text: Models.DetectTextInput[], options?: Models.TranslatorDetectOptionalParams | msRest.ServiceCallback<Models.DetectResultItem[]>, callback?: msRest.ServiceCallback<Models.DetectResultItem[]>): Promise<Models.TranslatorDetectResponse> {
    return this.client.sendOperationRequest(
      {
        text,
        options
      },
      detectOperationSpec,
      callback) as Promise<Models.TranslatorDetectResponse>;
  }

  /**
   * Provides alternative translations for a word and a small number of idiomatic phrases. Each
   * translation has a `part-of-speech` and a list of `back-translations`. The back-translations
   * enable a user to understand the translation in context. The Dictionary Example operation allows
   * further drill down to see example uses of each translation pair.
   * @param from Specifies the language of the input text. The source language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param to Specifies the language of the output text. The target language must be one of the
   * supported languages included in the `dictionary` scope of the Languages resource.
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the term to lookup.
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 100 characters including spaces.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `normalizedSource`- A string giving the normalized form of the source term. For example, if
   * the request is "JOHN", the normalized form will be "john". The content of this field becomes the
   * input to lookup examples.
   * * `displaySource`- A string giving the source term in a form best suited for end-user display.
   * For example, if the input is "JOHN", the display form will reflect the usual spelling of the
   * name- "John".
   * * `translations`- A list of translations for the source term. Each element of the list is an
   * object with the following properties:
   * * `normalizedTarget`- A string giving the normalized form of this term in the target language.
   * This value should be used as input to lookup examples.
   * * `displayTarget`- A string giving the term in the target language and in a form best suited for
   * end-user display. Generally, this will only differ from the `normalizedTarget` in terms of
   * capitalization. For example, a proper noun like "Juan" will have `normalizedTarget = "juan"` and
   * `displayTarget = "Juan"`.
   * * `posTag`- A string associating this term with a part-of-speech tag.
   *
   * | Tag name  | Description       |
   * | --------- | ----------------  |
   * | ADJ       | Adjectives        |
   * | ADV       | Adverbs           |
   * | CONJ      | Conjunctions       |
   * | DET       | Determiners       |
   * | MODAL     | Verbs             |
   * | NOUN      | Nouns             |
   * | PREP      | Prepositions      |
   * | PRON      | Pronouns          |
   * | VERB      | Verbs             |
   * | OTHER     | Other             |
   *
   * As an implementation note, these tags were determined by part-of-speech tagging the English
   * side, and then taking the most frequent tag for each source/target pair. So if people frequently
   * translate a Spanish word to a different part-of-speech tag in English, tags may end up being
   * wrong (with respect to the Spanish word).
   * * `confidence`- A value between 0.0 and 1.0 which represents the "confidence" (or perhaps more
   * accurately, "probability in the training data") of that translation pair. The sum of confidence
   * scores for one source word may or may not sum to 1.0.
   * * `prefixWord-` A string giving the word to display as a prefix of the translation. Currently,
   * this is the gendered determiner of nouns, in languages that have gendered determiners. For
   * example, the prefix of the Spanish word "mosca" is "la", since "mosca" is a feminine noun in
   * Spanish. This is only dependent on the translation, and not on the source. If there is no
   * prefix, it will be the empty string.
   * * `backTranslations-` A list of "back translations" of the target. For example, source words
   * that the target can translate to. The list is guaranteed to contain the source word that was
   * requested (e.g., if the source word being looked up is "fly", then it is guaranteed that "fly"
   * will be in the `backTranslations` list). However, it is not guaranteed to be in the first
   * position, and often will not be. Each element of the `backTranslations` list is an object
   * described by the following properties-
   * * `normalizedText-` A string giving the normalized form of the source term that is a
   * back-translation of the target. This value should be used as input to lookup examples.
   * * `displayText-` A string giving the source term that is a back-translation of the target in a
   * form best suited for end-user display.
   * * `numExamples-` An integer representing the number of examples that are available for this
   * translation pair. Actual examples must be retrieved with a separate call to lookup examples. The
   * number is mostly intended to facilitate display in a UX. For example, a user interface may add a
   * hyperlink to the back-translation if the number of examples is greater than zero and show the
   * back-translation as plain text if there are no examples. Note that the actual number of examples
   * returned by a call to lookup examples may be less than `numExamples`, because additional
   * filtering may be applied on the fly to remove "bad" examples.
   * * `frequencyCount-` An integer representing the frequency of this translation pair in the data.
   * The main purpose of this field is to provide a user interface with a means to sort
   * back-translations so the most frequent terms are first.
   *
   * Note - If the term being looked up does not exist in the dictionary, the response is 200 (OK)
   * but the `translations` list is an empty list.
   *
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param [options] The optional parameters
   * @returns Promise<Models.TranslatorDictionaryLookupResponse>
   */
  dictionaryLookup(from: string, to: string, text: Models.DictionaryLookupTextInput[], options?: Models.TranslatorDictionaryLookupOptionalParams): Promise<Models.TranslatorDictionaryLookupResponse>;
  /**
   * @param from Specifies the language of the input text. The source language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param to Specifies the language of the output text. The target language must be one of the
   * supported languages included in the `dictionary` scope of the Languages resource.
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the term to lookup.
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 100 characters including spaces.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `normalizedSource`- A string giving the normalized form of the source term. For example, if
   * the request is "JOHN", the normalized form will be "john". The content of this field becomes the
   * input to lookup examples.
   * * `displaySource`- A string giving the source term in a form best suited for end-user display.
   * For example, if the input is "JOHN", the display form will reflect the usual spelling of the
   * name- "John".
   * * `translations`- A list of translations for the source term. Each element of the list is an
   * object with the following properties:
   * * `normalizedTarget`- A string giving the normalized form of this term in the target language.
   * This value should be used as input to lookup examples.
   * * `displayTarget`- A string giving the term in the target language and in a form best suited for
   * end-user display. Generally, this will only differ from the `normalizedTarget` in terms of
   * capitalization. For example, a proper noun like "Juan" will have `normalizedTarget = "juan"` and
   * `displayTarget = "Juan"`.
   * * `posTag`- A string associating this term with a part-of-speech tag.
   *
   * | Tag name  | Description       |
   * | --------- | ----------------  |
   * | ADJ       | Adjectives        |
   * | ADV       | Adverbs           |
   * | CONJ      | Conjunctions       |
   * | DET       | Determiners       |
   * | MODAL     | Verbs             |
   * | NOUN      | Nouns             |
   * | PREP      | Prepositions      |
   * | PRON      | Pronouns          |
   * | VERB      | Verbs             |
   * | OTHER     | Other             |
   *
   * As an implementation note, these tags were determined by part-of-speech tagging the English
   * side, and then taking the most frequent tag for each source/target pair. So if people frequently
   * translate a Spanish word to a different part-of-speech tag in English, tags may end up being
   * wrong (with respect to the Spanish word).
   * * `confidence`- A value between 0.0 and 1.0 which represents the "confidence" (or perhaps more
   * accurately, "probability in the training data") of that translation pair. The sum of confidence
   * scores for one source word may or may not sum to 1.0.
   * * `prefixWord-` A string giving the word to display as a prefix of the translation. Currently,
   * this is the gendered determiner of nouns, in languages that have gendered determiners. For
   * example, the prefix of the Spanish word "mosca" is "la", since "mosca" is a feminine noun in
   * Spanish. This is only dependent on the translation, and not on the source. If there is no
   * prefix, it will be the empty string.
   * * `backTranslations-` A list of "back translations" of the target. For example, source words
   * that the target can translate to. The list is guaranteed to contain the source word that was
   * requested (e.g., if the source word being looked up is "fly", then it is guaranteed that "fly"
   * will be in the `backTranslations` list). However, it is not guaranteed to be in the first
   * position, and often will not be. Each element of the `backTranslations` list is an object
   * described by the following properties-
   * * `normalizedText-` A string giving the normalized form of the source term that is a
   * back-translation of the target. This value should be used as input to lookup examples.
   * * `displayText-` A string giving the source term that is a back-translation of the target in a
   * form best suited for end-user display.
   * * `numExamples-` An integer representing the number of examples that are available for this
   * translation pair. Actual examples must be retrieved with a separate call to lookup examples. The
   * number is mostly intended to facilitate display in a UX. For example, a user interface may add a
   * hyperlink to the back-translation if the number of examples is greater than zero and show the
   * back-translation as plain text if there are no examples. Note that the actual number of examples
   * returned by a call to lookup examples may be less than `numExamples`, because additional
   * filtering may be applied on the fly to remove "bad" examples.
   * * `frequencyCount-` An integer representing the frequency of this translation pair in the data.
   * The main purpose of this field is to provide a user interface with a means to sort
   * back-translations so the most frequent terms are first.
   *
   * Note - If the term being looked up does not exist in the dictionary, the response is 200 (OK)
   * but the `translations` list is an empty list.
   *
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param callback The callback
   */
  dictionaryLookup(from: string, to: string, text: Models.DictionaryLookupTextInput[], callback: msRest.ServiceCallback<Models.DictionaryLookupResultItem[]>): void;
  /**
   * @param from Specifies the language of the input text. The source language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param to Specifies the language of the output text. The target language must be one of the
   * supported languages included in the `dictionary` scope of the Languages resource.
   * @param text # Request Body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the term to lookup.
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 100 characters including spaces.
   *
   * # Response Body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `normalizedSource`- A string giving the normalized form of the source term. For example, if
   * the request is "JOHN", the normalized form will be "john". The content of this field becomes the
   * input to lookup examples.
   * * `displaySource`- A string giving the source term in a form best suited for end-user display.
   * For example, if the input is "JOHN", the display form will reflect the usual spelling of the
   * name- "John".
   * * `translations`- A list of translations for the source term. Each element of the list is an
   * object with the following properties:
   * * `normalizedTarget`- A string giving the normalized form of this term in the target language.
   * This value should be used as input to lookup examples.
   * * `displayTarget`- A string giving the term in the target language and in a form best suited for
   * end-user display. Generally, this will only differ from the `normalizedTarget` in terms of
   * capitalization. For example, a proper noun like "Juan" will have `normalizedTarget = "juan"` and
   * `displayTarget = "Juan"`.
   * * `posTag`- A string associating this term with a part-of-speech tag.
   *
   * | Tag name  | Description       |
   * | --------- | ----------------  |
   * | ADJ       | Adjectives        |
   * | ADV       | Adverbs           |
   * | CONJ      | Conjunctions       |
   * | DET       | Determiners       |
   * | MODAL     | Verbs             |
   * | NOUN      | Nouns             |
   * | PREP      | Prepositions      |
   * | PRON      | Pronouns          |
   * | VERB      | Verbs             |
   * | OTHER     | Other             |
   *
   * As an implementation note, these tags were determined by part-of-speech tagging the English
   * side, and then taking the most frequent tag for each source/target pair. So if people frequently
   * translate a Spanish word to a different part-of-speech tag in English, tags may end up being
   * wrong (with respect to the Spanish word).
   * * `confidence`- A value between 0.0 and 1.0 which represents the "confidence" (or perhaps more
   * accurately, "probability in the training data") of that translation pair. The sum of confidence
   * scores for one source word may or may not sum to 1.0.
   * * `prefixWord-` A string giving the word to display as a prefix of the translation. Currently,
   * this is the gendered determiner of nouns, in languages that have gendered determiners. For
   * example, the prefix of the Spanish word "mosca" is "la", since "mosca" is a feminine noun in
   * Spanish. This is only dependent on the translation, and not on the source. If there is no
   * prefix, it will be the empty string.
   * * `backTranslations-` A list of "back translations" of the target. For example, source words
   * that the target can translate to. The list is guaranteed to contain the source word that was
   * requested (e.g., if the source word being looked up is "fly", then it is guaranteed that "fly"
   * will be in the `backTranslations` list). However, it is not guaranteed to be in the first
   * position, and often will not be. Each element of the `backTranslations` list is an object
   * described by the following properties-
   * * `normalizedText-` A string giving the normalized form of the source term that is a
   * back-translation of the target. This value should be used as input to lookup examples.
   * * `displayText-` A string giving the source term that is a back-translation of the target in a
   * form best suited for end-user display.
   * * `numExamples-` An integer representing the number of examples that are available for this
   * translation pair. Actual examples must be retrieved with a separate call to lookup examples. The
   * number is mostly intended to facilitate display in a UX. For example, a user interface may add a
   * hyperlink to the back-translation if the number of examples is greater than zero and show the
   * back-translation as plain text if there are no examples. Note that the actual number of examples
   * returned by a call to lookup examples may be less than `numExamples`, because additional
   * filtering may be applied on the fly to remove "bad" examples.
   * * `frequencyCount-` An integer representing the frequency of this translation pair in the data.
   * The main purpose of this field is to provide a user interface with a means to sort
   * back-translations so the most frequent terms are first.
   *
   * Note - If the term being looked up does not exist in the dictionary, the response is 200 (OK)
   * but the `translations` list is an empty list.
   *
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * @param options The optional parameters
   * @param callback The callback
   */
  dictionaryLookup(from: string, to: string, text: Models.DictionaryLookupTextInput[], options: Models.TranslatorDictionaryLookupOptionalParams, callback: msRest.ServiceCallback<Models.DictionaryLookupResultItem[]>): void;
  dictionaryLookup(from: string, to: string, text: Models.DictionaryLookupTextInput[], options?: Models.TranslatorDictionaryLookupOptionalParams | msRest.ServiceCallback<Models.DictionaryLookupResultItem[]>, callback?: msRest.ServiceCallback<Models.DictionaryLookupResultItem[]>): Promise<Models.TranslatorDictionaryLookupResponse> {
    return this.client.sendOperationRequest(
      {
        from,
        to,
        text,
        options
      },
      dictionaryLookupOperationSpec,
      callback) as Promise<Models.TranslatorDictionaryLookupResponse>;
  }

  /**
   * Provides examples that show how terms in the dictionary are used in context. This operation is
   * used in tandem with `Dictionary lookup`.
   * @param from Specifies the language of the input text. The source language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param to Specifies the language of the output text. The target language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param text # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with the following
   * properties:
   * * `Text-` A string specifying the term to lookup. This should be the value of a `normalizedText`
   * field from the back-translations of a previous Dictionary lookup request. It can also be the
   * value of the `normalizedSource` field.
   * * `Translation-` A string specifying the translated text previously returned by the Dictionary
   * lookup operation. This should be the value from the `normalizedTarget` field in the
   * `translations` list of the Dictionary lookup response. The service will return examples for the
   * specific source-target word-pair.
   *
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 100 characters including spaces.
   *
   * # Response body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `normalizedSource-` A string giving the normalized form of the source term. Generally, this
   * should be identical to the value of the `Text` field at the matching list index in the body of
   * the request.
   * * `normalizedTarget-` A string giving the normalized form of the target term. Generally, this
   * should be identical to the value of the `Translation` field at the matching list index in the
   * body of the request.
   * * `examples-` A list of examples for the (source term, target term) pair. Each element of the
   * list is an object with the following properties:
   * * `sourcePrefix-` The string to concatenate before the value of `sourceTerm` to form a complete
   * example. Do not add a space character, since it is already there when it should be. This value
   * may be an empty string.
   * * `sourceTerm-` A string equal to the actual term looked up. The string is added with
   * `sourcePrefix` and `sourceSuffix` to form the complete example. Its value is separated so it can
   * be marked in a user interface, e.g., by bolding it.
   * * `sourceSuffix-` The string to concatenate after the value of `sourceTerm` to form a complete
   * example. Do not add a space character, since it is already there when it should be. This value
   * may be an empty string.
   * * `targetPrefix-` A string similar to `sourcePrefix` but for the target.
   * * `targetTerm-` A string similar to `sourceTerm` but for the target.
   * * `targetSuffix-` A string similar to `sourceSuffix` but for the target.
   *
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * NOTE - If there are no examples in the dictionary, the response is 200 (OK) but the `examples`
   * list is an empty list.
   * @param [options] The optional parameters
   * @returns Promise<Models.TranslatorDictionaryExamplesResponse>
   */
  dictionaryExamples(from: string, to: string, text: Models.DictionaryExampleTextInput[], options?: Models.TranslatorDictionaryExamplesOptionalParams): Promise<Models.TranslatorDictionaryExamplesResponse>;
  /**
   * @param from Specifies the language of the input text. The source language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param to Specifies the language of the output text. The target language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param text # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with the following
   * properties:
   * * `Text-` A string specifying the term to lookup. This should be the value of a `normalizedText`
   * field from the back-translations of a previous Dictionary lookup request. It can also be the
   * value of the `normalizedSource` field.
   * * `Translation-` A string specifying the translated text previously returned by the Dictionary
   * lookup operation. This should be the value from the `normalizedTarget` field in the
   * `translations` list of the Dictionary lookup response. The service will return examples for the
   * specific source-target word-pair.
   *
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 100 characters including spaces.
   *
   * # Response body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `normalizedSource-` A string giving the normalized form of the source term. Generally, this
   * should be identical to the value of the `Text` field at the matching list index in the body of
   * the request.
   * * `normalizedTarget-` A string giving the normalized form of the target term. Generally, this
   * should be identical to the value of the `Translation` field at the matching list index in the
   * body of the request.
   * * `examples-` A list of examples for the (source term, target term) pair. Each element of the
   * list is an object with the following properties:
   * * `sourcePrefix-` The string to concatenate before the value of `sourceTerm` to form a complete
   * example. Do not add a space character, since it is already there when it should be. This value
   * may be an empty string.
   * * `sourceTerm-` A string equal to the actual term looked up. The string is added with
   * `sourcePrefix` and `sourceSuffix` to form the complete example. Its value is separated so it can
   * be marked in a user interface, e.g., by bolding it.
   * * `sourceSuffix-` The string to concatenate after the value of `sourceTerm` to form a complete
   * example. Do not add a space character, since it is already there when it should be. This value
   * may be an empty string.
   * * `targetPrefix-` A string similar to `sourcePrefix` but for the target.
   * * `targetTerm-` A string similar to `sourceTerm` but for the target.
   * * `targetSuffix-` A string similar to `sourceSuffix` but for the target.
   *
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * NOTE - If there are no examples in the dictionary, the response is 200 (OK) but the `examples`
   * list is an empty list.
   * @param callback The callback
   */
  dictionaryExamples(from: string, to: string, text: Models.DictionaryExampleTextInput[], callback: msRest.ServiceCallback<Models.DictionaryExampleResultItem[]>): void;
  /**
   * @param from Specifies the language of the input text. The source language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param to Specifies the language of the output text. The target language must be one of the
   * supported languages included in the `dictionary` scope.
   * @param text # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with the following
   * properties:
   * * `Text-` A string specifying the term to lookup. This should be the value of a `normalizedText`
   * field from the back-translations of a previous Dictionary lookup request. It can also be the
   * value of the `normalizedSource` field.
   * * `Translation-` A string specifying the translated text previously returned by the Dictionary
   * lookup operation. This should be the value from the `normalizedTarget` field in the
   * `translations` list of the Dictionary lookup response. The service will return examples for the
   * specific source-target word-pair.
   *
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 100 characters including spaces.
   *
   * # Response body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties:
   * * `normalizedSource-` A string giving the normalized form of the source term. Generally, this
   * should be identical to the value of the `Text` field at the matching list index in the body of
   * the request.
   * * `normalizedTarget-` A string giving the normalized form of the target term. Generally, this
   * should be identical to the value of the `Translation` field at the matching list index in the
   * body of the request.
   * * `examples-` A list of examples for the (source term, target term) pair. Each element of the
   * list is an object with the following properties:
   * * `sourcePrefix-` The string to concatenate before the value of `sourceTerm` to form a complete
   * example. Do not add a space character, since it is already there when it should be. This value
   * may be an empty string.
   * * `sourceTerm-` A string equal to the actual term looked up. The string is added with
   * `sourcePrefix` and `sourceSuffix` to form the complete example. Its value is separated so it can
   * be marked in a user interface, e.g., by bolding it.
   * * `sourceSuffix-` The string to concatenate after the value of `sourceTerm` to form a complete
   * example. Do not add a space character, since it is already there when it should be. This value
   * may be an empty string.
   * * `targetPrefix-` A string similar to `sourcePrefix` but for the target.
   * * `targetTerm-` A string similar to `sourceTerm` but for the target.
   * * `targetSuffix-` A string similar to `sourceSuffix` but for the target.
   *
   * # Response Header
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   * NOTE - If there are no examples in the dictionary, the response is 200 (OK) but the `examples`
   * list is an empty list.
   * @param options The optional parameters
   * @param callback The callback
   */
  dictionaryExamples(from: string, to: string, text: Models.DictionaryExampleTextInput[], options: Models.TranslatorDictionaryExamplesOptionalParams, callback: msRest.ServiceCallback<Models.DictionaryExampleResultItem[]>): void;
  dictionaryExamples(from: string, to: string, text: Models.DictionaryExampleTextInput[], options?: Models.TranslatorDictionaryExamplesOptionalParams | msRest.ServiceCallback<Models.DictionaryExampleResultItem[]>, callback?: msRest.ServiceCallback<Models.DictionaryExampleResultItem[]>): Promise<Models.TranslatorDictionaryExamplesResponse> {
    return this.client.sendOperationRequest(
      {
        from,
        to,
        text,
        options
      },
      dictionaryExamplesOperationSpec,
      callback) as Promise<Models.TranslatorDictionaryExamplesResponse>;
  }

  /**
   * Gets the set of languages currently supported by other operations of the Translator Text API.
   * **Authentication is not required to get language resources.**
   *
   * # Response Body
   * A client uses the `scope` query parameter to define which groups of languages it is interested
   * in.
   * * `scope=translation` provides languages supported to translate text from one language to
   * another language.
   * * `scope=transliteration` provides capabilities for converting text in one language from one
   * script to another script.
   * * `scope=dictionary` provides language pairs for which `Dictionary` operations return data.
   *
   * A client may retrieve several groups simultaneously by specifying a comma-separated list of
   * names. For example, `scope=translation,transliteration,dictionary` would return supported
   * languages for all groups.
   *
   * A successful response is a JSON object with one property for each requested group.
   * The value for each property is as follows.
   *
   * * `translation` property
   * The value of the `translation` property is a dictionary of (key, value) pairs. Each key is a BCP
   * 47 language tag. A key identifies a language for which text can be translated to or translated
   * from. The value associated with the key is a JSON object with properties that describe the
   * language
   * * `name-` Display name of the language in the locale requested via `Accept-Language` header.
   * * `nativeName-` Display name of the language in the locale native for this language.
   * * `dir-` Directionality, which is `rtl` for right-to-left languages or `ltr` for left-to-right
   * languages.
   * ```json
   * {
   * "translation": {
   * ...
   * "fr": {
   * "name": "French",
   * "nativeName": "Français",
   * "dir": "ltr"
   * },
   * ...
   * }
   * }
   * ```
   * * `transliteration` property
   * The value of the `transliteration` property is a dictionary of (key, value) pairs. Each key is a
   * BCP 47 language tag. A key identifies a language for which text can be converted from one script
   * to another script. The value associated with the key is a JSON object with properties that
   * describe the language and its supported scripts
   * * `name-` Display name of the language in the locale requested via `Accept-Language` header.
   * * `nativeName-` Display name of the language in the locale native for this language.
   * * `scripts-` List of scripts to convert from. Each element of the `scripts` list has properties-
   * * `code-` Code identifying the script.
   * * `name-` Display name of the script in the locale requested via `Accept-Language` header.
   * * `nativeName-` Display name of the language in the locale native for the language.
   * * `dir-` Directionality, which is `rtl` for right-to-left languages or `ltr` for left-to-right
   * languages.
   * * `toScripts-` List of scripts available to convert text to. Each element of the `toScripts`
   * list has properties `code`, `name`, `nativeName`, and `dir` as described earlier.
   *
   * ```json
   * {
   * "transliteration": {
   * ...
   * "ja": {
   * "name": "Japanese",
   * "nativeName": "日本語",
   * "scripts": [
   * {
   * "code": "Jpan",
   * "name": "Japanese",
   * "nativeName": "日本語",
   * "dir": "ltr",
   * "toScripts": [
   * {
   * "code": "Latn",
   * "name": "Latin",
   * "nativeName": "ラテン語",
   * "dir": "ltr"
   * }
   * ]
   * },
   * {
   * "code": "Latn",
   * "name": "Latin",
   * "nativeName": "ラテン語",
   * "dir": "ltr",
   * "toScripts": [
   * {
   * "code": "Jpan",
   * "name": "Japanese",
   * "nativeName": "日本語",
   * "dir": "ltr"
   * }
   * ]
   * }
   * ]
   * },
   * ...
   * }
   * }
   *
   * ```
   * * `dictionary` property
   * The value of the `dictionary` property is a dictionary of (key, value) pairs. Each key is a BCP
   * 47 language tag. The key identifies a language for which alternative translations and
   * back-translations are available. The value is a JSON object that describes the source language
   * and the target languages with available translations.
   * * `name-` Display name of the source language in the locale requested via `Accept-Language`
   * header.
   * * `nativeName-` Display name of the language in the locale native for this language.
   * * `dir-` Directionality, which is `rtl` for right-to-left languages or `ltr` for left-to-right
   * languages.
   * * `translations-` List of languages with alterative translations and examples for the query
   * expressed in the source language. Each element of the `translations` list has properties
   * * `name-` Display name of the target language in the locale requested via `Accept-Language`
   * header.
   * * `nativeName-` Display name of the target language in the locale native for the target
   * language.
   * * `dir-` Directionality, which is `rtl` for right-to-left languages or `ltr` for left-to-right
   * languages.
   * * `code-` Language code identifying the target language.
   *
   * ```json
   *
   * "es": {
   * "name": "Spanish",
   * "nativeName": "Español",
   * "dir": "ltr",
   * "translations": [
   * {
   * "name": "English",
   * "nativeName": "English",
   * "dir": "ltr",
   * "code": "en"
   * }
   * ]
   * },
   *
   * ```
   *
   * The structure of the response object will not change without a change in the version of the API.
   * For the same version of the API, the list of available languages may change over time because
   * Microsoft Translator continually extends the list of languages supported by its services.
   *
   * The list of supported languages will not change frequently. To save network bandwidth and
   * improve responsiveness, a client application should consider caching language resources and the
   * corresponding entity tag (`ETag`). Then, the client application can periodically (for example,
   * once every 24 hours) query the service to fetch the latest set of supported languages. Passing
   * the current `ETag` value in an `If-None-Match` header field will allow the service to optimize
   * the response. If the resource has not been modified, the service will return status code 304 and
   * an empty response body.
   *
   * # Response Header
   * ETag - Current value of the entity tag for the requested groups of supported languages. To make
   * subsequent requests more efficient, the client may send the `ETag` value in an `If-None-Match`
   * header field.
   *
   * X-RequestId - Value generated by the service to identify the request. It is used for
   * troubleshooting purposes.
   *
   *
   * @param [options] The optional parameters
   * @returns Promise<Models.TranslatorLanguagesResponse>
   */
  languages(options?: Models.TranslatorLanguagesOptionalParams): Promise<Models.TranslatorLanguagesResponse>;
  /**
   * @param callback The callback
   */
  languages(callback: msRest.ServiceCallback<Models.LanguagesResult>): void;
  /**
   * @param options The optional parameters
   * @param callback The callback
   */
  languages(options: Models.TranslatorLanguagesOptionalParams, callback: msRest.ServiceCallback<Models.LanguagesResult>): void;
  languages(options?: Models.TranslatorLanguagesOptionalParams | msRest.ServiceCallback<Models.LanguagesResult>, callback?: msRest.ServiceCallback<Models.LanguagesResult>): Promise<Models.TranslatorLanguagesResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      languagesOperationSpec,
      callback) as Promise<Models.TranslatorLanguagesResponse>;
  }

  /**
   * Translates text into one or more languages.
   * @param to Specifies the language of the output text. Find which languages are available to
   * translate to by using the languages method. For example, use `to=de` to translate to German.
   * It's possible to translate to multiple languages simultaneously by repeating the `to` parameter
   * in the query string. For example, use `to=de&to=it` to translate to German and Italian in the
   * same request.
   * @param text # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the string to translate.
   * The following limitations apply:
   * * The array can have at most 25 elements.
   * * The entire text included in the request cannot exceed 5,000 characters including spaces.
   * # Response body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties-
   * * `detectedLanguage`- An object describing the detected language through the following
   * properties.
   * * `language`- A string representing the code of the detected language.
   * * `score`- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * The `detectedLanguage` property is only present in the result object when language
   * auto-detection is requested.
   * * `translations`- An array of translation results. The size of the array matches the number of
   * target languages specified in the `to` query parameter. Each element in the array includes.
   * * `to` A string representing the language code of the target language.
   * * `text`- A string giving the translated text.
   * * `transliteration`- An object giving the translated text in the script specified by the
   * `toScript` parameter.
   * * `script`- A string specifying the target script.
   * * `text`- A string giving the translated text in the target script.
   * The `transliteration` object is not included if transliteration does not take place.
   * *`alignment`- An object with a single string property named `proj`, which maps input text to
   * translated text. The alignment information is only provided when the request parameter
   * `includeAlignment` is `true`. Alignment is returned as a string value of the following format-
   * `[[SourceTextStartIndex]-[SourceTextEndIndex]–[TgtTextStartIndex]-[TgtTextEndIndex]]`. The colon
   * separates start and end index, the dash separates the languages, and space separates the words.
   * One word may align with zero, one, or multiple words in the other language, and the aligned
   * words may be non-contiguous. When no alignment information is available, the alignment element
   * will be empty. See Obtain alignment information for an example and restrictions.
   * * `sentLen`- An object returning sentence boundaries in the input and output texts.
   * * `srcSentLen`- An integer array representing the lengths of the sentences in the input text.
   * The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * * `transSentLen`- An integer array representing the lengths of the sentences in the translated
   * text. The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * Sentence boundaries are only included when the request parameter `includeSentenceLength` is
   * `true`.
   * * `sourceText`- An object with a single string property named `text`, which gives the input text
   * in the default script of the source language. `sourceText` property is present only when the
   * input is expressed in a script that's not the usual script for the language. For example, if the
   * input were Arabic written in Latin script, then `sourceText.text` would be the same Arabic text
   * converted into Arab script.
   * Example of JSON responses are provided in the examples section.
   *
   *
   * @param [options] The optional parameters
   * @returns Promise<Models.TranslatorTranslateResponse>
   */
  translate(to: string[], text: Models.TranslateTextInput[], options?: Models.TranslatorTranslateOptionalParams): Promise<Models.TranslatorTranslateResponse>;
  /**
   * @param to Specifies the language of the output text. Find which languages are available to
   * translate to by using the languages method. For example, use `to=de` to translate to German.
   * It's possible to translate to multiple languages simultaneously by repeating the `to` parameter
   * in the query string. For example, use `to=de&to=it` to translate to German and Italian in the
   * same request.
   * @param text # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the string to translate.
   * The following limitations apply:
   * * The array can have at most 25 elements.
   * * The entire text included in the request cannot exceed 5,000 characters including spaces.
   * # Response body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties-
   * * `detectedLanguage`- An object describing the detected language through the following
   * properties.
   * * `language`- A string representing the code of the detected language.
   * * `score`- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * The `detectedLanguage` property is only present in the result object when language
   * auto-detection is requested.
   * * `translations`- An array of translation results. The size of the array matches the number of
   * target languages specified in the `to` query parameter. Each element in the array includes.
   * * `to` A string representing the language code of the target language.
   * * `text`- A string giving the translated text.
   * * `transliteration`- An object giving the translated text in the script specified by the
   * `toScript` parameter.
   * * `script`- A string specifying the target script.
   * * `text`- A string giving the translated text in the target script.
   * The `transliteration` object is not included if transliteration does not take place.
   * *`alignment`- An object with a single string property named `proj`, which maps input text to
   * translated text. The alignment information is only provided when the request parameter
   * `includeAlignment` is `true`. Alignment is returned as a string value of the following format-
   * `[[SourceTextStartIndex]-[SourceTextEndIndex]–[TgtTextStartIndex]-[TgtTextEndIndex]]`. The colon
   * separates start and end index, the dash separates the languages, and space separates the words.
   * One word may align with zero, one, or multiple words in the other language, and the aligned
   * words may be non-contiguous. When no alignment information is available, the alignment element
   * will be empty. See Obtain alignment information for an example and restrictions.
   * * `sentLen`- An object returning sentence boundaries in the input and output texts.
   * * `srcSentLen`- An integer array representing the lengths of the sentences in the input text.
   * The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * * `transSentLen`- An integer array representing the lengths of the sentences in the translated
   * text. The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * Sentence boundaries are only included when the request parameter `includeSentenceLength` is
   * `true`.
   * * `sourceText`- An object with a single string property named `text`, which gives the input text
   * in the default script of the source language. `sourceText` property is present only when the
   * input is expressed in a script that's not the usual script for the language. For example, if the
   * input were Arabic written in Latin script, then `sourceText.text` would be the same Arabic text
   * converted into Arab script.
   * Example of JSON responses are provided in the examples section.
   *
   *
   * @param callback The callback
   */
  translate(to: string[], text: Models.TranslateTextInput[], callback: msRest.ServiceCallback<Models.TranslateResultAllItem[]>): void;
  /**
   * @param to Specifies the language of the output text. Find which languages are available to
   * translate to by using the languages method. For example, use `to=de` to translate to German.
   * It's possible to translate to multiple languages simultaneously by repeating the `to` parameter
   * in the query string. For example, use `to=de&to=it` to translate to German and Italian in the
   * same request.
   * @param text # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the string to translate.
   * The following limitations apply:
   * * The array can have at most 25 elements.
   * * The entire text included in the request cannot exceed 5,000 characters including spaces.
   * # Response body
   * A successful response is a JSON array with one result for each string in the input array. A
   * result object includes the following properties-
   * * `detectedLanguage`- An object describing the detected language through the following
   * properties.
   * * `language`- A string representing the code of the detected language.
   * * `score`- A float value indicating the confidence in the result. The score is between zero and
   * one and a low score indicates a low confidence.
   * The `detectedLanguage` property is only present in the result object when language
   * auto-detection is requested.
   * * `translations`- An array of translation results. The size of the array matches the number of
   * target languages specified in the `to` query parameter. Each element in the array includes.
   * * `to` A string representing the language code of the target language.
   * * `text`- A string giving the translated text.
   * * `transliteration`- An object giving the translated text in the script specified by the
   * `toScript` parameter.
   * * `script`- A string specifying the target script.
   * * `text`- A string giving the translated text in the target script.
   * The `transliteration` object is not included if transliteration does not take place.
   * *`alignment`- An object with a single string property named `proj`, which maps input text to
   * translated text. The alignment information is only provided when the request parameter
   * `includeAlignment` is `true`. Alignment is returned as a string value of the following format-
   * `[[SourceTextStartIndex]-[SourceTextEndIndex]–[TgtTextStartIndex]-[TgtTextEndIndex]]`. The colon
   * separates start and end index, the dash separates the languages, and space separates the words.
   * One word may align with zero, one, or multiple words in the other language, and the aligned
   * words may be non-contiguous. When no alignment information is available, the alignment element
   * will be empty. See Obtain alignment information for an example and restrictions.
   * * `sentLen`- An object returning sentence boundaries in the input and output texts.
   * * `srcSentLen`- An integer array representing the lengths of the sentences in the input text.
   * The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * * `transSentLen`- An integer array representing the lengths of the sentences in the translated
   * text. The length of the array is the number of sentences, and the values are the length of each
   * sentence.
   * Sentence boundaries are only included when the request parameter `includeSentenceLength` is
   * `true`.
   * * `sourceText`- An object with a single string property named `text`, which gives the input text
   * in the default script of the source language. `sourceText` property is present only when the
   * input is expressed in a script that's not the usual script for the language. For example, if the
   * input were Arabic written in Latin script, then `sourceText.text` would be the same Arabic text
   * converted into Arab script.
   * Example of JSON responses are provided in the examples section.
   *
   *
   * @param options The optional parameters
   * @param callback The callback
   */
  translate(to: string[], text: Models.TranslateTextInput[], options: Models.TranslatorTranslateOptionalParams, callback: msRest.ServiceCallback<Models.TranslateResultAllItem[]>): void;
  translate(to: string[], text: Models.TranslateTextInput[], options?: Models.TranslatorTranslateOptionalParams | msRest.ServiceCallback<Models.TranslateResultAllItem[]>, callback?: msRest.ServiceCallback<Models.TranslateResultAllItem[]>): Promise<Models.TranslatorTranslateResponse> {
    return this.client.sendOperationRequest(
      {
        to,
        text,
        options
      },
      translateOperationSpec,
      callback) as Promise<Models.TranslatorTranslateResponse>;
  }

  /**
   * Converts the text of a language in one script into another type of script. Example-
   * Japanese script "こんにちは"
   * Same word in Latin script "konnichiha"
   * @param language Specifies the language of the text to convert from one script to another.
   * Possible languages are listed in the `transliteration` scope obtained by querying the service
   * for its supported languages.
   * @param fromScript Specifies the script used by the input text. Lookup supported languages using
   * the `transliteration` scope, to find input scripts available for the selected language.
   * @param toScript Specifies the output script. Lookup supported languages using the
   * `transliteration` scope, to find output scripts available for the selected combination of input
   * language and input script.
   * @param texts # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the string to convert.
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 1,000 characters including spaces.
   * * The entire text included in the request cannot exceed 5,000 characters including spaces.
   *
   * # Response body
   * A successful response is a JSON array with one result for each element in the input array. A
   * result object includes the following properties:
   * * `text`- A string which is the result of converting the input string to the output script.
   * * `script`- A string specifying the script used in the output.
   *
   * @param [options] The optional parameters
   * @returns Promise<Models.TranslatorTransliterateResponse>
   */
  transliterate(language: string, fromScript: string, toScript: string, texts: Models.TransliterateTextInput[], options?: Models.TranslatorTransliterateOptionalParams): Promise<Models.TranslatorTransliterateResponse>;
  /**
   * @param language Specifies the language of the text to convert from one script to another.
   * Possible languages are listed in the `transliteration` scope obtained by querying the service
   * for its supported languages.
   * @param fromScript Specifies the script used by the input text. Lookup supported languages using
   * the `transliteration` scope, to find input scripts available for the selected language.
   * @param toScript Specifies the output script. Lookup supported languages using the
   * `transliteration` scope, to find output scripts available for the selected combination of input
   * language and input script.
   * @param texts # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the string to convert.
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 1,000 characters including spaces.
   * * The entire text included in the request cannot exceed 5,000 characters including spaces.
   *
   * # Response body
   * A successful response is a JSON array with one result for each element in the input array. A
   * result object includes the following properties:
   * * `text`- A string which is the result of converting the input string to the output script.
   * * `script`- A string specifying the script used in the output.
   *
   * @param callback The callback
   */
  transliterate(language: string, fromScript: string, toScript: string, texts: Models.TransliterateTextInput[], callback: msRest.ServiceCallback<Models.TransliterateResultItem[]>): void;
  /**
   * @param language Specifies the language of the text to convert from one script to another.
   * Possible languages are listed in the `transliteration` scope obtained by querying the service
   * for its supported languages.
   * @param fromScript Specifies the script used by the input text. Lookup supported languages using
   * the `transliteration` scope, to find input scripts available for the selected language.
   * @param toScript Specifies the output script. Lookup supported languages using the
   * `transliteration` scope, to find output scripts available for the selected combination of input
   * language and input script.
   * @param texts # Request body
   * The body of the request is a JSON array. Each array element is a JSON object with a string
   * property named `Text`, which represents the string to convert.
   * The following limitations apply:
   * * The array can have at most 10 elements.
   * * The text value of an array element cannot exceed 1,000 characters including spaces.
   * * The entire text included in the request cannot exceed 5,000 characters including spaces.
   *
   * # Response body
   * A successful response is a JSON array with one result for each element in the input array. A
   * result object includes the following properties:
   * * `text`- A string which is the result of converting the input string to the output script.
   * * `script`- A string specifying the script used in the output.
   *
   * @param options The optional parameters
   * @param callback The callback
   */
  transliterate(language: string, fromScript: string, toScript: string, texts: Models.TransliterateTextInput[], options: Models.TranslatorTransliterateOptionalParams, callback: msRest.ServiceCallback<Models.TransliterateResultItem[]>): void;
  transliterate(language: string, fromScript: string, toScript: string, texts: Models.TransliterateTextInput[], options?: Models.TranslatorTransliterateOptionalParams | msRest.ServiceCallback<Models.TransliterateResultItem[]>, callback?: msRest.ServiceCallback<Models.TransliterateResultItem[]>): Promise<Models.TranslatorTransliterateResponse> {
    return this.client.sendOperationRequest(
      {
        language,
        fromScript,
        toScript,
        texts,
        options
      },
      transliterateOperationSpec,
      callback) as Promise<Models.TranslatorTransliterateResponse>;
  }
}

// Operation Specifications
const serializer = new msRest.Serializer(Mappers);
const breakSentenceOperationSpec: msRest.OperationSpec = {
  httpMethod: "POST",
  path: "BreakSentence",
  urlParameters: [
    Parameters.endpoint
  ],
  queryParameters: [
    Parameters.apiVersion,
    Parameters.language0,
    Parameters.script
  ],
  headerParameters: [
    Parameters.xClientTraceId
  ],
  requestBody: {
    parameterPath: "text",
    mapper: {
      required: true,
      serializedName: "text",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "BreakSentenceTextInput"
          }
        }
      }
    }
  },
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "BreakSentenceResultItem"
            }
          }
        }
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  serializer
};

const detectOperationSpec: msRest.OperationSpec = {
  httpMethod: "POST",
  path: "Detect",
  urlParameters: [
    Parameters.endpoint
  ],
  queryParameters: [
    Parameters.apiVersion
  ],
  headerParameters: [
    Parameters.xClientTraceId
  ],
  requestBody: {
    parameterPath: "text",
    mapper: {
      required: true,
      serializedName: "text",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "DetectTextInput"
          }
        }
      }
    }
  },
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DetectResultItem"
            }
          }
        }
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  serializer
};

const dictionaryLookupOperationSpec: msRest.OperationSpec = {
  httpMethod: "POST",
  path: "Dictionary/Lookup",
  urlParameters: [
    Parameters.endpoint
  ],
  queryParameters: [
    Parameters.apiVersion,
    Parameters.from0,
    Parameters.to0
  ],
  headerParameters: [
    Parameters.xClientTraceId
  ],
  requestBody: {
    parameterPath: "text",
    mapper: {
      required: true,
      serializedName: "text",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "DictionaryLookupTextInput"
          }
        }
      }
    }
  },
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DictionaryLookupResultItem"
            }
          }
        }
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  serializer
};

const dictionaryExamplesOperationSpec: msRest.OperationSpec = {
  httpMethod: "POST",
  path: "Dictionary/Examples",
  urlParameters: [
    Parameters.endpoint
  ],
  queryParameters: [
    Parameters.apiVersion,
    Parameters.from0,
    Parameters.to0
  ],
  headerParameters: [
    Parameters.xClientTraceId
  ],
  requestBody: {
    parameterPath: "text",
    mapper: {
      required: true,
      serializedName: "text",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "DictionaryExampleTextInput"
          }
        }
      }
    }
  },
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DictionaryExampleResultItem"
            }
          }
        }
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  serializer
};

const languagesOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "Languages",
  urlParameters: [
    Parameters.endpoint
  ],
  queryParameters: [
    Parameters.apiVersion,
    Parameters.scope
  ],
  headerParameters: [
    Parameters.acceptLanguage,
    Parameters.xClientTraceId
  ],
  responses: {
    200: {
      bodyMapper: Mappers.LanguagesResult
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  serializer
};

const translateOperationSpec: msRest.OperationSpec = {
  httpMethod: "POST",
  path: "translate",
  urlParameters: [
    Parameters.endpoint
  ],
  queryParameters: [
    Parameters.apiVersion,
    Parameters.from1,
    Parameters.to1,
    Parameters.textType,
    Parameters.category,
    Parameters.profanityAction,
    Parameters.profanityMarker,
    Parameters.includeAlignment,
    Parameters.includeSentenceLength,
    Parameters.suggestedFrom,
    Parameters.fromScript0,
    Parameters.toScript0
  ],
  headerParameters: [
    Parameters.xClientTraceId
  ],
  requestBody: {
    parameterPath: "text",
    mapper: {
      required: true,
      serializedName: "text",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "TranslateTextInput"
          }
        }
      }
    }
  },
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TranslateResultAllItem"
            }
          }
        }
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  serializer
};

const transliterateOperationSpec: msRest.OperationSpec = {
  httpMethod: "POST",
  path: "transliterate",
  urlParameters: [
    Parameters.endpoint
  ],
  queryParameters: [
    Parameters.apiVersion,
    Parameters.language1,
    Parameters.fromScript1,
    Parameters.toScript1
  ],
  headerParameters: [
    Parameters.xClientTraceId
  ],
  requestBody: {
    parameterPath: "texts",
    mapper: {
      required: true,
      serializedName: "texts",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "TransliterateTextInput"
          }
        }
      }
    }
  },
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TransliterateResultItem"
            }
          }
        }
      }
    },
    default: {
      bodyMapper: Mappers.ErrorMessage
    }
  },
  serializer
};
