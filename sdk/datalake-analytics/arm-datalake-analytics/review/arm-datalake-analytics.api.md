## API Report File for "@azure/arm-datalake-analytics"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export type AADObjectType = string;

// @public
export interface Accounts {
    beginCreate(resourceGroupName: string, accountName: string, parameters: CreateDataLakeAnalyticsAccountParameters, options?: AccountsCreateOptionalParams): Promise<PollerLike<PollOperationState<AccountsCreateResponse>, AccountsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, parameters: CreateDataLakeAnalyticsAccountParameters, options?: AccountsCreateOptionalParams): Promise<AccountsCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, options?: AccountsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, options?: AccountsDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, options?: AccountsUpdateOptionalParams): Promise<PollerLike<PollOperationState<AccountsUpdateResponse>, AccountsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, options?: AccountsUpdateOptionalParams): Promise<AccountsUpdateResponse>;
    checkNameAvailability(location: string, parameters: CheckNameAvailabilityParameters, options?: AccountsCheckNameAvailabilityOptionalParams): Promise<AccountsCheckNameAvailabilityResponse>;
    get(resourceGroupName: string, accountName: string, options?: AccountsGetOptionalParams): Promise<AccountsGetResponse>;
    list(options?: AccountsListOptionalParams): PagedAsyncIterableIterator<DataLakeAnalyticsAccountBasic>;
    listByResourceGroup(resourceGroupName: string, options?: AccountsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<DataLakeAnalyticsAccountBasic>;
}

// @public
export interface AccountsCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountsCheckNameAvailabilityResponse = NameAvailabilityInformation;

// @public
export interface AccountsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AccountsCreateResponse = DataLakeAnalyticsAccount;

// @public
export interface AccountsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface AccountsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountsGetResponse = DataLakeAnalyticsAccount;

// @public
export interface AccountsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
    count?: boolean;
    filter?: string;
    orderby?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export type AccountsListByResourceGroupNextResponse = DataLakeAnalyticsAccountListResult;

// @public
export interface AccountsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
    count?: boolean;
    filter?: string;
    orderby?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export type AccountsListByResourceGroupResponse = DataLakeAnalyticsAccountListResult;

// @public
export interface AccountsListNextOptionalParams extends coreClient.OperationOptions {
    count?: boolean;
    filter?: string;
    orderby?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export type AccountsListNextResponse = DataLakeAnalyticsAccountListResult;

// @public
export interface AccountsListOptionalParams extends coreClient.OperationOptions {
    count?: boolean;
    filter?: string;
    orderby?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export type AccountsListResponse = DataLakeAnalyticsAccountListResult;

// @public
export interface AccountsUpdateOptionalParams extends coreClient.OperationOptions {
    parameters?: UpdateDataLakeAnalyticsAccountParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AccountsUpdateResponse = DataLakeAnalyticsAccount;

// @public
export interface AddDataLakeStoreParameters {
    suffix?: string;
}

// @public
export interface AddDataLakeStoreWithAccountParameters {
    name: string;
    suffix?: string;
}

// @public
export interface AddStorageAccountParameters {
    accessKey: string;
    suffix?: string;
}

// @public
export interface AddStorageAccountWithAccountParameters {
    accessKey: string;
    name: string;
    suffix?: string;
}

// @public
export interface CapabilityInformation {
    readonly accountCount?: number;
    readonly maxAccountCount?: number;
    readonly migrationState?: boolean;
    readonly state?: SubscriptionState;
    readonly subscriptionId?: string;
}

// @public
export interface CheckNameAvailabilityParameters {
    name: string;
    type: "Microsoft.DataLakeAnalytics/accounts";
}

// @public
export interface ComputePolicies {
    createOrUpdate(resourceGroupName: string, accountName: string, computePolicyName: string, parameters: CreateOrUpdateComputePolicyParameters, options?: ComputePoliciesCreateOrUpdateOptionalParams): Promise<ComputePoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, computePolicyName: string, options?: ComputePoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, computePolicyName: string, options?: ComputePoliciesGetOptionalParams): Promise<ComputePoliciesGetResponse>;
    listByAccount(resourceGroupName: string, accountName: string, options?: ComputePoliciesListByAccountOptionalParams): PagedAsyncIterableIterator<ComputePolicy>;
    update(resourceGroupName: string, accountName: string, computePolicyName: string, options?: ComputePoliciesUpdateOptionalParams): Promise<ComputePoliciesUpdateResponse>;
}

// @public
export interface ComputePoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ComputePoliciesCreateOrUpdateResponse = ComputePolicy;

// @public
export interface ComputePoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ComputePoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ComputePoliciesGetResponse = ComputePolicy;

// @public
export interface ComputePoliciesListByAccountNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ComputePoliciesListByAccountNextResponse = ComputePolicyListResult;

// @public
export interface ComputePoliciesListByAccountOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ComputePoliciesListByAccountResponse = ComputePolicyListResult;

// @public
export interface ComputePoliciesUpdateOptionalParams extends coreClient.OperationOptions {
    parameters?: UpdateComputePolicyParameters;
}

// @public
export type ComputePoliciesUpdateResponse = ComputePolicy;

// @public
export type ComputePolicy = SubResource & {
    readonly objectId?: string;
    readonly objectType?: AADObjectType;
    readonly maxDegreeOfParallelismPerJob?: number;
    readonly minPriorityPerJob?: number;
};

// @public
export interface ComputePolicyListResult {
    readonly nextLink?: string;
    readonly value?: ComputePolicy[];
}

// @public
export interface CreateComputePolicyWithAccountParameters {
    maxDegreeOfParallelismPerJob?: number;
    minPriorityPerJob?: number;
    name: string;
    objectId: string;
    objectType: AADObjectType;
}

// @public
export interface CreateDataLakeAnalyticsAccountParameters {
    computePolicies?: CreateComputePolicyWithAccountParameters[];
    dataLakeStoreAccounts: AddDataLakeStoreWithAccountParameters[];
    defaultDataLakeStoreAccount: string;
    firewallAllowAzureIps?: FirewallAllowAzureIpsState;
    firewallRules?: CreateFirewallRuleWithAccountParameters[];
    firewallState?: FirewallState;
    location: string;
    maxDegreeOfParallelism?: number;
    maxDegreeOfParallelismPerJob?: number;
    maxJobCount?: number;
    minPriorityPerJob?: number;
    newTier?: TierType;
    queryStoreRetention?: number;
    storageAccounts?: AddStorageAccountWithAccountParameters[];
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface CreateFirewallRuleWithAccountParameters {
    endIpAddress: string;
    name: string;
    startIpAddress: string;
}

// @public
export interface CreateOrUpdateComputePolicyParameters {
    maxDegreeOfParallelismPerJob?: number;
    minPriorityPerJob?: number;
    objectId: string;
    objectType: AADObjectType;
}

// @public
export interface CreateOrUpdateFirewallRuleParameters {
    endIpAddress: string;
    startIpAddress: string;
}

// @public
export type DataLakeAnalyticsAccount = Resource & {
    readonly accountId?: string;
    readonly provisioningState?: DataLakeAnalyticsAccountStatus;
    readonly state?: DataLakeAnalyticsAccountState;
    readonly creationTime?: Date;
    readonly lastModifiedTime?: Date;
    readonly endpoint?: string;
    readonly defaultDataLakeStoreAccountType?: string;
    readonly defaultDataLakeStoreAccount?: string;
    readonly dataLakeStoreAccounts?: DataLakeStoreAccountInformation[];
    publicDataLakeStoreAccounts?: DataLakeStoreAccountInformation[];
    readonly storageAccounts?: StorageAccountInformation[];
    readonly computePolicies?: ComputePolicy[];
    readonly hiveMetastores?: HiveMetastore[];
    readonly virtualNetworkRules?: VirtualNetworkRule[];
    readonly firewallRules?: FirewallRule[];
    firewallState?: FirewallState;
    firewallAllowAzureIps?: FirewallAllowAzureIpsState;
    newTier?: TierType;
    readonly currentTier?: TierType;
    maxJobCount?: number;
    readonly maxActiveJobCountPerUser?: number;
    readonly maxQueuedJobCountPerUser?: number;
    readonly maxJobRunningTimeInMin?: number;
    readonly systemMaxJobCount?: number;
    maxDegreeOfParallelism?: number;
    readonly systemMaxDegreeOfParallelism?: number;
    maxDegreeOfParallelismPerJob?: number;
    readonly minPriorityPerJob?: number;
    queryStoreRetention?: number;
    readonly debugDataAccessLevel?: DebugDataAccessLevel;
};

// @public
export type DataLakeAnalyticsAccountBasic = Resource & {
    readonly accountId?: string;
    readonly provisioningState?: DataLakeAnalyticsAccountStatus;
    readonly state?: DataLakeAnalyticsAccountState;
    readonly creationTime?: Date;
    readonly lastModifiedTime?: Date;
    readonly endpoint?: string;
};

// @public
export interface DataLakeAnalyticsAccountListResult {
    readonly count?: number;
    readonly nextLink?: string;
    readonly value?: DataLakeAnalyticsAccountBasic[];
}

// @public (undocumented)
export class DataLakeAnalyticsAccountManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: DataLakeAnalyticsAccountManagementClientOptionalParams);
    // (undocumented)
    accounts: Accounts;
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    computePolicies: ComputePolicies;
    // (undocumented)
    dataLakeStoreAccounts: DataLakeStoreAccounts;
    // (undocumented)
    firewallRules: FirewallRules;
    // (undocumented)
    locations: Locations;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    storageAccounts: StorageAccounts;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface DataLakeAnalyticsAccountManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export type DataLakeAnalyticsAccountProperties = DataLakeAnalyticsAccountPropertiesBasic & {
    readonly defaultDataLakeStoreAccountType?: string;
    readonly defaultDataLakeStoreAccount?: string;
    readonly dataLakeStoreAccounts?: DataLakeStoreAccountInformation[];
    publicDataLakeStoreAccounts?: DataLakeStoreAccountInformation[];
    readonly storageAccounts?: StorageAccountInformation[];
    readonly computePolicies?: ComputePolicy[];
    readonly hiveMetastores?: HiveMetastore[];
    readonly virtualNetworkRules?: VirtualNetworkRule[];
    readonly firewallRules?: FirewallRule[];
    firewallState?: FirewallState;
    firewallAllowAzureIps?: FirewallAllowAzureIpsState;
    newTier?: TierType;
    readonly currentTier?: TierType;
    maxJobCount?: number;
    readonly maxActiveJobCountPerUser?: number;
    readonly maxQueuedJobCountPerUser?: number;
    readonly maxJobRunningTimeInMin?: number;
    readonly systemMaxJobCount?: number;
    maxDegreeOfParallelism?: number;
    readonly systemMaxDegreeOfParallelism?: number;
    maxDegreeOfParallelismPerJob?: number;
    readonly minPriorityPerJob?: number;
    queryStoreRetention?: number;
    readonly debugDataAccessLevel?: DebugDataAccessLevel;
};

// @public
export interface DataLakeAnalyticsAccountPropertiesBasic {
    readonly accountId?: string;
    readonly creationTime?: Date;
    readonly endpoint?: string;
    readonly lastModifiedTime?: Date;
    readonly provisioningState?: DataLakeAnalyticsAccountStatus;
    readonly state?: DataLakeAnalyticsAccountState;
}

// @public
export type DataLakeAnalyticsAccountState = "Active" | "Suspended";

// @public
export type DataLakeAnalyticsAccountStatus = "Failed" | "Creating" | "Running" | "Succeeded" | "Patching" | "Suspending" | "Resuming" | "Deleting" | "Deleted" | "Undeleting" | "Canceled";

// @public
export type DataLakeStoreAccountInformation = SubResource & {
    readonly suffix?: string;
};

// @public
export interface DataLakeStoreAccountInformationListResult {
    readonly nextLink?: string;
    readonly value?: DataLakeStoreAccountInformation[];
}

// @public
export interface DataLakeStoreAccounts {
    add(resourceGroupName: string, accountName: string, dataLakeStoreAccountName: string, options?: DataLakeStoreAccountsAddOptionalParams): Promise<void>;
    delete(resourceGroupName: string, accountName: string, dataLakeStoreAccountName: string, options?: DataLakeStoreAccountsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, dataLakeStoreAccountName: string, options?: DataLakeStoreAccountsGetOptionalParams): Promise<DataLakeStoreAccountsGetResponse>;
    listByAccount(resourceGroupName: string, accountName: string, options?: DataLakeStoreAccountsListByAccountOptionalParams): PagedAsyncIterableIterator<DataLakeStoreAccountInformation>;
}

// @public
export interface DataLakeStoreAccountsAddOptionalParams extends coreClient.OperationOptions {
    parameters?: AddDataLakeStoreParameters;
}

// @public
export interface DataLakeStoreAccountsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DataLakeStoreAccountsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DataLakeStoreAccountsGetResponse = DataLakeStoreAccountInformation;

// @public
export interface DataLakeStoreAccountsListByAccountNextOptionalParams extends coreClient.OperationOptions {
    count?: boolean;
    filter?: string;
    orderby?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export type DataLakeStoreAccountsListByAccountNextResponse = DataLakeStoreAccountInformationListResult;

// @public
export interface DataLakeStoreAccountsListByAccountOptionalParams extends coreClient.OperationOptions {
    count?: boolean;
    filter?: string;
    orderby?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export type DataLakeStoreAccountsListByAccountResponse = DataLakeStoreAccountInformationListResult;

// @public
export type DebugDataAccessLevel = "All" | "Customer" | "None";

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export type FirewallAllowAzureIpsState = "Enabled" | "Disabled";

// @public
export type FirewallRule = SubResource & {
    readonly startIpAddress?: string;
    readonly endIpAddress?: string;
};

// @public
export interface FirewallRuleListResult {
    readonly nextLink?: string;
    readonly value?: FirewallRule[];
}

// @public
export interface FirewallRules {
    createOrUpdate(resourceGroupName: string, accountName: string, firewallRuleName: string, parameters: CreateOrUpdateFirewallRuleParameters, options?: FirewallRulesCreateOrUpdateOptionalParams): Promise<FirewallRulesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, firewallRuleName: string, options?: FirewallRulesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, firewallRuleName: string, options?: FirewallRulesGetOptionalParams): Promise<FirewallRulesGetResponse>;
    listByAccount(resourceGroupName: string, accountName: string, options?: FirewallRulesListByAccountOptionalParams): PagedAsyncIterableIterator<FirewallRule>;
    update(resourceGroupName: string, accountName: string, firewallRuleName: string, options?: FirewallRulesUpdateOptionalParams): Promise<FirewallRulesUpdateResponse>;
}

// @public
export interface FirewallRulesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FirewallRulesCreateOrUpdateResponse = FirewallRule;

// @public
export interface FirewallRulesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface FirewallRulesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FirewallRulesGetResponse = FirewallRule;

// @public
export interface FirewallRulesListByAccountNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FirewallRulesListByAccountNextResponse = FirewallRuleListResult;

// @public
export interface FirewallRulesListByAccountOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FirewallRulesListByAccountResponse = FirewallRuleListResult;

// @public
export interface FirewallRulesUpdateOptionalParams extends coreClient.OperationOptions {
    parameters?: UpdateFirewallRuleParameters;
}

// @public
export type FirewallRulesUpdateResponse = FirewallRule;

// @public
export type FirewallState = "Enabled" | "Disabled";

// @public (undocumented)
export type HiveMetastore = SubResource & {
    readonly serverUri?: string;
    readonly databaseName?: string;
    readonly runtimeVersion?: string;
    readonly userName?: string;
    readonly password?: string;
    readonly nestedResourceProvisioningState?: NestedResourceProvisioningState;
};

// @public
export interface HiveMetastoreListResult {
    readonly nextLink?: string;
    readonly value?: HiveMetastore[];
}

// @public
export enum KnownAADObjectType {
    // (undocumented)
    Group = "Group",
    // (undocumented)
    ServicePrincipal = "ServicePrincipal",
    // (undocumented)
    User = "User"
}

// @public
export enum KnownOperationOrigin {
    // (undocumented)
    System = "system",
    // (undocumented)
    User = "user",
    // (undocumented)
    UserSystem = "user,system"
}

// @public
export enum KnownSubscriptionState {
    // (undocumented)
    Deleted = "Deleted",
    // (undocumented)
    Registered = "Registered",
    // (undocumented)
    Suspended = "Suspended",
    // (undocumented)
    Unregistered = "Unregistered",
    // (undocumented)
    Warned = "Warned"
}

// @public
export interface Locations {
    getCapability(location: string, options?: LocationsGetCapabilityOptionalParams): Promise<LocationsGetCapabilityResponse>;
}

// @public
export interface LocationsGetCapabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationsGetCapabilityResponse = CapabilityInformation;

// @public
export interface NameAvailabilityInformation {
    readonly message?: string;
    readonly nameAvailable?: boolean;
    readonly reason?: string;
}

// @public
export type NestedResourceProvisioningState = "Succeeded" | "Canceled" | "Failed";

// @public
export interface Operation {
    readonly display?: OperationDisplay;
    readonly name?: string;
    readonly origin?: OperationOrigin;
    readonly properties?: OperationMetaPropertyInfo;
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationListResult {
    readonly nextLink?: string;
    readonly value?: Operation[];
}

// @public (undocumented)
export interface OperationMetaLogSpecification {
    blobDuration?: string;
    displayName?: string;
    name?: string;
}

// @public (undocumented)
export interface OperationMetaMetricAvailabilitiesSpecification {
    blobDuration?: string;
    timeGrain?: string;
}

// @public (undocumented)
export interface OperationMetaMetricSpecification {
    aggregationType?: string;
    availabilities?: OperationMetaMetricAvailabilitiesSpecification[];
    displayDescription?: string;
    displayName?: string;
    name?: string;
    unit?: string;
}

// @public (undocumented)
export interface OperationMetaPropertyInfo {
    serviceSpecification?: OperationMetaServiceSpecification;
}

// @public (undocumented)
export interface OperationMetaServiceSpecification {
    logSpecifications?: OperationMetaLogSpecification[];
    metricSpecifications?: OperationMetaMetricSpecification[];
}

// @public
export type OperationOrigin = string;

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): Promise<OperationsListResponse>;
}

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface Resource {
    readonly id?: string;
    readonly location?: string;
    readonly name?: string;
    readonly tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export interface SasTokenInformation {
    readonly accessToken?: string;
}

// @public
export interface SasTokenInformationListResult {
    readonly nextLink?: string;
    readonly value?: SasTokenInformation[];
}

// @public
export type StorageAccountInformation = SubResource & {
    readonly suffix?: string;
};

// @public
export interface StorageAccountInformationListResult {
    readonly nextLink?: string;
    readonly value?: StorageAccountInformation[];
}

// @public
export interface StorageAccounts {
    add(resourceGroupName: string, accountName: string, storageAccountName: string, parameters: AddStorageAccountParameters, options?: StorageAccountsAddOptionalParams): Promise<void>;
    delete(resourceGroupName: string, accountName: string, storageAccountName: string, options?: StorageAccountsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, storageAccountName: string, options?: StorageAccountsGetOptionalParams): Promise<StorageAccountsGetResponse>;
    getStorageContainer(resourceGroupName: string, accountName: string, storageAccountName: string, containerName: string, options?: StorageAccountsGetStorageContainerOptionalParams): Promise<StorageAccountsGetStorageContainerResponse>;
    listByAccount(resourceGroupName: string, accountName: string, options?: StorageAccountsListByAccountOptionalParams): PagedAsyncIterableIterator<StorageAccountInformation>;
    listSasTokens(resourceGroupName: string, accountName: string, storageAccountName: string, containerName: string, options?: StorageAccountsListSasTokensOptionalParams): PagedAsyncIterableIterator<SasTokenInformation>;
    listStorageContainers(resourceGroupName: string, accountName: string, storageAccountName: string, options?: StorageAccountsListStorageContainersOptionalParams): PagedAsyncIterableIterator<StorageContainer>;
    update(resourceGroupName: string, accountName: string, storageAccountName: string, options?: StorageAccountsUpdateOptionalParams): Promise<void>;
}

// @public
export interface StorageAccountsAddOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface StorageAccountsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface StorageAccountsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsGetResponse = StorageAccountInformation;

// @public
export interface StorageAccountsGetStorageContainerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsGetStorageContainerResponse = StorageContainer;

// @public
export interface StorageAccountsListByAccountNextOptionalParams extends coreClient.OperationOptions {
    count?: boolean;
    filter?: string;
    orderby?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export type StorageAccountsListByAccountNextResponse = StorageAccountInformationListResult;

// @public
export interface StorageAccountsListByAccountOptionalParams extends coreClient.OperationOptions {
    count?: boolean;
    filter?: string;
    orderby?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export type StorageAccountsListByAccountResponse = StorageAccountInformationListResult;

// @public
export interface StorageAccountsListSasTokensNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListSasTokensNextResponse = SasTokenInformationListResult;

// @public
export interface StorageAccountsListSasTokensOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListSasTokensResponse = SasTokenInformationListResult;

// @public
export interface StorageAccountsListStorageContainersNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListStorageContainersNextResponse = StorageContainerListResult;

// @public
export interface StorageAccountsListStorageContainersOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountsListStorageContainersResponse = StorageContainerListResult;

// @public
export interface StorageAccountsUpdateOptionalParams extends coreClient.OperationOptions {
    parameters?: UpdateStorageAccountParameters;
}

// @public
export type StorageContainer = SubResource & {
    readonly lastModifiedTime?: Date;
};

// @public
export interface StorageContainerListResult {
    readonly nextLink?: string;
    readonly value?: StorageContainer[];
}

// @public
export interface SubResource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export type SubscriptionState = string;

// @public
export type TierType = "Consumption" | "Commitment_100AUHours" | "Commitment_500AUHours" | "Commitment_1000AUHours" | "Commitment_5000AUHours" | "Commitment_10000AUHours" | "Commitment_50000AUHours" | "Commitment_100000AUHours" | "Commitment_500000AUHours";

// @public
export interface UpdateComputePolicyParameters {
    maxDegreeOfParallelismPerJob?: number;
    minPriorityPerJob?: number;
    objectId?: string;
    objectType?: AADObjectType;
}

// @public
export interface UpdateComputePolicyWithAccountParameters {
    maxDegreeOfParallelismPerJob?: number;
    minPriorityPerJob?: number;
    name: string;
    objectId?: string;
    objectType?: AADObjectType;
}

// @public
export interface UpdateDataLakeAnalyticsAccountParameters {
    computePolicies?: UpdateComputePolicyWithAccountParameters[];
    dataLakeStoreAccounts?: UpdateDataLakeStoreWithAccountParameters[];
    firewallAllowAzureIps?: FirewallAllowAzureIpsState;
    firewallRules?: UpdateFirewallRuleWithAccountParameters[];
    firewallState?: FirewallState;
    maxDegreeOfParallelism?: number;
    maxDegreeOfParallelismPerJob?: number;
    maxJobCount?: number;
    minPriorityPerJob?: number;
    newTier?: TierType;
    queryStoreRetention?: number;
    storageAccounts?: UpdateStorageAccountWithAccountParameters[];
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface UpdateDataLakeStoreWithAccountParameters {
    name: string;
    suffix?: string;
}

// @public
export interface UpdateFirewallRuleParameters {
    endIpAddress?: string;
    startIpAddress?: string;
}

// @public
export interface UpdateFirewallRuleWithAccountParameters {
    endIpAddress?: string;
    name: string;
    startIpAddress?: string;
}

// @public
export interface UpdateStorageAccountParameters {
    accessKey?: string;
    suffix?: string;
}

// @public
export interface UpdateStorageAccountWithAccountParameters {
    accessKey?: string;
    name: string;
    suffix?: string;
}

// @public
export type VirtualNetworkRule = SubResource & {
    readonly subnetId?: string;
    readonly virtualNetworkRuleState?: VirtualNetworkRuleState;
};

// @public
export interface VirtualNetworkRuleListResult {
    readonly nextLink?: string;
    readonly value?: VirtualNetworkRule[];
}

// @public
export type VirtualNetworkRuleState = "Active" | "NetworkSourceDeleted" | "Failed";

// (No @packageDocumentation comment for this package)

```
