## API Report File for "@azure/arm-postgresql-flexible"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export interface Backup {
    backupRetentionDays?: number;
    readonly earliestRestoreDate?: Date;
    geoRedundantBackup?: GeoRedundantBackupEnum;
}

// @public
export interface CapabilitiesListResult {
    readonly nextLink?: string;
    readonly value?: CapabilityProperties[];
}

// @public
export interface CapabilityProperties {
    readonly geoBackupSupported?: boolean;
    readonly status?: string;
    readonly supportedFlexibleServerEditions?: FlexibleServerEditionCapability[];
    readonly supportedHyperscaleNodeEditions?: HyperscaleNodeEditionCapability[];
    readonly zone?: string;
    readonly zoneRedundantHaAndGeoBackupSupported?: boolean;
    readonly zoneRedundantHaSupported?: boolean;
}

// @public
export interface CheckNameAvailability {
    execute(nameAvailabilityRequest: NameAvailabilityRequest, options?: CheckNameAvailabilityExecuteOptionalParams): Promise<CheckNameAvailabilityExecuteResponse>;
}

// @public
export interface CheckNameAvailabilityExecuteOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CheckNameAvailabilityExecuteResponse = NameAvailability;

// @public
export interface CloudError {
    error?: ErrorResponse;
}

// @public
export interface Configuration extends ProxyResource {
    readonly allowedValues?: string;
    readonly dataType?: ConfigurationDataType;
    readonly defaultValue?: string;
    readonly description?: string;
    readonly documentationLink?: string;
    readonly isConfigPendingRestart?: boolean;
    readonly isDynamicConfig?: boolean;
    readonly isReadOnly?: boolean;
    source?: string;
    readonly systemData?: SystemData;
    readonly unit?: string;
    value?: string;
}

// @public
export type ConfigurationDataType = string;

// @public
export interface ConfigurationListResult {
    nextLink?: string;
    value?: Configuration[];
}

// @public
export interface Configurations {
    beginPut(resourceGroupName: string, serverName: string, configurationName: string, parameters: Configuration, options?: ConfigurationsPutOptionalParams): Promise<PollerLike<PollOperationState<ConfigurationsPutResponse>, ConfigurationsPutResponse>>;
    beginPutAndWait(resourceGroupName: string, serverName: string, configurationName: string, parameters: Configuration, options?: ConfigurationsPutOptionalParams): Promise<ConfigurationsPutResponse>;
    beginUpdate(resourceGroupName: string, serverName: string, configurationName: string, parameters: Configuration, options?: ConfigurationsUpdateOptionalParams): Promise<PollerLike<PollOperationState<ConfigurationsUpdateResponse>, ConfigurationsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, serverName: string, configurationName: string, parameters: Configuration, options?: ConfigurationsUpdateOptionalParams): Promise<ConfigurationsUpdateResponse>;
    get(resourceGroupName: string, serverName: string, configurationName: string, options?: ConfigurationsGetOptionalParams): Promise<ConfigurationsGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: ConfigurationsListByServerOptionalParams): PagedAsyncIterableIterator<Configuration>;
}

// @public
export interface ConfigurationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConfigurationsGetResponse = Configuration;

// @public
export interface ConfigurationsListByServerNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConfigurationsListByServerNextResponse = ConfigurationListResult;

// @public
export interface ConfigurationsListByServerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConfigurationsListByServerResponse = ConfigurationListResult;

// @public
export interface ConfigurationsPutOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConfigurationsPutResponse = Configuration;

// @public
export interface ConfigurationsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConfigurationsUpdateResponse = Configuration;

// @public
export type CreatedByType = string;

// @public
export type CreateMode = string;

// @public
export type CreateModeForUpdate = string;

// @public
export interface Database extends ProxyResource {
    charset?: string;
    collation?: string;
    readonly systemData?: SystemData;
}

// @public
export interface DatabaseListResult {
    nextLink?: string;
    value?: Database[];
}

// @public
export interface Databases {
    beginCreate(resourceGroupName: string, serverName: string, databaseName: string, parameters: Database, options?: DatabasesCreateOptionalParams): Promise<PollerLike<PollOperationState<DatabasesCreateResponse>, DatabasesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, serverName: string, databaseName: string, parameters: Database, options?: DatabasesCreateOptionalParams): Promise<DatabasesCreateResponse>;
    beginDelete(resourceGroupName: string, serverName: string, databaseName: string, options?: DatabasesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, serverName: string, databaseName: string, options?: DatabasesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, serverName: string, databaseName: string, options?: DatabasesGetOptionalParams): Promise<DatabasesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: DatabasesListByServerOptionalParams): PagedAsyncIterableIterator<Database>;
}

// @public
export interface DatabasesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DatabasesCreateResponse = Database;

// @public
export interface DatabasesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DatabasesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DatabasesGetResponse = Database;

// @public
export interface DatabasesListByServerNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DatabasesListByServerNextResponse = DatabaseListResult;

// @public
export interface DatabasesListByServerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DatabasesListByServerResponse = DatabaseListResult;

// @public
export interface DelegatedSubnetUsage {
    readonly subnetName?: string;
    readonly usage?: number;
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorResponse {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorResponse[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export type FailoverMode = string;

// @public
export interface FirewallRule extends ProxyResource {
    endIpAddress: string;
    startIpAddress: string;
    readonly systemData?: SystemData;
}

// @public
export interface FirewallRuleListResult {
    nextLink?: string;
    value?: FirewallRule[];
}

// @public
export interface FirewallRules {
    beginCreateOrUpdate(resourceGroupName: string, serverName: string, firewallRuleName: string, parameters: FirewallRule, options?: FirewallRulesCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<FirewallRulesCreateOrUpdateResponse>, FirewallRulesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, serverName: string, firewallRuleName: string, parameters: FirewallRule, options?: FirewallRulesCreateOrUpdateOptionalParams): Promise<FirewallRulesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, serverName: string, firewallRuleName: string, options?: FirewallRulesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, serverName: string, firewallRuleName: string, options?: FirewallRulesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, serverName: string, firewallRuleName: string, options?: FirewallRulesGetOptionalParams): Promise<FirewallRulesGetResponse>;
    listByServer(resourceGroupName: string, serverName: string, options?: FirewallRulesListByServerOptionalParams): PagedAsyncIterableIterator<FirewallRule>;
}

// @public
export interface FirewallRulesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FirewallRulesCreateOrUpdateResponse = FirewallRule;

// @public
export interface FirewallRulesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface FirewallRulesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FirewallRulesGetResponse = FirewallRule;

// @public
export interface FirewallRulesListByServerNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FirewallRulesListByServerNextResponse = FirewallRuleListResult;

// @public
export interface FirewallRulesListByServerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FirewallRulesListByServerResponse = FirewallRuleListResult;

// @public
export interface FlexibleServerEditionCapability {
    readonly name?: string;
    readonly status?: string;
    readonly supportedServerVersions?: ServerVersionCapability[];
    readonly supportedStorageEditions?: StorageEditionCapability[];
}

// @public
export type GeoRedundantBackupEnum = string;

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface GetPrivateDnsZoneSuffix {
    execute(options?: GetPrivateDnsZoneSuffixExecuteOptionalParams): Promise<GetPrivateDnsZoneSuffixExecuteResponse>;
}

// @public
export interface GetPrivateDnsZoneSuffixExecuteOptionalParams extends coreClient.OperationOptions {
}

// @public
export type GetPrivateDnsZoneSuffixExecuteResponse = {
    body: string;
};

// @public
export interface HighAvailability {
    mode?: HighAvailabilityMode;
    standbyAvailabilityZone?: string;
    readonly state?: ServerHAState;
}

// @public
export type HighAvailabilityMode = string;

// @public
export interface HyperscaleNodeEditionCapability {
    readonly name?: string;
    readonly status?: string;
    readonly supportedNodeTypes?: NodeTypeCapability[];
    readonly supportedServerVersions?: ServerVersionCapability[];
    readonly supportedStorageEditions?: StorageEditionCapability[];
}

// @public
export enum KnownConfigurationDataType {
    Boolean = "Boolean",
    Enumeration = "Enumeration",
    Integer = "Integer",
    Numeric = "Numeric"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownCreateMode {
    Create = "Create",
    Default = "Default",
    PointInTimeRestore = "PointInTimeRestore",
    Update = "Update"
}

// @public
export enum KnownCreateModeForUpdate {
    Default = "Default",
    Update = "Update"
}

// @public
export enum KnownFailoverMode {
    ForcedFailover = "ForcedFailover",
    ForcedSwitchover = "ForcedSwitchover",
    PlannedFailover = "PlannedFailover",
    PlannedSwitchover = "PlannedSwitchover"
}

// @public
export enum KnownGeoRedundantBackupEnum {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownHighAvailabilityMode {
    Disabled = "Disabled",
    ZoneRedundant = "ZoneRedundant"
}

// @public
export enum KnownOperationOrigin {
    NotSpecified = "NotSpecified",
    System = "system",
    User = "user"
}

// @public
export enum KnownReason {
    AlreadyExists = "AlreadyExists",
    Invalid = "Invalid"
}

// @public
export enum KnownServerHAState {
    CreatingStandby = "CreatingStandby",
    FailingOver = "FailingOver",
    Healthy = "Healthy",
    NotEnabled = "NotEnabled",
    RemovingStandby = "RemovingStandby",
    ReplicatingData = "ReplicatingData"
}

// @public
export enum KnownServerPublicNetworkAccessState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownServerState {
    Disabled = "Disabled",
    Dropping = "Dropping",
    Ready = "Ready",
    Starting = "Starting",
    Stopped = "Stopped",
    Stopping = "Stopping",
    Updating = "Updating"
}

// @public
export enum KnownServerVersion {
    Eleven = "11",
    Thirteen = "13",
    Twelve = "12"
}

// @public
export enum KnownSkuTier {
    Burstable = "Burstable",
    GeneralPurpose = "GeneralPurpose",
    MemoryOptimized = "MemoryOptimized"
}

// @public
export interface LocationBasedCapabilities {
    listExecute(locationName: string, options?: LocationBasedCapabilitiesExecuteOptionalParams): PagedAsyncIterableIterator<CapabilityProperties>;
}

// @public
export interface LocationBasedCapabilitiesExecuteNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationBasedCapabilitiesExecuteNextResponse = CapabilitiesListResult;

// @public
export interface LocationBasedCapabilitiesExecuteOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationBasedCapabilitiesExecuteResponse = CapabilitiesListResult;

// @public
export interface MaintenanceWindow {
    customWindow?: string;
    dayOfWeek?: number;
    startHour?: number;
    startMinute?: number;
}

// @public
export interface NameAvailability {
    readonly message?: string;
    readonly name?: string;
    readonly nameAvailable?: boolean;
    readonly reason?: Reason;
    readonly type?: string;
}

// @public
export interface NameAvailabilityRequest {
    name: string;
    type?: string;
}

// @public
export interface Network {
    delegatedSubnetResourceId?: string;
    privateDnsZoneArmResourceId?: string;
    readonly publicNetworkAccess?: ServerPublicNetworkAccessState;
}

// @public
export interface NodeTypeCapability {
    readonly name?: string;
    readonly nodeType?: string;
    readonly status?: string;
}

// @public
export interface Operation {
    readonly display?: OperationDisplay;
    isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: OperationOrigin;
    readonly properties?: {
        [propertyName: string]: Record<string, unknown>;
    };
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationListResult {
    nextLink?: string;
    value?: Operation[];
}

// @public
export type OperationOrigin = string;

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): Promise<OperationsListResponse>;
}

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public (undocumented)
export class PostgreSQLManagementFlexibleServerClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: PostgreSQLManagementFlexibleServerClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    checkNameAvailability: CheckNameAvailability;
    // (undocumented)
    configurations: Configurations;
    // (undocumented)
    databases: Databases;
    // (undocumented)
    firewallRules: FirewallRules;
    // (undocumented)
    getPrivateDnsZoneSuffix: GetPrivateDnsZoneSuffix;
    // (undocumented)
    locationBasedCapabilities: LocationBasedCapabilities;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    servers: Servers;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    virtualNetworkSubnetUsage: VirtualNetworkSubnetUsage;
}

// @public
export interface PostgreSQLManagementFlexibleServerClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface ProxyResource extends Resource {
}

// @public
export type Reason = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface RestartParameter {
    failoverMode?: FailoverMode;
    restartWithFailover?: boolean;
}

// @public
export interface Server extends TrackedResource {
    administratorLogin?: string;
    administratorLoginPassword?: string;
    availabilityZone?: string;
    backup?: Backup;
    createMode?: CreateMode;
    readonly fullyQualifiedDomainName?: string;
    highAvailability?: HighAvailability;
    maintenanceWindow?: MaintenanceWindow;
    readonly minorVersion?: string;
    network?: Network;
    pointInTimeUTC?: Date;
    sku?: Sku;
    sourceServerResourceId?: string;
    readonly state?: ServerState;
    storage?: Storage_2;
    readonly systemData?: SystemData;
    version?: ServerVersion;
}

// @public
export interface ServerForUpdate {
    administratorLoginPassword?: string;
    backup?: Backup;
    createMode?: CreateModeForUpdate;
    highAvailability?: HighAvailability;
    location?: string;
    maintenanceWindow?: MaintenanceWindow;
    sku?: Sku;
    storage?: Storage_2;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type ServerHAState = string;

// @public
export interface ServerListResult {
    nextLink?: string;
    value?: Server[];
}

// @public
export type ServerPublicNetworkAccessState = string;

// @public
export interface Servers {
    beginCreate(resourceGroupName: string, serverName: string, parameters: Server, options?: ServersCreateOptionalParams): Promise<PollerLike<PollOperationState<ServersCreateResponse>, ServersCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, serverName: string, parameters: Server, options?: ServersCreateOptionalParams): Promise<ServersCreateResponse>;
    beginDelete(resourceGroupName: string, serverName: string, options?: ServersDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, serverName: string, options?: ServersDeleteOptionalParams): Promise<void>;
    beginRestart(resourceGroupName: string, serverName: string, options?: ServersRestartOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginRestartAndWait(resourceGroupName: string, serverName: string, options?: ServersRestartOptionalParams): Promise<void>;
    beginStart(resourceGroupName: string, serverName: string, options?: ServersStartOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginStartAndWait(resourceGroupName: string, serverName: string, options?: ServersStartOptionalParams): Promise<void>;
    beginStop(resourceGroupName: string, serverName: string, options?: ServersStopOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginStopAndWait(resourceGroupName: string, serverName: string, options?: ServersStopOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, serverName: string, parameters: ServerForUpdate, options?: ServersUpdateOptionalParams): Promise<PollerLike<PollOperationState<ServersUpdateResponse>, ServersUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, serverName: string, parameters: ServerForUpdate, options?: ServersUpdateOptionalParams): Promise<ServersUpdateResponse>;
    get(resourceGroupName: string, serverName: string, options?: ServersGetOptionalParams): Promise<ServersGetResponse>;
    list(options?: ServersListOptionalParams): PagedAsyncIterableIterator<Server>;
    listByResourceGroup(resourceGroupName: string, options?: ServersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Server>;
}

// @public
export interface ServersCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ServersCreateResponse = Server;

// @public
export interface ServersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ServersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServersGetResponse = Server;

// @public
export interface ServersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServersListByResourceGroupNextResponse = ServerListResult;

// @public
export interface ServersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServersListByResourceGroupResponse = ServerListResult;

// @public
export interface ServersListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServersListNextResponse = ServerListResult;

// @public
export interface ServersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ServersListResponse = ServerListResult;

// @public
export interface ServersRestartOptionalParams extends coreClient.OperationOptions {
    parameters?: RestartParameter;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ServersStartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ServersStopOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ServerState = string;

// @public
export interface ServersUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ServersUpdateResponse = Server;

// @public
export type ServerVersion = string;

// @public
export interface ServerVersionCapability {
    readonly name?: string;
    readonly status?: string;
    readonly supportedVcores?: VcoreCapability[];
}

// @public
export interface Sku {
    name: string;
    tier: SkuTier;
}

// @public
export type SkuTier = string;

// @public
interface Storage_2 {
    storageSizeGB?: number;
}
export { Storage_2 as Storage }

// @public
export interface StorageEditionCapability {
    readonly name?: string;
    readonly status?: string;
    readonly supportedStorageMB?: StorageMBCapability[];
}

// @public
export interface StorageMBCapability {
    readonly name?: string;
    readonly status?: string;
    readonly storageSizeMB?: number;
    readonly supportedIops?: number;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface VcoreCapability {
    readonly name?: string;
    readonly status?: string;
    readonly supportedIops?: number;
    readonly supportedMemoryPerVcoreMB?: number;
    readonly vCores?: number;
}

// @public
export interface VirtualNetworkSubnetUsage {
    execute(locationName: string, parameters: VirtualNetworkSubnetUsageParameter, options?: VirtualNetworkSubnetUsageExecuteOptionalParams): Promise<VirtualNetworkSubnetUsageExecuteResponse>;
}

// @public
export interface VirtualNetworkSubnetUsageExecuteOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VirtualNetworkSubnetUsageExecuteResponse = VirtualNetworkSubnetUsageResult;

// @public
export interface VirtualNetworkSubnetUsageParameter {
    virtualNetworkArmResourceId?: string;
}

// @public
export interface VirtualNetworkSubnetUsageResult {
    readonly delegatedSubnetsUsage?: DelegatedSubnetUsage[];
}

// (No @packageDocumentation comment for this package)

```
