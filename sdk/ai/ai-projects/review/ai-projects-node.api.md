## API Report File for "@azure/ai-projects"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AgentsClient } from '@azure/ai-agents';
import type { AzureOpenAI } from 'openai';
import { ClientOptions } from '@azure-rest/core-client';
import { OperationOptions } from '@azure-rest/core-client';
import type { Pipeline } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public
export class AIProjectClient {
    constructor(endpointParam: string, credential: TokenCredential, options?: AIProjectClientOptionalParams);
    get agents(): AgentsClient;
    readonly connections: ConnectionsOperations;
    readonly datasets: DatasetsOperations;
    readonly deployments: DeploymentsOperations;
    static fromEndpoint(endpoint: string, credential: TokenCredential, options?: AIProjectClientOptionalParams): AIProjectClient;
    getAzureOpenAIClient(options?: GetAzureOpenAIClientOptions): Promise<AzureOpenAI>;
    getEndpointUrl(): string;
    readonly indexes: IndexesOperations;
    readonly pipeline: Pipeline;
    readonly telemetry: TelemetryOperations;
}

// @public
export interface AIProjectClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface ApiKeyCredentials extends BaseCredentials {
    readonly apiKey?: string;
    readonly type: "ApiKey";
}

// @public
export interface AssetCredentialResponse {
    blobReference: BlobReference;
}

// @public
export interface AzureAISearchIndex extends Index {
    connectionName: string;
    fieldMapping?: FieldMapping;
    indexName: string;
    type: "AzureSearch";
}

// @public
export interface AzureOpenAIClientOptions {
    apiVersion?: string;
    connectionName?: string;
    connectionOptions?: ConnectionsGetOptionalParams;
    connectionSecretOptions?: ConnectionsGetWithCredentialsOptionalParams;
}

// @public
export interface BaseCredentials {
    readonly type: CredentialType;
}

// @public
export type BaseCredentialsUnion = ApiKeyCredentials | EntraIDCredentials | CustomCredential | SASCredentials | NoAuthenticationCredentials | BaseCredentials;

// @public
export interface BlobReference {
    blobUri: string;
    credential: SasCredential;
    storageAccountArmId: string;
}

// @public
export interface Connection {
    readonly credentials: BaseCredentialsUnion;
    readonly id: string;
    readonly isDefault: boolean;
    readonly metadata: Record<string, string>;
    readonly name: string;
    readonly target: string;
    readonly type: ConnectionType;
}

// @public
export interface ConnectionsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface ConnectionsGetWithCredentialsOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface ConnectionsListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    connectionType?: ConnectionType;
    defaultConnection?: boolean;
}

// @public
export interface ConnectionsOperations {
    get: (name: string, includeCredentials?: boolean, options?: ConnectionsGetOptionalParams) => Promise<Connection>;
    getDefault: (connectionType: ConnectionType, includeCredentials?: boolean) => Promise<Connection>;
    getWithCredentials: (name: string, options?: ConnectionsGetWithCredentialsOptionalParams) => Promise<Connection>;
    list: (options?: ConnectionsListOptionalParams) => PagedAsyncIterableIterator<Connection>;
}

// @public
export type ConnectionType = "AzureOpenAI" | "AzureBlob" | "AzureStorageAccount" | "CognitiveSearch" | "CosmosDB" | "ApiKey" | "AppConfig" | "AppInsights" | "CustomKeys";

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CosmosDBIndex extends Index {
    connectionName: string;
    containerName: string;
    databaseName: string;
    embeddingConfiguration: EmbeddingConfiguration;
    fieldMapping: FieldMapping;
    type: "CosmosDBNoSqlVectorStore";
}

// @public
export type CredentialType = "ApiKey" | "AAD" | "SAS" | "CustomKeys" | "None";

// @public
export interface CustomCredential extends BaseCredentials {
    readonly keys: Record<string, string>;
    readonly type: "CustomKeys";
}

// @public
export interface DatasetsCreateOrUpdateOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsDeleteOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsGetCredentialsOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsGetOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsListOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsListVersionsOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsOperations {
    createOrUpdate: (name: string, version: string, datasetVersion: DatasetVersionUnion, options?: DatasetsCreateOrUpdateOptionalParams) => Promise<DatasetVersionUnion>;
    delete: (name: string, version: string, options?: DatasetsDeleteOptionalParams) => Promise<void>;
    get: (name: string, version: string, options?: DatasetsGetOptionalParams) => Promise<DatasetVersionUnion>;
    getCredentials: (name: string, version: string, options?: DatasetsGetCredentialsOptionalParams) => Promise<AssetCredentialResponse>;
    list: (options?: DatasetsListOptionalParams) => PagedAsyncIterableIterator<DatasetVersionUnion>;
    listVersions: (name: string, options?: DatasetsListVersionsOptionalParams) => PagedAsyncIterableIterator<DatasetVersionUnion>;
    pendingUpload: (name: string, version: string, pendingUploadRequest: PendingUploadRequest, options?: DatasetsPendingUploadOptionalParams) => Promise<PendingUploadResponse>;
    uploadFile: (name: string, version: string, filePath: string, options?: DatasetUploadOptions) => Promise<DatasetVersionUnion>;
    uploadFolder: (name: string, version: string, folderPath: string, options?: DatasetUploadOptions) => Promise<DatasetVersionUnion>;
}

// @public
export interface DatasetsPendingUploadOptionalParams extends OperationOptions {
}

// @public
export type DatasetType = "uri_file" | "uri_folder";

// @public
export interface DatasetUploadOptions {
    connectionName?: string;
    filePattern?: RegExp;
}

// @public
export interface DatasetVersion {
    connectionName?: string;
    dataUri: string;
    description?: string;
    readonly id?: string;
    readonly isReference?: boolean;
    readonly name: string;
    tags?: Record<string, string>;
    type: DatasetType;
    readonly version: string;
}

// @public
export type DatasetVersionUnion = FileDatasetVersion | FolderDatasetVersion | DatasetVersion;

// @public
export interface Deployment {
    readonly name: string;
    type: DeploymentType;
}

// @public
export interface DeploymentsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DeploymentsListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    deploymentType?: DeploymentType;
    modelName?: string;
    modelPublisher?: string;
}

// @public
export interface DeploymentsOperations {
    get: (name: string, options?: DeploymentsGetOptionalParams) => Promise<DeploymentUnion>;
    list: (options?: DeploymentsListOptionalParams) => PagedAsyncIterableIterator<DeploymentUnion>;
}

// @public
export type DeploymentType = "ModelDeployment";

// @public
export type DeploymentUnion = ModelDeployment | Deployment;

// @public
export interface EmbeddingConfiguration {
    embeddingField: string;
    modelDeploymentName: string;
}

// @public
export interface EntraIDCredentials extends BaseCredentials {
    readonly type: "AAD";
}

// @public
export interface FieldMapping {
    contentFields: string[];
    filepathField?: string;
    metadataFields?: string[];
    titleField?: string;
    urlField?: string;
    vectorFields?: string[];
}

// @public
export interface FileDatasetVersion extends DatasetVersion {
    type: "uri_file";
}

// @public
export interface FolderDatasetVersion extends DatasetVersion {
    type: "uri_folder";
}

// @public
export interface GetAzureOpenAIClientOptions extends AzureOpenAIClientOptions {
}

// @public
export interface Index {
    description?: string;
    readonly id?: string;
    readonly name: string;
    tags?: Record<string, string>;
    type: IndexType;
    readonly version: string;
}

// @public
export interface IndexesCreateOrUpdateOptionalParams extends OperationOptions {
}

// @public
export interface IndexesDeleteOptionalParams extends OperationOptions {
}

// @public
export interface IndexesGetOptionalParams extends OperationOptions {
}

// @public
export interface IndexesListOptionalParams extends OperationOptions {
}

// @public
export interface IndexesListVersionsOptionalParams extends OperationOptions {
}

// @public
export interface IndexesOperations {
    createOrUpdate: (name: string, version: string, index: IndexUnion, options?: IndexesCreateOrUpdateOptionalParams) => Promise<IndexUnion>;
    delete: (name: string, version: string, options?: IndexesDeleteOptionalParams) => Promise<void>;
    get: (name: string, version: string, options?: IndexesGetOptionalParams) => Promise<IndexUnion>;
    list: (options?: IndexesListOptionalParams) => PagedAsyncIterableIterator<IndexUnion>;
    listVersions: (name: string, options?: IndexesListVersionsOptionalParams) => PagedAsyncIterableIterator<IndexUnion>;
}

// @public
export type IndexType = "AzureSearch" | "CosmosDBNoSqlVectorStore" | "ManagedAzureSearch";

// @public
export type IndexUnion = AzureAISearchIndex | ManagedAzureAISearchIndex | CosmosDBIndex | Index;

// @public
export interface InferenceOperations {
    azureOpenAI: (options?: AzureOpenAIClientOptions) => Promise<AzureOpenAI>;
}

// @public
export enum KnownVersions {
    V1 = "v1",
    V20250501 = "2025-05-01"
}

// @public
export interface ManagedAzureAISearchIndex extends Index {
    type: "ManagedAzureSearch";
    vectorStoreId: string;
}

// @public
export interface ModelDeployment extends Deployment {
    readonly capabilities: Record<string, string>;
    readonly connectionName?: string;
    readonly modelName: string;
    readonly modelPublisher: string;
    readonly modelVersion: string;
    readonly sku: Sku;
    type: "ModelDeployment";
}

// @public
export interface NoAuthenticationCredentials extends BaseCredentials {
    readonly type: "None";
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PendingUploadRequest {
    connectionName?: string;
    pendingUploadId?: string;
    pendingUploadType: "BlobReference";
}

// @public
export interface PendingUploadResponse {
    blobReference: BlobReference;
    pendingUploadId: string;
    pendingUploadType: "BlobReference";
    version?: string;
}

// @public
export type PendingUploadType = "None" | "BlobReference";

// @public
export interface SasCredential {
    readonly sasUri: string;
    readonly type: "SAS";
}

// @public
export interface SASCredentials extends BaseCredentials {
    readonly sasToken?: string;
    readonly type: "SAS";
}

// @public
export interface Sku {
    capacity: number;
    family: string;
    name: string;
    size: string;
    tier: string;
}

// @public
export interface TelemetryOperations {
    getApplicationInsightsConnectionString: () => Promise<string>;
}

// (No @packageDocumentation comment for this package)

```
