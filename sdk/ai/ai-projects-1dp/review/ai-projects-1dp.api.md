## API Report File for "@azure/ai-projects-1dp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ClientOptions } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public (undocumented)
export class AIProjectClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: AIProjectClientOptionalParams);
    readonly connections: ConnectionsOperations;
    readonly datasets: DatasetsOperations;
    readonly deployments: DeploymentsOperations;
    readonly evaluationResults: EvaluationResultsOperations;
    readonly evaluations: EvaluationsOperations;
    readonly indexes: IndexesOperations;
    readonly pipeline: Pipeline;
    readonly redTeams: RedTeamsOperations;
}

// @public
export interface AIProjectClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export type AttackStrategy = "easy" | "ascii_art" | "ascii_smuggler" | "atbash" | "base64" | "binary" | "caesar" | "character_space" | "jailbreak";

// @public
export type AuthenticationType = "ApiKey" | "AAD" | "SAS" | "CustomKeys" | "None";

// @public
export interface AzureAISearchIndex extends Index {
    connectionName: string;
    indexName: string;
    type: "AzureSearch";
}

// @public
export interface BlobReferenceForConsumption {
    blobUri: string;
    credential: SasCredential;
    storageAccountArmId: string;
}

// @public
export interface Connection {
    readonly authType: AuthenticationType;
    readonly metadata: Record<string, string>;
    readonly name: string;
    readonly target: string;
    readonly type: ConnectionType;
}

// @public
export interface ConnectionsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface ConnectionsListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    connectionType?: ConnectionType;
    maxpagesize?: number;
    skip?: number;
    top?: number;
}

// @public
export interface ConnectionsOperations {
    get: (name: string, options?: ConnectionsGetOptionalParams) => Promise<Connection>;
    list: (options?: ConnectionsListOptionalParams) => PagedAsyncIterableIterator<Connection>;
}

// @public
export type ConnectionType = "AzureOpenAI" | "AzureBlob" | "CognitiveSearch" | "CosmosDB" | "ApiKey" | "AppInsights" | "CustomKeys";

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CosmosDBIndex extends Index {
    connectionName: string;
    containerName: string;
    databaseName: string;
    embeddingConfiguration: EmbeddingConfiguration;
    type: "CosmosDBNoSqlVectorStore";
}

// @public
export interface DatasetsCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
    repeatabilityFirstSent?: Date;
    repeatabilityRequestId?: string;
}

// @public
export interface DatasetsCreateVersionOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsDeleteVersionOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsGetVersionOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsListLatestOptionalParams extends OperationOptions {
    listViewType?: ListViewType;
    skip?: string;
    tags?: string;
    top?: number;
}

// @public
export interface DatasetsListVersionsOptionalParams extends OperationOptions {
    listViewType?: ListViewType;
    skip?: string;
    tags?: string;
    top?: number;
}

// @public
export interface DatasetsOperations {
    create: (name: string, body: DatasetVersionUnion, options?: DatasetsCreateOptionalParams) => Promise<DatasetVersionUnion>;
    createVersion: (name: string, version: string, body: DatasetVersionUnion, options?: DatasetsCreateVersionOptionalParams) => Promise<DatasetVersionUnion>;
    deleteVersion: (name: string, version: string, options?: DatasetsDeleteVersionOptionalParams) => Promise<void>;
    getVersion: (name: string, version: string, options?: DatasetsGetVersionOptionalParams) => Promise<DatasetVersionUnion>;
    listLatest: (options?: DatasetsListLatestOptionalParams) => PagedAsyncIterableIterator<DatasetVersionUnion>;
    listVersions: (name: string, options?: DatasetsListVersionsOptionalParams) => PagedAsyncIterableIterator<DatasetVersionUnion>;
    startPendingUpload: (name: string, body: PendingUploadRequest, options?: DatasetsStartPendingUploadOptionalParams) => Promise<PendingUploadResponse>;
    startPendingUploadVersion: (name: string, version: string, body: PendingUploadRequest, options?: DatasetsStartPendingUploadVersionOptionalParams) => Promise<PendingUploadResponse>;
}

// @public
export interface DatasetsStartPendingUploadOptionalParams extends OperationOptions {
}

// @public
export interface DatasetsStartPendingUploadVersionOptionalParams extends OperationOptions {
}

// @public
export type DatasetType = "uri_file" | "uri_folder";

// @public
export interface DatasetVersion {
    datasetUri: string;
    description?: string;
    readonly id?: string;
    readonly isReference?: boolean;
    readonly name: string;
    stage?: string;
    tags?: Record<string, string>;
    type: DatasetType;
    readonly version: string;
}

// @public
export type DatasetVersionUnion = FileDatasetVersion | FolderDatasetVersion | DatasetVersion;

// @public
export interface Deployment {
    readonly name: string;
    type: DeploymentType;
}

// @public
export interface DeploymentsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DeploymentsListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    maxpagesize?: number;
    modelName?: string;
    modelPublisher?: string;
    skip?: number;
    top?: number;
}

// @public
export interface DeploymentsOperations {
    get: (name: string, options?: DeploymentsGetOptionalParams) => Promise<DeploymentUnion>;
    list: (options?: DeploymentsListOptionalParams) => PagedAsyncIterableIterator<DeploymentUnion>;
}

// @public
export type DeploymentType = "ModelDeployment";

// @public
export type DeploymentUnion = ModelDeployment | Deployment;

// @public
export interface EmbeddingConfiguration {
    embeddingField: string;
    modelDeploymentName: string;
}

// @public
export interface Evaluation {
    data: InputDataUnion;
    description?: string;
    displayName?: string;
    evaluators: Record<string, EvaluatorConfiguration>;
    readonly id: string;
    readonly outputs: Record<string, string>;
    properties?: Record<string, string>;
    readonly status?: string;
    tags?: Record<string, string>;
}

// @public
export interface EvaluationResult {
    blobUri?: string;
    datasetFamily?: string;
    datasetName?: string;
    description?: string;
    readonly id?: string;
    metrics?: Record<string, number>;
    modelAssetId?: string;
    modelName?: string;
    modelVersion?: string;
    readonly name: string;
    resultType?: ResultType;
    stage?: string;
    tags?: Record<string, string>;
    readonly version: string;
}

// @public
export interface EvaluationResultsCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
    repeatabilityFirstSent?: Date;
    repeatabilityRequestId?: string;
}

// @public
export interface EvaluationResultsCreateVersionOptionalParams extends OperationOptions {
}

// @public
export interface EvaluationResultsDeleteVersionOptionalParams extends OperationOptions {
}

// @public
export interface EvaluationResultsGetVersionOptionalParams extends OperationOptions {
}

// @public
export interface EvaluationResultsListLatestOptionalParams extends OperationOptions {
    listViewType?: ListViewType;
    skip?: string;
    tags?: string;
    top?: number;
}

// @public
export interface EvaluationResultsListVersionsOptionalParams extends OperationOptions {
    listViewType?: ListViewType;
    skip?: string;
    tags?: string;
    top?: number;
}

// @public
export interface EvaluationResultsOperations {
    create: (name: string, body: EvaluationResult, options?: EvaluationResultsCreateOptionalParams) => Promise<EvaluationResult>;
    createVersion: (name: string, version: string, body: EvaluationResult, options?: EvaluationResultsCreateVersionOptionalParams) => Promise<EvaluationResult>;
    deleteVersion: (name: string, version: string, options?: EvaluationResultsDeleteVersionOptionalParams) => Promise<void>;
    getVersion: (name: string, version: string, options?: EvaluationResultsGetVersionOptionalParams) => Promise<EvaluationResult>;
    listLatest: (options?: EvaluationResultsListLatestOptionalParams) => PagedAsyncIterableIterator<EvaluationResult>;
    listVersions: (name: string, options?: EvaluationResultsListVersionsOptionalParams) => PagedAsyncIterableIterator<EvaluationResult>;
    startPendingUpload: (name: string, version: string, body: PendingUploadRequest, options?: EvaluationResultsStartPendingUploadOptionalParams) => Promise<PendingUploadResponse>;
}

// @public
export interface EvaluationResultsStartPendingUploadOptionalParams extends OperationOptions {
}

// @public
export interface EvaluationsCreateRunOptionalParams extends OperationOptions {
}

// @public
export interface EvaluationsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface EvaluationsListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    maxpagesize?: number;
    skip?: number;
    top?: number;
}

// @public
export interface EvaluationsOperations {
    createRun: (evaluation: Evaluation, options?: EvaluationsCreateRunOptionalParams) => Promise<Evaluation>;
    get: (name: string, options?: EvaluationsGetOptionalParams) => Promise<Evaluation>;
    list: (options?: EvaluationsListOptionalParams) => PagedAsyncIterableIterator<Evaluation>;
}

// @public
export interface EvaluatorConfiguration {
    dataMapping?: Record<string, string>;
    id: string;
    initParams?: Record<string, any>;
}

// @public
export interface FileDatasetVersion extends DatasetVersion {
    openAIPurpose: string;
    type: "uri_file";
}

// @public
export interface FolderDatasetVersion extends DatasetVersion {
    type: "uri_folder";
}

// @public
export interface Index {
    description?: string;
    readonly id?: string;
    readonly name: string;
    stage?: string;
    tags?: Record<string, string>;
    type: IndexType;
    readonly version: string;
}

// @public
export interface IndexesCreateOptionalParams extends OperationOptions {
    clientRequestId?: string;
    repeatabilityFirstSent?: Date;
    repeatabilityRequestId?: string;
}

// @public
export interface IndexesCreateVersionOptionalParams extends OperationOptions {
}

// @public
export interface IndexesDeleteVersionOptionalParams extends OperationOptions {
}

// @public
export interface IndexesGetVersionOptionalParams extends OperationOptions {
}

// @public
export interface IndexesListLatestOptionalParams extends OperationOptions {
    listViewType?: ListViewType;
    skip?: string;
    tags?: string;
    top?: number;
}

// @public
export interface IndexesListVersionsOptionalParams extends OperationOptions {
    listViewType?: ListViewType;
    skip?: string;
    tags?: string;
    top?: number;
}

// @public
export interface IndexesOperations {
    create: (name: string, body: IndexUnion, options?: IndexesCreateOptionalParams) => Promise<IndexUnion>;
    createVersion: (name: string, version: string, body: IndexUnion, options?: IndexesCreateVersionOptionalParams) => Promise<IndexUnion>;
    deleteVersion: (name: string, version: string, options?: IndexesDeleteVersionOptionalParams) => Promise<void>;
    getVersion: (name: string, version: string, options?: IndexesGetVersionOptionalParams) => Promise<IndexUnion>;
    listLatest: (options?: IndexesListLatestOptionalParams) => PagedAsyncIterableIterator<IndexUnion>;
    listVersions: (name: string, options?: IndexesListVersionsOptionalParams) => PagedAsyncIterableIterator<IndexUnion>;
}

// @public
export type IndexType = "AzureSearch" | "CosmosDBNoSqlVectorStore" | "ManagedAzureSearch";

// @public
export type IndexUnion = AzureAISearchIndex | ManagedAzureAISearchIndex | CosmosDBIndex | Index;

// @public
export interface InputData {
    type: string;
}

// @public
export interface InputDataset extends InputData {
    id: string;
    // (undocumented)
    type: "dataset";
}

// @public
export type InputDataUnion = InputDataset | InputData;

// @public
export enum KnownVersions {
    V20250501 = "2025-05-01",
    V20250515Preview = "2025-05-15-preview"
}

// @public
export type ListViewType = "ActiveOnly" | "ArchivedOnly" | "All";

// @public
export interface ManagedAzureAISearchIndex extends Index {
    type: "ManagedAzureSearch";
    vectorStoreId: string;
}

// @public
export interface ModelDeployment extends Deployment {
    readonly capabilities: Record<string, string>;
    readonly connectionName?: string;
    readonly modelName: string;
    readonly modelPublisher: string;
    readonly modelVersion: string;
    readonly sku: Sku;
    type: "ModelDeployment";
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PendingUploadRequest {
    connectionName?: string;
    pendingUploadId?: string;
    pendingUploadType: "TemporaryBlobReference";
}

// @public
export interface PendingUploadResponse {
    blobReferenceForConsumption: BlobReferenceForConsumption;
    datasetVersion?: string;
    pendingUploadId: string;
    pendingUploadType: "TemporaryBlobReference";
}

// @public
export type PendingUploadType = "None" | "TemporaryBlobReference";

// @public
export interface RedTeam {
    applicationScenario?: string;
    attackStrategy: AttackStrategy[];
    readonly id: string;
    numTurns: number;
    readonly outputs: Record<string, string>;
    properties?: Record<string, string>;
    riskCategories: RiskCategory[];
    scanName: string;
    simulationOnly: boolean;
    readonly status?: string;
    tags?: Record<string, string>;
}

// @public
export interface RedTeamsCreateRunOptionalParams extends OperationOptions {
}

// @public
export interface RedTeamsGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface RedTeamsListOptionalParams extends OperationOptions {
    clientRequestId?: string;
    maxpagesize?: number;
    skip?: number;
    top?: number;
}

// @public
export interface RedTeamsOperations {
    createRun: (redTeam: RedTeam, options?: RedTeamsCreateRunOptionalParams) => Promise<RedTeam>;
    get: (name: string, options?: RedTeamsGetOptionalParams) => Promise<RedTeam>;
    list: (options?: RedTeamsListOptionalParams) => PagedAsyncIterableIterator<RedTeam>;
}

// @public
export type RepeatabilityResult = "accepted" | "rejected";

// @public
export type ResultType = "Benchmark" | "Evaluation" | "Redteam" | "Simulation";

// @public
export type RiskCategory = "HateUnfairness" | "Violence" | "Sexual" | "SelfHarm" | "ProtectedMaterial" | "CodeVulnerability" | "UngroundedAttributes";

// @public
export interface SasCredential {
    readonly sasUri: string;
    readonly type: "SAS";
}

// @public
export interface Sku {
    capacity: number;
    family: string;
    name: string;
    size: string;
    tier: string;
}

// (No @packageDocumentation comment for this package)

```
