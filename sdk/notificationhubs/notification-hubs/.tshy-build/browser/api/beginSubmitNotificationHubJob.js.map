{"version":3,"file":"beginSubmitNotificationHubJob.js","sourceRoot":"","sources":["../../../src/api/beginSubmitNotificationHubJob.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport type { CancelOnProgress, OperationState, PollerLike } from \"@azure/core-lro\";\nimport type { NotificationHubJob, NotificationHubJobPoller } from \"../models/notificationHubJob.js\";\nimport type { NotificationHubsClientContext } from \"./index.js\";\nimport type { PolledOperationOptions } from \"../models/options.js\";\nimport { delay } from \"@azure/core-util\";\nimport { getNotificationHubJob } from \"./getNotificationHubJob.js\";\nimport { submitNotificationHubJob } from \"./submitNotificationHubJob.js\";\n\n/**\n * Submits a Notification Hub job and creates a poller to poll for results.\n * @param context - The Notification Hubs client.\n * @param notificationHubJob - The Notification Hub import/export job to start.\n * @param options - The operation options.\n * @returns A poller which can be called to poll until completion of the job.\n */\nexport async function beginSubmitNotificationHubJob(\n  context: NotificationHubsClientContext,\n  notificationHubJob: NotificationHubJob,\n  polledOperationOptions: PolledOperationOptions = {},\n): Promise<NotificationHubJobPoller> {\n  let submittedJob = await submitNotificationHubJob(\n    context,\n    notificationHubJob,\n    polledOperationOptions,\n  );\n\n  type Handler = (state: OperationState<NotificationHubJob>) => void;\n\n  const state: OperationState<NotificationHubJob> = {\n    status: \"notStarted\",\n  };\n\n  const progressCallbacks = new Map<symbol, Handler>();\n  const processProgressCallbacks = async (): Promise<void> =>\n    progressCallbacks.forEach((h) => h(state));\n  let resultPromise: Promise<NotificationHubJob> | undefined;\n  const abortController = new AbortController();\n  const currentPollIntervalInMs = polledOperationOptions.updateIntervalInMs ?? 2000;\n\n  const poller: PollerLike<OperationState<NotificationHubJob>, NotificationHubJob> = {\n    async poll(options?: {\n      abortSignal?: AbortSignalLike;\n    }): Promise<OperationState<NotificationHubJob>> {\n      submittedJob = await getNotificationHubJob(context, submittedJob.jobId!, options);\n      if (submittedJob.status === \"Running\" || submittedJob.status === \"Started\") {\n        state.status = \"running\";\n      }\n\n      if (submittedJob.status === \"Completed\") {\n        state.status = \"succeeded\";\n        state.result = submittedJob;\n      }\n\n      if (submittedJob.status === \"Failed\") {\n        state.status = \"failed\";\n        state.error = new Error(submittedJob.failure);\n      }\n\n      await processProgressCallbacks();\n\n      if (state.status === \"canceled\") {\n        throw new Error(\"Operation was canceled\");\n      }\n      if (state.status === \"failed\") {\n        throw state.error;\n      }\n\n      return state;\n    },\n\n    pollUntilDone(pollOptions?: { abortSignal?: AbortSignalLike }): Promise<NotificationHubJob> {\n      return (resultPromise ??= (async () => {\n        const { abortSignal: inputAbortSignal } = pollOptions || {};\n        // In the future we can use AbortSignal.any() instead\n        function abortListener(): void {\n          abortController.abort();\n        }\n        const abortSignal = abortController.signal;\n        if (inputAbortSignal?.aborted) {\n          abortController.abort();\n        } else if (!abortSignal.aborted) {\n          inputAbortSignal?.addEventListener(\"abort\", abortListener, { once: true });\n        }\n\n        try {\n          if (!poller.isDone) {\n            await poller.poll({ abortSignal });\n            while (!poller.isDone) {\n              await delay(currentPollIntervalInMs, { abortSignal });\n              await poller.poll({ abortSignal });\n            }\n          }\n        } finally {\n          inputAbortSignal?.removeEventListener(\"abort\", abortListener);\n        }\n        switch (state.status) {\n          case \"succeeded\":\n            return poller.result as NotificationHubJob;\n          case \"canceled\":\n            throw new Error(\"Operation was canceled\");\n          case \"failed\":\n            throw state.error;\n          case \"notStarted\":\n          case \"running\":\n            throw new Error(`Polling completed without succeeding or failing`);\n        }\n      })().finally(() => {\n        resultPromise = undefined;\n      }));\n    },\n\n    onProgress(callback: (state: OperationState<NotificationHubJob>) => void): CancelOnProgress {\n      const s = Symbol();\n      progressCallbacks.set(s, callback);\n\n      return () => progressCallbacks.delete(s);\n    },\n\n    get isDone(): boolean {\n      return [\"succeeded\", \"failed\", \"canceled\"].includes(state.status);\n    },\n\n    get operationState(): OperationState<NotificationHubJob> | undefined {\n      return state;\n    },\n\n    get result(): NotificationHubJob | undefined {\n      return state.result;\n    },\n\n    async serialize(): Promise<string> {\n      return JSON.stringify({ state });\n    },\n\n    async submitted() {\n      // No-op\n      return;\n    },\n\n    then<TResult1 = NotificationHubJob, TResult2 = never>(\n      onfulfilled?:\n        | ((value: NotificationHubJob) => TResult1 | PromiseLike<TResult1>)\n        | undefined\n        | null,\n      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n    ): Promise<TResult1 | TResult2> {\n      return poller.pollUntilDone().then(onfulfilled, onrejected);\n    },\n    catch<TResult2 = never>(\n      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n    ): Promise<NotificationHubJob | TResult2> {\n      return poller.pollUntilDone().catch(onrejected);\n    },\n    finally(onfinally?: (() => void) | undefined | null): Promise<NotificationHubJob> {\n      return poller.pollUntilDone().finally(onfinally);\n    },\n    [Symbol.toStringTag]: \"Poller\",\n  };\n\n  return poller;\n}\n"]}