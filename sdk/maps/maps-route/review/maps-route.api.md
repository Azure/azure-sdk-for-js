## API Report File for "@azure/maps-route"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AlternativeRouteType as AlternativeRouteType_2 } from 'src/generated';
import { AzureKeyCredential } from '@azure/core-auth';
import { CommonClientOptions } from '@azure/core-client';
import { ComputeTravelTime as ComputeTravelTime_2 } from 'src/generated';
import { InclineLevel as InclineLevel_2 } from 'src/generated';
import { OperationOptions } from '@azure/core-client';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { Report as Report_2 } from 'src/generated';
import { RouteAvoidType as RouteAvoidType_2 } from 'src/generated';
import { RouteInstructionsType as RouteInstructionsType_2 } from 'src/generated';
import { RouteRepresentationForBestOrder as RouteRepresentationForBestOrder_2 } from 'src/generated';
import { RouteType as RouteType_2 } from 'src/generated';
import { SectionType as SectionType_2 } from 'src/generated';
import { TokenCredential } from '@azure/core-auth';
import { TravelMode as TravelMode_2 } from 'src/generated';
import { VehicleEngineType as VehicleEngineType_2 } from 'src/generated';
import { VehicleLoadType as VehicleLoadType_2 } from 'src/generated';
import { WindingnessLevel as WindingnessLevel_2 } from 'src/generated';

// @public
export type AlternativeRouteType = string;

export { AzureKeyCredential }

// @public
export interface BatchRequest {
    // Warning: (ae-forgotten-export) The symbol "BatchRequestItem" needs to be exported by the entry point index.d.ts
    batchItems?: BatchRequestItem[];
}

// @public
export type ComputeTravelTime = string;

// @public
export interface GetRouteDirectionsBatchOptions extends OperationOptions {
}

// @public
export interface GetRouteMatrixOptions extends OperationOptions {
}

// @public
export type InclineLevel = string;

// @public
export enum KnownAlternativeRouteType {
    AnyRoute = "anyRoute",
    BetterRoute = "betterRoute"
}

// @public
export enum KnownComputeTravelTime {
    All = "all",
    None = "none"
}

// @public
export enum KnownInclineLevel {
    High = "high",
    Low = "low",
    Normal = "normal"
}

// @public
export enum KnownReport {
    EffectiveSettings = "effectiveSettings"
}

// @public
export enum KnownRouteAvoidType {
    AlreadyUsedRoads = "alreadyUsedRoads",
    BorderCrossings = "borderCrossings",
    Carpools = "carpools",
    Ferries = "ferries",
    Motorways = "motorways",
    TollRoads = "tollRoads",
    UnpavedRoads = "unpavedRoads"
}

// @public
export enum KnownRouteInstructionsType {
    Coded = "coded",
    Tagged = "tagged",
    Text = "text"
}

// @public
export enum KnownRouteRepresentationForBestOrder {
    None = "none",
    Polyline = "polyline",
    SummaryOnly = "summaryOnly"
}

// @public
export enum KnownRouteType {
    Economy = "eco",
    Fastest = "fastest",
    Shortest = "shortest",
    Thrilling = "thrilling"
}

// @public
export enum KnownSectionType {
    CarOrTrain = "carTrain",
    Carpool = "carpool",
    Country = "country",
    Ferry = "ferry",
    Motorway = "motorway",
    Pedestrian = "pedestrian",
    TollRoad = "tollRoad",
    TollVignette = "tollVignette",
    Traffic = "traffic",
    TravelMode = "travelMode",
    Tunnel = "tunnel",
    Urban = "urban"
}

// @public
export enum KnownTravelMode {
    Bicycle = "bicycle",
    Bus = "bus",
    Car = "car",
    Motorcycle = "motorcycle",
    Pedestrian = "pedestrian",
    Taxi = "taxi",
    Truck = "truck",
    Van = "van"
}

// @public
export enum KnownVehicleEngineType {
    Combustion = "combustion",
    Electric = "electric"
}

// @public
export enum KnownVehicleLoadType {
    OtherHazmatExplosive = "otherHazmatExplosive",
    OtherHazmatGeneral = "otherHazmatGeneral",
    OtherHazmatHarmfulToWater = "otherHazmatHarmfulToWater",
    USHazmatClass1 = "USHazmatClass1",
    USHazmatClass2 = "USHazmatClass2",
    USHazmatClass3 = "USHazmatClass3",
    USHazmatClass4 = "USHazmatClass4",
    USHazmatClass5 = "USHazmatClass5",
    USHazmatClass6 = "USHazmatClass6",
    USHazmatClass7 = "USHazmatClass7",
    USHazmatClass8 = "USHazmatClass8",
    USHazmatClass9 = "USHazmatClass9"
}

// @public
export enum KnownWindingnessLevel {
    High = "high",
    Low = "low",
    Normal = "normal"
}

// @public
export interface LatLon {
    // (undocumented)
    latitude: number;
    // (undocumented)
    longitude: number;
}

// @public
export class MapsRouteClient {
    constructor(credential: AzureKeyCredential, options?: MapsRouteClientOptions);
    constructor(credential: TokenCredential, mapsAccountClientId: string, options?: MapsRouteClientOptions);
    // (undocumented)
    beginGetRouteDirectionsBatchResult(batchId: string, options?: GetRouteDirectionsBatchOptions): Promise<PollerLike<PollOperationState<RouteDirectionsBatchResult>, RouteDirectionsBatchResult>>;
    // (undocumented)
    beginGetRouteMatrixResult(matrixId: string, options?: GetRouteMatrixOptions): Promise<PollerLike<PollOperationState<RouteMatrixResult>, RouteMatrixResult>>;
    // (undocumented)
    beginRequestRouteDirectionsBatch(routeDirectionsBatchQueries: BatchRequest, options?: RequestRouteDirectionsBatchOptions): Promise<PollerLike<PollOperationState<RouteDirectionsBatchResult>, RouteDirectionsBatchResult>>;
    // (undocumented)
    beginRequestRouteMatrix(routeMatrixQuery: RouteMatrixQuery, options?: RouteMatrixOptions): Promise<PollerLike<PollOperationState<RouteMatrixResult>, RouteMatrixResult>>;
    getRouteDirections(routePoints: LatLon[], options?: RouteDirectionsOptions): Promise<RouteDirections>;
    // (undocumented)
    getRouteDirectionsWithAdditionalParameters(routePoints: LatLon[], routeDirectionParameters: RouteDirectionParameters, options?: RouteDirectionsOptions): Promise<RouteDirections>;
    // (undocumented)
    getRouteRange(coordinates: LatLon, options?: RouteRangeOptions): Promise<RouteRangeResult>;
    // (undocumented)
    requestRouteDirectionsBatch(routeDirectionsBatchQueries: BatchRequest, options?: RequestRouteDirectionsBatchOptions): Promise<RouteDirectionsBatchResult>;
    // (undocumented)
    requestRouteMatrix(routeMatrixQuery: RouteMatrixQuery, options?: RouteMatrixOptions): Promise<RouteMatrixResult>;
}

// @public
export type MapsRouteClientOptions = CommonClientOptions;

// @public
export type Report = string;

// @public
export interface RequestRouteDirectionsBatchOptions extends OperationOptions {
}

// @public
export type RouteAvoidType = string;

// @public
export interface RouteBaseOptions extends OperationOptions {
    accelerationEfficiency?: number;
    auxiliaryPowerInKw?: number;
    auxiliaryPowerInLitersPerHour?: number;
    avoid?: RouteAvoidType_2[];
    constantSpeedConsumptionInKwHPerHundredKm?: string;
    constantSpeedConsumptionInLitersPerHundredKm?: string;
    currentChargeInKwH?: number;
    currentFuelInLiters?: number;
    decelerationEfficiency?: number;
    departAt?: Date;
    downhillEfficiency?: number;
    fuelEnergyDensityInMegajoulesPerLiter?: number;
    inclineLevel?: InclineLevel_2;
    isCommercialVehicle?: boolean;
    maxChargeInKwH?: number;
    routeType?: RouteType_2;
    travelMode?: TravelMode_2;
    uphillEfficiency?: number;
    useTrafficData?: boolean;
    vehicleAxleWeight?: number;
    vehicleEngineType?: VehicleEngineType_2;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType_2;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel_2;
}

// @public
export interface RouteDirectionParameters {
    allowVignette?: string[];
    // Warning: (ae-forgotten-export) The symbol "GeoJsonMultiPolygon" needs to be exported by the entry point index.d.ts
    avoidAreas?: GeoJsonMultiPolygon;
    avoidVignette?: string[];
    supportingPoints?: Record<string, unknown>;
}

// @public
export interface RouteDirections {
    readonly formatVersion?: string;
    // Warning: (ae-forgotten-export) The symbol "RouteOptimizedWaypoint" needs to be exported by the entry point index.d.ts
    readonly optimizedWaypoints?: RouteOptimizedWaypoint[];
    // Warning: (ae-forgotten-export) The symbol "RouteReport" needs to be exported by the entry point index.d.ts
    report?: RouteReport;
    // Warning: (ae-forgotten-export) The symbol "Route" needs to be exported by the entry point index.d.ts
    readonly routes?: Route[];
}

// Warning: (ae-forgotten-export) The symbol "BatchResult" needs to be exported by the entry point index.d.ts
//
// @public
export type RouteDirectionsBatchResult = BatchResult & {
    readonly batchItems?: RouteDirectionsBatchItem[];
};

// @public
export interface RouteDirectionsOptions extends RouteBaseOptions {
    alternativeType?: AlternativeRouteType_2;
    arriveAt?: Date;
    computeBestWaypointOrder?: boolean;
    computeTravelTime?: ComputeTravelTime_2;
    filterSectionType?: SectionType_2;
    instructionsType?: RouteInstructionsType_2;
    language?: string;
    maxAlternatives?: number;
    minDeviationDistance?: number;
    minDeviationTime?: number;
    report?: Report_2;
    routeRepresentationForBestOrder?: RouteRepresentationForBestOrder_2;
    vehicleHeading?: number;
}

// @public
export type RouteInstructionsType = string;

// @public
export interface RouteMatrixOptions extends OperationOptions {
    arriveAt?: Date;
    avoid?: RouteAvoidType_2[];
    computeTravelTime?: ComputeTravelTime_2;
    departAt?: Date;
    filterSectionType?: SectionType_2;
    inclineLevel?: InclineLevel_2;
    routeType?: RouteType_2;
    travelMode?: TravelMode_2;
    useTrafficData?: boolean;
    vehicleAxleWeight?: number;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType_2;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel_2;
}

// @public
export interface RouteMatrixQuery {
    destinations?: GeoJsonMultiPoint;
    // Warning: (ae-forgotten-export) The symbol "GeoJsonMultiPoint" needs to be exported by the entry point index.d.ts
    origins?: GeoJsonMultiPoint;
}

// @public
export interface RouteMatrixResult {
    readonly formatVersion?: string;
    // Warning: (ae-forgotten-export) The symbol "RouteMatrix" needs to be exported by the entry point index.d.ts
    readonly matrix?: RouteMatrix[][];
    // Warning: (ae-forgotten-export) The symbol "RouteMatrixSummary" needs to be exported by the entry point index.d.ts
    readonly summary?: RouteMatrixSummary;
}

// @public
export interface RouteRangeOptions extends RouteBaseOptions {
    distanceBudgetInMeters?: number;
    energyBudgetInKwH?: number;
    fuelBudgetInLiters?: number;
    timeBudgetInSec?: number;
}

// @public
export interface RouteRangeResult {
    readonly formatVersion?: string;
    // Warning: (ae-forgotten-export) The symbol "RouteRange" needs to be exported by the entry point index.d.ts
    reachableRange?: RouteRange;
    report?: RouteReport;
}

// @public
export type RouteRepresentationForBestOrder = string;

// @public
export type RouteType = string;

// @public
export type SectionType = string;

// @public
export type TravelMode = string;

// @public
export type VehicleEngineType = string;

// @public
export type VehicleLoadType = string;

// @public
export type WindingnessLevel = string;


// Warnings were encountered during analysis:
//
// src/generated/models/index.ts:771:3 - (ae-forgotten-export) The symbol "RouteDirectionsBatchItem" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
