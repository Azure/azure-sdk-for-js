## API Report File for "@azure/maps-route"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AlternativeRouteType as AlternativeRouteType_2 } from 'src/generated';
import { AzureKeyCredential } from '@azure/core-auth';
import { CommonClientOptions } from '@azure/core-client';
import { ComputeTravelTime as ComputeTravelTime_2 } from 'src/generated';
import { DrivingSide } from 'src/generated/models';
import { ErrorResponse } from 'src/generated/models';
import { GuidanceInstructionType } from 'src/generated/models';
import { GuidanceManeuver } from 'src/generated/models';
import { InclineLevel as InclineLevel_2 } from 'src/generated';
import { JunctionType } from 'src/generated/models';
import { OperationOptions } from '@azure/core-client';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { Report as Report_2 } from 'src/generated';
import { RouteAvoidType as RouteAvoidType_2 } from 'src/generated';
import { RouteInstructionGroup } from 'src/generated/models';
import { RouteInstructionsType as RouteInstructionsType_2 } from 'src/generated';
import { RouteLegSummary } from 'src/generated/models';
import { RouteOptimizedWaypoint as RouteOptimizedWaypoint_2 } from 'src/generated/models';
import { RouteReport as RouteReport_2 } from 'src/generated/models';
import { RouteRepresentationForBestOrder as RouteRepresentationForBestOrder_2 } from 'src/generated';
import { RouteSection } from 'src/generated/models';
import { RouteSummary } from 'src/generated/models';
import { RouteType as RouteType_2 } from 'src/generated';
import { SectionType as SectionType_2 } from 'src/generated';
import { TokenCredential } from '@azure/core-auth';
import { TravelMode as TravelMode_2 } from 'src/generated';
import { VehicleEngineType as VehicleEngineType_2 } from 'src/generated';
import { VehicleLoadType as VehicleLoadType_2 } from 'src/generated';
import { WindingnessLevel as WindingnessLevel_2 } from 'src/generated';

// @public
export type AlternativeRouteType = string;

export { AzureKeyCredential }

// @public
export interface BatchItem<TResult> {
    readonly response?: TResult & ErrorResponse;
    readonly statusCode?: number;
}

// @public
export interface BatchPoller<TBatchResult> extends PollerLike<PollOperationState<TBatchResult>, TBatchResult> {
    getBatchId(): string | undefined;
}

// @public
export interface BatchPollerOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BatchRequest {
    // Warning: (ae-forgotten-export) The symbol "BatchRequestItem" needs to be exported by the entry point index.d.ts
    batchItems?: BatchRequestItem[];
}

// @public
export interface BatchResult<TResult> {
    readonly batchItems?: BatchItem<TResult>[];
    readonly successfulRequests?: number;
    readonly totalRequests?: number;
}

// @public
export type BBox = BBox2D | BBox3D;

// @public
export type BBox2D = [number, number, number, number];

// @public
export type BBox3D = [number, number, number, number, number, number];

// @public
export type ComputeTravelTime = string;

// @public
export interface GeoJsonFeature extends GeoJsonObject {
    // (undocumented)
    geometry?: GeoJsonGeometry;
    // (undocumented)
    id?: number | string;
    // (undocumented)
    properties?: {
        [name: string]: any;
    };
    // (undocumented)
    type: "Feature";
}

// @public
export interface GeoJsonFeatureCollection extends GeoJsonObject {
    // (undocumented)
    features: GeoJsonFeature[];
    // (undocumented)
    type: "FeatureCollection";
}

// @public
export type GeoJsonGeometry = GeoJsonPoint | GeoJsonMultiPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonMultiPolygon;

// @public
export interface GeoJsonGeometryCollection extends GeoJsonObject {
    // (undocumented)
    geometries: GeoJsonGeometry[];
    // (undocumented)
    type: "GeometryCollection";
}

// @public
export interface GeoJsonLineString extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[];
    // (undocumented)
    type: "LineString";
}

// @public
export interface GeoJsonMultiLineString extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][];
    // (undocumented)
    type: "MultiLineString";
}

// @public
export interface GeoJsonMultiPoint extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[];
    // (undocumented)
    type: "MultiPoint";
}

// @public
export interface GeoJsonMultiPolygon extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][][];
    // (undocumented)
    type: "MultiPolygon";
}

// @public
export interface GeoJsonObject {
    // (undocumented)
    bbox?: BBox;
    // (undocumented)
    type: GeoJsonType;
}

// @public
export interface GeoJsonPoint extends GeoJsonObject {
    // (undocumented)
    coordinates: Position;
    // (undocumented)
    type: "Point";
}

// @public
export interface GeoJsonPolygon extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][];
    // (undocumented)
    type: "Polygon";
}

// @public
export type GeoJsonType = GeometryType | "Feature" | "FeatureCollection";

// @public
export type GeometryType = "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon" | "GeometryCollection";

// @public
export type InclineLevel = string;

// @public
export enum KnownAlternativeRouteType {
    AnyRoute = "anyRoute",
    BetterRoute = "betterRoute"
}

// @public
export enum KnownComputeTravelTime {
    All = "all",
    None = "none"
}

// @public
export enum KnownInclineLevel {
    High = "high",
    Low = "low",
    Normal = "normal"
}

// @public
export enum KnownReport {
    EffectiveSettings = "effectiveSettings"
}

// @public
export enum KnownRouteAvoidType {
    AlreadyUsedRoads = "alreadyUsedRoads",
    BorderCrossings = "borderCrossings",
    Carpools = "carpools",
    Ferries = "ferries",
    Motorways = "motorways",
    TollRoads = "tollRoads",
    UnpavedRoads = "unpavedRoads"
}

// @public
export enum KnownRouteInstructionsType {
    Coded = "coded",
    Tagged = "tagged",
    Text = "text"
}

// @public
export enum KnownRouteRepresentationForBestOrder {
    None = "none",
    Polyline = "polyline",
    SummaryOnly = "summaryOnly"
}

// @public
export enum KnownRouteType {
    Economy = "eco",
    Fastest = "fastest",
    Shortest = "shortest",
    Thrilling = "thrilling"
}

// @public
export enum KnownSectionType {
    CarOrTrain = "carTrain",
    Carpool = "carpool",
    Country = "country",
    Ferry = "ferry",
    Motorway = "motorway",
    Pedestrian = "pedestrian",
    TollRoad = "tollRoad",
    TollVignette = "tollVignette",
    Traffic = "traffic",
    TravelMode = "travelMode",
    Tunnel = "tunnel",
    Urban = "urban"
}

// @public
export enum KnownTravelMode {
    Bicycle = "bicycle",
    Bus = "bus",
    Car = "car",
    Motorcycle = "motorcycle",
    Pedestrian = "pedestrian",
    Taxi = "taxi",
    Truck = "truck",
    Van = "van"
}

// @public
export enum KnownVehicleEngineType {
    Combustion = "combustion",
    Electric = "electric"
}

// @public
export enum KnownVehicleLoadType {
    OtherHazmatExplosive = "otherHazmatExplosive",
    OtherHazmatGeneral = "otherHazmatGeneral",
    OtherHazmatHarmfulToWater = "otherHazmatHarmfulToWater",
    USHazmatClass1 = "USHazmatClass1",
    USHazmatClass2 = "USHazmatClass2",
    USHazmatClass3 = "USHazmatClass3",
    USHazmatClass4 = "USHazmatClass4",
    USHazmatClass5 = "USHazmatClass5",
    USHazmatClass6 = "USHazmatClass6",
    USHazmatClass7 = "USHazmatClass7",
    USHazmatClass8 = "USHazmatClass8",
    USHazmatClass9 = "USHazmatClass9"
}

// @public
export enum KnownWindingnessLevel {
    High = "high",
    Low = "low",
    Normal = "normal"
}

// @public
export interface LatLon {
    // (undocumented)
    latitude: number;
    // (undocumented)
    longitude: number;
}

// @public
export class MapsRouteClient {
    constructor(credential: AzureKeyCredential, options?: MapsRouteClientOptions);
    constructor(credential: TokenCredential, mapsAccountClientId: string, options?: MapsRouteClientOptions);
    beginGetRouteDirectionsBatchResult(batchId: string, options?: RouteDirectionsBatchOptions & BatchPollerOptions): Promise<BatchPoller<BatchResult<RouteDirections>>>;
    beginGetRouteMatrixResult(matrixId: string, options?: RouteMatrixOptions & BatchPollerOptions): Promise<BatchPoller<RouteMatrixResult>>;
    beginRequestRouteDirectionsBatch(requests: RouteDirectionsRequest[], options?: RouteDirectionsBatchOptions & BatchPollerOptions): Promise<BatchPoller<BatchResult<RouteDirections>>>;
    beginRequestRouteMatrix(routeMatrixQuery: RouteMatrixQuery, options?: RouteMatrixOptions & BatchPollerOptions): Promise<BatchPoller<RouteMatrixResult>>;
    getRouteDirections(routePoints: LatLon[], options?: RouteDirectionsOptions & OperationOptions): Promise<RouteDirections>;
    getRouteDirectionsWithAdditionalParameters(routePoints: LatLon[], routeDirectionParameters: RouteDirectionParameters, options?: RouteDirectionsOptions & OperationOptions): Promise<RouteDirections>;
    getRouteRange(coordinates: LatLon, budget: RouteRangeBudget, options?: RouteRangeOptions): Promise<RouteRangeResult>;
    requestRouteDirectionsBatch(requests: RouteDirectionsRequest[], options?: RouteDirectionsBatchOptions): Promise<BatchResult<RouteDirections>>;
    requestRouteMatrix(routeMatrixQuery: RouteMatrixQuery, options?: RouteMatrixOptions): Promise<RouteMatrixResult>;
}

// @public
export type MapsRouteClientOptions = CommonClientOptions;

// @public
export type Position = Position2D | Position3D;

// @public
export type Position2D = [number, number];

// @public
export type Position3D = [number, number, number];

// @public
export type Report = string;

// @public
export type RequireOnlyOne<T> = {
    [K in keyof T]-?: Required<Pick<T, K>> & Partial<Record<Exclude<keyof T, K>, undefined>>;
}[keyof T];

// @public (undocumented)
export interface Route {
    readonly guidance?: RouteGuidance;
    readonly legs: RouteLeg[];
    readonly sections: RouteSection[];
    readonly summary: RouteSummary;
}

// @public
export type RouteAvoidType = string;

// @public
export interface RouteBaseOptions {
    accelerationEfficiency?: number;
    auxiliaryPowerInKw?: number;
    auxiliaryPowerInLitersPerHour?: number;
    avoid?: RouteAvoidType_2[];
    constantSpeedConsumptionInKwHPerHundredKm?: string;
    constantSpeedConsumptionInLitersPerHundredKm?: string;
    currentChargeInKwH?: number;
    currentFuelInLiters?: number;
    decelerationEfficiency?: number;
    departAt?: Date;
    downhillEfficiency?: number;
    fuelEnergyDensityInMegajoulesPerLiter?: number;
    inclineLevel?: InclineLevel_2;
    isCommercialVehicle?: boolean;
    maxChargeInKwH?: number;
    routeType?: RouteType_2;
    travelMode?: TravelMode_2;
    uphillEfficiency?: number;
    useTrafficData?: boolean;
    vehicleAxleWeight?: number;
    vehicleEngineType?: VehicleEngineType_2;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType_2;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel_2;
}

// @public
export interface RouteDirectionParameters {
    allowVignette?: string[];
    avoidAreas?: GeoJsonMultiPolygon;
    avoidVignette?: string[];
    supportingPoints?: GeoJsonGeometryCollection;
}

// @public
export interface RouteDirections {
    readonly formatVersion?: string;
    readonly optimizedWaypoints?: RouteOptimizedWaypoint_2[];
    report?: RouteReport_2;
    readonly routes?: Route[];
}

// @public
export interface RouteDirectionsBatchOptions extends OperationOptions {
}

// Warning: (ae-forgotten-export) The symbol "BatchResult" needs to be exported by the entry point index.d.ts
//
// @public
export type RouteDirectionsBatchResult = BatchResult_2 & {
    readonly batchItems?: RouteDirectionsBatchItem[];
};

// @public
export interface RouteDirectionsOptions extends RouteBaseOptions {
    alternativeType?: AlternativeRouteType_2;
    arriveAt?: Date;
    computeBestWaypointOrder?: boolean;
    computeTravelTime?: ComputeTravelTime_2;
    filterSectionType?: SectionType_2;
    instructionsType?: RouteInstructionsType_2;
    language?: string;
    maxAlternatives?: number;
    minDeviationDistance?: number;
    minDeviationTime?: number;
    report?: Report_2;
    routeRepresentationForBestOrder?: RouteRepresentationForBestOrder_2;
    vehicleHeading?: number;
}

// @public
export interface RouteDirectionsRequest {
    // (undocumented)
    options?: RouteDirectionsOptions;
    // (undocumented)
    routePoints: LatLon[];
}

// @public
export interface RouteGuidance {
    readonly instructionGroups: RouteInstructionGroup[];
    readonly instructions: RouteInstruction[];
}

// @public
export interface RouteInstruction {
    readonly combinedMessage?: string;
    readonly countryCode?: string;
    readonly drivingSide?: DrivingSide;
    readonly exitNumber?: string;
    instructionType?: GuidanceInstructionType;
    readonly junctionType?: JunctionType;
    readonly maneuver?: GuidanceManeuver;
    readonly message?: string;
    point?: LatLon;
    readonly pointIndex?: number;
    readonly possibleCombineWithNext?: boolean;
    readonly roadNumbers?: string[];
    readonly roundaboutExitNumber?: string;
    readonly routeOffsetInMeters?: number;
    readonly signpostText?: string;
    readonly stateCode?: string;
    readonly street?: string;
    readonly travelTimeInSeconds?: number;
    readonly turnAngleInDegrees?: number;
}

// @public
export type RouteInstructionsType = string;

// @public
export interface RouteLeg {
    readonly points: LatLon[];
    readonly summary: RouteLegSummary;
}

// @public
export interface RouteMatrixOptions extends OperationOptions {
    arriveAt?: Date;
    avoid?: RouteAvoidType_2[];
    computeTravelTime?: ComputeTravelTime_2;
    departAt?: Date;
    filterSectionType?: SectionType_2;
    inclineLevel?: InclineLevel_2;
    routeType?: RouteType_2;
    travelMode?: TravelMode_2;
    useTrafficData?: boolean;
    vehicleAxleWeight?: number;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType_2;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel_2;
}

// @public
export interface RouteMatrixQuery {
    destinations: GeoJsonMultiPoint;
    origins: GeoJsonMultiPoint;
}

// @public
export interface RouteMatrixResult {
    readonly formatVersion?: string;
    // Warning: (ae-forgotten-export) The symbol "RouteMatrix" needs to be exported by the entry point index.d.ts
    readonly matrix?: RouteMatrix[][];
    // Warning: (ae-forgotten-export) The symbol "RouteMatrixSummary" needs to be exported by the entry point index.d.ts
    readonly summary?: RouteMatrixSummary;
}

// @public
export interface RouteOptimizedWaypoint {
    readonly optimizedIndex?: number;
    readonly providedIndex?: number;
}

// @public
export interface RouteRange {
    readonly boundary?: LatLon[];
    center?: LatLon;
}

// @public
export type RouteRangeBudget = RequireOnlyOne<{
    fuelBudgetInLiters?: number;
    energyBudgetInKwH?: number;
    timeBudgetInSec?: number;
    distanceBudgetInMeters?: number;
}>;

// @public
export type RouteRangeOptions = RouteBaseOptions & OperationOptions;

// @public
export interface RouteRangeResult {
    readonly formatVersion?: string;
    reachableRange?: RouteRange;
    report?: RouteReport_2;
}

// @public
export interface RouteReport {
    // Warning: (ae-forgotten-export) The symbol "EffectiveSetting" needs to be exported by the entry point index.d.ts
    readonly effectiveSettings?: EffectiveSetting[];
}

// @public
export type RouteRepresentationForBestOrder = string;

// @public
export type RouteType = string;

// @public
export type SectionType = string;

// @public
export type TravelMode = string;

// @public
export type VehicleEngineType = string;

// @public
export type VehicleLoadType = string;

// @public
export type WindingnessLevel = string;


// Warnings were encountered during analysis:
//
// src/generated/models/index.ts:762:3 - (ae-forgotten-export) The symbol "RouteDirectionsBatchItem" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
