## API Report File for "@azure/maps-route"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AzureKeyCredential } from '@azure/core-auth';
import { CommonClientOptions } from '@azure/core-client';
import { OperationOptions } from '@azure/core-client';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export type AlternativeRouteType = string;

export { AzureKeyCredential }

// @public
export interface BatchItem<TResult> {
    readonly response: TResult | ErrorResponse;
    readonly statusCode: number;
}

// @public
export interface BatchPoller<TBatchResult> extends PollerLike<PollOperationState<TBatchResult>, TBatchResult> {
    getBatchId(): string | undefined;
}

// @public
export interface BatchPollerOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BatchResult<TResult> {
    readonly batchItems: BatchItem<TResult>[];
    readonly totalRequests: number;
    readonly totalSuccessfulRequests: number;
}

// @public
export type BBox = BBox2D | BBox3D;

// @public
export type BBox2D = [
southWestLongitude: number,
southWestLatitude: number,
northEastLongitude: number,
northEastLatitude: number
];

// @public
export type BBox3D = [
southWestLongitude: number,
southWestLatitude: number,
southWestElevation: number,
northEastLongitude: number,
northEastLatitude: number,
northEastElevation: number
];

// @public
export type ComputeTravelTime = string;

// @public
export type DelayMagnitude = string;

// @public
export type DrivingSide = "LEFT" | "RIGHT";

// @public
export interface EffectiveSetting {
    readonly key: string;
    readonly value: string;
}

// @public
export interface ErrorDetail {
    readonly code?: string;
    readonly message?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export type GeoJsonGeometry = GeoJsonPoint | GeoJsonMultiPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonMultiPolygon;

// @public
export interface GeoJsonGeometryCollection extends GeoJsonObject {
    // (undocumented)
    geometries: GeoJsonGeometry[];
    // (undocumented)
    type: "GeometryCollection";
}

// @public
export interface GeoJsonLineString extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[];
    // (undocumented)
    type: "LineString";
}

// @public
export interface GeoJsonMultiLineString extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][];
    // (undocumented)
    type: "MultiLineString";
}

// @public
export interface GeoJsonMultiPoint extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[];
    // (undocumented)
    type: "MultiPoint";
}

// @public
export interface GeoJsonMultiPolygon extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][][];
    // (undocumented)
    type: "MultiPolygon";
}

// @public
export interface GeoJsonObject {
    // (undocumented)
    bbox?: BBox;
    // (undocumented)
    type: GeoJsonType;
}

// @public
export interface GeoJsonPoint extends GeoJsonObject {
    // (undocumented)
    coordinates: Position;
    // (undocumented)
    type: "Point";
}

// @public
export interface GeoJsonPolygon extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][];
    // (undocumented)
    type: "Polygon";
}

// @public
export type GeoJsonType = GeometryType | "Feature" | "FeatureCollection";

// @public
export type GeometryType = "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon" | "GeometryCollection";

// @public
export type GuidanceInstructionType = string;

// @public
export type GuidanceManeuver = string;

// @public
export type InclineLevel = string;

// @public
export type JunctionType = string;

// @public
export enum KnownAlternativeRouteType {
    AnyRoute = "anyRoute",
    BetterRoute = "betterRoute"
}

// @public
export enum KnownComputeTravelTime {
    All = "all",
    None = "none"
}

// @public
export enum KnownDelayMagnitude {
    Major = "3",
    Minor = "1",
    Moderate = "2",
    Undefined = "4",
    Unknown = "0"
}

// @public
export enum KnownGuidanceInstructionType {
    DirectionInfo = "DIRECTION_INFO",
    LocationArrival = "LOCATION_ARRIVAL",
    LocationDeparture = "LOCATION_DEPARTURE",
    LocationWaypoint = "LOCATION_WAYPOINT",
    RoadChange = "ROAD_CHANGE",
    Turn = "TURN"
}

// @public
export enum KnownGuidanceManeuver {
    Arrive = "ARRIVE",
    ArriveLeft = "ARRIVE_LEFT",
    ArriveRight = "ARRIVE_RIGHT",
    BearLeft = "BEAR_LEFT",
    BearRight = "BEAR_RIGHT",
    Depart = "DEPART",
    EnterFreeway = "ENTER_FREEWAY",
    EnterHighway = "ENTER_HIGHWAY",
    EnterMotorway = "ENTER_MOTORWAY",
    EntranceRamp = "ENTRANCE_RAMP",
    Follow = "FOLLOW",
    KeepLeft = "KEEP_LEFT",
    KeepRight = "KEEP_RIGHT",
    MakeUTurn = "MAKE_UTURN",
    MotorwayExitLeft = "MOTORWAY_EXIT_LEFT",
    MotorwayExitRight = "MOTORWAY_EXIT_RIGHT",
    RoundaboutBack = "ROUNDABOUT_BACK",
    RoundaboutCross = "ROUNDABOUT_CROSS",
    RoundaboutLeft = "ROUNDABOUT_LEFT",
    RoundaboutRight = "ROUNDABOUT_RIGHT",
    SharpLeft = "SHARP_LEFT",
    SharpRight = "SHARP_RIGHT",
    Straight = "STRAIGHT",
    SwitchMainRoad = "SWITCH_MAIN_ROAD",
    SwitchParallelRoad = "SWITCH_PARALLEL_ROAD",
    TakeExit = "TAKE_EXIT",
    TakeFerry = "TAKE_FERRY",
    TryMakeUTurn = "TRY_MAKE_UTURN",
    TurnLeft = "TURN_LEFT",
    TurnRight = "TURN_RIGHT",
    WaypointLeft = "WAYPOINT_LEFT",
    WaypointReached = "WAYPOINT_REACHED",
    WaypointRight = "WAYPOINT_RIGHT"
}

// @public
export enum KnownInclineLevel {
    High = "high",
    Low = "low",
    Normal = "normal"
}

// @public
export enum KnownJunctionType {
    Bifurcation = "BIFURCATION",
    Regular = "REGULAR",
    Roundabout = "ROUNDABOUT"
}

// @public
export enum KnownReport {
    EffectiveSettings = "effectiveSettings"
}

// @public
export enum KnownResponseSectionType {
    CarOrTrain = "CAR_TRAIN",
    Carpool = "CARPOOL",
    Country = "COUNTRY",
    Ferry = "FERRY",
    Motorway = "MOTORWAY",
    Pedestrian = "PEDESTRIAN",
    TollRoad = "TOLL_ROAD",
    TollVignette = "TOLL_VIGNETTE",
    Traffic = "TRAFFIC",
    TravelMode = "TRAVEL_MODE",
    Tunnel = "TUNNEL",
    Urban = "URBAN"
}

// @public
export enum KnownResponseTravelMode {
    Bicycle = "bicycle",
    Bus = "bus",
    Car = "car",
    Motorcycle = "motorcycle",
    Other = "other",
    Pedestrian = "pedestrian",
    Taxi = "taxi",
    Truck = "truck",
    Van = "van"
}

// @public
export enum KnownRouteAvoidType {
    AlreadyUsedRoads = "alreadyUsedRoads",
    BorderCrossings = "borderCrossings",
    Carpools = "carpools",
    Ferries = "ferries",
    Motorways = "motorways",
    TollRoads = "tollRoads",
    UnpavedRoads = "unpavedRoads"
}

// @public
export enum KnownRouteInstructionsType {
    Coded = "coded",
    Tagged = "tagged",
    Text = "text"
}

// @public
export enum KnownRouteRepresentationForBestOrder {
    None = "none",
    Polyline = "polyline",
    SummaryOnly = "summaryOnly"
}

// @public
export enum KnownRouteType {
    Economy = "eco",
    Fastest = "fastest",
    Shortest = "shortest",
    Thrilling = "thrilling"
}

// @public
export enum KnownSectionType {
    CarOrTrain = "carTrain",
    Carpool = "carpool",
    Country = "country",
    Ferry = "ferry",
    Motorway = "motorway",
    Pedestrian = "pedestrian",
    TollRoad = "tollRoad",
    TollVignette = "tollVignette",
    Traffic = "traffic",
    TravelMode = "travelMode",
    Tunnel = "tunnel",
    Urban = "urban"
}

// @public
export enum KnownSimpleCategory {
    Jam = "JAM",
    Other = "OTHER",
    RoadClosure = "ROAD_CLOSURE",
    RoadWork = "ROAD_WORK"
}

// @public
export enum KnownTravelMode {
    Bicycle = "bicycle",
    Bus = "bus",
    Car = "car",
    Motorcycle = "motorcycle",
    Pedestrian = "pedestrian",
    Taxi = "taxi",
    Truck = "truck",
    Van = "van"
}

// @public
export enum KnownVehicleEngineType {
    Combustion = "combustion",
    Electric = "electric"
}

// @public
export enum KnownVehicleLoadType {
    OtherHazmatExplosive = "otherHazmatExplosive",
    OtherHazmatGeneral = "otherHazmatGeneral",
    OtherHazmatHarmfulToWater = "otherHazmatHarmfulToWater",
    USHazmatClass1 = "USHazmatClass1",
    USHazmatClass2 = "USHazmatClass2",
    USHazmatClass3 = "USHazmatClass3",
    USHazmatClass4 = "USHazmatClass4",
    USHazmatClass5 = "USHazmatClass5",
    USHazmatClass6 = "USHazmatClass6",
    USHazmatClass7 = "USHazmatClass7",
    USHazmatClass8 = "USHazmatClass8",
    USHazmatClass9 = "USHazmatClass9"
}

// @public
export enum KnownWindingnessLevel {
    High = "high",
    Low = "low",
    Normal = "normal"
}

// @public
export interface LatLon {
    // (undocumented)
    latitude: number;
    // (undocumented)
    longitude: number;
}

// @public
export class MapsRouteClient {
    constructor(credential: AzureKeyCredential, options?: MapsRouteClientOptions);
    constructor(credential: TokenCredential, mapsAccountClientId: string, options?: MapsRouteClientOptions);
    beginGetRouteDirectionsBatchResult(batchId: string, options?: RouteDirectionsBatchOptions & BatchPollerOptions): Promise<BatchPoller<BatchResult<RouteDirections>>>;
    beginGetRouteMatrixResult(matrixId: string, options?: RouteMatrixOptions & BatchPollerOptions): Promise<BatchPoller<RouteMatrixResult>>;
    beginRequestRouteDirectionsBatch(requests: RouteDirectionsRequest[], options?: RouteDirectionsBatchOptions & BatchPollerOptions): Promise<BatchPoller<BatchResult<RouteDirections>>>;
    beginRequestRouteMatrix(routeMatrixQuery: RouteMatrixQuery, options?: RouteMatrixOptions & BatchPollerOptions): Promise<BatchPoller<RouteMatrixResult>>;
    getRouteDirections(routePoints: LatLon[], options?: RouteDirectionsOptions & OperationOptions): Promise<RouteDirections>;
    getRouteDirectionsWithAdditionalParameters(routePoints: LatLon[], routeDirectionParameters: RouteDirectionParameters, options?: RouteDirectionsOptions & OperationOptions): Promise<RouteDirections>;
    getRouteRange(coordinates: LatLon, budget: RouteRangeBudget, options?: RouteRangeOptions): Promise<RouteRangeResult>;
}

// @public
export type MapsRouteClientOptions = CommonClientOptions;

// @public
export type Position = Position2D | Position3D;

// @public
export type Position2D = [longitude: number, latitude: number];

// @public
export type Position3D = [longitude: number, latitude: number, elevation: number];

// @public
export type Report = string;

// @public
export type RequireAtLeastOne<T> = {
    [K in keyof T]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<keyof T, K>>>;
}[keyof T];

// @public
export type ResponseSectionType = string;

// @public
export type ResponseTravelMode = string;

// @public (undocumented)
export interface Route {
    readonly guidance?: RouteGuidance;
    readonly legs: RouteLeg[];
    readonly sections?: RouteSection[];
    readonly summary: RouteSummary;
}

// @public
export type RouteAvoidType = string;

// @public
export interface RouteBaseOptions {
    accelerationEfficiency?: number;
    auxiliaryPowerInKw?: number;
    auxiliaryPowerInLitersPerHour?: number;
    avoid?: RouteAvoidType[];
    constantSpeedConsumptionInKwHPerHundredKm?: string;
    constantSpeedConsumptionInLitersPerHundredKm?: string;
    currentChargeInKwH?: number;
    currentFuelInLiters?: number;
    decelerationEfficiency?: number;
    departAt?: Date;
    downhillEfficiency?: number;
    fuelEnergyDensityInMegajoulesPerLiter?: number;
    inclineLevel?: InclineLevel;
    isCommercialVehicle?: boolean;
    maxChargeInKwH?: number;
    routeType?: RouteType;
    travelMode?: TravelMode;
    uphillEfficiency?: number;
    useTrafficData?: boolean;
    vehicleAxleWeight?: number;
    vehicleEngineType?: VehicleEngineType;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel;
}

// @public
export type RouteDirectionParameters = RequireAtLeastOne<{
    supportingPoints?: GeoJsonGeometryCollection;
    avoidVignette?: string[];
    allowVignette?: string[];
    avoidAreas?: GeoJsonMultiPolygon;
}>;

// @public
export interface RouteDirections {
    readonly formatVersion?: string;
    readonly optimizedWaypoints?: RouteOptimizedWaypoint[];
    report?: RouteReport;
    readonly routes: Route[];
}

// @public
export interface RouteDirectionsBatchOptions extends OperationOptions {
}

// @public
export interface RouteDirectionsOptions extends RouteBaseOptions {
    alternativeType?: AlternativeRouteType;
    arriveAt?: Date;
    computeBestWaypointOrder?: boolean;
    computeTravelTime?: ComputeTravelTime;
    filterSectionType?: SectionType;
    instructionsType?: RouteInstructionsType;
    language?: string;
    maxAlternatives?: number;
    minDeviationDistance?: number;
    minDeviationTime?: number;
    report?: Report;
    routeRepresentationForBestOrder?: RouteRepresentationForBestOrder;
    vehicleHeading?: number;
}

// @public
export interface RouteDirectionsRequest {
    // (undocumented)
    options?: RouteDirectionsOptions;
    // (undocumented)
    routePoints: LatLon[];
}

// @public
export interface RouteGuidance {
    readonly instructionGroups: RouteInstructionGroup[];
    readonly instructions: RouteInstruction[];
}

// @public
export interface RouteInstruction {
    readonly combinedMessage?: string;
    readonly countryCode?: string;
    readonly drivingSide?: DrivingSide;
    readonly exitNumber?: string;
    instructionType?: GuidanceInstructionType;
    readonly junctionType?: JunctionType;
    readonly maneuver?: GuidanceManeuver;
    readonly message?: string;
    point?: LatLon;
    readonly pointIndex?: number;
    readonly possibleCombineWithNext?: boolean;
    readonly roadNumbers?: string[];
    readonly roundaboutExitNumber?: string;
    readonly routeOffsetInMeters?: number;
    readonly signpostText?: string;
    readonly stateCode?: string;
    readonly street?: string;
    readonly travelTimeInSeconds?: number;
    readonly turnAngleInDegrees?: number;
}

// @public
export interface RouteInstructionGroup {
    readonly firstInstructionIndex?: number;
    readonly groupLengthInMeters?: number;
    readonly groupMessage?: string;
    readonly lastInstructionIndex?: number;
}

// @public
export type RouteInstructionsType = string;

// @public
export interface RouteLeg {
    readonly points: LatLon[];
    readonly summary: RouteSummary;
}

// @public
export interface RouteMatrix {
    readonly routeSummary?: RouteSummary;
    readonly statusCode: number;
}

// @public
export interface RouteMatrixOptions extends OperationOptions {
    arriveAt?: Date;
    avoid?: RouteAvoidType[];
    computeTravelTime?: ComputeTravelTime;
    departAt?: Date;
    filterSectionType?: SectionType;
    inclineLevel?: InclineLevel;
    routeType?: RouteType;
    travelMode?: TravelMode;
    useTrafficData?: boolean;
    vehicleAxleWeight?: number;
    vehicleHeight?: number;
    vehicleLength?: number;
    vehicleLoadType?: VehicleLoadType;
    vehicleMaxSpeed?: number;
    vehicleWeight?: number;
    vehicleWidth?: number;
    windingness?: WindingnessLevel;
}

// @public
export interface RouteMatrixQuery {
    destinations: GeoJsonMultiPoint;
    origins: GeoJsonMultiPoint;
}

// @public
export interface RouteMatrixResult {
    readonly formatVersion?: string;
    readonly matrix: RouteMatrix[][];
    readonly summary: RouteMatrixSummary;
}

// @public
export interface RouteMatrixSummary {
    readonly successfulRoutes: number;
    readonly totalRoutes: number;
}

// @public
export interface RouteOptimizedWaypoint {
    readonly optimizedIndex: number;
    readonly providedIndex: number;
}

// @public
export interface RouteRange {
    readonly boundary: LatLon[];
    center: LatLon;
}

// @public
export type RouteRangeBudget = {
    fuelBudgetInLiters: number;
} | {
    energyBudgetInKwH: number;
} | {
    timeBudgetInSeconds: number;
} | {
    distanceBudgetInMeters: number;
};

// @public
export type RouteRangeOptions = RouteBaseOptions & OperationOptions;

// @public
export interface RouteRangeResult {
    readonly formatVersion?: string;
    reachableRange: RouteRange;
    report?: RouteReport;
}

// @public
export interface RouteReport {
    readonly effectiveSettings: EffectiveSetting[];
}

// @public
export type RouteRepresentationForBestOrder = string;

// @public
export interface RouteSection {
    readonly delayInSeconds?: number;
    readonly delayMagnitude?: DelayMagnitude;
    readonly effectiveSpeedInKmh?: number;
    readonly endPointIndex: number;
    readonly sectionType: ResponseSectionType;
    readonly simpleCategory?: SimpleCategory;
    readonly startPointIndex: number;
    tec?: RouteSectionTec;
    readonly travelMode?: ResponseTravelMode;
}

// @public
export interface RouteSectionTec {
    causes?: RouteSectionTecCause[];
    readonly effectCode?: number;
}

// @public
export interface RouteSectionTecCause {
    readonly mainCauseCode?: number;
    readonly subCauseCode?: number;
}

// @public
export interface RouteSummary {
    readonly arrivalTime: Date;
    readonly departureTime: Date;
    readonly lengthInMeters: number;
    readonly trafficDelayInSeconds: number;
    readonly travelTimeInSeconds: number;
}

// @public
export type RouteType = string;

// @public
export type SectionType = string;

// @public
export type SimpleCategory = string;

// @public
export type TravelMode = string;

// @public
export type VehicleEngineType = string;

// @public
export type VehicleLoadType = string;

// @public
export type WindingnessLevel = string;

// (No @packageDocumentation comment for this package)

```
