## API Report File for "@azure/maps-search"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AzureKeyCredential } from '@azure/core-auth';
import { CommonClientOptions } from '@azure/core-client';
import { OperationOptions } from '@azure/core-client';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface Address {
    readonly boundingBox?: BoundingBox;
    readonly buildingNumber?: string;
    readonly country?: string;
    readonly countryCode?: string;
    readonly countryCodeISO3?: string;
    readonly countrySecondarySubdivision?: string;
    readonly countrySubdivision?: string;
    readonly countrySubdivisionName?: string;
    readonly countryTertiarySubdivision?: string;
    readonly crossStreet?: string;
    readonly extendedPostalCode?: string;
    readonly freeformAddress?: string;
    readonly localName?: string;
    readonly municipality?: string;
    readonly municipalitySubdivision?: string;
    readonly postalCode?: string;
    readonly routeNumbers?: number[];
    readonly street?: string;
    readonly streetName?: string;
    readonly streetNameAndNumber?: string;
    readonly streetNumber?: string;
}

// @public
export interface AddressRanges {
    from?: LatLong;
    rangeLeft?: string;
    rangeRight?: string;
    to?: LatLong;
}

// @public
export interface BatchItem<TResult> {
    // Warning: (ae-forgotten-export) The symbol "ErrorResponse" needs to be exported by the entry point index.d.ts
    readonly response?: TResult & ErrorResponse;
    readonly statusCode?: number;
}

// @public
export interface BatchResult<TResult extends SearchAddressResult | ReverseSearchAddressResult> {
    readonly batchItems?: BatchItem<TResult>[];
    readonly successfulRequests?: number;
    readonly totalRequests?: number;
}

// @public
export class BoundingBox {
    constructor(topLeft: LatLong, bottomRight: LatLong);
    get bottom(): number;
    get bottomLeft(): LatLong;
    get bottomRight(): LatLong;
    get left(): number;
    get right(): number;
    get top(): number;
    get topLeft(): LatLong;
    get topRight(): LatLong;
}

// @public
export interface BrandName {
    readonly name?: string;
}

// @public
export interface Classification {
    readonly code?: string;
    readonly names?: ClassificationName[];
}

// @public
export interface ClassificationName {
    readonly name?: string;
    readonly nameLocale?: string;
}

// @public
export interface DataSource {
    geometry?: GeometryIdentifier;
}

// @public
export type ElectricVehicleConnector = string;

// @public
export interface EntryPoint {
    position?: LatLong;
    readonly type?: EntryPointType;
}

// @public
export type EntryPointType = string;

// @public
export interface FuzzySearchBatchOptions extends OperationOptions {
}

// @public
export interface FuzzySearchOptions extends SearchPointOfInterestOptions {
    entityType?: GeographicEntityType;
    indexFilter?: SearchIndexes[];
    maxFuzzyLevel?: number;
    minFuzzyLevel?: number;
}

// @public
export interface FuzzySearchRequest {
    // (undocumented)
    coordinates?: LatLong;
    // (undocumented)
    countryFilter?: string[];
    // (undocumented)
    options?: FuzzySearchRequestOptions;
    // (undocumented)
    query: string;
}

// @public (undocumented)
export type FuzzySearchRequestOptions = Omit<FuzzySearchOptions, keyof OperationOptions>;

// @public
export type GeographicEntityType = string;

// @public
export interface GeoJsonCircleFeature extends GeoJsonFeature {
    // (undocumented)
    geometry: GeoJsonPoint;
    // (undocumented)
    properties: {
        subType: "Circle";
        radius: number;
    };
}

// @public
export interface GeoJsonFeature {
    // (undocumented)
    geometry: GeoJsonPolygon | GeoJsonPoint;
    // (undocumented)
    id?: string | number | undefined;
    // (undocumented)
    properties?: {
        [name: string]: any;
    };
    // (undocumented)
    type: "Feature";
}

// @public
export interface GeoJsonFeatureCollection {
    // (undocumented)
    features: GeoJsonFeature[];
    // (undocumented)
    type: "FeatureCollection";
}

// @public
export interface GeoJsonGeometryCollection {
    // (undocumented)
    geometries: GeoJsonPolygon[];
    // (undocumented)
    type: "GeometryCollection";
}

// @public
export interface GeoJsonLineString {
    // (undocumented)
    coordinates: number[][];
    // (undocumented)
    type: "LineString";
}

// Warning: (ae-forgotten-export) The symbol "GeoJsonObject" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "GeoJsonGeometryUnion" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "GeoJsonFeature" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "GeoJsonFeatureCollection" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type GeoJsonObjectUnion = GeoJsonObject | GeoJsonGeometryUnion | GeoJsonFeature_2 | GeoJsonFeatureCollection_2;

// @public
export interface GeoJsonPoint {
    // (undocumented)
    coordinates: number[];
    // (undocumented)
    type: "Point";
}

// @public
export interface GeoJsonPolygon {
    // (undocumented)
    coordinates: number[][][];
    // (undocumented)
    type: "Polygon";
}

// @public
export interface GeoJsonPolygonFeature extends GeoJsonFeature {
    // (undocumented)
    geometry: GeoJsonPolygon;
}

// @public
export interface GeometryIdentifier {
    readonly id?: string;
}

// @public
export interface GetPointOfInterestCategoryTreeOptions extends OperationOptions {
    language?: string;
}

// @public
export class LatLong {
    constructor(latitude: number, longitude: number);
    get latitude(): number;
    get longitude(): number;
    }

// @public
export interface ListPolygonsOptions extends OperationOptions {
}

// @public
export type LocalizedMapView = string;

// @public
export type MatchType = string;

// @public
export interface OperatingHours {
    readonly mode?: string;
    readonly timeRanges?: OperatingHoursTimeRange[];
}

// @public
export type OperatingHoursRange = string;

// @public
export interface OperatingHoursTime {
    readonly date?: string;
    readonly hour?: number;
    readonly minute?: number;
}

// @public
export interface OperatingHoursTimeRange {
    endTime?: OperatingHoursTime;
    startTime?: OperatingHoursTime;
}

// @public
export interface PointOfInterest {
    readonly brands?: BrandName[];
    readonly categorySet?: PointOfInterestCategorySet[];
    readonly classifications?: Classification[];
    readonly name?: string;
    operatingHours?: OperatingHours;
    readonly phone?: string;
    readonly url?: string;
}

// @public
export interface PointOfInterestCategorySet {
    readonly id?: number;
}

// @public
export interface PointOfInterestCategoryTreeResult {
    // Warning: (ae-forgotten-export) The symbol "PointOfInterestCategory" needs to be exported by the entry point index.d.ts
    readonly categories?: PointOfInterestCategory[];
}

// @public (undocumented)
export interface Polygon {
    geometryData?: GeoJsonObjectUnion;
    readonly providerID?: string;
}

// @public
export interface PolygonResult {
    readonly polygons?: Polygon[];
}

// @public
export type QueryType = string;

// @public
export interface ReverseSearchAddressBatchOptions extends OperationOptions {
}

// @public
export interface ReverseSearchAddressOptions extends ReverseSearchBaseOptions {
    allowFreeformNewline?: boolean;
    entityType?: GeographicEntityType;
    includeMatchType?: boolean;
    includeRoadUse?: boolean;
    includeSpeedLimit?: boolean;
    numberParam?: string;
    roadUse?: RoadUseType[];
}

// @public
export interface ReverseSearchAddressRequest {
    // (undocumented)
    coordinates: LatLong;
    // (undocumented)
    options?: ReverseSearchAddressRequestOptions;
}

// @public (undocumented)
export type ReverseSearchAddressRequestOptions = Omit<ReverseSearchAddressOptions, keyof OperationOptions>;

// @public (undocumented)
export interface ReverseSearchAddressResult {
    readonly numResults?: number;
    readonly queryTime?: number;
    readonly results?: ReverseSearchAddressResultItem[];
}

// @public (undocumented)
export interface ReverseSearchAddressResultItem {
    readonly address?: Address;
    readonly matchType?: MatchType;
    readonly position?: LatLong;
    readonly roadUse?: RoadUseType[];
}

// @public
export interface ReverseSearchBaseOptions extends OperationOptions {
    heading?: number;
    language?: string;
    localizedMapView?: LocalizedMapView;
    radiusInMeters?: number;
}

// @public
export interface ReverseSearchCrossStreetAddressOptions extends ReverseSearchBaseOptions {
    top?: number;
}

// @public (undocumented)
export interface ReverseSearchCrossStreetAddressResult {
    readonly numResults?: number;
    readonly queryTime?: number;
    readonly results?: ReverseSearchCrossStreetAddressResultItem[];
}

// @public (undocumented)
export interface ReverseSearchCrossStreetAddressResultItem {
    readonly address?: Address;
    readonly matchType?: MatchType;
    readonly position?: LatLong;
    readonly roadUse?: RoadUseType[];
}

// @public
export type RoadUseType = string;

// @public
export interface SearchAddressBaseOptions extends SearchBaseOptions {
    boundingBox?: BoundingBox;
    isTypeAhead?: boolean;
    radiusInMeters?: number;
}

// @public
export interface SearchAddressBatchOptions extends OperationOptions {
}

// @public
export interface SearchAddressOptions extends SearchAddressBaseOptions {
    coordinates?: LatLong;
    countryFilter?: string[];
    entityType?: GeographicEntityType;
}

// @public
export interface SearchAddressRequest {
    // (undocumented)
    options?: SearchAddressRequestOptions;
    // (undocumented)
    query: string;
}

// @public (undocumented)
export type SearchAddressRequestOptions = Omit<SearchAddressOptions, keyof OperationOptions>;

// @public
export interface SearchAddressResult {
    readonly fuzzyLevel?: number;
    readonly geoBias?: LatLong;
    readonly numResults?: number;
    readonly query?: string;
    readonly queryTime?: number;
    readonly queryType?: QueryType;
    readonly results?: SearchAddressResultItem[];
    readonly skip?: number;
    readonly top?: number;
    readonly totalResults?: number;
}

// @public
export interface SearchAddressResultItem {
    readonly address?: Address;
    readonly addressRanges?: AddressRanges;
    readonly dataSources?: DataSource;
    readonly detourTime?: number;
    readonly distanceInMeters?: number;
    readonly entityType?: GeographicEntityType;
    readonly entryPoints?: EntryPoint[];
    readonly id?: string;
    readonly info?: string;
    readonly matchType?: MatchType;
    readonly pointOfInterest?: PointOfInterest;
    readonly position?: LatLong;
    readonly score?: number;
    readonly type?: SearchAddressResultType;
    readonly viewport?: BoundingBox;
}

// @public
export type SearchAddressResultType = string;

// @public
export interface SearchAlongRouteOptions extends SearchGeometryBaseOptions {
    brandFilter?: string[];
    electricVehicleConnectorFilter?: ElectricVehicleConnector[];
}

// @public
export interface SearchBaseOptions extends OperationOptions {
    extendedPostalCodesFor?: SearchIndexes[];
    language?: string;
    localizedMapView?: LocalizedMapView;
    skip?: number;
    top?: number;
}

// @public
export class SearchClient {
    constructor(credential: AzureKeyCredential);
    constructor(credential: AzureKeyCredential, options?: SearchClientOptions);
    constructor(credential: TokenCredential, clientId: string);
    constructor(credential: TokenCredential, clientId: string, options?: SearchClientOptions);
    beginFuzzySearchBatch(requests: FuzzySearchRequest[], options?: FuzzySearchBatchOptions): Promise<PollerLike<PollOperationState<BatchResult<SearchAddressResult>>, BatchResult<SearchAddressResult>>>;
    beginReverseSearchAddressBatch(requests: ReverseSearchAddressRequest[], options?: ReverseSearchAddressBatchOptions): Promise<PollerLike<PollOperationState<BatchResult<ReverseSearchAddressResult>>, BatchResult<ReverseSearchAddressResult>>>;
    beginSearchAddressBatch(requests: SearchAddressRequest[], options?: SearchAddressBatchOptions): Promise<PollerLike<PollOperationState<BatchResult<SearchAddressResult>>, BatchResult<SearchAddressResult>>>;
    fuzzySearch(query: string, coordinates: LatLong, options?: FuzzySearchOptions): Promise<SearchAddressResult>;
    fuzzySearch(query: string, countryFilter: string[], options?: FuzzySearchOptions): Promise<SearchAddressResult>;
    fuzzySearch(query: string, coordinates: LatLong, countryFilter: string[], options?: FuzzySearchOptions): Promise<SearchAddressResult>;
    fuzzySearchBatchSync(requests: FuzzySearchRequest[], options?: FuzzySearchBatchOptions): Promise<BatchResult<SearchAddressResult>>;
    getPointOfInterestCategoryTree(options?: GetPointOfInterestCategoryTreeOptions): Promise<PointOfInterestCategory[]>;
    listPolygons(geometryIds: string[], options?: ListPolygonsOptions): Promise<Polygon[]>;
    reverseSearchAddress(coordinates: LatLong, options?: ReverseSearchAddressOptions): Promise<ReverseSearchAddressResult>;
    reverseSearchAddressBatchSync(requests: ReverseSearchAddressRequest[], options?: ReverseSearchAddressBatchOptions): Promise<BatchResult<ReverseSearchAddressResult>>;
    reverseSearchCrossStreetAddress(coordinates: LatLong, options?: ReverseSearchCrossStreetAddressOptions): Promise<ReverseSearchCrossStreetAddressResult>;
    searchAddress(query: string, options?: SearchAddressOptions): Promise<SearchAddressResult>;
    searchAddressBatchSync(requests: SearchAddressRequest[], options?: SearchAddressBatchOptions): Promise<BatchResult<SearchAddressResult>>;
    searchAlongRoute(query: string, maxDetourTime: number, route: GeoJsonLineString, options?: SearchAlongRouteOptions): Promise<SearchAddressResult>;
    searchInsideGeometry(query: string, geometry: GeoJsonPolygon | GeoJsonGeometryCollection | GeoJsonFeatureCollection, options?: SearchInsideGeometryOptions): Promise<SearchAddressResult>;
    searchNearbyPointOfInterest(coordinates: LatLong, options?: SearchNearbyPointOfInterestOptions): Promise<SearchAddressResult>;
    searchPointOfInterest(query: string, coordinates: LatLong, options?: SearchPointOfInterestOptions): Promise<SearchAddressResult>;
    searchPointOfInterest(query: string, countryFilter: string[], options?: SearchPointOfInterestOptions): Promise<SearchAddressResult>;
    searchPointOfInterest(query: string, coordinates: LatLong, countryFilter: string[], options?: SearchPointOfInterestOptions): Promise<SearchAddressResult>;
    searchPointOfInterestCategory(query: string, coordinates: LatLong, options?: SearchPointOfInterestCategoryOptions): Promise<SearchAddressResult>;
    searchPointOfInterestCategory(query: string, countryFilter: string[], options?: SearchPointOfInterestCategoryOptions): Promise<SearchAddressResult>;
    searchPointOfInterestCategory(query: string, coordinates: LatLong, countryFilter: string[], options?: SearchPointOfInterestCategoryOptions): Promise<SearchAddressResult>;
    searchStructuredAddress(structuredAddress: StructuredAddress, options?: SearchStructuredAddressOptions): Promise<SearchAddressResult>;
}

// @public
export interface SearchClientOptions extends CommonClientOptions {
}

// @public
export interface SearchExtraFilterOptions {
    brandFilter?: string[];
    categoryFilter?: number[];
    electricVehicleConnectorFilter?: ElectricVehicleConnector[];
}

// @public
export interface SearchGeometryBaseOptions extends OperationOptions {
    categoryFilter?: number[];
    localizedMapView?: LocalizedMapView;
    operatingHours?: OperatingHoursRange;
    top?: number;
}

// @public
export type SearchIndexes = string;

// @public
export interface SearchInsideGeometryOptions extends SearchGeometryBaseOptions {
    extendedPostalCodesFor?: SearchIndexes[];
    indexFilter?: SearchIndexes[];
    language?: string;
}

// @public
export interface SearchNearbyPointOfInterestOptions extends SearchBaseOptions, SearchExtraFilterOptions {
    countryFilter?: string[];
    radiusInMeters?: number;
}

// @public (undocumented)
export type SearchPointOfInterestCategoryOptions = SearchPointOfInterestOptions;

// @public
export interface SearchPointOfInterestOptions extends SearchAddressBaseOptions, SearchExtraFilterOptions {
    operatingHours?: OperatingHoursRange;
}

// @public
export interface SearchStructuredAddressOptions extends SearchBaseOptions {
    entityType?: GeographicEntityType;
}

// @public
export interface StructuredAddress {
    countryCode: string;
    countrySecondarySubdivision?: string;
    countrySubdivision?: string;
    countryTertiarySubdivision?: string;
    crossStreet?: string;
    municipality?: string;
    municipalitySubdivision?: string;
    postalCode?: string;
    streetName?: string;
    streetNumber?: string;
}


// (No @packageDocumentation comment for this package)

```
