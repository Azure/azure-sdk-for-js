## API Report File for "@azure/maps-search"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AzureKeyCredential } from '@azure/core-auth';
import { CommonClientOptions } from '@azure/core-client';
import { OperationOptions } from '@azure/core-client';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface Address {
    readonly boundingBox?: BoundingBox;
    readonly buildingNumber?: string;
    readonly country?: string;
    readonly countryCode?: string;
    readonly countryCodeISO3?: string;
    readonly countrySecondarySubdivision?: string;
    readonly countrySubdivision?: string;
    readonly countrySubdivisionName?: string;
    readonly countryTertiarySubdivision?: string;
    readonly crossStreet?: string;
    readonly extendedPostalCode?: string;
    readonly freeformAddress?: string;
    readonly localName?: string;
    readonly municipality?: string;
    readonly municipalitySubdivision?: string;
    readonly postalCode?: string;
    readonly routeNumbers?: string[];
    readonly street?: string;
    readonly streetName?: string;
    readonly streetNameAndNumber?: string;
    readonly streetNumber?: string;
}

// @public
export interface AddressRanges {
    from: LatLon;
    rangeLeft: string;
    rangeRight: string;
    to: LatLon;
}

export { AzureKeyCredential }

// @public
export interface BatchItem<TResult> {
    readonly response: TResult | ErrorResponse;
    readonly statusCode: number;
}

// @public
export interface BatchPoller<TBatchResult> extends PollerLike<PollOperationState<TBatchResult>, TBatchResult> {
    getBatchId(): string | undefined;
}

// @public
export interface BatchPollerOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BatchResult<TResult> {
    readonly batchItems: BatchItem<TResult>[];
    readonly totalRequests: number;
    readonly totalSuccessfulRequests: number;
}

// @public
export type BBox = BBox2D | BBox3D;

// @public
export type BBox2D = [
southWestLongitude: number,
southWestLatitude: number,
northEastLongitude: number,
northEastLatitude: number
];

// @public
export type BBox3D = [
southWestLongitude: number,
southWestLatitude: number,
southWestElevation: number,
northEastLongitude: number,
northEastLatitude: number,
northEastElevation: number
];

// @public
export interface BoundingBox {
    bottomRight: LatLon;
    topLeft: LatLon;
}

// @public
export interface Brand {
    readonly name: string;
}

// @public
export interface Classification {
    readonly code: string;
    readonly names: ClassificationName[];
}

// @public
export interface ClassificationName {
    readonly name: string;
    readonly nameLocale: string;
}

// @public
export interface DataSource {
    geometry?: GeometryIdentifier;
}

// @public
export type ElectricVehicleConnector = string;

// @public
export interface EntityGeometry {
    geometryData?: GeoJsonFeatureCollection;
    readonly providerId: string;
}

// @public
export interface EntryPoint {
    position: LatLon;
    readonly type: EntryPointType;
}

// @public
export type EntryPointType = string;

// @public
export interface ErrorDetail {
    readonly code?: string;
    readonly message?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface FuzzySearchBaseOptions extends SearchPointOfInterestBaseOptions {
    entityType?: GeographicEntityType;
    indexFilter?: SearchIndexes[];
    maxFuzzyLevel?: number;
    minFuzzyLevel?: number;
}

// @public
export type FuzzySearchBatchOptions = OperationOptions & BatchPollerOptions;

// @public
export type FuzzySearchOptions = FuzzySearchBaseOptions;

// @public
export interface FuzzySearchRequest {
    // (undocumented)
    options?: FuzzySearchOptions;
    // (undocumented)
    searchQuery: SearchQuery;
}

// @public
export type GeographicEntityType = string;

// @public (undocumented)
export interface GeoJsonCircleFeature extends GeoJsonFeature {
    // (undocumented)
    geometry: GeoJsonPoint;
    // (undocumented)
    properties: {
        subType: "Circle";
        radius: number;
    };
}

// @public (undocumented)
export type GeoJsonCircleOrPolygonFeature = GeoJsonPolygonFeature | GeoJsonCircleFeature;

// @public
export interface GeoJsonCircleOrPolygonFeatureCollection extends GeoJsonFeatureCollection {
    // (undocumented)
    features: GeoJsonCircleOrPolygonFeature[];
}

// @public
export interface GeoJsonFeature extends GeoJsonObject {
    // (undocumented)
    geometry?: GeoJsonGeometry;
    // (undocumented)
    id?: number | string;
    // (undocumented)
    properties?: Record<string, any>;
    // (undocumented)
    type: "Feature";
}

// @public
export interface GeoJsonFeatureCollection extends GeoJsonObject {
    // (undocumented)
    features: GeoJsonFeature[];
    // (undocumented)
    type: "FeatureCollection";
}

// @public
export type GeoJsonGeometry = GeoJsonPoint | GeoJsonMultiPoint | GeoJsonLineString | GeoJsonMultiLineString | GeoJsonPolygon | GeoJsonMultiPolygon;

// @public
export interface GeoJsonGeometryCollection extends GeoJsonObject {
    // (undocumented)
    geometries: GeoJsonGeometry[];
    // (undocumented)
    type: "GeometryCollection";
}

// @public
export interface GeoJsonLineString extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[];
    // (undocumented)
    type: "LineString";
}

// @public
export interface GeoJsonMultiLineString extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][];
    // (undocumented)
    type: "MultiLineString";
}

// @public
export interface GeoJsonMultiPoint extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[];
    // (undocumented)
    type: "MultiPoint";
}

// @public
export interface GeoJsonMultiPolygon extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][][];
    // (undocumented)
    type: "MultiPolygon";
}

// @public
export interface GeoJsonObject {
    // (undocumented)
    bbox?: BBox;
    // (undocumented)
    type: GeoJsonType;
}

// @public
export interface GeoJsonPoint extends GeoJsonObject {
    // (undocumented)
    coordinates: Position;
    // (undocumented)
    type: "Point";
}

// @public
export interface GeoJsonPolygon extends GeoJsonObject {
    // (undocumented)
    coordinates: Position[][];
    // (undocumented)
    type: "Polygon";
}

// @public
export interface GeoJsonPolygonCollection extends GeoJsonGeometryCollection {
    // (undocumented)
    geometries: GeoJsonPolygon[];
}

// @public
export interface GeoJsonPolygonFeature extends GeoJsonFeature {
    // (undocumented)
    geometry: GeoJsonPolygon;
}

// @public
export type GeoJsonType = GeometryType | "Feature" | "FeatureCollection";

// @public
export interface GeometryIdentifier {
    readonly id: string;
}

// @public
export type GeometryType = "Point" | "MultiPoint" | "LineString" | "MultiLineString" | "Polygon" | "MultiPolygon" | "GeometryCollection";

// @public
export type GetGeometriesOptions = OperationOptions;

// @public
export interface GetPointOfInterestCategoriesOptions extends OperationOptions {
    language?: string;
}

// @public
export enum KnownElectricVehicleConnector {
    Chademo = "Chademo",
    IEC60309AC1PhaseBlue = "IEC60309AC1PhaseBlue",
    IEC60309DCWhite = "IEC60309DCWhite",
    IEC62196Type1 = "IEC62196Type1",
    IEC62196Type1CCS = "IEC62196Type1CCS",
    IEC62196Type2CableAttached = "IEC62196Type2CableAttached",
    IEC62196Type2CCS = "IEC62196Type2CCS",
    IEC62196Type2Outlet = "IEC62196Type2Outlet",
    IEC62196Type3 = "IEC62196Type3",
    StandardHouseholdCountrySpecific = "StandardHouseholdCountrySpecific",
    Tesla = "Tesla"
}

// @public
export enum KnownEntryPointType {
    // (undocumented)
    Main = "main",
    // (undocumented)
    Minor = "minor"
}

// @public
export enum KnownGeographicEntityType {
    // (undocumented)
    Country = "Country",
    // (undocumented)
    CountrySecondarySubdivision = "CountrySecondarySubdivision",
    // (undocumented)
    CountrySubdivision = "CountrySubdivision",
    // (undocumented)
    CountryTertiarySubdivision = "CountryTertiarySubdivision",
    // (undocumented)
    Municipality = "Municipality",
    // (undocumented)
    MunicipalitySubdivision = "MunicipalitySubdivision",
    // (undocumented)
    Neighbourhood = "Neighbourhood",
    // (undocumented)
    PostalCodeArea = "PostalCodeArea"
}

// @public
export enum KnownLocalizedMapView {
    AE = "AE",
    AR = "AR",
    Auto = "Auto",
    BH = "BH",
    IN = "IN",
    IQ = "IQ",
    JO = "JO",
    KW = "KW",
    LB = "LB",
    MA = "MA",
    OM = "OM",
    PK = "PK",
    PS = "PS",
    QA = "QA",
    SA = "SA",
    SY = "SY",
    Unified = "Unified",
    YE = "YE"
}

// @public
export enum KnownMatchType {
    // (undocumented)
    AddressPoint = "AddressPoint",
    // (undocumented)
    HouseNumberRange = "HouseNumberRange",
    // (undocumented)
    Street = "Street"
}

// @public
export enum KnownOperatingHoursRange {
    NextSevenDays = "nextSevenDays"
}

// @public
export enum KnownQueryType {
    Global = "NON_NEAR",
    Nearby = "NEARBY"
}

// @public
export enum KnownRoadUseType {
    // (undocumented)
    Arterial = "Arterial",
    // (undocumented)
    LimitedAccess = "LimitedAccess",
    // (undocumented)
    LocalStreet = "LocalStreet",
    // (undocumented)
    Ramp = "Ramp",
    // (undocumented)
    Rotary = "Rotary",
    // (undocumented)
    Terminal = "Terminal"
}

// @public
export enum KnownSearchAddressResultType {
    // (undocumented)
    AddressRange = "Address Range",
    // (undocumented)
    CrossStreet = "Cross Street",
    // (undocumented)
    Geography = "Geography",
    // (undocumented)
    POI = "POI",
    // (undocumented)
    PointAddress = "Point Address",
    // (undocumented)
    Street = "Street"
}

// @public
export enum KnownSearchIndexes {
    Address = "Addr",
    CrossStreets = "Xstr",
    Geographies = "Geo",
    PointAddresses = "PAD",
    PointsOfInterest = "POI",
    Streets = "Str"
}

// @public
export interface LatLon {
    // (undocumented)
    latitude: number;
    // (undocumented)
    longitude: number;
}

// @public
export type LocalizedMapView = string;

// @public
export class MapsSearchClient {
    constructor(credential: AzureKeyCredential, options?: MapsSearchClientOptions);
    constructor(credential: TokenCredential, mapsAccountClientId: string, options?: MapsSearchClientOptions);
    beginFuzzySearchBatch(requests: FuzzySearchRequest[], options?: FuzzySearchBatchOptions): Promise<BatchPoller<BatchResult<SearchAddressResult>>>;
    beginGetFuzzySearchBatchResult(batchId: string, options?: FuzzySearchBatchOptions): Promise<BatchPoller<BatchResult<SearchAddressResult>>>;
    beginGetReverseSearchAddressBatchResult(batchId: string, options?: ReverseSearchAddressBatchOptions): Promise<BatchPoller<BatchResult<ReverseSearchAddressResult>>>;
    beginGetSearchAddressBatchResult(batchId: string, options?: SearchAddressBatchOptions): Promise<BatchPoller<BatchResult<SearchAddressResult>>>;
    beginReverseSearchAddressBatch(requests: ReverseSearchAddressRequest[], options?: ReverseSearchAddressBatchOptions): Promise<BatchPoller<BatchResult<ReverseSearchAddressResult>>>;
    beginSearchAddressBatch(requests: SearchAddressRequest[], options?: SearchAddressBatchOptions): Promise<BatchPoller<BatchResult<SearchAddressResult>>>;
    fuzzySearch(searchQuery: SearchQuery, options?: FuzzySearchOptions & OperationOptions): Promise<SearchAddressResult>;
    getGeometries(geometryIds: string[], options?: GetGeometriesOptions): Promise<EntityGeometry[]>;
    getPointOfInterestCategories(options?: GetPointOfInterestCategoriesOptions): Promise<PointOfInterestCategory[]>;
    reverseSearchAddress(coordinates: LatLon, options?: ReverseSearchAddressOptions & OperationOptions): Promise<ReverseSearchAddressResult>;
    reverseSearchCrossStreetAddress(coordinates: LatLon, options?: ReverseSearchCrossStreetAddressOptions): Promise<ReverseSearchCrossStreetAddressResult>;
    searchAddress(query: string, options?: SearchAddressOptions & OperationOptions): Promise<SearchAddressResult>;
    searchAlongRoute(query: string, maxDetourTime: number, route: GeoJsonLineString, options?: SearchAlongRouteOptions): Promise<SearchAddressResult>;
    searchInsideGeometry(query: string, geometry: SearchGeometry, options?: SearchInsideGeometryOptions): Promise<SearchAddressResult>;
    searchNearbyPointOfInterest(coordinates: LatLon, options?: SearchNearbyPointOfInterestOptions): Promise<SearchAddressResult>;
    searchPointOfInterest(searchQuery: SearchQuery, options?: SearchPointOfInterestOptions): Promise<SearchAddressResult>;
    searchPointOfInterestCategory(searchQuery: SearchQuery, options?: SearchPointOfInterestCategoryOptions): Promise<SearchAddressResult>;
    searchStructuredAddress(structuredAddress: StructuredAddress, options?: SearchStructuredAddressOptions): Promise<SearchAddressResult>;
}

// @public
export type MapsSearchClientOptions = CommonClientOptions;

// @public
export type MatchType = string;

// @public
export interface OperatingHours {
    readonly mode: string;
    readonly timeRanges: OperatingHoursTimeRange[];
}

// @public
export type OperatingHoursRange = string;

// @public
export interface OperatingHoursTime {
    readonly date: string;
    readonly hour: number;
    readonly minute: number;
}

// @public
export interface OperatingHoursTimeRange {
    endTime: OperatingHoursTime;
    startTime: OperatingHoursTime;
}

// @public
export interface PointOfInterest {
    readonly brands?: Brand[];
    readonly categories?: string[];
    readonly categorySet?: PointOfInterestCategorySet[];
    readonly classifications?: Classification[];
    readonly name: string;
    operatingHours?: OperatingHours;
    readonly phone?: string;
    readonly url?: string;
}

// @public
export interface PointOfInterestCategory {
    readonly childIds: number[];
    readonly id: number;
    readonly name: string;
    readonly synonyms: string[];
}

// @public
export interface PointOfInterestCategorySet {
    readonly id: number;
}

// @public
export interface PointOfInterestCategoryTreeResult {
    readonly categories?: PointOfInterestCategory[];
}

// @public
export type Position = Position2D | Position3D;

// @public
export type Position2D = [longitude: number, latitude: number];

// @public
export type Position3D = [longitude: number, latitude: number, elevation: number];

// @public
export type QueryType = string;

// @public
export type ReverseSearchAddressBatchOptions = OperationOptions & BatchPollerOptions;

// @public
export interface ReverseSearchAddressOptions extends ReverseSearchBaseOptions {
    allowFreeformNewline?: boolean;
    entityType?: GeographicEntityType;
    includeMatchType?: boolean;
    includeRoadUse?: boolean;
    includeSpeedLimit?: boolean;
    roadUse?: RoadUseType[];
    streetNumber?: string;
}

// @public
export interface ReverseSearchAddressRequest {
    // (undocumented)
    coordinates: LatLon;
    // (undocumented)
    options?: ReverseSearchAddressOptions;
}

// @public (undocumented)
export interface ReverseSearchAddressResult {
    readonly numResults: number;
    readonly queryTime: number;
    readonly results: ReverseSearchAddressResultItem[];
}

// @public (undocumented)
export interface ReverseSearchAddressResultItem {
    readonly address: Address;
    readonly matchType?: MatchType;
    readonly position: LatLon;
    readonly roadUse?: RoadUseType[];
}

// @public
export interface ReverseSearchBaseOptions {
    heading?: number;
    language?: string;
    localizedMapView?: LocalizedMapView;
    radiusInMeters?: number;
}

// @public
export interface ReverseSearchCrossStreetAddressOptions extends ReverseSearchBaseOptions, OperationOptions {
    top?: number;
}

// @public (undocumented)
export interface ReverseSearchCrossStreetAddressResult {
    readonly numResults: number;
    readonly queryTime: number;
    readonly results: ReverseSearchCrossStreetAddressResultItem[];
}

// @public (undocumented)
export interface ReverseSearchCrossStreetAddressResultItem {
    readonly address?: Address;
    readonly position?: LatLon;
}

// @public
export type RoadUseType = string;

// @public
export interface SearchAddressBaseOptions extends SearchBaseOptions {
    boundingBox?: BoundingBox;
    isTypeAhead?: boolean;
    radiusInMeters?: number;
}

// @public
export type SearchAddressBatchOptions = OperationOptions & BatchPollerOptions;

// @public
export interface SearchAddressOptions extends SearchAddressBaseOptions {
    coordinates?: LatLon;
    countryCodeFilter?: string[];
    entityType?: GeographicEntityType;
}

// @public
export interface SearchAddressRequest {
    // (undocumented)
    options?: SearchAddressOptions;
    // (undocumented)
    query: string;
}

// @public
export interface SearchAddressResult {
    readonly fuzzyLevel?: number;
    readonly geoBias?: LatLon;
    readonly numResults: number;
    readonly query?: string;
    readonly queryTime: number;
    readonly queryType?: QueryType;
    readonly results: SearchAddressResultItem[];
    readonly skip?: number;
    readonly totalResults?: number;
}

// @public
export interface SearchAddressResultItem {
    readonly address: Address;
    readonly addressRanges?: AddressRanges;
    readonly dataSources?: DataSource;
    readonly detourTime?: number;
    readonly distanceInMeters?: number;
    readonly entityType?: GeographicEntityType;
    readonly entryPoints?: EntryPoint[];
    readonly id: string;
    readonly info?: string;
    readonly matchType?: MatchType;
    readonly pointOfInterest?: PointOfInterest;
    readonly position: LatLon;
    readonly score: number;
    readonly type: SearchAddressResultType;
    readonly viewport: BoundingBox;
}

// @public
export type SearchAddressResultType = string;

// @public
export interface SearchAlongRouteOptions extends SearchGeometryBaseOptions, OperationOptions {
    brandFilter?: string[];
    electricVehicleConnectorFilter?: ElectricVehicleConnector[];
}

// @public
export interface SearchBaseOptions {
    extendedPostalCodesFor?: SearchIndexes[];
    language?: string;
    localizedMapView?: LocalizedMapView;
    skip?: number;
    top?: number;
}

// @public
export interface SearchExtraFilterOptions {
    brandFilter?: string[];
    categoryFilter?: number[];
    electricVehicleConnectorFilter?: ElectricVehicleConnector[];
}

// @public (undocumented)
export type SearchGeometry = GeoJsonPolygon | GeoJsonPolygonCollection | GeoJsonCircleOrPolygonFeatureCollection;

// @public
export interface SearchGeometryBaseOptions {
    categoryFilter?: number[];
    localizedMapView?: LocalizedMapView;
    operatingHours?: OperatingHoursRange;
    top?: number;
}

// @public
export type SearchIndexes = string;

// @public
export interface SearchInsideGeometryOptions extends SearchGeometryBaseOptions, OperationOptions {
    extendedPostalCodesFor?: SearchIndexes[];
    indexFilter?: SearchIndexes[];
    language?: string;
}

// @public
export interface SearchNearbyPointOfInterestOptions extends SearchBaseOptions, SearchExtraFilterOptions, OperationOptions {
    countryCodeFilter?: string[];
    radiusInMeters?: number;
}

// @public
export interface SearchPointOfInterestBaseOptions extends SearchAddressBaseOptions, SearchExtraFilterOptions {
    operatingHours?: OperatingHoursRange;
}

// @public
export type SearchPointOfInterestCategoryOptions = SearchPointOfInterestOptions;

// @public
export type SearchPointOfInterestOptions = SearchPointOfInterestBaseOptions & OperationOptions;

// @public
export type SearchQuery = {
    query: string;
    coordinates: LatLon;
} | {
    query: string;
    countryCodeFilter: string[];
};

// @public
export interface SearchStructuredAddressOptions extends SearchBaseOptions, OperationOptions {
    entityType?: GeographicEntityType;
}

// @public
export interface StructuredAddress {
    countryCode: string;
    countrySecondarySubdivision?: string;
    countrySubdivision?: string;
    countryTertiarySubdivision?: string;
    crossStreet?: string;
    municipality?: string;
    municipalitySubdivision?: string;
    postalCode?: string;
    streetName?: string;
    streetNumber?: string;
}

// (No @packageDocumentation comment for this package)

```
