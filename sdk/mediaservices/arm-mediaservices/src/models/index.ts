/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError, AzureServiceClientOptions } from "@azure/ms-rest-azure-js";
import * as msRest from "@azure/ms-rest-js";

export { BaseResource, CloudError };

/**
 * Operation details.
 */
export interface OperationDisplay {
  /**
   * The service provider.
   */
  provider?: string;
  /**
   * Resource on which the operation is performed.
   */
  resource?: string;
  /**
   * The operation type.
   */
  operation?: string;
  /**
   * The operation description.
   */
  description?: string;
}

/**
 * A metric dimension.
 */
export interface MetricDimension {
  /**
   * The metric dimension name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The display name for the dimension.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly displayName?: string;
  /**
   * Whether to export metric to shoebox.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly toBeExportedForShoebox?: boolean;
}

/**
 * A metric emitted by service.
 */
export interface MetricSpecification {
  /**
   * The metric name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The metric display name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly displayName?: string;
  /**
   * The metric display description.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly displayDescription?: string;
  /**
   * The metric unit. Possible values include: 'Bytes', 'Count', 'Milliseconds'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly unit?: MetricUnit;
  /**
   * The metric aggregation type. Possible values include: 'Average', 'Count', 'Total'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly aggregationType?: MetricAggregationType;
  /**
   * The metric lock aggregation type. Possible values include: 'Average', 'Count', 'Total'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly lockAggregationType?: MetricAggregationType;
  /**
   * Supported aggregation types.
   */
  supportedAggregationTypes?: string[];
  /**
   * The metric dimensions.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly dimensions?: MetricDimension[];
  /**
   * Indicates whether regional MDM account is enabled.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly enableRegionalMdmAccount?: boolean;
  /**
   * The source MDM account.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly sourceMdmAccount?: string;
  /**
   * The source MDM namespace.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly sourceMdmNamespace?: string;
  /**
   * The supported time grain types.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly supportedTimeGrainTypes?: string[];
}

/**
 * A diagnostic log emitted by service.
 */
export interface LogSpecification {
  /**
   * The diagnostic log category name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The diagnostic log category display name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly displayName?: string;
  /**
   * The time range for requests in each blob.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly blobDuration?: string;
}

/**
 * The service metric specifications.
 */
export interface ServiceSpecification {
  /**
   * List of log specifications.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly logSpecifications?: LogSpecification[];
  /**
   * List of metric specifications.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly metricSpecifications?: MetricSpecification[];
}

/**
 * The service specification property.
 */
export interface Properties {
  /**
   * The service specifications.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly serviceSpecification?: ServiceSpecification;
}

/**
 * An operation.
 */
export interface Operation {
  /**
   * The operation name.
   */
  name: string;
  /**
   * The operation display name.
   */
  display?: OperationDisplay;
  /**
   * Origin of the operation.
   */
  origin?: string;
  /**
   * Operation properties format.
   */
  properties?: Properties;
  /**
   * Whether the operation applies to data-plane.
   */
  isDataAction?: boolean;
  /**
   * Indicates the action type. Possible values include: 'Internal'
   */
  actionType?: ActionType;
}

/**
 * The response from the check name availability request.
 */
export interface EntityNameAvailabilityCheckOutput {
  /**
   * Specifies if the name is available.
   */
  nameAvailable: boolean;
  /**
   * Specifies the reason if the name is not available.
   */
  reason?: string;
  /**
   * Specifies the detailed reason if the name is not available.
   */
  message?: string;
}

/**
 * An interface representing ResourceIdentity.
 */
export interface ResourceIdentity {
  /**
   * The user assigned managed identity's ARM ID to use when accessing a resource.
   */
  userAssignedIdentity?: string;
  /**
   * Indicates whether to use System Assigned Managed Identity. Mutual exclusive with User Assigned
   * Managed Identity.
   */
  useSystemAssignedIdentity: boolean;
}

/**
 * The storage account details.
 */
export interface StorageAccount {
  /**
   * The ID of the storage account resource. Media Services relies on tables and queues as well as
   * blobs, so the primary storage account must be a Standard Storage account (either
   * Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts can be added as
   * secondary storage accounts.
   */
  id?: string;
  /**
   * The type of the storage account. Possible values include: 'Primary', 'Secondary'
   */
  type: StorageAccountType;
  /**
   * The storage account identity.
   */
  identity?: ResourceIdentity;
  /**
   * The current status of the storage account mapping.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: string;
}

/**
 * The input to the sync storage keys request.
 */
export interface SyncStorageKeysInput {
  /**
   * The ID of the storage account resource.
   */
  id?: string;
}

/**
 * An interface representing KeyVaultProperties.
 */
export interface KeyVaultProperties {
  /**
   * The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for
   * example https://vault/keys/mykey/version1) or reference a key without a version (for example
   * https://vault/keys/mykey).
   */
  keyIdentifier?: string;
  /**
   * The current key used to encrypt the Media Services account, including the key version.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly currentKeyIdentifier?: string;
}

/**
 * An interface representing AccountEncryption.
 */
export interface AccountEncryption {
  /**
   * The type of key used to encrypt the Account Key. Possible values include: 'SystemKey',
   * 'CustomerKey'
   */
  type: AccountEncryptionKeyType;
  /**
   * The properties of the key used to encrypt the account.
   */
  keyVaultProperties?: KeyVaultProperties;
  /**
   * The Key Vault identity.
   */
  identity?: ResourceIdentity;
  /**
   * The current status of the Key Vault mapping.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: string;
}

/**
 * An interface representing AccessControl.
 */
export interface AccessControl {
  /**
   * The behavior for IP access control in Key Delivery. Possible values include: 'Allow', 'Deny'
   */
  defaultAction?: DefaultAction;
  /**
   * The IP allow list for access control in Key Delivery. If the default action is set to 'Allow',
   * the IP allow list must be empty.
   */
  ipAllowList?: string[];
}

/**
 * An interface representing KeyDelivery.
 */
export interface KeyDelivery {
  /**
   * The access control properties for Key Delivery.
   */
  accessControl?: AccessControl;
}

/**
 * An interface representing UserAssignedManagedIdentity.
 */
export interface UserAssignedManagedIdentity {
  /**
   * The client ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clientId?: string;
  /**
   * The principal ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly principalId?: string;
}

/**
 * An interface representing MediaServiceIdentity.
 */
export interface MediaServiceIdentity {
  /**
   * The identity type.
   */
  type: string;
  /**
   * The Principal ID of the identity.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly principalId?: string;
  /**
   * The Tenant ID of the identity.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly tenantId?: string;
  /**
   * The user assigned managed identities.
   */
  userAssignedIdentities?: { [propertyName: string]: UserAssignedManagedIdentity };
}

/**
 * Metadata pertaining to creation and last modification of the resource.
 */
export interface SystemData {
  /**
   * The identity that created the resource.
   */
  createdBy?: string;
  /**
   * The type of identity that created the resource. Possible values include: 'User',
   * 'Application', 'ManagedIdentity', 'Key'
   */
  createdByType?: CreatedByType;
  /**
   * The timestamp of resource creation (UTC).
   */
  createdAt?: Date;
  /**
   * The identity that last modified the resource.
   */
  lastModifiedBy?: string;
  /**
   * The type of identity that last modified the resource. Possible values include: 'User',
   * 'Application', 'ManagedIdentity', 'Key'
   */
  lastModifiedByType?: CreatedByType;
  /**
   * The timestamp of resource last modification (UTC)
   */
  lastModifiedAt?: Date;
}

/**
 * Common fields that are returned in the response for all Azure Resource Manager resources
 * @summary Resource
 */
export interface Resource extends BaseResource {
  /**
   * Fully qualified resource ID for the resource. Ex -
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
  /**
   * The name of the resource
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
   * "Microsoft.Storage/storageAccounts"
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
}

/**
 * The resource model definition for an Azure Resource Manager tracked top level resource which has
 * 'tags' and a 'location'
 * @summary Tracked Resource
 */
export interface TrackedResource extends Resource {
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * The geo-location where the resource lives
   */
  location: string;
}

/**
 * A Media Services account.
 */
export interface MediaService extends TrackedResource {
  /**
   * The Media Services account ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly mediaServiceId?: string;
  /**
   * The storage accounts for this resource.
   */
  storageAccounts?: StorageAccount[];
  /**
   * Possible values include: 'System', 'ManagedIdentity'
   */
  storageAuthentication?: StorageAuthentication;
  /**
   * The account encryption properties.
   */
  encryption?: AccountEncryption;
  /**
   * The Key Delivery properties for Media Services account.
   */
  keyDelivery?: KeyDelivery;
  /**
   * Whether or not public network access is allowed for resources under the Media Services
   * account. Possible values include: 'Enabled', 'Disabled'
   */
  publicNetworkAccess?: PublicNetworkAccess;
  /**
   * The Managed Identity for the Media Services account.
   */
  identity?: MediaServiceIdentity;
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * A Media Services account update.
 */
export interface MediaServiceUpdate {
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * The Media Services account ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly mediaServiceId?: string;
  /**
   * The storage accounts for this resource.
   */
  storageAccounts?: StorageAccount[];
  /**
   * Possible values include: 'System', 'ManagedIdentity'
   */
  storageAuthentication?: StorageAuthentication;
  /**
   * The account encryption properties.
   */
  encryption?: AccountEncryption;
  /**
   * The Key Delivery properties for Media Services account.
   */
  keyDelivery?: KeyDelivery;
  /**
   * Whether or not public network access is allowed for resources under the Media Services
   * account. Possible values include: 'Enabled', 'Disabled'
   */
  publicNetworkAccess?: PublicNetworkAccess;
  /**
   * The Managed Identity for the Media Services account.
   */
  identity?: MediaServiceIdentity;
}

/**
 * An interface representing ListEdgePoliciesInput.
 */
export interface ListEdgePoliciesInput {
  /**
   * Unique identifier of the edge device.
   */
  deviceId?: string;
}

/**
 * An interface representing EdgeUsageDataEventHub.
 */
export interface EdgeUsageDataEventHub {
  /**
   * Name of the Event Hub where usage will be reported.
   */
  name?: string;
  /**
   * Namespace of the Event Hub where usage will be reported.
   */
  namespace?: string;
  /**
   * SAS token needed to interact with Event Hub.
   */
  token?: string;
}

/**
 * An interface representing EdgeUsageDataCollectionPolicy.
 */
export interface EdgeUsageDataCollectionPolicy {
  /**
   * Usage data collection frequency in ISO 8601 duration format e.g. PT10M , PT5H.
   */
  dataCollectionFrequency?: string;
  /**
   * Usage data reporting frequency in ISO 8601 duration format e.g. PT10M , PT5H.
   */
  dataReportingFrequency?: string;
  /**
   * Maximum time for which the functionality of the device will not be hampered for not reporting
   * the usage data.
   */
  maxAllowedUnreportedUsageDuration?: string;
  /**
   * Details of Event Hub where the usage will be reported.
   */
  eventHubDetails?: EdgeUsageDataEventHub;
}

/**
 * An interface representing EdgePolicies.
 */
export interface EdgePolicies {
  usageDataCollectionPolicy?: EdgeUsageDataCollectionPolicy;
}

/**
 * A collection of Operation items.
 */
export interface OperationCollection {
  /**
   * A collection of Operation items.
   */
  value?: Operation[];
}

/**
 * The input to the check name availability request.
 */
export interface CheckNameAvailabilityInput {
  /**
   * The account name.
   */
  name?: string;
  /**
   * The account type. For a Media Services account, this should be 'MediaServices'.
   */
  type?: string;
}

/**
 * The resource management error additional info.
 */
export interface ErrorAdditionalInfo {
  /**
   * The additional info type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
  /**
   * The additional info.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly info?: any;
}

/**
 * The error detail.
 */
export interface ErrorDetail {
  /**
   * The error code.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly code?: string;
  /**
   * The error message.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
  /**
   * The error target.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly target?: string;
  /**
   * The error details.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly details?: ErrorDetail[];
  /**
   * The error additional info.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly additionalInfo?: ErrorAdditionalInfo[];
}

/**
 * Common error response for all Azure Resource Manager APIs to return error details for failed
 * operations. (This also follows the OData error response format.).
 * @summary Error response
 */
export interface ErrorResponse {
  /**
   * The error object.
   */
  error?: ErrorDetail;
}

/**
 * The resource model definition for a Azure Resource Manager proxy resource. It will not have tags
 * and a location
 * @summary Proxy Resource
 */
export interface ProxyResource extends Resource {
}

/**
 * The resource model definition for an Azure Resource Manager resource with an etag.
 * @summary Entity Resource
 */
export interface AzureEntityResource extends Resource {
  /**
   * Resource Etag.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly etag?: string;
}

/**
 * A collection of information about the state of the connection between service consumer and
 * provider.
 */
export interface PrivateLinkServiceConnectionState {
  /**
   * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the
   * service. Possible values include: 'Pending', 'Approved', 'Rejected'
   */
  status?: PrivateEndpointServiceConnectionStatus;
  /**
   * The reason for approval/rejection of the connection.
   */
  description?: string;
  /**
   * A message indicating if changes on the service provider require any updates on the consumer.
   */
  actionsRequired?: string;
}

/**
 * The Private Endpoint resource.
 */
export interface PrivateEndpoint {
  /**
   * The ARM identifier for Private Endpoint
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
}

/**
 * The Private Endpoint Connection resource.
 */
export interface PrivateEndpointConnection extends Resource {
  /**
   * The resource of private end point.
   */
  privateEndpoint?: PrivateEndpoint;
  /**
   * A collection of information about the state of the connection between service consumer and
   * provider.
   */
  privateLinkServiceConnectionState: PrivateLinkServiceConnectionState;
  /**
   * The provisioning state of the private endpoint connection resource. Possible values include:
   * 'Succeeded', 'Creating', 'Deleting', 'Failed'
   */
  provisioningState?: PrivateEndpointConnectionProvisioningState;
}

/**
 * List of private endpoint connection associated with the specified storage account
 */
export interface PrivateEndpointConnectionListResult {
  /**
   * Array of private endpoint connections
   */
  value?: PrivateEndpointConnection[];
}

/**
 * A private link resource
 */
export interface PrivateLinkResource extends Resource {
  /**
   * The private link resource group id.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly groupId?: string;
  /**
   * The private link resource required member names.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly requiredMembers?: string[];
  /**
   * The private link resource Private link DNS zone name.
   */
  requiredZoneNames?: string[];
}

/**
 * A list of private link resources
 */
export interface PrivateLinkResourceListResult {
  /**
   * Array of private link resources
   */
  value?: PrivateLinkResource[];
}

/**
 * The presentation time range, this is asset related and not recommended for Account Filter.
 */
export interface PresentationTimeRange {
  /**
   * The absolute start time boundary.
   */
  startTimestamp?: number;
  /**
   * The absolute end time boundary.
   */
  endTimestamp?: number;
  /**
   * The relative to end sliding window.
   */
  presentationWindowDuration?: number;
  /**
   * The relative to end right edge.
   */
  liveBackoffDuration?: number;
  /**
   * The time scale of time stamps.
   */
  timescale?: number;
  /**
   * The indicator of forcing existing of end time stamp.
   */
  forceEndTimestamp?: boolean;
}

/**
 * The class to specify one track property condition.
 */
export interface FilterTrackPropertyCondition {
  /**
   * The track property type. Possible values include: 'Unknown', 'Type', 'Name', 'Language',
   * 'FourCC', 'Bitrate'
   */
  property: FilterTrackPropertyType;
  /**
   * The track property value.
   */
  value: string;
  /**
   * The track property condition operation. Possible values include: 'Equal', 'NotEqual'
   */
  operation: FilterTrackPropertyCompareOperation;
}

/**
 * Filter First Quality
 */
export interface FirstQuality {
  /**
   * The first quality bitrate.
   */
  bitrate: number;
}

/**
 * Representing a list of FilterTrackPropertyConditions to select a track.  The filters are
 * combined using a logical AND operation.
 */
export interface FilterTrackSelection {
  /**
   * The track selections.
   */
  trackSelections: FilterTrackPropertyCondition[];
}

/**
 * An Account Filter.
 */
export interface AccountFilter extends ProxyResource {
  /**
   * The presentation time range.
   */
  presentationTimeRange?: PresentationTimeRange;
  /**
   * The first quality.
   */
  firstQuality?: FirstQuality;
  /**
   * The tracks selection conditions.
   */
  tracks?: FilterTrackSelection[];
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * The Asset Storage container SAS URLs.
 */
export interface AssetContainerSas {
  /**
   * The list of Asset container SAS URLs.
   */
  assetContainerSasUrls?: string[];
}

/**
 * The Asset File Storage encryption metadata.
 */
export interface AssetFileEncryptionMetadata {
  /**
   * The Asset File initialization vector.
   */
  initializationVector?: string;
  /**
   * The Asset File name.
   */
  assetFileName?: string;
  /**
   * The Asset File Id.
   */
  assetFileId: string;
}

/**
 * Data needed to decrypt asset files encrypted with legacy storage encryption.
 */
export interface StorageEncryptedAssetDecryptionData {
  /**
   * The Asset File storage encryption key.
   */
  key?: Uint8Array;
  /**
   * Asset File encryption metadata.
   */
  assetFileEncryptionMetadata?: AssetFileEncryptionMetadata[];
}

/**
 * Properties of the Streaming Locator.
 */
export interface AssetStreamingLocator {
  /**
   * Streaming Locator name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * Asset Name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly assetName?: string;
  /**
   * The creation time of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * The start time of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly startTime?: Date;
  /**
   * The end time of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly endTime?: Date;
  /**
   * StreamingLocatorId of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly streamingLocatorId?: string;
  /**
   * Name of the Streaming Policy used by this Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly streamingPolicyName?: string;
  /**
   * Name of the default ContentKeyPolicy used by this Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly defaultContentKeyPolicyName?: string;
}

/**
 * The Streaming Locators associated with this Asset.
 */
export interface ListStreamingLocatorsResponse {
  /**
   * The list of Streaming Locators.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly streamingLocators?: AssetStreamingLocator[];
}

/**
 * An Asset.
 */
export interface Asset extends ProxyResource {
  /**
   * The Asset ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly assetId?: string;
  /**
   * The creation date of the Asset.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * The last modified date of the Asset.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly lastModified?: Date;
  /**
   * The alternate ID of the Asset.
   */
  alternateId?: string;
  /**
   * The Asset description.
   */
  description?: string;
  /**
   * The name of the asset blob container.
   */
  container?: string;
  /**
   * The name of the storage account.
   */
  storageAccountName?: string;
  /**
   * The Asset encryption format. One of None or MediaStorageEncryption. Possible values include:
   * 'None', 'MediaStorageClientEncryption'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly storageEncryptionFormat?: AssetStorageEncryptionFormat;
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * An Asset Filter.
 */
export interface AssetFilter extends ProxyResource {
  /**
   * The presentation time range.
   */
  presentationTimeRange?: PresentationTimeRange;
  /**
   * The first quality.
   */
  firstQuality?: FirstQuality;
  /**
   * The tracks selection conditions.
   */
  tracks?: FilterTrackSelection[];
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * The parameters to the list SAS request.
 */
export interface ListContainerSasInput {
  /**
   * The permissions to set on the SAS URL. Possible values include: 'Read', 'ReadWrite',
   * 'ReadWriteDelete'
   */
  permissions?: AssetContainerPermission;
  /**
   * The SAS URL expiration time.  This must be less than 24 hours from the current time.
   */
  expiryTime?: Date;
}

/**
 * Configures the Explicit Analog Television Output Restriction control bits. For further details
 * see the PlayReady Compliance Rules.
 */
export interface ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
  /**
   * Indicates whether this restriction is enforced on a Best Effort basis.
   */
  bestEffort: boolean;
  /**
   * Configures the restriction control bits. Must be between 0 and 3 inclusive.
   */
  configurationData: number;
}

/**
 * Contains the possible cases for ContentKeyPolicyPlayReadyContentKeyLocation.
 */
export type ContentKeyPolicyPlayReadyContentKeyLocationUnion = ContentKeyPolicyPlayReadyContentKeyLocation | ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader | ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier;

/**
 * Base class for content key ID location. A derived class must be used to represent the location.
 */
export interface ContentKeyPolicyPlayReadyContentKeyLocation {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "ContentKeyPolicyPlayReadyContentKeyLocation";
}

/**
 * Specifies that the content key ID is in the PlayReady header.
 */
export interface ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader";
}

/**
 * Specifies that the content key ID is specified in the PlayReady configuration.
 */
export interface ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier";
  /**
   * The content key ID.
   */
  keyId: string;
}

/**
 * Configures the Play Right in the PlayReady license.
 */
export interface ContentKeyPolicyPlayReadyPlayRight {
  /**
   * The amount of time that the license is valid after the license is first used to play content.
   */
  firstPlayExpiration?: string;
  /**
   * Configures the Serial Copy Management System (SCMS) in the license. Must be between 0 and 3
   * inclusive.
   */
  scmsRestriction?: number;
  /**
   * Configures Automatic Gain Control (AGC) and Color Stripe in the license. Must be between 0 and
   * 3 inclusive.
   */
  agcAndColorStripeRestriction?: number;
  /**
   * Configures the Explicit Analog Television Output Restriction in the license. Configuration
   * data must be between 0 and 3 inclusive.
   */
  explicitAnalogTelevisionOutputRestriction?: ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction;
  /**
   * Enables the Image Constraint For Analog Component Video Restriction in the license.
   */
  digitalVideoOnlyContentRestriction: boolean;
  /**
   * Enables the Image Constraint For Analog Component Video Restriction in the license.
   */
  imageConstraintForAnalogComponentVideoRestriction: boolean;
  /**
   * Enables the Image Constraint For Analog Component Video Restriction in the license.
   */
  imageConstraintForAnalogComputerMonitorRestriction: boolean;
  /**
   * Configures Unknown output handling settings of the license. Possible values include:
   * 'Unknown', 'NotAllowed', 'Allowed', 'AllowedWithVideoConstriction'
   */
  allowPassingVideoContentToUnknownOutput: ContentKeyPolicyPlayReadyUnknownOutputPassingOption;
  /**
   * Specifies the output protection level for uncompressed digital video.
   */
  uncompressedDigitalVideoOpl?: number;
  /**
   * Specifies the output protection level for compressed digital video.
   */
  compressedDigitalVideoOpl?: number;
  /**
   * Specifies the output protection level for compressed digital audio.
   */
  analogVideoOpl?: number;
  /**
   * Specifies the output protection level for compressed digital audio.
   */
  compressedDigitalAudioOpl?: number;
  /**
   * Specifies the output protection level for uncompressed digital audio.
   */
  uncompressedDigitalAudioOpl?: number;
}

/**
 * Represents a token claim.
 */
export interface ContentKeyPolicyTokenClaim {
  /**
   * Token claim type.
   */
  claimType?: string;
  /**
   * Token claim value.
   */
  claimValue?: string;
}

/**
 * The PlayReady license
 */
export interface ContentKeyPolicyPlayReadyLicense {
  /**
   * A flag indicating whether test devices can use the license.
   */
  allowTestDevices: boolean;
  /**
   * The begin date of license
   */
  beginDate?: Date;
  /**
   * The expiration date of license.
   */
  expirationDate?: Date;
  /**
   * The relative begin date of license.
   */
  relativeBeginDate?: string;
  /**
   * The relative expiration date of license.
   */
  relativeExpirationDate?: string;
  /**
   * The grace period of license.
   */
  gracePeriod?: string;
  /**
   * The license PlayRight
   */
  playRight?: ContentKeyPolicyPlayReadyPlayRight;
  /**
   * The license type. Possible values include: 'Unknown', 'NonPersistent', 'Persistent'
   */
  licenseType: ContentKeyPolicyPlayReadyLicenseType;
  /**
   * The content key location.
   */
  contentKeyLocation: ContentKeyPolicyPlayReadyContentKeyLocationUnion;
  /**
   * The PlayReady content type. Possible values include: 'Unknown', 'Unspecified',
   * 'UltraVioletDownload', 'UltraVioletStreaming'
   */
  contentType: ContentKeyPolicyPlayReadyContentType;
}

/**
 * Contains the possible cases for ContentKeyPolicyRestriction.
 */
export type ContentKeyPolicyRestrictionUnion = ContentKeyPolicyRestriction | ContentKeyPolicyOpenRestriction | ContentKeyPolicyUnknownRestriction | ContentKeyPolicyTokenRestriction;

/**
 * Base class for Content Key Policy restrictions. A derived class must be used to create a
 * restriction.
 */
export interface ContentKeyPolicyRestriction {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "ContentKeyPolicyRestriction";
}

/**
 * Represents an open restriction. License or key will be delivered on every request.
 */
export interface ContentKeyPolicyOpenRestriction {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyOpenRestriction";
}

/**
 * Represents a ContentKeyPolicyRestriction that is unavailable in the current API version.
 */
export interface ContentKeyPolicyUnknownRestriction {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyUnknownRestriction";
}

/**
 * Contains the possible cases for ContentKeyPolicyConfiguration.
 */
export type ContentKeyPolicyConfigurationUnion = ContentKeyPolicyConfiguration | ContentKeyPolicyClearKeyConfiguration | ContentKeyPolicyUnknownConfiguration | ContentKeyPolicyWidevineConfiguration | ContentKeyPolicyPlayReadyConfiguration | ContentKeyPolicyFairPlayConfiguration;

/**
 * Base class for Content Key Policy configuration. A derived class must be used to create a
 * configuration.
 */
export interface ContentKeyPolicyConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "ContentKeyPolicyConfiguration";
}

/**
 * Contains the possible cases for ContentKeyPolicyRestrictionTokenKey.
 */
export type ContentKeyPolicyRestrictionTokenKeyUnion = ContentKeyPolicyRestrictionTokenKey | ContentKeyPolicySymmetricTokenKey | ContentKeyPolicyRsaTokenKey | ContentKeyPolicyX509CertificateTokenKey;

/**
 * Base class for Content Key Policy key for token validation. A derived class must be used to
 * create a token key.
 */
export interface ContentKeyPolicyRestrictionTokenKey {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "ContentKeyPolicyRestrictionTokenKey";
}

/**
 * Specifies a symmetric key for token validation.
 */
export interface ContentKeyPolicySymmetricTokenKey {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey";
  /**
   * The key value of the key
   */
  keyValue: Uint8Array;
}

/**
 * Specifies a RSA key for token validation
 */
export interface ContentKeyPolicyRsaTokenKey {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyRsaTokenKey";
  /**
   * The RSA Parameter exponent
   */
  exponent: Uint8Array;
  /**
   * The RSA Parameter modulus
   */
  modulus: Uint8Array;
}

/**
 * Specifies a certificate for token validation.
 */
export interface ContentKeyPolicyX509CertificateTokenKey {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey";
  /**
   * The raw data field of a certificate in PKCS 12 format (X509Certificate2 in .NET)
   */
  rawBody: Uint8Array;
}

/**
 * Represents a token restriction. Provided token must match these requirements for successful
 * license or key delivery.
 */
export interface ContentKeyPolicyTokenRestriction {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyTokenRestriction";
  /**
   * The token issuer.
   */
  issuer: string;
  /**
   * The audience for the token.
   */
  audience: string;
  /**
   * The primary verification key.
   */
  primaryVerificationKey: ContentKeyPolicyRestrictionTokenKeyUnion;
  /**
   * A list of alternative verification keys.
   */
  alternateVerificationKeys?: ContentKeyPolicyRestrictionTokenKeyUnion[];
  /**
   * A list of required token claims.
   */
  requiredClaims?: ContentKeyPolicyTokenClaim[];
  /**
   * The type of token. Possible values include: 'Unknown', 'Swt', 'Jwt'
   */
  restrictionTokenType: ContentKeyPolicyRestrictionTokenType;
  /**
   * The OpenID connect discovery document.
   */
  openIdConnectDiscoveryDocument?: string;
}

/**
 * Represents a configuration for non-DRM keys.
 */
export interface ContentKeyPolicyClearKeyConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration";
}

/**
 * Represents a ContentKeyPolicyConfiguration that is unavailable in the current API version.
 */
export interface ContentKeyPolicyUnknownConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration";
}

/**
 * Specifies a configuration for Widevine licenses.
 */
export interface ContentKeyPolicyWidevineConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration";
  /**
   * The Widevine template.
   */
  widevineTemplate: string;
}

/**
 * Specifies a configuration for PlayReady licenses.
 */
export interface ContentKeyPolicyPlayReadyConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration";
  /**
   * The PlayReady licenses.
   */
  licenses: ContentKeyPolicyPlayReadyLicense[];
  /**
   * The custom response data.
   */
  responseCustomData?: string;
}

/**
 * An interface representing ContentKeyPolicyFairPlayOfflineRentalConfiguration.
 */
export interface ContentKeyPolicyFairPlayOfflineRentalConfiguration {
  /**
   * Playback duration
   */
  playbackDurationSeconds: number;
  /**
   * Storage duration
   */
  storageDurationSeconds: number;
}

/**
 * Specifies a configuration for FairPlay licenses.
 */
export interface ContentKeyPolicyFairPlayConfiguration {
  /**
   * Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration";
  /**
   * The key that must be used as FairPlay Application Secret key.
   */
  ask: Uint8Array;
  /**
   * The password encrypting FairPlay certificate in PKCS 12 (pfx) format.
   */
  fairPlayPfxPassword: string;
  /**
   * The Base64 representation of FairPlay certificate in PKCS 12 (pfx) format (including private
   * key).
   */
  fairPlayPfx: string;
  /**
   * The rental and lease key type. Possible values include: 'Unknown', 'Undefined', 'DualExpiry',
   * 'PersistentUnlimited', 'PersistentLimited'
   */
  rentalAndLeaseKeyType: ContentKeyPolicyFairPlayRentalAndLeaseKeyType;
  /**
   * The rental duration. Must be greater than or equal to 0.
   */
  rentalDuration: number;
  /**
   * Offline rental policy
   */
  offlineRentalConfiguration?: ContentKeyPolicyFairPlayOfflineRentalConfiguration;
}

/**
 * Represents a policy option.
 */
export interface ContentKeyPolicyOption {
  /**
   * The legacy Policy Option ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly policyOptionId?: string;
  /**
   * The Policy Option description.
   */
  name?: string;
  /**
   * The key delivery configuration.
   */
  configuration: ContentKeyPolicyConfigurationUnion;
  /**
   * The requirements that must be met to deliver keys with this configuration
   */
  restriction: ContentKeyPolicyRestrictionUnion;
}

/**
 * The properties of the Content Key Policy.
 */
export interface ContentKeyPolicyProperties {
  /**
   * The legacy Policy ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly policyId?: string;
  /**
   * The creation date of the Policy
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * The last modified date of the Policy
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly lastModified?: Date;
  /**
   * A description for the Policy.
   */
  description?: string;
  /**
   * The Key Policy options.
   */
  options: ContentKeyPolicyOption[];
}

/**
 * A Content Key Policy resource.
 */
export interface ContentKeyPolicy extends ProxyResource {
  /**
   * The legacy Policy ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly policyId?: string;
  /**
   * The creation date of the Policy
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * The last modified date of the Policy
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly lastModified?: Date;
  /**
   * A description for the Policy.
   */
  description?: string;
  /**
   * The Key Policy options.
   */
  options: ContentKeyPolicyOption[];
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * Class to specify one track property condition
 */
export interface TrackPropertyCondition {
  /**
   * Track property type. Possible values include: 'Unknown', 'FourCC'
   */
  property: TrackPropertyType;
  /**
   * Track property condition operation. Possible values include: 'Unknown', 'Equal'
   */
  operation: TrackPropertyCompareOperation;
  /**
   * Track property value
   */
  value?: string;
}

/**
 * Class to select a track
 */
export interface TrackSelection {
  /**
   * TrackSelections is a track property condition list which can specify track(s)
   */
  trackSelections?: TrackPropertyCondition[];
}

/**
 * Class to specify properties of default content key for each encryption scheme
 */
export interface DefaultKey {
  /**
   * Label can be used to specify Content Key when creating a Streaming Locator
   */
  label?: string;
  /**
   * Policy used by Default Key
   */
  policyName?: string;
}

/**
 * Class to specify properties of content key
 */
export interface StreamingPolicyContentKey {
  /**
   * Label can be used to specify Content Key when creating a Streaming Locator
   */
  label?: string;
  /**
   * Policy used by Content Key
   */
  policyName?: string;
  /**
   * Tracks which use this content key
   */
  tracks?: TrackSelection[];
}

/**
 * Class to specify properties of all content keys in Streaming Policy
 */
export interface StreamingPolicyContentKeys {
  /**
   * Default content key for an encryption scheme
   */
  defaultKey?: DefaultKey;
  /**
   * Representing tracks needs separate content key
   */
  keyToTrackMappings?: StreamingPolicyContentKey[];
}

/**
 * Class to specify configurations of PlayReady in Streaming Policy
 */
export interface StreamingPolicyPlayReadyConfiguration {
  /**
   * Template for the URL of the custom service delivering licenses to end user players.  Not
   * required when using Azure Media Services for issuing licenses.  The template supports
   * replaceable tokens that the service will update at runtime with the value specific to the
   * request.  The currently supported token values are {AlternativeMediaId}, which is replaced
   * with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced
   * with the value of identifier of the key being requested.
   */
  customLicenseAcquisitionUrlTemplate?: string;
  /**
   * Custom attributes for PlayReady
   */
  playReadyCustomAttributes?: string;
}

/**
 * Class to specify configurations of Widevine in Streaming Policy
 */
export interface StreamingPolicyWidevineConfiguration {
  /**
   * Template for the URL of the custom service delivering licenses to end user players.  Not
   * required when using Azure Media Services for issuing licenses.  The template supports
   * replaceable tokens that the service will update at runtime with the value specific to the
   * request.  The currently supported token values are {AlternativeMediaId}, which is replaced
   * with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced
   * with the value of identifier of the key being requested.
   */
  customLicenseAcquisitionUrlTemplate?: string;
}

/**
 * Class to specify configurations of FairPlay in Streaming Policy
 */
export interface StreamingPolicyFairPlayConfiguration {
  /**
   * Template for the URL of the custom service delivering licenses to end user players.  Not
   * required when using Azure Media Services for issuing licenses.  The template supports
   * replaceable tokens that the service will update at runtime with the value specific to the
   * request.  The currently supported token values are {AlternativeMediaId}, which is replaced
   * with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced
   * with the value of identifier of the key being requested.
   */
  customLicenseAcquisitionUrlTemplate?: string;
  /**
   * All license to be persistent or not
   */
  allowPersistentLicense: boolean;
}

/**
 * Class to specify DRM configurations of CommonEncryptionCbcs scheme in Streaming Policy
 */
export interface CbcsDrmConfiguration {
  /**
   * FairPlay configurations
   */
  fairPlay?: StreamingPolicyFairPlayConfiguration;
  /**
   * PlayReady configurations
   */
  playReady?: StreamingPolicyPlayReadyConfiguration;
  /**
   * Widevine configurations
   */
  widevine?: StreamingPolicyWidevineConfiguration;
}

/**
 * Class to specify DRM configurations of CommonEncryptionCenc scheme in Streaming Policy
 */
export interface CencDrmConfiguration {
  /**
   * PlayReady configurations
   */
  playReady?: StreamingPolicyPlayReadyConfiguration;
  /**
   * Widevine configurations
   */
  widevine?: StreamingPolicyWidevineConfiguration;
}

/**
 * Class to specify which protocols are enabled
 */
export interface EnabledProtocols {
  /**
   * Enable Download protocol or not
   */
  download: boolean;
  /**
   * Enable DASH protocol or not
   */
  dash: boolean;
  /**
   * Enable HLS protocol or not
   */
  hls: boolean;
  /**
   * Enable SmoothStreaming protocol or not
   */
  smoothStreaming: boolean;
}

/**
 * Class for NoEncryption scheme
 */
export interface NoEncryption {
  /**
   * Representing supported protocols
   */
  enabledProtocols?: EnabledProtocols;
}

/**
 * Class for EnvelopeEncryption encryption scheme
 */
export interface EnvelopeEncryption {
  /**
   * Representing supported protocols
   */
  enabledProtocols?: EnabledProtocols;
  /**
   * Representing which tracks should not be encrypted
   */
  clearTracks?: TrackSelection[];
  /**
   * Representing default content key for each encryption scheme and separate content keys for
   * specific tracks
   */
  contentKeys?: StreamingPolicyContentKeys;
  /**
   * Template for the URL of the custom service delivering keys to end user players.  Not required
   * when using Azure Media Services for issuing keys.  The template supports replaceable tokens
   * that the service will update at runtime with the value specific to the request.  The currently
   * supported token values are {AlternativeMediaId}, which is replaced with the value of
   * StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of
   * identifier of the key being requested.
   */
  customKeyAcquisitionUrlTemplate?: string;
}

/**
 * Class for envelope encryption scheme
 */
export interface CommonEncryptionCenc {
  /**
   * Representing supported protocols
   */
  enabledProtocols?: EnabledProtocols;
  /**
   * Representing which tracks should not be encrypted
   */
  clearTracks?: TrackSelection[];
  /**
   * Representing default content key for each encryption scheme and separate content keys for
   * specific tracks
   */
  contentKeys?: StreamingPolicyContentKeys;
  /**
   * Configuration of DRMs for CommonEncryptionCenc encryption scheme
   */
  drm?: CencDrmConfiguration;
}

/**
 * Class for CommonEncryptionCbcs encryption scheme
 */
export interface CommonEncryptionCbcs {
  /**
   * Representing supported protocols
   */
  enabledProtocols?: EnabledProtocols;
  /**
   * Representing which tracks should not be encrypted
   */
  clearTracks?: TrackSelection[];
  /**
   * Representing default content key for each encryption scheme and separate content keys for
   * specific tracks
   */
  contentKeys?: StreamingPolicyContentKeys;
  /**
   * Configuration of DRMs for current encryption scheme
   */
  drm?: CbcsDrmConfiguration;
}

/**
 * A Streaming Policy resource
 */
export interface StreamingPolicy extends ProxyResource {
  /**
   * Creation time of Streaming Policy
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * Default ContentKey used by current Streaming Policy
   */
  defaultContentKeyPolicyName?: string;
  /**
   * Configuration of EnvelopeEncryption
   */
  envelopeEncryption?: EnvelopeEncryption;
  /**
   * Configuration of CommonEncryptionCenc
   */
  commonEncryptionCenc?: CommonEncryptionCenc;
  /**
   * Configuration of CommonEncryptionCbcs
   */
  commonEncryptionCbcs?: CommonEncryptionCbcs;
  /**
   * Configurations of NoEncryption
   */
  noEncryption?: NoEncryption;
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * Class for content key in Streaming Locator
 */
export interface StreamingLocatorContentKey {
  /**
   * ID of Content Key
   */
  id: string;
  /**
   * Encryption type of Content Key. Possible values include: 'CommonEncryptionCenc',
   * 'CommonEncryptionCbcs', 'EnvelopeEncryption'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: StreamingLocatorContentKeyType;
  /**
   * Label of Content Key as specified in the Streaming Policy
   */
  labelReferenceInStreamingPolicy?: string;
  /**
   * Value of Content Key
   */
  value?: string;
  /**
   * ContentKeyPolicy used by Content Key
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly policyName?: string;
  /**
   * Tracks which use this Content Key
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly tracks?: TrackSelection[];
}

/**
 * Class of paths for streaming
 */
export interface StreamingPath {
  /**
   * Streaming protocol. Possible values include: 'Hls', 'Dash', 'SmoothStreaming', 'Download'
   */
  streamingProtocol: StreamingPolicyStreamingProtocol;
  /**
   * Encryption scheme. Possible values include: 'NoEncryption', 'EnvelopeEncryption',
   * 'CommonEncryptionCenc', 'CommonEncryptionCbcs'
   */
  encryptionScheme: EncryptionScheme;
  /**
   * Streaming paths for each protocol and encryptionScheme pair
   */
  paths?: string[];
}

/**
 * Class of response for listContentKeys action
 */
export interface ListContentKeysResponse {
  /**
   * ContentKeys used by current Streaming Locator
   */
  contentKeys?: StreamingLocatorContentKey[];
}

/**
 * Class of response for listPaths action
 */
export interface ListPathsResponse {
  /**
   * Streaming Paths supported by current Streaming Locator
   */
  streamingPaths?: StreamingPath[];
  /**
   * Download Paths supported by current Streaming Locator
   */
  downloadPaths?: string[];
}

/**
 * A Streaming Locator resource
 */
export interface StreamingLocator extends ProxyResource {
  /**
   * Asset Name
   */
  assetName: string;
  /**
   * The creation time of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * The start time of the Streaming Locator.
   */
  startTime?: Date;
  /**
   * The end time of the Streaming Locator.
   */
  endTime?: Date;
  /**
   * The StreamingLocatorId of the Streaming Locator.
   */
  streamingLocatorId?: string;
  /**
   * Name of the Streaming Policy used by this Streaming Locator. Either specify the name of
   * Streaming Policy you created or use one of the predefined Streaming Policies. The predefined
   * Streaming Policies available are: 'Predefined_DownloadOnly', 'Predefined_ClearStreamingOnly',
   * 'Predefined_DownloadAndClearStreaming', 'Predefined_ClearKey',
   * 'Predefined_MultiDrmCencStreaming' and 'Predefined_MultiDrmStreaming'
   */
  streamingPolicyName: string;
  /**
   * Name of the default ContentKeyPolicy used by this Streaming Locator.
   */
  defaultContentKeyPolicyName?: string;
  /**
   * The ContentKeys used by this Streaming Locator.
   */
  contentKeys?: StreamingLocatorContentKey[];
  /**
   * Alternative Media ID of this Streaming Locator
   */
  alternativeMediaId?: string;
  /**
   * A list of asset or account filters which apply to this streaming locator
   */
  filters?: string[];
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * HTTP Live Streaming (HLS) packing setting for the live output.
 */
export interface Hls {
  /**
   * The number of fragments in an HTTP Live Streaming (HLS) TS segment in the output of the live
   * event. This value does not affect the packing ratio for HLS CMAF output.
   */
  fragmentsPerTsSegment?: number;
}

/**
 * The Live Output.
 */
export interface LiveOutput extends ProxyResource {
  /**
   * The description of the live output.
   */
  description?: string;
  /**
   * The asset that the live output will write to.
   */
  assetName: string;
  /**
   * ISO 8601 time between 1 minute to 25 hours to indicate the maximum content length that can be
   * archived in the asset for this live output. This also sets the maximum content length for the
   * rewind window. For example, use PT1H30M to indicate 1 hour and 30 minutes of archive window.
   */
  archiveWindowLength: string;
  /**
   * The manifest file name. If not provided, the service will generate one automatically.
   */
  manifestName?: string;
  /**
   * HTTP Live Streaming (HLS) packing setting for the live output.
   */
  hls?: Hls;
  /**
   * The initial timestamp that the live output will start at, any content before this value will
   * not be archived.
   */
  outputSnapTime?: number;
  /**
   * The creation time the live output.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * The time the live output was last modified.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly lastModified?: Date;
  /**
   * The provisioning state of the live output.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The resource state of the live output. Possible values include: 'Creating', 'Running',
   * 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: LiveOutputResourceState;
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * The live event endpoint.
 */
export interface LiveEventEndpoint {
  /**
   * The endpoint protocol.
   */
  protocol?: string;
  /**
   * The endpoint URL.
   */
  url?: string;
}

/**
 * The IP address range in the CIDR scheme.
 */
export interface IPRange {
  /**
   * The friendly name for the IP address range.
   */
  name?: string;
  /**
   * The IP address.
   */
  address?: string;
  /**
   * The subnet mask prefix length (see CIDR notation).
   */
  subnetPrefixLength?: number;
}

/**
 * The IP access control.
 */
export interface IPAccessControl {
  /**
   * The IP allow list.
   */
  allow?: IPRange[];
}

/**
 * The IP access control for live event input.
 */
export interface LiveEventInputAccessControl {
  /**
   * The IP access control properties.
   */
  ip?: IPAccessControl;
}

/**
 * The live event input.
 */
export interface LiveEventInput {
  /**
   * The input protocol for the live event. This is specified at creation time and cannot be
   * updated. Possible values include: 'FragmentedMP4', 'RTMP'
   */
  streamingProtocol: LiveEventInputProtocol;
  /**
   * Access control for live event input.
   */
  accessControl?: LiveEventInputAccessControl;
  /**
   * ISO 8601 time duration of the key frame interval duration of the input. This value sets the
   * EXT-X-TARGETDURATION property in the HLS output. For example, use PT2S to indicate 2 seconds.
   * Leave the value empty for encoding live events.
   */
  keyFrameIntervalDuration?: string;
  /**
   * A UUID in string form to uniquely identify the stream. This can be specified at creation time
   * but cannot be updated. If omitted, the service will generate a unique value.
   */
  accessToken?: string;
  /**
   * The input endpoints for the live event.
   */
  endpoints?: LiveEventEndpoint[];
}

/**
 * The IP access control for the live event preview endpoint.
 */
export interface LiveEventPreviewAccessControl {
  /**
   * The IP access control properties.
   */
  ip?: IPAccessControl;
}

/**
 * Live event preview settings.
 */
export interface LiveEventPreview {
  /**
   * The endpoints for preview. Do not share the preview URL with the live event audience.
   */
  endpoints?: LiveEventEndpoint[];
  /**
   * The access control for live event preview.
   */
  accessControl?: LiveEventPreviewAccessControl;
  /**
   * The identifier of the preview locator in Guid format. Specifying this at creation time allows
   * the caller to know the preview locator url before the event is created. If omitted, the
   * service will generate a random identifier. This value cannot be updated once the live event is
   * created.
   */
  previewLocator?: string;
  /**
   * The name of streaming policy used for the live event preview. This value is specified at
   * creation time and cannot be updated.
   */
  streamingPolicyName?: string;
  /**
   * An alternative media identifier associated with the streaming locator created for the preview.
   * This value is specified at creation time and cannot be updated. The identifier can be used in
   * the CustomLicenseAcquisitionUrlTemplate or the CustomKeyAcquisitionUrlTemplate of the
   * StreamingPolicy specified in the StreamingPolicyName field.
   */
  alternativeMediaId?: string;
}

/**
 * Specifies the live event type and optional encoding settings for encoding live events.
 */
export interface LiveEventEncoding {
  /**
   * Live event type. When encodingType is set to None, the service simply passes through the
   * incoming video and audio layer(s) to the output. When encodingType is set to Standard or
   * Premium1080p, a live encoder transcodes the incoming stream into multiple bitrates or layers.
   * See https://go.microsoft.com/fwlink/?linkid=2095101 for more information. This property cannot
   * be modified after the live event is created. Possible values include: 'None', 'Standard',
   * 'Premium1080p', 'PassthroughBasic', 'PassthroughStandard'
   */
  encodingType?: LiveEventEncodingType;
  /**
   * The optional encoding preset name, used when encodingType is not None. This value is specified
   * at creation time and cannot be updated. If the encodingType is set to Standard, then the
   * default preset name is ‘Default720p’. Else if the encodingType is set to Premium1080p, the
   * default preset is ‘Default1080p’.
   */
  presetName?: string;
  /**
   * Specifies how the input video will be resized to fit the desired output resolution(s). Default
   * is None. Possible values include: 'None', 'AutoSize', 'AutoFit'
   */
  stretchMode?: StretchMode;
  /**
   * Use an ISO 8601 time value between 0.5 to 20 seconds to specify the output fragment length for
   * the video and audio tracks of an encoding live event. For example, use PT2S to indicate 2
   * seconds. For the video track it also defines the key frame interval, or the length of a GoP
   * (group of pictures).   If this value is not set for an encoding live event, the fragment
   * duration defaults to 2 seconds. The value cannot be set for pass-through live events.
   */
  keyFrameInterval?: string;
}

/**
 * A track selection condition. This property is reserved for future use, any value set on this
 * property will be ignored.
 */
export interface LiveEventInputTrackSelection {
  /**
   * Property name to select. This property is reserved for future use, any value set on this
   * property will be ignored.
   */
  property?: string;
  /**
   * Comparing operation. This property is reserved for future use, any value set on this property
   * will be ignored.
   */
  operation?: string;
  /**
   * Property value to select. This property is reserved for future use, any value set on this
   * property will be ignored.
   */
  value?: string;
}

/**
 * Describes a transcription track in the output of a live event, generated using speech-to-text
 * transcription. This property is reserved for future use, any value set on this property will be
 * ignored.
 */
export interface LiveEventOutputTranscriptionTrack {
  /**
   * The output track name. This property is reserved for future use, any value set on this
   * property will be ignored.
   */
  trackName: string;
}

/**
 * Describes the transcription tracks in the output of a live event, generated using speech-to-text
 * transcription. This property is reserved for future use, any value set on this property will be
 * ignored.
 */
export interface LiveEventTranscription {
  /**
   * Specifies the language (locale) to be used for speech-to-text transcription – it should match
   * the spoken language in the audio track. The value should be in BCP-47 format (e.g: 'en-US').
   * See https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live
   * transcription feature and the list of supported languages.
   */
  language?: string;
  /**
   * Provides a mechanism to select the audio track in the input live feed, to which speech-to-text
   * transcription is applied. This property is reserved for future use, any value set on this
   * property will be ignored.
   */
  inputTrackSelection?: LiveEventInputTrackSelection[];
  /**
   * Describes a transcription track in the output of a live event, generated using speech-to-text
   * transcription. This property is reserved for future use, any value set on this property will
   * be ignored.
   */
  outputTranscriptionTrack?: LiveEventOutputTranscriptionTrack;
}

/**
 * The client access policy.
 */
export interface CrossSiteAccessPolicies {
  /**
   * The content of clientaccesspolicy.xml used by Silverlight.
   */
  clientAccessPolicy?: string;
  /**
   * The content of crossdomain.xml used by Silverlight.
   */
  crossDomainPolicy?: string;
}

/**
 * The LiveEvent action input parameter definition.
 */
export interface LiveEventActionInput {
  /**
   * The flag indicates whether live outputs are automatically deleted when live event is being
   * stopped. Deleting live outputs do not delete the underlying assets.
   */
  removeOutputsOnStop?: boolean;
}

/**
 * The live event.
 */
export interface LiveEvent extends TrackedResource {
  /**
   * A description for the live event.
   */
  description?: string;
  /**
   * Live event input settings. It defines how the live event receives input from a contribution
   * encoder.
   */
  input: LiveEventInput;
  /**
   * Live event preview settings. Preview allows live event producers to preview the live streaming
   * content without creating any live output.
   */
  preview?: LiveEventPreview;
  /**
   * Encoding settings for the live event. It configures whether a live encoder is used for the
   * live event and settings for the live encoder if it is used.
   */
  encoding?: LiveEventEncoding;
  /**
   * Live transcription settings for the live event. See
   * https://go.microsoft.com/fwlink/?linkid=2133742 for more information about the live
   * transcription feature.
   */
  transcriptions?: LiveEventTranscription[];
  /**
   * The provisioning state of the live event.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The resource state of the live event. See https://go.microsoft.com/fwlink/?linkid=2139012 for
   * more information. Possible values include: 'Stopped', 'Allocating', 'StandBy', 'Starting',
   * 'Running', 'Stopping', 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: LiveEventResourceState;
  /**
   * Live event cross site access policies.
   */
  crossSiteAccessPolicies?: CrossSiteAccessPolicies;
  /**
   * Specifies whether a static hostname would be assigned to the live event preview and ingest
   * endpoints. This value can only be updated if the live event is in Standby state
   */
  useStaticHostname?: boolean;
  /**
   * When useStaticHostname is set to true, the hostnamePrefix specifies the first part of the
   * hostname assigned to the live event preview and ingest endpoints. The final hostname would be
   * a combination of this prefix, the media service account name and a short code for the Azure
   * Media Services data center.
   */
  hostnamePrefix?: string;
  /**
   * The options to use for the LiveEvent. This value is specified at creation time and cannot be
   * updated. The valid values for the array entry values are 'Default' and 'LowLatency'.
   */
  streamOptions?: StreamOptionsFlag[];
  /**
   * The creation time for the live event
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * The last modified time of the live event.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly lastModified?: Date;
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * Akamai Signature Header authentication key.
 */
export interface AkamaiSignatureHeaderAuthenticationKey {
  /**
   * identifier of the key
   */
  identifier?: string;
  /**
   * authentication key
   */
  base64Key?: string;
  /**
   * The expiration time of the authentication key.
   */
  expiration?: Date;
}

/**
 * Akamai access control
 */
export interface AkamaiAccessControl {
  /**
   * authentication key list
   */
  akamaiSignatureHeaderAuthenticationKeyList?: AkamaiSignatureHeaderAuthenticationKey[];
}

/**
 * Streaming endpoint access control definition.
 */
export interface StreamingEndpointAccessControl {
  /**
   * The access control of Akamai
   */
  akamai?: AkamaiAccessControl;
  /**
   * The IP access control of the streaming endpoint.
   */
  ip?: IPAccessControl;
}

/**
 * scale units definition
 */
export interface StreamingEntityScaleUnit {
  /**
   * The scale unit number of the streaming endpoint.
   */
  scaleUnit?: number;
}

/**
 * The streaming endpoint.
 */
export interface StreamingEndpoint extends TrackedResource {
  /**
   * The streaming endpoint description.
   */
  description?: string;
  /**
   * The number of scale units. Use the Scale operation to adjust this value.
   */
  scaleUnits: number;
  /**
   * This feature is deprecated, do not set a value for this property.
   */
  availabilitySetName?: string;
  /**
   * The access control definition of the streaming endpoint.
   */
  accessControl?: StreamingEndpointAccessControl;
  /**
   * Max cache age
   */
  maxCacheAge?: number;
  /**
   * The custom host names of the streaming endpoint
   */
  customHostNames?: string[];
  /**
   * The streaming endpoint host name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly hostName?: string;
  /**
   * The CDN enabled flag.
   */
  cdnEnabled?: boolean;
  /**
   * The CDN provider name.
   */
  cdnProvider?: string;
  /**
   * The CDN profile name.
   */
  cdnProfile?: string;
  /**
   * The provisioning state of the streaming endpoint.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The resource state of the streaming endpoint. Possible values include: 'Stopped', 'Starting',
   * 'Running', 'Stopping', 'Deleting', 'Scaling'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly resourceState?: StreamingEndpointResourceState;
  /**
   * The streaming endpoint access policies.
   */
  crossSiteAccessPolicies?: CrossSiteAccessPolicies;
  /**
   * The free trial expiration time.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly freeTrialEndTime?: Date;
  /**
   * The exact time the streaming endpoint was created.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly created?: Date;
  /**
   * The exact time the streaming endpoint was last modified.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly lastModified?: Date;
  /**
   * The system metadata relating to this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * Optional Parameters.
 */
export interface AssetsListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
  /**
   * Specifies the key by which the result collection should be ordered.
   */
  orderby?: string;
}

/**
 * Optional Parameters.
 */
export interface AssetsListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
  /**
   * Specifies the key by which the result collection should be ordered.
   */
  orderby?: string;
}

/**
 * Optional Parameters.
 */
export interface ContentKeyPoliciesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
  /**
   * Specifies the key by which the result collection should be ordered.
   */
  orderby?: string;
}

/**
 * Optional Parameters.
 */
export interface ContentKeyPoliciesListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
  /**
   * Specifies the key by which the result collection should be ordered.
   */
  orderby?: string;
}

/**
 * Optional Parameters.
 */
export interface StreamingPoliciesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
  /**
   * Specifies the key by which the result collection should be ordered.
   */
  orderby?: string;
}

/**
 * Optional Parameters.
 */
export interface StreamingPoliciesListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
  /**
   * Specifies the key by which the result collection should be ordered.
   */
  orderby?: string;
}

/**
 * Optional Parameters.
 */
export interface StreamingLocatorsListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
  /**
   * Specifies the key by which the result collection should be ordered.
   */
  orderby?: string;
}

/**
 * Optional Parameters.
 */
export interface StreamingLocatorsListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
  /**
   * Specifies the key by which the result collection should be ordered.
   */
  orderby?: string;
}

/**
 * Optional Parameters.
 */
export interface LiveEventsCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The flag indicates if the resource should be automatically started on creation.
   */
  autoStart?: boolean;
}

/**
 * Optional Parameters.
 */
export interface LiveEventsBeginCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The flag indicates if the resource should be automatically started on creation.
   */
  autoStart?: boolean;
}

/**
 * Optional Parameters.
 */
export interface StreamingEndpointsCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The flag indicates if the resource should be automatically started on creation.
   */
  autoStart?: boolean;
}

/**
 * Optional Parameters.
 */
export interface StreamingEndpointsBeginCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The flag indicates if the resource should be automatically started on creation.
   */
  autoStart?: boolean;
}

/**
 * An interface representing AzureMediaServicesOptions.
 */
export interface AzureMediaServicesOptions extends AzureServiceClientOptions {
  baseUri?: string;
}

/**
 * @interface
 * A collection of MediaService items.
 * @extends Array<MediaService>
 */
export interface MediaServiceCollection extends Array<MediaService> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * A collection of AccountFilter items.
 * @extends Array<AccountFilter>
 */
export interface AccountFilterCollection extends Array<AccountFilter> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * A collection of Asset items.
 * @extends Array<Asset>
 */
export interface AssetCollection extends Array<Asset> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * A collection of AssetFilter items.
 * @extends Array<AssetFilter>
 */
export interface AssetFilterCollection extends Array<AssetFilter> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * A collection of ContentKeyPolicy items.
 * @extends Array<ContentKeyPolicy>
 */
export interface ContentKeyPolicyCollection extends Array<ContentKeyPolicy> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * A collection of StreamingPolicy items.
 * @extends Array<StreamingPolicy>
 */
export interface StreamingPolicyCollection extends Array<StreamingPolicy> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * A collection of StreamingLocator items.
 * @extends Array<StreamingLocator>
 */
export interface StreamingLocatorCollection extends Array<StreamingLocator> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * The LiveEvent list result.
 * @summary LiveEventListResult
 * @extends Array<LiveEvent>
 */
export interface LiveEventListResult extends Array<LiveEvent> {
  /**
   * The number of result.
   */
  odatacount?: number;
  /**
   * The link to the next set of results. Not empty if value contains incomplete list of live
   * outputs.
   */
  odatanextLink?: string;
}

/**
 * @interface
 * The LiveOutput list result.
 * @summary LiveOutputListResult
 * @extends Array<LiveOutput>
 */
export interface LiveOutputListResult extends Array<LiveOutput> {
  /**
   * The number of result.
   */
  odatacount?: number;
  /**
   * The link to the next set of results. Not empty if value contains incomplete list of live
   * outputs.
   */
  odatanextLink?: string;
}

/**
 * @interface
 * The streaming endpoint list result.
 * @summary StreamingEndpointListResult
 * @extends Array<StreamingEndpoint>
 */
export interface StreamingEndpointListResult extends Array<StreamingEndpoint> {
  /**
   * The number of result.
   */
  odatacount?: number;
  /**
   * The link to the next set of results. Not empty if value contains incomplete list of streaming
   * endpoints.
   */
  odatanextLink?: string;
}

/**
 * Defines values for MetricUnit.
 * Possible values include: 'Bytes', 'Count', 'Milliseconds'
 * @readonly
 * @enum {string}
 */
export type MetricUnit = 'Bytes' | 'Count' | 'Milliseconds';

/**
 * Defines values for MetricAggregationType.
 * Possible values include: 'Average', 'Count', 'Total'
 * @readonly
 * @enum {string}
 */
export type MetricAggregationType = 'Average' | 'Count' | 'Total';

/**
 * Defines values for ActionType.
 * Possible values include: 'Internal'
 * @readonly
 * @enum {string}
 */
export type ActionType = 'Internal';

/**
 * Defines values for StorageAccountType.
 * Possible values include: 'Primary', 'Secondary'
 * @readonly
 * @enum {string}
 */
export type StorageAccountType = 'Primary' | 'Secondary';

/**
 * Defines values for StorageAuthentication.
 * Possible values include: 'System', 'ManagedIdentity'
 * @readonly
 * @enum {string}
 */
export type StorageAuthentication = 'System' | 'ManagedIdentity';

/**
 * Defines values for AccountEncryptionKeyType.
 * Possible values include: 'SystemKey', 'CustomerKey'
 * @readonly
 * @enum {string}
 */
export type AccountEncryptionKeyType = 'SystemKey' | 'CustomerKey';

/**
 * Defines values for DefaultAction.
 * Possible values include: 'Allow', 'Deny'
 * @readonly
 * @enum {string}
 */
export type DefaultAction = 'Allow' | 'Deny';

/**
 * Defines values for PublicNetworkAccess.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type PublicNetworkAccess = 'Enabled' | 'Disabled';

/**
 * Defines values for CreatedByType.
 * Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
 * @readonly
 * @enum {string}
 */
export type CreatedByType = 'User' | 'Application' | 'ManagedIdentity' | 'Key';

/**
 * Defines values for PrivateEndpointConnectionProvisioningState.
 * Possible values include: 'Succeeded', 'Creating', 'Deleting', 'Failed'
 * @readonly
 * @enum {string}
 */
export type PrivateEndpointConnectionProvisioningState = 'Succeeded' | 'Creating' | 'Deleting' | 'Failed';

/**
 * Defines values for PrivateEndpointServiceConnectionStatus.
 * Possible values include: 'Pending', 'Approved', 'Rejected'
 * @readonly
 * @enum {string}
 */
export type PrivateEndpointServiceConnectionStatus = 'Pending' | 'Approved' | 'Rejected';

/**
 * Defines values for FilterTrackPropertyType.
 * Possible values include: 'Unknown', 'Type', 'Name', 'Language', 'FourCC', 'Bitrate'
 * @readonly
 * @enum {string}
 */
export type FilterTrackPropertyType = 'Unknown' | 'Type' | 'Name' | 'Language' | 'FourCC' | 'Bitrate';

/**
 * Defines values for FilterTrackPropertyCompareOperation.
 * Possible values include: 'Equal', 'NotEqual'
 * @readonly
 * @enum {string}
 */
export type FilterTrackPropertyCompareOperation = 'Equal' | 'NotEqual';

/**
 * Defines values for AssetStorageEncryptionFormat.
 * Possible values include: 'None', 'MediaStorageClientEncryption'
 * @readonly
 * @enum {string}
 */
export type AssetStorageEncryptionFormat = 'None' | 'MediaStorageClientEncryption';

/**
 * Defines values for AssetContainerPermission.
 * Possible values include: 'Read', 'ReadWrite', 'ReadWriteDelete'
 * @readonly
 * @enum {string}
 */
export type AssetContainerPermission = 'Read' | 'ReadWrite' | 'ReadWriteDelete';

/**
 * Defines values for ContentKeyPolicyPlayReadyUnknownOutputPassingOption.
 * Possible values include: 'Unknown', 'NotAllowed', 'Allowed', 'AllowedWithVideoConstriction'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyPlayReadyUnknownOutputPassingOption = 'Unknown' | 'NotAllowed' | 'Allowed' | 'AllowedWithVideoConstriction';

/**
 * Defines values for ContentKeyPolicyPlayReadyLicenseType.
 * Possible values include: 'Unknown', 'NonPersistent', 'Persistent'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyPlayReadyLicenseType = 'Unknown' | 'NonPersistent' | 'Persistent';

/**
 * Defines values for ContentKeyPolicyPlayReadyContentType.
 * Possible values include: 'Unknown', 'Unspecified', 'UltraVioletDownload', 'UltraVioletStreaming'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyPlayReadyContentType = 'Unknown' | 'Unspecified' | 'UltraVioletDownload' | 'UltraVioletStreaming';

/**
 * Defines values for ContentKeyPolicyRestrictionTokenType.
 * Possible values include: 'Unknown', 'Swt', 'Jwt'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyRestrictionTokenType = 'Unknown' | 'Swt' | 'Jwt';

/**
 * Defines values for ContentKeyPolicyFairPlayRentalAndLeaseKeyType.
 * Possible values include: 'Unknown', 'Undefined', 'DualExpiry', 'PersistentUnlimited',
 * 'PersistentLimited'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyFairPlayRentalAndLeaseKeyType = 'Unknown' | 'Undefined' | 'DualExpiry' | 'PersistentUnlimited' | 'PersistentLimited';

/**
 * Defines values for TrackPropertyType.
 * Possible values include: 'Unknown', 'FourCC'
 * @readonly
 * @enum {string}
 */
export type TrackPropertyType = 'Unknown' | 'FourCC';

/**
 * Defines values for TrackPropertyCompareOperation.
 * Possible values include: 'Unknown', 'Equal'
 * @readonly
 * @enum {string}
 */
export type TrackPropertyCompareOperation = 'Unknown' | 'Equal';

/**
 * Defines values for StreamingLocatorContentKeyType.
 * Possible values include: 'CommonEncryptionCenc', 'CommonEncryptionCbcs', 'EnvelopeEncryption'
 * @readonly
 * @enum {string}
 */
export type StreamingLocatorContentKeyType = 'CommonEncryptionCenc' | 'CommonEncryptionCbcs' | 'EnvelopeEncryption';

/**
 * Defines values for StreamingPolicyStreamingProtocol.
 * Possible values include: 'Hls', 'Dash', 'SmoothStreaming', 'Download'
 * @readonly
 * @enum {string}
 */
export type StreamingPolicyStreamingProtocol = 'Hls' | 'Dash' | 'SmoothStreaming' | 'Download';

/**
 * Defines values for EncryptionScheme.
 * Possible values include: 'NoEncryption', 'EnvelopeEncryption', 'CommonEncryptionCenc',
 * 'CommonEncryptionCbcs'
 * @readonly
 * @enum {string}
 */
export type EncryptionScheme = 'NoEncryption' | 'EnvelopeEncryption' | 'CommonEncryptionCenc' | 'CommonEncryptionCbcs';

/**
 * Defines values for LiveOutputResourceState.
 * Possible values include: 'Creating', 'Running', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type LiveOutputResourceState = 'Creating' | 'Running' | 'Deleting';

/**
 * Defines values for LiveEventInputProtocol.
 * Possible values include: 'FragmentedMP4', 'RTMP'
 * @readonly
 * @enum {string}
 */
export type LiveEventInputProtocol = 'FragmentedMP4' | 'RTMP';

/**
 * Defines values for LiveEventEncodingType.
 * Possible values include: 'None', 'Standard', 'Premium1080p', 'PassthroughBasic',
 * 'PassthroughStandard'
 * @readonly
 * @enum {string}
 */
export type LiveEventEncodingType = 'None' | 'Standard' | 'Premium1080p' | 'PassthroughBasic' | 'PassthroughStandard';

/**
 * Defines values for StretchMode.
 * Possible values include: 'None', 'AutoSize', 'AutoFit'
 * @readonly
 * @enum {string}
 */
export type StretchMode = 'None' | 'AutoSize' | 'AutoFit';

/**
 * Defines values for LiveEventResourceState.
 * Possible values include: 'Stopped', 'Allocating', 'StandBy', 'Starting', 'Running', 'Stopping',
 * 'Deleting'
 * @readonly
 * @enum {string}
 */
export type LiveEventResourceState = 'Stopped' | 'Allocating' | 'StandBy' | 'Starting' | 'Running' | 'Stopping' | 'Deleting';

/**
 * Defines values for StreamOptionsFlag.
 * Possible values include: 'Default', 'LowLatency'
 * @readonly
 * @enum {string}
 */
export type StreamOptionsFlag = 'Default' | 'LowLatency';

/**
 * Defines values for StreamingEndpointResourceState.
 * Possible values include: 'Stopped', 'Starting', 'Running', 'Stopping', 'Deleting', 'Scaling'
 * @readonly
 * @enum {string}
 */
export type StreamingEndpointResourceState = 'Stopped' | 'Starting' | 'Running' | 'Stopping' | 'Deleting' | 'Scaling';

/**
 * Contains response data for the list operation.
 */
export type OperationsListResponse = OperationCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MediaservicesListResponse = MediaServiceCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaServiceCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MediaservicesGetResponse = MediaService & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaService;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type MediaservicesCreateOrUpdateResponse = MediaService & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaService;
    };
};

/**
 * Contains response data for the update operation.
 */
export type MediaservicesUpdateResponse = MediaService & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaService;
    };
};

/**
 * Contains response data for the listEdgePolicies operation.
 */
export type MediaservicesListEdgePoliciesResponse = EdgePolicies & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EdgePolicies;
    };
};

/**
 * Contains response data for the listBySubscription operation.
 */
export type MediaservicesListBySubscriptionResponse = MediaServiceCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaServiceCollection;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type MediaservicesListNextResponse = MediaServiceCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaServiceCollection;
    };
};

/**
 * Contains response data for the listBySubscriptionNext operation.
 */
export type MediaservicesListBySubscriptionNextResponse = MediaServiceCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaServiceCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PrivateLinkResourcesListResponse = PrivateLinkResourceListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateLinkResourceListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PrivateLinkResourcesGetResponse = PrivateLinkResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateLinkResource;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateEndpointConnectionListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateEndpointConnection;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type PrivateEndpointConnectionsCreateOrUpdateResponse = PrivateEndpointConnection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateEndpointConnection;
    };
};

/**
 * Contains response data for the checkNameAvailability operation.
 */
export type LocationsCheckNameAvailabilityResponse = EntityNameAvailabilityCheckOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EntityNameAvailabilityCheckOutput;
    };
};

/**
 * Contains response data for the list operation.
 */
export type AccountFiltersListResponse = AccountFilterCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilterCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AccountFiltersGetResponse = AccountFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilter;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type AccountFiltersCreateOrUpdateResponse = AccountFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilter;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AccountFiltersUpdateResponse = AccountFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilter;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type AccountFiltersListNextResponse = AccountFilterCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilterCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type AssetsListResponse = AssetCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AssetsGetResponse = Asset & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Asset;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type AssetsCreateOrUpdateResponse = Asset & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Asset;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AssetsUpdateResponse = Asset & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Asset;
    };
};

/**
 * Contains response data for the listContainerSas operation.
 */
export type AssetsListContainerSasResponse = AssetContainerSas & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetContainerSas;
    };
};

/**
 * Contains response data for the getEncryptionKey operation.
 */
export type AssetsGetEncryptionKeyResponse = StorageEncryptedAssetDecryptionData & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StorageEncryptedAssetDecryptionData;
    };
};

/**
 * Contains response data for the listStreamingLocators operation.
 */
export type AssetsListStreamingLocatorsResponse = ListStreamingLocatorsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ListStreamingLocatorsResponse;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type AssetsListNextResponse = AssetCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type AssetFiltersListResponse = AssetFilterCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilterCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AssetFiltersGetResponse = AssetFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilter;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type AssetFiltersCreateOrUpdateResponse = AssetFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilter;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AssetFiltersUpdateResponse = AssetFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilter;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type AssetFiltersListNextResponse = AssetFilterCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilterCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ContentKeyPoliciesListResponse = ContentKeyPolicyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicyCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ContentKeyPoliciesGetResponse = ContentKeyPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicy;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ContentKeyPoliciesCreateOrUpdateResponse = ContentKeyPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicy;
    };
};

/**
 * Contains response data for the update operation.
 */
export type ContentKeyPoliciesUpdateResponse = ContentKeyPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicy;
    };
};

/**
 * Contains response data for the getPolicyPropertiesWithSecrets operation.
 */
export type ContentKeyPoliciesGetPolicyPropertiesWithSecretsResponse = ContentKeyPolicyProperties & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicyProperties;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type ContentKeyPoliciesListNextResponse = ContentKeyPolicyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicyCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type StreamingPoliciesListResponse = StreamingPolicyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingPolicyCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type StreamingPoliciesGetResponse = StreamingPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingPolicy;
    };
};

/**
 * Contains response data for the create operation.
 */
export type StreamingPoliciesCreateResponse = StreamingPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingPolicy;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type StreamingPoliciesListNextResponse = StreamingPolicyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingPolicyCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type StreamingLocatorsListResponse = StreamingLocatorCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingLocatorCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type StreamingLocatorsGetResponse = StreamingLocator & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingLocator;
    };
};

/**
 * Contains response data for the create operation.
 */
export type StreamingLocatorsCreateResponse = StreamingLocator & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingLocator;
    };
};

/**
 * Contains response data for the listContentKeys operation.
 */
export type StreamingLocatorsListContentKeysResponse = ListContentKeysResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ListContentKeysResponse;
    };
};

/**
 * Contains response data for the listPaths operation.
 */
export type StreamingLocatorsListPathsResponse = ListPathsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ListPathsResponse;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type StreamingLocatorsListNextResponse = StreamingLocatorCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingLocatorCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type LiveEventsListResponse = LiveEventListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEventListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type LiveEventsGetResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the create operation.
 */
export type LiveEventsCreateResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the update operation.
 */
export type LiveEventsUpdateResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type LiveEventsBeginCreateResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type LiveEventsBeginUpdateResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type LiveEventsListNextResponse = LiveEventListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEventListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type LiveOutputsListResponse = LiveOutputListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutputListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type LiveOutputsGetResponse = LiveOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutput;
    };
};

/**
 * Contains response data for the create operation.
 */
export type LiveOutputsCreateResponse = LiveOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutput;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type LiveOutputsBeginCreateResponse = LiveOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutput;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type LiveOutputsListNextResponse = LiveOutputListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutputListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type StreamingEndpointsListResponse = StreamingEndpointListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpointListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type StreamingEndpointsGetResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the create operation.
 */
export type StreamingEndpointsCreateResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the update operation.
 */
export type StreamingEndpointsUpdateResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type StreamingEndpointsBeginCreateResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type StreamingEndpointsBeginUpdateResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type StreamingEndpointsListNextResponse = StreamingEndpointListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpointListResult;
    };
};
