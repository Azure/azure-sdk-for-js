## API Report File for "@azure/arm-mediaservices"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export interface AacAudio extends Audio_2 {
    odataType: "#Microsoft.Media.AacAudio";
    profile?: AacAudioProfile;
}

// @public
export type AacAudioProfile = string;

// @public
export interface AbsoluteClipTime extends ClipTime {
    odataType: "#Microsoft.Media.AbsoluteClipTime";
    time: string;
}

// @public (undocumented)
export interface AccessControl {
    defaultAction?: DefaultAction;
    ipAllowList?: string[];
}

// @public (undocumented)
export interface AccountEncryption {
    identity?: ResourceIdentity;
    keyVaultProperties?: KeyVaultProperties;
    readonly status?: string;
    type: AccountEncryptionKeyType;
}

// @public
export type AccountEncryptionKeyType = string;

// @public
export interface AccountFilter extends ProxyResource {
    firstQuality?: FirstQuality;
    presentationTimeRange?: PresentationTimeRange;
    readonly systemData?: SystemData;
    tracks?: FilterTrackSelection[];
}

// @public
export interface AccountFilterCollection {
    odataNextLink?: string;
    value?: AccountFilter[];
}

// @public
export interface AccountFilters {
    createOrUpdate(resourceGroupName: string, accountName: string, filterName: string, parameters: AccountFilter, options?: AccountFiltersCreateOrUpdateOptionalParams): Promise<AccountFiltersCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, filterName: string, options?: AccountFiltersDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, filterName: string, options?: AccountFiltersGetOptionalParams): Promise<AccountFiltersGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: AccountFiltersListOptionalParams): PagedAsyncIterableIterator<AccountFilter>;
    update(resourceGroupName: string, accountName: string, filterName: string, parameters: AccountFilter, options?: AccountFiltersUpdateOptionalParams): Promise<AccountFiltersUpdateResponse>;
}

// @public
export interface AccountFiltersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountFiltersCreateOrUpdateResponse = AccountFilter;

// @public
export interface AccountFiltersDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AccountFiltersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountFiltersGetResponse = AccountFilter;

// @public
export interface AccountFiltersListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountFiltersListNextResponse = AccountFilterCollection;

// @public
export interface AccountFiltersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountFiltersListResponse = AccountFilterCollection;

// @public
export interface AccountFiltersUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccountFiltersUpdateResponse = AccountFilter;

// @public
export type ActionType = string;

// @public
export interface AkamaiAccessControl {
    akamaiSignatureHeaderAuthenticationKeyList?: AkamaiSignatureHeaderAuthenticationKey[];
}

// @public
export interface AkamaiSignatureHeaderAuthenticationKey {
    base64Key?: string;
    expiration?: Date;
    identifier?: string;
}

// @public
export type AnalysisResolution = string;

// @public
export interface ArmStreamingEndpointCapacity {
    default?: number;
    maximum?: number;
    minimum?: number;
    readonly scaleType?: string;
}

// @public
export interface ArmStreamingEndpointCurrentSku {
    capacity?: number;
    readonly name?: string;
}

// @public
export interface ArmStreamingEndpointSku {
    readonly name?: string;
}

// @public (undocumented)
export interface ArmStreamingEndpointSkuInfo {
    capacity?: ArmStreamingEndpointCapacity;
    // (undocumented)
    resourceType?: string;
    sku?: ArmStreamingEndpointSku;
}

// @public
export interface Asset extends ProxyResource {
    alternateId?: string;
    readonly assetId?: string;
    container?: string;
    readonly created?: Date;
    description?: string;
    readonly lastModified?: Date;
    storageAccountName?: string;
    readonly storageEncryptionFormat?: AssetStorageEncryptionFormat;
    readonly systemData?: SystemData;
}

// @public
export interface AssetCollection {
    odataNextLink?: string;
    value?: Asset[];
}

// @public
export type AssetContainerPermission = string;

// @public
export interface AssetContainerSas {
    assetContainerSasUrls?: string[];
}

// @public
export interface AssetFileEncryptionMetadata {
    assetFileId: string;
    assetFileName?: string;
    initializationVector?: string;
}

// @public
export interface AssetFilter extends ProxyResource {
    firstQuality?: FirstQuality;
    presentationTimeRange?: PresentationTimeRange;
    readonly systemData?: SystemData;
    tracks?: FilterTrackSelection[];
}

// @public
export interface AssetFilterCollection {
    odataNextLink?: string;
    value?: AssetFilter[];
}

// @public
export interface AssetFilters {
    createOrUpdate(resourceGroupName: string, accountName: string, assetName: string, filterName: string, parameters: AssetFilter, options?: AssetFiltersCreateOrUpdateOptionalParams): Promise<AssetFiltersCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, assetName: string, filterName: string, options?: AssetFiltersDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, assetName: string, filterName: string, options?: AssetFiltersGetOptionalParams): Promise<AssetFiltersGetResponse>;
    list(resourceGroupName: string, accountName: string, assetName: string, options?: AssetFiltersListOptionalParams): PagedAsyncIterableIterator<AssetFilter>;
    update(resourceGroupName: string, accountName: string, assetName: string, filterName: string, parameters: AssetFilter, options?: AssetFiltersUpdateOptionalParams): Promise<AssetFiltersUpdateResponse>;
}

// @public
export interface AssetFiltersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetFiltersCreateOrUpdateResponse = AssetFilter;

// @public
export interface AssetFiltersDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AssetFiltersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetFiltersGetResponse = AssetFilter;

// @public
export interface AssetFiltersListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetFiltersListNextResponse = AssetFilterCollection;

// @public
export interface AssetFiltersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetFiltersListResponse = AssetFilterCollection;

// @public
export interface AssetFiltersUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetFiltersUpdateResponse = AssetFilter;

// @public
export interface Assets {
    createOrUpdate(resourceGroupName: string, accountName: string, assetName: string, parameters: Asset, options?: AssetsCreateOrUpdateOptionalParams): Promise<AssetsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, assetName: string, options?: AssetsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, assetName: string, options?: AssetsGetOptionalParams): Promise<AssetsGetResponse>;
    getEncryptionKey(resourceGroupName: string, accountName: string, assetName: string, options?: AssetsGetEncryptionKeyOptionalParams): Promise<AssetsGetEncryptionKeyResponse>;
    list(resourceGroupName: string, accountName: string, options?: AssetsListOptionalParams): PagedAsyncIterableIterator<Asset>;
    listContainerSas(resourceGroupName: string, accountName: string, assetName: string, parameters: ListContainerSasInput, options?: AssetsListContainerSasOptionalParams): Promise<AssetsListContainerSasResponse>;
    listStreamingLocators(resourceGroupName: string, accountName: string, assetName: string, options?: AssetsListStreamingLocatorsOptionalParams): Promise<AssetsListStreamingLocatorsResponse>;
    update(resourceGroupName: string, accountName: string, assetName: string, parameters: Asset, options?: AssetsUpdateOptionalParams): Promise<AssetsUpdateResponse>;
}

// @public
export interface AssetsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetsCreateOrUpdateResponse = Asset;

// @public
export interface AssetsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AssetsGetEncryptionKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetsGetEncryptionKeyResponse = StorageEncryptedAssetDecryptionData;

// @public
export interface AssetsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetsGetResponse = Asset;

// @public
export interface AssetsListContainerSasOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetsListContainerSasResponse = AssetContainerSas;

// @public
export interface AssetsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetsListNextResponse = AssetCollection;

// @public
export interface AssetsListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    orderby?: string;
    top?: number;
}

// @public
export type AssetsListResponse = AssetCollection;

// @public
export interface AssetsListStreamingLocatorsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetsListStreamingLocatorsResponse = ListStreamingLocatorsResponse;

// @public
export type AssetStorageEncryptionFormat = string;

// @public
export interface AssetStreamingLocator {
    readonly assetName?: string;
    readonly created?: Date;
    readonly defaultContentKeyPolicyName?: string;
    readonly endTime?: Date;
    readonly name?: string;
    readonly startTime?: Date;
    readonly streamingLocatorId?: string;
    readonly streamingPolicyName?: string;
}

// @public
export interface AssetsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AssetsUpdateResponse = Asset;

// @public
export interface AssetTrack extends ProxyResource {
    readonly provisioningState?: ProvisioningState;
    track?: TrackBaseUnion;
}

// @public
export interface AssetTrackCollection {
    value?: AssetTrack[];
}

// @public
export interface AssetTrackOperationStatus {
    endTime?: Date;
    error?: ErrorDetail;
    id?: string;
    name: string;
    startTime?: Date;
    status: string;
}

// @public
export interface AsyncOperationResult {
    error?: ErrorDetail;
    name?: string;
    status?: AsyncOperationStatus;
}

// @public
export type AsyncOperationStatus = string;

// @public
export type AttributeFilter = string;

// @public
interface Audio_2 extends Codec {
    bitrate?: number;
    channels?: number;
    odataType: "#Microsoft.Media.Audio" | "#Microsoft.Media.AacAudio" | "#Microsoft.Media.DDAudio";
    samplingRate?: number;
}
export { Audio_2 as Audio }

// @public
export type AudioAnalysisMode = string;

// @public
export interface AudioAnalyzerPreset extends Preset {
    audioLanguage?: string;
    experimentalOptions?: {
        [propertyName: string]: string;
    };
    mode?: AudioAnalysisMode;
    odataType: "#Microsoft.Media.AudioAnalyzerPreset" | "#Microsoft.Media.VideoAnalyzerPreset";
}

// @public (undocumented)
export type AudioAnalyzerPresetUnion = AudioAnalyzerPreset | VideoAnalyzerPreset;

// @public
export interface AudioOverlay extends Overlay {
    odataType: "#Microsoft.Media.AudioOverlay";
}

// @public
export interface AudioTrack extends TrackBase {
    readonly bitRate?: number;
    dashSettings?: DashSettings;
    displayName?: string;
    fileName?: string;
    hlsSettings?: HlsSettings;
    languageCode?: string;
    mpeg4TrackId?: number;
    odataType: "#Microsoft.Media.AudioTrack";
}

// @public
export interface AudioTrackDescriptor extends TrackDescriptor {
    channelMapping?: ChannelMapping;
    odataType: "#Microsoft.Media.AudioTrackDescriptor" | "#Microsoft.Media.SelectAudioTrackByAttribute" | "#Microsoft.Media.SelectAudioTrackById";
}

// @public (undocumented)
export type AudioTrackDescriptorUnion = AudioTrackDescriptor | SelectAudioTrackByAttribute | SelectAudioTrackById;

// @public (undocumented)
export type AudioUnion = Audio_2 | AacAudio | DDAudio;

// @public (undocumented)
export class AzureMediaServices extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: AzureMediaServicesOptionalParams);
    // (undocumented)
    accountFilters: AccountFilters;
    // (undocumented)
    assetFilters: AssetFilters;
    // (undocumented)
    assets: Assets;
    // (undocumented)
    contentKeyPolicies: ContentKeyPolicies;
    // (undocumented)
    jobs: Jobs;
    // (undocumented)
    liveEvents: LiveEvents;
    // (undocumented)
    liveOutputs: LiveOutputs;
    // (undocumented)
    locations: Locations;
    // (undocumented)
    mediaservices: Mediaservices;
    // (undocumented)
    mediaServicesOperationResults: MediaServicesOperationResults;
    // (undocumented)
    mediaServicesOperationStatuses: MediaServicesOperationStatuses;
    // (undocumented)
    operationResults: OperationResults;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    operationStatuses: OperationStatuses;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    streamingEndpoints: StreamingEndpoints;
    // (undocumented)
    streamingLocators: StreamingLocators;
    // (undocumented)
    streamingPolicies: StreamingPolicies;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    tracks: Tracks;
    // (undocumented)
    transforms: Transforms;
}

// @public
export interface AzureMediaServicesOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    endpoint?: string;
}

// @public
export type BlurType = string;

// @public
export interface BuiltInStandardEncoderPreset extends Preset {
    configurations?: PresetConfigurations;
    odataType: "#Microsoft.Media.BuiltInStandardEncoderPreset";
    presetName: EncoderNamedPreset;
}

// @public
export interface CbcsDrmConfiguration {
    fairPlay?: StreamingPolicyFairPlayConfiguration;
    playReady?: StreamingPolicyPlayReadyConfiguration;
    widevine?: StreamingPolicyWidevineConfiguration;
}

// @public
export interface CencDrmConfiguration {
    playReady?: StreamingPolicyPlayReadyConfiguration;
    widevine?: StreamingPolicyWidevineConfiguration;
}

// @public
export type ChannelMapping = string;

// @public
export interface CheckNameAvailabilityInput {
    name?: string;
    type?: string;
}

// @public
export interface ClearKeyEncryptionConfiguration {
    customKeysAcquisitionUrlTemplate?: string;
}

// @public
export interface ClipTime {
    odataType: "#Microsoft.Media.AbsoluteClipTime" | "#Microsoft.Media.UtcClipTime";
}

// @public (undocumented)
export type ClipTimeUnion = ClipTime | AbsoluteClipTime | UtcClipTime;

// @public
export interface Codec {
    label?: string;
    odataType: "#Microsoft.Media.Audio" | "#Microsoft.Media.AacAudio" | "#Microsoft.Media.DDAudio" | "#Microsoft.Media.Video" | "#Microsoft.Media.H265Video" | "#Microsoft.Media.CopyVideo" | "#Microsoft.Media.Image" | "#Microsoft.Media.CopyAudio" | "#Microsoft.Media.H264Video" | "#Microsoft.Media.JpgImage" | "#Microsoft.Media.PngImage";
}

// @public (undocumented)
export type CodecUnion = Codec | AudioUnion | VideoUnion | CopyVideo | CopyAudio;

// @public
export interface CommonEncryptionCbcs {
    clearKeyEncryptionConfiguration?: ClearKeyEncryptionConfiguration;
    clearTracks?: TrackSelection[];
    contentKeys?: StreamingPolicyContentKeys;
    drm?: CbcsDrmConfiguration;
    enabledProtocols?: EnabledProtocols;
}

// @public
export interface CommonEncryptionCenc {
    clearKeyEncryptionConfiguration?: ClearKeyEncryptionConfiguration;
    clearTracks?: TrackSelection[];
    contentKeys?: StreamingPolicyContentKeys;
    drm?: CencDrmConfiguration;
    enabledProtocols?: EnabledProtocols;
}

// @public
export type Complexity = string;

// @public
export interface ContentKeyPolicies {
    createOrUpdate(resourceGroupName: string, accountName: string, contentKeyPolicyName: string, parameters: ContentKeyPolicy, options?: ContentKeyPoliciesCreateOrUpdateOptionalParams): Promise<ContentKeyPoliciesCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, contentKeyPolicyName: string, options?: ContentKeyPoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, contentKeyPolicyName: string, options?: ContentKeyPoliciesGetOptionalParams): Promise<ContentKeyPoliciesGetResponse>;
    getPolicyPropertiesWithSecrets(resourceGroupName: string, accountName: string, contentKeyPolicyName: string, options?: ContentKeyPoliciesGetPolicyPropertiesWithSecretsOptionalParams): Promise<ContentKeyPoliciesGetPolicyPropertiesWithSecretsResponse>;
    list(resourceGroupName: string, accountName: string, options?: ContentKeyPoliciesListOptionalParams): PagedAsyncIterableIterator<ContentKeyPolicy>;
    update(resourceGroupName: string, accountName: string, contentKeyPolicyName: string, parameters: ContentKeyPolicy, options?: ContentKeyPoliciesUpdateOptionalParams): Promise<ContentKeyPoliciesUpdateResponse>;
}

// @public
export interface ContentKeyPoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ContentKeyPoliciesCreateOrUpdateResponse = ContentKeyPolicy;

// @public
export interface ContentKeyPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ContentKeyPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ContentKeyPoliciesGetPolicyPropertiesWithSecretsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ContentKeyPoliciesGetPolicyPropertiesWithSecretsResponse = ContentKeyPolicyProperties;

// @public
export type ContentKeyPoliciesGetResponse = ContentKeyPolicy;

// @public
export interface ContentKeyPoliciesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ContentKeyPoliciesListNextResponse = ContentKeyPolicyCollection;

// @public
export interface ContentKeyPoliciesListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    orderby?: string;
    top?: number;
}

// @public
export type ContentKeyPoliciesListResponse = ContentKeyPolicyCollection;

// @public
export interface ContentKeyPoliciesUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ContentKeyPoliciesUpdateResponse = ContentKeyPolicy;

// @public
export interface ContentKeyPolicy extends ProxyResource {
    readonly created?: Date;
    description?: string;
    readonly lastModified?: Date;
    options?: ContentKeyPolicyOption[];
    readonly policyId?: string;
    readonly systemData?: SystemData;
}

// @public
export interface ContentKeyPolicyClearKeyConfiguration extends ContentKeyPolicyConfiguration {
    odataType: "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration";
}

// @public
export interface ContentKeyPolicyCollection {
    odataNextLink?: string;
    value?: ContentKeyPolicy[];
}

// @public
export interface ContentKeyPolicyConfiguration {
    odataType: "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration" | "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration" | "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration" | "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration" | "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration";
}

// @public (undocumented)
export type ContentKeyPolicyConfigurationUnion = ContentKeyPolicyConfiguration | ContentKeyPolicyClearKeyConfiguration | ContentKeyPolicyUnknownConfiguration | ContentKeyPolicyWidevineConfiguration | ContentKeyPolicyPlayReadyConfiguration | ContentKeyPolicyFairPlayConfiguration;

// @public
export interface ContentKeyPolicyFairPlayConfiguration extends ContentKeyPolicyConfiguration {
    ask: Uint8Array | null;
    fairPlayPfx: string | null;
    fairPlayPfxPassword: string | null;
    odataType: "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration";
    offlineRentalConfiguration?: ContentKeyPolicyFairPlayOfflineRentalConfiguration;
    rentalAndLeaseKeyType: ContentKeyPolicyFairPlayRentalAndLeaseKeyType;
    rentalDuration: number;
}

// @public (undocumented)
export interface ContentKeyPolicyFairPlayOfflineRentalConfiguration {
    playbackDurationSeconds: number;
    storageDurationSeconds: number;
}

// @public
export type ContentKeyPolicyFairPlayRentalAndLeaseKeyType = string;

// @public
export interface ContentKeyPolicyOpenRestriction extends ContentKeyPolicyRestriction {
    odataType: "#Microsoft.Media.ContentKeyPolicyOpenRestriction";
}

// @public
export interface ContentKeyPolicyOption {
    configuration: ContentKeyPolicyConfigurationUnion;
    name?: string;
    readonly policyOptionId?: string;
    restriction: ContentKeyPolicyRestrictionUnion;
}

// @public
export interface ContentKeyPolicyPlayReadyConfiguration extends ContentKeyPolicyConfiguration {
    licenses: ContentKeyPolicyPlayReadyLicense[];
    odataType: "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration";
    responseCustomData?: string;
}

// @public
export interface ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader extends ContentKeyPolicyPlayReadyContentKeyLocation {
    odataType: "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader";
}

// @public
export interface ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier extends ContentKeyPolicyPlayReadyContentKeyLocation {
    keyId: string | null;
    odataType: "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier";
}

// @public
export interface ContentKeyPolicyPlayReadyContentKeyLocation {
    odataType: "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader" | "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier";
}

// @public (undocumented)
export type ContentKeyPolicyPlayReadyContentKeyLocationUnion = ContentKeyPolicyPlayReadyContentKeyLocation | ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader | ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier;

// @public
export type ContentKeyPolicyPlayReadyContentType = string;

// @public
export interface ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
    bestEffort: boolean;
    configurationData: number;
}

// @public
export interface ContentKeyPolicyPlayReadyLicense {
    allowTestDevices: boolean;
    beginDate?: Date;
    contentKeyLocation: ContentKeyPolicyPlayReadyContentKeyLocationUnion;
    contentType: ContentKeyPolicyPlayReadyContentType;
    expirationDate?: Date;
    gracePeriod?: string;
    licenseType: ContentKeyPolicyPlayReadyLicenseType;
    playRight?: ContentKeyPolicyPlayReadyPlayRight;
    relativeBeginDate?: string;
    relativeExpirationDate?: string;
    securityLevel?: SecurityLevel;
}

// @public
export type ContentKeyPolicyPlayReadyLicenseType = string;

// @public
export interface ContentKeyPolicyPlayReadyPlayRight {
    agcAndColorStripeRestriction?: number;
    allowPassingVideoContentToUnknownOutput: ContentKeyPolicyPlayReadyUnknownOutputPassingOption;
    analogVideoOpl?: number;
    compressedDigitalAudioOpl?: number;
    compressedDigitalVideoOpl?: number;
    digitalVideoOnlyContentRestriction: boolean;
    explicitAnalogTelevisionOutputRestriction?: ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction;
    firstPlayExpiration?: string;
    imageConstraintForAnalogComponentVideoRestriction: boolean;
    imageConstraintForAnalogComputerMonitorRestriction: boolean;
    scmsRestriction?: number;
    uncompressedDigitalAudioOpl?: number;
    uncompressedDigitalVideoOpl?: number;
}

// @public
export type ContentKeyPolicyPlayReadyUnknownOutputPassingOption = string;

// @public
export interface ContentKeyPolicyProperties {
    readonly created?: Date;
    description?: string;
    readonly lastModified?: Date;
    options: ContentKeyPolicyOption[];
    readonly policyId?: string;
}

// @public
export interface ContentKeyPolicyRestriction {
    odataType: "#Microsoft.Media.ContentKeyPolicyOpenRestriction" | "#Microsoft.Media.ContentKeyPolicyUnknownRestriction" | "#Microsoft.Media.ContentKeyPolicyTokenRestriction";
}

// @public
export interface ContentKeyPolicyRestrictionTokenKey {
    odataType: "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey" | "#Microsoft.Media.ContentKeyPolicyRsaTokenKey" | "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey";
}

// @public (undocumented)
export type ContentKeyPolicyRestrictionTokenKeyUnion = ContentKeyPolicyRestrictionTokenKey | ContentKeyPolicySymmetricTokenKey | ContentKeyPolicyRsaTokenKey | ContentKeyPolicyX509CertificateTokenKey;

// @public
export type ContentKeyPolicyRestrictionTokenType = string;

// @public (undocumented)
export type ContentKeyPolicyRestrictionUnion = ContentKeyPolicyRestriction | ContentKeyPolicyOpenRestriction | ContentKeyPolicyUnknownRestriction | ContentKeyPolicyTokenRestriction;

// @public
export interface ContentKeyPolicyRsaTokenKey extends ContentKeyPolicyRestrictionTokenKey {
    exponent: Uint8Array | null;
    modulus: Uint8Array | null;
    odataType: "#Microsoft.Media.ContentKeyPolicyRsaTokenKey";
}

// @public
export interface ContentKeyPolicySymmetricTokenKey extends ContentKeyPolicyRestrictionTokenKey {
    keyValue: Uint8Array | null;
    odataType: "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey";
}

// @public
export interface ContentKeyPolicyTokenClaim {
    claimType?: string;
    claimValue?: string;
}

// @public
export interface ContentKeyPolicyTokenRestriction extends ContentKeyPolicyRestriction {
    alternateVerificationKeys?: ContentKeyPolicyRestrictionTokenKeyUnion[];
    audience: string;
    issuer: string;
    odataType: "#Microsoft.Media.ContentKeyPolicyTokenRestriction";
    openIdConnectDiscoveryDocument?: string;
    primaryVerificationKey: ContentKeyPolicyRestrictionTokenKeyUnion | null;
    requiredClaims?: ContentKeyPolicyTokenClaim[];
    restrictionTokenType: ContentKeyPolicyRestrictionTokenType;
}

// @public
export interface ContentKeyPolicyUnknownConfiguration extends ContentKeyPolicyConfiguration {
    odataType: "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration";
}

// @public
export interface ContentKeyPolicyUnknownRestriction extends ContentKeyPolicyRestriction {
    odataType: "#Microsoft.Media.ContentKeyPolicyUnknownRestriction";
}

// @public
export interface ContentKeyPolicyWidevineConfiguration extends ContentKeyPolicyConfiguration {
    odataType: "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration";
    widevineTemplate: string;
}

// @public
export interface ContentKeyPolicyX509CertificateTokenKey extends ContentKeyPolicyRestrictionTokenKey {
    odataType: "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey";
    rawBody: Uint8Array | null;
}

// @public
export interface CopyAudio extends Codec {
    odataType: "#Microsoft.Media.CopyAudio";
}

// @public
export interface CopyVideo extends Codec {
    odataType: "#Microsoft.Media.CopyVideo";
}

// @public
export type CreatedByType = string;

// @public
export interface CrossSiteAccessPolicies {
    clientAccessPolicy?: string;
    crossDomainPolicy?: string;
}

// @public
export interface DashSettings {
    role?: string;
}

// @public
export interface DDAudio extends Audio_2 {
    odataType: "#Microsoft.Media.DDAudio";
}

// @public
export type DefaultAction = string;

// @public
export interface DefaultKey {
    label?: string;
    policyName?: string;
}

// @public
export interface Deinterlace {
    mode?: DeinterlaceMode;
    parity?: DeinterlaceParity;
}

// @public
export type DeinterlaceMode = string;

// @public
export type DeinterlaceParity = string;

// @public (undocumented)
export interface EdgePolicies {
    // (undocumented)
    usageDataCollectionPolicy?: EdgeUsageDataCollectionPolicy;
}

// @public (undocumented)
export interface EdgeUsageDataCollectionPolicy {
    dataCollectionFrequency?: string;
    dataReportingFrequency?: string;
    eventHubDetails?: EdgeUsageDataEventHub;
    maxAllowedUnreportedUsageDuration?: string;
}

// @public (undocumented)
export interface EdgeUsageDataEventHub {
    name?: string;
    namespace?: string;
    token?: string;
}

// @public
export interface EnabledProtocols {
    dash: boolean;
    download: boolean;
    hls: boolean;
    smoothStreaming: boolean;
}

// @public
export type EncoderNamedPreset = string;

// @public
export type EncryptionScheme = string;

// @public
export interface EntityNameAvailabilityCheckOutput {
    message?: string;
    nameAvailable: boolean;
    reason?: string;
}

// @public
export type EntropyMode = string;

// @public
export interface EnvelopeEncryption {
    clearTracks?: TrackSelection[];
    contentKeys?: StreamingPolicyContentKeys;
    customKeyAcquisitionUrlTemplate?: string;
    enabledProtocols?: EnabledProtocols;
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface FaceDetectorPreset extends Preset {
    blurType?: BlurType;
    experimentalOptions?: {
        [propertyName: string]: string;
    };
    mode?: FaceRedactorMode;
    odataType: "#Microsoft.Media.FaceDetectorPreset";
    resolution?: AnalysisResolution;
}

// @public
export type FaceRedactorMode = string;

// @public
export interface Fade {
    duration: string;
    fadeColor: string;
    start?: string;
}

// @public
export interface Filters {
    crop?: Rectangle;
    deinterlace?: Deinterlace;
    fadeIn?: Fade;
    fadeOut?: Fade;
    overlays?: OverlayUnion[];
    rotation?: Rotation;
}

// @public
export type FilterTrackPropertyCompareOperation = string;

// @public
export interface FilterTrackPropertyCondition {
    operation: FilterTrackPropertyCompareOperation;
    property: FilterTrackPropertyType;
    value: string;
}

// @public
export type FilterTrackPropertyType = string;

// @public
export interface FilterTrackSelection {
    trackSelections: FilterTrackPropertyCondition[];
}

// @public
export interface FirstQuality {
    bitrate: number;
}

// @public
export interface Format {
    filenamePattern: string;
    odataType: "#Microsoft.Media.ImageFormat" | "#Microsoft.Media.JpgFormat" | "#Microsoft.Media.PngFormat" | "#Microsoft.Media.MultiBitrateFormat" | "#Microsoft.Media.Mp4Format" | "#Microsoft.Media.TransportStreamFormat";
}

// @public (undocumented)
export type FormatUnion = Format | ImageFormatUnion | MultiBitrateFormatUnion;

// @public
export interface FromAllInputFile extends InputDefinition {
    odataType: "#Microsoft.Media.FromAllInputFile";
}

// @public
export interface FromEachInputFile extends InputDefinition {
    odataType: "#Microsoft.Media.FromEachInputFile";
}

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export type H264Complexity = string;

// @public
export interface H264Layer extends VideoLayer {
    bufferWindow?: string;
    crf?: number;
    entropyMode?: EntropyMode;
    level?: string;
    profile?: H264VideoProfile;
    referenceFrames?: number;
}

// @public
export type H264RateControlMode = string;

// @public
export interface H264Video extends Video {
    complexity?: H264Complexity;
    layers?: H264Layer[];
    odataType: "#Microsoft.Media.H264Video";
    rateControlMode?: H264RateControlMode;
    sceneChangeDetection?: boolean;
}

// @public
export type H264VideoProfile = string;

// @public
export type H265Complexity = string;

// @public
export interface H265Layer extends H265VideoLayer {
    bufferWindow?: string;
    crf?: number;
    level?: string;
    profile?: H265VideoProfile;
    referenceFrames?: number;
}

// @public
export interface H265Video extends Video {
    complexity?: H265Complexity;
    layers?: H265Layer[];
    odataType: "#Microsoft.Media.H265Video";
    sceneChangeDetection?: boolean;
}

// @public
export interface H265VideoLayer extends Layer {
    adaptiveBFrame?: boolean;
    bFrames?: number;
    bitrate: number;
    frameRate?: string;
    maxBitrate?: number;
    slices?: number;
}

// @public
export type H265VideoProfile = string;

// @public
export interface Hls {
    fragmentsPerTsSegment?: number;
}

// @public
export interface HlsSettings {
    characteristics?: string;
    default?: boolean;
    forced?: boolean;
}

// @public
interface Image_2 extends Video {
    odataType: "#Microsoft.Media.Image" | "#Microsoft.Media.JpgImage" | "#Microsoft.Media.PngImage";
    range?: string;
    start: string;
    step?: string;
}
export { Image_2 as Image }

// @public
export interface ImageFormat extends Format {
    odataType: "#Microsoft.Media.ImageFormat" | "#Microsoft.Media.JpgFormat" | "#Microsoft.Media.PngFormat";
}

// @public (undocumented)
export type ImageFormatUnion = ImageFormat | JpgFormat | PngFormat;

// @public (undocumented)
export type ImageUnion = Image_2 | JpgImage | PngImage;

// @public
export interface InputDefinition {
    includedTracks?: TrackDescriptorUnion[];
    odataType: "#Microsoft.Media.FromAllInputFile" | "#Microsoft.Media.FromEachInputFile" | "#Microsoft.Media.InputFile";
}

// @public (undocumented)
export type InputDefinitionUnion = InputDefinition | FromAllInputFile | FromEachInputFile | InputFile;

// @public
export interface InputFile extends InputDefinition {
    filename?: string;
    odataType: "#Microsoft.Media.InputFile";
}

// @public
export type InsightsType = string;

// @public
export type InterleaveOutput = string;

// @public
export interface IPAccessControl {
    allow?: IPRange[];
}

// @public
export interface IPRange {
    address?: string;
    name?: string;
    subnetPrefixLength?: number;
}

// @public
export interface Job extends ProxyResource {
    correlationData?: {
        [propertyName: string]: string;
    };
    readonly created?: Date;
    description?: string;
    readonly endTime?: Date;
    input?: JobInputUnion;
    readonly lastModified?: Date;
    outputs?: JobOutputUnion[];
    priority?: Priority;
    readonly startTime?: Date;
    readonly state?: JobState;
    readonly systemData?: SystemData;
}

// @public
export interface JobCollection {
    odataNextLink?: string;
    value?: Job[];
}

// @public
export interface JobError {
    readonly category?: JobErrorCategory;
    readonly code?: JobErrorCode;
    readonly details?: JobErrorDetail[];
    readonly message?: string;
    readonly retry?: JobRetry;
}

// @public
export type JobErrorCategory = string;

// @public
export type JobErrorCode = string;

// @public
export interface JobErrorDetail {
    readonly code?: string;
    readonly message?: string;
}

// @public
export interface JobInput {
    odataType: "#Microsoft.Media.JobInputClip" | "#Microsoft.Media.JobInputs" | "#Microsoft.Media.JobInputAsset" | "#Microsoft.Media.JobInputHttp" | "#Microsoft.Media.JobInputSequence";
}

// @public
export interface JobInputAsset extends JobInputClip {
    assetName: string;
    odataType: "#Microsoft.Media.JobInputAsset";
}

// @public
export interface JobInputClip extends JobInput {
    end?: ClipTimeUnion;
    files?: string[];
    inputDefinitions?: InputDefinitionUnion[];
    label?: string;
    odataType: "#Microsoft.Media.JobInputClip" | "#Microsoft.Media.JobInputAsset" | "#Microsoft.Media.JobInputHttp";
    start?: ClipTimeUnion;
}

// @public (undocumented)
export type JobInputClipUnion = JobInputClip | JobInputAsset | JobInputHttp;

// @public
export interface JobInputHttp extends JobInputClip {
    baseUri?: string;
    odataType: "#Microsoft.Media.JobInputHttp";
}

// @public
export interface JobInputs extends JobInput {
    inputs?: JobInputUnion[];
    odataType: "#Microsoft.Media.JobInputs";
}

// @public
export interface JobInputSequence extends JobInput {
    inputs?: JobInputClipUnion[];
    odataType: "#Microsoft.Media.JobInputSequence";
}

// @public (undocumented)
export type JobInputUnion = JobInput | JobInputClipUnion | JobInputs | JobInputSequence;

// @public
export interface JobOutput {
    readonly endTime?: Date;
    readonly error?: JobError;
    label?: string;
    odataType: "#Microsoft.Media.JobOutputAsset";
    presetOverride?: PresetUnion;
    readonly progress?: number;
    readonly startTime?: Date;
    readonly state?: JobState;
}

// @public
export interface JobOutputAsset extends JobOutput {
    assetName: string;
    odataType: "#Microsoft.Media.JobOutputAsset";
}

// @public (undocumented)
export type JobOutputUnion = JobOutput | JobOutputAsset;

// @public
export type JobRetry = string;

// @public
export interface Jobs {
    cancelJob(resourceGroupName: string, accountName: string, transformName: string, jobName: string, options?: JobsCancelJobOptionalParams): Promise<void>;
    create(resourceGroupName: string, accountName: string, transformName: string, jobName: string, parameters: Job, options?: JobsCreateOptionalParams): Promise<JobsCreateResponse>;
    delete(resourceGroupName: string, accountName: string, transformName: string, jobName: string, options?: JobsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, transformName: string, jobName: string, options?: JobsGetOptionalParams): Promise<JobsGetResponse>;
    list(resourceGroupName: string, accountName: string, transformName: string, options?: JobsListOptionalParams): PagedAsyncIterableIterator<Job>;
    update(resourceGroupName: string, accountName: string, transformName: string, jobName: string, parameters: Job, options?: JobsUpdateOptionalParams): Promise<JobsUpdateResponse>;
}

// @public
export interface JobsCancelJobOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface JobsCreateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type JobsCreateResponse = Job;

// @public
export interface JobsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface JobsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type JobsGetResponse = Job;

// @public
export interface JobsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type JobsListNextResponse = JobCollection;

// @public
export interface JobsListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    orderby?: string;
}

// @public
export type JobsListResponse = JobCollection;

// @public
export type JobState = string;

// @public
export interface JobsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type JobsUpdateResponse = Job;

// @public
export interface JpgFormat extends ImageFormat {
    odataType: "#Microsoft.Media.JpgFormat";
}

// @public
export interface JpgImage extends Image_2 {
    layers?: JpgLayer[];
    odataType: "#Microsoft.Media.JpgImage";
    spriteColumn?: number;
}

// @public
export interface JpgLayer extends Layer {
    quality?: number;
}

// @public (undocumented)
export interface KeyDelivery {
    accessControl?: AccessControl;
}

// @public (undocumented)
export interface KeyVaultProperties {
    readonly currentKeyIdentifier?: string;
    keyIdentifier?: string;
}

// @public
export enum KnownAacAudioProfile {
    AacLc = "AacLc",
    HeAacV1 = "HeAacV1",
    HeAacV2 = "HeAacV2"
}

// @public
export enum KnownAccountEncryptionKeyType {
    CustomerKey = "CustomerKey",
    SystemKey = "SystemKey"
}

// @public
export enum KnownActionType {
    Internal = "Internal"
}

// @public
export enum KnownAnalysisResolution {
    SourceResolution = "SourceResolution",
    StandardDefinition = "StandardDefinition"
}

// @public
export enum KnownAssetContainerPermission {
    Read = "Read",
    ReadWrite = "ReadWrite",
    ReadWriteDelete = "ReadWriteDelete"
}

// @public
export enum KnownAssetStorageEncryptionFormat {
    MediaStorageClientEncryption = "MediaStorageClientEncryption",
    None = "None"
}

// @public
export enum KnownAsyncOperationStatus {
    Failed = "Failed",
    InProgress = "InProgress",
    Succeeded = "Succeeded"
}

// @public
export enum KnownAttributeFilter {
    All = "All",
    Bottom = "Bottom",
    Top = "Top",
    ValueEquals = "ValueEquals"
}

// @public
export enum KnownAudioAnalysisMode {
    Basic = "Basic",
    Standard = "Standard"
}

// @public
export enum KnownBlurType {
    Black = "Black",
    Box = "Box",
    High = "High",
    Low = "Low",
    Med = "Med"
}

// @public
export enum KnownChannelMapping {
    BackLeft = "BackLeft",
    BackRight = "BackRight",
    Center = "Center",
    FrontLeft = "FrontLeft",
    FrontRight = "FrontRight",
    LowFrequencyEffects = "LowFrequencyEffects",
    StereoLeft = "StereoLeft",
    StereoRight = "StereoRight"
}

// @public
export enum KnownComplexity {
    Balanced = "Balanced",
    Quality = "Quality",
    Speed = "Speed"
}

// @public
export enum KnownContentKeyPolicyFairPlayRentalAndLeaseKeyType {
    DualExpiry = "DualExpiry",
    PersistentLimited = "PersistentLimited",
    PersistentUnlimited = "PersistentUnlimited",
    Undefined = "Undefined",
    Unknown = "Unknown"
}

// @public
export enum KnownContentKeyPolicyPlayReadyContentType {
    UltraVioletDownload = "UltraVioletDownload",
    UltraVioletStreaming = "UltraVioletStreaming",
    Unknown = "Unknown",
    Unspecified = "Unspecified"
}

// @public
export enum KnownContentKeyPolicyPlayReadyLicenseType {
    NonPersistent = "NonPersistent",
    Persistent = "Persistent",
    Unknown = "Unknown"
}

// @public
export enum KnownContentKeyPolicyPlayReadyUnknownOutputPassingOption {
    Allowed = "Allowed",
    AllowedWithVideoConstriction = "AllowedWithVideoConstriction",
    NotAllowed = "NotAllowed",
    Unknown = "Unknown"
}

// @public
export enum KnownContentKeyPolicyRestrictionTokenType {
    Jwt = "Jwt",
    Swt = "Swt",
    Unknown = "Unknown"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDefaultAction {
    Allow = "Allow",
    Deny = "Deny"
}

// @public
export enum KnownDeinterlaceMode {
    AutoPixelAdaptive = "AutoPixelAdaptive",
    Off = "Off"
}

// @public
export enum KnownDeinterlaceParity {
    Auto = "Auto",
    BottomFieldFirst = "BottomFieldFirst",
    TopFieldFirst = "TopFieldFirst"
}

// @public
export enum KnownEncoderNamedPreset {
    AACGoodQualityAudio = "AACGoodQualityAudio",
    AdaptiveStreaming = "AdaptiveStreaming",
    ContentAwareEncoding = "ContentAwareEncoding",
    ContentAwareEncodingExperimental = "ContentAwareEncodingExperimental",
    CopyAllBitrateNonInterleaved = "CopyAllBitrateNonInterleaved",
    DDGoodQualityAudio = "DDGoodQualityAudio",
    H264MultipleBitrate1080P = "H264MultipleBitrate1080p",
    H264MultipleBitrate720P = "H264MultipleBitrate720p",
    H264MultipleBitrateSD = "H264MultipleBitrateSD",
    H264SingleBitrate1080P = "H264SingleBitrate1080p",
    H264SingleBitrate720P = "H264SingleBitrate720p",
    H264SingleBitrateSD = "H264SingleBitrateSD",
    H265AdaptiveStreaming = "H265AdaptiveStreaming",
    H265ContentAwareEncoding = "H265ContentAwareEncoding",
    H265SingleBitrate1080P = "H265SingleBitrate1080p",
    H265SingleBitrate4K = "H265SingleBitrate4K",
    H265SingleBitrate720P = "H265SingleBitrate720p"
}

// @public
export enum KnownEncryptionScheme {
    CommonEncryptionCbcs = "CommonEncryptionCbcs",
    CommonEncryptionCenc = "CommonEncryptionCenc",
    EnvelopeEncryption = "EnvelopeEncryption",
    NoEncryption = "NoEncryption"
}

// @public
export enum KnownEntropyMode {
    Cabac = "Cabac",
    Cavlc = "Cavlc"
}

// @public
export enum KnownFaceRedactorMode {
    Analyze = "Analyze",
    Combined = "Combined",
    Redact = "Redact"
}

// @public
export enum KnownFilterTrackPropertyCompareOperation {
    Equal = "Equal",
    NotEqual = "NotEqual"
}

// @public
export enum KnownFilterTrackPropertyType {
    Bitrate = "Bitrate",
    FourCC = "FourCC",
    Language = "Language",
    Name = "Name",
    Type = "Type",
    Unknown = "Unknown"
}

// @public
export enum KnownH264Complexity {
    Balanced = "Balanced",
    Quality = "Quality",
    Speed = "Speed"
}

// @public
export enum KnownH264RateControlMode {
    ABR = "ABR",
    CBR = "CBR",
    CRF = "CRF"
}

// @public
export enum KnownH264VideoProfile {
    Auto = "Auto",
    Baseline = "Baseline",
    High = "High",
    High422 = "High422",
    High444 = "High444",
    Main = "Main"
}

// @public
export enum KnownH265Complexity {
    Balanced = "Balanced",
    Quality = "Quality",
    Speed = "Speed"
}

// @public
export enum KnownH265VideoProfile {
    Auto = "Auto",
    Main = "Main",
    Main10 = "Main10"
}

// @public
export enum KnownInsightsType {
    AllInsights = "AllInsights",
    AudioInsightsOnly = "AudioInsightsOnly",
    VideoInsightsOnly = "VideoInsightsOnly"
}

// @public
export enum KnownInterleaveOutput {
    InterleavedOutput = "InterleavedOutput",
    NonInterleavedOutput = "NonInterleavedOutput"
}

// @public
export enum KnownJobErrorCategory {
    Account = "Account",
    Configuration = "Configuration",
    Content = "Content",
    Download = "Download",
    Service = "Service",
    Upload = "Upload"
}

// @public
export enum KnownJobErrorCode {
    ConfigurationUnsupported = "ConfigurationUnsupported",
    ContentMalformed = "ContentMalformed",
    ContentUnsupported = "ContentUnsupported",
    DownloadNotAccessible = "DownloadNotAccessible",
    DownloadTransientError = "DownloadTransientError",
    IdentityUnsupported = "IdentityUnsupported",
    ServiceError = "ServiceError",
    ServiceTransientError = "ServiceTransientError",
    UploadNotAccessible = "UploadNotAccessible",
    UploadTransientError = "UploadTransientError"
}

// @public
export enum KnownJobRetry {
    DoNotRetry = "DoNotRetry",
    MayRetry = "MayRetry"
}

// @public
export enum KnownJobState {
    Canceled = "Canceled",
    Canceling = "Canceling",
    Error = "Error",
    Finished = "Finished",
    Processing = "Processing",
    Queued = "Queued",
    Scheduled = "Scheduled"
}

// @public
export enum KnownLiveEventEncodingType {
    None = "None",
    PassthroughBasic = "PassthroughBasic",
    PassthroughStandard = "PassthroughStandard",
    Premium1080P = "Premium1080p",
    Standard = "Standard"
}

// @public
export enum KnownLiveEventInputProtocol {
    FragmentedMP4 = "FragmentedMP4",
    Rtmp = "RTMP"
}

// @public
export enum KnownLiveEventResourceState {
    Allocating = "Allocating",
    Deleting = "Deleting",
    Running = "Running",
    StandBy = "StandBy",
    Starting = "Starting",
    Stopped = "Stopped",
    Stopping = "Stopping"
}

// @public
export enum KnownLiveOutputResourceState {
    Creating = "Creating",
    Deleting = "Deleting",
    Running = "Running"
}

// @public
export enum KnownMetricAggregationType {
    Average = "Average",
    Count = "Count",
    Total = "Total"
}

// @public
export enum KnownMetricUnit {
    Bytes = "Bytes",
    Count = "Count",
    Milliseconds = "Milliseconds"
}

// @public
export enum KnownOnErrorType {
    ContinueJob = "ContinueJob",
    StopProcessingJob = "StopProcessingJob"
}

// @public
export enum KnownPriority {
    High = "High",
    Low = "Low",
    Normal = "Normal"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownPrivateEndpointServiceConnectionStatus {
    Approved = "Approved",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownProvisioningState {
    Failed = "Failed",
    InProgress = "InProgress",
    Succeeded = "Succeeded"
}

// @public
export enum KnownPublicNetworkAccess {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownRotation {
    Auto = "Auto",
    None = "None",
    Rotate0 = "Rotate0",
    Rotate180 = "Rotate180",
    Rotate270 = "Rotate270",
    Rotate90 = "Rotate90"
}

// @public
export enum KnownSecurityLevel {
    SL150 = "SL150",
    SL2000 = "SL2000",
    SL3000 = "SL3000",
    Unknown = "Unknown"
}

// @public
export enum KnownStorageAccountType {
    Primary = "Primary",
    Secondary = "Secondary"
}

// @public
export enum KnownStorageAuthentication {
    ManagedIdentity = "ManagedIdentity",
    System = "System"
}

// @public
export enum KnownStreamingEndpointResourceState {
    Deleting = "Deleting",
    Running = "Running",
    Scaling = "Scaling",
    Starting = "Starting",
    Stopped = "Stopped",
    Stopping = "Stopping"
}

// @public
export enum KnownStreamingLocatorContentKeyType {
    CommonEncryptionCbcs = "CommonEncryptionCbcs",
    CommonEncryptionCenc = "CommonEncryptionCenc",
    EnvelopeEncryption = "EnvelopeEncryption"
}

// @public
export enum KnownStreamingPolicyStreamingProtocol {
    Dash = "Dash",
    Download = "Download",
    Hls = "Hls",
    SmoothStreaming = "SmoothStreaming"
}

// @public
export enum KnownStreamOptionsFlag {
    Default = "Default",
    LowLatency = "LowLatency",
    LowLatencyV2 = "LowLatencyV2"
}

// @public
export enum KnownStretchMode {
    AutoFit = "AutoFit",
    AutoSize = "AutoSize",
    None = "None"
}

// @public
export enum KnownTrackAttribute {
    Bitrate = "Bitrate",
    Language = "Language"
}

// @public
export enum KnownTrackPropertyCompareOperation {
    Equal = "Equal",
    Unknown = "Unknown"
}

// @public
export enum KnownTrackPropertyType {
    FourCC = "FourCC",
    Unknown = "Unknown"
}

// @public
export enum KnownVideoSyncMode {
    Auto = "Auto",
    Cfr = "Cfr",
    Passthrough = "Passthrough",
    Vfr = "Vfr"
}

// @public
export enum KnownVisibility {
    Hidden = "Hidden",
    Visible = "Visible"
}

// @public
export interface Layer {
    height?: string;
    label?: string;
    width?: string;
}

// @public
export interface ListContainerSasInput {
    expiryTime?: Date;
    permissions?: AssetContainerPermission;
}

// @public
export interface ListContentKeysResponse {
    contentKeys?: StreamingLocatorContentKey[];
}

// @public (undocumented)
export interface ListEdgePoliciesInput {
    deviceId?: string;
}

// @public
export interface ListPathsResponse {
    downloadPaths?: string[];
    streamingPaths?: StreamingPath[];
}

// @public
export interface ListStreamingLocatorsResponse {
    readonly streamingLocators?: AssetStreamingLocator[];
}

// @public
export interface LiveEvent extends TrackedResource {
    readonly created?: Date;
    crossSiteAccessPolicies?: CrossSiteAccessPolicies;
    description?: string;
    encoding?: LiveEventEncoding;
    hostnamePrefix?: string;
    input?: LiveEventInput;
    readonly lastModified?: Date;
    preview?: LiveEventPreview;
    readonly provisioningState?: string;
    readonly resourceState?: LiveEventResourceState;
    streamOptions?: StreamOptionsFlag[];
    readonly systemData?: SystemData;
    transcriptions?: LiveEventTranscription[];
    useStaticHostname?: boolean;
}

// @public
export interface LiveEventActionInput {
    removeOutputsOnStop?: boolean;
}

// @public
export interface LiveEventEncoding {
    encodingType?: LiveEventEncodingType;
    keyFrameInterval?: string;
    presetName?: string;
    stretchMode?: StretchMode;
}

// @public
export type LiveEventEncodingType = string;

// @public
export interface LiveEventEndpoint {
    protocol?: string;
    url?: string;
}

// @public
export interface LiveEventInput {
    accessControl?: LiveEventInputAccessControl;
    accessToken?: string;
    endpoints?: LiveEventEndpoint[];
    keyFrameIntervalDuration?: string;
    streamingProtocol: LiveEventInputProtocol;
}

// @public
export interface LiveEventInputAccessControl {
    ip?: IPAccessControl;
}

// @public
export type LiveEventInputProtocol = string;

// @public
export interface LiveEventInputTrackSelection {
    operation?: string;
    property?: string;
    value?: string;
}

// @public
export interface LiveEventListResult {
    odataCount?: number;
    odataNextLink?: string;
    value?: LiveEvent[];
}

// @public
export interface LiveEventOutputTranscriptionTrack {
    trackName: string;
}

// @public
export interface LiveEventPreview {
    accessControl?: LiveEventPreviewAccessControl;
    alternativeMediaId?: string;
    endpoints?: LiveEventEndpoint[];
    previewLocator?: string;
    streamingPolicyName?: string;
}

// @public
export interface LiveEventPreviewAccessControl {
    ip?: IPAccessControl;
}

// @public
export type LiveEventResourceState = string;

// @public
export interface LiveEvents {
    asyncOperation(resourceGroupName: string, accountName: string, operationId: string, options?: LiveEventsAsyncOperationOptionalParams): Promise<LiveEventsAsyncOperationResponse>;
    beginAllocate(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsAllocateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginAllocateAndWait(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsAllocateOptionalParams): Promise<void>;
    beginCreate(resourceGroupName: string, accountName: string, liveEventName: string, parameters: LiveEvent, options?: LiveEventsCreateOptionalParams): Promise<PollerLike<PollOperationState<LiveEventsCreateResponse>, LiveEventsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, liveEventName: string, parameters: LiveEvent, options?: LiveEventsCreateOptionalParams): Promise<LiveEventsCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsDeleteOptionalParams): Promise<void>;
    beginReset(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsResetOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginResetAndWait(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsResetOptionalParams): Promise<void>;
    beginStart(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsStartOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginStartAndWait(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsStartOptionalParams): Promise<void>;
    beginStop(resourceGroupName: string, accountName: string, liveEventName: string, parameters: LiveEventActionInput, options?: LiveEventsStopOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginStopAndWait(resourceGroupName: string, accountName: string, liveEventName: string, parameters: LiveEventActionInput, options?: LiveEventsStopOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, liveEventName: string, parameters: LiveEvent, options?: LiveEventsUpdateOptionalParams): Promise<PollerLike<PollOperationState<LiveEventsUpdateResponse>, LiveEventsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, liveEventName: string, parameters: LiveEvent, options?: LiveEventsUpdateOptionalParams): Promise<LiveEventsUpdateResponse>;
    get(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveEventsGetOptionalParams): Promise<LiveEventsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: LiveEventsListOptionalParams): PagedAsyncIterableIterator<LiveEvent>;
    operationLocation(resourceGroupName: string, accountName: string, liveEventName: string, operationId: string, options?: LiveEventsOperationLocationOptionalParams): Promise<LiveEventsOperationLocationResponse>;
}

// @public
export interface LiveEventsAllocateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface LiveEventsAsyncOperationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveEventsAsyncOperationResponse = AsyncOperationResult;

// @public
export interface LiveEventsCreateOptionalParams extends coreClient.OperationOptions {
    autoStart?: boolean;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type LiveEventsCreateResponse = LiveEvent;

// @public
export interface LiveEventsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface LiveEventsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveEventsGetResponse = LiveEvent;

// @public
export interface LiveEventsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveEventsListNextResponse = LiveEventListResult;

// @public
export interface LiveEventsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveEventsListResponse = LiveEventListResult;

// @public
export interface LiveEventsOperationLocationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveEventsOperationLocationResponse = LiveEvent;

// @public
export interface LiveEventsResetOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface LiveEventsStartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface LiveEventsStopOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface LiveEventsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type LiveEventsUpdateResponse = LiveEvent;

// @public
export interface LiveEventTranscription {
    inputTrackSelection?: LiveEventInputTrackSelection[];
    language?: string;
    outputTranscriptionTrack?: LiveEventOutputTranscriptionTrack;
}

// @public
export interface LiveOutput extends ProxyResource {
    archiveWindowLength?: string;
    assetName?: string;
    readonly created?: Date;
    description?: string;
    hls?: Hls;
    readonly lastModified?: Date;
    manifestName?: string;
    outputSnapTime?: number;
    readonly provisioningState?: string;
    readonly resourceState?: LiveOutputResourceState;
    rewindWindowLength?: string;
    readonly systemData?: SystemData;
}

// @public
export interface LiveOutputListResult {
    odataCount?: number;
    odataNextLink?: string;
    value?: LiveOutput[];
}

// @public
export type LiveOutputResourceState = string;

// @public
export interface LiveOutputs {
    asyncOperation(resourceGroupName: string, accountName: string, operationId: string, options?: LiveOutputsAsyncOperationOptionalParams): Promise<LiveOutputsAsyncOperationResponse>;
    beginCreate(resourceGroupName: string, accountName: string, liveEventName: string, liveOutputName: string, parameters: LiveOutput, options?: LiveOutputsCreateOptionalParams): Promise<PollerLike<PollOperationState<LiveOutputsCreateResponse>, LiveOutputsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, liveEventName: string, liveOutputName: string, parameters: LiveOutput, options?: LiveOutputsCreateOptionalParams): Promise<LiveOutputsCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, liveEventName: string, liveOutputName: string, options?: LiveOutputsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, liveEventName: string, liveOutputName: string, options?: LiveOutputsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, liveEventName: string, liveOutputName: string, options?: LiveOutputsGetOptionalParams): Promise<LiveOutputsGetResponse>;
    list(resourceGroupName: string, accountName: string, liveEventName: string, options?: LiveOutputsListOptionalParams): PagedAsyncIterableIterator<LiveOutput>;
    operationLocation(resourceGroupName: string, accountName: string, liveEventName: string, liveOutputName: string, operationId: string, options?: LiveOutputsOperationLocationOptionalParams): Promise<LiveOutputsOperationLocationResponse>;
}

// @public
export interface LiveOutputsAsyncOperationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveOutputsAsyncOperationResponse = AsyncOperationResult;

// @public
export interface LiveOutputsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type LiveOutputsCreateResponse = LiveOutput;

// @public
export interface LiveOutputsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface LiveOutputsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveOutputsGetResponse = LiveOutput;

// @public
export interface LiveOutputsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveOutputsListNextResponse = LiveOutputListResult;

// @public
export interface LiveOutputsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveOutputsListResponse = LiveOutputListResult;

// @public
export interface LiveOutputsOperationLocationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LiveOutputsOperationLocationResponse = LiveOutput;

// @public
export interface Locations {
    checkNameAvailability(locationName: string, parameters: CheckNameAvailabilityInput, options?: LocationsCheckNameAvailabilityOptionalParams): Promise<LocationsCheckNameAvailabilityResponse>;
}

// @public
export interface LocationsCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type LocationsCheckNameAvailabilityResponse = EntityNameAvailabilityCheckOutput;

// @public
export interface LogSpecification {
    readonly blobDuration?: string;
    readonly displayName?: string;
    readonly name?: string;
}

// @public
export interface MediaService extends TrackedResource {
    encryption?: AccountEncryption;
    identity?: MediaServiceIdentity;
    keyDelivery?: KeyDelivery;
    readonly mediaServiceId?: string;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    readonly provisioningState?: ProvisioningState;
    publicNetworkAccess?: PublicNetworkAccess;
    storageAccounts?: StorageAccount[];
    // (undocumented)
    storageAuthentication?: StorageAuthentication;
    readonly systemData?: SystemData;
}

// @public
export interface MediaServiceCollection {
    odataNextLink?: string;
    value?: MediaService[];
}

// @public (undocumented)
export interface MediaServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: string;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedManagedIdentity;
    };
}

// @public
export interface MediaServiceOperationStatus {
    endTime?: Date;
    error?: ErrorDetail;
    id?: string;
    name: string;
    startTime?: Date;
    status: string;
}

// @public
export interface Mediaservices {
    beginCreateOrUpdate(resourceGroupName: string, accountName: string, parameters: MediaService, options?: MediaservicesCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<MediaservicesCreateOrUpdateResponse>, MediaservicesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, accountName: string, parameters: MediaService, options?: MediaservicesCreateOrUpdateOptionalParams): Promise<MediaservicesCreateOrUpdateResponse>;
    beginUpdate(resourceGroupName: string, accountName: string, parameters: MediaServiceUpdate, options?: MediaservicesUpdateOptionalParams): Promise<PollerLike<PollOperationState<MediaservicesUpdateResponse>, MediaservicesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, parameters: MediaServiceUpdate, options?: MediaservicesUpdateOptionalParams): Promise<MediaservicesUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, options?: MediaservicesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, options?: MediaservicesGetOptionalParams): Promise<MediaservicesGetResponse>;
    list(resourceGroupName: string, options?: MediaservicesListOptionalParams): PagedAsyncIterableIterator<MediaService>;
    listBySubscription(options?: MediaservicesListBySubscriptionOptionalParams): PagedAsyncIterableIterator<MediaService>;
    listEdgePolicies(resourceGroupName: string, accountName: string, parameters: ListEdgePoliciesInput, options?: MediaservicesListEdgePoliciesOptionalParams): Promise<MediaservicesListEdgePoliciesResponse>;
    syncStorageKeys(resourceGroupName: string, accountName: string, parameters: SyncStorageKeysInput, options?: MediaservicesSyncStorageKeysOptionalParams): Promise<void>;
}

// @public
export interface MediaservicesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
    retryAfter?: number;
}

// @public
export interface MediaservicesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type MediaservicesCreateOrUpdateResponse = MediaservicesCreateOrUpdateHeaders & MediaService;

// @public
export interface MediaservicesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface MediaservicesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MediaservicesGetResponse = MediaService;

// @public
export interface MediaservicesListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MediaservicesListBySubscriptionNextResponse = MediaServiceCollection;

// @public
export interface MediaservicesListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MediaservicesListBySubscriptionResponse = MediaServiceCollection;

// @public
export interface MediaservicesListEdgePoliciesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MediaservicesListEdgePoliciesResponse = EdgePolicies;

// @public
export interface MediaservicesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MediaservicesListNextResponse = MediaServiceCollection;

// @public
export interface MediaservicesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MediaservicesListResponse = MediaServiceCollection;

// @public
export interface MediaServicesOperationResults {
    get(locationName: string, operationId: string, options?: MediaServicesOperationResultsGetOptionalParams): Promise<MediaServicesOperationResultsGetResponse>;
}

// @public
export interface MediaServicesOperationResultsGetHeaders {
    azureAsyncOperation?: string;
    location?: string;
    retryAfter?: number;
}

// @public
export interface MediaServicesOperationResultsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MediaServicesOperationResultsGetResponse = MediaService;

// @public
export interface MediaServicesOperationStatuses {
    get(locationName: string, operationId: string, options?: MediaServicesOperationStatusesGetOptionalParams): Promise<MediaServicesOperationStatusesGetResponse>;
}

// @public
export interface MediaServicesOperationStatusesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MediaServicesOperationStatusesGetResponse = MediaServiceOperationStatus;

// @public
export interface MediaservicesSyncStorageKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface MediaservicesUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
    retryAfter?: number;
}

// @public
export interface MediaservicesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type MediaservicesUpdateResponse = MediaservicesUpdateHeaders & MediaService;

// @public
export interface MediaServiceUpdate {
    encryption?: AccountEncryption;
    identity?: MediaServiceIdentity;
    keyDelivery?: KeyDelivery;
    readonly mediaServiceId?: string;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    readonly provisioningState?: ProvisioningState;
    publicNetworkAccess?: PublicNetworkAccess;
    storageAccounts?: StorageAccount[];
    // (undocumented)
    storageAuthentication?: StorageAuthentication;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type MetricAggregationType = string;

// @public
export interface MetricDimension {
    readonly displayName?: string;
    readonly name?: string;
    readonly toBeExportedForShoebox?: boolean;
}

// @public
export interface MetricSpecification {
    readonly aggregationType?: MetricAggregationType;
    readonly dimensions?: MetricDimension[];
    readonly displayDescription?: string;
    readonly displayName?: string;
    readonly enableRegionalMdmAccount?: boolean;
    readonly lockAggregationType?: MetricAggregationType;
    readonly name?: string;
    readonly sourceMdmAccount?: string;
    readonly sourceMdmNamespace?: string;
    supportedAggregationTypes?: string[];
    readonly supportedTimeGrainTypes?: string[];
    readonly unit?: MetricUnit;
}

// @public
export type MetricUnit = string;

// @public
export interface Mp4Format extends MultiBitrateFormat {
    odataType: "#Microsoft.Media.Mp4Format";
}

// @public
export interface MultiBitrateFormat extends Format {
    odataType: "#Microsoft.Media.MultiBitrateFormat" | "#Microsoft.Media.Mp4Format" | "#Microsoft.Media.TransportStreamFormat";
    outputFiles?: OutputFile[];
}

// @public (undocumented)
export type MultiBitrateFormatUnion = MultiBitrateFormat | Mp4Format | TransportStreamFormat;

// @public
export interface NoEncryption {
    enabledProtocols?: EnabledProtocols;
}

// @public
export type OnErrorType = string;

// @public
export interface Operation {
    actionType?: ActionType;
    display?: OperationDisplay;
    isDataAction?: boolean;
    name: string;
    origin?: string;
    properties?: Properties;
}

// @public
export interface OperationCollection {
    value?: Operation[];
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationResults {
    get(resourceGroupName: string, accountName: string, assetName: string, trackName: string, operationId: string, options?: OperationResultsGetOptionalParams): Promise<OperationResultsGetResponse>;
}

// @public
export interface OperationResultsGetHeaders {
    azureAsyncOperation?: string;
    location?: string;
    retryAfter?: number;
}

// @public
export interface OperationResultsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationResultsGetResponse = AssetTrack;

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): Promise<OperationsListResponse>;
}

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationCollection;

// @public
export interface OperationStatuses {
    get(resourceGroupName: string, accountName: string, assetName: string, trackName: string, operationId: string, options?: OperationStatusesGetOptionalParams): Promise<OperationStatusesGetResponse>;
}

// @public
export interface OperationStatusesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationStatusesGetResponse = AssetTrackOperationStatus;

// @public
export interface OutputFile {
    labels: string[];
}

// @public
export interface Overlay {
    audioGainLevel?: number;
    end?: string;
    fadeInDuration?: string;
    fadeOutDuration?: string;
    inputLabel: string;
    odataType: "#Microsoft.Media.AudioOverlay" | "#Microsoft.Media.VideoOverlay";
    start?: string;
}

// @public (undocumented)
export type OverlayUnion = Overlay | AudioOverlay | VideoOverlay;

// @public
export interface PngFormat extends ImageFormat {
    odataType: "#Microsoft.Media.PngFormat";
}

// @public
export interface PngImage extends Image_2 {
    layers?: PngLayer[];
    odataType: "#Microsoft.Media.PngImage";
}

// @public
export interface PngLayer extends Layer {
}

// @public
export interface PresentationTimeRange {
    endTimestamp?: number;
    forceEndTimestamp?: boolean;
    liveBackoffDuration?: number;
    presentationWindowDuration?: number;
    startTimestamp?: number;
    timescale?: number;
}

// @public
export interface Preset {
    odataType: "#Microsoft.Media.FaceDetectorPreset" | "#Microsoft.Media.AudioAnalyzerPreset" | "#Microsoft.Media.BuiltInStandardEncoderPreset" | "#Microsoft.Media.StandardEncoderPreset" | "#Microsoft.Media.VideoAnalyzerPreset";
}

// @public
export interface PresetConfigurations {
    complexity?: Complexity;
    interleaveOutput?: InterleaveOutput;
    keyFrameIntervalInSeconds?: number;
    maxBitrateBps?: number;
    maxHeight?: number;
    maxLayers?: number;
    minBitrateBps?: number;
    minHeight?: number;
}

// @public (undocumented)
export type PresetUnion = Preset | FaceDetectorPreset | AudioAnalyzerPresetUnion | BuiltInStandardEncoderPreset | StandardEncoderPreset;

// @public
export type Priority = string;

// @public
export interface PrivateEndpoint {
    readonly id?: string;
}

// @public
export interface PrivateEndpointConnection extends Resource {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
}

// @public
export interface PrivateEndpointConnectionListResult {
    value?: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export interface PrivateEndpointConnections {
    createOrUpdate(resourceGroupName: string, accountName: string, name: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionsCreateOrUpdateOptionalParams): Promise<PrivateEndpointConnectionsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, name: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, name: string, options?: PrivateEndpointConnectionsGetOptionalParams): Promise<PrivateEndpointConnectionsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: PrivateEndpointConnectionsListOptionalParams): Promise<PrivateEndpointConnectionsListResponse>;
}

// @public
export interface PrivateEndpointConnectionsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsCreateOrUpdateResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult;

// @public
export type PrivateEndpointServiceConnectionStatus = string;

// @public
export interface PrivateLinkResource extends Resource {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
}

// @public
export interface PrivateLinkResourceListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkResources {
    get(resourceGroupName: string, accountName: string, name: string, options?: PrivateLinkResourcesGetOptionalParams): Promise<PrivateLinkResourcesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: PrivateLinkResourcesListOptionalParams): Promise<PrivateLinkResourcesListResponse>;
}

// @public
export interface PrivateLinkResourcesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesGetResponse = PrivateLinkResource;

// @public
export interface PrivateLinkResourcesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesListResponse = PrivateLinkResourceListResult;

// @public
export interface PrivateLinkServiceConnectionState {
    actionsRequired?: string;
    description?: string;
    status?: PrivateEndpointServiceConnectionStatus;
}

// @public
export interface Properties {
    readonly serviceSpecification?: ServiceSpecification;
}

// @public
export type ProvisioningState = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export type PublicNetworkAccess = string;

// @public
export interface Rectangle {
    height?: string;
    left?: string;
    top?: string;
    width?: string;
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public (undocumented)
export interface ResourceIdentity {
    userAssignedIdentity?: string;
    useSystemAssignedIdentity: boolean;
}

// @public
export type Rotation = string;

// @public
export type SecurityLevel = string;

// @public
export interface SelectAudioTrackByAttribute extends AudioTrackDescriptor {
    attribute: TrackAttribute;
    filter: AttributeFilter;
    filterValue?: string;
    odataType: "#Microsoft.Media.SelectAudioTrackByAttribute";
}

// @public
export interface SelectAudioTrackById extends AudioTrackDescriptor {
    odataType: "#Microsoft.Media.SelectAudioTrackById";
    trackId: number;
}

// @public
export interface SelectVideoTrackByAttribute extends VideoTrackDescriptor {
    attribute: TrackAttribute;
    filter: AttributeFilter;
    filterValue?: string;
    odataType: "#Microsoft.Media.SelectVideoTrackByAttribute";
}

// @public
export interface SelectVideoTrackById extends VideoTrackDescriptor {
    odataType: "#Microsoft.Media.SelectVideoTrackById";
    trackId: number;
}

// @public
export interface ServiceSpecification {
    readonly logSpecifications?: LogSpecification[];
    readonly metricSpecifications?: MetricSpecification[];
}

// @public
export interface StandardEncoderPreset extends Preset {
    codecs: CodecUnion[];
    experimentalOptions?: {
        [propertyName: string]: string;
    };
    filters?: Filters;
    formats: FormatUnion[];
    odataType: "#Microsoft.Media.StandardEncoderPreset";
}

// @public
export interface StorageAccount {
    id?: string;
    identity?: ResourceIdentity;
    readonly status?: string;
    type: StorageAccountType;
}

// @public
export type StorageAccountType = string;

// @public
export type StorageAuthentication = string;

// @public
export interface StorageEncryptedAssetDecryptionData {
    assetFileEncryptionMetadata?: AssetFileEncryptionMetadata[];
    key?: Uint8Array;
}

// @public
export interface StreamingEndpoint extends TrackedResource {
    accessControl?: StreamingEndpointAccessControl;
    availabilitySetName?: string;
    cdnEnabled?: boolean;
    cdnProfile?: string;
    cdnProvider?: string;
    readonly created?: Date;
    crossSiteAccessPolicies?: CrossSiteAccessPolicies;
    customHostNames?: string[];
    description?: string;
    readonly freeTrialEndTime?: Date;
    readonly hostName?: string;
    readonly lastModified?: Date;
    maxCacheAge?: number;
    readonly provisioningState?: string;
    readonly resourceState?: StreamingEndpointResourceState;
    scaleUnits?: number;
    sku?: ArmStreamingEndpointCurrentSku;
    readonly systemData?: SystemData;
}

// @public
export interface StreamingEndpointAccessControl {
    akamai?: AkamaiAccessControl;
    ip?: IPAccessControl;
}

// @public
export interface StreamingEndpointListResult {
    odataCount?: number;
    odataNextLink?: string;
    value?: StreamingEndpoint[];
}

// @public
export type StreamingEndpointResourceState = string;

// @public
export interface StreamingEndpoints {
    asyncOperation(resourceGroupName: string, accountName: string, operationId: string, options?: StreamingEndpointsAsyncOperationOptionalParams): Promise<StreamingEndpointsAsyncOperationResponse>;
    beginCreate(resourceGroupName: string, accountName: string, streamingEndpointName: string, parameters: StreamingEndpoint, options?: StreamingEndpointsCreateOptionalParams): Promise<PollerLike<PollOperationState<StreamingEndpointsCreateResponse>, StreamingEndpointsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, accountName: string, streamingEndpointName: string, parameters: StreamingEndpoint, options?: StreamingEndpointsCreateOptionalParams): Promise<StreamingEndpointsCreateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, streamingEndpointName: string, options?: StreamingEndpointsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, streamingEndpointName: string, options?: StreamingEndpointsDeleteOptionalParams): Promise<void>;
    beginScale(resourceGroupName: string, accountName: string, streamingEndpointName: string, parameters: StreamingEntityScaleUnit, options?: StreamingEndpointsScaleOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginScaleAndWait(resourceGroupName: string, accountName: string, streamingEndpointName: string, parameters: StreamingEntityScaleUnit, options?: StreamingEndpointsScaleOptionalParams): Promise<void>;
    beginStart(resourceGroupName: string, accountName: string, streamingEndpointName: string, options?: StreamingEndpointsStartOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginStartAndWait(resourceGroupName: string, accountName: string, streamingEndpointName: string, options?: StreamingEndpointsStartOptionalParams): Promise<void>;
    beginStop(resourceGroupName: string, accountName: string, streamingEndpointName: string, options?: StreamingEndpointsStopOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginStopAndWait(resourceGroupName: string, accountName: string, streamingEndpointName: string, options?: StreamingEndpointsStopOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, accountName: string, streamingEndpointName: string, parameters: StreamingEndpoint, options?: StreamingEndpointsUpdateOptionalParams): Promise<PollerLike<PollOperationState<StreamingEndpointsUpdateResponse>, StreamingEndpointsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, streamingEndpointName: string, parameters: StreamingEndpoint, options?: StreamingEndpointsUpdateOptionalParams): Promise<StreamingEndpointsUpdateResponse>;
    get(resourceGroupName: string, accountName: string, streamingEndpointName: string, options?: StreamingEndpointsGetOptionalParams): Promise<StreamingEndpointsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: StreamingEndpointsListOptionalParams): PagedAsyncIterableIterator<StreamingEndpoint>;
    operationLocation(resourceGroupName: string, accountName: string, streamingEndpointName: string, operationId: string, options?: StreamingEndpointsOperationLocationOptionalParams): Promise<StreamingEndpointsOperationLocationResponse>;
    skus(resourceGroupName: string, accountName: string, streamingEndpointName: string, options?: StreamingEndpointsSkusOptionalParams): Promise<StreamingEndpointsSkusResponse>;
}

// @public
export interface StreamingEndpointsAsyncOperationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingEndpointsAsyncOperationResponse = AsyncOperationResult;

// @public
export interface StreamingEndpointsCreateOptionalParams extends coreClient.OperationOptions {
    autoStart?: boolean;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StreamingEndpointsCreateResponse = StreamingEndpoint;

// @public
export interface StreamingEndpointsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StreamingEndpointsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingEndpointsGetResponse = StreamingEndpoint;

// @public (undocumented)
export interface StreamingEndpointSkuInfoListResult {
    value?: ArmStreamingEndpointSkuInfo[];
}

// @public
export interface StreamingEndpointsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingEndpointsListNextResponse = StreamingEndpointListResult;

// @public
export interface StreamingEndpointsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingEndpointsListResponse = StreamingEndpointListResult;

// @public
export interface StreamingEndpointsOperationLocationOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingEndpointsOperationLocationResponse = StreamingEndpoint;

// @public
export interface StreamingEndpointsScaleOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StreamingEndpointsSkusOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingEndpointsSkusResponse = StreamingEndpointSkuInfoListResult;

// @public
export interface StreamingEndpointsStartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StreamingEndpointsStopOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StreamingEndpointsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StreamingEndpointsUpdateResponse = StreamingEndpoint;

// @public
export interface StreamingEntityScaleUnit {
    scaleUnit?: number;
}

// @public
export interface StreamingLocator extends ProxyResource {
    alternativeMediaId?: string;
    assetName?: string;
    contentKeys?: StreamingLocatorContentKey[];
    readonly created?: Date;
    defaultContentKeyPolicyName?: string;
    endTime?: Date;
    filters?: string[];
    startTime?: Date;
    streamingLocatorId?: string;
    streamingPolicyName?: string;
    readonly systemData?: SystemData;
}

// @public
export interface StreamingLocatorCollection {
    odataNextLink?: string;
    value?: StreamingLocator[];
}

// @public
export interface StreamingLocatorContentKey {
    id: string;
    labelReferenceInStreamingPolicy?: string;
    readonly policyName?: string;
    readonly tracks?: TrackSelection[];
    readonly type?: StreamingLocatorContentKeyType;
    value?: string;
}

// @public
export type StreamingLocatorContentKeyType = string;

// @public
export interface StreamingLocators {
    create(resourceGroupName: string, accountName: string, streamingLocatorName: string, parameters: StreamingLocator, options?: StreamingLocatorsCreateOptionalParams): Promise<StreamingLocatorsCreateResponse>;
    delete(resourceGroupName: string, accountName: string, streamingLocatorName: string, options?: StreamingLocatorsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, streamingLocatorName: string, options?: StreamingLocatorsGetOptionalParams): Promise<StreamingLocatorsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: StreamingLocatorsListOptionalParams): PagedAsyncIterableIterator<StreamingLocator>;
    listContentKeys(resourceGroupName: string, accountName: string, streamingLocatorName: string, options?: StreamingLocatorsListContentKeysOptionalParams): Promise<StreamingLocatorsListContentKeysResponse>;
    listPaths(resourceGroupName: string, accountName: string, streamingLocatorName: string, options?: StreamingLocatorsListPathsOptionalParams): Promise<StreamingLocatorsListPathsResponse>;
}

// @public
export interface StreamingLocatorsCreateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingLocatorsCreateResponse = StreamingLocator;

// @public
export interface StreamingLocatorsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface StreamingLocatorsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingLocatorsGetResponse = StreamingLocator;

// @public
export interface StreamingLocatorsListContentKeysOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingLocatorsListContentKeysResponse = ListContentKeysResponse;

// @public
export interface StreamingLocatorsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingLocatorsListNextResponse = StreamingLocatorCollection;

// @public
export interface StreamingLocatorsListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    orderby?: string;
    top?: number;
}

// @public
export interface StreamingLocatorsListPathsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingLocatorsListPathsResponse = ListPathsResponse;

// @public
export type StreamingLocatorsListResponse = StreamingLocatorCollection;

// @public
export interface StreamingPath {
    encryptionScheme: EncryptionScheme;
    paths?: string[];
    streamingProtocol: StreamingPolicyStreamingProtocol;
}

// @public
export interface StreamingPolicies {
    create(resourceGroupName: string, accountName: string, streamingPolicyName: string, parameters: StreamingPolicy, options?: StreamingPoliciesCreateOptionalParams): Promise<StreamingPoliciesCreateResponse>;
    delete(resourceGroupName: string, accountName: string, streamingPolicyName: string, options?: StreamingPoliciesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, streamingPolicyName: string, options?: StreamingPoliciesGetOptionalParams): Promise<StreamingPoliciesGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: StreamingPoliciesListOptionalParams): PagedAsyncIterableIterator<StreamingPolicy>;
}

// @public
export interface StreamingPoliciesCreateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingPoliciesCreateResponse = StreamingPolicy;

// @public
export interface StreamingPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface StreamingPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingPoliciesGetResponse = StreamingPolicy;

// @public
export interface StreamingPoliciesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StreamingPoliciesListNextResponse = StreamingPolicyCollection;

// @public
export interface StreamingPoliciesListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    orderby?: string;
    top?: number;
}

// @public
export type StreamingPoliciesListResponse = StreamingPolicyCollection;

// @public
export interface StreamingPolicy extends ProxyResource {
    commonEncryptionCbcs?: CommonEncryptionCbcs;
    commonEncryptionCenc?: CommonEncryptionCenc;
    readonly created?: Date;
    defaultContentKeyPolicyName?: string;
    envelopeEncryption?: EnvelopeEncryption;
    noEncryption?: NoEncryption;
    readonly systemData?: SystemData;
}

// @public
export interface StreamingPolicyCollection {
    odataNextLink?: string;
    value?: StreamingPolicy[];
}

// @public
export interface StreamingPolicyContentKey {
    label?: string;
    policyName?: string;
    tracks?: TrackSelection[];
}

// @public
export interface StreamingPolicyContentKeys {
    defaultKey?: DefaultKey;
    keyToTrackMappings?: StreamingPolicyContentKey[];
}

// @public
export interface StreamingPolicyFairPlayConfiguration {
    allowPersistentLicense: boolean;
    customLicenseAcquisitionUrlTemplate?: string;
}

// @public
export interface StreamingPolicyPlayReadyConfiguration {
    customLicenseAcquisitionUrlTemplate?: string;
    playReadyCustomAttributes?: string;
}

// @public
export type StreamingPolicyStreamingProtocol = string;

// @public
export interface StreamingPolicyWidevineConfiguration {
    customLicenseAcquisitionUrlTemplate?: string;
}

// @public
export type StreamOptionsFlag = string;

// @public
export type StretchMode = string;

// @public
export interface SyncStorageKeysInput {
    id?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
interface TextTrack_2 extends TrackBase {
    displayName?: string;
    fileName?: string;
    hlsSettings?: HlsSettings;
    readonly languageCode?: string;
    odataType: "#Microsoft.Media.TextTrack";
    playerVisibility?: Visibility;
}
export { TextTrack_2 as TextTrack }

// @public
export type TrackAttribute = string;

// @public
export interface TrackBase {
    odataType: "#Microsoft.Media.AudioTrack" | "#Microsoft.Media.VideoTrack" | "#Microsoft.Media.TextTrack";
}

// @public (undocumented)
export type TrackBaseUnion = TrackBase | AudioTrack | VideoTrack | TextTrack_2;

// @public
export interface TrackDescriptor {
    odataType: "#Microsoft.Media.AudioTrackDescriptor" | "#Microsoft.Media.SelectAudioTrackByAttribute" | "#Microsoft.Media.SelectAudioTrackById" | "#Microsoft.Media.VideoTrackDescriptor" | "#Microsoft.Media.SelectVideoTrackByAttribute" | "#Microsoft.Media.SelectVideoTrackById";
}

// @public (undocumented)
export type TrackDescriptorUnion = TrackDescriptor | AudioTrackDescriptorUnion | VideoTrackDescriptorUnion;

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type TrackPropertyCompareOperation = string;

// @public
export interface TrackPropertyCondition {
    operation: TrackPropertyCompareOperation;
    property: TrackPropertyType;
    value?: string;
}

// @public
export type TrackPropertyType = string;

// @public
export interface Tracks {
    beginCreateOrUpdate(resourceGroupName: string, accountName: string, assetName: string, trackName: string, parameters: AssetTrack, options?: TracksCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<TracksCreateOrUpdateResponse>, TracksCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, accountName: string, assetName: string, trackName: string, parameters: AssetTrack, options?: TracksCreateOrUpdateOptionalParams): Promise<TracksCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, accountName: string, assetName: string, trackName: string, options?: TracksDeleteOptionalParams): Promise<PollerLike<PollOperationState<TracksDeleteResponse>, TracksDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, accountName: string, assetName: string, trackName: string, options?: TracksDeleteOptionalParams): Promise<TracksDeleteResponse>;
    beginUpdate(resourceGroupName: string, accountName: string, assetName: string, trackName: string, parameters: AssetTrack, options?: TracksUpdateOptionalParams): Promise<PollerLike<PollOperationState<TracksUpdateResponse>, TracksUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, accountName: string, assetName: string, trackName: string, parameters: AssetTrack, options?: TracksUpdateOptionalParams): Promise<TracksUpdateResponse>;
    beginUpdateTrackData(resourceGroupName: string, accountName: string, assetName: string, trackName: string, options?: TracksUpdateTrackDataOptionalParams): Promise<PollerLike<PollOperationState<TracksUpdateTrackDataResponse>, TracksUpdateTrackDataResponse>>;
    beginUpdateTrackDataAndWait(resourceGroupName: string, accountName: string, assetName: string, trackName: string, options?: TracksUpdateTrackDataOptionalParams): Promise<TracksUpdateTrackDataResponse>;
    get(resourceGroupName: string, accountName: string, assetName: string, trackName: string, options?: TracksGetOptionalParams): Promise<TracksGetResponse>;
    list(resourceGroupName: string, accountName: string, assetName: string, options?: TracksListOptionalParams): PagedAsyncIterableIterator<AssetTrack>;
}

// @public
export interface TracksCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
    retryAfter?: number;
}

// @public
export interface TracksCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TracksCreateOrUpdateResponse = TracksCreateOrUpdateHeaders & AssetTrack;

// @public
export interface TracksDeleteHeaders {
    azureAsyncOperation?: string;
    location?: string;
    retryAfter?: number;
}

// @public
export interface TracksDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TracksDeleteResponse = TracksDeleteHeaders;

// @public
export interface TrackSelection {
    trackSelections?: TrackPropertyCondition[];
}

// @public
export interface TracksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TracksGetResponse = AssetTrack;

// @public
export interface TracksListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TracksListResponse = AssetTrackCollection;

// @public
export interface TracksUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
    retryAfter?: number;
}

// @public
export interface TracksUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TracksUpdateResponse = TracksUpdateHeaders & AssetTrack;

// @public
export interface TracksUpdateTrackDataHeaders {
    azureAsyncOperation?: string;
    location?: string;
    retryAfter?: number;
}

// @public
export interface TracksUpdateTrackDataOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TracksUpdateTrackDataResponse = TracksUpdateTrackDataHeaders;

// @public
export interface Transform extends ProxyResource {
    readonly created?: Date;
    description?: string;
    readonly lastModified?: Date;
    outputs?: TransformOutput[];
    readonly systemData?: SystemData;
}

// @public
export interface TransformCollection {
    odataNextLink?: string;
    value?: Transform[];
}

// @public
export interface TransformOutput {
    onError?: OnErrorType;
    preset: PresetUnion;
    relativePriority?: Priority;
}

// @public
export interface Transforms {
    createOrUpdate(resourceGroupName: string, accountName: string, transformName: string, parameters: Transform, options?: TransformsCreateOrUpdateOptionalParams): Promise<TransformsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, accountName: string, transformName: string, options?: TransformsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, accountName: string, transformName: string, options?: TransformsGetOptionalParams): Promise<TransformsGetResponse>;
    list(resourceGroupName: string, accountName: string, options?: TransformsListOptionalParams): PagedAsyncIterableIterator<Transform>;
    update(resourceGroupName: string, accountName: string, transformName: string, parameters: Transform, options?: TransformsUpdateOptionalParams): Promise<TransformsUpdateResponse>;
}

// @public
export interface TransformsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TransformsCreateOrUpdateResponse = Transform;

// @public
export interface TransformsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface TransformsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TransformsGetResponse = Transform;

// @public
export interface TransformsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TransformsListNextResponse = TransformCollection;

// @public
export interface TransformsListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    orderby?: string;
}

// @public
export type TransformsListResponse = TransformCollection;

// @public
export interface TransformsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TransformsUpdateResponse = Transform;

// @public
export interface TransportStreamFormat extends MultiBitrateFormat {
    odataType: "#Microsoft.Media.TransportStreamFormat";
}

// @public (undocumented)
export interface UserAssignedManagedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface UtcClipTime extends ClipTime {
    odataType: "#Microsoft.Media.UtcClipTime";
    time: Date;
}

// @public
export interface Video extends Codec {
    keyFrameInterval?: string;
    odataType: "#Microsoft.Media.Video" | "#Microsoft.Media.H265Video" | "#Microsoft.Media.Image" | "#Microsoft.Media.H264Video" | "#Microsoft.Media.JpgImage" | "#Microsoft.Media.PngImage";
    stretchMode?: StretchMode;
    syncMode?: VideoSyncMode;
}

// @public
export interface VideoAnalyzerPreset extends AudioAnalyzerPreset {
    insightsToExtract?: InsightsType;
    odataType: "#Microsoft.Media.VideoAnalyzerPreset";
}

// @public
export interface VideoLayer extends Layer {
    adaptiveBFrame?: boolean;
    bFrames?: number;
    bitrate: number;
    frameRate?: string;
    maxBitrate?: number;
    slices?: number;
}

// @public
export interface VideoOverlay extends Overlay {
    cropRectangle?: Rectangle;
    odataType: "#Microsoft.Media.VideoOverlay";
    opacity?: number;
    position?: Rectangle;
}

// @public
export type VideoSyncMode = string;

// @public
export interface VideoTrack extends TrackBase {
    odataType: "#Microsoft.Media.VideoTrack";
}

// @public
export interface VideoTrackDescriptor extends TrackDescriptor {
    odataType: "#Microsoft.Media.VideoTrackDescriptor" | "#Microsoft.Media.SelectVideoTrackByAttribute" | "#Microsoft.Media.SelectVideoTrackById";
}

// @public (undocumented)
export type VideoTrackDescriptorUnion = VideoTrackDescriptor | SelectVideoTrackByAttribute | SelectVideoTrackById;

// @public (undocumented)
export type VideoUnion = Video | H265Video | ImageUnion | H264Video;

// @public
export type Visibility = string;

// (No @packageDocumentation comment for this package)

```
