{"version":3,"file":"instrumentServiceBusMessage.js","sourceRoot":"","sources":["../../../src/diagnostics/instrumentServiceBusMessage.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { TracingContext, TracingSpanLink, TracingSpanOptions } from \"@azure/core-tracing\";\nimport type { ConnectionContext } from \"../connectionContext.js\";\nimport type { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs.js\";\nimport type { ServiceBusReceiver } from \"../receivers/receiver.js\";\nimport type { ServiceBusMessage, ServiceBusReceivedMessage } from \"../serviceBusMessage.js\";\nimport type { MessagingOperationNames } from \"./tracing.js\";\nimport { toSpanOptions, tracingClient } from \"./tracing.js\";\n\n/**\n * @internal\n */\nexport const TRACEPARENT_PROPERTY = \"Diagnostic-Id\";\n\n/**\n * @hidden\n */\nexport interface InstrumentableMessage {\n  /**\n   * The application specific properties which can be\n   * used for custom message metadata.\n   */\n  applicationProperties?: { [key: string]: number | boolean | string | Date | null };\n}\n\n/**\n * Instruments an AMQP message with a proper `Diagnostic-Id` for tracing.\n *\n * @hidden\n */\nexport function instrumentMessage<T extends InstrumentableMessage>(\n  message: T,\n  options: OperationOptionsBase,\n  entityPath: string,\n  host: string,\n  operation: MessagingOperationNames,\n): {\n  /**\n   * If instrumentation was done, a copy of the message with\n   * message.applicationProperties['Diagnostic-Id'] filled\n   * out appropriately.\n   */\n  message: T;\n\n  /**\n   * A valid SpanContext if this message should be linked to a parent span, or undefined otherwise.\n   */\n  spanContext: TracingContext | undefined;\n} {\n  // check if the event has already been instrumented\n  const previouslyInstrumented = Boolean(message.applicationProperties?.[TRACEPARENT_PROPERTY]);\n\n  if (previouslyInstrumented) {\n    return {\n      message,\n      spanContext: undefined,\n    };\n  }\n\n  const { span: messageSpan, updatedOptions } = tracingClient.startSpan(\n    \"message\",\n    options,\n    toSpanOptions({ entityPath, host }, operation, \"producer\"),\n  );\n\n  try {\n    if (!messageSpan.isRecording()) {\n      return {\n        message,\n        spanContext: undefined,\n      };\n    }\n\n    const traceParent = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions?.tracingContext,\n    )[\"traceparent\"];\n\n    if (traceParent) {\n      // create a copy so the original isn't modified\n      message = {\n        ...message,\n        applicationProperties: {\n          ...message.applicationProperties,\n          [TRACEPARENT_PROPERTY]: traceParent,\n        },\n      };\n    }\n\n    return {\n      message,\n      spanContext: updatedOptions.tracingOptions?.tracingContext,\n    };\n  } finally {\n    messageSpan.end();\n  }\n}\n\n/**\n * Extracts the `SpanContext` from an `ServiceBusMessage` if the context exists.\n * @param message - An individual `ServiceBusMessage` object.\n * @internal\n */\nexport function extractSpanContextFromServiceBusMessage(\n  message: ServiceBusMessage,\n): TracingContext | undefined {\n  if (!message.applicationProperties || !message.applicationProperties[TRACEPARENT_PROPERTY]) {\n    return;\n  }\n\n  const diagnosticId = message.applicationProperties[TRACEPARENT_PROPERTY] as string;\n  return tracingClient.parseTraceparentHeader(diagnosticId);\n}\n\n/**\n * Provides an iterable over messages, whether it is a single message or multiple\n * messages.\n *\n * @param receivedMessages - A single message or a set of messages\n * @internal\n */\nfunction* getReceivedMessages(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n): Iterable<ServiceBusReceivedMessage> {\n  if (!Array.isArray(receivedMessages)) {\n    yield receivedMessages;\n  } else {\n    for (const message of receivedMessages) {\n      yield message;\n    }\n  }\n}\n\n/**\n * @internal\n */\nexport function toProcessingSpanOptions(\n  receivedMessages: ServiceBusReceivedMessage | ServiceBusReceivedMessage[],\n  receiver: Pick<ServiceBusReceiver, \"entityPath\">,\n  connectionConfig: Pick<ConnectionContext[\"config\"], \"host\">,\n  operation: MessagingOperationNames,\n): TracingSpanOptions {\n  const spanLinks: TracingSpanLink[] = [];\n  for (const receivedMessage of getReceivedMessages(receivedMessages)) {\n    const tracingContext = extractSpanContextFromServiceBusMessage(receivedMessage);\n    if (tracingContext) {\n      spanLinks.push({\n        tracingContext,\n        attributes: {\n          enqueuedTime: receivedMessage.enqueuedTimeUtc?.getTime(),\n        },\n      });\n    }\n  }\n  return {\n    spanLinks,\n    spanKind: \"consumer\",\n    ...toSpanOptions({ host: connectionConfig.host, entityPath: receiver.entityPath }, operation),\n  };\n}\n"]}