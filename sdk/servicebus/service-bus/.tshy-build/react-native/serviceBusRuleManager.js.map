{"version":3,"file":"serviceBusRuleManager.js","sourceRoot":"","sources":["../../src/serviceBusRuleManager.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAKlC,OAAO,EAAE,kBAAkB,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAC;AAE7D,OAAO,EAAE,iBAAiB,IAAI,MAAM,EAAE,MAAM,UAAU,CAAC;AAEvD,OAAO,EAAE,eAAe,EAAE,MAAM,yCAAyC,CAAC;AAC1E,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAChD,OAAO,EAAE,4BAA4B,EAAE,MAAM,kBAAkB,CAAC;AAEhE,OAAO,EAAE,aAAa,EAAE,MAAM,0BAA0B,CAAC;AAEzD,OAAO,EAAE,qBAAqB,EAAE,MAAM,oBAAoB,CAAC;AAoD3D;;GAEG;AACH,MAAM,OAAO,yBAAyB;IAQpC;;;OAGG;IACH,YACU,QAA2B,EAC3B,WAAmB,EACnB,gBAA8B,EAAE;QAFhC,aAAQ,GAAR,QAAQ,CAAmB;QAC3B,gBAAW,GAAX,WAAW,CAAQ;QACnB,kBAAa,GAAb,aAAa,CAAmB;QAd1C;;WAEG;QACK,cAAS,GAAY,KAAK,CAAC;QAajC,4BAA4B,CAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC;QAC9B,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,aAAa,CAAC,CAAC;IAC3C,CAAC;IAED,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,QAAQ,CAAC,wBAAwB,CAAC;IAClE,CAAC;IA4BD,KAAK,CAAC,UAAU,CACd,QAAgB,EAChB,MAA6C,EAC7C,4BAAmE,EACnE,UAA4B,EAAE;QAE9B,IAAI,aAAa,GAA8B,SAAS,CAAC;QACzD,IAAI,WAAyC,CAAC;QAC9C,IAAI,4BAA4B,EAAE,CAAC;YACjC,IAAI,eAAe,CAAC,4BAA4B,CAAC,EAAE,CAAC;gBAClD,oEAAoE;gBACpE,aAAa,GAAG,4BAA4B,CAAC;gBAC7C,WAAW,GAAG,OAAO,CAAC;YACxB,CAAC;iBAAM,CAAC;gBACN,sEAAsE;gBACtE,WAAW,mCAAQ,4BAA4B,GAAK,OAAO,CAAE,CAAC;YAChE,CAAC;QACH,CAAC;QAED,OAAO,aAAa,CAAC,QAAQ,CAC3B,kCAAkC,EAClC,WAAW,aAAX,WAAW,cAAX,WAAW,GAAI,EAAE,EACjB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,uBAAuB,GAAG,KAAK,IAAmB,EAAE;gBACxD,OAAO,IAAI,CAAC,QAAQ;qBACjB,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC;qBACrC,OAAO,CAAC,QAAQ,EAAE,MAAM,EAAE,aAAa,aAAb,aAAa,uBAAb,aAAa,CAAE,aAAa,kCAClD,cAAc,KACjB,kBAAkB,EAAE,IAAI,CAAC,IAAI,EAC7B,WAAW,EAAE,SAAS,EACtB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;YACP,CAAC,CAAC;YACF,MAAM,MAAM,GAAsB;gBAChC,SAAS,EAAE,uBAAuB;gBAClC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAE,kBAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,WAAW;aACzC,CAAC;YACF,OAAO,KAAK,CAAO,MAAM,CAAC,CAAC;QAC7B,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,QAAQ,CACpB,OAA+C;QAE/C,OAAO,aAAa,CAAC,QAAQ,CAC3B,gCAAgC,EAChC,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,EACb,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,wBAAwB,GAAG,KAAK,IAA+B,EAAE;gBACrE,OAAO,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,QAAQ,iCAC9D,cAAc,KACjB,kBAAkB,EAAE,IAAI,CAAC,IAAI,EAC7B,WAAW,EAAE,UAAU,EACvB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;YACL,CAAC,CAAC;YACF,MAAM,MAAM,GAAkC;gBAC5C,SAAS,EAAE,wBAAwB;gBACnC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAE,kBAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,WAAW;aACzC,CAAC;YACF,OAAO,KAAK,CAAmB,MAAM,CAAC,CAAC;QACzC,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACI,SAAS,CACd,OAA0B;QAE1B,MAAM,CAAC,OAAO,CAAC,qDAAqD,EAAE,OAAO,CAAC,CAAC;QAC/E,MAAM,WAAW,GAAoE;YACnF,aAAa,EAAE,CAAC;YAChB,OAAO,EAAE,KAAK,EAAE,QAAQ,EAAE,WAAW,EAAE,EAAE;gBACvC,MAAM,GAAG,GAAG,WAAW,aAAX,WAAW,cAAX,WAAW,GAAI,GAAG,CAAC;gBAC/B,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,QAAQ,iBAC/B,IAAI,EAAE,QAAQ,EACd,QAAQ,EAAE,GAAG,IACV,OAAO,EACV,CAAC;gBACH,OAAO,KAAK,CAAC,MAAM;oBACjB,CAAC,CAAC;wBACE,IAAI,EAAE,KAAK;wBACX,YAAY,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;qBACrE;oBACH,CAAC,CAAC,SAAS,CAAC;YAChB,CAAC;SACF,CAAC;QAEF,OAAO,qBAAqB,CAAC,WAAW,CAAC,CAAC;IAC5C,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,UAAU,CAAC,QAAgB,EAAE,UAA4B,EAAE;QAC/D,OAAO,aAAa,CAAC,QAAQ,CAC3B,kCAAkC,EAClC,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,0BAA0B,GAAG,KAAK,IAAmB,EAAE;gBAC3D,OAAO,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,UAAU,CAAC,QAAQ,kCACzE,cAAc,KACjB,kBAAkB,EAAE,IAAI,CAAC,IAAI,EAC7B,WAAW,EAAE,YAAY,EACzB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;YACL,CAAC,CAAC;YACF,MAAM,MAAM,GAAsB;gBAChC,SAAS,EAAE,0BAA0B;gBACrC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAE,kBAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,WAAW;aACzC,CAAC;YACF,OAAO,KAAK,CAAO,MAAM,CAAC,CAAC;QAC7B,CAAC,CACF,CAAC;IACJ,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { OperationOptionsBase } from \"./modelsToBeSharedWithEventHubs.js\";\nimport type { ConnectionContext } from \"./connectionContext.js\";\nimport type { RetryConfig, RetryOptions } from \"@azure/core-amqp\";\nimport { RetryOperationType, retry } from \"@azure/core-amqp\";\nimport type { CorrelationRuleFilter } from \"./core/managementClient.js\";\nimport { ruleManagerLogger as logger } from \"./log.js\";\nimport type { RuleProperties, SqlRuleAction } from \"./serializers/ruleResourceSerializer.js\";\nimport { isSqlRuleAction } from \"./serializers/ruleResourceSerializer.js\";\nimport { getUniqueName } from \"./util/utils.js\";\nimport { throwErrorIfConnectionClosed } from \"./util/errors.js\";\nimport type { SqlRuleFilter } from \"./serializers/ruleResourceSerializer.js\";\nimport { tracingClient } from \"./diagnostics/tracing.js\";\nimport type { PagedAsyncIterableIterator, PagedResult } from \"@azure/core-paging\";\nimport { getPagedAsyncIterator } from \"@azure/core-paging\";\nimport type { OperationOptions } from \"@azure/core-client\";\nimport type { ListRequestOptions } from \"./serviceBusAtomManagementClient.js\";\n\n/**\n * Allows rules for a subscription to be managed. This rule manager requires only Listen claims, whereas the\n * {@link ServiceBusAdministrationClient} requires Manage claims.\n */\nexport interface ServiceBusRuleManager {\n  /**\n   * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.\n   *\n   * @param ruleName - the name of the rule\n   * @param filter - the filter expression that the rule evaluates.\n   * @param options - The options that can be used to abort, trace and control other configurations on the request.\n   */\n  createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    options?: OperationOptionsBase,\n  ): Promise<void>;\n  /**\n   * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.\n   *\n   * @param ruleName - the name of the rule\n   * @param filter - the filter expression that the rule evaluates.\n   * @param ruleAction - The SQL like expression that can be executed on the message should the associated filter apply.\n   * @param options - The options that can be used to abort, trace and control other configurations on the request.\n   */\n  createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleAction?: SqlRuleAction,\n    options?: OperationOptionsBase,\n  ): Promise<void>;\n  /**\n   * Deletes a rule.\n   *\n   * @param ruleName - the name of the rule\n   */\n  deleteRule(ruleName: string, options?: OperationOptionsBase): Promise<void>;\n  /**\n   * Returns an async iterable iterator to list all the rules\n   * under the specified subscription.\n   *\n   * .byPage() returns an async iterable iterator to list the rules in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  listRules(options?: OperationOptions): PagedAsyncIterableIterator<RuleProperties>;\n}\n\n/**\n * @internal\n */\nexport class ServiceBusRuleManagerImpl implements ServiceBusRuleManager {\n  /**\n   * Denotes if close() was called on this sender\n   */\n  private _isClosed: boolean = false;\n  private name: string;\n  public entityPath: string;\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   */\n  constructor(\n    private _context: ConnectionContext,\n    private _entityPath: string,\n    private _retryOptions: RetryOptions = {},\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this.entityPath = _entityPath;\n    this.name = getUniqueName(\"ruleManager\");\n  }\n\n  public get isClosed(): boolean {\n    return this._isClosed || this._context.wasConnectionCloseCalled;\n  }\n\n  /**\n   * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.\n   *\n   * @param ruleName - the name of the rule\n   * @param filter - the filter expression that the rule evaluates.\n   * @param options - The options that can be used to abort, trace and control other configurations on the request.\n   */\n  createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    options?: OperationOptions,\n  ): Promise<void>;\n  /**\n   * Adds a rule to the current subscription to filter the messages reaching from topic to the subscription.\n   *\n   * @param ruleName - the name of the rule\n   * @param filter - the filter expression that the rule evaluates.\n   * @param ruleAction - The SQL like expression that can be executed on the message should the associated filter apply.\n   * @param options - The options that can be used to abort, trace and control other configurations on the request.\n   */\n  createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleAction?: SqlRuleAction,\n    options?: OperationOptions,\n  ): Promise<void>;\n  async createRule(\n    ruleName: string,\n    filter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleActionOrOperationOptions?: SqlRuleAction | OperationOptionsBase,\n    options: OperationOptions = {},\n  ): Promise<void> {\n    let sqlRuleAction: SqlRuleAction | undefined = undefined;\n    let operOptions: OperationOptions | undefined;\n    if (ruleActionOrOperationOptions) {\n      if (isSqlRuleAction(ruleActionOrOperationOptions)) {\n        // Overload#2 - where the sqlExpression in the ruleAction is defined\n        sqlRuleAction = ruleActionOrOperationOptions;\n        operOptions = options;\n      } else {\n        // Overload#1 - where the sqlExpression in the ruleAction is undefined\n        operOptions = { ...ruleActionOrOperationOptions, ...options };\n      }\n    }\n\n    return tracingClient.withSpan(\n      \"ServiceBusRuleManager.createRule\",\n      operOptions ?? {},\n      async (updatedOptions) => {\n        const addRuleOperationPromise = async (): Promise<void> => {\n          return this._context\n            .getManagementClient(this._entityPath)\n            .addRule(ruleName, filter, sqlRuleAction?.sqlExpression, {\n              ...updatedOptions,\n              associatedLinkName: this.name,\n              requestName: \"addRule\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n        };\n        const config: RetryConfig<void> = {\n          operation: addRuleOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: updatedOptions?.abortSignal,\n        };\n        return retry<void>(config);\n      },\n    );\n  }\n\n  /**\n   * Get all rules associated with the subscription.\n   */\n  private async getRules(\n    options?: ListRequestOptions & OperationOptions,\n  ): Promise<RuleProperties[]> {\n    return tracingClient.withSpan(\n      \"ServiceBusRuleManager.getRules\",\n      options ?? {},\n      async (updatedOptions) => {\n        const getRulesOperationPromise = async (): Promise<RuleProperties[]> => {\n          return this._context.getManagementClient(this._entityPath).getRules({\n            ...updatedOptions,\n            associatedLinkName: this.name,\n            requestName: \"getRules\",\n            timeoutInMs: this._retryOptions.timeoutInMs,\n          });\n        };\n        const config: RetryConfig<RuleProperties[]> = {\n          operation: getRulesOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: updatedOptions?.abortSignal,\n        };\n        return retry<RuleProperties[]>(config);\n      },\n    );\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the rules\n   * under the specified subscription.\n   *\n   * .byPage() returns an async iterable iterator to list the rules in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listRules(\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<RuleProperties, RuleProperties[], { maxPageSize?: number }> {\n    logger.verbose(`Performing operation - listRules() with options: %j`, options);\n    const pagedResult: PagedResult<RuleProperties[], { maxPageSize?: number }, number> = {\n      firstPageLink: 0,\n      getPage: async (pageLink, maxPageSize) => {\n        const top = maxPageSize ?? 100;\n        const rules = await this.getRules({\n          skip: pageLink,\n          maxCount: top,\n          ...options,\n        });\n        return rules.length\n          ? {\n              page: rules,\n              nextPageLink: rules.length > 0 ? pageLink + rules.length : undefined,\n            }\n          : undefined;\n      },\n    };\n\n    return getPagedAsyncIterator(pagedResult);\n  }\n\n  /**\n   * Deletes a rule.\n   */\n  async deleteRule(ruleName: string, options: OperationOptions = {}): Promise<void> {\n    return tracingClient.withSpan(\n      \"ServiceBusRuleManager.deleteRule\",\n      options,\n      async (updatedOptions) => {\n        const removeRuleOperationPromise = async (): Promise<void> => {\n          return this._context.getManagementClient(this._entityPath).removeRule(ruleName, {\n            ...updatedOptions,\n            associatedLinkName: this.name,\n            requestName: \"removeRule\",\n            timeoutInMs: this._retryOptions.timeoutInMs,\n          });\n        };\n        const config: RetryConfig<void> = {\n          operation: removeRuleOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: updatedOptions?.abortSignal,\n        };\n        return retry<void>(config);\n      },\n    );\n  }\n}\n"]}