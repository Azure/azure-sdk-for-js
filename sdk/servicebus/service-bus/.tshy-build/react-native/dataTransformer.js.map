{"version":3,"file":"dataTransformer.js","sourceRoot":"","sources":["../../src/dataTransformer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { message } from \"rhea-promise\";\nimport isBuffer from \"is-buffer\";\nimport { Buffer } from \"buffer\";\nimport { logErrorStackTrace, logger } from \"./log.js\";\n\n/** @internal */\nexport const dataSectionTypeCode = 0x75 as const;\n/** @internal */\nexport const sequenceSectionTypeCode = 0x76 as const;\n/** @internal */\nexport const valueSectionTypeCode = 0x77 as const;\n\n/**\n * Mirror of the internal Section interface in rhea.\n *\n * @internal\n */\nexport interface RheaAmqpSection {\n  typecode:\n    | typeof dataSectionTypeCode\n    | typeof sequenceSectionTypeCode\n    | typeof valueSectionTypeCode;\n  content: any;\n}\n\n/**\n * The default data transformer that will be used by the Azure SDK.\n * @internal\n */\nexport const defaultDataTransformer = {\n  /**\n   * A function that takes the body property from an EventData object\n   * and returns an encoded body (some form of AMQP type).\n   *\n   * @param body - The AMQP message body\n   * @returns The encoded AMQP message body as an AMQP Data type\n   * (data section in rhea terms). Section object with following properties:\n   * - typecode: 117 (0x75)\n   * - content: The given AMQP message body as a Buffer.\n   * - multiple: true | undefined.\n   */\n  encode(body: unknown, bodyType: \"data\" | \"value\" | \"sequence\"): any {\n    let result: any;\n    if (bodyType === \"value\") {\n      // TODO: Expose value_section from `rhea` similar to the data_section and sequence_section. Right now there isn't a way to create a value section officially.\n      result = message.data_section(body);\n      result.typecode = valueSectionTypeCode;\n    } else if (bodyType === \"sequence\") {\n      result = message.sequence_section(body);\n    } else if (isBuffer(body) || body instanceof Uint8Array) {\n      result = message.data_section(body);\n    } else {\n      // string, undefined, null, boolean, array, object, number should end up here\n      // coercing undefined to null as that will ensure that null value will be given to the\n      // customer on receive.\n      if (body === undefined) body = null; // tslint:disable-line\n      try {\n        const bodyStr = JSON.stringify(body);\n        result = message.data_section(Buffer.from(bodyStr, \"utf8\"));\n      } catch (err: any) {\n        const msg =\n          `An error occurred while executing JSON.stringify() on the given body ` +\n          body +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        logger.warning(\"[encode] \" + msg);\n        logErrorStackTrace(logger, err);\n        throw new Error(msg);\n      }\n    }\n    return result;\n  },\n  /**\n   * A function that takes the body property from an AMQP message\n   * (an AMQP Data type (data section in rhea terms)) and returns the decoded message body.\n   * If it cannot decode the body then it returns the body\n   * as-is.\n   *\n   * NOTE: Use this to decode a message body when you know that the entire contents are _only_ contained\n   * in the 'data' section of the message (for instance, messages from the $mgmt link). Otherwise\n   * use 'defaultDataTransformer.decodeWithType', which can handle data coming from separate sections\n   * of the AMQP mesage.\n   *\n   * @param body - The AMQP message body\n   * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body content.\n   * @returns decoded body or the given body as-is.\n   */\n  decode(body: unknown, skipParsingBodyAsJson: boolean): unknown {\n    let actualContent = body;\n\n    if (isRheaAmqpSection(body)) {\n      actualContent = body.content;\n    }\n\n    return skipParsingBodyAsJson ? actualContent : tryToJsonDecode(actualContent);\n  },\n  /**\n   * A function that takes the body property from an AMQP message, which can come from either\n   * the 'data', 'value' or 'sequence' sections of an AMQP message.\n   *\n   * If the body is not a JSON string the the raw contents will be returned, along with the bodyType\n   * indicating which part of the AMQP message the body was decoded from.\n   *\n   * @param body - The AMQP message body as received from rhea.\n   * @param skipParsingBodyAsJson - Boolean to skip running JSON.parse() on message body.\n   * @returns The decoded/raw body and the body type.\n   */\n  decodeWithType(\n    body: unknown | RheaAmqpSection,\n    skipParsingBodyAsJson: boolean,\n  ): { body: unknown; bodyType: \"data\" | \"sequence\" | \"value\" } {\n    try {\n      if (isRheaAmqpSection(body)) {\n        switch (body.typecode) {\n          case dataSectionTypeCode:\n            return {\n              body: skipParsingBodyAsJson ? body.content : tryToJsonDecode(body.content),\n              bodyType: \"data\",\n            };\n          case sequenceSectionTypeCode:\n            // typecode:\n            // handle sequences\n            return { body: body.content, bodyType: \"sequence\" };\n          case valueSectionTypeCode:\n            // value\n            return { body: body.content, bodyType: \"value\" };\n        }\n      } else {\n        // not sure - we have to try to infer the proper bodyType and content\n        if (isBuffer(body)) {\n          // This indicates that we are getting the AMQP described type. Let us try decoding it.\n          return { body: skipParsingBodyAsJson ? body : tryToJsonDecode(body), bodyType: \"data\" };\n        } else {\n          return { body: body, bodyType: \"value\" };\n        }\n      }\n    } catch (err: any) {\n      logger.verbose(\n        \"[decode] An error occurred while decoding the received message body. The error is: %O\",\n        err,\n      );\n      throw err;\n    }\n  },\n};\n\n/** @internal */\nexport function isRheaAmqpSection(\n  possibleSection: any | RheaAmqpSection,\n): possibleSection is RheaAmqpSection {\n  return (\n    possibleSection != null &&\n    typeof possibleSection.typecode === \"number\" &&\n    (possibleSection.typecode === dataSectionTypeCode ||\n      possibleSection.typecode === valueSectionTypeCode ||\n      possibleSection.typecode === sequenceSectionTypeCode)\n  );\n}\n\n/**\n * Attempts to decode 'body' as a JSON string. If it fails it returns body\n * verbatim.\n *\n * @param body - An AMQP message body.\n * @returns A JSON decoded object, or body if body was not a JSON string.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function tryToJsonDecode(body: any): any {\n  let processedBody = body;\n  try {\n    // Trying to stringify and JSON.parse() anything else will fail flat and we shall return\n    // the original type back\n    const bodyStr: string = processedBody.toString(\"utf8\");\n    processedBody = JSON.parse(bodyStr);\n  } catch (err: any) {\n    logger.verbose(\n      \"[decode] An error occurred while trying JSON.parse() on the received body. \" +\n        \"The error is %O\",\n      err,\n    );\n  }\n  return processedBody;\n}\n"]}