{"version":3,"file":"serviceBusMessageBatch.js","sourceRoot":"","sources":["../../src/serviceBusMessageBatch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { ServiceBusMessage } from \"./serviceBusMessage.js\";\nimport { toRheaMessage } from \"./serviceBusMessage.js\";\nimport {\n  errorInvalidMessageTypeSingle,\n  throwIfNotValidServiceBusMessage,\n  throwTypeErrorIfParameterMissing,\n} from \"./util/errors.js\";\nimport type { ConnectionContext } from \"./connectionContext.js\";\nimport type { MessageAnnotations, Message as RheaMessage } from \"rhea-promise\";\nimport {\n  messageProperties as RheaMessagePropertiesList,\n  message as RheaMessageUtil,\n} from \"rhea-promise\";\nimport type { TracingContext } from \"@azure/core-tracing\";\nimport type { TryAddOptions } from \"./modelsToBeSharedWithEventHubs.js\";\nimport type { AmqpAnnotatedMessage } from \"@azure/core-amqp\";\nimport { defaultDataTransformer } from \"./dataTransformer.js\";\nimport { instrumentMessage } from \"./diagnostics/instrumentServiceBusMessage.js\";\n\n/**\n * @internal\n * The amount of bytes to reserve as overhead for a small message.\n */\nconst smallMessageOverhead = 5;\n/**\n * @internal\n * The amount of bytes to reserve as overhead for a large message.\n */\nconst largeMessageOverhead = 8;\n/**\n * @internal\n * The maximum number of bytes that a message may be to be considered small.\n */\nconst smallMessageMaxBytes = 255;\n\n/**\n * A batch of messages that you can create using the {@link createBatch} method.\n *\n */\nexport interface ServiceBusMessageBatch {\n  /**\n   * Size of the batch in bytes after the events added to it have been encoded into a single AMQP\n   * message.\n   * @readonly\n   */\n  readonly sizeInBytes: number;\n\n  /**\n   * Number of messages added to the batch.\n   * @readonly\n   */\n  readonly count: number;\n\n  /**\n   * The maximum size of the batch, in bytes. The `tryAddMessage` function on the batch will return `false`\n   * if the message being added causes the size of the batch to exceed this limit. Use the `createMessageBatch()` method on\n   * the `Sender` to set the maxSizeInBytes.\n   * @readonly\n   */\n  readonly maxSizeInBytes: number;\n\n  /**\n   * Adds a message to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next event.\n   *\n   * @param message - The message to add to the batch.\n   * @returns A boolean value indicating if the message has been added to the batch or not.\n   */\n  tryAddMessage(\n    message: ServiceBusMessage | AmqpAnnotatedMessage,\n    options?: TryAddOptions,\n  ): boolean;\n\n  /**\n   * The AMQP message containing encoded events that were added to the batch.\n   * Used internally by the `sendBatch()` method on the `Sender`.\n   * This is not meant for the user to use directly.\n   *\n   * @readonly\n   * @internal\n   * @hidden\n   */\n  _generateMessage(): Buffer;\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding events to the batch.\n   * Used internally by the `sendBatch()` method to set up the right spans in traces if tracing is enabled.\n   * @internal\n   * @hidden\n   */\n  readonly _messageSpanContexts: TracingContext[];\n}\n\n/**\n * An internal class representing a batch of messages which can be used to send messages to Service Bus.\n *\n * @internal\n */\nexport class ServiceBusMessageBatchImpl implements ServiceBusMessageBatch {\n  /**\n   * Current size of the batch in bytes.\n   */\n  private _sizeInBytes: number;\n  /**\n   * Encoded amqp messages.\n   */\n  private _encodedMessages: Buffer[] = [];\n  /**\n   * List of 'message' span contexts.\n   */\n  private _spanContexts: TracingContext[] = [];\n  /**\n   * ServiceBusMessageBatch should not be constructed using `new ServiceBusMessageBatch()`\n   * Use the `createBatch()` method on your `Sender` instead.\n   * @internal\n   * @hidden\n   */\n  constructor(\n    private _context: ConnectionContext,\n    private _maxSizeInBytes: number,\n  ) {\n    this._sizeInBytes = 0;\n    this._batchMessageProperties = {};\n  }\n\n  /**\n   * The maximum size of the batch, in bytes.\n   * @readonly\n   */\n  get maxSizeInBytes(): number {\n    return this._maxSizeInBytes;\n  }\n\n  /**\n   * Size of the `ServiceBusMessageBatch` instance after the messages added to it have been\n   * encoded into a single AMQP message.\n   * @readonly\n   */\n  get sizeInBytes(): number {\n    return this._sizeInBytes;\n  }\n\n  /**\n   * Number of messages in the `ServiceBusMessageBatch` instance.\n   * @readonly\n   */\n  get count(): number {\n    return this._encodedMessages.length;\n  }\n\n  /**\n   * Gets the \"message\" span contexts that were created when adding messages to the batch.\n   * @internal\n   * @hidden\n   */\n  get _messageSpanContexts(): TracingContext[] {\n    return this._spanContexts;\n  }\n\n  /**\n   * Generates an AMQP message that contains the provided encoded messages and annotations.\n   *\n   * @param encodedMessages - The already encoded messages to include in the AMQP batch.\n   * @param annotations - The message annotations to set on the batch.\n   * @param applicationProperties - The application properties to set on the batch.\n   * @param messageProperties - The message properties to set on the batch.\n   */\n  private _generateBatch(\n    encodedMessages: Buffer[],\n    annotations?: MessageAnnotations,\n    applicationProperties?: { [key: string]: any },\n    messageProperties?: { [key: string]: string },\n  ): Buffer {\n    const batchEnvelope: RheaMessage = {\n      body: RheaMessageUtil.data_sections(encodedMessages),\n      message_annotations: annotations,\n      application_properties: applicationProperties,\n    };\n    if (messageProperties) {\n      for (const prop of RheaMessagePropertiesList) {\n        if ((messageProperties as any)[prop]) {\n          (batchEnvelope as any)[prop] = (messageProperties as any)[prop];\n        }\n      }\n    }\n    return RheaMessageUtil.encode(batchEnvelope);\n  }\n\n  /**\n   * Represents the single AMQP message which is the result of encoding all the events\n   * added into the `ServiceBusMessageBatch` instance.\n   *\n   * This is not meant for the user to use directly.\n   *\n   * When the `ServiceBusMessageBatch` instance is passed to the `sendBatch()` method on the `Sender`,\n   * this single batched AMQP message is what gets sent over the wire to the service.\n   * @readonly\n   */\n  _generateMessage(): Buffer {\n    return this._generateBatch(\n      this._encodedMessages,\n      this._batchAnnotations,\n      this._batchApplicationProperties,\n      this._batchMessageProperties,\n    );\n  }\n\n  /**\n   * The message annotations to apply on the batch envelope.\n   * This will reflect the message annotations on the first message\n   * that was added to the batch.\n   */\n  private _batchAnnotations?: MessageAnnotations;\n  /**\n   * The message properties to apply on the batch envelope.\n   * This will reflect the message properties on the first message\n   * that was added to the batch.\n   */\n  private _batchMessageProperties?: { [key: string]: string };\n  /**\n   * The application properties to apply on the batch envelope.\n   * This will reflect the application properties on the first message\n   * that was added to the batch.\n   */\n  private _batchApplicationProperties?: { [key: string]: any };\n\n  /**\n   * Tries to add a message to the batch if permitted by the batch's size limit.\n   * **NOTE**: Always remember to check the return value of this method, before calling it again\n   * for the next message.\n   *\n   * @param originalMessage - An individual service bus message.\n   * @returns A boolean value indicating if the message has been added to the batch or not.\n   */\n  public tryAddMessage(\n    originalMessage: ServiceBusMessage | AmqpAnnotatedMessage,\n    options: TryAddOptions = {},\n  ): boolean {\n    throwTypeErrorIfParameterMissing(this._context.connectionId, \"message\", originalMessage);\n    throwIfNotValidServiceBusMessage(originalMessage, errorInvalidMessageTypeSingle);\n\n    const { message, spanContext } = instrumentMessage(\n      originalMessage,\n      options,\n      this._context.config.entityPath!,\n      this._context.config.host,\n      \"publish\",\n    );\n\n    // Convert ServiceBusMessage to AmqpMessage.\n    const amqpMessage = toRheaMessage(message, defaultDataTransformer);\n\n    const encodedMessage = RheaMessageUtil.encode(amqpMessage);\n    let currentSize = this._sizeInBytes;\n\n    // The first time an event is added, we need to calculate\n    // the overhead of creating an AMQP batch, including the\n    // message_annotations, application_properties and message_properties\n    // that are taken from the 1st message.\n    if (this.count === 0) {\n      if (amqpMessage.message_annotations) {\n        this._batchAnnotations = amqpMessage.message_annotations;\n      }\n      if (amqpMessage.application_properties) {\n        this._batchApplicationProperties = amqpMessage.application_properties;\n      }\n      for (const prop of RheaMessagePropertiesList) {\n        if ((amqpMessage as any)[prop]) {\n          (this._batchMessageProperties as any)[prop] = (amqpMessage as any)[prop];\n        }\n      }\n      // Figure out the overhead of creating a batch by generating an empty batch\n      // with the expected batch annotations.\n      currentSize += this._generateBatch(\n        [],\n        this._batchAnnotations,\n        this._batchApplicationProperties,\n        this._batchMessageProperties,\n      ).length;\n    }\n\n    const messageSize = encodedMessage.length;\n    const messageOverhead =\n      messageSize <= smallMessageMaxBytes ? smallMessageOverhead : largeMessageOverhead;\n    currentSize += messageSize + messageOverhead;\n    // Check if the size of the batch exceeds the maximum allowed size\n    // once we add the new event to it.\n    if (currentSize > this._maxSizeInBytes) {\n      return false;\n    }\n\n    // The message will fit in the batch, so it is now safe to store it.\n    this._encodedMessages.push(encodedMessage);\n    if (spanContext) {\n      this._spanContexts.push(spanContext);\n    }\n\n    this._sizeInBytes = currentSize;\n    return true;\n  }\n}\n"]}