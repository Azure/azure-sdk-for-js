{"version":3,"file":"errors.js","sourceRoot":"","sources":["../../../src/util/errors.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport Long from \"long\";\nimport type { ConnectionContext } from \"../connectionContext.js\";\nimport { logger, receiverLogger } from \"../log.js\";\nimport type { ReceiveMode } from \"../models.js\";\nimport type { ServiceBusReceivedMessage } from \"../serviceBusMessage.js\";\nimport { isAmqpAnnotatedMessage, isServiceBusMessage } from \"../serviceBusMessage.js\";\nimport { isDefined } from \"@azure/core-util\";\n\n/**\n * Error message to use when EntityPath in connection string does not match the\n * queue or topic name passed to the methods in the ServiceBusClient that create\n * senders and receivers.\n *\n * @internal\n */\nexport const entityPathMisMatchError =\n  \"The queue or topic name provided does not match the EntityPath in the connection string passed to the ServiceBusClient constructor.\";\n\n/**\n * Error message for when maxMessageCount provided is invalid.\n *\n * @internal\n */\nexport const InvalidMaxMessageCountError = \"'maxMessageCount' must be a number greater than 0.\";\n\n/**\n * @internal\n * Logs and throws Error if the current AMQP connection is closed.\n * @param context - The ConnectionContext associated with the current AMQP connection.\n */\nexport function throwErrorIfConnectionClosed(context: ConnectionContext): void {\n  if (context && context.wasConnectionCloseCalled) {\n    const errorMessage = \"The underlying AMQP connection is closed.\";\n    const error = new Error(errorMessage);\n    logger.warning(`[${context.connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Gets the error message when a sender is used when its already closed\n * @param entityPath - Value of the `entityPath` property on the client which denotes its name\n */\nexport function getSenderClosedErrorMsg(entityPath: string): string {\n  return (\n    `The sender for \"${entityPath}\" has been closed and can no longer be used. ` +\n    `Please create a new sender using the \"createSender\" method on the ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * Gets the error message when a receiver is used when its already closed\n * @param entityPath - Value of the `entityPath` property on the client which denotes its name\n * @param sessionId - If using session receiver, then the id of the session\n */\nexport function getReceiverClosedErrorMsg(entityPath: string, sessionId?: string): string {\n  if (!isDefined(sessionId)) {\n    return (\n      `The receiver for \"${entityPath}\" has been closed and can no longer be used. ` +\n      `Please create a new receiver using the \"createReceiver\" method on the ServiceBusClient.`\n    );\n  }\n  return (\n    `The receiver for session \"${sessionId}\" in \"${entityPath}\" has been closed and can no ` +\n    `longer be used. Please create a new receiver using the \"acceptSession\" or \"acceptNextSession\" method on the ServiceBusClient.`\n  );\n}\n\n/**\n * @internal\n * @param entityPath - Value of the `entityPath` property on the client which denotes its name\n * @param sessionId - If using session receiver, then the id of the session\n */\nexport function getAlreadyReceivingErrorMsg(entityPath: string, sessionId?: string): string {\n  if (!isDefined(sessionId)) {\n    return `The receiver for \"${entityPath}\" is already receiving messages.`;\n  }\n  return `The receiver for session \"${sessionId}\" for \"${entityPath}\" is already receiving messages.`;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is undefined or null\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to check\n * @param parameterValue - Value of the parameter to check\n */\nexport function throwTypeErrorIfParameterMissing(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: unknown,\n): void {\n  if (parameterValue === undefined || parameterValue === null) {\n    const error = new TypeError(`Missing parameter \"${parameterName}\"`);\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not an instance of expected type\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n * @param constructor - Constructor function of the expected parameter type\n */\nexport function throwTypeErrorIfNotInstanceOfParameterType(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: unknown,\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  constructor: Function,\n): void {\n  if (!(parameterValue instanceof constructor)) {\n    const error = new TypeError(\n      `The parameter \"${parameterName}\" should be an instance of \"${constructor.name}\"`,\n    );\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not of expected type\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n * @param expectedType - Expected type of the parameter\n */\nexport function throwTypeErrorIfParameterTypeMismatch(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: unknown,\n  expectedType: string,\n): void {\n  if (typeof parameterValue !== expectedType) {\n    const error = new TypeError(\n      `The parameter \"${parameterName}\" should be of type \"${expectedType}\"`,\n    );\n    logger.warning(`[${connectionId}] %O`, error);\n    throw error;\n  }\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not of type `Long` or an array of type `Long`\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLong(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: unknown,\n): TypeError | undefined {\n  if (Array.isArray(parameterValue)) {\n    return throwTypeErrorIfParameterNotLongArray(connectionId, parameterName, parameterValue);\n  }\n  if (Long.isLong(parameterValue)) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be of type \"Long\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is not an array of type `Long`\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterNotLongArray(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: any[],\n): TypeError | undefined {\n  if (parameterValue.every((item) => Long.isLong(item))) {\n    return;\n  }\n  const error = new TypeError(`The parameter \"${parameterName}\" should be an array of type \"Long\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * Logs and Throws TypeError if given parameter is an empty string\n * @param connectionId - Id of the underlying AMQP connection used for logging\n * @param parameterName - Name of the parameter to type check\n * @param parameterValue - Value of the parameter to type check\n */\nexport function throwTypeErrorIfParameterIsEmptyString(\n  connectionId: string,\n  parameterName: string,\n  parameterValue: string,\n): TypeError | undefined {\n  if (parameterValue !== \"\") {\n    return;\n  }\n  const error = new TypeError(`Empty string not allowed in parameter \"${parameterName}\"`);\n  logger.warning(`[${connectionId}] %O`, error);\n  throw error;\n}\n\n/**\n * @internal\n * The error message for operations on the receiver that are invalid for a message received in receiveAndDelete mode.\n */\nexport const InvalidOperationInReceiveAndDeleteMode =\n  \"The operation is not supported in 'receiveAndDelete' receive mode.\";\n\n/**\n * @internal\n * The error message for operations on the receiver that are invalid for a peeked message.\n */\nexport const InvalidOperationForPeekedMessage =\n  \"This operation is not supported for peeked messages. Only messages received using 'receiveMessages()', 'subscribe()' and 'getMessageIterator()' methods on the receiver in 'peekLock' receive mode can be settled.\";\n\n/**\n * @internal\n * The error message for when one attempts to settle an already settled message.\n */\nexport const MessageAlreadySettled = \"The message has either been deleted or already settled\";\n\n/**\n * Throws error if the ServiceBusReceivedMessage cannot be settled.\n * @internal\n */\nexport function throwErrorIfInvalidOperationOnMessage(\n  message: ServiceBusReceivedMessage,\n  receiveMode: ReceiveMode,\n  connectionId: string,\n): void {\n  let error: Error | undefined;\n\n  if (receiveMode === \"receiveAndDelete\") {\n    error = new Error(InvalidOperationInReceiveAndDeleteMode);\n  } else if (!message.lockToken) {\n    error = new Error(InvalidOperationForPeekedMessage);\n  }\n\n  if (error) {\n    receiverLogger.logError(\n      error,\n      \"[%s] An error occurred for message with id '%s'\",\n      connectionId,\n      message.messageId,\n    );\n    throw error;\n  }\n}\n\n/**\n * Error message for when the ServiceBusMessage provided by the user has different values\n * for partitionKey and sessionId.\n * @internal\n */\nexport const PartitionKeySessionIdMismatchError =\n  \"The fields 'partitionKey' and 'sessionId' cannot have different values.\";\n/**\n * Throws error if the given object is not a valid ServiceBusMessage\n * @internal\n * @param msg - The object that needs to be validated as a ServiceBusMessage\n * @param errorMessageForWrongType - The error message to use when given object is not a ServiceBusMessage\n */\nexport function throwIfNotValidServiceBusMessage(\n  msg: unknown,\n  errorMessageForWrongType: string,\n): void {\n  if (!isServiceBusMessage(msg) && !isAmqpAnnotatedMessage(msg)) {\n    throw new TypeError(errorMessageForWrongType);\n  }\n\n  if (isServiceBusMessage(msg)) {\n    if (msg.partitionKey && msg.sessionId && msg.partitionKey !== msg.sessionId) {\n      throw new TypeError(PartitionKeySessionIdMismatchError);\n    }\n  }\n}\n\n/** @internal */\nexport const errorInvalidMessageTypeSingleOrArray =\n  \"Provided value for 'messages' must be of type: ServiceBusMessage, AmqpAnnotatedMessage, ServiceBusMessageBatch or an array of type ServiceBusMessage or AmqpAnnotatedMessage.\";\n\n/** @internal */\nexport const errorInvalidMessageTypeSingle =\n  \"Provided value for 'message' must be of type: ServiceBusMessage or AmqpAnnotatedMessage.\";\n"]}