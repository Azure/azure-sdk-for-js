{"version":3,"file":"models.js","sourceRoot":"","sources":["../../src/models.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { OperationOptionsBase } from \"./modelsToBeSharedWithEventHubs.js\";\nimport type Long from \"long\";\nimport type { ServiceBusReceivedMessage } from \"./serviceBusMessage.js\";\nimport type { ServiceBusError } from \"./serviceBusError.js\";\n\n/**\n * Arguments to the `processError` callback.\n */\nexport interface ProcessErrorArgs {\n  /**\n   * The error.\n   */\n  error: Error | ServiceBusError;\n  /**\n   * The operation where the error originated.\n   *\n   * 'abandon': Errors that occur when if `abandon` is triggered automatically.\n   * 'complete': Errors that occur when autoComplete completes a message.\n   * 'processMessageCallback': Errors thrown from the user's `processMessage` callback passed to `subscribe`.\n   * 'receive': Errors thrown when receiving messages.\n   * 'renewLock': Errors thrown when automatic lock renewal fails.\n   */\n  errorSource: \"abandon\" | \"complete\" | \"processMessageCallback\" | \"receive\" | \"renewLock\";\n  /**\n   * The entity path for the current receiver.\n   */\n  entityPath: string;\n  /**\n   * The fully qualified namespace for the Service Bus.\n   */\n  fullyQualifiedNamespace: string;\n  /**\n   * The identifier of the client that raised this event.\n   */\n  identifier: string;\n}\n\n/**\n * @internal\n */\nexport interface InternalProcessErrorArgs extends Omit<ProcessErrorArgs, \"errorSource\"> {\n  /**\n   * The operation where the error originated.\n   *\n   * 'abandon': Errors that occur when if `abandon` is triggered automatically.\n   * 'complete': Errors that occur when autoComplete completes a message.\n   * 'processMessageCallback': Errors thrown from the user's `processMessage` callback passed to `subscribe`.\n   * 'receive': Errors thrown when receiving messages.\n   * 'renewLock': Errors thrown when automatic lock renewal fails.\n   */\n  errorSource: ProcessErrorArgs[\"errorSource\"] | \"internal\";\n}\n\n/**\n * The general message handler interface (used for streamMessages).\n */\nexport interface MessageHandlers {\n  /**\n   * Handler that processes messages from service bus.\n   *\n   * @param message - A message received from Service Bus.\n   */\n  processMessage(message: ServiceBusReceivedMessage): Promise<void>;\n  /**\n   * Handler that processes errors that occur during receiving.\n   *\n   * This handler will be called for any error that occurs in the receiver when\n   *   - receiving the message, or\n   *   - executing your `processMessage` callback, or\n   *   - receiver is completing the message on your behalf after successfully running your `processMessage` callback and `autoCompleteMessages` is enabled\n   *   - receiver is abandoning the message on your behalf if running your `processMessage` callback fails and `autoCompleteMessages` is enabled\n   *   - receiver is renewing the lock on your behalf due to auto lock renewal feature being enabled\n   *\n   * Note that when receiving messages in a stream using `subscribe()`, the receiver will automatically retry receiving messages on all errors unless\n   * `close()` is called on the subscription. It is completely up to users to decide what errors are considered non-recoverable and to handle them\n   * accordingly in this callback.\n   * For a list of errors occurs within Service Bus, please refer to https://learn.microsoft.com/javascript/api/\\@azure/service-bus/servicebuserror?view=azure-node-latest\n   * @param args - The error and additional context to indicate where\n   * the error originated.\n   */\n  processError(args: ProcessErrorArgs): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport interface InternalMessageHandlers extends MessageHandlers {\n  /**\n   * Called when the connection is initialized but before we've added credits.\n   * NOTE: This handler is completely internal and only used for tests.\n   */\n  postInitialize?: () => Promise<void>;\n\n  /**\n   * Called before we actually initialize the link itself.\n   * NOTE: This handler is completely internal and only used for tests.\n   */\n  preInitialize?: () => Promise<void>;\n\n  /**\n   * Forwards internal errors that are not normally reported to the customer to `processError`.\n   * (defaults to false)\n   */\n  forwardInternalErrors?: boolean;\n}\n\n/**\n * Represents the possible receive modes for the receiver.\n * @internal\n */\nexport type ReceiveMode = \"peekLock\" | \"receiveAndDelete\";\n\n/**\n * Options to use when creating a receiver.\n */\nexport interface ServiceBusReceiverOptions {\n  /**\n   * Represents the receive mode for the receiver.\n   *\n   * In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue/subscription.\n   *\n   * Messages that are not settled within the lock duration will be redelivered as many times as\n   * the max delivery count set on the queue/subscription, after which they get sent to a separate\n   * dead letter queue.\n   *\n   * You can settle a message by calling complete(), abandon(), defer() or deadletter() methods on\n   * the message.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   */\n  receiveMode?: \"peekLock\" | \"receiveAndDelete\";\n  /**\n   * Represents the sub queue that is applicable for any queue or subscription.\n   * Valid values are \"deadLetter\" and \"transferDeadLetter\". To learn more about dead letter queues,\n   * see https://learn.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\n   */\n  subQueueType?: \"deadLetter\" | \"transferDeadLetter\";\n\n  /**\n   * The maximum duration, in milliseconds, that the lock on the message will be renewed automatically by the client.\n   * This auto renewal stops once the message is settled.\n   *\n   * - **Default**: `300 * 1000` milliseconds (5 minutes).\n   * - **To disable autolock renewal**, set this to `0`.\n   *\n   * **Example:**\n   *\n   *    If the message lock expires in 2 minutes and your message processing time is 8 minutes...\n   *\n   *    Set maxAutoLockRenewalDurationInMs to 10 minutes, and the message lock will be automatically renewed for 4 times\n   *    (equivalent to having the message locked for 4 times its lock duration by leveraging the lock renewals).\n   */\n  maxAutoLockRenewalDurationInMs?: number;\n  /**\n   * Option to disable the client from running JSON.parse() on the message body when receiving the message.\n   * Not applicable if the message was sent with AMQP body type value or sequence. Use this option when you\n   * prefer to work directly with the bytes present in the message body than have the client attempt to parse it.\n   */\n  skipParsingBodyAsJson?: boolean;\n  /**\n   * Whether to skip converting Date type on properties of message annotations\n   * or application properties into numbers when receiving the message. By\n   * default, properties of Date type is converted into UNIX epoch number for\n   * compatibility.\n   */\n  skipConvertingDate?: boolean;\n  /**\n   * Sets the name to identify the receiver. This can be used to correlate logs and exceptions.\n   * If not specified or empty, a random unique one will be used.\n   */\n  identifier?: string;\n}\n\n/**\n * Options to use when creating a sender.\n */\nexport interface ServiceBusSenderOptions {\n  /**\n   * Sets the name to identify the sender. This can be used to correlate logs and exceptions.\n   * If not specified or empty, a random unique one will be used.\n   */\n  identifier?: string;\n}\n\n/**\n * Options to configure the `createBatch` method on the `Sender`.\n * - `maxSizeInBytes`: The upper limit for the size of batch.\n *\n * Example usage:\n * ```ts snippet:ignore\n * {\n *     maxSizeInBytes: 1024 * 1024 // 1 MB\n * }\n * ```\n */\nexport interface CreateMessageBatchOptions extends OperationOptionsBase {\n  /**\n   * The upper limit for the size of batch. The `tryAdd` function will return `false` after this limit is reached.\n   */\n  maxSizeInBytes?: number;\n}\n\n/**\n * Options when receiving a batch of messages from Service Bus.\n */\nexport interface ReceiveMessagesOptions extends OperationOptionsBase {\n  /**\n   * The maximum amount of time to wait for messages to arrive.\n   *  **Default**: `60000` milliseconds.\n   */\n  maxWaitTimeInMs?: number;\n}\n\n/**\n * Options when getting an iterable iterator from Service Bus.\n */\nexport interface GetMessageIteratorOptions extends OperationOptionsBase {}\n\n/**\n * Options used when subscribing to a Service Bus queue or subscription.\n */\nexport interface SubscribeOptions extends OperationOptionsBase {\n  /**\n   * Indicates whether the message should be settled automatically based on the result from the\n   * user provided `processMessage` callback.\n   *\n   * - If an error is thrown from the `processMessage` callback the message will be abandoned\n   *   using `receiver.abandonMessage()`. Doing so will make the message available again from the\n   *   queue/subscription and the delivery count will be incremented.\n   * - If NO error is thrown from `processMessage` the message will be completed\n   *   using `receiver.completeMessage()`. Doing so removes the message from the queue/subscription.\n   *\n   * This option is ignored if messages are received in the `receiveAndDelete` receive mode or if\n   * the message is already settled in the user provided message callback.\n   *\n   * - **Default**: `true`.\n   */\n  autoCompleteMessages?: boolean;\n  /**\n   * The maximum number of concurrent calls that the library\n   * can make to the user's message handler. Once this limit has been reached, more messages will\n   * not be received until at least one of the calls to the user's message handler has completed.\n   * - **Default**: `1`.\n   */\n  maxConcurrentCalls?: number;\n}\n\n/**\n * Describes the options passed to the `acceptSession` and `acceptNextSession` methods\n * when using a Queue/Subscription that has sessions enabled.\n */\nexport interface ServiceBusSessionReceiverOptions extends OperationOptionsBase {\n  /**\n   * Represents the receive mode for the receiver.\n   *\n   * In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue/subscription.\n   *\n   * Messages that are not settled within the lock duration will be redelivered as many times as\n   * the max delivery count set on the queue/subscription, after which they get sent to a separate\n   * dead letter queue.\n   *\n   * You can settle a message by calling complete(), abandon(), defer() or deadletter() methods on\n   * the message.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   */\n  receiveMode?: \"peekLock\" | \"receiveAndDelete\";\n  /**\n   * The maximum duration, in milliseconds, that the lock on the session will be renewed automatically by the client.\n   *\n   * - **Default**: `300000` milliseconds (5 minutes).\n   * - **To disable autolock renewal**, set this to `0`.\n   *\n   * **Example:**\n   *\n   *    If the lock expires in 2 minutes and your processing time is 8 minutes...\n   *\n   *    Set maxAutoLockRenewalDurationInMs to 10 minutes, and the lock will be automatically renewed about 4 times\n   *    (equivalent to having the session locked for 4 times its lock duration by leveraging the lock renewals).\n   */\n  maxAutoLockRenewalDurationInMs?: number;\n  /**\n   * Option to disable the client from running JSON.parse() on the message body when receiving the message.\n   * Not applicable if the message was sent with AMQP body type value or sequence. Use this option when you\n   * prefer to work directly with the bytes present in the message body than have the client attempt to parse it.\n   */\n  skipParsingBodyAsJson?: boolean;\n  /**\n   * Whether to skip converting Date type on properties of message annotations\n   * or application properties into numbers when receiving the message. By\n   * default, properties of Date type is converted into UNIX epoch number for\n   * compatibility.\n   */\n  skipConvertingDate?: boolean;\n  /**\n   * Sets the name to identify the session receiver. This can be used to correlate logs and exceptions.\n   * If not specified or empty, a random unique one will be used.\n   */\n  identifier?: string;\n}\n\n/**\n * Describes the options passed to the `peekMessages` method on a receiver.\n */\nexport interface PeekMessagesOptions extends OperationOptionsBase {\n  /**\n   * The sequence number to start peeking messages from (inclusive).\n   */\n  fromSequenceNumber?: Long;\n}\n\n/**\n * Options to configure messages deletion.\n */\nexport interface DeleteMessagesOptions extends OperationOptionsBase {\n  /**\n   * If specified, only messages enqueued before this time are deleted.\n   */\n  beforeEnqueueTime?: Date;\n  /**\n   * Up to `maxMessageCount` messages will be deleted.\n   */\n  maxMessageCount: number;\n}\n\n/**\n * Options to configure deletion of all messages in an entity.\n */\nexport interface PurgeMessagesOptions extends OperationOptionsBase {\n  /**\n   * If specified, only messages enqueued before this time are deleted.\n   */\n  beforeEnqueueTime?: Date;\n}\n"]}