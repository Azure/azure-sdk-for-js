{"version":3,"file":"serviceBusClient.js","sourceRoot":"","sources":["../../src/serviceBusClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { ConnectionConfig } from \"@azure/core-amqp\";\nimport type { TokenCredential, NamedKeyCredential, SASCredential } from \"@azure/core-auth\";\nimport type { ServiceBusClientOptions } from \"./constructorHelpers.js\";\nimport {\n  createConnectionContextForConnectionString,\n  createConnectionContextForCredential,\n} from \"./constructorHelpers.js\";\nimport { ConnectionContext } from \"./connectionContext.js\";\nimport type {\n  ServiceBusReceiverOptions,\n  ServiceBusSessionReceiverOptions,\n  ReceiveMode,\n  ServiceBusSenderOptions,\n} from \"./models.js\";\nimport type { ServiceBusReceiver } from \"./receivers/receiver.js\";\nimport { ServiceBusReceiverImpl } from \"./receivers/receiver.js\";\nimport type { ServiceBusSessionReceiver } from \"./receivers/sessionReceiver.js\";\nimport { ServiceBusSessionReceiverImpl } from \"./receivers/sessionReceiver.js\";\nimport type { ServiceBusRuleManager } from \"./serviceBusRuleManager.js\";\nimport { ServiceBusRuleManagerImpl } from \"./serviceBusRuleManager.js\";\nimport type { ServiceBusSender } from \"./sender.js\";\nimport { ServiceBusSenderImpl } from \"./sender.js\";\nimport { entityPathMisMatchError } from \"./util/errors.js\";\nimport { MessageSession } from \"./session/messageSession.js\";\nimport { isDefined } from \"@azure/core-util\";\nimport { isCredential } from \"./util/typeGuards.js\";\nimport { ensureValidIdentifier } from \"./util/utils.js\";\n\n/**\n * A client that can create Sender instances for sending messages to queues and\n * topics as well as Receiver instances to receive messages from queues and subscriptions.\n */\nexport class ServiceBusClient {\n  private _connectionContext: ConnectionContext;\n  private _clientOptions: ServiceBusClientOptions;\n  /**\n   * The fully qualified namespace of the Service Bus instance for which this client is created.\n   * This is likely to be similar to <yournamespace>.servicebus.windows.net.\n   */\n  public fullyQualifiedNamespace: string;\n  /**\n   * The name used to identify this ServiceBusClient.\n   * If not specified or empty, a random unique one will be generated.\n   */\n  public identifier: string;\n  /**\n   * Creates an instance of the ServiceBusClient class which can be used to create senders and receivers to\n   * the Azure Service Bus namespace provided in the connection string. No connection is made to the service\n   * until the senders/receivers created with the client are used to send/receive messages.\n   * @param connectionString - A connection string for Azure Service Bus namespace.\n   * NOTE: this connection string can contain an EntityPath, which is ignored.\n   * @param options - Options for the service bus client.\n   */\n  constructor(connectionString: string, options?: ServiceBusClientOptions);\n  /**\n   * Creates an instance of the ServiceBusClient class which can be used to create senders and receivers to\n   * the Azure Service Bus namespace provided. No connection is made to the service until\n   * the senders/receivers created with the client are used to send/receive messages.\n   * @param fullyQualifiedNamespace - The full namespace of your Service Bus instance which is\n   * likely to be similar to <yournamespace>.servicebus.windows.net.\n   * @param credential - A credential object used by the client to get the token to authenticate the connection\n   * with the Azure Service Bus. See &commat;azure/identity for creating the credentials.\n   * If you're using an own implementation of the `TokenCredential` interface against AAD, then set the \"scopes\" for service-bus\n   * to be `[\"https://servicebus.azure.net//user_impersonation\"]` to get the appropriate token.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * Use the `AzureSASCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessSignature`\n   * without using a connection string. This field maps to `signature` in `AzureSASCredential`.\n   * @param options - A set of options to apply when configuring the client.\n   * - `retryOptions`   : Configures the retry policy for all the operations on the client.\n   * For example, `{ \"maxRetries\": 4 }` or `{ \"maxRetries\": 4, \"retryDelayInMs\": 30000 }`.\n   * - `webSocketOptions`: Configures the channelling of the AMQP connection over Web Sockets.\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    credential: TokenCredential | NamedKeyCredential | SASCredential,\n    options?: ServiceBusClientOptions,\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    credentialOrOptions2?:\n      | TokenCredential\n      | NamedKeyCredential\n      | SASCredential\n      | ServiceBusClientOptions,\n    options3?: ServiceBusClientOptions,\n  ) {\n    if (isCredential(credentialOrOptions2)) {\n      const fullyQualifiedNamespace: string = fullyQualifiedNamespaceOrConnectionString1;\n      const credential = credentialOrOptions2;\n      this._clientOptions = options3 || {};\n\n      this._connectionContext = createConnectionContextForCredential(\n        credential,\n        fullyQualifiedNamespace,\n        this._clientOptions,\n      );\n    } else {\n      const connectionString: string = fullyQualifiedNamespaceOrConnectionString1;\n      this._clientOptions = credentialOrOptions2 || {};\n\n      this._connectionContext = createConnectionContextForConnectionString(\n        connectionString,\n        this._clientOptions,\n      );\n    }\n    this.fullyQualifiedNamespace = this._connectionContext.config.host;\n    this.identifier = ensureValidIdentifier(\n      this.fullyQualifiedNamespace,\n      this._clientOptions.identifier,\n    );\n    this._clientOptions.retryOptions = this._clientOptions.retryOptions || {};\n\n    const timeoutInMs = this._clientOptions.retryOptions.timeoutInMs;\n    if (\n      isDefined(timeoutInMs) &&\n      (typeof timeoutInMs !== \"number\" || !isFinite(timeoutInMs) || timeoutInMs <= 0)\n    ) {\n      throw new Error(`${timeoutInMs} is an invalid value for retryOptions.timeoutInMs`);\n    }\n  }\n\n  /**\n   * Creates a receiver for an Azure Service Bus queue. No connection is made\n   * to the service until one of the methods on the receiver is called.\n   *\n   * To target sub queues like the dead letter queue or the transfer dead letter queue, provide the\n   * `subQueue` in the options. To learn more about dead letter queues, see\n   * https://learn.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * Messages that are not settled within the lock duration will be redelivered as many times as\n   * the max delivery count set on the queue, after which they get sent to a separate dead letter\n   * queue.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName - The name of the queue to receive from.\n   * @param options - Options to pass the receiveMode, defaulted to peekLock.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  createReceiver(queueName: string, options?: ServiceBusReceiverOptions): ServiceBusReceiver;\n  /**\n   * Creates a receiver for an Azure Service Bus subscription. No connection is made\n   * to the service until one of the methods on the receiver is called.\n   *\n   * To target sub queues like the dead letter queue or the transfer dead letter queue, provide the\n   * `subQueue` in the options. To learn more about dead letter queues, see\n   * https://learn.microsoft.com/azure/service-bus-messaging/service-bus-dead-letter-queues\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * Messages that are not settled within the lock duration will be redelivered as many times as\n   * the max delivery count set on the subscription, after which they get sent to a separate dead letter\n   * queue.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName - Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.\n   * @param options - Options to pass the receiveMode, defaulted to peekLock.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  createReceiver(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusReceiverOptions,\n  ): ServiceBusReceiver;\n  createReceiver(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionName2?: ServiceBusReceiverOptions | string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options3?: ServiceBusReceiverOptions,\n  ): ServiceBusReceiver {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    // NOTE: we don't currently have any options for this kind of receiver but\n    // when we do make sure you pass them in and extract them.\n    const { entityPath, receiveMode, options } = extractReceiverArguments(\n      queueOrTopicName1,\n      optionsOrSubscriptionName2,\n      options3,\n    );\n\n    let entityPathWithSubQueue = entityPath;\n    if (options?.subQueueType) {\n      switch (options?.subQueueType) {\n        case \"deadLetter\":\n          entityPathWithSubQueue += \"/$DeadLetterQueue\";\n          break;\n        case \"transferDeadLetter\":\n          entityPathWithSubQueue += \"/$Transfer/$DeadLetterQueue\";\n          break;\n        default:\n          throw new Error(\n            `Invalid subQueueType '${options?.subQueueType}' provided. Valid values are 'deadLetter' and 'transferDeadLetter'`,\n          );\n      }\n    }\n\n    const maxLockAutoRenewDurationInMs =\n      options?.maxAutoLockRenewalDurationInMs != null\n        ? options.maxAutoLockRenewalDurationInMs\n        : 5 * 60 * 1000;\n\n    return new ServiceBusReceiverImpl(\n      this._connectionContext,\n      entityPathWithSubQueue,\n      receiveMode,\n      maxLockAutoRenewDurationInMs,\n      options?.skipParsingBodyAsJson ?? false,\n      options?.skipConvertingDate ?? false,\n      this._clientOptions.retryOptions,\n      options?.identifier,\n    );\n  }\n\n  /**\n   * Creates an instance of {@link ServiceBusRuleManager} that is used to manage\n   * the rules for a subscription.\n   *\n   * @param topicName - the topic to create {@link ServiceBusRuleManager}\n   * @param subscriptionName - the subscription specific to the specified topic to create a {@link ServiceBusRuleManager} for.\n   * @returns a {@link ServiceBusRuleManager} scoped to the specified subscription and topic.\n   */\n  createRuleManager(topicName: string, subscriptionName: string): ServiceBusRuleManager {\n    validateEntityPath(this._connectionContext.config, topicName);\n\n    const { entityPath } = extractReceiverArguments(topicName, subscriptionName);\n    return new ServiceBusRuleManagerImpl(\n      this._connectionContext,\n      entityPath,\n      this._clientOptions.retryOptions,\n    );\n  }\n\n  /**\n   * Creates a receiver for a session enabled Azure Service Bus queue.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName - The name of the queue to receive from.\n   * @param sessionId - The id of the session from which messages need to be received\n   * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptSession(\n    queueName: string,\n    sessionId: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver>;\n  /**\n   * Creates a receiver for a session enabled Azure Service Bus subscription.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName - Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.\n   * @param sessionId - The id of the session from which messages need to be received\n   * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptSession(\n    topicName: string,\n    subscriptionName: string,\n    sessionId: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver>;\n  async acceptSession(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionNameOrSessionId2?: ServiceBusSessionReceiverOptions | string,\n    optionsOrSessionId3?: ServiceBusSessionReceiverOptions | string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options4?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver> {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    let sessionId: string;\n    let entityPath: string;\n    let receiveMode: \"peekLock\" | \"receiveAndDelete\";\n    let options: ServiceBusSessionReceiverOptions | undefined;\n\n    if (\n      typeof queueOrTopicName1 === \"string\" &&\n      typeof optionsOrSubscriptionNameOrSessionId2 === \"string\" &&\n      typeof optionsOrSessionId3 === \"string\"\n    ) {\n      // subscription constructor\n      sessionId = optionsOrSessionId3;\n\n      ({ entityPath, receiveMode, options } = extractReceiverArguments(\n        queueOrTopicName1,\n        optionsOrSubscriptionNameOrSessionId2,\n        // skip the session ID parameter (3)\n        options4,\n      ));\n    } else if (\n      typeof queueOrTopicName1 === \"string\" &&\n      typeof optionsOrSubscriptionNameOrSessionId2 === \"string\" &&\n      typeof optionsOrSessionId3 !== \"string\"\n    ) {\n      // queue constructor (but only because we know we're not a subscription constructor)\n      sessionId = optionsOrSubscriptionNameOrSessionId2;\n\n      ({ entityPath, receiveMode, options } = extractReceiverArguments(\n        queueOrTopicName1,\n        // skip the session ID parameter (2)\n        optionsOrSessionId3,\n        undefined,\n      ));\n    } else {\n      throw new Error(\"Unhandled set of parameters\");\n    }\n\n    const messageSession = await MessageSession.create(\n      ensureValidIdentifier(entityPath, options?.identifier),\n      this._connectionContext,\n      entityPath,\n      sessionId,\n      {\n        maxAutoLockRenewalDurationInMs: options?.maxAutoLockRenewalDurationInMs,\n        receiveMode,\n        abortSignal: options?.abortSignal,\n        retryOptions: this._clientOptions.retryOptions,\n        skipParsingBodyAsJson: options?.skipParsingBodyAsJson ?? false,\n        skipConvertingDate: options?.skipConvertingDate ?? false,\n      },\n    );\n\n    const sessionReceiver = new ServiceBusSessionReceiverImpl(\n      messageSession,\n      this._connectionContext,\n      entityPath,\n      receiveMode,\n      options?.skipParsingBodyAsJson ?? false,\n      options?.skipConvertingDate ?? false,\n      this._clientOptions.retryOptions,\n    );\n\n    return sessionReceiver;\n  }\n\n  /**\n   * Creates a receiver for the next available session in a session-enabled Azure Service Bus queue.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param queueName - The name of the queue to receive from.\n   * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptNextSession(\n    queueName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver>;\n  /**\n   * Creates a receiver for the next available session in a session-enabled Azure Service Bus subscription.\n   *\n   * You can choose between two receive modes:  \"peekLock\" (default) and \"receiveAndDelete\".\n   * - In peekLock mode, the receiver has a lock on the message for the duration specified on the\n   * queue.\n   * - In receiveAndDelete mode, messages are deleted from Service Bus as they are received.\n   *\n   * You can settle a message by calling completeMessage(), abandonMessage(), deferMessage() or\n   * deadletterMessage() methods on the receiver.\n   *\n   * More information about how peekLock and message settlement works here:\n   * https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement#peeklock\n   *\n   * @param topicName - Name of the topic for the subscription we want to receive from.\n   * @param subscriptionName - Name of the subscription (under the `topic`) that we want to receive from.\n   * @param options - Options include receiveMode(defaulted to peekLock), options to create session receiver.\n   * @returns A receiver that can be used to receive, peek and settle messages.\n   */\n  acceptNextSession(\n    topicName: string,\n    subscriptionName: string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver>;\n  async acceptNextSession(\n    queueOrTopicName1: string,\n    optionsOrSubscriptionName2?: ServiceBusSessionReceiverOptions | string,\n    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n    options3?: ServiceBusSessionReceiverOptions,\n  ): Promise<ServiceBusSessionReceiver> {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName1);\n\n    const { entityPath, receiveMode, options } = extractReceiverArguments(\n      queueOrTopicName1,\n      optionsOrSubscriptionName2,\n      options3,\n    );\n\n    const messageSession = await MessageSession.create(\n      ensureValidIdentifier(entityPath, options?.identifier),\n      this._connectionContext,\n      entityPath,\n      undefined,\n      {\n        maxAutoLockRenewalDurationInMs: options?.maxAutoLockRenewalDurationInMs,\n        receiveMode,\n        abortSignal: options?.abortSignal,\n        retryOptions: this._clientOptions.retryOptions,\n        skipParsingBodyAsJson: options?.skipParsingBodyAsJson ?? false,\n        skipConvertingDate: options?.skipConvertingDate ?? false,\n      },\n    );\n\n    const sessionReceiver = new ServiceBusSessionReceiverImpl(\n      messageSession,\n      this._connectionContext,\n      entityPath,\n      receiveMode,\n      options?.skipParsingBodyAsJson ?? false,\n      options?.skipConvertingDate ?? false,\n      this._clientOptions.retryOptions,\n    );\n\n    return sessionReceiver;\n  }\n\n  /**\n   * Creates a Sender which can be used to send messages, schedule messages to be\n   * sent at a later time and cancel such scheduled messages. No connection is made\n   * to the service until one of the methods on the sender is called.\n   * @param queueOrTopicName - The name of a queue or topic to send messages to.\n   */\n  // eslint-disable-next-line @azure/azure-sdk/ts-naming-options\n  createSender(queueOrTopicName: string, options: ServiceBusSenderOptions = {}): ServiceBusSender {\n    validateEntityPath(this._connectionContext.config, queueOrTopicName);\n\n    return new ServiceBusSenderImpl(\n      this._connectionContext,\n      queueOrTopicName,\n      this._clientOptions.retryOptions,\n      options.identifier,\n    );\n  }\n\n  /**\n   * Closes the underlying AMQP connection.\n   * NOTE: this will also disconnect any Receiver or Sender instances created from this\n   * instance.\n   */\n  close(): Promise<void> {\n    return ConnectionContext.close(this._connectionContext);\n  }\n}\n\n/**\n * Helper to validate and extract the common arguments from both the create*Receiver() overloads that\n * have this pattern:\n *\n * queue, options\n * topic, subscription, options\n *\n * @internal\n */\nexport function extractReceiverArguments<OptionsT extends { receiveMode?: ReceiveMode }>(\n  queueOrTopicName1: string,\n  optionsOrSubscriptionName2: string | OptionsT | undefined,\n  definitelyOptions3?: OptionsT,\n): {\n  entityPath: string;\n  receiveMode: ReceiveMode;\n  options?: Omit<OptionsT, \"receiveMode\">;\n} {\n  let entityPath: string;\n  let options: OptionsT | undefined;\n  if (typeof optionsOrSubscriptionName2 === \"string\") {\n    const topic = queueOrTopicName1;\n    const subscription = optionsOrSubscriptionName2;\n    entityPath = `${topic}/Subscriptions/${subscription}`;\n    options = definitelyOptions3;\n  } else {\n    entityPath = queueOrTopicName1;\n    options = optionsOrSubscriptionName2;\n  }\n  let receiveMode: ReceiveMode;\n  if (!options || !isDefined(options.receiveMode) || options.receiveMode === \"peekLock\") {\n    receiveMode = \"peekLock\";\n  } else if (options.receiveMode === \"receiveAndDelete\") {\n    receiveMode = \"receiveAndDelete\";\n  } else {\n    throw new TypeError(\n      `Invalid receiveMode '${options?.receiveMode}' provided. Valid values are 'peekLock' and 'receiveAndDelete'`,\n    );\n  }\n  delete options?.receiveMode;\n  return {\n    entityPath,\n    receiveMode,\n    options,\n  };\n}\n\n/**\n * Validates that the EntityPath in the connection string (if any) matches with the\n * queue or topic name passed to the methods that create senders and receivers.\n *\n * @internal\n */\nfunction validateEntityPath(connectionConfig: ConnectionConfig, queueOrTopicName: string): void {\n  if (connectionConfig.entityPath && connectionConfig.entityPath !== queueOrTopicName) {\n    throw new Error(entityPathMisMatchError);\n  }\n}\n"]}