{"version":3,"file":"serviceBusAtomManagementClient.js","sourceRoot":"","sources":["../../src/serviceBusAtomManagementClient.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAElC,OAAO,EAAE,SAAS,IAAI,aAAa,EAAE,qBAAqB,EAAE,MAAM,kBAAkB,CAAC;AAErF,OAAO,EAAE,iBAAiB,EAAE,oBAAoB,EAAE,MAAM,kBAAkB,CAAC;AAM3E,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAC;AAQnD,OAAO,EACL,+BAA+B,EAC/B,SAAS,EACT,yBAAyB,EACzB,qBAAqB,GACtB,MAAM,2BAA2B,CAAC;AAEnC,OAAO,EAAE,oBAAoB,IAAI,MAAM,EAAE,MAAM,UAAU,CAAC;AAE1D,OAAO,EACL,cAAc,EACd,2BAA2B,GAC5B,MAAM,8CAA8C,CAAC;AAOtD,OAAO,EACL,UAAU,EACV,iBAAiB,EACjB,2BAA2B,EAC3B,uBAAuB,GACxB,MAAM,0CAA0C,CAAC;AAOlD,OAAO,EACL,SAAS,EACT,eAAe,EACf,sBAAsB,GACvB,MAAM,yCAAyC,CAAC;AAOjD,OAAO,EACL,iBAAiB,EACjB,wBAAwB,EACxB,kCAAkC,EAClC,8BAA8B,GAC/B,MAAM,iDAAiD,CAAC;AAOzD,OAAO,EACL,UAAU,EACV,iBAAiB,EACjB,2BAA2B,EAC3B,uBAAuB,GACxB,MAAM,0CAA0C,CAAC;AAElD,OAAO,EAAE,uBAAuB,EAAE,MAAM,yBAAyB,CAAC;AAClE,OAAO,KAAK,SAAS,MAAM,qBAAqB,CAAC;AACjD,OAAO,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AAC9C,OAAO,EAAE,2BAA2B,EAAE,MAAM,uCAAuC,CAAC;AACpF,OAAO,EAAE,aAAa,EAAE,MAAM,0BAA0B,CAAC;AACzD,OAAO,EAAE,SAAS,EAAE,MAAM,kBAAkB,CAAC;AAE7C,OAAO,EACL,qBAAqB,EACrB,mBAAmB,EACnB,aAAa,EACb,gBAAgB,GACjB,MAAM,iBAAiB,CAAC;AAgDzB,SAAS,aAAa,CAAC,WAEtB;IACC,OAAO;QACL,IAAI,EAAE,eAAe;QACrB,KAAK,CAAC,WAAW,CAAC,OAAwB,EAAE,IAAiB;YAC3D,MAAM,MAAM,GAAG,MAAM,WAAW,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YACtD,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;QACtB,CAAC;KACF,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,MAAM,OAAO,8BAA+B,SAAQ,aAAa;IAqD/D,YACE,0CAAkD,EAClD,oBAGyC,EACzC,QAAgD;;QAEhD,IAAI,OAA8C,CAAC;QACnD,IAAI,uBAA+B,CAAC;QACpC,IAAI,WAA0D,CAAC;QAC/D,IAAI,UAA0B,CAAC;QAC/B,IAAI,MAAM,GAAY,IAAI,CAAC;QAC3B,IAAI,iBAAiB,CAAC,oBAAoB,CAAC,EAAE,CAAC;YAC5C,uBAAuB,GAAG,0CAA0C,CAAC;YACrE,OAAO,GAAG,QAAQ,IAAI,EAAE,CAAC;YACzB,WAAW,GAAG,oBAAoB,CAAC;YACnC,UAAU,GAAG,+BAA+B,CAAC;gBAC3C,UAAU,EAAE,WAAW;gBACvB,MAAM,EAAE,aAAa,CAAC,kBAAkB;aACzC,CAAC,CAAC;QACL,CAAC;aAAM,IAAI,oBAAoB,CAAC,oBAAoB,CAAC,EAAE,CAAC;YACtD,uBAAuB,GAAG,0CAA0C,CAAC;YACrE,WAAW,GAAG,IAAI,2BAA2B,CAAC,oBAAoB,CAAC,CAAC;YACpE,OAAO,GAAG,QAAQ,IAAI,EAAE,CAAC;YACzB,UAAU,GAAG,aAAa,CAAC,WAA0C,CAAC,CAAC;QACzE,CAAC;aAAM,CAAC;YACN,MAAM,gBAAgB,GAAG,0CAA0C,CAAC;YACpE,OAAO,GAAG,oBAAoB,IAAI,EAAE,CAAC;YACrC,MAAM,mBAAmB,GAAQ,qBAAqB,CAAC,gBAAgB,CAAC,CAAC;YACzE,IAAI,mBAAmB,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;gBAC/C,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC,CAAC;YAC5D,CAAC;YACD,IAAI,CAAC;gBACH,uBAAuB,GAAG,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;YAClF,CAAC;YAAC,WAAM,CAAC;gBACP,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC,CAAC;YACrE,CAAC;YACD,IAAI,mBAAmB,CAAC,sBAAsB,EAAE,CAAC;gBAC/C,MAAM,GAAG,KAAK,CAAC;YACjB,CAAC;YACD,WAAW,GAAG,IAAI,2BAA2B,CAAC;gBAC5C,GAAG,EAAE,mBAAmB,CAAC,eAAe;gBACxC,IAAI,EAAE,mBAAmB,CAAC,mBAAmB;aAC9C,CAAC,CAAC;YACH,UAAU,GAAG,aAAa,CAAC,WAA0C,CAAC,CAAC;QACzE,CAAC;QAED,MAAM,eAAe,GAAG,qBAAqB,CAAC,MAAA,OAAO,CAAC,gBAAgB,0CAAE,eAAe,CAAC,CAAC;QACzF,MAAM,oBAAoB,GAAG,yBAAyB,iCACjD,OAAO,KACV,gBAAgB,EAAE;gBAChB,eAAe;aAChB,IACD,CAAC;QACH,oBAAoB,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;QAC3C,KAAK,CAAC,EAAE,QAAQ,EAAE,oBAAoB,EAAE,CAAC,CAAC;QAC1C,IAAI,CAAC,QAAQ,GAAG,uBAAuB,CAAC;QACxC,IAAI,CAAC,oBAAoB,GAAG,uBAAuB,CAAC,QAAQ,CAAC,GAAG,CAAC;YAC/D,CAAC,CAAC,OAAO,GAAG,uBAAuB;YACnC,CAAC,CAAC,OAAO,GAAG,uBAAuB,GAAG,GAAG,CAAC;QAC5C,IAAI,CAAC,cAAc,GAAG,MAAA,OAAO,CAAC,cAAc,mCAAI,SAAS,CAAC,mBAAmB,CAAC;QAC9E,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,2BAA2B,GAAG,IAAI,2BAA2B,EAAE,CAAC;QACrE,IAAI,CAAC,uBAAuB,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAC7D,IAAI,CAAC,uBAAuB,GAAG,IAAI,uBAAuB,EAAE,CAAC;QAC7D,IAAI,CAAC,8BAA8B,GAAG,IAAI,8BAA8B,EAAE,CAAC;QAC3E,IAAI,CAAC,sBAAsB,GAAG,IAAI,sBAAsB,EAAE,CAAC;IAC7D,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,sBAAsB,CAC1B,mBAAqC,EAAE;QAEvC,MAAM,CAAC,OAAO,CAAC,4DAA4D,CAAC,CAAC;QAE7E,OAAO,aAAa,CAAC,QAAQ,CAC3B,uDAAuD,EACvD,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,gBAAgB,EAChB,IAAI,CAAC,2BAA2B,EAChC,cAAc,CACf,CAAC;YACF,OAAO,IAAI,CAAC,gCAAgC,CAAC,QAAQ,CAAC,CAAC;QACzD,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,KAAK,CAAC,WAAW,CACf,SAAiB,EACjB,UAA8B,EAAE;QAEhC,OAAO,aAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAC5C,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,wDAAwD,SAAS,oBAAoB,EACrF,OAAO,CACR,CAAC;YACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,SAAS,EACT,iBAAiB,CAAC,OAAO,IAAI,EAAE,CAAC,EAChC,IAAI,CAAC,uBAAuB,EAC5B,KAAK,EACL,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC3C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;OAaG;IACH,KAAK,CAAC,QAAQ,CACZ,SAAiB,EACjB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,yCAAyC,EACzC,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,qDAAqD,SAAS,GAAG,CAAC,CAAC;YAClF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC3C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,yBAAyB,CAC7B,SAAiB,EACjB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,0DAA0D,EAC1D,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,sEAAsE,SAAS,GAAG,CACnF,CAAC;YACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,mCAAmC,CAAC,QAAQ,CAAC,CAAC;QAC5D,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACK,KAAK,CAAC,SAAS,CACrB,UAAiD,EAAE;QAEnD,OAAO,aAAa,CAAC,QAAQ,CAC3B,0CAA0C,EAC1C,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,gEAAgE,EAAE,OAAO,CAAC,CAAC;YAC1F,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CACvC,mBAAmB,EACnB,cAAc,EACd,IAAI,CAAC,uBAAuB,CAC7B,CAAC;YAEF,OAAO,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QAChD,CAAC,CACF,CAAC;IACJ,CAAC;IAEc,cAAc;4EAC3B,MAAe,EACf,UAAgE,EAAE;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG,CAAC;gBACF,YAAY,GAAG,cAAM,IAAI,CAAC,SAAS,iBACjC,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,oBAAM,YAAY,CAAA,CAAC;YACrB,CAAC,QAAQ,MAAM,EAAE;QACnB,CAAC;KAAA;IAEc,aAAa;2EAC1B,UAA4B,EAAE;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,eAAA,KAAA,cAAA,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA,+DAAE,CAAC;oBAAvC,cAAoC;oBAApC,WAAoC;oBAArD,MAAM,OAAO,KAAA,CAAA;oBACtB,cAAA,KAAK,CAAC,CAAC,iBAAA,cAAA,OAAO,CAAA,CAAA,CAAA,CAAC;gBACjB,CAAC;;;;;;;;;QACH,CAAC;KAAA;IAED;;;;;;OAMG;IACI,UAAU,CACf,OAA0B;QAE1B,MAAM,CAAC,OAAO,CAAC,iEAAiE,EAAE,OAAO,CAAC,CAAC;QAC3F,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QACzC,OAAO;YACL;eACG;YACH,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;YACrB,CAAC;YACD;eACG;YACH,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;YACd,CAAC;YACD;eACG;YACH,MAAM,EAAE,CAAC,WAAyB,EAAE,EAAE,EAAE;gBACtC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,iBAAiB,kBACnD,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;YACL,CAAC;SACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;OAWG;IACK,KAAK,CAAC,0BAA0B,CACtC,UAAiD,EAAE;QAEnD,OAAO,aAAa,CAAC,QAAQ,CAC3B,2DAA2D,EAC3D,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,iFAAiF,EACjF,OAAO,CACR,CAAC;YACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CACvC,mBAAmB,EACnB,cAAc,EACd,IAAI,CAAC,uBAAuB,CAC7B,CAAC;YAEF,OAAO,IAAI,CAAC,wCAAwC,CAAC,QAAQ,CAAC,CAAC;QACjE,CAAC,CACF,CAAC;IACJ,CAAC;IAEc,+BAA+B;6FAC5C,MAAe,EACf,UAAgE,EAAE;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG,CAAC;gBACF,YAAY,GAAG,cAAM,IAAI,CAAC,0BAA0B,iBAClD,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,oBAAM,YAAY,CAAA,CAAC;YACrB,CAAC,QAAQ,MAAM,EAAE;QACnB,CAAC;KAAA;IAEc,8BAA8B;4FAC3C,UAA4B,EAAE;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,eAAA,KAAA,cAAA,IAAI,CAAC,+BAA+B,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA,+DAAE,CAAC;oBAAxD,cAAqD;oBAArD,WAAqD;oBAAtE,MAAM,OAAO,KAAA,CAAA;oBACtB,cAAA,KAAK,CAAC,CAAC,iBAAA,cAAA,OAAO,CAAA,CAAA,CAAA,CAAC;gBACjB,CAAC;;;;;;;;;QACH,CAAC;KAAA;IAED;;;;;;;OAOG;IACI,2BAA2B,CAChC,OAA0B;QAE1B,MAAM,CAAC,OAAO,CACZ,kFAAkF,EAClF,OAAO,CACR,CAAC;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,8BAA8B,CAAC,OAAO,CAAC,CAAC;QAC1D,OAAO;YACL;eACG;YACH,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;YACrB,CAAC;YACD;eACG;YACH,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;YACd,CAAC;YACD;eACG;YACH,MAAM,EAAE,CAAC,WAAyB,EAAE,EAAE,EAAE;gBACtC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,kBACpE,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;YACL,CAAC;SACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACH,KAAK,CAAC,WAAW,CACf,KAAoC,EACpC,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAC5C,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,wDAAwD,KAAK,CAAC,IAAI,oBAAoB,EACtF,KAAK,CACN,CAAC;YAEF,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;gBAC9C,MAAM,IAAI,SAAS,CACjB,iGAAiG,CAClG,CAAC;YACJ,CAAC;YAED,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;gBAChB,MAAM,IAAI,SAAS,CAAC,gEAAgE,CAAC,CAAC;YACxF,CAAC;YAED,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,KAAK,CAAC,IAAI,EACV,iBAAiB,CAAC,KAAK,CAAC,EACxB,IAAI,CAAC,uBAAuB,EAC5B,IAAI,EACJ,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC3C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,WAAW,CACf,SAAiB,EACjB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAC5C,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,wDAAwD,SAAS,GAAG,CAAC,CAAC;YACrF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,CACxC,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,cAAc,CACf,CAAC;YAEF,OAAO,EAAE,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC;QACtD,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,WAAW,CAAC,SAAiB,EAAE,mBAAqC,EAAE;QAC1E,MAAM,CAAC,OAAO,CAAC,wDAAwD,SAAS,GAAG,CAAC,CAAC;QACrF,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,aAAa,CAAC,SAAS,CACtD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;QACF,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;YAC/C,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC;YACtC,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;YAC9C,OAAO,KAAK,CAAC;QACf,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,KAAK,CAAC,WAAW,CACf,SAAiB,EACjB,UAA8B,EAAE;QAEhC,OAAO,aAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAC5C,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,wDAAwD,SAAS,oBAAoB,EACrF,OAAO,CACR,CAAC;YACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,SAAS,EACT,iBAAiB,CAAC,OAAO,IAAI,EAAE,CAAC,EAChC,IAAI,CAAC,uBAAuB,EAC5B,KAAK,EACL,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC3C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;OAaG;IACH,KAAK,CAAC,QAAQ,CACZ,SAAiB,EACjB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,yCAAyC,EACzC,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,qDAAqD,SAAS,GAAG,CAAC,CAAC;YAClF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC3C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,yBAAyB,CAC7B,SAAiB,EACjB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,0DAA0D,EAC1D,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,sEAAsE,SAAS,GAAG,CACnF,CAAC;YACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,mCAAmC,CAAC,QAAQ,CAAC,CAAC;QAC5D,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACK,KAAK,CAAC,SAAS,CACrB,UAAiD,EAAE;QAEnD,OAAO,aAAa,CAAC,QAAQ,CAC3B,0CAA0C,EAC1C,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,gEAAgE,EAAE,OAAO,CAAC,CAAC;YAC1F,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CACvC,mBAAmB,EACnB,cAAc,EACd,IAAI,CAAC,uBAAuB,CAC7B,CAAC;YAEF,OAAO,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,CAAC;QAChD,CAAC,CACF,CAAC;IACJ,CAAC;IAEc,cAAc;4EAC3B,MAAe,EACf,UAAgE,EAAE;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG,CAAC;gBACF,YAAY,GAAG,cAAM,IAAI,CAAC,SAAS,iBACjC,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,oBAAM,YAAY,CAAA,CAAC;YACrB,CAAC,QAAQ,MAAM,EAAE;QACnB,CAAC;KAAA;IAEc,aAAa;2EAC1B,UAA4B,EAAE;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,eAAA,KAAA,cAAA,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA,+DAAE,CAAC;oBAAvC,cAAoC;oBAApC,WAAoC;oBAArD,MAAM,OAAO,KAAA,CAAA;oBACtB,cAAA,KAAK,CAAC,CAAC,iBAAA,cAAA,OAAO,CAAA,CAAA,CAAA,CAAC;gBACjB,CAAC;;;;;;;;;QACH,CAAC;KAAA;IAED;;;;;;;OAOG;IACI,UAAU,CACf,OAA0B;QAE1B,MAAM,CAAC,OAAO,CAAC,iEAAiE,EAAE,OAAO,CAAC,CAAC;QAC3F,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QACzC,OAAO;YACL;eACG;YACH,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;YACrB,CAAC;YACD;eACG;YACH,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;YACd,CAAC;YACD;eACG;YACH,MAAM,EAAE,CAAC,WAAyB,EAAE,EAAE,EAAE;gBACtC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,iBAAiB,kBACnD,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;YACL,CAAC;SACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;OAWG;IACK,KAAK,CAAC,0BAA0B,CACtC,UAAiD,EAAE;QAEnD,OAAO,aAAa,CAAC,QAAQ,CAC3B,2DAA2D,EAE3D,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,iFAAiF,EACjF,OAAO,CACR,CAAC;YACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CACvC,mBAAmB,EACnB,cAAc,EACd,IAAI,CAAC,uBAAuB,CAC7B,CAAC;YAEF,OAAO,IAAI,CAAC,wCAAwC,CAAC,QAAQ,CAAC,CAAC;QACjE,CAAC,CACF,CAAC;IACJ,CAAC;IAEc,+BAA+B;6FAC5C,MAAe,EACf,UAAgE,EAAE;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG,CAAC;gBACF,YAAY,GAAG,cAAM,IAAI,CAAC,0BAA0B,iBAClD,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,oBAAM,YAAY,CAAA,CAAC;YACrB,CAAC,QAAQ,MAAM,EAAE;QACnB,CAAC;KAAA;IAEc,8BAA8B;4FAC3C,UAA4B,EAAE;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,eAAA,KAAA,cAAA,IAAI,CAAC,+BAA+B,CAAC,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA,+DAAE,CAAC;oBAAxD,cAAqD;oBAArD,WAAqD;oBAAtE,MAAM,OAAO,KAAA,CAAA;oBACtB,cAAA,KAAK,CAAC,CAAC,iBAAA,cAAA,OAAO,CAAA,CAAA,CAAA,CAAC;gBACjB,CAAC;;;;;;;;;QACH,CAAC;KAAA;IAED;;;;;;;OAOG;IACI,2BAA2B,CAChC,OAA0B;QAE1B,MAAM,CAAC,OAAO,CACZ,kFAAkF,EAClF,OAAO,CACR,CAAC;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,8BAA8B,CAAC,OAAO,CAAC,CAAC;QAC1D,OAAO;YACL;;eAEG;YACH,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;YACrB,CAAC;YACD;;eAEG;YACH,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;YACd,CAAC;YACD;;eAEG;YACH,MAAM,EAAE,CAAC,WAAyB,EAAE,EAAE,EAAE;gBACtC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,kBACpE,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;YACL,CAAC;SACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;;;;;;OAmBG;IACH,KAAK,CAAC,WAAW,CACf,KAAoC,EACpC,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAE5C,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,wDAAwD,KAAK,CAAC,IAAI,oBAAoB,EACtF,KAAK,CACN,CAAC;YAEF,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,EAAE,CAAC;gBAC9C,MAAM,IAAI,SAAS,CACjB,iGAAiG,CAClG,CAAC;YACJ,CAAC;YAED,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;gBAChB,MAAM,IAAI,SAAS,CAAC,gEAAgE,CAAC,CAAC;YACxF,CAAC;YAED,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,KAAK,CAAC,IAAI,EACV,iBAAiB,CAAC,KAAK,CAAC,EACxB,IAAI,CAAC,uBAAuB,EAC5B,IAAI,EACJ,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QAC3C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,WAAW,CACf,SAAiB,EACjB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAC5C,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,wDAAwD,SAAS,GAAG,CAAC,CAAC;YACrF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,CACxC,SAAS,EACT,IAAI,CAAC,uBAAuB,EAC5B,cAAc,CACf,CAAC;YAEF,OAAO,EAAE,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC;QACtD,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,WAAW,CAAC,SAAiB,EAAE,gBAAmC;QACtE,MAAM,CAAC,OAAO,CAAC,wDAAwD,SAAS,GAAG,CAAC,CAAC;QACrF,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,aAAa,CAAC,SAAS,CACtD,4CAA4C,EAC5C,gBAAgB,CACjB,CAAC;QACF,IAAI,CAAC;YACH,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC;YACtC,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;YAC/C,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;YAC9C,OAAO,KAAK,CAAC;QACf,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,KAAK,CAAC,kBAAkB,CACtB,SAAiB,EACjB,gBAAwB,EACxB,UAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,mDAAmD,EACnD,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,+DAA+D,gBAAgB,oBAAoB,EACnG,OAAO,CACR,CAAC;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;YACvE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,QAAQ,EACR,wBAAwB,CAAC,OAAO,IAAI,EAAE,CAAC,EACvC,IAAI,CAAC,8BAA8B,EACnC,KAAK,EACL,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;QAClD,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;OAaG;IACH,KAAK,CAAC,eAAe,CACnB,SAAiB,EACjB,gBAAwB,EACxB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,gDAAgD,EAChD,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,4DAA4D,gBAAgB,GAAG,CAChF,CAAC;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;YACvE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,QAAQ,EACR,IAAI,CAAC,8BAA8B,EACnC,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;QAClD,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,gCAAgC,CACpC,SAAiB,EACjB,gBAAwB,EACxB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,iEAAiE,EACjE,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,6EAA6E,gBAAgB,GAAG,CACjG,CAAC;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;YACvE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,QAAQ,EACR,IAAI,CAAC,8BAA8B,EACnC,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,0CAA0C,CAAC,QAAQ,CAAC,CAAC;QACnE,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACK,KAAK,CAAC,gBAAgB,CAC5B,SAAiB,EACjB,UAAiD,EAAE;QAEnD,OAAO,aAAa,CAAC,QAAQ,CAC3B,iDAAiD,EACjD,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,uEAAuE,EACvE,OAAO,CACR,CAAC;YACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CACvC,SAAS,GAAG,iBAAiB,EAC7B,cAAc,EACd,IAAI,CAAC,8BAA8B,CACpC,CAAC;YAEF,OAAO,IAAI,CAAC,8BAA8B,CAAC,QAAQ,CAAC,CAAC;QACvD,CAAC,CACF,CAAC;IACJ,CAAC;IAEc,qBAAqB;mFAClC,SAAiB,EACjB,MAAe,EACf,UAAgE,EAAE;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG,CAAC;gBACF,YAAY,GAAG,cAAM,IAAI,CAAC,gBAAgB,CAAC,SAAS,kBAClD,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,oBAAM,YAAY,CAAA,CAAC;YACrB,CAAC,QAAQ,MAAM,EAAE;QACnB,CAAC;KAAA;IAEc,oBAAoB;kFACjC,SAAiB,EACjB,UAA4B,EAAE;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,eAAA,KAAA,cAAA,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA,+DAAE,CAAC;oBAAzD,cAAsD;oBAAtD,WAAsD;oBAAvE,MAAM,OAAO,KAAA,CAAA;oBACtB,cAAA,KAAK,CAAC,CAAC,iBAAA,cAAA,OAAO,CAAA,CAAA,CAAA,CAAC;gBACjB,CAAC;;;;;;;;;QACH,CAAC;KAAA;IAED;;;;;;;;OAQG;IACI,iBAAiB,CACtB,SAAiB,EACjB,OAA0B;QAE1B,MAAM,CAAC,OAAO,CACZ,wEAAwE,EACxE,OAAO,CACR,CAAC;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,oBAAoB,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAC3D,OAAO;YACL;eACG;YACH,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;YACrB,CAAC;YACD;eACG;YACH,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;YACd,CAAC;YACD;eACG;YACH,MAAM,EAAE,CAAC,WAAyB,EAAE,EAAE,EAAE;gBACtC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,qBAAqB,CAAC,SAAS,EAAE,QAAQ,CAAC,iBAAiB,kBACrE,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;YACL,CAAC;SACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;OAWG;IACK,KAAK,CAAC,iCAAiC,CAC7C,SAAiB,EACjB,UAAiD,EAAE;QAEnD,OAAO,aAAa,CAAC,QAAQ,CAC3B,kEAAkE,EAClE,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,wFAAwF,EACxF,OAAO,CACR,CAAC;YACF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CACvC,SAAS,GAAG,iBAAiB,EAC7B,cAAc,EACd,IAAI,CAAC,8BAA8B,CACpC,CAAC;YAEF,OAAO,IAAI,CAAC,+CAA+C,CAAC,QAAQ,CAAC,CAAC;QACxE,CAAC,CACF,CAAC;IACJ,CAAC;IAEc,sCAAsC;oGACnD,SAAiB,EACjB,MAAe,EACf,UAAgE,EAAE;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG,CAAC;gBACF,YAAY,GAAG,cAAM,IAAI,CAAC,iCAAiC,CAAC,SAAS,kBACnE,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,oBAAM,YAAY,CAAA,CAAC;YACrB,CAAC,QAAQ,MAAM,EAAE;QACnB,CAAC;KAAA;IAEc,qCAAqC;mGAClD,SAAiB,EACjB,UAA4B,EAAE;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,eAAA,KAAA,cAAA,IAAI,CAAC,sCAAsC,CACrE,SAAS,EACT,MAAM,EACN,OAAO,CACR,CAAA,IAAA,+DAAE,CAAC;oBAJwB,cAI3B;oBAJ2B,WAI3B;oBAJU,MAAM,OAAO,KAAA,CAAA;oBAKtB,cAAA,KAAK,CAAC,CAAC,iBAAA,cAAA,OAAO,CAAA,CAAA,CAAA,CAAC;gBACjB,CAAC;;;;;;;;;QACH,CAAC;KAAA;IAED;;;;;;;OAOG;IACI,kCAAkC,CACvC,SAAiB,EACjB,OAA0B;QAK1B,MAAM,CAAC,OAAO,CACZ,yFAAyF,EACzF,OAAO,CACR,CAAC;QACF,MAAM,IAAI,GAAG,IAAI,CAAC,qCAAqC,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAC5E,OAAO;YACL;eACG;YACH,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;YACrB,CAAC;YACD;eACG;YACH,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;YACd,CAAC;YACD;eACG;YACH,MAAM,EAAE,CAAC,WAAyB,EAAE,EAAE,EAAE;gBACtC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,sCAAsC,CAAC,SAAS,EAAE,QAAQ,CAAC,iBAAiB,kBACtF,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;YACL,CAAC;SACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;;;;;OAkBG;IACH,KAAK,CAAC,kBAAkB,CACtB,YAAkD,EAClD,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,mDAAmD,EAEnD,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,+DAA+D,YAAY,CAAC,gBAAgB,oBAAoB,EAChH,YAAY,CACb,CAAC;YAEF,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,IAAI,YAAY,IAAI,IAAI,EAAE,CAAC;gBAC5D,MAAM,IAAI,SAAS,CACjB,+GAA+G,CAChH,CAAC;YACJ,CAAC;YAED,IAAI,CAAC,YAAY,CAAC,SAAS,IAAI,CAAC,YAAY,CAAC,gBAAgB,EAAE,CAAC;gBAC9D,MAAM,IAAI,SAAS,CACjB,wGAAwG,CACzG,CAAC;YACJ,CAAC;YAED,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CACvC,YAAY,CAAC,SAAS,EACtB,YAAY,CAAC,gBAAgB,CAC9B,CAAC;YAEF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,QAAQ,EACR,wBAAwB,CAAC,YAAY,CAAC,EACtC,IAAI,CAAC,8BAA8B,EACnC,IAAI,EACJ,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;QAClD,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,kBAAkB,CACtB,SAAiB,EACjB,gBAAwB,EACxB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,mDAAmD,EAEnD,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,+DAA+D,gBAAgB,GAAG,CACnF,CAAC;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;YACvE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,CACxC,QAAQ,EACR,IAAI,CAAC,8BAA8B,EACnC,cAAc,CACf,CAAC;YAEF,OAAO,EAAE,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC;QACtD,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,kBAAkB,CACtB,SAAiB,EACjB,gBAAwB,EACxB,mBAAqC,EAAE;QAEvC,MAAM,CAAC,OAAO,CACZ,+DAA+D,SAAS,UAAU,gBAAgB,GAAG,CACtG,CAAC;QACF,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,aAAa,CAAC,SAAS,CACtD,mDAAmD,EACnD,gBAAgB,CACjB,CAAC;QACF,IAAI,CAAC;YACH,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC;YACtC,MAAM,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,gBAAgB,EAAE,cAAc,CAAC,CAAC;YACxE,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;YAC9C,OAAO,KAAK,CAAC;QACf,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAgDD,KAAK,CAAC,UAAU,CACd,SAAiB,EACjB,gBAAwB,EACxB,QAAgB,EAChB,UAAiD,EACjD,4BAA+D,EAC/D,gBAAmC;QAEnC,IAAI,UAAU,GAA8B,SAAS,CAAC;QACtD,IAAI,WAAyC,CAAC;QAC9C,IAAI,4BAA4B,EAAE,CAAC;YACjC,IAAI,eAAe,CAAC,4BAA4B,CAAC,EAAE,CAAC;gBAClD,oEAAoE;gBACpE,UAAU,GAAG,4BAA4B,CAAC;gBAC1C,WAAW,GAAG,gBAAgB,CAAC;YACjC,CAAC;iBAAM,CAAC;gBACN,aAAa;gBACb,sEAAsE;gBACtE,WAAW,mCAAQ,4BAA4B,GAAK,gBAAgB,CAAE,CAAC;YACzE,CAAC;QACH,CAAC;QAED,OAAO,aAAa,CAAC,QAAQ,CAC3B,2CAA2C,EAC3C,WAAW,aAAX,WAAW,cAAX,WAAW,GAAI,EAAE,EACjB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,uDAAuD,QAAQ,qBAAqB,EACpF,UAAU,CACX,CAAC;YACF,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,CAAC,CAAC;YACzE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,QAAQ,EACR,EAAE,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,EAC1D,IAAI,CAAC,sBAAsB,EAC3B,KAAK,EACL,cAAc,CACf,CAAC;YACF,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAC1C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,OAAO,CACX,SAAiB,EACjB,gBAAwB,EACxB,QAAgB,EAChB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,wCAAwC,EACxC,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,oDAAoD,QAAQ,GAAG,CAAC,CAAC;YAChF,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,CAAC,CAAC;YACzE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,QAAQ,EACR,IAAI,CAAC,sBAAsB,EAC3B,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAC1C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;OAWG;IACK,KAAK,CAAC,QAAQ,CACpB,SAAiB,EACjB,gBAAwB,EACxB,UAAiD,EAAE;QAEnD,OAAO,aAAa,CAAC,QAAQ,CAC3B,yCAAyC,EAEzC,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,+DAA+D,EAAE,OAAO,CAAC,CAAC;YACzF,MAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,gBAAgB,CAAC,GAAG,SAAS,CAAC;YACnF,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,aAAa,CACvC,QAAQ,EACR,cAAc,EACd,IAAI,CAAC,sBAAsB,CAC5B,CAAC;YAEF,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;QAC/C,CAAC,CACF,CAAC;IACJ,CAAC;IAEc,aAAa;2EAC1B,SAAiB,EACjB,gBAAwB,EACxB,MAAe,EACf,UAAgE,EAAE;YAElE,IAAI,YAAY,CAAC;YACjB,GAAG,CAAC;gBACF,YAAY,GAAG,cAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,gBAAgB,kBAC5D,IAAI,EAAE,MAAM,CAAC,MAAM,CAAC,EACpB,QAAQ,EAAE,OAAO,CAAC,WAAW,IAC1B,OAAO,EACV,CAAA,CAAC;gBACH,MAAM,GAAG,YAAY,CAAC,iBAAiB,CAAC;gBACxC,oBAAM,YAAY,CAAA,CAAC;YACrB,CAAC,QAAQ,MAAM,EAAE;QACnB,CAAC;KAAA;IAEc,YAAY;0EACzB,SAAiB,EACjB,gBAAwB,EACxB,UAA4B,EAAE;;YAE9B,IAAI,MAA0B,CAAC;;gBAC/B,KAA4B,eAAA,KAAA,cAAA,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,gBAAgB,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA,IAAA,+DAAE,CAAC;oBAAnE,cAAgE;oBAAhE,WAAgE;oBAAjF,MAAM,OAAO,KAAA,CAAA;oBACtB,cAAA,KAAK,CAAC,CAAC,iBAAA,cAAA,OAAO,CAAA,CAAA,CAAA,CAAC;gBACjB,CAAC;;;;;;;;;QACH,CAAC;KAAA;IAED;;;;;;;OAOG;IACI,SAAS,CACd,SAAiB,EACjB,gBAAwB,EACxB,OAA0B;QAE1B,MAAM,CAAC,OAAO,CAAC,gEAAgE,EAAE,OAAO,CAAC,CAAC;QAC1F,MAAM,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,EAAE,gBAAgB,EAAE,OAAO,CAAC,CAAC;QACrE,OAAO;YACL;eACG;YACH,IAAI;gBACF,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC;YACrB,CAAC;YACD;eACG;YACH,CAAC,MAAM,CAAC,aAAa,CAAC;gBACpB,OAAO,IAAI,CAAC;YACd,CAAC;YACD;eACG;YACH,MAAM,EAAE,CAAC,WAAyB,EAAE,EAAE,EAAE;gBACtC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC;gBACjE,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,CAAC,iBAAiB,kBAC/E,WAAW,EAAE,QAAQ,CAAC,WAAW,IAC9B,OAAO,EACV,CAAC;YACL,CAAC;SACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;;;;OAiBG;IACH,KAAK,CAAC,UAAU,CACd,SAAiB,EACjB,gBAAwB,EACxB,IAAkC,EAClC,gBAAmC;QAEnC,OAAO,aAAa,CAAC,QAAQ,CAC3B,2CAA2C,EAC3C,gBAAgB,aAAhB,gBAAgB,cAAhB,gBAAgB,GAAI,EAAE,EACtB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CACZ,uDAAuD,IAAI,CAAC,IAAI,oBAAoB,EACpF,IAAI,CACL,CAAC;YAEF,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,IAAI,KAAK,IAAI,EAAE,CAAC;gBAC7C,MAAM,IAAI,SAAS,CACjB,+FAA+F,CAChG,CAAC;YACJ,CAAC;YAED,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;gBACf,MAAM,IAAI,SAAS,CAAC,+DAA+D,CAAC,CAAC;YACvF,CAAC;YAED,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1E,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,WAAW,CACrC,QAAQ,EACR,IAAI,EACJ,IAAI,CAAC,sBAAsB,EAC3B,IAAI,EACJ,cAAc,CACf,CAAC;YAEF,OAAO,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAC1C,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,KAAK,CAAC,UAAU,CACd,SAAiB,EACjB,gBAAwB,EACxB,QAAgB,EAChB,gBAAmC;QAEnC,OAAO,aAAa,CAAC,QAAQ,CAC3B,2CAA2C,EAC3C,gBAAgB,aAAhB,gBAAgB,cAAhB,gBAAgB,GAAI,EAAE,EACtB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,CAAC,OAAO,CAAC,uDAAuD,QAAQ,GAAG,CAAC,CAAC;YACnF,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,CAAC,CAAC;YACzE,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,cAAc,CACxC,QAAQ,EACR,IAAI,CAAC,sBAAsB,EAC3B,cAAc,CACf,CAAC;YAEF,OAAO,EAAE,SAAS,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CAAC;QACtD,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,UAAU,CACd,SAAiB,EACjB,gBAAwB,EACxB,QAAgB,EAChB,mBAAqC,EAAE;QAEvC,MAAM,CAAC,OAAO,CAAC,uDAAuD,QAAQ,GAAG,CAAC,CAAC;QACnF,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,aAAa,CAAC,SAAS,CACtD,2CAA2C,EAC3C,gBAAgB,CACjB,CAAC;QACF,IAAI,CAAC;YACH,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC,CAAC;YACtC,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,gBAAgB,EAAE,QAAQ,EAAE,cAAc,CAAC,CAAC;YAC1E,OAAO,IAAI,CAAC;QACd,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC;YAC9C,OAAO,KAAK,CAAC;QACf,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,WAAW,CACvB,IAAY,EACZ,YAIqB,EACrB,UAA6B,EAC7B,WAAoB,KAAK,EACzB,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAC5C,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,OAAO,GAAoB,qBAAqB,CAAC;gBACrD,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACtB,MAAM,EAAE,KAAK;gBACb,uBAAuB,EAAE,CAAC,IAAI,CAAC,MAAM;aACtC,CAAC,CAAC;YACH,IAAI,QAAQ,EAAE,CAAC;gBACb,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;YACvC,CAAC;YAED,MAAM,yBAAyB,GAAG,YAEH,CAAC;YAChC,IACE,yBAAyB,CAAC,SAAS;gBACnC,yBAAyB,CAAC,6BAA6B,EACvD,CAAC;gBACD,MAAM,KAAK,GACT,IAAI,CAAC,WAAW,YAAY,2BAA2B;oBACrD,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK;oBACxD,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC,aAAa,CAAC,kBAAkB,CAAC,CAAC,CAAE,CAAC,KAAK,CAAC;gBAEnF,IAAI,yBAAyB,CAAC,SAAS,EAAE,CAAC;oBACxC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,sCAAsC,EAAE,KAAK,CAAC,CAAC;oBACnE,IAAI,CAAC,aAAa,CAAC,yBAAyB,CAAC,SAAS,CAAC,EAAE,CAAC;wBACxD,yBAAyB,CAAC,SAAS,GAAG,IAAI,CAAC,oBAAoB,CAAC,MAAM,CACpE,yBAAyB,CAAC,SAAS,CACpC,CAAC;oBACJ,CAAC;gBACH,CAAC;gBACD,IAAI,yBAAyB,CAAC,6BAA6B,EAAE,CAAC;oBAC5D,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,yCAAyC,EAAE,KAAK,CAAC,CAAC;oBACtE,IAAI,CAAC,aAAa,CAAC,yBAAyB,CAAC,6BAA6B,CAAC,EAAE,CAAC;wBAC5E,yBAAyB,CAAC,6BAA6B;4BACrD,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAC9B,yBAAyB,CAAC,6BAA6B,CACxD,CAAC;oBACN,CAAC;gBACH,CAAC;YACH,CAAC;YAED,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,EAAE,+CAA+C,CAAC,CAAC;YAErF,OAAO,uBAAuB,CAAC,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,EAAE,YAAY,CAAC,CAAC;QAC1F,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,WAAW,CACvB,IAAY,EACZ,UAA6B,EAC7B,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAC5C,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,OAAO,GAAG,qBAAqB,CAAC;gBACpC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACtB,MAAM,EAAE,KAAK;gBACb,uBAAuB,EAAE,CAAC,IAAI,CAAC,MAAM;aACtC,CAAC,CAAC;YAEH,MAAM,QAAQ,GAAG,MAAM,uBAAuB,CAAC,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,CAAC,CAAC;YAC1F,IACE,CAAC,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC;gBAC/B,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC,EACxE,CAAC;gBACD,MAAM,GAAG,GAAG,IAAI,SAAS,CACvB,yBAAyB,IAAI,oCAAoC,EACjE;oBACE,IAAI,EAAE,4BAA4B;oBAClC,UAAU,EAAE,QAAQ,CAAC,MAAM;oBAC3B,OAAO;oBACP,QAAQ;iBACT,CACF,CAAC;gBACF,MAAM,GAAG,CAAC;YACZ,CAAC;YACD,OAAO,QAAQ,CAAC;QAClB,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,aAAa,CACzB,IAAY,EACZ,UAAiD,EAAE,EACnD,UAA6B;QAE7B,OAAO,aAAa,CAAC,QAAQ,CAC3B,8CAA8C,EAC9C,OAAO,EACP,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,WAAW,GAA8B,EAAE,CAAC;YAClD,IAAI,OAAO,EAAE,CAAC;gBACZ,IAAI,OAAO,CAAC,IAAI,EAAE,CAAC;oBACjB,WAAW,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACjD,CAAC;gBACD,IAAI,OAAO,CAAC,QAAQ,EAAE,CAAC;oBACrB,WAAW,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC;gBACpD,CAAC;YACH,CAAC;YAED,MAAM,OAAO,GAAG,qBAAqB,CAAC;gBACpC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,WAAW,CAAC;gBACnC,MAAM,EAAE,KAAK;gBACb,uBAAuB,EAAE,CAAC,IAAI,CAAC,MAAM;aACtC,CAAC,CAAC;YAEH,OAAO,uBAAuB,CAAC,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,CAAC,CAAC;QAC5E,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,cAAc,CAC1B,IAAY,EACZ,UAA6B,EAC7B,mBAAqC,EAAE;QAEvC,OAAO,aAAa,CAAC,QAAQ,CAC3B,+CAA+C,EAC/C,gBAAgB,EAChB,KAAK,EAAE,cAAc,EAAE,EAAE;YACvB,MAAM,OAAO,GAAG,qBAAqB,CAAC;gBACpC,GAAG,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACtB,MAAM,EAAE,QAAQ;gBAChB,uBAAuB,EAAE,CAAC,IAAI,CAAC,MAAM;aACtC,CAAC,CAAC;YACH,OAAO,uBAAuB,CAAC,IAAI,EAAE,OAAO,EAAE,UAAU,EAAE,cAAc,CAAC,CAAC;QAC5E,CAAC,CACF,CAAC;IACJ,CAAC;IAEO,MAAM,CAAC,IAAY,EAAE,WAAuC;QAClE,MAAM,OAAO,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,MAAM,IAAI,CAAC,QAAQ,IAAI,IAAI,EAAE,CAAC;QAE/E,MAAM,UAAU,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC;QACpC,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,SAAS,CAAC,qBAAqB,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAElF,IAAI,WAAW,EAAE,CAAC;YAChB,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC;gBAC3C,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;YACrD,CAAC;QACH,CAAC;QAED,OAAO,UAAU,CAAC,QAAQ,EAAE,CAAC;IAC/B,CAAC;IAEO,mBAAmB,CAAC,SAAiB,EAAE,gBAAwB;QACrE,OAAO,SAAS,GAAG,iBAAiB,GAAG,gBAAgB,CAAC;IAC1D,CAAC;IAEO,WAAW,CAAC,SAAiB,EAAE,gBAAwB,EAAE,QAAgB;QAC/E,OAAO,SAAS,GAAG,iBAAiB,GAAG,gBAAgB,GAAG,SAAS,GAAG,QAAQ,CAAC;IACjF,CAAC;IAEO,wBAAwB,CAAC,GAAW;QAC1C,IAAI,CAAC,GAAG,EAAE,CAAC;YACT,OAAO,SAAS,CAAC;QACnB,CAAC;QACD,IAAI,CAAC;YACH,MAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,YAAY,CAAC,GAAG,CAAC,SAAS,CAAC,mBAAmB,GAAG,MAAM,CAAC,CAAC;YACrF,OAAO,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC;QAC5C,CAAC;QAAC,OAAO,KAAU,EAAE,CAAC;YACpB,MAAM,IAAI,KAAK,CACb,wBAAwB,SAAS,CAAC,mBAAmB,2CAA2C;gBAC9F,KAAK,CACR,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,gCAAgC,CACtC,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,SAAS,GAAG,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YACtD,MAAM,iBAAiB,GAAsC,MAAM,CAAC,cAAc,CAChF,SAAS,IAAI,EAAE,EACf,WAAW,EACX,EAAE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC,EAAE,CACJ,CAAC;YACvC,OAAO,iBAAiB,CAAC;QAC3B,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,sHAAsH,EACtH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,uBAAuB,CAC7B,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,MAAM,GAAsB,EAAE,CAAC;YACrC,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;gBACxC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;YACjF,CAAC;YACD,MAAM,aAAa,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC9C,MAAM,KAAK,GAAG,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC3C,IAAI,KAAK,EAAE,CAAC;oBACV,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACrB,CAAC;YACH,CAAC;YACD,MAAM,kBAAkB,GAAsC,MAAM,CAAC,cAAc,CACjF,MAAM,EACN,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACmC,CAAC;YACvC,kBAAkB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClD,OAAO,kBAAkB,CAAC;QAC5B,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,oHAAoH,EACpH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,wCAAwC,CAC9C,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,MAAM,GAA6B,EAAE,CAAC;YAC5C,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;gBACxC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;YACjF,CAAC;YACD,MAAM,aAAa,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC9C,MAAM,KAAK,GAAG,2BAA2B,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5D,IAAI,KAAK,EAAE,CAAC;oBACV,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACrB,CAAC;YACH,CAAC;YACD,MAAM,kBAAkB,GAA6C,MAAM,CAAC,cAAc,CACxF,MAAM,EACN,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CAC0C,CAAC;YAC9C,kBAAkB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClD,OAAO,kBAAkB,CAAC;QAC5B,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,oHAAoH,EACpH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,kBAAkB,CAAC,QAA+B;QACxD,IAAI,CAAC;YACH,MAAM,KAAK,GAAG,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC9C,MAAM,aAAa,GAAkC,MAAM,CAAC,cAAc,CACxE,KAAK,IAAI,EAAE,EACX,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CAC+B,CAAC;YACnC,OAAO,aAAa,CAAC;QACvB,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,kHAAkH,EAClH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,mCAAmC,CACzC,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,KAAK,GAAG,2BAA2B,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC/D,MAAM,aAAa,GAAyC,MAAM,CAAC,cAAc,CAC/E,KAAK,IAAI,EAAE,EACX,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACsC,CAAC;YAC1C,OAAO,aAAa,CAAC;QACvB,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,kHAAkH,EAClH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,uBAAuB,CAC7B,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,MAAM,GAAsB,EAAE,CAAC;YACrC,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;gBACxC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;YACjF,CAAC;YACD,MAAM,aAAa,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC9C,MAAM,KAAK,GAAG,UAAU,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC3C,IAAI,KAAK,EAAE,CAAC;oBACV,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACrB,CAAC;YACH,CAAC;YACD,MAAM,kBAAkB,GAAsC,MAAM,CAAC,cAAc,CACjF,MAAM,EACN,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACmC,CAAC;YACvC,kBAAkB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClD,OAAO,kBAAkB,CAAC;QAC5B,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,oHAAoH,EACpH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,wCAAwC,CAC9C,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,MAAM,GAA6B,EAAE,CAAC;YAC5C,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;gBACxC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;YACjF,CAAC;YACD,MAAM,aAAa,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC9C,MAAM,KAAK,GAAG,2BAA2B,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5D,IAAI,KAAK,EAAE,CAAC;oBACV,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACrB,CAAC;YACH,CAAC;YACD,MAAM,kBAAkB,GAA6C,MAAM,CAAC,cAAc,CACxF,MAAM,EACN,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CAC0C,CAAC;YAC9C,kBAAkB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YAClD,OAAO,kBAAkB,CAAC;QAC5B,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,oHAAoH,EACpH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IACO,kBAAkB,CAAC,QAA+B;QACxD,IAAI,CAAC;YACH,MAAM,KAAK,GAAG,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC9C,MAAM,aAAa,GAAkC,MAAM,CAAC,cAAc,CACxE,KAAK,IAAI,EAAE,EACX,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CAC+B,CAAC;YACnC,OAAO,aAAa,CAAC;QACvB,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,kHAAkH,EAClH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,mCAAmC,CACzC,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,KAAK,GAAG,2BAA2B,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC/D,MAAM,aAAa,GAAyC,MAAM,CAAC,cAAc,CAC/E,KAAK,IAAI,EAAE,EACX,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACsC,CAAC;YAC1C,OAAO,aAAa,CAAC;QACvB,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,kHAAkH,EAClH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,8BAA8B,CACpC,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,aAAa,GAA6B,EAAE,CAAC;YACnD,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;gBACxC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;YACjF,CAAC;YACD,MAAM,oBAAoB,GAAQ,QAAQ,CAAC,UAAU,CAAC;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACrD,MAAM,YAAY,GAAG,iBAAiB,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;gBAChE,IAAI,YAAY,EAAE,CAAC;oBACjB,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBACnC,CAAC;YACH,CAAC;YACD,MAAM,yBAAyB,GAC7B,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,WAAW,EAAE;gBAChD,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CAA6C,CAAC;YACjD,yBAAyB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YACzD,OAAO,yBAAyB,CAAC;QACnC,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,2HAA2H,EAC3H;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,+CAA+C,CACrD,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,aAAa,GAAoC,EAAE,CAAC;YAC1D,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;gBACxC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;YACjF,CAAC;YACD,MAAM,oBAAoB,GAAQ,QAAQ,CAAC,UAAU,CAAC;YACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACrD,MAAM,YAAY,GAAG,kCAAkC,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,CAAC;gBACjF,IAAI,YAAY,EAAE,CAAC;oBACjB,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBACnC,CAAC;YACH,CAAC;YACD,MAAM,yBAAyB,GAC7B,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,WAAW,EAAE;gBAChD,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CAAoD,CAAC;YACxD,yBAAyB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YACzD,OAAO,yBAAyB,CAAC;QACnC,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,2HAA2H,EAC3H;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,yBAAyB,CAC/B,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,iBAAiB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC5D,MAAM,oBAAoB,GAAyC,MAAM,CAAC,cAAc,CACtF,YAAY,IAAI,EAAE,EAClB,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACsC,CAAC;YAC1C,OAAO,oBAAoB,CAAC;QAC9B,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,yHAAyH,EACzH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,0CAA0C,CAChD,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,kCAAkC,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC7E,MAAM,oBAAoB,GACxB,MAAM,CAAC,cAAc,CAAC,YAAY,IAAI,EAAE,EAAE,WAAW,EAAE;gBACrD,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CAAgD,CAAC;YACpD,OAAO,oBAAoB,CAAC;QAC9B,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,yHAAyH,EACzH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,sBAAsB,CAC5B,QAA+B;QAE/B,IAAI,CAAC;YACH,MAAM,KAAK,GAAqB,EAAE,CAAC;YACnC,MAAM,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;YAC/E,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;gBACxC,MAAM,IAAI,SAAS,CAAC,GAAG,QAAQ,CAAC,UAAU,mCAAmC,CAAC,CAAC;YACjF,CAAC;YACD,MAAM,YAAY,GAAQ,QAAQ,CAAC,UAAU,CAAC;YAC9C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC7C,MAAM,IAAI,GAAG,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;gBACxC,IAAI,IAAI,EAAE,CAAC;oBACT,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACnB,CAAC;YACH,CAAC;YACD,MAAM,iBAAiB,GAAqC,MAAM,CAAC,cAAc,CAC/E,KAAK,EACL,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CACkC,CAAC;YACtC,iBAAiB,CAAC,iBAAiB,GAAG,UAAU,CAAC;YACjD,OAAO,iBAAiB,CAAC;QAC3B,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,mHAAmH,EACnH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,iBAAiB,CAAC,QAA+B;QACvD,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAC5C,MAAM,YAAY,GAAiC,MAAM,CAAC,cAAc,CACtE,IAAI,IAAI,EAAE,EACV,WAAW,EACX;gBACE,KAAK,EAAE,mBAAmB,CAAC,QAAQ,CAAC;aACrC,CAC8B,CAAC;YAClC,OAAO,YAAY,CAAC;QACtB,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,uCAAuC,CAAC,CAAC;YAC9D,MAAM,IAAI,SAAS,CACjB,iHAAiH,EACjH;gBACE,IAAI,EAAE,SAAS,CAAC,WAAW;gBAC3B,UAAU,EAAE,QAAQ,CAAC,MAAM;gBAC3B,OAAO,EAAE,QAAQ,CAAC,OAAO;gBACzB,QAAQ;aACT,CACF,CAAC;QACJ,CAAC;IACH,CAAC;IAEO,+BAA+B,CAAC,KAAyB;QAC/D,IAAI,CAAC,CAAC,KAAK,KAAK,SAAS,IAAI,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;YAChF,MAAM,IAAI,KAAK,CAAC,6BAA6B,KAAK,WAAW,CAAC,CAAC;QACjE,CAAC;IACH,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { Constants as AMQPConstants, parseConnectionString } from \"@azure/core-amqp\";\nimport type { TokenCredential, NamedKeyCredential } from \"@azure/core-auth\";\nimport { isTokenCredential, isNamedKeyCredential } from \"@azure/core-auth\";\nimport type {\n  OperationOptions,\n  CommonClientOptions,\n  FullOperationResponse,\n} from \"@azure/core-client\";\nimport { ServiceClient } from \"@azure/core-client\";\nimport type { PagedAsyncIterableIterator, PageSettings } from \"@azure/core-paging\";\nimport type {\n  PipelineResponse,\n  PipelineRequest,\n  PipelinePolicy,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport {\n  bearerTokenAuthenticationPolicy,\n  RestError,\n  createPipelineFromOptions,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport type { CorrelationRuleFilter } from \"./core/managementClient.js\";\nimport { administrationLogger as logger } from \"./log.js\";\nimport type { NamespaceProperties } from \"./serializers/namespaceResourceSerializer.js\";\nimport {\n  buildNamespace,\n  NamespaceResourceSerializer,\n} from \"./serializers/namespaceResourceSerializer.js\";\nimport type {\n  CreateQueueOptions,\n  InternalQueueOptions,\n  QueueProperties,\n  QueueRuntimeProperties,\n} from \"./serializers/queueResourceSerializer.js\";\nimport {\n  buildQueue,\n  buildQueueOptions,\n  buildQueueRuntimeProperties,\n  QueueResourceSerializer,\n} from \"./serializers/queueResourceSerializer.js\";\nimport type {\n  CreateRuleOptions,\n  RuleProperties,\n  SqlRuleAction,\n  SqlRuleFilter,\n} from \"./serializers/ruleResourceSerializer.js\";\nimport {\n  buildRule,\n  isSqlRuleAction,\n  RuleResourceSerializer,\n} from \"./serializers/ruleResourceSerializer.js\";\nimport type {\n  CreateSubscriptionOptions,\n  InternalSubscriptionOptions,\n  SubscriptionProperties,\n  SubscriptionRuntimeProperties,\n} from \"./serializers/subscriptionResourceSerializer.js\";\nimport {\n  buildSubscription,\n  buildSubscriptionOptions,\n  buildSubscriptionRuntimeProperties,\n  SubscriptionResourceSerializer,\n} from \"./serializers/subscriptionResourceSerializer.js\";\nimport type {\n  CreateTopicOptions,\n  InternalTopicOptions,\n  TopicProperties,\n  TopicRuntimeProperties,\n} from \"./serializers/topicResourceSerializer.js\";\nimport {\n  buildTopic,\n  buildTopicOptions,\n  buildTopicRuntimeProperties,\n  TopicResourceSerializer,\n} from \"./serializers/topicResourceSerializer.js\";\nimport type { AtomXmlSerializer } from \"./util/atomXmlHelper.js\";\nimport { executeAtomXmlOperation } from \"./util/atomXmlHelper.js\";\nimport * as Constants from \"./util/constants.js\";\nimport { parseURL } from \"./util/parseUrl.js\";\nimport { SasServiceClientCredentials } from \"./util/sasServiceClientCredentials.js\";\nimport { tracingClient } from \"./diagnostics/tracing.js\";\nimport { isDefined } from \"@azure/core-util\";\nimport type { ServiceBusAtomAPIVersion } from \"./util/utils.js\";\nimport {\n  formatUserAgentPrefix,\n  getHttpResponseOnly,\n  isAbsoluteUrl,\n  isJSONLikeObject,\n} from \"./util/utils.js\";\nimport type { HttpResponse } from \"./util/compat/index.js\";\n\n/**\n * Request options for list<entity-type>() operations\n */\nexport interface ListRequestOptions {\n  /**\n   * Count of entities to fetch.\n   */\n  maxCount?: number;\n\n  /**\n   * Count of entities to skip from being fetched.\n   */\n  skip?: number;\n}\n\n/**\n * Represents the returned response of the operation along with the raw response.\n */\nexport type WithResponse<T extends object> = T & {\n  /**\n   * The underlying HTTP response.\n   */\n  _response: HttpResponse;\n};\n\n/**\n * Represents the client options of the `ServiceBusAdministrationClient`.\n */\nexport interface ServiceBusAdministrationClientOptions extends CommonClientOptions {\n  /**\n   * Service version of the ATOM API.\n   *\n   * Currently supported = \"2021-05\" | \"2017-04\"\n   *\n   * Defaults to \"2021-05\".\n   */\n  serviceVersion?: \"2021-05\" | \"2017-04\";\n}\n\n/**\n * Represents the result of list operation on entities which also contains the `continuationToken` to start iterating over from.\n */\nexport type EntitiesResponse<T extends object> = WithResponse<Array<T>> &\n  Pick<PageSettings, \"continuationToken\">;\n\nfunction signingPolicy(credentials: {\n  signRequest(request: PipelineRequest): Promise<PipelineRequest>;\n}): PipelinePolicy {\n  return {\n    name: \"signingPolicy\",\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const signed = await credentials.signRequest(request);\n      return next(signed);\n    },\n  };\n}\n\n/**\n * All operations return promises that resolve to an object that has the relevant output.\n * These objects also have a property called `_response` that you can use if you want to\n * access the direct response from the service.\n */\nexport class ServiceBusAdministrationClient extends ServiceClient {\n  /**\n   * Reference to the endpoint as extracted from input connection string.\n   */\n  private endpoint: string;\n\n  /**\n   * Reference to the endpoint with protocol prefix as extracted from input connection string.\n   */\n  private endpointWithProtocol: string;\n\n  private serviceVersion: ServiceBusAtomAPIVersion;\n\n  private useTls: boolean;\n\n  /**\n   * Singleton instances of serializers used across the various operations.\n   */\n  private namespaceResourceSerializer: AtomXmlSerializer;\n  private queueResourceSerializer: AtomXmlSerializer;\n  private topicResourceSerializer: AtomXmlSerializer;\n  private subscriptionResourceSerializer: AtomXmlSerializer;\n  private ruleResourceSerializer: AtomXmlSerializer;\n\n  /**\n   * Credentials used to generate tokens as required for the various operations.\n   */\n  private credentials: SasServiceClientCredentials | TokenCredential;\n\n  /**\n   * Initializes a new instance of the ServiceBusAdministrationClient class.\n   * @param connectionString - The connection string needed for the client to connect to Azure.\n   * @param options - PipelineOptions\n   */\n  constructor(connectionString: string, options?: ServiceBusAdministrationClientOptions);\n  /**\n   *\n   * @param fullyQualifiedNamespace - The fully qualified namespace of your Service Bus instance which is\n   * likely to be similar to <yournamespace>.servicebus.windows.net.\n   * @param credential - A credential object used by the client to get the token to authenticate the connection\n   * with the Azure Service Bus. See &commat;azure/identity for creating the credentials.\n   * If you're using your own implementation of the `TokenCredential` interface against AAD, then set the \"scopes\" for service-bus\n   * to be `[\"https://servicebus.azure.net//user_impersonation\"]` to get the appropriate token.\n   * Use the `AzureNamedKeyCredential` from &commat;azure/core-auth if you want to pass in a `SharedAccessKeyName`\n   * and `SharedAccessKey` without using a connection string. These fields map to the `name` and `key` field respectively\n   * in `AzureNamedKeyCredential`.\n   * @param options - PipelineOptions\n   */\n  constructor(\n    fullyQualifiedNamespace: string,\n    credential: TokenCredential | NamedKeyCredential,\n    options?: ServiceBusAdministrationClientOptions,\n  );\n  constructor(\n    fullyQualifiedNamespaceOrConnectionString1: string,\n    credentialOrOptions2?:\n      | TokenCredential\n      | NamedKeyCredential\n      | ServiceBusAdministrationClientOptions,\n    options3?: ServiceBusAdministrationClientOptions,\n  ) {\n    let options: ServiceBusAdministrationClientOptions;\n    let fullyQualifiedNamespace: string;\n    let credentials: SasServiceClientCredentials | TokenCredential;\n    let authPolicy: PipelinePolicy;\n    let useTls: boolean = true;\n    if (isTokenCredential(credentialOrOptions2)) {\n      fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;\n      options = options3 || {};\n      credentials = credentialOrOptions2;\n      authPolicy = bearerTokenAuthenticationPolicy({\n        credential: credentials,\n        scopes: AMQPConstants.aadServiceBusScope,\n      });\n    } else if (isNamedKeyCredential(credentialOrOptions2)) {\n      fullyQualifiedNamespace = fullyQualifiedNamespaceOrConnectionString1;\n      credentials = new SasServiceClientCredentials(credentialOrOptions2);\n      options = options3 || {};\n      authPolicy = signingPolicy(credentials as SasServiceClientCredentials);\n    } else {\n      const connectionString = fullyQualifiedNamespaceOrConnectionString1;\n      options = credentialOrOptions2 || {};\n      const connectionStringObj: any = parseConnectionString(connectionString);\n      if (connectionStringObj.Endpoint === undefined) {\n        throw new Error(\"Missing Endpoint in connection string.\");\n      }\n      try {\n        fullyQualifiedNamespace = connectionStringObj.Endpoint.match(\".*://([^/]*)\")[1];\n      } catch {\n        throw new Error(\"Endpoint in the connection string is not valid.\");\n      }\n      if (connectionStringObj.UseDevelopmentEmulator) {\n        useTls = false;\n      }\n      credentials = new SasServiceClientCredentials({\n        key: connectionStringObj.SharedAccessKey,\n        name: connectionStringObj.SharedAccessKeyName,\n      });\n      authPolicy = signingPolicy(credentials as SasServiceClientCredentials);\n    }\n\n    const userAgentPrefix = formatUserAgentPrefix(options.userAgentOptions?.userAgentPrefix);\n    const serviceClientOptions = createPipelineFromOptions({\n      ...options,\n      userAgentOptions: {\n        userAgentPrefix,\n      },\n    });\n    serviceClientOptions.addPolicy(authPolicy);\n    super({ pipeline: serviceClientOptions });\n    this.endpoint = fullyQualifiedNamespace;\n    this.endpointWithProtocol = fullyQualifiedNamespace.endsWith(\"/\")\n      ? \"sb://\" + fullyQualifiedNamespace\n      : \"sb://\" + fullyQualifiedNamespace + \"/\";\n    this.serviceVersion = options.serviceVersion ?? Constants.CURRENT_API_VERSION;\n    this.useTls = useTls;\n    this.credentials = credentials;\n    this.namespaceResourceSerializer = new NamespaceResourceSerializer();\n    this.queueResourceSerializer = new QueueResourceSerializer();\n    this.topicResourceSerializer = new TopicResourceSerializer();\n    this.subscriptionResourceSerializer = new SubscriptionResourceSerializer();\n    this.ruleResourceSerializer = new RuleResourceSerializer();\n  }\n\n  /**\n   * Returns an object representing the metadata related to a service bus namespace.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   */\n  async getNamespaceProperties(\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<NamespaceProperties>> {\n    logger.verbose(`Performing management operation - getNamespaceProperties()`);\n\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getNamespaceProperties\",\n      operationOptions,\n      async (updatedOptions) => {\n        const response = await this.getResource(\n          \"$namespaceinfo\",\n          this.namespaceResourceSerializer,\n          updatedOptions,\n        );\n        return this.buildNamespacePropertiesResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Creates a queue with given name, configured using the given options\n   * @param options - Options to configure the Queue being created(For example, you can configure a queue to support partitions or sessions)\n   *  and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createQueue(\n    queueName: string,\n    options: CreateQueueOptions = {},\n  ): Promise<WithResponse<QueueProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.createQueue\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - createQueue() for \"${queueName}\" with options: %j`,\n          options,\n        );\n        const response = await this.putResource(\n          queueName,\n          buildQueueOptions(options || {}),\n          this.queueResourceSerializer,\n          false,\n          updatedOptions,\n        );\n\n        return this.buildQueueResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Queue and its properties.\n   * If you want to get the Queue runtime info like message count details, use `getQueueRuntimeProperties` API.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getQueue(\n    queueName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<QueueProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getQueue\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getQueue() for \"${queueName}\"`);\n        const response = await this.getResource(\n          queueName,\n          this.queueResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildQueueResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Queue runtime info like message count details.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getQueueRuntimeProperties(\n    queueName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<QueueRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getQueueRuntimeProperties\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getQueueRuntimeProperties() for \"${queueName}\"`,\n        );\n        const response = await this.getResource(\n          queueName,\n          this.queueResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildQueueRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns a list of objects, each representing a Queue along with its properties.\n   * If you want to get the runtime info of the queues like message count, use `getQueuesRuntimeProperties` API instead.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getQueues(\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<QueueProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getQueues\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getQueues() with options: %j`, options);\n        const response = await this.listResources(\n          \"$Resources/Queues\",\n          updatedOptions,\n          this.queueResourceSerializer,\n        );\n\n        return this.buildListQueuesResponse(response);\n      },\n    );\n  }\n\n  private async *listQueuesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<QueueProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getQueues({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listQueuesAll(\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<QueueProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listQueuesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the queues.\n   *\n   * .byPage() returns an async iterable iterator to list the queues in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listQueues(\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<QueueProperties, EntitiesResponse<QueueProperties>> {\n    logger.verbose(`Performing management operation - listQueues() with options: %j`, options);\n    const iter = this.listQueuesAll(options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listQueuesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Queue's runtime info like message count details.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getQueuesRuntimeProperties(\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<QueueRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getQueuesRuntimeProperties\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getQueuesRuntimeProperties() with options: %j`,\n          options,\n        );\n        const response = await this.listResources(\n          \"$Resources/Queues\",\n          updatedOptions,\n          this.queueResourceSerializer,\n        );\n\n        return this.buildListQueuesRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  private async *listQueuesRuntimePropertiesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<QueueRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getQueuesRuntimeProperties({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listQueuesRuntimePropertiesAll(\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<QueueRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listQueuesRuntimePropertiesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the queues.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of the queues in pages.\n   *\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listQueuesRuntimeProperties(\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<QueueRuntimeProperties, EntitiesResponse<QueueRuntimeProperties>> {\n    logger.verbose(\n      `Performing management operation - listQueuesRuntimeProperties() with options: %j`,\n      options,\n    );\n    const iter = this.listQueuesRuntimePropertiesAll(options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listQueuesRuntimePropertiesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Updates the queue based on the queue properties provided.\n   * All queue properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getQueue()`, update the desired properties in it, and then pass the modified object to `updateQueue()`.\n   *\n   * The properties that cannot be updated are marked as readonly in the `QueueProperties` interface.\n   *\n   * @param queue - Object representing the properties of the queue and the raw response.\n   * `requiresSession`, `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the queue.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateQueue(\n    queue: WithResponse<QueueProperties>,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<QueueProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.updateQueue\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - updateQueue() for \"${queue.name}\" with options: %j`,\n          queue,\n        );\n\n        if (!isJSONLikeObject(queue) || queue == null) {\n          throw new TypeError(\n            `Parameter \"queue\" must be an object of type \"QueueDescription\" and cannot be undefined or null.`,\n          );\n        }\n\n        if (!queue.name) {\n          throw new TypeError(`\"name\" attribute of the parameter \"queue\" cannot be undefined.`);\n        }\n\n        const response = await this.putResource(\n          queue.name,\n          buildQueueOptions(queue),\n          this.queueResourceSerializer,\n          true,\n          updatedOptions,\n        );\n\n        return this.buildQueueResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Deletes a queue.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteQueue(\n    queueName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<{}>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteQueue\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - deleteQueue() for \"${queueName}\"`);\n        const response = await this.deleteResource(\n          queueName,\n          this.queueResourceSerializer,\n          updatedOptions,\n        );\n\n        return { _response: getHttpResponseOnly(response) };\n      },\n    );\n  }\n\n  /**\n   * Checks whether a given queue exists or not.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  async queueExists(queueName: string, operationOptions: OperationOptions = {}): Promise<boolean> {\n    logger.verbose(`Performing management operation - queueExists() for \"${queueName}\"`);\n    const { span, updatedOptions } = tracingClient.startSpan(\n      \"ServiceBusAdministrationClient.queueExists\",\n      operationOptions,\n    );\n    try {\n      await this.getQueue(queueName, updatedOptions);\n      span.setStatus({ status: \"success\" });\n      return true;\n    } catch (e: any) {\n      span.setStatus({ status: \"error\", error: e });\n      return false;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a topic with given name, configured using the given options\n   * @param options - Options to configure the Topic being created(For example, you can configure a topic to support partitions)\n   * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createTopic(\n    topicName: string,\n    options: CreateTopicOptions = {},\n  ): Promise<WithResponse<TopicProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.createTopic\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - createTopic() for \"${topicName}\" with options: %j`,\n          options,\n        );\n        const response = await this.putResource(\n          topicName,\n          buildTopicOptions(options || {}),\n          this.topicResourceSerializer,\n          false,\n          updatedOptions,\n        );\n\n        return this.buildTopicResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Topic and its properties.\n   * If you want to get the Topic runtime info like subscription count details, use `getTopicRuntimeProperties` API.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getTopic(\n    topicName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<TopicProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getTopic\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getTopic() for \"${topicName}\"`);\n        const response = await this.getResource(\n          topicName,\n          this.topicResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildTopicResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Topic runtime info like subscription count.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getTopicRuntimeProperties(\n    topicName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<TopicRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getTopicRuntimeProperties\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getTopicRuntimeProperties() for \"${topicName}\"`,\n        );\n        const response = await this.getResource(\n          topicName,\n          this.topicResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildTopicRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns a list of objects, each representing a Topic along with its properties.\n   * If you want to get the runtime info of the topics like subscription count, use `getTopicsRuntimeProperties` API instead.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getTopics(\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<TopicProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getTopics\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getTopics() with options: %j`, options);\n        const response = await this.listResources(\n          \"$Resources/Topics\",\n          updatedOptions,\n          this.topicResourceSerializer,\n        );\n\n        return this.buildListTopicsResponse(response);\n      },\n    );\n  }\n\n  private async *listTopicsPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<TopicProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getTopics({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listTopicsAll(\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<TopicProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listTopicsPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the topics.\n   *\n   * .byPage() returns an async iterable iterator to list the topics in pages.\n   *\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listTopics(\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<TopicProperties, EntitiesResponse<TopicProperties>> {\n    logger.verbose(`Performing management operation - listTopics() with options: %j`, options);\n    const iter = this.listTopicsAll(options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listTopicsPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Topic's runtime info like subscription count.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getTopicsRuntimeProperties(\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<TopicRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getTopicsRuntimeProperties\",\n\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getTopicsRuntimeProperties() with options: %j`,\n          options,\n        );\n        const response = await this.listResources(\n          \"$Resources/Topics\",\n          updatedOptions,\n          this.topicResourceSerializer,\n        );\n\n        return this.buildListTopicsRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  private async *listTopicsRuntimePropertiesPage(\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<TopicRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getTopicsRuntimeProperties({\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listTopicsRuntimePropertiesAll(\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<TopicRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listTopicsRuntimePropertiesPage(marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the topics.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of the topics in pages.\n   *\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listTopicsRuntimeProperties(\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<TopicRuntimeProperties, EntitiesResponse<TopicRuntimeProperties>> {\n    logger.verbose(\n      `Performing management operation - listTopicsRuntimeProperties() with options: %j`,\n      options,\n    );\n    const iter = this.listTopicsRuntimePropertiesAll(options);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listTopicsRuntimePropertiesPage(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Updates the topic based on the topic properties provided.\n   * All topic properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getTopic()`, update the desired properties in it, and then pass the modified object to `updateTopic()`.\n   *\n   * The properties that cannot be updated are marked as readonly in the `TopicProperties` interface.\n   *\n   * @param topic - Object representing the properties of the topic and the raw response.\n   * `requiresDuplicateDetection`, `enablePartitioning`, and `name` can't be updated after creating the topic.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateTopic(\n    topic: WithResponse<TopicProperties>,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<TopicProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.updateTopic\",\n\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - updateTopic() for \"${topic.name}\" with options: %j`,\n          topic,\n        );\n\n        if (!isJSONLikeObject(topic) || topic == null) {\n          throw new TypeError(\n            `Parameter \"topic\" must be an object of type \"TopicDescription\" and cannot be undefined or null.`,\n          );\n        }\n\n        if (!topic.name) {\n          throw new TypeError(`\"name\" attribute of the parameter \"topic\" cannot be undefined.`);\n        }\n\n        const response = await this.putResource(\n          topic.name,\n          buildTopicOptions(topic),\n          this.topicResourceSerializer,\n          true,\n          updatedOptions,\n        );\n\n        return this.buildTopicResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Deletes a topic.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteTopic(\n    topicName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<{}>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteTopic\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - deleteTopic() for \"${topicName}\"`);\n        const response = await this.deleteResource(\n          topicName,\n          this.topicResourceSerializer,\n          updatedOptions,\n        );\n\n        return { _response: getHttpResponseOnly(response) };\n      },\n    );\n  }\n\n  /**\n   * Checks whether a given topic exists or not.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  async topicExists(topicName: string, operationOptions?: OperationOptions): Promise<boolean> {\n    logger.verbose(`Performing management operation - topicExists() for \"${topicName}\"`);\n    const { span, updatedOptions } = tracingClient.startSpan(\n      \"ServiceBusAdministrationClient.topicExists\",\n      operationOptions,\n    );\n    try {\n      span.setStatus({ status: \"success\" });\n      await this.getTopic(topicName, updatedOptions);\n      return true;\n    } catch (e: any) {\n      span.setStatus({ status: \"error\", error: e });\n      return false;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a subscription with given name, configured using the given options\n   * @param options - Options to configure the Subscription being created(For example, you can configure a Subscription to support partitions or sessions)\n   * and the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async createSubscription(\n    topicName: string,\n    subscriptionName: string,\n    options: CreateSubscriptionOptions = {},\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.createSubscription\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - createSubscription() for \"${subscriptionName}\" with options: %j`,\n          options,\n        );\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n        const response = await this.putResource(\n          fullPath,\n          buildSubscriptionOptions(options || {}),\n          this.subscriptionResourceSerializer,\n          false,\n          updatedOptions,\n        );\n\n        return this.buildSubscriptionResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Subscription and its properties.\n   * If you want to get the Subscription runtime info like message count details, use `getSubscriptionRuntimeProperties` API.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getSubscription(\n    topicName: string,\n    subscriptionName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getSubscription\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getSubscription() for \"${subscriptionName}\"`,\n        );\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n        const response = await this.getResource(\n          fullPath,\n          this.subscriptionResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildSubscriptionResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Subscription runtime info like message count details.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getSubscriptionRuntimeProperties(\n    topicName: string,\n    subscriptionName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<SubscriptionRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getSubscriptionRuntimeProperties\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getSubscriptionRuntimeProperties() for \"${subscriptionName}\"`,\n        );\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n        const response = await this.getResource(\n          fullPath,\n          this.subscriptionResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildSubscriptionRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns a list of objects, each representing a Subscription along with its properties.\n   * If you want to get the runtime info of the subscriptions like message count, use `getSubscriptionsRuntimeProperties` API instead.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getSubscriptions(\n    topicName: string,\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<SubscriptionProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getSubscriptions\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getSubscriptions() with options: %j`,\n          options,\n        );\n        const response = await this.listResources(\n          topicName + \"/Subscriptions/\",\n          updatedOptions,\n          this.subscriptionResourceSerializer,\n        );\n\n        return this.buildListSubscriptionsResponse(response);\n      },\n    );\n  }\n\n  private async *listSubscriptionsPage(\n    topicName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<SubscriptionProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getSubscriptions(topicName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listSubscriptionsAll(\n    topicName: string,\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<SubscriptionProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listSubscriptionsPage(topicName, marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   *\n   * Returns an async iterable iterator to list all the subscriptions\n   * under the specified topic.\n   *\n   * .byPage() returns an async iterable iterator to list the subscriptions in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listSubscriptions(\n    topicName: string,\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<SubscriptionProperties, EntitiesResponse<SubscriptionProperties>> {\n    logger.verbose(\n      `Performing management operation - listSubscriptions() with options: %j`,\n      options,\n    );\n    const iter = this.listSubscriptionsAll(topicName, options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listSubscriptionsPage(topicName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns a list of objects, each representing a Subscription's runtime info like message count details.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getSubscriptionsRuntimeProperties(\n    topicName: string,\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<SubscriptionRuntimeProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getSubscriptionsRuntimeProperties\",\n      options,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - getSubscriptionsRuntimeProperties() with options: %j`,\n          options,\n        );\n        const response = await this.listResources(\n          topicName + \"/Subscriptions/\",\n          updatedOptions,\n          this.subscriptionResourceSerializer,\n        );\n\n        return this.buildListSubscriptionsRuntimePropertiesResponse(response);\n      },\n    );\n  }\n\n  private async *listSubscriptionsRuntimePropertiesPage(\n    topicName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<SubscriptionRuntimeProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getSubscriptionsRuntimeProperties(topicName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listSubscriptionsRuntimePropertiesAll(\n    topicName: string,\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<SubscriptionRuntimeProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listSubscriptionsRuntimePropertiesPage(\n      topicName,\n      marker,\n      options,\n    )) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list runtime info of the subscriptions\n   * under the specified topic.\n   *\n   * .byPage() returns an async iterable iterator to list runtime info of subscriptions in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listSubscriptionsRuntimeProperties(\n    topicName: string,\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<\n    SubscriptionRuntimeProperties,\n    EntitiesResponse<SubscriptionRuntimeProperties>\n  > {\n    logger.verbose(\n      `Performing management operation - listSubscriptionsRuntimeProperties() with options: %j`,\n      options,\n    );\n    const iter = this.listSubscriptionsRuntimePropertiesAll(topicName, options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listSubscriptionsRuntimePropertiesPage(topicName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Updates the subscription based on the subscription properties provided.\n   * All subscription properties must be set even though only a subset of them are actually updatable.\n   * Therefore, the suggested flow is to use the output from `getSubscription()`, update the desired properties in it, and then pass the modified object to `updateSubscription()`.\n   *\n   * The properties that cannot be updated are marked as readonly in the `SubscriptionProperties` interface.\n   * @param subscription - Object representing the properties of the subscription and the raw response.\n   * `subscriptionName`, `topicName`, and `requiresSession` can't be updated after creating the subscription.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateSubscription(\n    subscription: WithResponse<SubscriptionProperties>,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<SubscriptionProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.updateSubscription\",\n\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - updateSubscription() for \"${subscription.subscriptionName}\" with options: %j`,\n          subscription,\n        );\n\n        if (!isJSONLikeObject(subscription) || subscription == null) {\n          throw new TypeError(\n            `Parameter \"subscription\" must be an object of type \"SubscriptionDescription\" and cannot be undefined or null.`,\n          );\n        }\n\n        if (!subscription.topicName || !subscription.subscriptionName) {\n          throw new TypeError(\n            `The attributes \"topicName\" and \"subscriptionName\" of the parameter \"subscription\" cannot be undefined.`,\n          );\n        }\n\n        const fullPath = this.getSubscriptionPath(\n          subscription.topicName,\n          subscription.subscriptionName,\n        );\n\n        const response = await this.putResource(\n          fullPath,\n          buildSubscriptionOptions(subscription),\n          this.subscriptionResourceSerializer,\n          true,\n          updatedOptions,\n        );\n\n        return this.buildSubscriptionResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Deletes a subscription.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteSubscription(\n    topicName: string,\n    subscriptionName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<{}>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteSubscription\",\n\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - deleteSubscription() for \"${subscriptionName}\"`,\n        );\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName);\n        const response = await this.deleteResource(\n          fullPath,\n          this.subscriptionResourceSerializer,\n          updatedOptions,\n        );\n\n        return { _response: getHttpResponseOnly(response) };\n      },\n    );\n  }\n\n  /**\n   * Checks whether a given subscription exists in the topic or not.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   */\n  async subscriptionExists(\n    topicName: string,\n    subscriptionName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<boolean> {\n    logger.verbose(\n      `Performing management operation - subscriptionExists() for \"${topicName}\" and \"${subscriptionName}\"`,\n    );\n    const { span, updatedOptions } = tracingClient.startSpan(\n      \"ServiceBusAdministrationClient.subscriptionExists\",\n      operationOptions,\n    );\n    try {\n      span.setStatus({ status: \"success\" });\n      await this.getSubscription(topicName, subscriptionName, updatedOptions);\n      return true;\n    } catch (e: any) {\n      span.setStatus({ status: \"error\", error: e });\n      return false;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a rule with given name, configured using the given options.\n   * @param ruleFilter - Defines the filter expression that the rule evaluates.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<RuleProperties>>;\n  /**\n   * Creates a rule with given name, configured using the given options.\n   * @param ruleFilter - Defines the filter expression that the rule evaluates.\n   * @param ruleAction - The SQL like expression that can be executed on the message should the associated filter apply.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityAlreadyExistsError` when requested messaging entity already exists,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `QuotaExceededError` when requested operation fails due to quote limits exceeding from service side,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleAction: SqlRuleAction,\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<RuleProperties>>;\n  async createRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    ruleFilter: SqlRuleFilter | CorrelationRuleFilter,\n    ruleActionOrOperationOptions?: SqlRuleAction | OperationOptions,\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<RuleProperties>> {\n    let ruleAction: SqlRuleAction | undefined = undefined;\n    let operOptions: OperationOptions | undefined;\n    if (ruleActionOrOperationOptions) {\n      if (isSqlRuleAction(ruleActionOrOperationOptions)) {\n        // Overload#2 - where the sqlExpression in the ruleAction is defined\n        ruleAction = ruleActionOrOperationOptions;\n        operOptions = operationOptions;\n      } else {\n        // Overload#1\n        // Overload#2 - where the sqlExpression in the ruleAction is undefined\n        operOptions = { ...ruleActionOrOperationOptions, ...operationOptions };\n      }\n    }\n\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.createRule\",\n      operOptions ?? {},\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - createRule() for \"${ruleName}\" with filter: \"%j\"`,\n          ruleFilter,\n        );\n        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n        const response = await this.putResource(\n          fullPath,\n          { name: ruleName, filter: ruleFilter, action: ruleAction },\n          this.ruleResourceSerializer,\n          false,\n          updatedOptions,\n        );\n        return this.buildRuleResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Returns an object representing the Rule with the given name along with all its properties.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async getRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<WithResponse<RuleProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getRule\",\n      operationOptions,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getRule() for \"${ruleName}\"`);\n        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n        const response = await this.getResource(\n          fullPath,\n          this.ruleResourceSerializer,\n          updatedOptions,\n        );\n\n        return this.buildRuleResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Lists existing rules.\n   * @param options - The options include the maxCount and the count of entities to skip, the operation options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  private async getRules(\n    topicName: string,\n    subscriptionName: string,\n    options: ListRequestOptions & OperationOptions = {},\n  ): Promise<EntitiesResponse<RuleProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getRules\",\n\n      options,\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - getRules() with options: %j`, options);\n        const fullPath = this.getSubscriptionPath(topicName, subscriptionName) + \"/Rules/\";\n        const response = await this.listResources(\n          fullPath,\n          updatedOptions,\n          this.ruleResourceSerializer,\n        );\n\n        return this.buildListRulesResponse(response);\n      },\n    );\n  }\n\n  private async *listRulesPage(\n    topicName: string,\n    subscriptionName: string,\n    marker?: string,\n    options: OperationOptions & Pick<PageSettings, \"maxPageSize\"> = {},\n  ): AsyncIterableIterator<EntitiesResponse<RuleProperties>> {\n    let listResponse;\n    do {\n      listResponse = await this.getRules(topicName, subscriptionName, {\n        skip: Number(marker),\n        maxCount: options.maxPageSize,\n        ...options,\n      });\n      marker = listResponse.continuationToken;\n      yield listResponse;\n    } while (marker);\n  }\n\n  private async *listRulesAll(\n    topicName: string,\n    subscriptionName: string,\n    options: OperationOptions = {},\n  ): AsyncIterableIterator<RuleProperties> {\n    let marker: string | undefined;\n    for await (const segment of this.listRulesPage(topicName, subscriptionName, marker, options)) {\n      yield* segment;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the rules\n   * under the specified subscription.\n   *\n   * .byPage() returns an async iterable iterator to list the rules in pages.\n   *\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listRules(\n    topicName: string,\n    subscriptionName: string,\n    options?: OperationOptions,\n  ): PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>> {\n    logger.verbose(`Performing management operation - listRules() with options: %j`, options);\n    const iter = this.listRulesAll(topicName, subscriptionName, options);\n    return {\n      /**\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       */\n      byPage: (settings: PageSettings = {}) => {\n        this.throwIfInvalidContinuationToken(settings.continuationToken);\n        return this.listRulesPage(topicName, subscriptionName, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...options,\n        });\n      },\n    };\n  }\n\n  /**\n   * Updates properties on the Rule by the given name based on the given options.\n   * All rule properties must be set even if one of them is being updated.\n   * Therefore, the suggested flow is to use the output from `getRule()`, update the desired properties in it, and then pass the modified object to `updateRule()`.\n   *\n   * @param rule - Options to configure the Rule being updated and the raw response.\n   * For example, you can configure the filter to apply on associated Topic/Subscription.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async updateRule(\n    topicName: string,\n    subscriptionName: string,\n    rule: WithResponse<RuleProperties>,\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<RuleProperties>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.updateRule\",\n      operationOptions ?? {},\n      async (updatedOptions) => {\n        logger.verbose(\n          `Performing management operation - updateRule() for \"${rule.name}\" with options: %j`,\n          rule,\n        );\n\n        if (!isJSONLikeObject(rule) || rule === null) {\n          throw new TypeError(\n            `Parameter \"rule\" must be an object of type \"RuleDescription\" and cannot be undefined or null.`,\n          );\n        }\n\n        if (!rule.name) {\n          throw new TypeError(`\"name\" attribute of the parameter \"rule\" cannot be undefined.`);\n        }\n\n        const fullPath = this.getRulePath(topicName, subscriptionName, rule.name);\n        const response = await this.putResource(\n          fullPath,\n          rule,\n          this.ruleResourceSerializer,\n          true,\n          updatedOptions,\n        );\n\n        return this.buildRuleResponse(response);\n      },\n    );\n  }\n\n  /**\n   * Deletes a rule.\n   * @param operationOptions - The options that can be used to abort, trace and control other configurations on the HTTP request.\n   *\n   * Following are errors that can be expected from this operation\n   * @throws `RestError` with code `UnauthorizedRequestError` when given request fails due to authorization problems,\n   * @throws `RestError` with code `MessageEntityNotFoundError` when requested messaging entity does not exist,\n   * @throws `RestError` with code `InvalidOperationError` when requested operation is invalid and we encounter a 403 HTTP status code,\n   * @throws `RestError` with code `ServerBusyError` when the request fails due to server being busy,\n   * @throws `RestError` with code `ServiceError` when receiving unrecognized HTTP status or for a scenarios such as\n   * bad requests or requests resulting in conflicting operation on the server,\n   * @throws `RestError` with code and statusCode representing the standard set of REST API errors.\n   */\n  async deleteRule(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    operationOptions?: OperationOptions,\n  ): Promise<WithResponse<{}>> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteRule\",\n      operationOptions ?? {},\n      async (updatedOptions) => {\n        logger.verbose(`Performing management operation - deleteRule() for \"${ruleName}\"`);\n        const fullPath = this.getRulePath(topicName, subscriptionName, ruleName);\n        const response = await this.deleteResource(\n          fullPath,\n          this.ruleResourceSerializer,\n          updatedOptions,\n        );\n\n        return { _response: getHttpResponseOnly(response) };\n      },\n    );\n  }\n\n  /**\n   * Checks whether a given rule exists or not.\n   *\n   */\n  async ruleExists(\n    topicName: string,\n    subscriptionName: string,\n    ruleName: string,\n    operationOptions: OperationOptions = {},\n  ): Promise<boolean> {\n    logger.verbose(`Performing management operation - ruleExists() for \"${ruleName}\"`);\n    const { span, updatedOptions } = tracingClient.startSpan(\n      \"ServiceBusAdministrationClient.ruleExists\",\n      operationOptions,\n    );\n    try {\n      span.setStatus({ status: \"success\" });\n      await this.getRule(topicName, subscriptionName, ruleName, updatedOptions);\n      return true;\n    } catch (e: any) {\n      span.setStatus({ status: \"error\", error: e });\n      return false;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates or updates a resource based on `isUpdate` parameter.\n   */\n  private async putResource(\n    name: string,\n    entityFields:\n      | InternalQueueOptions\n      | InternalTopicOptions\n      | InternalSubscriptionOptions\n      | CreateRuleOptions,\n    serializer: AtomXmlSerializer,\n    isUpdate: boolean = false,\n    operationOptions: OperationOptions = {},\n  ): Promise<PipelineResponse> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.putResource\",\n      operationOptions,\n      async (updatedOptions) => {\n        const request: PipelineRequest = createPipelineRequest({\n          url: this.getUrl(name),\n          method: \"PUT\",\n          allowInsecureConnection: !this.useTls,\n        });\n        if (isUpdate) {\n          request.headers.set(\"If-Match\", \"*\");\n        }\n\n        const queueOrSubscriptionFields = entityFields as\n          | InternalQueueOptions\n          | InternalSubscriptionOptions;\n        if (\n          queueOrSubscriptionFields.ForwardTo ||\n          queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo\n        ) {\n          const token =\n            this.credentials instanceof SasServiceClientCredentials\n              ? (await this.credentials.getToken(this.endpoint)).token\n              : (await this.credentials.getToken([AMQPConstants.aadServiceBusScope]))!.token;\n\n          if (queueOrSubscriptionFields.ForwardTo) {\n            request.headers.set(\"ServiceBusSupplementaryAuthorization\", token);\n            if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardTo)) {\n              queueOrSubscriptionFields.ForwardTo = this.endpointWithProtocol.concat(\n                queueOrSubscriptionFields.ForwardTo,\n              );\n            }\n          }\n          if (queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo) {\n            request.headers.set(\"ServiceBusDlqSupplementaryAuthorization\", token);\n            if (!isAbsoluteUrl(queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo)) {\n              queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo =\n                this.endpointWithProtocol.concat(\n                  queueOrSubscriptionFields.ForwardDeadLetteredMessagesTo,\n                );\n            }\n          }\n        }\n\n        request.headers.set(\"content-type\", \"application/atom+xml;type=entry;charset=utf-8\");\n\n        return executeAtomXmlOperation(this, request, serializer, updatedOptions, entityFields);\n      },\n    );\n  }\n\n  /**\n   * Gets a resource.\n   */\n  private async getResource(\n    name: string,\n    serializer: AtomXmlSerializer,\n    operationOptions: OperationOptions = {},\n  ): Promise<FullOperationResponse> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.getResource\",\n      operationOptions,\n      async (updatedOptions) => {\n        const request = createPipelineRequest({\n          url: this.getUrl(name),\n          method: \"GET\",\n          allowInsecureConnection: !this.useTls,\n        });\n\n        const response = await executeAtomXmlOperation(this, request, serializer, updatedOptions);\n        if (\n          !isDefined(response.parsedBody) ||\n          (Array.isArray(response.parsedBody) && response.parsedBody.length === 0)\n        ) {\n          const err = new RestError(\n            `The messaging entity \"${name}\" being requested cannot be found.`,\n            {\n              code: \"MessageEntityNotFoundError\",\n              statusCode: response.status,\n              request,\n              response,\n            },\n          );\n          throw err;\n        }\n        return response;\n      },\n    );\n  }\n\n  /**\n   * Lists existing resources\n   */\n  private async listResources(\n    name: string,\n    options: ListRequestOptions & OperationOptions = {},\n    serializer: AtomXmlSerializer,\n  ): Promise<FullOperationResponse> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.listResources\",\n      options,\n      async (updatedOptions) => {\n        const queryParams: { [key: string]: string } = {};\n        if (options) {\n          if (options.skip) {\n            queryParams[\"$skip\"] = options.skip.toString();\n          }\n          if (options.maxCount) {\n            queryParams[\"$top\"] = options.maxCount.toString();\n          }\n        }\n\n        const request = createPipelineRequest({\n          url: this.getUrl(name, queryParams),\n          method: \"GET\",\n          allowInsecureConnection: !this.useTls,\n        });\n\n        return executeAtomXmlOperation(this, request, serializer, updatedOptions);\n      },\n    );\n  }\n\n  /**\n   * Deletes a resource.\n   */\n  private async deleteResource(\n    name: string,\n    serializer: AtomXmlSerializer,\n    operationOptions: OperationOptions = {},\n  ): Promise<FullOperationResponse> {\n    return tracingClient.withSpan(\n      \"ServiceBusAdministrationClient.deleteResource\",\n      operationOptions,\n      async (updatedOptions) => {\n        const request = createPipelineRequest({\n          url: this.getUrl(name),\n          method: \"DELETE\",\n          allowInsecureConnection: !this.useTls,\n        });\n        return executeAtomXmlOperation(this, request, serializer, updatedOptions);\n      },\n    );\n  }\n\n  private getUrl(path: string, queryParams?: { [key: string]: string }): string {\n    const baseUri = `${this.useTls ? \"https\" : \"http\"}://${this.endpoint}/${path}`;\n\n    const requestUrl = new URL(baseUri);\n    requestUrl.searchParams.set(Constants.API_VERSION_QUERY_KEY, this.serviceVersion);\n\n    if (queryParams) {\n      for (const key of Object.keys(queryParams)) {\n        requestUrl.searchParams.set(key, queryParams[key]);\n      }\n    }\n\n    return requestUrl.toString();\n  }\n\n  private getSubscriptionPath(topicName: string, subscriptionName: string): string {\n    return topicName + \"/Subscriptions/\" + subscriptionName;\n  }\n\n  private getRulePath(topicName: string, subscriptionName: string, ruleName: string): string {\n    return topicName + \"/Subscriptions/\" + subscriptionName + \"/Rules/\" + ruleName;\n  }\n\n  private getMarkerFromNextLinkUrl(url: string): string | undefined {\n    if (!url) {\n      return undefined;\n    }\n    try {\n      const value = parseURL(url).searchParams.get(Constants.XML_METADATA_MARKER + \"skip\");\n      return value !== null ? value : undefined;\n    } catch (error: any) {\n      throw new Error(\n        `Unable to parse the '${Constants.XML_METADATA_MARKER}skip' from the next-link in the response ` +\n          error,\n      );\n    }\n  }\n\n  private buildNamespacePropertiesResponse(\n    response: FullOperationResponse,\n  ): WithResponse<NamespaceProperties> {\n    try {\n      const namespace = buildNamespace(response.parsedBody);\n      const namespaceResponse: WithResponse<NamespaceProperties> = Object.defineProperty(\n        namespace || {},\n        \"_response\",\n        { value: getHttpResponseOnly(response) },\n      ) as WithResponse<NamespaceProperties>;\n      return namespaceResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a namespace object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListQueuesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<QueueProperties> {\n    try {\n      const queues: QueueProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawQueueArray: any = response.parsedBody;\n      for (let i = 0; i < rawQueueArray.length; i++) {\n        const queue = buildQueue(rawQueueArray[i]);\n        if (queue) {\n          queues.push(queue);\n        }\n      }\n      const listQueuesResponse: EntitiesResponse<QueueProperties> = Object.defineProperty(\n        queues,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<QueueProperties>;\n      listQueuesResponse.continuationToken = nextMarker;\n      return listQueuesResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListQueuesRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<QueueRuntimeProperties> {\n    try {\n      const queues: QueueRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawQueueArray: any = response.parsedBody;\n      for (let i = 0; i < rawQueueArray.length; i++) {\n        const queue = buildQueueRuntimeProperties(rawQueueArray[i]);\n        if (queue) {\n          queues.push(queue);\n        }\n      }\n      const listQueuesResponse: EntitiesResponse<QueueRuntimeProperties> = Object.defineProperty(\n        queues,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<QueueRuntimeProperties>;\n      listQueuesResponse.continuationToken = nextMarker;\n      return listQueuesResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of queues using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildQueueResponse(response: FullOperationResponse): WithResponse<QueueProperties> {\n    try {\n      const queue = buildQueue(response.parsedBody);\n      const queueResponse: WithResponse<QueueProperties> = Object.defineProperty(\n        queue || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<QueueProperties>;\n      return queueResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a queue object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildQueueRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): WithResponse<QueueRuntimeProperties> {\n    try {\n      const queue = buildQueueRuntimeProperties(response.parsedBody);\n      const queueResponse: WithResponse<QueueRuntimeProperties> = Object.defineProperty(\n        queue || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<QueueRuntimeProperties>;\n      return queueResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a queue object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListTopicsResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<TopicProperties> {\n    try {\n      const topics: TopicProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawTopicArray: any = response.parsedBody;\n      for (let i = 0; i < rawTopicArray.length; i++) {\n        const topic = buildTopic(rawTopicArray[i]);\n        if (topic) {\n          topics.push(topic);\n        }\n      }\n      const listTopicsResponse: EntitiesResponse<TopicProperties> = Object.defineProperty(\n        topics,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<TopicProperties>;\n      listTopicsResponse.continuationToken = nextMarker;\n      return listTopicsResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListTopicsRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<TopicRuntimeProperties> {\n    try {\n      const topics: TopicRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawTopicArray: any = response.parsedBody;\n      for (let i = 0; i < rawTopicArray.length; i++) {\n        const topic = buildTopicRuntimeProperties(rawTopicArray[i]);\n        if (topic) {\n          topics.push(topic);\n        }\n      }\n      const listTopicsResponse: EntitiesResponse<TopicRuntimeProperties> = Object.defineProperty(\n        topics,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<TopicRuntimeProperties>;\n      listTopicsResponse.continuationToken = nextMarker;\n      return listTopicsResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of topics using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n  private buildTopicResponse(response: FullOperationResponse): WithResponse<TopicProperties> {\n    try {\n      const topic = buildTopic(response.parsedBody);\n      const topicResponse: WithResponse<TopicProperties> = Object.defineProperty(\n        topic || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<TopicProperties>;\n      return topicResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a topic object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildTopicRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): WithResponse<TopicRuntimeProperties> {\n    try {\n      const topic = buildTopicRuntimeProperties(response.parsedBody);\n      const topicResponse: WithResponse<TopicRuntimeProperties> = Object.defineProperty(\n        topic || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<TopicRuntimeProperties>;\n      return topicResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a topic object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListSubscriptionsResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<SubscriptionProperties> {\n    try {\n      const subscriptions: SubscriptionProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawSubscriptionArray: any = response.parsedBody;\n      for (let i = 0; i < rawSubscriptionArray.length; i++) {\n        const subscription = buildSubscription(rawSubscriptionArray[i]);\n        if (subscription) {\n          subscriptions.push(subscription);\n        }\n      }\n      const listSubscriptionsResponse: EntitiesResponse<SubscriptionProperties> =\n        Object.defineProperty(subscriptions, \"_response\", {\n          value: getHttpResponseOnly(response),\n        }) as EntitiesResponse<SubscriptionProperties>;\n      listSubscriptionsResponse.continuationToken = nextMarker;\n      return listSubscriptionsResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListSubscriptionsRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<SubscriptionRuntimeProperties> {\n    try {\n      const subscriptions: SubscriptionRuntimeProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawSubscriptionArray: any = response.parsedBody;\n      for (let i = 0; i < rawSubscriptionArray.length; i++) {\n        const subscription = buildSubscriptionRuntimeProperties(rawSubscriptionArray[i]);\n        if (subscription) {\n          subscriptions.push(subscription);\n        }\n      }\n      const listSubscriptionsResponse: EntitiesResponse<SubscriptionRuntimeProperties> =\n        Object.defineProperty(subscriptions, \"_response\", {\n          value: getHttpResponseOnly(response),\n        }) as EntitiesResponse<SubscriptionRuntimeProperties>;\n      listSubscriptionsResponse.continuationToken = nextMarker;\n      return listSubscriptionsResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of subscriptions using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildSubscriptionResponse(\n    response: FullOperationResponse,\n  ): WithResponse<SubscriptionProperties> {\n    try {\n      const subscription = buildSubscription(response.parsedBody);\n      const subscriptionResponse: WithResponse<SubscriptionProperties> = Object.defineProperty(\n        subscription || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<SubscriptionProperties>;\n      return subscriptionResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildSubscriptionRuntimePropertiesResponse(\n    response: FullOperationResponse,\n  ): WithResponse<SubscriptionRuntimeProperties> {\n    try {\n      const subscription = buildSubscriptionRuntimeProperties(response.parsedBody);\n      const subscriptionResponse: WithResponse<SubscriptionRuntimeProperties> =\n        Object.defineProperty(subscription || {}, \"_response\", {\n          value: getHttpResponseOnly(response),\n        }) as WithResponse<SubscriptionRuntimeProperties>;\n      return subscriptionResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a subscription object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildListRulesResponse(\n    response: FullOperationResponse,\n  ): EntitiesResponse<RuleProperties> {\n    try {\n      const rules: RuleProperties[] = [];\n      const nextMarker = this.getMarkerFromNextLinkUrl(response.parsedBody.nextLink);\n      if (!Array.isArray(response.parsedBody)) {\n        throw new TypeError(`${response.parsedBody} was expected to be of type Array`);\n      }\n      const rawRuleArray: any = response.parsedBody;\n      for (let i = 0; i < rawRuleArray.length; i++) {\n        const rule = buildRule(rawRuleArray[i]);\n        if (rule) {\n          rules.push(rule);\n        }\n      }\n      const listRulesResponse: EntitiesResponse<RuleProperties> = Object.defineProperty(\n        rules,\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as EntitiesResponse<RuleProperties>;\n      listRulesResponse.continuationToken = nextMarker;\n      return listRulesResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a list of rules using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private buildRuleResponse(response: FullOperationResponse): WithResponse<RuleProperties> {\n    try {\n      const rule = buildRule(response.parsedBody);\n      const ruleResponse: WithResponse<RuleProperties> = Object.defineProperty(\n        rule || {},\n        \"_response\",\n        {\n          value: getHttpResponseOnly(response),\n        },\n      ) as WithResponse<RuleProperties>;\n      return ruleResponse;\n    } catch (err: any) {\n      logger.logError(err, \"Failure parsing response from service\");\n      throw new RestError(\n        `Error occurred while parsing the response body - cannot form a rule object using the response from the service.`,\n        {\n          code: RestError.PARSE_ERROR,\n          statusCode: response.status,\n          request: response.request,\n          response,\n        },\n      );\n    }\n  }\n\n  private throwIfInvalidContinuationToken(token: string | undefined): void {\n    if (!(token === undefined || (typeof token === \"string\" && Number(token) >= 0))) {\n      throw new Error(`Invalid continuationToken ${token} provided`);\n    }\n  }\n}\n"]}