{"version":3,"file":"semaphore.js","sourceRoot":"","sources":["../../../src/util/semaphore.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAElC;;;GAGG;AACH,MAAa,SAAS;IAOpB,YAAY,KAAa;QAFjB,WAAM,GAA+D,EAAE,CAAC;QACxE,UAAK,GAAW,CAAC,CAAC;QAExB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;YAC9B,MAAM,IAAI,SAAS,CAAC,sCAAsC,OAAO,KAAK,EAAE,CAAC,CAAC;QAC5E,CAAC;QAED,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;YACd,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;QACjD,CAAC;QACD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IAED;;;OAGG;IACH,OAAO;QACL,IAAI,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;YAC5B,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;YAChB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3B,CAAC;QAED,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAC5B,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACH,OAAO;QACL,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;YACvB,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;YACjC,IAAI,IAAI,EAAE,CAAC;gBACT,IAAI,EAAE,CAAC;YACT,CAAC;QACH,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACH,GAAG,CAAI,EAA4B;QACjC,OAAO,IAAI,CAAC,OAAO,EAAE;aAClB,IAAI,CAAC,EAAE,CAAC;aACR,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE;YACZ,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,OAAO,GAAG,CAAC;QACb,CAAC,CAAC;aACD,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;YACb,IAAI,CAAC,OAAO,EAAE,CAAC;YACf,MAAM,GAAG,CAAC;QACZ,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;OAEG;IACH,gBAAgB;QACd,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,gBAAgB;QACd,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;IAC5B,CAAC;CACF;AA/ED,8BA+EC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * @internal\n * A simple Semaphore\n */\nexport class Semaphore {\n  /**\n   * The number of concurrent calls that can be made.\n   */\n  limit: number;\n  private _queue: ((value?: void | PromiseLike<void> | undefined) => void)[] = [];\n  private _used: number = 0;\n  constructor(limit: number) {\n    if (typeof limit !== \"number\") {\n      throw new TypeError(`Expected limit to be a number, got ${typeof limit}`);\n    }\n\n    if (limit < 1) {\n      throw new Error(\"limit cannot be less than 1\");\n    }\n    this.limit = limit;\n  }\n\n  /**\n   * Acquires a lock from the semaphore, returns a Promise that resolves when the caller holds\n   * a lock.\n   */\n  acquire(): Promise<void> {\n    if (this._used < this.limit) {\n      this._used += 1;\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve) => {\n      this._queue.push(resolve);\n    });\n  }\n\n  /**\n   * Releases a lock back to the semaphore.\n   */\n  release(): void {\n    if (this._queue.length) {\n      const item = this._queue.shift();\n      if (item) {\n        item();\n      }\n    } else {\n      this._used -= 1;\n    }\n  }\n\n  /**\n   * Aquires a lock from the semaphore and then execute the fn. If the fn returns a Promise,\n   * wait for that promise to settle and then release the lock back to the semaphore.\n   * @param fn - The function that needs to be executed in the ciritical region.\n   * @returns A Promise that will settle with the return value of fn.\n   */\n  use<T>(fn: () => T | PromiseLike<T>): Promise<T> {\n    return this.acquire()\n      .then(fn)\n      .then((val) => {\n        this.release();\n        return val;\n      })\n      .catch((err) => {\n        this.release();\n        throw err;\n      });\n  }\n\n  /**\n   * Provides the number of locks currently held.\n   */\n  currentLockCount(): number {\n    return this._used;\n  }\n\n  /**\n   * Provides the number of tasks waiting to acquire a lock.\n   */\n  awaitedTaskCount(): number {\n    return this._queue.length;\n  }\n}\n"]}