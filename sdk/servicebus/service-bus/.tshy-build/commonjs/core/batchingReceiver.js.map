{"version":3,"file":"batchingReceiver.js","sourceRoot":"","sources":["../../../src/core/batchingReceiver.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { receiverLogger as logger } from \"../log.js\";\nimport type {\n  AmqpError,\n  EventContext,\n  OnAmqpEvent,\n  Receiver as RheaPromiseReceiver,\n  Session,\n} from \"rhea-promise\";\nimport { ReceiverEvents, SessionEvents } from \"rhea-promise\";\nimport { ServiceBusMessageImpl } from \"../serviceBusMessage.js\";\nimport type { OnAmqpEventAsPromise, ReceiveOptions } from \"./messageReceiver.js\";\nimport { MessageReceiver } from \"./messageReceiver.js\";\nimport type { ConnectionContext } from \"../connectionContext.js\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors.js\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { checkAndRegisterWithAbortSignal } from \"../util/utils.js\";\nimport { receiveDrainTimeoutInMs } from \"../util/constants.js\";\nimport type { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs.js\";\nimport { toProcessingSpanOptions } from \"../diagnostics/instrumentServiceBusMessage.js\";\nimport type { ReceiveMode } from \"../models.js\";\nimport { ServiceBusError, translateServiceBusError } from \"../serviceBusError.js\";\nimport { tracingClient } from \"../diagnostics/tracing.js\";\n\n/**\n * Describes the batching receiver where the user can receive a specified number of messages for\n * a predefined time.\n * @internal\n */\nexport class BatchingReceiver extends MessageReceiver {\n  /**\n   * Instantiate a new BatchingReceiver.\n   *\n   * @param identifier - name to identify this receiver.\n   * @param connectionContext - The client entity context.\n   * @param options - Options for how you'd like to connect.\n   */\n  constructor(\n    identifier: string,\n    connectionContext: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions,\n  ) {\n    super(identifier, connectionContext, entityPath, \"batching\", options);\n\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      connectionContext,\n      entityPath,\n      async (abortSignal?: AbortSignalLike): Promise<MinimalReceiver | undefined> => {\n        let lastError: Error | AmqpError | undefined;\n\n        const rcvrOptions = this._createReceiverOptions(false, {\n          onError: (context) => {\n            lastError = context?.receiver?.error;\n          },\n          onSessionError: (context) => {\n            lastError = context?.session?.error;\n          },\n          onClose: async () => {\n            /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */\n          },\n          onSessionClose: async () => {\n            /** Nothing to do here - the next call will just fail so they'll get an appropriate error from somewhere else. */\n          },\n          onMessage: async () => {\n            /** Nothing to do here -  we don't add credits initially so we don't need to worry about handling any messages.*/\n          },\n        });\n\n        await this._init(rcvrOptions, abortSignal);\n\n        if (lastError != null) {\n          throw lastError;\n        }\n\n        return this.link;\n      },\n      this.receiveMode,\n      options.skipParsingBodyAsJson ?? false,\n      options.skipConvertingDate ?? false,\n    );\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages;\n  }\n\n  /**\n   * To be called when connection is disconnected to gracefully close ongoing receive request.\n   * @param connectionError - The connection error if any.\n   */\n  async onDetached(connectionError?: AmqpError | Error): Promise<void> {\n    await this.closeLink();\n\n    if (connectionError == null) {\n      connectionError = new Error(\n        \"Unknown error occurred on the AMQP connection while receiving messages.\",\n      );\n    }\n\n    this._batchingReceiverLite.terminate(connectionError);\n  }\n\n  /**\n   * Receives a batch of messages from a ServiceBus Queue/Topic.\n   * @param maxMessageCount - The maximum number of messages to receive.\n   * In Peeklock mode, this number is capped at 2047 due to constraints of the underlying buffer.\n   * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * @param maxTimeAfterFirstMessageInMs - The total amount of time to wait after the first message\n   * has been received. Defaults to 1 second.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns A promise that resolves with an array of Message objects.\n   */\n  async receive(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase,\n  ): Promise<ServiceBusMessageImpl[]> {\n    throwErrorIfConnectionClosed(this._context);\n    try {\n      const messages = await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options,\n      });\n\n      if (this._lockRenewer) {\n        for (const message of messages) {\n          this._lockRenewer.start(this, message, (_error) => {\n            // the auto lock renewer already logs this in a detailed way. So this hook is mainly here\n            // to potentially forward the error to the user (which we're not doing yet)\n          });\n        }\n      }\n\n      return messages;\n    } catch (error: any) {\n      logger.logError(error, \"[%s] Rejecting receiveMessages()\", this.logPrefix);\n      throw error;\n    }\n  }\n\n  static create(\n    clientId: string,\n    context: ConnectionContext,\n    entityPath: string,\n    options: ReceiveOptions,\n  ): BatchingReceiver {\n    throwErrorIfConnectionClosed(context);\n    const bReceiver = new BatchingReceiver(clientId, context, entityPath, options);\n    context.messageReceivers[bReceiver.name] = bReceiver;\n    return bReceiver;\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.messageReceivers[this.name];\n  }\n}\n\n/**\n * Gets a function that returns the smaller of the two timeouts,\n * taking into account elapsed time from when getRemainingWaitTimeInMsFn\n * was called.\n *\n * @param maxWaitTimeInMs - Maximum time to wait for the first message\n * @param maxTimeAfterFirstMessageInMs - Maximum time to wait after the first message before completing the receive.\n *\n * @internal\n */\nexport function getRemainingWaitTimeInMsFn(\n  maxWaitTimeInMs: number,\n  maxTimeAfterFirstMessageInMs: number,\n): () => number {\n  const startTimeMs = Date.now();\n\n  return () => {\n    const remainingTimeMs = maxWaitTimeInMs - (Date.now() - startTimeMs);\n\n    if (remainingTimeMs < 0) {\n      return 0;\n    }\n\n    return Math.min(remainingTimeMs, maxTimeAfterFirstMessageInMs);\n  };\n}\n\n/**\n * Useful interface that mimics EventEmitter without requiring us to actually\n * import the events definition (which is annoying with browsers).\n *\n * @internal\n */\ntype EventEmitterLike<T extends RheaPromiseReceiver | Session> = Pick<\n  T,\n  \"once\" | \"removeListener\" | \"on\"\n>;\n\n/**\n * The bare minimum needed to receive messages for batched\n * message receiving.\n *\n * @internal\n */\nexport type MinimalReceiver = Pick<\n  RheaPromiseReceiver,\n  \"name\" | \"isOpen\" | \"credit\" | \"addCredit\" | \"drain\" | \"drainCredit\" | \"close\"\n> &\n  EventEmitterLike<RheaPromiseReceiver> & {\n    session: EventEmitterLike<Session>;\n  } & {\n    connection: {\n      id: string;\n    };\n  };\n\n/**\n * @internal\n */\ntype MessageAndDelivery = Pick<EventContext, \"message\" | \"delivery\">;\n\n/**\n * @internal\n */\ninterface ReceiveMessageArgs extends OperationOptionsBase {\n  maxMessageCount: number;\n  maxWaitTimeInMs: number;\n  maxTimeAfterFirstMessageInMs: number;\n}\n\n/**\n * The internals of a batching receiver minus anything that would require us to hold onto a client entity context\n * or a receiver on a permanent basis.\n *\n * Usable with both session and non-session receivers.\n *\n * @internal\n */\nexport class BatchingReceiverLite {\n  // testing hook\n  private _drainTimeoutInMs: number = receiveDrainTimeoutInMs;\n  constructor(\n    private _connectionContext: ConnectionContext,\n    public entityPath: string,\n    private _getCurrentReceiver: (\n      abortSignal?: AbortSignalLike,\n    ) => Promise<MinimalReceiver | undefined>,\n    private _receiveMode: ReceiveMode,\n    _skipParsingBodyAsJson: boolean,\n    _skipConvertingDate: boolean,\n  ) {\n    this._createServiceBusMessage = (context: MessageAndDelivery) => {\n      return new ServiceBusMessageImpl(\n        context.message!,\n        context.delivery!,\n        true,\n        this._receiveMode,\n        _skipParsingBodyAsJson,\n        _skipConvertingDate,\n      );\n    };\n\n    this._getRemainingWaitTimeInMsFn = (\n      maxWaitTimeInMs: number,\n      maxTimeAfterFirstMessageInMs: number,\n    ) => getRemainingWaitTimeInMsFn(maxWaitTimeInMs, maxTimeAfterFirstMessageInMs);\n\n    this.isReceivingMessages = false;\n  }\n\n  private _createServiceBusMessage: (\n    context: Pick<EventContext, \"message\" | \"delivery\">,\n  ) => ServiceBusMessageImpl;\n\n  private _getRemainingWaitTimeInMsFn: typeof getRemainingWaitTimeInMsFn;\n  private _closeHandler: ((connectionError?: AmqpError | Error) => void) | undefined;\n  private _finalAction: (() => void) | undefined;\n\n  isReceivingMessages: boolean;\n\n  /**\n   * Receives a set of messages,\n   *\n   * @internal\n   * @hidden\n   */\n  public async receiveMessages(args: ReceiveMessageArgs): Promise<ServiceBusMessageImpl[]> {\n    try {\n      this.isReceivingMessages = true;\n      const receiver = await this._getCurrentReceiver(args.abortSignal);\n\n      if (receiver == null) {\n        // (was somehow closed in between the init() and the return)\n        throw new ServiceBusError(\"Link closed before receiving messages.\", \"GeneralError\");\n      }\n\n      const messages = await new Promise<ServiceBusMessageImpl[]>((resolve, reject) =>\n        this._receiveMessagesImpl(receiver, args, resolve, reject),\n      );\n      return tracingClient.withSpan(\n        \"BatchingReceiverLite.process\",\n        args,\n        () => messages,\n        toProcessingSpanOptions(messages, this, this._connectionContext.config, \"process\"),\n      );\n    } finally {\n      this._closeHandler = undefined;\n      this.isReceivingMessages = false;\n    }\n  }\n\n  /**\n   * Closes the receiver (optionally with an error), cancelling any current operations.\n   *\n   * @param connectionError - An optional error (rhea doesn't always deliver one for certain disconnection events)\n   */\n  terminate(connectionError?: Error | AmqpError): void {\n    if (this._closeHandler) {\n      this._closeHandler(connectionError);\n      this._closeHandler = undefined;\n    }\n  }\n\n  private async tryDrainReceiver(\n    receiver: MinimalReceiver,\n    loggingPrefix: string,\n    remainingWaitTimeInMs: number,\n    abortSignal?: AbortSignalLike,\n  ): Promise<void> {\n    if (!receiver.isOpen() || receiver.credit <= 0) {\n      return;\n    }\n    let drainTimedout: boolean = false;\n    let drainTimer: ReturnType<typeof setTimeout>;\n    const timeToWaitInMs = Math.max(this._drainTimeoutInMs, remainingWaitTimeInMs);\n    const drainPromise = new Promise<void>((resolve) => {\n      function drainListener(): void {\n        logger.verbose(`${loggingPrefix} Receiver has been drained.`);\n        clearTimeout(drainTimer);\n        resolve();\n      }\n      function removeListeners(): void {\n        abortSignal?.removeEventListener(\"abort\", onAbort);\n        receiver.removeListener(ReceiverEvents.receiverDrained, drainListener);\n      }\n      function onAbort(): void {\n        removeListeners();\n        clearTimeout(drainTimer);\n        resolve();\n      }\n\n      drainTimer = setTimeout(() => {\n        drainTimedout = true;\n        removeListeners();\n        resolve();\n      }, timeToWaitInMs);\n      receiver.once(ReceiverEvents.receiverDrained, drainListener);\n      abortSignal?.addEventListener(\"abort\", onAbort);\n    });\n\n    receiver.drainCredit();\n    logger.verbose(\n      `${loggingPrefix} Draining leftover credits(${receiver.credit}), waiting for event_drained event, or timing out after ${timeToWaitInMs} milliseconds...`,\n    );\n    await drainPromise;\n    if (drainTimedout) {\n      logger.warning(\n        `${loggingPrefix} Time out after ${timeToWaitInMs} milliseconds when draining credits. Closing receiver...`,\n      );\n      // Close the receiver link since we have not received the receiver drain event\n      // to prevent out-of-sync state between local and remote\n      await receiver.close();\n    }\n\n    // Turn off draining.\n    receiver.drain = false;\n  }\n\n  private _receiveMessagesImpl(\n    receiver: MinimalReceiver,\n    args: ReceiveMessageArgs,\n    origResolve: (messages: ServiceBusMessageImpl[]) => void,\n    origReject: (err: Error | AmqpError) => void,\n  ): void {\n    const getRemainingWaitTimeInMs = this._getRemainingWaitTimeInMsFn(\n      args.maxWaitTimeInMs,\n      args.maxTimeAfterFirstMessageInMs,\n    );\n\n    const brokeredMessages: ServiceBusMessageImpl[] = [];\n    const loggingPrefix = `[${receiver.connection.id}|r:${receiver.name}]`;\n\n    let totalWaitTimer: NodeJS.Timeout | undefined;\n    // eslint-disable-next-line prefer-const\n    let cleanupBeforeResolveOrReject: () => void;\n\n    const rejectAfterCleanup = (err: Error | AmqpError): void => {\n      cleanupBeforeResolveOrReject();\n      origReject(err);\n    };\n\n    const resolveImmediately = (result: ServiceBusMessageImpl[]): void => {\n      cleanupBeforeResolveOrReject();\n      origResolve(result);\n    };\n\n    const resolveAfterPendingMessageCallbacks = (result: ServiceBusMessageImpl[]): void => {\n      // NOTE: through rhea-promise, most of our event handlers are made asynchronous by calling setTimeout(emit).\n      // However, a small set (*error and drain) execute immediately. This can lead to a situation where the logical\n      // ordering of events is correct but the execution order is incorrect because the events are not all getting\n      // put into the task queue the same way.\n      // setTimeout() ensures that we resolve _after_ any already-queued onMessage handlers that may\n      // be waiting in the task queue.\n      setTimeout(() => {\n        cleanupBeforeResolveOrReject();\n        origResolve(result);\n      });\n    };\n\n    const onError: OnAmqpEvent = (context: EventContext) => {\n      const eventType = context.session?.error != null ? \"session_error\" : \"receiver_error\";\n      let error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        error = translateServiceBusError(error);\n        logger.logError(error, `${loggingPrefix} '${eventType}' event occurred. Received an error`);\n      } else {\n        error = new ServiceBusError(\"An error occurred while receiving messages.\", \"GeneralError\");\n      }\n      rejectAfterCleanup(error);\n    };\n\n    this._closeHandler = (error?: AmqpError | Error): void => {\n      if (\n        // no error, just closing. Go ahead and return what we have.\n        error == null ||\n        // Return the collected messages if in ReceiveAndDelete mode because otherwise they are lost forever\n        (this._receiveMode === \"receiveAndDelete\" && brokeredMessages.length)\n      ) {\n        logger.verbose(\n          `${loggingPrefix} Closing. Resolving with ${brokeredMessages.length} messages.`,\n        );\n        return resolveAfterPendingMessageCallbacks(brokeredMessages);\n      }\n\n      rejectAfterCleanup(translateServiceBusError(error));\n    };\n\n    let abortSignalCleanupFunction: (() => void) | undefined = undefined;\n\n    // Final action to be performed after\n    // - maxMessageCount is reached or\n    // - maxWaitTime is passed or\n    // - newMessageWaitTimeoutInSeconds is passed since the last message was received\n    this._finalAction = async (): Promise<void> => {\n      if (receiver.drain) {\n        // If a drain is already in process then we should let it complete. Some messages might still be in flight, but they will\n        // arrive before the drain completes.\n        logger.verbose(`${loggingPrefix} Already draining.`);\n        return;\n      }\n\n      const remainingWaitTimeInMs = getRemainingWaitTimeInMs();\n      await this.tryDrainReceiver(receiver, loggingPrefix, remainingWaitTimeInMs, args.abortSignal);\n      logger.verbose(\n        `${loggingPrefix} Resolving receiveMessages() with ${brokeredMessages.length} messages.`,\n      );\n      resolveImmediately(brokeredMessages);\n    };\n\n    // Action to be performed on the \"message\" event.\n    const onReceiveMessage: OnAmqpEventAsPromise = async (context: EventContext) => {\n      // TODO: this appears to be aggravating a bug that we need to look into more deeply.\n      // The same timeout+drain sequence should work fine for receiveAndDelete but it appears\n      // to cause problems.\n      if (this._receiveMode === \"peekLock\") {\n        if (brokeredMessages.length === 0) {\n          // We'll now remove the old timer (which was the overall `maxWaitTimeMs` timer)\n          // and replace it with another timer that is a (probably) much shorter interval.\n          //\n          // This allows the user to get access to received messages earlier and also gives us\n          // a chance to have fewer messages internally that could get lost if the user's\n          // app crashes.\n          if (totalWaitTimer) clearTimeout(totalWaitTimer);\n          const remainingWaitTimeInMs = getRemainingWaitTimeInMs();\n          totalWaitTimer = setTimeout(() => {\n            logger.verbose(\n              `${loggingPrefix} Batching, waited for ${remainingWaitTimeInMs} milliseconds after receiving the first message.`,\n            );\n            this._finalAction!();\n          }, remainingWaitTimeInMs);\n        }\n      }\n\n      try {\n        const data: ServiceBusMessageImpl = this._createServiceBusMessage(context);\n        brokeredMessages.push(data);\n\n        // NOTE: we used to actually \"lose\" any extra messages. At this point I've fixed the areas that were causing us to receive\n        // extra messages but if this bug arises in some other way it's better to return the message than it would be to let it be\n        // silently dropped on the floor.\n        if (brokeredMessages.length > args.maxMessageCount) {\n          logger.warning(\n            `More messages arrived than expected: ${args.maxMessageCount} vs ${brokeredMessages.length}`,\n          );\n        }\n      } catch (err: any) {\n        const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n        logger.logError(\n          err,\n          `${loggingPrefix} Received an error while converting AmqpMessage to ServiceBusMessage`,\n        );\n        rejectAfterCleanup(errObj);\n      }\n      if (brokeredMessages.length >= args.maxMessageCount) {\n        this._finalAction!();\n      }\n    };\n\n    const onClose: OnAmqpEventAsPromise = async (context: EventContext) => {\n      const type = context.session?.error != null ? \"session_closed\" : \"receiver_closed\";\n      const error = context.session?.error || context.receiver?.error;\n\n      if (error) {\n        logger.logError(error, `${loggingPrefix} '${type}' event occurred. The associated error`);\n      }\n    };\n\n    cleanupBeforeResolveOrReject = (): void => {\n      if (receiver != null) {\n        receiver.removeListener(ReceiverEvents.receiverError, onError);\n        receiver.removeListener(ReceiverEvents.message, onReceiveMessage);\n        receiver.session.removeListener(SessionEvents.sessionError, onError);\n        receiver.removeListener(ReceiverEvents.receiverClose, onClose);\n        receiver.session.removeListener(SessionEvents.sessionClose, onClose);\n      }\n\n      if (totalWaitTimer) {\n        clearTimeout(totalWaitTimer);\n      }\n\n      if (abortSignalCleanupFunction) {\n        abortSignalCleanupFunction();\n      }\n      abortSignalCleanupFunction = undefined;\n    };\n\n    abortSignalCleanupFunction = checkAndRegisterWithAbortSignal((err) => {\n      if (receiver.drain) {\n        // If a drain is already in process and we cancel, the link state may be out of sync\n        // with remote. Reset the link so that we will have fresh start.\n        receiver.close();\n      }\n      rejectAfterCleanup(err);\n    }, args.abortSignal);\n\n    // By adding credit here, we let the service know that at max we can handle `maxMessageCount`\n    // number of messages concurrently. We will return the user an array of messages that can\n    // be of size upto maxMessageCount. Then the user needs to accordingly dispose\n    // (complete/abandon/defer/deadletter) the messages from the array.\n    const creditToAdd = args.maxMessageCount - receiver.credit;\n    logger.verbose(\n      `${loggingPrefix} Ensure enough credit for receiving ${args.maxMessageCount} messages. Current: ${receiver.credit}.  To add: ${creditToAdd}.`,\n    );\n\n    if (creditToAdd > 0) {\n      receiver.addCredit(creditToAdd);\n    }\n\n    logger.verbose(\n      `${loggingPrefix} Setting the wait timer for ${args.maxWaitTimeInMs} milliseconds.`,\n    );\n\n    totalWaitTimer = setTimeout(() => {\n      logger.verbose(\n        `${loggingPrefix} Batching, waited for max wait time ${args.maxWaitTimeInMs} milliseconds.`,\n      );\n      this._finalAction!();\n    }, args.maxWaitTimeInMs);\n\n    receiver.on(ReceiverEvents.message, onReceiveMessage);\n    receiver.on(ReceiverEvents.receiverError, onError);\n    receiver.on(ReceiverEvents.receiverClose, onClose);\n\n    receiver.session.on(SessionEvents.sessionError, onError);\n    receiver.session.on(SessionEvents.sessionClose, onClose);\n  }\n}\n"]}