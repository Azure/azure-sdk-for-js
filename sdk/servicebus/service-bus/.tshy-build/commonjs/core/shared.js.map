{"version":3,"file":"shared.js","sourceRoot":"","sources":["../../../src/core/shared.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;AAqClC,4CAuCC;AASD,sDA6BC;AA/GD,8DAAiE;AACjE,sCAA2C;AAE3C,gDAA6C;AAmB7C;;;;;;;;;;;GAWG;AACH,SAAgB,gBAAgB,CAC9B,SAAiB,EACjB,QAA8B,EAC9B,sBAA4D;IAE5D,IAAI,QAAQ,EAAE,CAAC;QACb,MAAM,EAAE,GAAG,QAAQ,CAAC,EAAE,CAAC;QACvB,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAY,CAAC;QACpC,MAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,CAAC;QACxC,uBAAc,CAAC,OAAO,CACpB,wEAAwE,GAAG,WAAW,EACtF,SAAS,EACT,EAAE,EACF,OAAO,EACP,KAAK,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAC3C,CAAC;QACF,IAAI,OAAO,IAAI,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;YAC9C,MAAM,OAAO,GAAG,sBAAsB,CAAC,GAAG,CAAC,EAAE,CAA4B,CAAC;YAC1E,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAC5B,uBAAc,CAAC,OAAO,CACpB,oEAAoE,EACpE,SAAS,EACT,EAAE,CACH,CAAC;YACF,MAAM,YAAY,GAAG,sBAAsB,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YACvD,uBAAc,CAAC,OAAO,CACpB,+DAA+D,EAC/D,SAAS,EACT,EAAE,EACF,YAAY,CACb,CAAC;YACF,IAAI,KAAK,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,SAAS,IAAI,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE,CAAC;gBAC/E,MAAM,KAAK,GAAG,IAAA,6CAAwB,EAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACpD,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAC/B,CAAC;YAED,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3B,CAAC;IACH,CAAC;AACH,CAAC;AAED,8GAA8G;AAC9G,MAAM,WAAW,GAAG,GAAG,qBAAS,CAAC,YAAY,UAAU,CAAC;AACxD;;;;GAIG;AACH,SAAgB,qBAAqB,CACnC,IAAY,EACZ,WAAwB,EACxB,MAAc,EACd,QAAgB,EAChB,QAA0B,EAC1B,WAAoB;IAEpB,MAAM,UAAU,GACd,WAAW,KAAK,SAAS;QACvB,CAAC,CAAC,EAAE,CAAC,qBAAS,CAAC,sBAAsB,CAAC,EAAE,QAAQ,EAAE,CAAC,WAAW,CAAC,EAAE,WAAW,EAAE;QAC9E,CAAC,CAAC,EAAE,CAAC,qBAAS,CAAC,sBAAsB,CAAC,EAAE,QAAQ,EAAE,CAAC;IACvD,MAAM,WAAW,mBACf,IAAI;QACJ,2GAA2G;QAC3G,8HAA8H;QAC9H,UAAU,EAAE,WAAW,KAAK,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK;QAC7D,uDAAuD;QACvD,eAAe,EAAE,WAAW,KAAK,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3D,6DAA6D;QAC7D,eAAe,EAAE,WAAW,KAAK,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAC3D,MAAM,EACN,MAAM,EAAE,QAAQ,EAChB,aAAa,EAAE,CAAC,EAChB,UAAU,IACP,QAAQ,CACZ,CAAC;IAEF,OAAO,WAAW,CAAC;AACrB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Delivery, ReceiverOptions, Source } from \"rhea-promise\";\nimport { translateServiceBusError } from \"../serviceBusError.js\";\nimport { receiverLogger } from \"../log.js\";\nimport type { ReceiveMode } from \"../models.js\";\nimport { Constants } from \"@azure/core-amqp\";\n\n/**\n * @internal\n */\nexport type ReceiverHandlers = Pick<\n  ReceiverOptions,\n  \"onMessage\" | \"onError\" | \"onClose\" | \"onSessionError\" | \"onSessionClose\" | \"onSettled\"\n>;\n\n/**\n * @internal\n */\nexport interface DeferredPromiseAndTimer {\n  resolve: (value?: any) => void;\n  reject: (reason?: any) => void;\n  timer: NodeJS.Timeout;\n}\n\n/**\n * This is the shared onSettled handler for all of the receiver implementations.\n *\n * The sequence is basically:\n * 1. User calls `await <ServiceBusMessage instance>.complete()`     (or other settlement methods)\n * 2. This creates a `Promise` that gets stored in the _deliveryDispositionMap\n * 3. When the service acknowledges the settlement this method gets called for that message.\n * 4. We resolve() the promise from the _deliveryDispositionMap.\n * 5. User's code after the settlement continues.\n *\n * @internal\n */\nexport function onMessageSettled(\n  logPrefix: string,\n  delivery: Delivery | undefined,\n  deliveryDispositionMap: Map<number, DeferredPromiseAndTimer>,\n): void {\n  if (delivery) {\n    const id = delivery.id;\n    const state = delivery.remote_state;\n    const settled = delivery.remote_settled;\n    receiverLogger.verbose(\n      \"%s Delivery with id %d, remote_settled: %s, remote_state: %o has been \" + \"received.\",\n      logPrefix,\n      id,\n      settled,\n      state && state.error ? state.error : state,\n    );\n    if (settled && deliveryDispositionMap.has(id)) {\n      const promise = deliveryDispositionMap.get(id) as DeferredPromiseAndTimer;\n      clearTimeout(promise.timer);\n      receiverLogger.verbose(\n        \"%s Found the delivery with id %d in the map and cleared the timer.\",\n        logPrefix,\n        id,\n      );\n      const deleteResult = deliveryDispositionMap.delete(id);\n      receiverLogger.verbose(\n        \"%s Successfully deleted the delivery with id %d from the map.\",\n        logPrefix,\n        id,\n        deleteResult,\n      );\n      if (state && state.error && (state.error.condition || state.error.description)) {\n        const error = translateServiceBusError(state.error);\n        return promise.reject(error);\n      }\n\n      return promise.resolve();\n    }\n  }\n}\n\n// Placed in Service Bus for now and can be promoted to core-amqp if also useful for Event Hubs in the future.\nconst timeoutName = `${Constants.vendorString}:timeout`;\n/**\n * Creates the options that need to be specified while creating an AMQP receiver link.\n *\n * @internal\n */\nexport function createReceiverOptions(\n  name: string,\n  receiveMode: ReceiveMode,\n  source: Source,\n  clientId: string,\n  handlers: ReceiverHandlers,\n  timeoutInMs?: number,\n): ReceiverOptions {\n  const properties =\n    timeoutInMs !== undefined\n      ? { [Constants.receiverIdentifierName]: clientId, [timeoutName]: timeoutInMs }\n      : { [Constants.receiverIdentifierName]: clientId };\n  const rcvrOptions: ReceiverOptions = {\n    name,\n    // \"autoaccept\" being true in the \"receiveAndDelete\" mode sets the \"settled\" flag to true on the deliveries\n    // which helps in clearing the circular buffer(size=2048) as it is needed to receive messages after 2048 of them are received.\n    autoaccept: receiveMode === \"receiveAndDelete\" ? true : false,\n    // receiveAndDelete -> first(0), peekLock -> second (1)\n    rcv_settle_mode: receiveMode === \"receiveAndDelete\" ? 0 : 1,\n    // receiveAndDelete -> settled (1), peekLock -> unsettled (0)\n    snd_settle_mode: receiveMode === \"receiveAndDelete\" ? 1 : 0,\n    source,\n    target: clientId,\n    credit_window: 0,\n    properties,\n    ...handlers,\n  };\n\n  return rcvrOptions;\n}\n"]}