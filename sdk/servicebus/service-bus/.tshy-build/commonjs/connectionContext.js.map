{"version":3,"file":"connectionContext.js","sourceRoot":"","sources":["../../src/connectionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { connectionLogger as logger } from \"./log.js\";\nimport { packageJsonInfo } from \"./util/constants.js\";\nimport type {\n  ConnectionConfig,\n  CreateConnectionContextBaseParameters,\n  SasTokenProvider,\n} from \"@azure/core-amqp\";\nimport { ConnectionContextBase } from \"@azure/core-amqp\";\nimport type { TokenCredential } from \"@azure/core-auth\";\nimport type { ServiceBusClientOptions } from \"./constructorHelpers.js\";\nimport type {\n  AmqpError,\n  Connection,\n  ConnectionError,\n  EventContext,\n  OnAmqpEvent,\n} from \"rhea-promise\";\nimport { ConnectionEvents } from \"rhea-promise\";\nimport type { MessageSender } from \"./core/messageSender.js\";\nimport type { MessageSession } from \"./session/messageSession.js\";\nimport type { MessageReceiver } from \"./core/messageReceiver.js\";\nimport { ManagementClient } from \"./core/managementClient.js\";\nimport { formatUserAgentPrefix } from \"./util/utils.js\";\nimport { getRuntimeInfo } from \"./util/runtimeInfo.js\";\nimport type { NonSessionReceiverType, ReceiverType } from \"./core/linkEntity.js\";\nimport { ServiceBusError } from \"./serviceBusError.js\";\n\n/**\n * @internal\n * Provides contextual information like the underlying amqp connection, cbs session, management session,\n * tokenCredential, senders, receivers, etc. about the ServiceBus client.\n */\nexport interface ConnectionContext extends ConnectionContextBase {\n  /**\n   * The credential to be used for Authentication.\n   * Default value: SasTokenProvider.\n   */\n  tokenCredential: SasTokenProvider | TokenCredential;\n  /**\n   * A map of active Service Bus Senders with sender name as key.\n   */\n  senders: { [name: string]: MessageSender };\n  /**\n   * A map of active Service Bus receivers for non session enabled queues/subscriptions\n   * with receiver name as key.\n   */\n  messageReceivers: { [name: string]: MessageReceiver };\n  /**\n   * A map of active Service Bus receivers for session enabled queues/subscriptions\n   * with receiver name as key.\n   */\n  messageSessions: { [name: string]: MessageSession };\n  /**\n   * A map of ManagementClient instances for operations over the $management link\n   * with key as the entity path.\n   */\n  managementClients: { [name: string]: ManagementClient };\n  /**\n   * Function returning a promise that resolves once the connectionContext is ready to open an AMQP link.\n   * ConnectionContext will be ready to open an AMQP link when:\n   * - The AMQP connection is already open on both sides.\n   * - The AMQP connection has been closed or disconnected. In this case, a new AMQP connection is expected\n   * to be created first.\n   * An AMQP link cannot be opened if the AMQP connection\n   * is in the process of closing or disconnecting.\n   */\n  readyToOpenLink(): Promise<void>;\n  /**\n   * Fetches the receiver from the cache in ConnectionContext based on the receiverName given.\n   * Useful for when a message needs to be settled or have its lock renewed.\n   *\n   * TODO: Track the right receiver on the message instead of the ConnectionContext to remove\n   * the need for this helper.\n   */\n  getReceiverFromCache(\n    receiverName: string,\n    sessionId?: string,\n  ): MessageReceiver | MessageSession | undefined;\n  /**\n   * Gets the management client for given entity path from the cache\n   * Creates one if none exists in the cache\n   */\n  getManagementClient(entityPath: string): ManagementClient;\n  /**\n   * Indicates whether the connection is in the process of closing.\n   * When this returns `true`, a `disconnected` event will be received\n   * after the connection is closed.\n   */\n  isConnectionClosing(): boolean;\n}\n\n/**\n * Describes the members on the ConnectionContext that are only\n * used by it internally.\n * @hidden\n * @internal\n */\nexport interface ConnectionContextInternalMembers extends ConnectionContext {\n  /**\n   * Resolves once the context's connection emits a `disconnected` event.\n   */\n  waitForDisconnectedEvent(): Promise<void>;\n  /**\n   * Resolves once the connection has finished being reset.\n   * Connections are reset as part of reacting to a `disconnected` event.\n   */\n  waitForConnectionReset(): Promise<void>;\n}\n\n/**\n * @internal\n * Helper type to get the names of all the functions on an object.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\n/**\n * @internal\n * Helper type to get the types of all the functions on an object.\n */\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n/**\n * @internal\n * Helper type to get the types of all the functions on ConnectionContext\n * and the internal methods from ConnectionContextInternalMembers.\n * Note that this excludes the functions that ConnectionContext inherits.\n * Each function also has its `this` type set as `ConnectionContext`.\n */\ntype ConnectionContextMethods = Omit<\n  FunctionProperties<ConnectionContextInternalMembers>,\n  FunctionPropertyNames<ConnectionContextBase>\n> &\n  ThisType<ConnectionContextInternalMembers>;\n\n/**\n * @internal\n * Helper method to call onDetached on the non-sessions batching and streaming receivers from the connection context upon seeing an error.\n */\nasync function callOnDetachedOnReceivers(\n  connectionContext: ConnectionContext,\n  contextOrConnectionError: Error | ConnectionError | AmqpError | undefined,\n  receiverType: NonSessionReceiverType,\n): Promise<void[]> {\n  const detachCalls: Promise<void>[] = [];\n\n  // Iterating over non-sessions batching and streaming receivers\n  for (const receiverName of Object.keys(connectionContext.messageReceivers)) {\n    const receiver = connectionContext.messageReceivers[receiverName];\n    if (receiver && receiver.receiverType === receiverType) {\n      logger.verbose(\n        \"[%s] calling detached on %s receiver '%s'.\",\n        connectionContext.connection.id,\n        receiver.receiverType,\n        receiver.name,\n      );\n      detachCalls.push(\n        receiver.onDetached(contextOrConnectionError).catch((err) => {\n          logger.logError(\n            err,\n            \"[%s] An error occurred while calling onDetached() on the %s receiver '%s'\",\n            connectionContext.connection.id,\n            receiver.receiverType,\n            receiver.name,\n          );\n        }),\n      );\n    }\n  }\n  return Promise.all(detachCalls);\n}\n\n/**\n * @internal\n * Helper method to call onDetached on the session receivers from the connection context upon seeing an error.\n */\nasync function callOnDetachedOnSessionReceivers(\n  connectionContext: ConnectionContext,\n  contextOrConnectionError: Error | ConnectionError | AmqpError | undefined,\n): Promise<void[]> {\n  const getSessionError = (sessionId: string, entityPath: string): ServiceBusError => {\n    const sessionInfo =\n      `The receiver for session \"${sessionId}\" in \"${entityPath}\" has been closed and can no longer be used. ` +\n      `Please create a new receiver using the \"acceptSession\" or \"acceptNextSession\" method on the ServiceBusClient.`;\n\n    const errorMessage =\n      contextOrConnectionError == null\n        ? `Unknown error occurred on the AMQP connection while receiving messages. ` + sessionInfo\n        : `Error occurred on the AMQP connection while receiving messages. ` +\n          sessionInfo +\n          `\\nMore info - \\n${contextOrConnectionError}`;\n\n    const error = new ServiceBusError(errorMessage, \"SessionLockLost\");\n    error.retryable = false;\n    return error;\n  };\n\n  const detachCalls: Promise<void>[] = [];\n\n  for (const receiverName of Object.keys(connectionContext.messageSessions)) {\n    const receiver = connectionContext.messageSessions[receiverName];\n    logger.verbose(\n      \"[%s] calling detached on %s receiver(sessions).\",\n      connectionContext.connection.id,\n      receiver.name,\n    );\n    detachCalls.push(\n      receiver.onDetached(getSessionError(receiver.sessionId, receiver.entityPath)).catch((err) => {\n        logger.logError(\n          err,\n          \"[%s] An error occurred while calling onDetached() on the session receiver(sessions) '%s'\",\n          connectionContext.connection.id,\n          receiver.name,\n        );\n      }),\n    );\n  }\n\n  return Promise.all(detachCalls);\n}\n\n/**\n * @internal\n * Helper method to get the number of receivers of specified type from the connectionContext.\n */\nfunction getNumberOfReceivers(\n  connectionContext: Pick<ConnectionContext, \"messageReceivers\" | \"messageSessions\">,\n  receiverType: ReceiverType,\n): number {\n  if (receiverType === \"session\") {\n    const receivers = connectionContext.messageSessions;\n    return Object.keys(receivers).length;\n  }\n  const receivers = connectionContext.messageReceivers;\n  const receiverNames = Object.keys(receivers);\n  const count = receiverNames.reduce(\n    (acc, name) => (receivers[name].receiverType === receiverType ? ++acc : acc),\n    0,\n  );\n  return count;\n}\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace ConnectionContext {\n  export function create(\n    config: ConnectionConfig,\n    tokenCredential: SasTokenProvider | TokenCredential,\n    options?: ServiceBusClientOptions,\n  ): ConnectionContext {\n    if (!options) options = {};\n    const userAgent = `${formatUserAgentPrefix(\n      options.userAgentOptions?.userAgentPrefix,\n    )} ${getRuntimeInfo()}`;\n    const parameters: CreateConnectionContextBaseParameters = {\n      config: config,\n      // re-enabling this will be a post-GA discussion similar to event-hubs.\n      // dataTransformer: options.dataTransformer,\n      isEntityPathRequired: false,\n      connectionProperties: {\n        product: \"MSJSClient\",\n        userAgent,\n        version: packageJsonInfo.version,\n      },\n    };\n    // Let us create the base context and then add ServiceBus specific ConnectionContext properties.\n    const connectionContext = ConnectionContextBase.create(parameters) as ConnectionContext;\n    connectionContext.tokenCredential = tokenCredential;\n    connectionContext.senders = {};\n    connectionContext.messageReceivers = {};\n    connectionContext.messageSessions = {};\n    connectionContext.managementClients = {};\n\n    let waitForConnectionRefreshResolve: () => void;\n    let waitForConnectionRefreshPromise: Promise<void> | undefined;\n    Object.assign<ConnectionContext, ConnectionContextMethods>(connectionContext, {\n      isConnectionClosing() {\n        // When the connection is not open, but the remote end is open,\n        // then the rhea connection is in the process of terminating.\n        return Boolean(!this.connection.isOpen() && this.connection.isRemoteOpen());\n      },\n      async readyToOpenLink() {\n        logger.verbose(\n          `[${this.connectionId}] Waiting until the connection is ready to open link.`,\n        );\n        // Check that the connection isn't in the process of closing.\n        // This can happen when the idle timeout has been reached but\n        // the underlying socket is waiting to be destroyed.\n        if (this.isConnectionClosing()) {\n          logger.verbose(\n            `[${this.connectionId}] Connection is closing, waiting for disconnected event`,\n          );\n          // Wait for the disconnected event that indicates the underlying socket has closed.\n          await this.waitForDisconnectedEvent();\n        }\n\n        // Wait for the connection to be reset.\n        await this.waitForConnectionReset();\n        logger.verbose(`[${this.connectionId}] Connection is ready to open link.`);\n      },\n      waitForDisconnectedEvent() {\n        return new Promise((resolve) => {\n          logger.verbose(\n            `[${this.connectionId}] Attempting to reinitialize connection` +\n              ` but the connection is in the process of closing.` +\n              ` Waiting for the disconnect event before continuing.`,\n          );\n          this.connection.once(ConnectionEvents.disconnected, resolve);\n        });\n      },\n      waitForConnectionReset() {\n        // Check if the connection is currently in the process of disconnecting.\n        if (waitForConnectionRefreshPromise) {\n          logger.verbose(`[${this.connectionId}] Waiting for connection reset`);\n          return waitForConnectionRefreshPromise;\n        }\n\n        logger.verbose(\n          `[${this.connectionId}] Connection not waiting to be reset. Resolving immediately.`,\n        );\n        return Promise.resolve();\n      },\n      getReceiverFromCache(\n        receiverName: string,\n        sessionId?: string,\n      ): MessageReceiver | MessageSession | undefined {\n        if (sessionId != null && this.messageSessions[receiverName]) {\n          return this.messageSessions[receiverName];\n        }\n\n        if (this.messageReceivers[receiverName]) {\n          return this.messageReceivers[receiverName];\n        }\n\n        let existingReceivers = \"\";\n        if (sessionId != null) {\n          for (const messageSessionName of Object.keys(this.messageSessions)) {\n            if (this.messageSessions[messageSessionName].sessionId === sessionId) {\n              existingReceivers = this.messageSessions[messageSessionName].name;\n              break;\n            }\n          }\n        } else {\n          existingReceivers +=\n            (existingReceivers ? \", \" : \"\") + Object.keys(this.messageReceivers).join(\",\");\n        }\n\n        logger.verbose(\n          \"[%s] Failed to find receiver '%s' among existing receivers: %s\",\n          this.connectionId,\n          receiverName,\n          existingReceivers,\n        );\n        return;\n      },\n      getManagementClient(entityPath: string): ManagementClient {\n        if (!this.managementClients[entityPath]) {\n          this.managementClients[entityPath] = new ManagementClient(this, entityPath, {\n            address: `${entityPath}/$management`,\n          });\n        }\n        return this.managementClients[entityPath];\n      },\n    });\n\n    // Define listeners to be added to the connection object for\n    // \"connection_open\" and \"connection_error\" events.\n    const onConnectionOpen: OnAmqpEvent = () => {\n      connectionContext.wasConnectionCloseCalled = false;\n      logger.verbose(\n        \"[%s] setting 'wasConnectionCloseCalled' property of connection context to %s.\",\n        connectionContext.connection.id,\n        connectionContext.wasConnectionCloseCalled,\n      );\n    };\n\n    const disconnected: OnAmqpEvent = async (context: EventContext) => {\n      if (waitForConnectionRefreshPromise) {\n        return;\n      }\n\n      waitForConnectionRefreshPromise = new Promise((resolve) => {\n        waitForConnectionRefreshResolve = resolve;\n      });\n\n      const connectionError =\n        context.connection && context.connection.error ? context.connection.error : undefined;\n      if (connectionError) {\n        logger.logError(\n          connectionError,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n      const contextError = context.error;\n      if (contextError) {\n        logger.logError(\n          contextError,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n      const state: Readonly<{\n        wasConnectionCloseCalled: boolean;\n        numSenders: number;\n        numReceivers: number;\n      }> = {\n        wasConnectionCloseCalled: connectionContext.wasConnectionCloseCalled,\n        numSenders: Object.keys(connectionContext.senders).length,\n        numReceivers:\n          Object.keys(connectionContext.messageReceivers).length +\n          Object.keys(connectionContext.messageSessions).length,\n      };\n\n      // Clear internal map maintained by rhea to avoid reconnecting of old links once the\n      // connection is back up.\n      connectionContext.connection.removeAllSessions();\n\n      // Close the cbs session to ensure all the event handlers are released.\n      await connectionContext.cbsSession.close();\n\n      // Close the management sessions to ensure all the event handlers are released.\n      for (const entityPath of Object.keys(connectionContext.managementClients)) {\n        await connectionContext.managementClients[entityPath].close();\n      }\n\n      if (state.wasConnectionCloseCalled) {\n        // Do Nothing\n      } else {\n        // Calling onDetached on sender\n        if (state.numSenders) {\n          // We don't do recovery for the sender:\n          //   Because we don't want to keep the sender active all the time\n          //   and the \"next\" send call would bear the burden of creating the link.\n          // Call onDetached() on sender so that it can gracefully shutdown\n          //   by cleaning up the timers and closing the links.\n          // We don't call onDetached for sender after `refreshConnection()`\n          //   because any new send calls that potentially initialize links would also get affected if called later.\n          logger.verbose(\n            `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${state.numSenders} ` +\n              `senders. We should not reconnect.`,\n          );\n          const detachCalls: Promise<void>[] = [];\n          for (const senderName of Object.keys(connectionContext.senders)) {\n            const sender = connectionContext.senders[senderName];\n            if (sender) {\n              logger.verbose(\n                \"[%s] calling detached on sender '%s'.\",\n                connectionContext.connection.id,\n                sender.name,\n              );\n              detachCalls.push(\n                sender.onDetached().catch((err) => {\n                  logger.logError(\n                    err,\n                    \"[%s] An error occurred while calling onDetached() the sender '%s'\",\n                    connectionContext.connection.id,\n                    sender.name,\n                  );\n                }),\n              );\n            }\n          }\n          await Promise.all(detachCalls);\n        }\n\n        // Calling onDetached on batching receivers for the same reasons as sender\n        const numBatchingReceivers = getNumberOfReceivers(connectionContext, \"batching\");\n        if (numBatchingReceivers) {\n          logger.verbose(\n            `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numBatchingReceivers} ` +\n              `batching receivers. We should not reconnect.`,\n          );\n\n          // Call onDetached() on receivers so that batching receivers it can gracefully close any ongoing batch operation\n          await callOnDetachedOnReceivers(\n            connectionContext,\n            connectionError || contextError,\n            \"batching\",\n          );\n        }\n\n        // Calling onDetached on session receivers\n        const numSessionReceivers = getNumberOfReceivers(connectionContext, \"session\");\n        if (numSessionReceivers) {\n          logger.verbose(\n            `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numSessionReceivers} ` +\n              `session receivers. We should close them.`,\n          );\n\n          await callOnDetachedOnSessionReceivers(\n            connectionContext,\n            connectionError || contextError,\n          );\n        }\n      }\n      await refreshConnection();\n      waitForConnectionRefreshResolve();\n      waitForConnectionRefreshPromise = undefined;\n      // The connection should always be brought back up if the sdk did not call connection.close()\n      // and there was at least one receiver link on the connection before it went down.\n      logger.verbose(\"[%s] state: %O\", connectionContext.connectionId, state);\n\n      // Calling onDetached on streaming receivers\n      const numStreamingReceivers = getNumberOfReceivers(connectionContext, \"streaming\");\n      if (!state.wasConnectionCloseCalled && numStreamingReceivers) {\n        logger.verbose(\n          `[${connectionContext.connection.id}] connection.close() was not called from the sdk and there were ${numStreamingReceivers} ` +\n            `streaming receivers. We should reconnect.`,\n        );\n\n        // Calling `onDetached()` on streaming receivers after the refreshConnection() since `onDetached()` would\n        // recover the streaming receivers and that would only be possible after the connection is refreshed.\n        //\n        // This is different from the batching receiver since `onDetached()` for the batching receiver would\n        // return the outstanding messages and close the receive link.\n        await callOnDetachedOnReceivers(\n          connectionContext,\n          connectionError || contextError,\n          \"streaming\",\n        );\n      }\n    };\n\n    const protocolError: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        logger.logError(\n          context.connection.error,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n      if (context.error) {\n        logger.logError(\n          context.error,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n    };\n\n    const error: OnAmqpEvent = async (context: EventContext) => {\n      if (context.connection && context.connection.error) {\n        logger.logError(\n          context.connection.error,\n          \"[%s] Error (context.connection.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n      if (context.error) {\n        logger.logError(\n          context.error,\n          \"[%s] Error (context.error) occurred on the amqp connection\",\n          connectionContext.connection.id,\n        );\n      }\n    };\n\n    async function refreshConnection(): Promise<void> {\n      const originalConnectionId = connectionContext.connectionId;\n      try {\n        await cleanConnectionContext();\n      } catch (err: any) {\n        logger.logError(\n          err,\n          `[${connectionContext.connectionId}] There was an error closing the connection before reconnecting`,\n        );\n      }\n      // Create a new connection, id, locks, and cbs client.\n      connectionContext.refreshConnection();\n      addConnectionListeners(connectionContext.connection);\n      logger.verbose(\n        `The connection \"${originalConnectionId}\" has been updated to \"${connectionContext.connectionId}\".`,\n      );\n    }\n\n    function addConnectionListeners(connection: Connection): void {\n      // Add listeners on the connection object.\n      connection.on(ConnectionEvents.connectionOpen, onConnectionOpen);\n      connection.on(ConnectionEvents.disconnected, disconnected);\n      connection.on(ConnectionEvents.protocolError, protocolError);\n      connection.on(ConnectionEvents.error, error);\n    }\n\n    async function cleanConnectionContext(): Promise<void> {\n      // Remove listeners from the connection object.\n      connectionContext.connection.removeListener(\n        ConnectionEvents.connectionOpen,\n        onConnectionOpen,\n      );\n      connectionContext.connection.removeListener(ConnectionEvents.disconnected, disconnected);\n      connectionContext.connection.removeListener(ConnectionEvents.protocolError, protocolError);\n      connectionContext.connection.removeListener(ConnectionEvents.error, error);\n      // Close the connection\n      await connectionContext.connection.close();\n    }\n\n    addConnectionListeners(connectionContext.connection);\n\n    logger.verbose(\"[%s] Created connection context successfully.\", connectionContext.connectionId);\n\n    return connectionContext;\n  }\n\n  /**\n   * Closes the AMQP connection created by this ServiceBusClient along with AMQP links for\n   * sender/receivers created by the queue/topic/subscription clients created by this\n   * ServiceBusClient.\n   * Once closed,\n   * - the clients created by this ServiceBusClient cannot be used to send/receive messages anymore.\n   * - this ServiceBusClient cannot be used to create any new queues/topics/subscriptions clients.\n   */\n  export async function close(context: ConnectionContext): Promise<void> {\n    const logPrefix = `[${context.connectionId}]`;\n\n    try {\n      logger.verbose(`${logPrefix} Permanently closing the amqp connection on the client.`);\n\n      const senderNames = Object.keys(context.senders);\n      const messageReceiverNames = Object.keys(context.messageReceivers);\n      const messageSessionNames = Object.keys(context.messageSessions);\n      const managementClientsEntityPaths = Object.keys(context.managementClients);\n      logger.verbose(\n        `${logPrefix} Permanently closing all the senders(${senderNames.length}), MessageReceivers(${messageReceiverNames.length}), MessageSessions(${messageSessionNames.length}), and ManagementClients(${managementClientsEntityPaths.length}).`,\n      );\n      await Promise.all([\n        ...senderNames.map((n) => context.senders[n].close()),\n        ...messageReceiverNames.map((n) => context.messageReceivers[n].close()),\n        ...messageSessionNames.map((n) => context.messageSessions[n].close()),\n        ...managementClientsEntityPaths.map((p) => context.managementClients[p].close()),\n      ]);\n\n      logger.verbose(`${logPrefix} Permanently closing cbsSession`);\n      await context.cbsSession.close();\n\n      logger.verbose(`${logPrefix} Permanently closing internal connection`);\n      await context.connection.close();\n      context.wasConnectionCloseCalled = true;\n      logger.verbose(`[${logPrefix} Permanently closed the amqp connection on the client.`);\n    } catch (err: any) {\n      const errObj = err instanceof Error ? err : new Error(JSON.stringify(err));\n      logger.logError(err, `${logPrefix} An error occurred while closing the connection`);\n      throw errObj;\n    }\n  }\n}\n"]}