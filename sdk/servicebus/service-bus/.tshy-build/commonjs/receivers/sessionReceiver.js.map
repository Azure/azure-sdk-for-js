{"version":3,"file":"sessionReceiver.js","sourceRoot":"","sources":["../../../src/receivers/sessionReceiver.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAgBlC,iDAS2B;AAE3B,2DAQ6B;AAE7B,+CAAoG;AAIpG,gDAAkG;AAGlG,kGAAwF;AACxF,0DAA0D;AAC1D,sCAAqD;AACrD,8DAAiE;AAkEjE;;GAEG;AACH,MAAa,6BAA6B;IASxC,IAAY,SAAS;QACnB,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,YAAY,YAAY,IAAI,CAAC,UAAU,GAAG,CAAC;IACtE,CAAC;IAED;;;;OAIG;IACH,YACU,eAA+B,EAC/B,QAA2B,EAC5B,UAAkB,EAClB,WAA4C,EAC3C,sBAA+B,EAC/B,mBAA4B,EAC5B,gBAA8B,EAAE;QANhC,oBAAe,GAAf,eAAe,CAAgB;QAC/B,aAAQ,GAAR,QAAQ,CAAmB;QAC5B,eAAU,GAAV,UAAU,CAAQ;QAClB,gBAAW,GAAX,WAAW,CAAiC;QAC3C,2BAAsB,GAAtB,sBAAsB,CAAS;QAC/B,wBAAmB,GAAnB,mBAAmB,CAAS;QAC5B,kBAAa,GAAb,aAAa,CAAmB;QArB1C;;WAEG;QACK,cAAS,GAAY,KAAK,CAAC;QAoBjC,IAAA,wCAA4B,EAAC,QAAQ,CAAC,CAAC;QACvC,IAAI,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC;QAC3C,IAAI,CAAC,UAAU,GAAG,eAAe,CAAC,UAAU,CAAC;IAC/C,CAAC;IAEO,kCAAkC;QACxC,IAAA,wCAA4B,EAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC5C,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;gBACnB,MAAM,YAAY,GAAG,IAAA,qCAAyB,EAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBAChF,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;gBACtC,uBAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,SAAS,iBAAiB,CAAC,CAAC;gBAC3D,MAAM,KAAK,CAAC;YACd,CAAC;YACD,MAAM,SAAS,GAAc;gBAC3B,SAAS,EAAE,oCAAwB,CAAC,oBAAoB;gBACxD,WAAW,EAAE,uDAAuD,IAAI,CAAC,SAAS,EAAE;aACrF,CAAC;YACF,MAAM,IAAA,6CAAwB,EAAC,SAAS,CAAC,CAAC;QAC5C,CAAC;IACH,CAAC;IAEO,wBAAwB;QAC9B,IAAI,IAAI,CAAC,oBAAoB,EAAE,EAAE,CAAC;YAChC,MAAM,YAAY,GAAG,IAAA,uCAA2B,EAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;YAClF,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,YAAY,CAAC,CAAC;YACtC,uBAAM,CAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,SAAS,wBAAwB,CAAC,CAAC;YAClE,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;IAED,IAAW,QAAQ;QACjB,OAAO,CACL,IAAI,CAAC,SAAS;YACd,CAAC,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC;YACzD,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,EAAE,CAC/B,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,IAAW,qBAAqB;QAC9B,OAAO,IAAI,CAAC,eAAe,CAAC,qBAAqB,CAAC;IACpD,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,KAAK,CAAC,gBAAgB,CAAC,OAA8B;QACnD,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAE1C,OAAO,0BAAa,CAAC,QAAQ,CAC3B,4CAA4C,EAC5C,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,EACb,CAAC,cAAc,EAAE,EAAE;YACjB,MAAM,gCAAgC,GAAG,KAAK,IAAmB,EAAE;gBACjE,IAAI,CAAC,eAAgB,CAAC,qBAAqB,GAAG,MAAM,IAAI,CAAC,QAAQ;qBAC9D,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,gBAAgB,CAAC,IAAI,CAAC,SAAS,kCAC3B,cAAc,KACjB,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,kBAAkB,EAC/B,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;gBACL,OAAO,IAAI,CAAC,eAAgB,CAAC,qBAAsB,CAAC;YACtD,CAAC,CAAC;YACF,MAAM,MAAM,GAAsB;gBAChC,SAAS,EAAE,gCAAgC;gBAC3C,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAE,8BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAO,IAAA,iBAAK,EAAO,MAAM,CAAC,CAAC;QAC7B,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,eAAe,CAAC,KAAc,EAAE,UAAgC,EAAE;QACtE,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAE1C,OAAO,0BAAa,CAAC,QAAQ,CAC3B,2CAA2C,EAC3C,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,EACb,CAAC,cAAc,EAAE,EAAE;YACjB,MAAM,+BAA+B,GAAG,KAAK,IAAmB,EAAE;gBAChE,MAAM,IAAI,CAAC,QAAQ;qBAChB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,eAAe,CAAC,IAAI,CAAC,SAAU,EAAE,KAAK,kCAClC,cAAc,KACjB,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,UAAU,EACvB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;gBACL,OAAO;YACT,CAAC,CAAC;YACF,MAAM,MAAM,GAAsB;gBAChC,SAAS,EAAE,+BAA+B;gBAC1C,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAE,8BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAO,IAAA,iBAAK,EAAO,MAAM,CAAC,CAAC;QAC7B,CAAC,CACF,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,eAAe,CAAC,UAAgC,EAAE;QACtD,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAE1C,OAAO,0BAAa,CAAC,QAAQ,CAC3B,2CAA2C,EAC3C,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,EACb,CAAC,cAAc,EAAE,EAAE;YACjB,MAAM,+BAA+B,GAAG,KAAK,IAAkB,EAAE;gBAC/D,OAAO,IAAI,CAAC,QAAQ;qBACjB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,eAAe,CAAC,IAAI,CAAC,SAAS,kCAC1B,cAAc,KACjB,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,UAAU,EACvB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;YACP,CAAC,CAAC;YACF,MAAM,MAAM,GAAqB;gBAC/B,SAAS,EAAE,+BAA+B;gBAC1C,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;gBACxC,aAAa,EAAE,8BAAkB,CAAC,UAAU;gBAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;gBAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;aAClC,CAAC;YACF,OAAO,IAAA,iBAAK,EAAM,MAAM,CAAC,CAAC;QAC5B,CAAC,CACF,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,YAAY,CAChB,eAAuB,EACvB,UAA+B,EAAE;;QAEjC,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAE1C,MAAM,wBAAwB,mCACzB,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,cAAc,EAC3B,WAAW,EAAE,MAAA,IAAI,CAAC,aAAa,0CAAE,WAAW,EAC5C,qBAAqB,EAAE,IAAI,CAAC,sBAAsB,EAClD,kBAAkB,EAAE,IAAI,CAAC,mBAAmB,GAC7C,CAAC;QACF,qFAAqF;QACrF,MAAM,EAAE,kBAAkB,EAAE,eAAe,EAAE,GAAG,OAE/C,CAAC;QACF,MAAM,oBAAoB,GAAG,KAAK,IAA0C,EAAE;YAC5E,IAAI,kBAAkB,KAAK,SAAS,EAAE,CAAC;gBACrC,OAAO,IAAI,CAAC,QAAQ;qBACjB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,oBAAoB,CACnB,kBAAkB,EAClB,eAAe,EACf,IAAI,CAAC,SAAS,EACd,eAAe,EACf,wBAAwB,CACzB,CAAC;YACN,CAAC;iBAAM,CAAC;gBACN,OAAO,IAAI,CAAC,QAAQ;qBACjB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;qBACpC,qBAAqB,CACpB,IAAI,CAAC,SAAS,EACd,eAAe,EACf,eAAe,EACf,wBAAwB,CACzB,CAAC;YACN,CAAC;QACH,CAAC,CAAC;QAEF,MAAM,MAAM,GAA6C;YACvD,SAAS,EAAE,oBAAoB;YAC/B,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;YACxC,aAAa,EAAE,8BAAkB,CAAC,UAAU;YAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;YAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;SAClC,CAAC;QACF,OAAO,IAAA,iBAAK,EAA8B,MAAM,CAAC,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,uBAAuB,CAC3B,eAA8B,EAC9B,UAAgC,EAAE;QAElC,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAA,4CAAgC,EAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;QACF,IAAA,4CAAgC,EAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;QAEF,MAAM,uBAAuB,GAAG,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC;YAC5D,CAAC,CAAC,eAAe;YACjB,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC;QACtB,MAAM,uCAAuC,GAAG,KAAK,IAEnD,EAAE;YACF,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,QAAQ;iBACzC,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;iBACpC,uBAAuB,CAAC,uBAAuB,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,SAAS,kCAC7E,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,yBAAyB,EACtC,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,EAC3C,qBAAqB,EAAE,IAAI,CAAC,sBAAsB,EAClD,kBAAkB,EAAE,IAAI,CAAC,mBAAmB,IAC5C,CAAC;YACL,OAAO,gBAAgB,CAAC;QAC1B,CAAC,CAAC;QACF,MAAM,MAAM,GAA6C;YACvD,SAAS,EAAE,uCAAuC;YAClD,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;YACxC,aAAa,EAAE,8BAAkB,CAAC,UAAU;YAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;YAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;SAClC,CAAC;QACF,OAAO,IAAA,iBAAK,EAA8B,MAAM,CAAC,CAAC;IACpD,CAAC;IAED,KAAK,CAAC,cAAc,CAAC,OAA8B;QACjD,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAE1C,MAAM,8BAA8B,GAAG,GAAoB,EAAE;YAC3D,OAAO,IAAI,CAAC,QAAQ;iBACjB,mBAAmB,CAAC,IAAI,CAAC,UAAU,CAAC;iBACpC,cAAc,CAAC,OAAO,CAAC,eAAe,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB,EAAE,IAAI,CAAC,SAAS,kCAC9E,OAAO,KACV,kBAAkB,EAAE,IAAI,CAAC,eAAe,CAAC,IAAI,EAC7C,WAAW,EAAE,gBAAgB,EAC7B,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,WAAW,IAC3C,CAAC;QACP,CAAC,CAAC;QACF,MAAM,MAAM,GAAwB;YAClC,SAAS,EAAE,8BAA8B;YACzC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;YACxC,aAAa,EAAE,8BAAkB,CAAC,UAAU;YAC5C,YAAY,EAAE,IAAI,CAAC,aAAa;YAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;SAClC,CAAC;QACF,OAAO,IAAA,iBAAK,EAAS,MAAM,CAAC,CAAC;IAC/B,CAAC;IAED,KAAK,CAAC,aAAa,CAAC,OAA8B;QAChD,IAAI,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC;YAC3C,eAAe,EAAE,mCAAqB;YACtC,iBAAiB,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB;SAC9C,CAAC,CAAC;QACH,IAAI,YAAY,KAAK,mCAAqB,EAAE,CAAC;YAC3C,IAAI,UAAU,GAAG,mCAAqB,CAAC;YACvC,OAAO,UAAU,KAAK,mCAAqB,EAAE,CAAC;gBAC5C,UAAU,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC;oBACrC,eAAe,EAAE,mCAAqB;oBACtC,iBAAiB,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,iBAAiB;iBAC9C,CAAC,CAAC;gBACH,YAAY,IAAI,UAAU,CAAC;YAC7B,CAAC;QACH,CAAC;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAED,KAAK,CAAC,eAAe,CACnB,eAAuB,EACvB,OAAgC;QAEhC,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,IAAA,4CAAgC,EAC9B,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,CAChB,CAAC;QACF,IAAA,iDAAqC,EACnC,IAAI,CAAC,QAAQ,CAAC,YAAY,EAC1B,iBAAiB,EACjB,eAAe,EACf,QAAQ,CACT,CAAC;QAEF,IAAI,KAAK,CAAC,eAAe,CAAC,IAAI,eAAe,GAAG,CAAC,EAAE,CAAC;YAClD,MAAM,IAAI,SAAS,CAAC,uCAA2B,CAAC,CAAC;QACnD,CAAC;QAED,MAAM,4BAA4B,GAAG,KAAK,IAA0C,EAAE;;YACpF,MAAM,gBAAgB,GAAG,MAAM,IAAI,CAAC,eAAgB,CAAC,eAAe,CAClE,eAAe,EACf,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,eAAe,mCAAI,qBAAS,CAAC,2BAA2B,EACjE,0DAA4C,EAC5C,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,CACd,CAAC;YAEF,OAAO,gBAAgB,CAAC;QAC1B,CAAC,CAAC;QACF,MAAM,MAAM,GAA6C;YACvD,SAAS,EAAE,4BAA4B;YACvC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY;YACxC,aAAa,EAAE,8BAAkB,CAAC,cAAc;YAChD,YAAY,EAAE,IAAI,CAAC,aAAa;YAChC,WAAW,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW;SAClC,CAAC;QACF,OAAO,IAAA,iBAAK,EAA8B,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;YAC9D,MAAM,IAAA,6CAAwB,EAAC,GAAG,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,SAAS,CACP,QAAyB,EACzB,OAA0B;QAI1B,yCAAyC;QACzC,IAAA,8CAA0B,EAAC,QAAQ,CAAC,CAAC;QAErC,OAAO,GAAG,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,CAAC;QAExB,MAAM,YAAY,GAAG,IAAA,2CAAuB,EAAC,QAAQ,CAAC,CAAC;QAEvD,IAAI,CAAC,uBAAuB,CAC1B,KAAK,EAAE,OAA8B,EAAE,EAAE;YACvC,OAAO,0BAAa,CAAC,QAAQ,CAC3B,yBAAyB,EACzB,OAAO,aAAP,OAAO,cAAP,OAAO,GAAI,EAAE,EACb,GAAG,EAAE,CAAC,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,EACtC,IAAA,wDAAuB,EAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,SAAS,CAAC,CACxE,CAAC;QACJ,CAAC,EACD,YAAY,EACZ,OAAO,CACR,CAAC;QAEF,OAAO;YACL,KAAK,EAAE,KAAK,IAAmB,EAAE;;gBAC/B,OAAO,MAAA,IAAI,CAAC,eAAe,0CAAE,cAAc,CAAC,OAAO,EAAE,CAAC;YACxD,CAAC;SACF,CAAC;IACJ,CAAC;IAED;;;;;;;;;;;;;;;;;;;;OAoBG;IACK,uBAAuB,CAC7B,SAAoB,EACpB,OAAgB,EAChB,OAAyB;QAEzB,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAI,CAAC,wBAAwB,EAAE,CAAC;QAChC,MAAM,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC;QAC1C,IAAA,4CAAgC,EAAC,MAAM,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;QACjE,IAAA,4CAAgC,EAAC,MAAM,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;QAC7D,IAAI,OAAO,SAAS,KAAK,UAAU,EAAE,CAAC;YACpC,MAAM,IAAI,SAAS,CAAC,uDAAuD,CAAC,CAAC;QAC/E,CAAC;QACD,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE,CAAC;YAClC,MAAM,IAAI,SAAS,CAAC,qDAAqD,CAAC,CAAC;QAC7E,CAAC;QAED,IAAI,CAAC;YACH,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,SAAS,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;QAC9D,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,OAAO,CAAC;gBACN,KAAK,EAAE,GAAG;gBACV,WAAW,EAAE,SAAS;gBACtB,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,uBAAuB,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI;gBAClD,UAAU,EAAE,IAAI,CAAC,UAAU;aAC5B,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAED,kBAAkB,CAChB,OAAmC;QAEnC,OAAO,IAAA,sCAAkB,EAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAC3C,CAAC;IAED,KAAK,CAAC,eAAe,CAAC,OAAkC;QACtD,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAA,iDAAqC,EAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;QACjD,OAAO,IAAA,mCAAe,EAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;IACtF,CAAC;IAED,KAAK,CAAC,cAAc,CAClB,OAAkC,EAClC,kBAA+E;QAE/E,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAA,iDAAqC,EAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;QACjD,OAAO,IAAA,kCAAc,EACnB,OAAO,EACP,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,UAAU,EACf,kBAAkB,EAClB,IAAI,CAAC,aAAa,CACnB,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,YAAY,CAChB,OAAkC,EAClC,kBAA+E;QAE/E,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAA,iDAAqC,EAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;QACjD,OAAO,IAAA,gCAAY,EACjB,OAAO,EACP,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,UAAU,EACf,kBAAkB,EAClB,IAAI,CAAC,aAAa,CACnB,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,iBAAiB,CACrB,OAAkC,EAClC,OAAwF;QAExF,IAAI,CAAC,kCAAkC,EAAE,CAAC;QAC1C,IAAA,iDAAqC,EAAC,OAAO,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;QAC7F,MAAM,OAAO,GAAG,OAAgC,CAAC;QACjD,OAAO,IAAA,qCAAiB,EAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,OAAO,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;IACjG,CAAC;IAED,KAAK,CAAC,gBAAgB;QACpB,MAAM,IAAI,KAAK,CAAC,2EAA2E,CAAC,CAAC;IAC/F,CAAC;IAED,KAAK,CAAC,KAAK;QACT,IAAI,CAAC;YACH,MAAM,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,CAAC;QACrC,CAAC;QAAC,OAAO,GAAQ,EAAE,CAAC;YAClB,uBAAM,CAAC,QAAQ,CACb,GAAG,EACH,uEAAuE,EACvE,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CACf,CAAC;YACF,MAAM,GAAG,CAAC;QACZ,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;QACxB,CAAC;IACH,CAAC;IAED;;;OAGG;IACK,oBAAoB;QAC1B,OAAO,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC,CAAC,CAAC,KAAK,CAAC;IACjF,CAAC;CACF;AAriBD,sEAqiBC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { ConnectionContext } from \"../connectionContext.js\";\nimport type {\n  MessageHandlers,\n  ReceiveMessagesOptions,\n  ServiceBusReceivedMessage,\n} from \"../index.js\";\nimport type {\n  PeekMessagesOptions,\n  GetMessageIteratorOptions,\n  SubscribeOptions,\n  DeleteMessagesOptions,\n  PurgeMessagesOptions,\n} from \"../models.js\";\nimport type { MessageSession } from \"../session/messageSession.js\";\nimport {\n  getAlreadyReceivingErrorMsg,\n  getReceiverClosedErrorMsg,\n  InvalidMaxMessageCountError,\n  throwErrorIfConnectionClosed,\n  throwTypeErrorIfParameterMissing,\n  throwTypeErrorIfParameterNotLong,\n  throwErrorIfInvalidOperationOnMessage,\n  throwTypeErrorIfParameterTypeMismatch,\n} from \"../util/errors.js\";\nimport type { OnError, OnMessage } from \"../core/messageReceiver.js\";\nimport {\n  abandonMessage,\n  assertValidMessageHandlers,\n  completeMessage,\n  deadLetterMessage,\n  deferMessage,\n  getMessageIterator,\n  wrapProcessErrorHandler,\n} from \"./receiverCommon.js\";\nimport type { ServiceBusReceiver } from \"./receiver.js\";\nimport { defaultMaxTimeAfterFirstMessageForBatchingMs, MaxDeleteMessageCount } from \"./receiver.js\";\nimport type Long from \"long\";\nimport type { ServiceBusMessageImpl, DeadLetterOptions } from \"../serviceBusMessage.js\";\nimport type { RetryConfig, RetryOptions } from \"@azure/core-amqp\";\nimport { Constants, RetryOperationType, retry, ErrorNameConditionMapper } from \"@azure/core-amqp\";\nimport type { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs.js\";\nimport type { AmqpError } from \"rhea-promise\";\nimport { toProcessingSpanOptions } from \"../diagnostics/instrumentServiceBusMessage.js\";\nimport { tracingClient } from \"../diagnostics/tracing.js\";\nimport { receiverLogger as logger } from \"../log.js\";\nimport { translateServiceBusError } from \"../serviceBusError.js\";\n\n/**\n *A receiver that handles sessions, including renewing the session lock.\n */\nexport interface ServiceBusSessionReceiver extends ServiceBusReceiver {\n  /**\n   * The session ID.\n   */\n  readonly sessionId: string;\n\n  /**\n   * The time in UTC until which the session is locked.\n   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * Will return undefined until a AMQP receiver link has been successfully set up for the session.\n   *\n   * @readonly\n   */\n  readonly sessionLockedUntilUtc: Date;\n\n  /**\n   * Streams messages to message handlers.\n   * @param handlers - A handler that gets called for messages and errors.\n   * @param options - Options for subscribe.\n   * @returns An object that can be closed, sending any remaining messages to `handlers` and\n   * stopping new messages from arriving.\n   */\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions,\n  ): {\n    /**\n     * Causes the subscriber to stop receiving new messages.\n     */\n    close(): Promise<void>;\n  };\n\n  /**\n   * Renews the lock on the session.\n   */\n  renewSessionLock(options?: OperationOptionsBase): Promise<Date>;\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while retrieving session state.\n   */\n  getSessionState(options?: OperationOptionsBase): Promise<any>;\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param state - The state that needs to be set.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while setting the session state.\n   *\n   */\n  setSessionState(state: any, options?: OperationOptionsBase): Promise<void>;\n}\n\n/**\n * @internal\n */\nexport class ServiceBusSessionReceiverImpl implements ServiceBusSessionReceiver {\n  public sessionId: string;\n  public identifier: string;\n\n  /**\n   * Denotes if close() was called on this receiver\n   */\n  private _isClosed: boolean = false;\n\n  private get logPrefix(): string {\n    return `[${this._context.connectionId}|session:${this.entityPath}]`;\n  }\n\n  /**\n   * @internal\n   * @throws Error if the underlying connection is closed.\n   * @throws Error if an open receiver is already existing for given sessionId.\n   */\n  constructor(\n    private _messageSession: MessageSession,\n    private _context: ConnectionContext,\n    public entityPath: string,\n    public receiveMode: \"peekLock\" | \"receiveAndDelete\",\n    private _skipParsingBodyAsJson: boolean,\n    private _skipConvertingDate: boolean,\n    private _retryOptions: RetryOptions = {},\n  ) {\n    throwErrorIfConnectionClosed(_context);\n    this.sessionId = _messageSession.sessionId;\n    this.identifier = _messageSession.identifier;\n  }\n\n  private _throwIfReceiverOrConnectionClosed(): void {\n    throwErrorIfConnectionClosed(this._context);\n    if (this.isClosed) {\n      if (this._isClosed) {\n        const errorMessage = getReceiverClosedErrorMsg(this.entityPath, this.sessionId);\n        const error = new Error(errorMessage);\n        logger.logError(error, `${this.logPrefix} already closed`);\n        throw error;\n      }\n      const amqpError: AmqpError = {\n        condition: ErrorNameConditionMapper.SessionLockLostError,\n        description: `The session lock has expired on the session with id ${this.sessionId}`,\n      };\n      throw translateServiceBusError(amqpError);\n    }\n  }\n\n  private _throwIfAlreadyReceiving(): void {\n    if (this._isReceivingMessages()) {\n      const errorMessage = getAlreadyReceivingErrorMsg(this.entityPath, this.sessionId);\n      const error = new Error(errorMessage);\n      logger.logError(error, `${this.logPrefix} is already receiving.`);\n      throw error;\n    }\n  }\n\n  public get isClosed(): boolean {\n    return (\n      this._isClosed ||\n      !this._context.messageSessions[this._messageSession.name] ||\n      !this._messageSession.isOpen()\n    );\n  }\n\n  /**\n   * The time in UTC until which the session is locked.\n   * Every time `renewSessionLock()` is called, this time gets updated to current time plus the lock\n   * duration as specified during the Queue/Subscription creation.\n   *\n   * When the lock on the session expires\n   * - The current receiver can no longer be used to receive more messages.\n   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.\n   * - Messages that were received in `peekLock` mode with this receiver but not yet settled\n   * will land back in the Queue/Subscription with their delivery count incremented.\n   *\n   * @readonly\n   */\n  public get sessionLockedUntilUtc(): Date {\n    return this._messageSession.sessionLockedUntilUtc;\n  }\n\n  /**\n   * Renews the lock on the session for the duration as specified during the Queue/Subscription\n   * creation. You can check the `sessionLockedUntilUtc` property for the time when the lock expires.\n   *\n   * When the lock on the session expires\n   * - The current receiver can no longer be used to receive mode messages.\n   * Create a new receiver using `ServiceBusClient.acceptSession()` or `ServiceBusClient.acceptNextSession()`.\n   * - Messages that were received in `peekLock` mode with this receiver but not yet settled\n   * will land back in the Queue/Subscription with their delivery count incremented.\n   *\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns New lock token expiry date and time in UTC format.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while renewing session lock.\n   */\n  async renewSessionLock(options?: OperationOptionsBase): Promise<Date> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.renewSessionLock\",\n      options ?? {},\n      (updatedOptions) => {\n        const renewSessionLockOperationPromise = async (): Promise<Date> => {\n          this._messageSession!.sessionLockedUntilUtc = await this._context\n            .getManagementClient(this.entityPath)\n            .renewSessionLock(this.sessionId, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"renewSessionLock\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n          return this._messageSession!.sessionLockedUntilUtc!;\n        };\n        const config: RetryConfig<Date> = {\n          operation: renewSessionLockOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<Date>(config);\n      },\n    );\n  }\n\n  /**\n   * Sets the state on the Session. For more on session states, see\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param state - The state that needs to be set.\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while setting the session state.\n   */\n  async setSessionState(state: unknown, options: OperationOptionsBase = {}): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.setSessionState\",\n      options ?? {},\n      (updatedOptions) => {\n        const setSessionStateOperationPromise = async (): Promise<void> => {\n          await this._context\n            .getManagementClient(this.entityPath)\n            .setSessionState(this.sessionId!, state, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"setState\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n          return;\n        };\n        const config: RetryConfig<void> = {\n          operation: setSessionStateOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<void>(config);\n      },\n    );\n  }\n\n  /**\n   * Gets the state of the Session. For more on session states, see\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-sessions#message-session-state | Session State}\n   * @param options - Options bag to pass an abort signal or tracing options.\n   * @returns The state of that session\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws `ServiceBusError` if the service returns an error while retrieving session state.\n   */\n  async getSessionState(options: OperationOptionsBase = {}): Promise<any> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    return tracingClient.withSpan(\n      \"ServiceBusSessionReceiver.getSessionState\",\n      options ?? {},\n      (updatedOptions) => {\n        const getSessionStateOperationPromise = async (): Promise<any> => {\n          return this._context\n            .getManagementClient(this.entityPath)\n            .getSessionState(this.sessionId, {\n              ...updatedOptions,\n              associatedLinkName: this._messageSession.name,\n              requestName: \"getState\",\n              timeoutInMs: this._retryOptions.timeoutInMs,\n            });\n        };\n        const config: RetryConfig<any> = {\n          operation: getSessionStateOperationPromise,\n          connectionId: this._context.connectionId,\n          operationType: RetryOperationType.management,\n          retryOptions: this._retryOptions,\n          abortSignal: options?.abortSignal,\n        };\n        return retry<any>(config);\n      },\n    );\n  }\n\n  async peekMessages(\n    maxMessageCount: number,\n    options: PeekMessagesOptions = {},\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const managementRequestOptions = {\n      ...options,\n      associatedLinkName: this._messageSession.name,\n      requestName: \"peekMessages\",\n      timeoutInMs: this._retryOptions?.timeoutInMs,\n      skipParsingBodyAsJson: this._skipParsingBodyAsJson,\n      skipConvertingDate: this._skipConvertingDate,\n    };\n    // omitMessageBody is available at runtime, but only exported in experimental subpath\n    const { fromSequenceNumber, omitMessageBody } = options as PeekMessagesOptions & {\n      omitMessageBody: boolean;\n    };\n    const peekOperationPromise = async (): Promise<ServiceBusReceivedMessage[]> => {\n      if (fromSequenceNumber !== undefined) {\n        return this._context\n          .getManagementClient(this.entityPath)\n          .peekBySequenceNumber(\n            fromSequenceNumber,\n            maxMessageCount,\n            this.sessionId,\n            omitMessageBody,\n            managementRequestOptions,\n          );\n      } else {\n        return this._context\n          .getManagementClient(this.entityPath)\n          .peekMessagesBySession(\n            this.sessionId,\n            maxMessageCount,\n            omitMessageBody,\n            managementRequestOptions,\n          );\n      }\n    };\n\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: peekOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  async receiveDeferredMessages(\n    sequenceNumbers: Long | Long[],\n    options: OperationOptionsBase = {},\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n    throwTypeErrorIfParameterNotLong(\n      this._context.connectionId,\n      \"sequenceNumbers\",\n      sequenceNumbers,\n    );\n\n    const deferredSequenceNumbers = Array.isArray(sequenceNumbers)\n      ? sequenceNumbers\n      : [sequenceNumbers];\n    const receiveDeferredMessagesOperationPromise = async (): Promise<\n      ServiceBusReceivedMessage[]\n    > => {\n      const deferredMessages = await this._context\n        .getManagementClient(this.entityPath)\n        .receiveDeferredMessages(deferredSequenceNumbers, this.receiveMode, this.sessionId, {\n          ...options,\n          associatedLinkName: this._messageSession.name,\n          requestName: \"receiveDeferredMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs,\n          skipParsingBodyAsJson: this._skipParsingBodyAsJson,\n          skipConvertingDate: this._skipConvertingDate,\n        });\n      return deferredMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveDeferredMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config);\n  }\n\n  async deleteMessages(options: DeleteMessagesOptions): Promise<number> {\n    this._throwIfReceiverOrConnectionClosed();\n\n    const deleteMessagesOperationPromise = (): Promise<number> => {\n      return this._context\n        .getManagementClient(this.entityPath)\n        .deleteMessages(options.maxMessageCount, options?.beforeEnqueueTime, this.sessionId, {\n          ...options,\n          associatedLinkName: this._messageSession.name,\n          requestName: \"deleteMessages\",\n          timeoutInMs: this._retryOptions.timeoutInMs,\n        });\n    };\n    const config: RetryConfig<number> = {\n      operation: deleteMessagesOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.management,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<number>(config);\n  }\n\n  async purgeMessages(options?: PurgeMessagesOptions): Promise<number> {\n    let deletedCount = await this.deleteMessages({\n      maxMessageCount: MaxDeleteMessageCount,\n      beforeEnqueueTime: options?.beforeEnqueueTime,\n    });\n    if (deletedCount === MaxDeleteMessageCount) {\n      let batchCount = MaxDeleteMessageCount;\n      while (batchCount === MaxDeleteMessageCount) {\n        batchCount = await this.deleteMessages({\n          maxMessageCount: MaxDeleteMessageCount,\n          beforeEnqueueTime: options?.beforeEnqueueTime,\n        });\n        deletedCount += batchCount;\n      }\n    }\n    return deletedCount;\n  }\n\n  async receiveMessages(\n    maxMessageCount: number,\n    options?: ReceiveMessagesOptions,\n  ): Promise<ServiceBusReceivedMessage[]> {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    throwTypeErrorIfParameterMissing(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n    );\n    throwTypeErrorIfParameterTypeMismatch(\n      this._context.connectionId,\n      \"maxMessageCount\",\n      maxMessageCount,\n      \"number\",\n    );\n\n    if (isNaN(maxMessageCount) || maxMessageCount < 1) {\n      throw new TypeError(InvalidMaxMessageCountError);\n    }\n\n    const receiveBatchOperationPromise = async (): Promise<ServiceBusReceivedMessage[]> => {\n      const receivedMessages = await this._messageSession!.receiveMessages(\n        maxMessageCount,\n        options?.maxWaitTimeInMs ?? Constants.defaultOperationTimeoutInMs,\n        defaultMaxTimeAfterFirstMessageForBatchingMs,\n        options ?? {},\n      );\n\n      return receivedMessages;\n    };\n    const config: RetryConfig<ServiceBusReceivedMessage[]> = {\n      operation: receiveBatchOperationPromise,\n      connectionId: this._context.connectionId,\n      operationType: RetryOperationType.receiveMessage,\n      retryOptions: this._retryOptions,\n      abortSignal: options?.abortSignal,\n    };\n    return retry<ServiceBusReceivedMessage[]>(config).catch((err) => {\n      throw translateServiceBusError(err);\n    });\n  }\n\n  subscribe(\n    handlers: MessageHandlers,\n    options?: SubscribeOptions,\n  ): {\n    close(): Promise<void>;\n  } {\n    // TODO - receiverOptions for subscribe??\n    assertValidMessageHandlers(handlers);\n\n    options = options ?? {};\n\n    const processError = wrapProcessErrorHandler(handlers);\n\n    this._registerMessageHandler(\n      async (message: ServiceBusMessageImpl) => {\n        return tracingClient.withSpan(\n          \"SessionReceiver.process\",\n          options ?? {},\n          () => handlers.processMessage(message),\n          toProcessingSpanOptions(message, this, this._context.config, \"process\"),\n        );\n      },\n      processError,\n      options,\n    );\n\n    return {\n      close: async (): Promise<void> => {\n        return this._messageSession?.receiverHelper.suspend();\n      },\n    };\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver.\n   *\n   * Throws an error if there is another receive operation in progress on the same receiver. If you\n   * are not sure whether there is another receive operation running, check the `isReceivingMessages`\n   * property on the receiver.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed\n   * or if the lock on the session should be automatically renewed. You can control the\n   * maximum number of messages that should be concurrently processed. You can\n   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   *\n   * @throws Error if the underlying connection or receiver is closed.\n   * @throws Error if the receiver is already in state of receiving messages.\n   * @throws `ServiceBusError` if the service returns an error while receiving messages. These are bubbled up to be handled by user provided `onError` handler.\n   */\n  private _registerMessageHandler(\n    onMessage: OnMessage,\n    onError: OnError,\n    options: SubscribeOptions,\n  ): void {\n    this._throwIfReceiverOrConnectionClosed();\n    this._throwIfAlreadyReceiving();\n    const connId = this._context.connectionId;\n    throwTypeErrorIfParameterMissing(connId, \"onMessage\", onMessage);\n    throwTypeErrorIfParameterMissing(connId, \"onError\", onError);\n    if (typeof onMessage !== \"function\") {\n      throw new TypeError(\"The parameter 'onMessage' must be of type 'function'.\");\n    }\n    if (typeof onError !== \"function\") {\n      throw new TypeError(\"The parameter 'onError' must be of type 'function'.\");\n    }\n\n    try {\n      this._messageSession.subscribe(onMessage, onError, options);\n    } catch (err: any) {\n      onError({\n        error: err,\n        errorSource: \"receive\",\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        identifier: this.identifier,\n      });\n    }\n  }\n\n  getMessageIterator(\n    options?: GetMessageIteratorOptions,\n  ): AsyncIterableIterator<ServiceBusReceivedMessage> {\n    return getMessageIterator(this, options);\n  }\n\n  async completeMessage(message: ServiceBusReceivedMessage): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return completeMessage(msgImpl, this._context, this.entityPath, this._retryOptions);\n  }\n\n  async abandonMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return abandonMessage(\n      msgImpl,\n      this._context,\n      this.entityPath,\n      propertiesToModify,\n      this._retryOptions,\n    );\n  }\n\n  async deferMessage(\n    message: ServiceBusReceivedMessage,\n    propertiesToModify?: { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deferMessage(\n      msgImpl,\n      this._context,\n      this.entityPath,\n      propertiesToModify,\n      this._retryOptions,\n    );\n  }\n\n  async deadLetterMessage(\n    message: ServiceBusReceivedMessage,\n    options?: DeadLetterOptions & { [key: string]: number | boolean | string | Date | null },\n  ): Promise<void> {\n    this._throwIfReceiverOrConnectionClosed();\n    throwErrorIfInvalidOperationOnMessage(message, this.receiveMode, this._context.connectionId);\n    const msgImpl = message as ServiceBusMessageImpl;\n    return deadLetterMessage(msgImpl, this._context, this.entityPath, options, this._retryOptions);\n  }\n\n  async renewMessageLock(): Promise<Date> {\n    throw new Error(\"Renewing message lock is an invalid operation when working with sessions.\");\n  }\n\n  async close(): Promise<void> {\n    try {\n      await this._messageSession.close();\n    } catch (err: any) {\n      logger.logError(\n        err,\n        \"%s An error occurred while closing the SessionReceiver for session %s\",\n        this.logPrefix,\n        this.sessionId,\n      );\n      throw err;\n    } finally {\n      this._isClosed = true;\n    }\n  }\n\n  /**\n   * Indicates whether the receiver is currently receiving messages or not.\n   * When this returns true, new `registerMessageHandler()` or `receiveMessages()` calls cannot be made.\n   */\n  private _isReceivingMessages(): boolean {\n    return this._messageSession ? this._messageSession.isReceivingMessages : false;\n  }\n}\n"]}