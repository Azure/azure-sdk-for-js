{"version":3,"file":"serviceBusMessage.js","sourceRoot":"","sources":["../../src/serviceBusMessage.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AmqpAnnotatedMessage, Constants } from \"@azure/core-amqp\";\nimport { Buffer } from \"buffer\";\nimport Long from \"long\";\nimport type {\n  Delivery,\n  DeliveryAnnotations,\n  MessageAnnotations,\n  Message as RheaMessage,\n} from \"rhea-promise\";\nimport { uuid_to_string } from \"rhea-promise\";\nimport { defaultDataTransformer } from \"./dataTransformer.js\";\nimport { messageLogger as logger } from \"./log.js\";\nimport type { ReceiveMode } from \"./models.js\";\nimport { isDefined, isObjectWithProperties } from \"@azure/core-util\";\nimport { reorderLockToken } from \"./util/utils.js\";\n\n/**\n * @internal\n */\nexport enum DispositionType {\n  complete = \"complete\",\n  deadletter = \"deadletter\",\n  abandon = \"abandon\",\n  defer = \"defer\",\n}\n\n/**\n * @internal\n * Describes the delivery annotations for Service Bus.\n */\nexport interface ServiceBusDeliveryAnnotations extends DeliveryAnnotations {\n  /**\n   * The offset of the last event.\n   */\n  last_enqueued_offset?: string;\n  /**\n   * The sequence number of the last event.\n   */\n  last_enqueued_sequence_number?: number;\n  /**\n   * The enqueued time of the last event.\n   */\n  last_enqueued_time_utc?: number;\n  /**\n   * The retrieval time of the last event.\n   */\n  runtime_info_retrieval_time_utc?: number;\n  /**\n   * Any unknown delivery annotations.\n   */\n  [x: string]: any;\n}\n\n/**\n * @internal\n * Describes the message annotations for Service Bus.\n */\nexport interface ServiceBusMessageAnnotations extends MessageAnnotations {\n  /**\n   * Annotation for the partition key set for the event.\n   */\n  \"x-opt-partition-key\"?: string | null;\n  /**\n   * Annontation for the sequence number of the event.\n   */\n  \"x-opt-sequence-number\"?: number;\n  /**\n   * Annotation for the enqueued time of the event.\n   */\n  \"x-opt-enqueued-time\"?: number;\n  /**\n   * Annotation for the offset of the event.\n   */\n  \"x-opt-offset\"?: string;\n  /**\n   * Annotation for the message being locked until.\n   */\n  \"x-opt-locked-until\"?: Date | number;\n  /**\n   * Annotation for the message state.\n   */\n  \"x-opt-message-state\"?: number;\n}\n\n/**\n * Describes the reason and error description for dead lettering a message using the `deadLetter()`\n * method on the message received from Service Bus.\n */\nexport interface DeadLetterOptions {\n  /**\n   * The reason for deadlettering the message.\n   */\n  deadLetterReason: string;\n  /**\n   * The error description for deadlettering the message.\n   */\n  deadLetterErrorDescription: string;\n}\n\n/**\n * Describes the message to be sent to Service Bus.\n */\nexport interface ServiceBusMessage {\n  /**\n   * The message body that needs to be sent or is received.\n   * If the application receiving the message is not using this SDK,\n   * convert your body payload to a byte array or Buffer for better\n   * cross-language compatibility.\n   */\n  body: any;\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload.\n   *\n   * Note: Numbers that are not whole integers are not allowed.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   * See {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  correlationId?: string | number | Buffer;\n  /**\n   * The partition key for sending a message to a partitioned entity.\n   * Maximum length is 128 characters. For {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-partitioning | partitioned entities},\n   * setting this value enables assigning related messages to the same internal partition,\n   * so that submission sequence order is correctly recorded. The partition is chosen by a hash\n   * function over this value and cannot be chosen directly.\n   * - For session-aware entities, the `sessionId` property overrides this value.\n   * - For non partitioned entities, partition key will be ignored\n   *\n   */\n  partitionKey?: string;\n  /**\n   * The partition key for sending a message into an entity\n   * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a\n   * transfer queue in the scope of a transaction, this value selects the transfer queue partition:\n   * This is functionally equivalent to `partitionKey` property and ensures that messages are kept\n   * together and in order as they are transferred.\n   * See {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via | Transfers and Send Via}.\n   */\n\n  // Will be required later for implementing Transactions\n  // viaPartitionKey?: string;\n\n  /**\n   * The session identifier for a session-aware entity. Maximum\n   * length is 128 characters. For session-aware entities, this application-defined value specifies\n   * the session affiliation of the message. Messages with the same session identifier are subject\n   * to summary locking and enable exact in-order processing and demultiplexing. For\n   * session-unaware entities, this value is ignored.\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-sessions | Message Sessions}.\n   */\n  sessionId?: string;\n  /**\n   * The session identifier augmenting the `replyTo` address.\n   * Maximum length is 128 characters. This value augments the ReplyTo information and specifies\n   * which SessionId should be set for the reply when sent to the reply entity.\n   * See {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  replyToSessionId?: string;\n  /**\n   * The message’s time to live value. This value is the relative\n   * duration after which the message expires, starting from the instant the message has been\n   * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,\n   * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level\n   * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is\n   * silently adjusted if it does. See\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-expiration | Expiration}.\n   */\n  timeToLive?: number;\n  /**\n   * The application specific label. This property enables the\n   * application to indicate the purpose of the message to the receiver in a standardized. fashion,\n   * similar to an email subject line. The mapped AMQP property is \"subject\".\n   */\n  subject?: string;\n  /**\n   * The \"to\" address. This property is reserved for future use in routing\n   * scenarios and presently ignored by the broker itself. Applications can use this value in\n   * rule-driven {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding | auto-forward chaining}\n   * scenarios to indicate the intended logical destination of the message.\n   */\n  to?: string;\n  /**\n   * The address of an entity to send replies to. This optional and\n   * application-defined value is a standard way to express a reply path to the receiver of the\n   * message. When a sender expects a reply, it sets the value to the absolute or relative path of\n   * the queue or topic it expects the reply to be sent to. See\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  replyTo?: string;\n  /**\n   * The date and time in UTC at which the message will\n   * be enqueued. This property returns the time in UTC; when setting the property, the\n   * supplied DateTime value must also be in UTC. This value is for delayed message sending.\n   * It is utilized to delay messages sending to a specific time in the future. Message enqueuing\n   * time does not mean that the message will be sent at the same time. It will get enqueued,\n   * but the actual sending time depends on the queue's workload and its state.\n   */\n  scheduledEnqueueTimeUtc?: Date;\n  /**\n   * The application specific properties which can be\n   * used for custom message metadata.\n   */\n  applicationProperties?: { [key: string]: number | boolean | string | Date | null };\n}\n\n/**\n * @internal\n * Gets the error message for when a property on given message is not of expected type\n */\nexport function getMessagePropertyTypeMismatchError(msg: ServiceBusMessage): Error | undefined {\n  if (msg.contentType != null && typeof msg.contentType !== \"string\") {\n    return new TypeError(\"The property 'contentType' on the message must be of type 'string'\");\n  }\n\n  if (msg.subject != null && typeof msg.subject !== \"string\") {\n    return new TypeError(\"The property 'label' on the message must be of type 'string'\");\n  }\n\n  if (msg.to != null && typeof msg.to !== \"string\") {\n    return new TypeError(\"The property 'to' on the message must be of type 'string'\");\n  }\n\n  if (msg.replyTo != null && typeof msg.replyTo !== \"string\") {\n    return new TypeError(\"The property 'replyTo' on the message must be of type 'string'\");\n  }\n\n  if (msg.replyToSessionId != null && typeof msg.replyToSessionId !== \"string\") {\n    return new TypeError(\"The property 'replyToSessionId' on the message must be of type 'string'\");\n  }\n\n  if (msg.timeToLive != null && typeof msg.timeToLive !== \"number\") {\n    return new TypeError(\"The property 'timeToLive' on the message must be of type 'number'\");\n  }\n\n  if (msg.sessionId != null && typeof msg.sessionId !== \"string\") {\n    return new TypeError(\"The property 'sessionId' on the message must be of type 'string'\");\n  }\n\n  if (\n    msg.messageId != null &&\n    typeof msg.messageId !== \"string\" &&\n    typeof msg.messageId !== \"number\" &&\n    !Buffer.isBuffer(msg.messageId)\n  ) {\n    return new TypeError(\n      \"The property 'messageId' on the message must be of type string, number or Buffer\",\n    );\n  }\n\n  if (\n    msg.correlationId != null &&\n    typeof msg.correlationId !== \"string\" &&\n    typeof msg.correlationId !== \"number\" &&\n    !Buffer.isBuffer(msg.correlationId)\n  ) {\n    return new TypeError(\n      \"The property 'correlationId' on the message must be of type string, number or Buffer\",\n    );\n  }\n  return;\n}\n\n/**\n * @internal\n * Converts given ServiceBusMessage to RheaMessage\n */\nexport function toRheaMessage(\n  msg: ServiceBusMessage | ServiceBusReceivedMessage | AmqpAnnotatedMessage,\n  encoder: Pick<typeof defaultDataTransformer, \"encode\">,\n): RheaMessage {\n  let amqpMsg: RheaMessage;\n  if (isAmqpAnnotatedMessage(msg)) {\n    amqpMsg = {\n      ...AmqpAnnotatedMessage.toRheaMessage(msg),\n      body: encoder.encode(msg.body, msg.bodyType ?? \"data\"),\n    };\n  } else {\n    let bodyType: \"data\" | \"sequence\" | \"value\" = \"data\";\n\n    if (isServiceBusReceivedMessage(msg)) {\n      /*\n       * TODO: this is a bit complicated.\n       *\n       * It seems reasonable to expect to be able to round-trip a message (ie,\n       * receive a message, and then send it again, possibly to another queue / topic).\n       * If the user does that we need to make sure to respect their original AMQP\n       * type so when the message is re - encoded we don't put 'body' into the wrong spot.\n       *\n       * The complication is that we need to decide if we're okay with respecting a field\n       * from the rawAmqpMessage, which up until now we've treated as just vestigial\n       * information on send. My hope is that the use case of \"alter the sb message in some\n       * incompatible way with the underying _rawAmqpMessage.bodyType\" is not common\n       * enough for us to try to do anything more than what I'm doing here.\n       */\n      bodyType = msg._rawAmqpMessage.bodyType ?? \"data\";\n    }\n\n    // TODO: it seems sensible that we'd also do this for AMQPAnnotated message.\n    const validationError = getMessagePropertyTypeMismatchError(msg);\n\n    if (validationError) {\n      throw validationError;\n    }\n\n    amqpMsg = {\n      body: encoder.encode(msg.body, bodyType),\n      message_annotations: {},\n    };\n\n    if (msg.timeToLive) {\n      amqpMsg.ttl = Math.min(msg.timeToLive, Constants.maxUint32Value);\n      amqpMsg.creation_time = new Date();\n      amqpMsg.absolute_expiry_time = new Date(\n        Math.min(amqpMsg.creation_time.getTime() + amqpMsg.ttl, Constants.maxAbsoluteExpiryTime),\n      );\n    }\n  }\n\n  if (isAmqpAnnotatedMessage(msg)) {\n    return amqpMsg;\n  }\n\n  if (msg.applicationProperties != null) {\n    amqpMsg.application_properties = msg.applicationProperties;\n  }\n  if (msg.contentType != null) {\n    amqpMsg.content_type = msg.contentType;\n  }\n  if (msg.sessionId != null) {\n    if (msg.sessionId.length > Constants.maxSessionIdLength) {\n      throw new Error(\n        \"Length of 'sessionId' property on the message cannot be greater than 128 characters.\",\n      );\n    }\n\n    amqpMsg.group_id = msg.sessionId;\n  }\n  if (msg.replyTo != null) {\n    amqpMsg.reply_to = msg.replyTo;\n  }\n  if (msg.to != null) {\n    amqpMsg.to = msg.to;\n  }\n  if (msg.subject != null) {\n    amqpMsg.subject = msg.subject;\n  }\n\n  updateMessageId(amqpMsg, msg.messageId);\n\n  if (msg.correlationId != null) {\n    amqpMsg.correlation_id = msg.correlationId;\n  }\n  if (msg.replyToSessionId != null) {\n    amqpMsg.reply_to_group_id = msg.replyToSessionId;\n  }\n  if (msg.partitionKey != null) {\n    if (msg.partitionKey.length > Constants.maxPartitionKeyLength) {\n      throw new Error(\n        \"Length of 'partitionKey' property on the message cannot be greater than 128 characters.\",\n      );\n    }\n    amqpMsg.message_annotations![Constants.partitionKey] = msg.partitionKey;\n  }\n\n  // Will be required later for implementing Transactions\n  // if (msg.viaPartitionKey != null) {\n  //   if (msg.viaPartitionKey.length > Constants.maxPartitionKeyLength) {\n  //     throw new Error(\n  //       \"Length of 'viaPartitionKey' property on the message cannot be greater than 128 characters.\"\n  //     );\n  //   }\n  //   amqpMsg.message_annotations![Constants.viaPartitionKey] = msg.viaPartitionKey;\n  // }\n\n  updateScheduledTime(amqpMsg, msg.scheduledEnqueueTimeUtc);\n\n  logger.verbose(\"SBMessage to RheaMessage: %O\", amqpMsg);\n  return amqpMsg;\n}\n\n/** @internal */\nexport function updateMessageId(\n  rheaMessage: RheaMessage,\n  messageId: RheaMessage[\"message_id\"],\n): void {\n  if (messageId != null) {\n    if (typeof messageId === \"string\" && messageId.length > Constants.maxMessageIdLength) {\n      throw new Error(\n        `Length of 'messageId' property on the message cannot be greater than ${Constants.maxMessageIdLength} characters.`,\n      );\n    }\n\n    rheaMessage.message_id = messageId;\n  }\n}\n\n/** @internal */\nexport function updateScheduledTime(\n  rheaMessage: RheaMessage,\n  scheduledEnqueuedTimeUtc: Date | undefined,\n): void {\n  if (scheduledEnqueuedTimeUtc != null) {\n    rheaMessage.message_annotations = rheaMessage.message_annotations ?? {};\n    rheaMessage.message_annotations[Constants.scheduledEnqueueTime] = scheduledEnqueuedTimeUtc;\n  }\n}\n\n/**\n * Describes the message received from Service Bus during peek operations and so cannot be settled.\n */\nexport interface ServiceBusReceivedMessage extends ServiceBusMessage {\n  /**\n   * The reason for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterReason?: string;\n  /**\n   * The error description for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterErrorDescription?: string;\n  /**\n   * The lock token is a reference to the lock that is being held by the broker in\n   * `peekLock` receive mode. Locks are used internally settle messages as explained in the\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement | product documentation in more detail}\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   * @readonly\n   */\n  readonly lockToken?: string;\n  /**\n   * Number of deliveries that have been attempted for this message. The count is\n   * incremented when a message lock expires, or the message is explicitly abandoned using the\n   * `abandon()` method on the message.\n   * @readonly\n   */\n  readonly deliveryCount?: number;\n  /**\n   * The UTC instant at which the message has been accepted and stored in Service Bus.\n   * @readonly\n   */\n  readonly enqueuedTimeUtc?: Date;\n  /**\n   * The UTC instant at which the message is marked for removal and no longer available for\n   * retrieval from the entity due to expiration. This property is computed from 2 other properties\n   * on the message: `enqueuedTimeUtc` + `timeToLive`.\n   */\n  readonly expiresAtUtc?: Date;\n  /**\n   * The UTC instant until which the message is held locked in the queue/subscription.\n   * When the lock expires, the `deliveryCount` is incremented and the message is again available\n   * for retrieval.\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   */\n  lockedUntilUtc?: Date;\n  /**\n   * The original sequence number of the message. For\n   * messages that have been auto-forwarded, this property reflects the sequence number that had\n   * first been assigned to the message at its original point of submission.\n   * @readonly\n   */\n  readonly enqueuedSequenceNumber?: number;\n  /**\n   * The unique number assigned to a message by Service Bus.\n   * The sequence number is a unique 64-bit integer assigned to a message as it is accepted\n   * and stored by the broker and functions as its true identifier. For partitioned entities,\n   * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.\n   * They roll over to 0 when the 48-64 bit range is exhausted.\n   *\n   * **Max safe integer** that Javascript currently supports is `2^53 - 1`. The sequence number\n   * is an AMQP `Long` type which can be upto 64 bits long. To represent that we are using a\n   * library named {@link https://github.com/dcodeIO/long.js | long.js}. We expect customers\n   * to use the **`Long`** type exported by this library.\n   * @readonly\n   */\n  readonly sequenceNumber?: Long;\n  /**\n   * The name of the queue or subscription that this message\n   * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered\n   * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the\n   * entity in which the message was dead-lettered.\n   * @readonly\n   */\n  readonly deadLetterSource?: string;\n  /**\n   * State of the message can be active, deferred or scheduled. Deferred messages have deferred state,\n   * scheduled messages have scheduled state, all other messages have active state.\n   */\n  readonly state: \"active\" | \"deferred\" | \"scheduled\";\n  /**\n   * The underlying raw amqp message.\n   * @readonly\n   */\n  readonly _rawAmqpMessage: AmqpAnnotatedMessage;\n}\n\n/**\n * @internal\n * Converts given RheaMessage to ServiceBusReceivedMessage\n */\nexport function fromRheaMessage(\n  rheaMessage: RheaMessage,\n  options: {\n    skipParsingBodyAsJson: boolean;\n    skipConvertingDate?: boolean;\n    delivery?: Delivery;\n    shouldReorderLockToken?: boolean;\n  },\n): ServiceBusReceivedMessage {\n  if (!rheaMessage) {\n    rheaMessage = {\n      body: undefined,\n    };\n  }\n  const {\n    skipParsingBodyAsJson,\n    delivery,\n    shouldReorderLockToken,\n    skipConvertingDate = false,\n  } = options;\n  const { body, bodyType } = defaultDataTransformer.decodeWithType(\n    rheaMessage.body,\n    skipParsingBodyAsJson,\n  );\n\n  const sbmsg: ServiceBusMessage = {\n    body: body,\n  };\n\n  if (rheaMessage.application_properties != null) {\n    sbmsg.applicationProperties = skipConvertingDate\n      ? rheaMessage.application_properties\n      : convertDatesToNumbers(rheaMessage.application_properties);\n  }\n  if (rheaMessage.content_type != null) {\n    sbmsg.contentType = rheaMessage.content_type;\n  }\n  if (rheaMessage.group_id != null) {\n    sbmsg.sessionId = rheaMessage.group_id;\n  }\n  if (rheaMessage.reply_to != null) {\n    sbmsg.replyTo = rheaMessage.reply_to;\n  }\n  if (rheaMessage.to != null) {\n    sbmsg.to = rheaMessage.to;\n  }\n  if (rheaMessage.subject != null) {\n    sbmsg.subject = rheaMessage.subject;\n  }\n  if (rheaMessage.message_id != null) {\n    sbmsg.messageId = rheaMessage.message_id;\n  }\n  if (rheaMessage.correlation_id != null) {\n    sbmsg.correlationId = rheaMessage.correlation_id;\n  }\n  if (rheaMessage.reply_to_group_id != null) {\n    sbmsg.replyToSessionId = rheaMessage.reply_to_group_id;\n  }\n\n  if (rheaMessage.message_annotations != null) {\n    if (rheaMessage.message_annotations[Constants.partitionKey] != null) {\n      sbmsg.partitionKey = rheaMessage.message_annotations[Constants.partitionKey];\n    }\n\n    // Will be required later for implementing Transactions\n    // if (msg.message_annotations[Constants.viaPartitionKey] != null) {\n    //   sbmsg.viaPartitionKey = msg.message_annotations[Constants.viaPartitionKey];\n    // }\n\n    if (rheaMessage.message_annotations[Constants.scheduledEnqueueTime] != null) {\n      sbmsg.scheduledEnqueueTimeUtc =\n        rheaMessage.message_annotations[Constants.scheduledEnqueueTime];\n    }\n  }\n\n  type PartialWritable<T> = Partial<{\n    -readonly [P in keyof T]: T[P];\n  }>;\n  const props: PartialWritable<ServiceBusReceivedMessage> & {\n    state: \"active\" | \"deferred\" | \"scheduled\";\n  } = { state: \"active\" };\n  if (rheaMessage.message_annotations != null) {\n    if (rheaMessage.message_annotations[Constants.deadLetterSource] != null) {\n      props.deadLetterSource = rheaMessage.message_annotations[Constants.deadLetterSource];\n    }\n    const messageState = rheaMessage.message_annotations[Constants.messageState];\n    if (messageState === 1) {\n      props.state = \"deferred\";\n    } else if (messageState === 2) {\n      props.state = \"scheduled\";\n    }\n    if (rheaMessage.message_annotations[Constants.enqueueSequenceNumber] != null) {\n      props.enqueuedSequenceNumber =\n        rheaMessage.message_annotations[Constants.enqueueSequenceNumber];\n    }\n    if (rheaMessage.message_annotations[Constants.sequenceNumber] != null) {\n      if (Buffer.isBuffer(rheaMessage.message_annotations[Constants.sequenceNumber])) {\n        props.sequenceNumber = Long.fromBytesBE(\n          rheaMessage.message_annotations[Constants.sequenceNumber],\n        );\n      } else {\n        props.sequenceNumber = Long.fromNumber(\n          rheaMessage.message_annotations[Constants.sequenceNumber],\n        );\n      }\n    }\n    if (rheaMessage.message_annotations[Constants.enqueuedTime] != null) {\n      props.enqueuedTimeUtc = new Date(\n        rheaMessage.message_annotations[Constants.enqueuedTime] as number,\n      );\n    }\n    if (rheaMessage.message_annotations[Constants.lockedUntil] != null) {\n      props.lockedUntilUtc = new Date(\n        rheaMessage.message_annotations[Constants.lockedUntil] as number,\n      );\n    }\n  }\n\n  const rawMessage = AmqpAnnotatedMessage.fromRheaMessage(rheaMessage);\n  rawMessage.bodyType = bodyType;\n  if (rheaMessage.ttl == null) {\n    rheaMessage.ttl = rawMessage.header?.timeToLive ?? Constants.maxDurationValue;\n  }\n  if (props.enqueuedTimeUtc) {\n    props.expiresAtUtc = new Date(\n      Math.min(props.enqueuedTimeUtc.getTime() + rheaMessage.ttl, Constants.maxDurationValue),\n    );\n  }\n\n  if (rawMessage.applicationProperties) {\n    rawMessage.applicationProperties = skipConvertingDate\n      ? rawMessage.applicationProperties\n      : convertDatesToNumbers(rawMessage.applicationProperties);\n  }\n  if (rawMessage.deliveryAnnotations) {\n    rawMessage.deliveryAnnotations = skipConvertingDate\n      ? rawMessage.deliveryAnnotations\n      : convertDatesToNumbers(rawMessage.deliveryAnnotations);\n  }\n  if (rawMessage.messageAnnotations) {\n    rawMessage.messageAnnotations = skipConvertingDate\n      ? rawMessage.messageAnnotations\n      : convertDatesToNumbers(rawMessage.messageAnnotations);\n  }\n\n  if (rawMessage.header?.timeToLive) {\n    sbmsg.timeToLive = rawMessage.header.timeToLive;\n  }\n\n  const rcvdsbmsg: ServiceBusReceivedMessage = {\n    _rawAmqpMessage: rawMessage,\n    deliveryCount: rheaMessage.delivery_count,\n    lockToken:\n      delivery && delivery.tag && delivery.tag.length !== 0\n        ? uuid_to_string(\n            shouldReorderLockToken === true\n              ? reorderLockToken(\n                  typeof delivery.tag === \"string\" ? Buffer.from(delivery.tag) : delivery.tag,\n                )\n              : typeof delivery.tag === \"string\"\n                ? Buffer.from(delivery.tag)\n                : delivery.tag,\n          )\n        : undefined,\n    ...sbmsg,\n    ...props,\n    deadLetterReason: sbmsg.applicationProperties?.DeadLetterReason as string | undefined,\n    deadLetterErrorDescription: sbmsg.applicationProperties?.DeadLetterErrorDescription as\n      | string\n      | undefined,\n  };\n\n  logger.verbose(\"AmqpMessage to ServiceBusReceivedMessage: %O\", rcvdsbmsg);\n  return rcvdsbmsg;\n}\n\n/**\n * @internal\n */\nexport function isServiceBusMessage(possible: unknown): possible is ServiceBusMessage {\n  return isObjectWithProperties(possible, [\"body\"]);\n}\n\n/**\n * @internal\n */\nexport function isAmqpAnnotatedMessage(possible: unknown): possible is AmqpAnnotatedMessage {\n  return (\n    isObjectWithProperties(possible, [\"body\", \"bodyType\"]) &&\n    possible.constructor.name !== ServiceBusMessageImpl.name\n  );\n}\n\n/**\n * @internal\n */\nexport function isServiceBusReceivedMessage(\n  possible: unknown,\n): possible is ServiceBusReceivedMessage {\n  return isServiceBusMessage(possible) && \"_rawAmqpMessage\" in possible;\n}\n\n/**\n * Describes the message received from Service Bus.\n *\n * @internal\n */\nexport class ServiceBusMessageImpl implements ServiceBusReceivedMessage {\n  /**\n   * The message body that needs to be sent or is received.\n   */\n  body: any;\n  /**\n   * The application specific properties.\n   */\n  applicationProperties?: { [key: string]: any };\n  /**\n   * The message identifier is an\n   * application-defined value that uniquely identifies the message and its payload. The identifier\n   * is a free-form string and can reflect a GUID or an identifier derived from the application\n   * context. If enabled, the\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/duplicate-detection | duplicate detection}\n   * identifies and removes second and further submissions of messages with the same MessageId.\n   */\n  messageId?: string | number | Buffer;\n  /**\n   * The content type of the message. Optionally describes\n   * the payload of the message, with a descriptor following the format of RFC2045, Section 5, for\n   * example \"application/json\".\n   */\n  contentType?: string;\n  /**\n   * The correlation identifier that allows an\n   * application to specify a context for the message for the purposes of correlation, for example\n   * reflecting the MessageId of a message that is being replied to.\n   * See {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  correlationId?: string | number | Buffer;\n  /**\n   * The partition key for sending a message to a\n   * partitioned entity. Maximum length is 128 characters. For {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-partitioning | partitioned entities},\n   * setting this value enables assigning related messages to the same internal partition,\n   * so that submission sequence order is correctly recorded. The partition is chosen by a hash\n   * function over this value and cannot be chosen directly. For session-aware entities,\n   * the `sessionId` property overrides this value.\n   */\n  partitionKey?: string;\n  /**\n   * The partition key for sending a message into an entity\n   * via a partitioned transfer queue. Maximum length is 128 characters. If a message is sent via a\n   * transfer queue in the scope of a transaction, this value selects the transfer queue partition:\n   * This is functionally equivalent to `partitionKey` property and ensures that messages are kept\n   * together and in order as they are transferred.\n   * See {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-transactions#transfers-and-send-via | Transfers and Send Via}.\n   */\n  // Will be required later for implementing Transactions\n  // viaPartitionKey?: string;\n  /**\n   * The session identifier for a session-aware entity. Maximum\n   * length is 128 characters. For session-aware entities, this application-defined value specifies\n   * the session affiliation of the message. Messages with the same session identifier are subject\n   * to summary locking and enable exact in-order processing and demultiplexing. For\n   * session-unaware entities, this value is ignored.\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-sessions | Message Sessions}.\n   */\n  sessionId?: string;\n  /**\n   * The session identifier augmenting the `replyTo` address.\n   * Maximum length is 128 characters. This value augments the ReplyTo information and specifies\n   * which SessionId should be set for the reply when sent to the reply entity.\n   * See {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  replyToSessionId?: string;\n  /**\n   * The message’s time to live value. This value is the relative\n   * duration after which the message expires, starting from the instant the message has been\n   * accepted and stored by the broker, as captured in `enqueuedTimeUtc`. When not set explicitly,\n   * the assumed value is the DefaultTimeToLive for the respective queue or topic. A message-level\n   * `timeToLive` value cannot be longer than the entity's DefaultTimeToLive setting and it is\n   * silently adjusted if it does. See\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-expiration | Expiration}.\n   */\n  timeToLive?: number;\n  /**\n   * The application specific label. This property enables the\n   * application to indicate the purpose of the message to the receiver in a standardized. fashion,\n   * similar to an email subject line. The mapped AMQP property is \"subject\".\n   */\n  subject?: string;\n  /**\n   * The \"to\" address. This property is reserved for future use in routing\n   * scenarios and presently ignored by the broker itself. Applications can use this value in\n   * rule-driven {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-auto-forwarding | auto-forward chaining}\n   * scenarios to indicate the intended logical destination of the message.\n   */\n  to?: string;\n  /**\n   * The address of an entity to send replies to. This optional and\n   * application-defined value is a standard way to express a reply path to the receiver of the\n   * message. When a sender expects a reply, it sets the value to the absolute or relative path of\n   * the queue or topic it expects the reply to be sent to. See\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messages-payloads?#message-routing-and-correlation | Message Routing and Correlation}.\n   */\n  replyTo?: string;\n  /**\n   * The date and time in UTC at which the message will\n   * be enqueued. This property returns the time in UTC; when setting the property, the\n   * supplied DateTime value must also be in UTC. This value is for delayed message sending.\n   * It is utilized to delay messages sending to a specific time in the future. Message enqueuing\n   * time does not mean that the message will be sent at the same time. It will get enqueued,\n   * but the actual sending time depends on the queue's workload and its state.\n   */\n  scheduledEnqueueTimeUtc?: Date;\n  /**\n   * The lock token is a reference to the lock that is being held by the broker in\n   * `peekLock` receive mode. Locks are used internally settle messages as explained in the\n   * {@link https://learn.microsoft.com/azure/service-bus-messaging/message-transfers-locks-settlement | product documentation in more detail}\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   * @readonly\n   */\n  readonly lockToken?: string;\n  /**\n   * Number of deliveries that have been attempted for this message. The count is\n   * incremented when a message lock expires, or the message is explicitly abandoned using the\n   * `abandon()` method on the message.\n   * @readonly\n   */\n  readonly deliveryCount?: number;\n  /**\n   * The UTC instant at which the message has been accepted and stored in Service Bus.\n   * @readonly\n   */\n  readonly enqueuedTimeUtc?: Date;\n  /**\n   * The UTC instant at which the message is marked for removal and no longer available for\n   * retrieval from the entity due to expiration. This property is computed from 2 other properties\n   * on the message: `enqueuedTimeUtc` + `timeToLive`.\n   */\n  readonly expiresAtUtc?: Date;\n  /**\n   * The UTC instant until which the message is held locked in the queue/subscription.\n   * When the lock expires, the `deliveryCount` is incremented and the message is again available\n   * for retrieval.\n   * - Not applicable when the message is received in `receiveAndDelete` receive mode.\n   * mode.\n   */\n  lockedUntilUtc?: Date;\n  /**\n   * The original sequence number of the message. For\n   * messages that have been auto-forwarded, this property reflects the sequence number that had\n   * first been assigned to the message at its original point of submission.\n   * @readonly\n   */\n  readonly enqueuedSequenceNumber?: number;\n  /**\n   * The unique number assigned to a message by Service Bus.\n   * The sequence number is a unique 64-bit integer assigned to a message as it is accepted\n   * and stored by the broker and functions as its true identifier. For partitioned entities,\n   * the topmost 16 bits reflect the partition identifier. Sequence numbers monotonically increase.\n   * They roll over to 0 when the 48-64 bit range is exhausted.\n   * @readonly\n   */\n  readonly sequenceNumber?: Long;\n  /**\n   * The name of the queue or subscription that this message\n   * was enqueued on, before it was deadlettered. Only set in messages that have been dead-lettered\n   * and subsequently auto-forwarded from the dead-letter sub-queue to another entity. Indicates the\n   * entity in which the message was dead-lettered.\n   * @readonly\n   */\n  readonly deadLetterSource?: string;\n  /**\n   * State of the message can be active, deferred or scheduled. Deferred messages have deferred state,\n   * scheduled messages have scheduled state, all other messages have active state.\n   */\n  readonly state: \"active\" | \"deferred\" | \"scheduled\";\n  /**\n   * The associated delivery of the received message.\n   */\n  readonly delivery: Delivery;\n  /**\n   * The underlying raw amqp annotated message.\n   * @readonly\n   */\n  readonly _rawAmqpMessage: AmqpAnnotatedMessage;\n  /**\n   * The reason for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterReason?: string;\n  /**\n   * The error description for deadlettering the message.\n   * @readonly\n   */\n  readonly deadLetterErrorDescription?: string;\n  /**\n   * @internal\n   */\n  constructor(\n    msg: RheaMessage,\n    delivery: Delivery,\n    shouldReorderLockToken: boolean,\n    receiveMode: ReceiveMode,\n    skipParsingBodyAsJson: boolean,\n    skipConvertingDate: boolean,\n  ) {\n    const { _rawAmqpMessage, ...restOfMessageProps } = fromRheaMessage(\n      msg,\n\n      { skipParsingBodyAsJson, delivery, shouldReorderLockToken, skipConvertingDate },\n    );\n    this._rawAmqpMessage = _rawAmqpMessage; // need to initialize _rawAmqpMessage property to make compiler happy\n    Object.assign(this, restOfMessageProps);\n    this.state = restOfMessageProps.state; // to suppress error TS2564: Property 'state' has no initializer and is not definitely assigned in the constructor.\n\n    // Lock on a message is applicable only in peekLock mode, but the service sets\n    // the lock token even in receiveAndDelete mode if the entity in question is partitioned.\n    if (receiveMode === \"receiveAndDelete\") {\n      this.lockToken = undefined;\n    }\n    this.delivery = delivery;\n  }\n\n  /**\n   * Creates a clone of the current message to allow it to be re-sent to the queue\n   * @returns ServiceBusMessage\n   */\n  clone(): ServiceBusMessage {\n    // We are returning a ServiceBusMessage object because that object can then be sent to Service Bus\n    const clone: ServiceBusMessage = {\n      body: this.body,\n      contentType: this.contentType,\n      correlationId: this.correlationId,\n      subject: this.subject,\n      messageId: this.messageId,\n      partitionKey: this.partitionKey,\n      replyTo: this.replyTo,\n      replyToSessionId: this.replyToSessionId,\n      scheduledEnqueueTimeUtc: this.scheduledEnqueueTimeUtc,\n      sessionId: this.sessionId,\n      timeToLive: this.timeToLive,\n      to: this.to,\n      applicationProperties: this.applicationProperties,\n      // Will be required later for implementing Transactions\n      // viaPartitionKey: this.viaPartitionKey\n    };\n\n    return clone;\n  }\n}\n\n/**\n * Converts any Date objects into a number representing date.getTime().\n * Recursively checks for any Date objects in arrays and objects.\n * @internal\n */\nfunction convertDatesToNumbers<T = unknown>(thing: T): T {\n  // fast exit\n  if (!isDefined(thing)) return thing;\n\n  // When 'thing' is a Date, return the number representation\n  if (\n    typeof thing === \"object\" &&\n    isObjectWithProperties(thing, [\"getTime\"]) &&\n    typeof thing.getTime === \"function\"\n  ) {\n    return thing.getTime();\n  }\n\n  /*\n    Examples:\n    [0, 'foo', new Date(), { nested: new Date()}]\n  */\n  if (Array.isArray(thing)) {\n    const result = [];\n    for (const element of thing) {\n      result.push(convertDatesToNumbers(element));\n    }\n    return result as unknown as T;\n  }\n\n  /*\n    Examples:\n    { foo: new Date(), children: { nested: new Date() }}\n  */\n  if (typeof thing === \"object\" && isDefined<object>(thing)) {\n    const thingShallowCopy = { ...thing };\n    for (const key of Object.keys(thingShallowCopy)) {\n      (thingShallowCopy as any)[key] = convertDatesToNumbers((thingShallowCopy as any)[key]);\n    }\n    return thingShallowCopy;\n  }\n\n  return thing;\n}\n"]}