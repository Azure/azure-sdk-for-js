{"version":3,"file":"messageSession.js","sourceRoot":"","sources":["../../../src/session/messageSession.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { MessagingError, RetryOptions } from \"@azure/core-amqp\";\nimport { Constants, ErrorNameConditionMapper, StandardAbortMessage } from \"@azure/core-amqp\";\nimport type { AmqpError, EventContext, OnAmqpEvent, Receiver, ReceiverOptions } from \"rhea-promise\";\nimport { ReceiverEvents } from \"rhea-promise\";\nimport type { ConnectionContext } from \"../connectionContext.js\";\nimport { LinkEntity } from \"../core/linkEntity.js\";\nimport type { DispositionStatusOptions } from \"../core/managementClient.js\";\nimport type { OnAmqpEventAsPromise, OnError, OnMessage } from \"../core/messageReceiver.js\";\nimport { receiverLogger as logger } from \"../log.js\";\nimport { DispositionType, ServiceBusMessageImpl } from \"../serviceBusMessage.js\";\nimport { throwErrorIfConnectionClosed } from \"../util/errors.js\";\nimport { calculateRenewAfterDuration, convertTicksToDate } from \"../util/utils.js\";\nimport type { MinimalReceiver } from \"../core/batchingReceiver.js\";\nimport { BatchingReceiverLite } from \"../core/batchingReceiver.js\";\nimport type { DeferredPromiseAndTimer } from \"../core/shared.js\";\nimport { onMessageSettled, createReceiverOptions } from \"../core/shared.js\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { ReceiverHelper } from \"../core/receiverHelper.js\";\nimport type {\n  ServiceBusSessionReceiverOptions,\n  ProcessErrorArgs,\n  ReceiveMode,\n  SubscribeOptions,\n} from \"../models.js\";\nimport type { OperationOptionsBase } from \"../modelsToBeSharedWithEventHubs.js\";\nimport { ServiceBusError, translateServiceBusError } from \"../serviceBusError.js\";\nimport { abandonMessage, completeMessage } from \"../receivers/receiverCommon.js\";\nimport { delay, isDefined } from \"@azure/core-util\";\n\n/**\n * Describes the options that need to be provided while creating a message session receiver link.\n * @internal\n */\nexport interface CreateMessageSessionReceiverLinkOptions {\n  onClose: OnAmqpEventAsPromise;\n  onSessionClose: OnAmqpEventAsPromise;\n  onError: OnAmqpEvent;\n  onSessionError: OnAmqpEvent;\n  onSettled: OnAmqpEvent;\n  sessionId?: string;\n}\n\n/**\n * @internal\n * Describes all the options that can be set while instantiating a MessageSession object.\n */\nexport type MessageSessionOptions = Pick<\n  ServiceBusSessionReceiverOptions,\n  \"maxAutoLockRenewalDurationInMs\" | \"abortSignal\"\n> & {\n  receiveMode?: ReceiveMode;\n  retryOptions: RetryOptions | undefined;\n  skipParsingBodyAsJson: boolean;\n  skipConvertingDate: boolean;\n};\n\n/**\n * @internal\n * Describes the receiver for a Message Session.\n */\nexport class MessageSession extends LinkEntity<Receiver> {\n  /**\n   * Provides the duration until which the session is locked.\n   */\n  sessionLockedUntilUtc!: Date;\n  /**\n   * The sessionId for the message session. Empty string is valid sessionId.\n   */\n  sessionId!: string;\n  /**\n   * The maximum number of concurrent sessions that the\n   * client should initiate.\n   * - **Default**: `1`.\n   */\n  maxConcurrentSessions?: number;\n  /**\n   * The maximum number of messages that should be\n   * processed concurrently in a session while in streaming mode. Once this limit has been reached,\n   * more messages will not be received until the user's message handler has completed processing current message.\n   * - **Default**: `1` (message in a session at a time).\n   */\n  maxConcurrentCalls: number = 1;\n  /**\n   * The mode in which messages should be received.\n   * Default: ReceiveMode.peekLock\n   */\n  receiveMode: ReceiveMode;\n  /**\n   * Indicates whether `Message.complete()` should be called\n   * automatically after the message processing is complete while receiving messages with handlers.\n   * Default: false.\n   */\n  autoComplete: boolean;\n  /**\n   * The maximum duration within which the\n   * lock will be renewed automatically. This value should be greater than the longest message\n   * lock duration; for example, the `lockDuration` property on the received message.\n   *\n   * Default: `300 * 1000` (5 minutes);\n   */\n  maxAutoRenewDurationInMs: number;\n  /**\n   * Should lock renewal happen automatically.\n   */\n  autoRenewLock: boolean;\n  /**\n   * Denotes if we are currently receiving messages\n   */\n  get isReceivingMessages(): boolean {\n    return this._batchingReceiverLite.isReceivingMessages || this._isReceivingMessagesForSubscriber;\n  }\n\n  private _batchingReceiverLite: BatchingReceiverLite;\n  private _isReceivingMessagesForSubscriber: boolean;\n\n  /**\n   * Maintains a map of deliveries that\n   * are being actively disposed. It acts as a store for correlating the responses received for\n   * active dispositions.\n   */\n  private _deliveryDispositionMap: Map<number, DeferredPromiseAndTimer> = new Map<\n    number,\n    DeferredPromiseAndTimer\n  >();\n  /**\n   * The message handler provided by the user that will\n   * be wrapped inside _onAmqpMessage.\n   */\n  private _onMessage!: OnMessage;\n  /**\n   * The error handler provided by the user that will be wrapped\n   * inside _onAmqpError.\n   */\n  private _onError?: OnError;\n  /**\n   * If the user provided error handler is present then it will\n   * notify the user's error handler about the error.\n   */\n  private _notifyError: OnError;\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_close\" event.\n   */\n  private _onAmqpClose: OnAmqpEventAsPromise;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_error\" event.\n   */\n  private _onSessionError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on\n   * the underlying rhea receiver's session for the \"session_close\" event.\n   */\n  private _onSessionClose: OnAmqpEventAsPromise;\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"receiver_error\" event.\n   */\n  private _onAmqpError: OnAmqpEvent;\n  /**\n   * The message handler that will be set as the handler on the\n   * underlying rhea receiver for the \"settled\" event.\n   */\n  private _onSettled: OnAmqpEvent;\n  /**\n   * The session lock renewal timer that keeps\n   * track of when the MessageSession is due for session lock renewal.\n   */\n  private _sessionLockRenewalTimer?: NodeJS.Timeout;\n\n  private _totalAutoLockRenewDuration: number;\n\n  /**\n   * Whether to prevent the client from running JSON.parse() on the message body when receiving the message.\n   */\n  private skipParsingBodyAsJson: boolean;\n\n  /**\n   * Whether to skip converting Date type on properties of message annotations\n   * or application properties into numbers when receiving the message. By\n   * default, properties of Date type is converted into UNIX epoch number for\n   * compatibility.\n   */\n  private skipConvertingDate: boolean;\n\n  public get receiverHelper(): ReceiverHelper {\n    return this._receiverHelper;\n  }\n  private _receiverHelper: ReceiverHelper;\n\n  /**\n   * Ensures that the session lock is renewed before it expires. The lock will not be renewed for\n   * more than the configured totalAutoLockRenewDuration.\n   */\n  private _ensureSessionLockRenewal(): void {\n    if (\n      this.autoRenewLock &&\n      new Date(this._totalAutoLockRenewDuration) > this.sessionLockedUntilUtc! &&\n      Date.now() < this._totalAutoLockRenewDuration &&\n      this.isOpen()\n    ) {\n      const nextRenewalTimeout = calculateRenewAfterDuration(this.sessionLockedUntilUtc!);\n      this._sessionLockRenewalTimer = setTimeout(async () => {\n        try {\n          logger.verbose(\n            \"%s Attempting to renew the session lock for MessageSession '%s' \" + \"with name '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n            this.name,\n          );\n          this.sessionLockedUntilUtc = await this._context\n            .getManagementClient(this.entityPath)\n            .renewSessionLock(this.sessionId, {\n              associatedLinkName: this.name,\n              timeoutInMs: 10000,\n            });\n          logger.verbose(\n            \"%s Successfully renewed the session lock for MessageSession '%s' \" + \"with name '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n            this.name,\n          );\n          logger.verbose(\n            \"%s Calling _ensureSessionLockRenewal() again for MessageSession '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n          );\n          this._ensureSessionLockRenewal();\n        } catch (err: any) {\n          logger.logError(\n            err,\n            \"%s An error occurred while renewing the session lock for MessageSession '%s'\",\n            this.logPrefix,\n            this.sessionId,\n          );\n        }\n      }, nextRenewalTimeout);\n      logger.verbose(\n        \"%s MessageSession '%s' has next session lock renewal in %d milliseconds @(%s).\",\n        this.logPrefix,\n        this.sessionId,\n        nextRenewalTimeout,\n        new Date(Date.now() + nextRenewalTimeout).toString(),\n      );\n    }\n  }\n\n  protected async createRheaLink(\n    options: ReceiverOptions,\n    _abortSignal?: AbortSignalLike,\n  ): Promise<Receiver> {\n    this._lastSBError = undefined;\n    let errorMessage: string = \"\";\n\n    const link = await this._context.connection.createReceiver(options);\n    this._intermediateLink = link;\n\n    const receivedSessionId = link.source?.filter?.[Constants.sessionFilterName];\n    if (this._providedSessionId === undefined && receivedSessionId === undefined) {\n      // When we ask for any sessions (passing option of session-filter: undefined),\n      // but don't receive one back, check whether service has sent any error.\n      if (\n        options.source &&\n        typeof options.source !== \"string\" &&\n        options.source.filter &&\n        Constants.sessionFilterName in options.source.filter &&\n        options.source.filter![Constants.sessionFilterName] === undefined\n      ) {\n        await delay(1); // yield to eventloop\n        if (this._lastSBError) {\n          logger.verbose(\"%s cleaning up resources held by link\", this.logPrefix);\n          await link.close({ closeSession: true });\n          link.remove();\n          throw this._lastSBError;\n        }\n      }\n      // Ideally this code path should never be reached as `MessageSession.createReceiver()` should fail instead\n      // TODO: https://github.com/Azure/azure-sdk-for-js/issues/9775 to figure out why this code path indeed gets hit.\n      errorMessage = `Failed to create a receiver. No unlocked sessions available.`;\n    } else if (\n      this._providedSessionId !== undefined &&\n      receivedSessionId !== this._providedSessionId\n    ) {\n      // This code path is reached if the session is already locked by another receiver.\n      // TODO: Check why the service would not throw an error or just timeout instead of giving a misleading successful receiver\n      errorMessage = `Failed to create a receiver for the requested session '${this._providedSessionId}'. It may be locked by another receiver.`;\n    }\n\n    if (errorMessage) {\n      const error = translateServiceBusError({\n        description: errorMessage,\n        condition: ErrorNameConditionMapper.SessionCannotBeLockedError,\n      });\n      logger.logError(error, this.logPrefix);\n      logger.verbose(\n        \"%s cleaning up resources held by intermediate link (SessionCannotBeLockedError)\",\n        this.logPrefix,\n      );\n      await link.close({ closeSession: true });\n      link.remove();\n      throw error;\n    }\n\n    return link;\n  }\n\n  /**\n   * Creates a new AMQP receiver under a new AMQP session.\n   */\n  private async _init(\n    opts: { abortSignal?: AbortSignalLike; timeoutInMs?: number } = {},\n  ): Promise<void> {\n    try {\n      const sessionOptions = this._createMessageSessionOptions(this.identifier, opts.timeoutInMs);\n      await this.initLink(sessionOptions, opts.abortSignal);\n\n      if (!this.link) {\n        throw new Error(\"INTERNAL ERROR: failed to create receiver but without an error.\");\n      }\n\n      const receivedSessionId = this.link.source?.filter?.[Constants.sessionFilterName];\n\n      if (this._providedSessionId === undefined) this.sessionId = receivedSessionId;\n      this.sessionLockedUntilUtc = convertTicksToDate(\n        this.link.properties[\"com.microsoft:locked-until-utc\"],\n      );\n      logger.verbose(\n        \"%s Session with id '%s' is locked until: '%s'.\",\n        this.logPrefix,\n        this.sessionId,\n        this.sessionLockedUntilUtc.toISOString(),\n      );\n      logger.verbose(\n        \"%s Receiver created with receiver options: %O\",\n        this.logPrefix,\n        sessionOptions,\n      );\n      if (!this._context.messageSessions[this.name]) {\n        this._context.messageSessions[this.name] = this;\n      }\n      this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;\n      this._ensureSessionLockRenewal();\n    } catch (err: any) {\n      const errObj = translateServiceBusError(err);\n      logger.logError(errObj, \"%s An error occured while creating the receiver\", this.logPrefix);\n\n      // Fix the unhelpful error messages for the OperationTimeoutError that comes from `rhea-promise`.\n      if ((errObj as MessagingError).code === \"OperationTimeoutError\") {\n        if (this._providedSessionId !== undefined) {\n          errObj.message = `Failed to create a receiver for the requested session '${this._providedSessionId}' within allocated time and retry attempts.`;\n        } else {\n          errObj.message = \"Failed to create a receiver within allocated time and retry attempts.\";\n        }\n      }\n      if (this._intermediateLink) {\n        logger.verbose(\"%s cleaning up resources held by intermediate link\", this.logPrefix);\n        await this._intermediateLink.close({ closeSession: true });\n        this._intermediateLink.remove();\n      }\n      throw errObj;\n    }\n  }\n\n  /**\n   * Creates the options that need to be specified while creating an AMQP receiver link.\n   */\n  private _createMessageSessionOptions(clientId: string, timeoutInMs?: number): ReceiverOptions {\n    const rcvrOptions: ReceiverOptions = createReceiverOptions(\n      this.name,\n      this.receiveMode,\n      {\n        address: this.address,\n        filter: { [Constants.sessionFilterName]: this.sessionId },\n      },\n      clientId,\n      {\n        onClose: (context) =>\n          this._onAmqpClose(context).catch(() => {\n            /* */\n          }),\n        onSessionClose: (context) =>\n          this._onSessionClose(context).catch(() => {\n            /* */\n          }),\n        onError: this._onAmqpError,\n        onSessionError: this._onSessionError,\n        onSettled: this._onSettled,\n      },\n      timeoutInMs,\n    );\n\n    return rcvrOptions;\n  }\n\n  private _retryOptions: RetryOptions | undefined;\n  private _lastSBError: Error | ServiceBusError | undefined;\n  private _intermediateLink: Receiver | undefined;\n\n  /**\n   * Constructs a MessageSession instance which lets you receive messages as batches\n   * or via callbacks using subscribe.\n   *\n   * @param _providedSessionId - The sessionId provided by the user. This can be the\n   * name of a session ID to open (empty string is also valid) or it can be undefined,\n   * to indicate we want the next unlocked non-empty session.\n   */\n  constructor(\n    public identifier: string,\n    connectionContext: ConnectionContext,\n    entityPath: string,\n    private _providedSessionId: string | undefined,\n    options: MessageSessionOptions,\n  ) {\n    super(entityPath, entityPath, connectionContext, \"session\", logger, {\n      address: entityPath,\n      audience: `${connectionContext.config.endpoint}${entityPath}`,\n    });\n    this._receiverHelper = new ReceiverHelper(() => ({\n      receiver: this.link,\n      logPrefix: this.logPrefix,\n    }));\n    this._retryOptions = options.retryOptions;\n    this.autoComplete = false;\n    if (isDefined(this._providedSessionId)) this.sessionId = this._providedSessionId;\n    this.receiveMode = options.receiveMode || \"peekLock\";\n    this.skipParsingBodyAsJson = options.skipParsingBodyAsJson;\n    this.skipConvertingDate = options.skipConvertingDate;\n    this.maxAutoRenewDurationInMs =\n      options.maxAutoLockRenewalDurationInMs != null\n        ? options.maxAutoLockRenewalDurationInMs\n        : 300 * 1000;\n    this._totalAutoLockRenewDuration = Date.now() + this.maxAutoRenewDurationInMs;\n    this.autoRenewLock = this.maxAutoRenewDurationInMs > 0 && this.receiveMode === \"peekLock\";\n\n    this._isReceivingMessagesForSubscriber = false;\n    this._batchingReceiverLite = new BatchingReceiverLite(\n      connectionContext,\n      entityPath,\n      async (_abortSignal?: AbortSignalLike): Promise<MinimalReceiver> => {\n        return this.link!;\n      },\n      this.receiveMode,\n      this.skipParsingBodyAsJson,\n      this.skipConvertingDate,\n    );\n\n    // setting all the handlers\n    this._onSettled = (context: EventContext) => {\n      const delivery = context.delivery;\n\n      onMessageSettled(this.logPrefix, delivery, this._deliveryDispositionMap);\n    };\n\n    this._notifyError = async (args: ProcessErrorArgs) => {\n      if (this._onError) {\n        this._onError(args);\n        logger.verbose(\n          \"%s Notified the user's error handler about the error received by the Receiver\",\n          this.logPrefix,\n        );\n      }\n    };\n\n    this._onAmqpError = (context: EventContext) => {\n      const receiverError = context.receiver && context.receiver.error;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        if (sbError.code === \"SessionLockLostError\") {\n          sbError.message = `The session lock has expired on the session with id ${this.sessionId}.`;\n        }\n        this._lastSBError = sbError;\n        logger.logError(sbError, \"%s An error occurred for Receiver\", this.logPrefix);\n        this._notifyError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          identifier: this.identifier,\n        });\n      }\n    };\n\n    this._onSessionError = (context: EventContext) => {\n      const connectionId = this._context.connectionId;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError);\n        logger.logError(\n          sbError,\n          \"[%s] An error occurred on the session for Receiver '%s': %O.\",\n          connectionId,\n          this.name,\n          sbError,\n        );\n        this._notifyError({\n          error: sbError,\n          errorSource: \"receive\",\n          entityPath: this.entityPath,\n          fullyQualifiedNamespace: this._context.config.host,\n          identifier: this.identifier,\n        });\n      }\n    };\n\n    this._onAmqpClose = async (context: EventContext) => {\n      const connectionId = this._context.connectionId;\n      const receiverError = context.receiver && context.receiver.error;\n      const receiver = this.link || context.receiver!;\n      if (receiverError) {\n        const sbError = translateServiceBusError(receiverError) as MessagingError;\n        logger.logError(\n          sbError,\n          \"[%s] 'receiver_close' event occurred for receiver '%s' for sessionId '%s'. \" +\n            \"The associated error is: %O\",\n          connectionId,\n          this.name,\n          this.sessionId,\n          sbError,\n        );\n        // no need to notify the user's error handler since rhea guarantees that receiver_error\n        // will always be emitted before receiver_close.\n      }\n      if (receiver && !receiver.isItselfClosed()) {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          this.logPrefix,\n          this.sessionId,\n        );\n        try {\n          await this.close();\n        } catch (err: any) {\n          logger.logError(\n            err,\n            \"%s An error occurred while closing the receiver for sessionId '%s'.\",\n            this.logPrefix,\n            this.sessionId,\n          );\n        }\n      } else {\n        logger.verbose(\n          \"%s 'receiver_close' event occurred on the receiver for sessionId '%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          this.logPrefix,\n          this.sessionId,\n        );\n      }\n    };\n\n    this._onSessionClose = async (context: EventContext) => {\n      const receiver = this.link || context.receiver!;\n      const sessionError = context.session && context.session.error;\n      if (sessionError) {\n        const sbError = translateServiceBusError(sessionError);\n        logger.logError(\n          sbError,\n          \"%s 'session_close' event occurred for receiver for sessionId '%s'. \" +\n            \"The associated error is\",\n          this.logPrefix,\n          this.sessionId,\n        );\n        // no need to notify the user's error handler since rhea guarantees that session_error\n        // will always be emitted before session_close.\n      }\n\n      if (receiver && !receiver.isSessionItselfClosed()) {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the receiver for sessionId '%s' \" +\n            \"and the sdk did not initiate this. Hence, let's gracefully close the receiver.\",\n          this.logPrefix,\n          this.sessionId,\n        );\n        try {\n          await this.close();\n        } catch (err: any) {\n          logger.logError(\n            err,\n            \"%s An error occurred while closing the receiver for sessionId '%s'\",\n            this.logPrefix,\n            this.sessionId,\n          );\n        }\n      } else {\n        logger.verbose(\n          \"%s 'session_close' event occurred on the receiver for sessionId'%s' \" +\n            \"because the sdk initiated it. Hence no need to gracefully close the receiver\",\n          this.logPrefix,\n          this.sessionId,\n        );\n      }\n    };\n  }\n\n  /**\n   * Closes the underlying AMQP receiver link.\n   */\n  async close(error?: Error | AmqpError): Promise<void> {\n    try {\n      this._isReceivingMessagesForSubscriber = false;\n      if (this._sessionLockRenewalTimer) clearTimeout(this._sessionLockRenewalTimer);\n      logger.verbose(\n        \"%s Cleared the timers for 'no new message received' task and \" +\n          \"'session lock renewal' task.\",\n        this.logPrefix,\n      );\n\n      await super.close();\n\n      this._batchingReceiverLite.terminate(error);\n    } catch (err: any) {\n      logger.logError(\n        err,\n        \"%s An error occurred while closing the message session with id '%s'\",\n        this.logPrefix,\n        this.sessionId,\n      );\n    }\n  }\n\n  /**\n   * Determines whether the AMQP receiver link is open. If open then returns true else returns false.\n   */\n  isOpen(): boolean {\n    const result: boolean = this.link! && this.link!.isOpen();\n    logger.verbose(\n      \"%s Receiver for sessionId '%s' is open? -> %s\",\n      this.logPrefix,\n      this.sessionId,\n      result,\n    );\n    return result;\n  }\n\n  /**\n   * Registers handlers to deal with the incoming stream of messages over an AMQP receiver link\n   * from a Queue/Subscription.\n   * To stop receiving messages, call `close()` on the SessionReceiver or set the property\n   * `newMessageWaitTimeoutInMs` in the options to provide a timeout.\n   *\n   * @param onMessage - Handler for processing each incoming message.\n   * @param onError - Handler for any error that occurs while receiving or processing messages.\n   * @param options - Options to control whether messages should be automatically completed. You can\n   * also provide a timeout in milliseconds to denote the amount of time to wait for a new message\n   * before closing the receiver.\n   */\n  public subscribe(onMessage: OnMessage, onError: OnError, options: SubscribeOptions): void {\n    this.receiverHelper.resume();\n    this._subscribeImpl(onMessage, onError, options);\n  }\n\n  private _subscribeImpl(onMessage: OnMessage, onError: OnError, options: SubscribeOptions): void {\n    if (!options) options = {};\n\n    if (options.abortSignal?.aborted) {\n      throw new AbortError(StandardAbortMessage);\n    }\n\n    this._isReceivingMessagesForSubscriber = true;\n    if (typeof options.maxConcurrentCalls === \"number\" && options.maxConcurrentCalls > 0) {\n      this.maxConcurrentCalls = options.maxConcurrentCalls;\n    }\n\n    // If explicitly set to false then autoComplete is false else true (default).\n    this.autoComplete =\n      options.autoCompleteMessages === false ? options.autoCompleteMessages : true;\n    this._onMessage = onMessage;\n    this._onError = onError;\n\n    if (this.link && this.link.isOpen()) {\n      const onSessionMessage = async (context: EventContext): Promise<void> => {\n        // If the receiver got closed in PeekLock mode, avoid processing the message as we\n        // cannot settle the message.\n        if (this.receiveMode === \"peekLock\" && (!this.link || !this.link.isOpen())) {\n          logger.verbose(\n            \"%s Not calling the user's message handler for the current message \" +\n              \"as the receiver is closed\",\n            this.logPrefix,\n          );\n          return;\n        }\n\n        const bMessage = new ServiceBusMessageImpl(\n          context.message!,\n          context.delivery!,\n          true,\n          this.receiveMode,\n          this.skipParsingBodyAsJson,\n          this.skipConvertingDate,\n        );\n\n        try {\n          await this._onMessage(bMessage);\n\n          if (\n            this.autoComplete &&\n            this.receiveMode === \"peekLock\" &&\n            !bMessage.delivery.remote_settled\n          ) {\n            try {\n              logger.verbose(\n                \"%s Auto completing the message with id '%s' on the receiver.\",\n                this.logPrefix,\n                bMessage.messageId,\n              );\n              await completeMessage(bMessage, this._context, this.entityPath, this._retryOptions);\n            } catch (completeError: any) {\n              const translatedError = translateServiceBusError(completeError);\n              logger.logError(\n                translatedError,\n                \"%s An error occurred while completing the message with id '%s' on the \" +\n                  \"receiver\",\n                this.logPrefix,\n                bMessage.messageId,\n              );\n              await this._notifyError({\n                error: translatedError,\n                errorSource: \"complete\",\n                entityPath: this.entityPath,\n                fullyQualifiedNamespace: this._context.config.host,\n                identifier: this.identifier,\n              });\n            }\n          }\n        } catch (err: any) {\n          logger.logError(\n            err,\n            \"%s An error occurred while running user's message handler for the message \" +\n              \"with id '%s' on the receiver\",\n            this.logPrefix,\n            bMessage.messageId,\n          );\n          await this._onError!({\n            error: err,\n            errorSource: \"processMessageCallback\",\n            entityPath: this.entityPath,\n            fullyQualifiedNamespace: this._context.config.host,\n            identifier: this.identifier,\n          });\n\n          const error = translateServiceBusError(err);\n          // Nothing much to do if user's message handler throws. Let us try abandoning the message.\n          if (\n            !bMessage.delivery.remote_settled &&\n            this.receiveMode === \"peekLock\" &&\n            this.isOpen() // only try to abandon the messages if the connection is still open\n          ) {\n            try {\n              logger.logError(\n                error,\n                \"%s Abandoning the message with id '%s' on the receiver since an error occured\",\n                this.logPrefix,\n                bMessage.messageId,\n              );\n              await abandonMessage(\n                bMessage,\n                this._context,\n                this.entityPath,\n                undefined,\n                this._retryOptions,\n              );\n            } catch (abandonError: any) {\n              const translatedError = translateServiceBusError(abandonError);\n              logger.logError(\n                translatedError,\n                \"%s An error occurred while abandoning the message with id '%s' on the \" +\n                  \"receiver\",\n                this.logPrefix,\n                bMessage.messageId,\n                translatedError,\n              );\n              await this._notifyError({\n                error: translatedError,\n                errorSource: \"abandon\",\n                entityPath: this.entityPath,\n                fullyQualifiedNamespace: this._context.config.host,\n                identifier: this.identifier,\n              });\n            }\n          }\n          return;\n        } finally {\n          try {\n            this.receiverHelper.addCredit(1);\n          } catch (err: any) {\n            // this isn't something we expect in normal operation - we'd only get here\n            // because of a bug in our code.\n            this.processCreditError(err);\n          }\n        }\n      };\n      // setting the \"message\" event listener.\n      this.link.on(ReceiverEvents.message, onSessionMessage);\n\n      try {\n        this.receiverHelper.addCredit(this.maxConcurrentCalls);\n      } catch (err: any) {\n        // this isn't something we expect in normal operation - we'd only get here\n        // because of a bug in our code.\n        this.processCreditError(err);\n      }\n    } else {\n      this._isReceivingMessagesForSubscriber = false;\n      const msg =\n        `MessageSession with sessionId '${this.sessionId}' and name '${this.name}' ` +\n        `has either not been created or is not open.`;\n      logger.verbose(\"[%s] %s\", this._context.connectionId, msg);\n      this._notifyError({\n        error: new Error(msg),\n        // This is _probably_ the right error code since we require that\n        // the message session is created before we even give back the receiver. So it not\n        // being open at this point is either:\n        //\n        // 1. we didn't acquire the lock\n        // 2. the connection was broken (we don't reconnect)\n        //\n        // If any of these becomes untrue you'll probably want to re-evaluate this classification.\n        errorSource: \"receive\",\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        identifier: this.identifier,\n      });\n    }\n  }\n\n  private async processCreditError(err: any): Promise<void> {\n    if (err.name === \"AbortError\") {\n      // if we fail to add credits because the user has asked us to stop\n      // then this isn't an error - it's normal.\n      return;\n    }\n\n    logger.logError(err, \"Cannot request messages on the receiver\");\n\n    const error = new ServiceBusError(\"Cannot request messages on the receiver\", \"SessionLockLost\");\n    error.retryable = false;\n\n    // from the user's perspective this is a fatal link error and they should retry\n    // opening the link.\n    await this._onError!({\n      error,\n      errorSource: \"processMessageCallback\",\n      entityPath: this.entityPath,\n      fullyQualifiedNamespace: this._context.config.host,\n      identifier: this.identifier,\n    });\n  }\n\n  /**\n   * Returns a batch of messages based on given count and timeout over an AMQP receiver link\n   * from a Queue/Subscription.\n   *\n   * @param maxMessageCount - The maximum number of messages to receive from Queue/Subscription.\n   * @param maxWaitTimeInMs - The total wait time in milliseconds until which the receiver will attempt to receive specified number of messages.\n   * If this time elapses before the `maxMessageCount` is reached, then messages collected till then will be returned to the user.\n   * @returns A promise that resolves with an array of Message objects.\n   */\n  async receiveMessages(\n    maxMessageCount: number,\n    maxWaitTimeInMs: number,\n    maxTimeAfterFirstMessageInMs: number,\n    options: OperationOptionsBase,\n  ): Promise<ServiceBusMessageImpl[]> {\n    try {\n      return await this._batchingReceiverLite.receiveMessages({\n        maxMessageCount,\n        maxWaitTimeInMs,\n        maxTimeAfterFirstMessageInMs,\n        ...options,\n      });\n    } catch (error: any) {\n      logger.logError(error, `${this.logPrefix} Rejecting receiveMessages() with error`);\n      throw error;\n    }\n  }\n\n  /**\n   * To be called when connection is disconnected to gracefully close ongoing receive request.\n   * @param connectionError - The connection error if any.\n   */\n  async onDetached(connectionError: AmqpError | Error): Promise<void> {\n    logger.error(\n      translateServiceBusError(connectionError),\n      `${this.logPrefix} onDetached: closing link (session receiver will not reconnect)`,\n    );\n    try {\n      // Notifying so that the streaming receiver knows about the error\n      await this._notifyError({\n        entityPath: this.entityPath,\n        fullyQualifiedNamespace: this._context.config.host,\n        error: translateServiceBusError(connectionError),\n        errorSource: \"receive\",\n        identifier: this.identifier,\n      });\n    } catch (error: any) {\n      logger.error(\n        translateServiceBusError(error),\n        `${\n          this.logPrefix\n        } onDetached: unexpected error seen when tried calling \"_notifyError\" with ${translateServiceBusError(\n          connectionError,\n        )}`,\n      );\n    }\n    await this.close(connectionError);\n  }\n\n  /**\n   * Settles the message with the specified disposition.\n   * @param message - The ServiceBus Message that needs to be settled.\n   * @param operation - The disposition type.\n   * @param options - Optional parameters that can be provided while disposing the message.\n   */\n  async settleMessage(\n    message: ServiceBusMessageImpl,\n    operation: DispositionType,\n    options: DispositionStatusOptions,\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      if (operation.match(/^(complete|abandon|defer|deadletter)$/) == null) {\n        return reject(new Error(`operation: '${operation}' is not a valid operation.`));\n      }\n      const delivery = message.delivery;\n      const timer = setTimeout(() => {\n        this._deliveryDispositionMap.delete(delivery.id);\n        logger.verbose(\n          \"[%s] Disposition for delivery id: %d, did not complete in %d milliseconds. \" +\n            \"Hence rejecting the promise with timeout error\",\n          this._context.connectionId,\n          delivery.id,\n          Constants.defaultOperationTimeoutInMs,\n        );\n\n        const e: AmqpError = {\n          condition: ErrorNameConditionMapper.ServiceUnavailableError,\n          description:\n            \"Operation to settle the message has timed out. The disposition of the \" +\n            \"message may or may not be successful\",\n        };\n        return reject(translateServiceBusError(e));\n      }, Constants.defaultOperationTimeoutInMs);\n      this._deliveryDispositionMap.set(delivery.id, {\n        resolve: resolve,\n        reject: reject,\n        timer: timer,\n      });\n      if (operation === DispositionType.complete) {\n        delivery.accept();\n      } else if (operation === DispositionType.abandon) {\n        const params: any = {\n          undeliverable_here: false,\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.defer) {\n        const params: any = {\n          undeliverable_here: true,\n        };\n        if (options.propertiesToModify) params.message_annotations = options.propertiesToModify;\n        delivery.modified(params);\n      } else if (operation === DispositionType.deadletter) {\n        const error: AmqpError = {\n          condition: Constants.deadLetterName,\n          info: {\n            ...options.propertiesToModify,\n            DeadLetterReason: options.deadLetterReason,\n            DeadLetterErrorDescription: options.deadLetterDescription,\n          },\n        };\n        delivery.reject(error);\n      }\n    });\n  }\n\n  /**\n   * Creates a new instance of the MessageSession based on the provided parameters.\n   * @param identifier - name to identify the message session\n   * @param context - The client entity context\n   * @param options - Options that can be provided while creating the MessageSession.\n   */\n  static async create(\n    identifier: string,\n    context: ConnectionContext,\n    entityPath: string,\n    sessionId: string | undefined,\n    options: MessageSessionOptions,\n  ): Promise<MessageSession> {\n    throwErrorIfConnectionClosed(context);\n    const messageSession = new MessageSession(identifier, context, entityPath, sessionId, options);\n    let timeoutInMs: number | undefined;\n    // Only passing client timeout in link properties for accepting next available\n    // session as this is the only long-polling scenario.\n    if (sessionId === undefined) {\n      timeoutInMs = options.retryOptions?.timeoutInMs ?? Constants.defaultOperationTimeoutInMs;\n      // The number of milliseconds to use as the basis for calculating a random jitter amount\n      // opening receiver links. This is intended to ensure that multiple\n      // session operations don't timeout at the same exact moment.\n      const openReceiveLinkBaseJitterInMs = 100;\n      // The amount of time to subtract from the client timeout when setting the server timeout when attempting to\n      // accept the next available session. This will decrease the likelihood that the client times out before receiving a\n      // response from the server.\n      const openReceiveLinkBufferInMs = 20;\n      // The amount minimum threshold for the server timeout for which we will subtract the \"openReceiveLinkBufferInMs\".\n      // If the server timeout is less than this, we will not subtract the additional buffer.\n      const openReceiveLinkBufferThresholdInMs = 1000;\n      // Subtract a random amount up to 100ms from the operation timeout as the jitter when attempting to open next available session link.\n      // This prevents excessive resource usage when using high amounts of concurrency and accepting the next available session.\n      // Take the min of 1% of the total timeout and the base jitter amount so that we don't end up subtracting more than 1% of the total timeout.\n      const jitterBaseInMs = Math.min(timeoutInMs * 0.01, openReceiveLinkBaseJitterInMs);\n      // We set the operation timeout on the properties not only to include the jitter, but also because the server will otherwise\n      // restrict the maximum timeout to 1 minute and 5 seconds, regardless of the client timeout. We only do this for accepting next available\n      // session as this is the only long-polling scenario.\n      timeoutInMs = Math.floor(timeoutInMs - jitterBaseInMs * Math.random());\n      // Subtract an additional constant buffer to reduce the likelihood that the client times out before the service which leads to unnecessary\n      // network traffic. If the timeout is too short, we won't do this.\n      if (timeoutInMs >= openReceiveLinkBufferThresholdInMs) {\n        timeoutInMs -= openReceiveLinkBufferInMs;\n      }\n    }\n\n    await messageSession._init({\n      abortSignal: options?.abortSignal,\n      timeoutInMs,\n    });\n    return messageSession;\n  }\n\n  protected removeLinkFromContext(): void {\n    delete this._context.messageSessions[this.name];\n  }\n}\n"]}