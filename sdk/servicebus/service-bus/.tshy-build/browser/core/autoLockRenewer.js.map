{"version":3,"file":"autoLockRenewer.js","sourceRoot":"","sources":["../../../src/core/autoLockRenewer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { ConnectionContext } from \"../connectionContext.js\";\nimport { receiverLogger as logger } from \"../log.js\";\nimport type { ServiceBusMessageImpl } from \"../serviceBusMessage.js\";\nimport { calculateRenewAfterDuration } from \"../util/utils.js\";\nimport type { LinkEntity } from \"./linkEntity.js\";\nimport type { OnErrorNoContext } from \"./messageReceiver.js\";\n\n/**\n * @internal\n */\nexport type RenewableMessageProperties = Readonly<\n  Pick<ServiceBusMessageImpl, \"lockToken\" | \"messageId\">\n> &\n  // updated when we renew the lock\n  Pick<ServiceBusMessageImpl, \"lockedUntilUtc\">;\n\n/**\n * @internal\n */\ntype MinimalLink = Pick<LinkEntity<any>, \"name\" | \"logPrefix\" | \"entityPath\">;\n\n/**\n * Tracks locks for messages, renewing until a configurable duration.\n *\n * @internal\n */\nexport class LockRenewer {\n  /**\n   * A map of link names to individual maps for each\n   * link that map a message ID to its auto-renewal timer.\n   */\n  private _messageRenewLockTimers = new Map<string, Map<string, NodeJS.Timeout | undefined>>();\n\n  // just here for make unit testing a bit easier.\n  private _calculateRenewAfterDuration: typeof calculateRenewAfterDuration;\n\n  constructor(\n    private _context: Pick<ConnectionContext, \"getManagementClient\">,\n    private _maxAutoRenewDurationInMs: number,\n  ) {\n    this._calculateRenewAfterDuration = calculateRenewAfterDuration;\n  }\n\n  /**\n   * Creates an AutoLockRenewer.\n   *\n   * @param linkEntity - Your link entity instance (probably 'this')\n   * @param context - The connection context for your link entity (probably 'this._context')\n   * @param options - The ReceiveOptions passed through to your message receiver.\n   * @returns if the lock mode is peek lock (or if is unspecified, thus defaulting to peekLock)\n   * and the options.maxAutoLockRenewalDurationInMs is greater than 0..Otherwise, returns undefined.\n   */\n  static create(\n    context: Pick<ConnectionContext, \"getManagementClient\">,\n    maxAutoRenewLockDurationInMs: number,\n    receiveMode: \"peekLock\" | \"receiveAndDelete\",\n  ): LockRenewer | undefined {\n    if (receiveMode !== \"peekLock\") {\n      return undefined;\n    }\n\n    if (maxAutoRenewLockDurationInMs <= 0) {\n      return undefined;\n    }\n\n    return new LockRenewer(context, maxAutoRenewLockDurationInMs);\n  }\n\n  /**\n   * Cancels all pending lock renewals for messages on given link and removes all entries from our internal cache.\n   */\n  stopAll(linkEntity: MinimalLink): void {\n    logger.verbose(\n      `${linkEntity.logPrefix} Clearing message renew lock timers for all the active messages.`,\n    );\n\n    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);\n\n    if (messagesForLink == null) {\n      return;\n    }\n\n    for (const messageId of messagesForLink.keys()) {\n      this._stopAndRemoveById(linkEntity, messagesForLink, messageId);\n    }\n\n    this._messageRenewLockTimers.delete(linkEntity.name);\n  }\n\n  /**\n   * Stops lock renewal for a single message.\n   *\n   * @param bMessage - The message whose lock renewal we will stop.\n   */\n  stop(linkEntity: MinimalLink, bMessage: RenewableMessageProperties): void {\n    const messageId = bMessage.messageId as string;\n\n    const messagesForLink = this._messageRenewLockTimers.get(linkEntity.name);\n\n    if (messagesForLink == null) {\n      return;\n    }\n\n    this._stopAndRemoveById(linkEntity, messagesForLink, messageId);\n  }\n\n  /**\n   * Starts lock renewal for a single message.\n   *\n   * @param bMessage - The message whose lock renewal we will start.\n   */\n  start(\n    linkEntity: MinimalLink,\n    bMessage: RenewableMessageProperties,\n    onError: OnErrorNoContext,\n  ): void {\n    try {\n      const logPrefix = linkEntity.logPrefix;\n\n      if (bMessage.lockToken == null) {\n        throw new Error(\n          `Can't start auto lock renewal for message with message id '${bMessage.messageId}' since it does not have a lock token.`,\n        );\n      }\n\n      const lockToken = bMessage.lockToken;\n      const linkMessageMap = this._getOrCreateMapForLink(linkEntity);\n      // - We need to renew locks before they expire by looking at bMessage.lockedUntilUtc.\n      // - This autorenewal needs to happen **NO MORE** than maxAutoRenewDurationInMs\n      // - We should be able to clear the renewal timer when the user's message handler\n      // is done (whether it succeeds or fails).\n      // Setting the messageId with undefined value in the linkMessageMap because we\n      // track state by checking the presence of messageId in the map. It is removed from the map\n      // when an attempt is made to settle the message (either by the user or by the sdk) OR\n      // when the execution of user's message handler completes.\n      linkMessageMap.set(bMessage.messageId as string, undefined);\n\n      logger.verbose(\n        `${logPrefix} message with id '${\n          bMessage.messageId\n        }' is locked until ${bMessage.lockedUntilUtc!.toString()}.`,\n      );\n      const totalAutoLockRenewDuration = Date.now() + this._maxAutoRenewDurationInMs;\n      const totalAutoLockRenewDurationDate = new Date(totalAutoLockRenewDuration);\n      logger.verbose(\n        `${logPrefix} Total autolockrenew duration for message with id '${\n          bMessage.messageId\n        }' is: ${totalAutoLockRenewDurationDate.toString()}`,\n      );\n\n      const autoRenewLockTask = (): void => {\n        const renewalNeededToMaintainLock =\n          // if the lock expires _after_ our max auto-renew duration there's no reason to\n          // spin up an auto-renewer - it's already held for the duration.\n          totalAutoLockRenewDurationDate > bMessage.lockedUntilUtc!;\n\n        if (!renewalNeededToMaintainLock) {\n          logger.verbose(\n            `${logPrefix} Autolockrenew not needed as message's lockedUntilUtc ${bMessage.lockedUntilUtc} is after the total autolockrenew duration ${totalAutoLockRenewDurationDate} for message with messageId '${bMessage.messageId}'. Hence we will stop the autoLockRenewTask.`,\n          );\n          this.stop(linkEntity, bMessage);\n        } else if (Date.now() >= totalAutoLockRenewDuration) {\n          // once we've exceeded the max amount of time we'll renew we can stop.\n          logger.verbose(\n            `${logPrefix} Current time ${new Date()} exceeds the total autolockrenew duration ${totalAutoLockRenewDurationDate} for message with messageId '${\n              bMessage.messageId\n            }'. Hence we will stop the autoLockRenewTask.`,\n          );\n          this.stop(linkEntity, bMessage);\n        } else {\n          if (linkMessageMap.has(bMessage.messageId as string)) {\n            // TODO: We can run into problems with clock skew between the client and the server.\n            // It would be better to calculate the duration based on the \"lockDuration\" property\n            // of the queue. However, we do not have the management plane of the client ready for\n            // now. Hence we rely on the lockedUntilUtc property on the message set by ServiceBus.\n            const amount = this._calculateRenewAfterDuration(bMessage.lockedUntilUtc!);\n\n            logger.verbose(\n              `${logPrefix} Sleeping for ${amount} milliseconds while renewing the lock for message with id '${bMessage.messageId}'`,\n            );\n            // Setting the value of the messageId to the actual timer. This will be cleared when\n            // an attempt is made to settle the message (either by the user or by the sdk) OR\n            // when the execution of user's message handler completes.\n            const autoRenewTimer = setTimeout(async () => {\n              try {\n                logger.verbose(\n                  `${logPrefix} Attempting to renew the lock for message with id '${bMessage.messageId}'.`,\n                );\n\n                bMessage.lockedUntilUtc = await this._context\n                  .getManagementClient(linkEntity.entityPath)\n                  .renewLock(lockToken, {\n                    associatedLinkName: linkEntity.name,\n                  });\n                logger.verbose(\n                  `${logPrefix} Successfully renewed the lock for message with id '${bMessage.messageId}'. Starting next auto-lock-renew cycle for message.`,\n                );\n\n                autoRenewLockTask();\n              } catch (err: any) {\n                logger.logError(\n                  err,\n                  `${logPrefix} An error occurred while auto renewing the message lock '${bMessage.lockToken}' for message with id '${bMessage.messageId}'`,\n                );\n                onError(err);\n              }\n            }, amount);\n\n            // Prevent the active Timer from keeping the Node.js event loop active.\n            if (typeof autoRenewTimer.unref === \"function\") {\n              autoRenewTimer.unref();\n            }\n\n            linkMessageMap.set(bMessage.messageId as string, autoRenewTimer);\n          } else {\n            logger.verbose(\n              `${logPrefix} Looks like the message lock renew timer has already been cleared for message with id '${bMessage.messageId}'.`,\n            );\n          }\n        }\n      };\n\n      // start\n      autoRenewLockTask();\n    } catch (err: any) {\n      onError(err);\n    }\n  }\n\n  private _getOrCreateMapForLink(linkEntity: MinimalLink): Map<string, NodeJS.Timeout | undefined> {\n    if (!this._messageRenewLockTimers.has(linkEntity.name)) {\n      this._messageRenewLockTimers.set(\n        linkEntity.name,\n        new Map<string, NodeJS.Timeout | undefined>(),\n      );\n    }\n\n    return this._messageRenewLockTimers.get(linkEntity.name)!;\n  }\n\n  private _stopAndRemoveById(\n    linkEntity: MinimalLink,\n    linkMessageMap: Map<string, NodeJS.Timeout | undefined>,\n    messageId: string | undefined,\n  ): void {\n    if (messageId == null) {\n      throw new Error(\"Failed to stop auto lock renewal - no message ID\");\n    }\n\n    // TODO: messageId doesn't actually need to be unique. Perhaps we should use lockToken\n    // instead?\n    if (linkMessageMap.has(messageId)) {\n      clearTimeout(linkMessageMap.get(messageId) as NodeJS.Timeout);\n      logger.verbose(\n        `${linkEntity.logPrefix} Cleared the message renew lock timer for message with id '${messageId}'.`,\n      );\n      linkMessageMap.delete(messageId);\n    }\n  }\n}\n"]}