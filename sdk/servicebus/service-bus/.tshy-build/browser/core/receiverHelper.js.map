{"version":3,"file":"receiverHelper.js","sourceRoot":"","sources":["../../../src/core/receiverHelper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport type { Receiver } from \"rhea-promise\";\nimport { ReceiverEvents } from \"rhea-promise\";\nimport { receiverLogger as logger } from \"../log.js\";\nimport { ServiceBusError } from \"../serviceBusError.js\";\nimport { receiveDrainTimeoutInMs } from \"../util/constants.js\";\n\n/**\n * Wraps the receiver with some higher level operations for managing state\n * like credits, draining, etc...\n *\n * @internal\n */\nexport class ReceiverHelper {\n  private _isSuspended: boolean = true;\n\n  constructor(\n    private _getCurrentReceiver: () => { receiver: Receiver | undefined; logPrefix: string },\n  ) {}\n\n  private _getCurrentReceiverOrError():\n    | \"is undefined\"\n    | \"is not open\"\n    | \"is suspended\"\n    | { receiver: Receiver | undefined; logPrefix: string } {\n    const currentReceiverData = this._getCurrentReceiver();\n\n    if (currentReceiverData.receiver == null) {\n      return \"is undefined\";\n    }\n\n    if (!currentReceiverData.receiver.isOpen()) {\n      return \"is not open\";\n    }\n\n    if (this._isSuspended) {\n      return \"is suspended\";\n    }\n\n    return currentReceiverData;\n  }\n\n  /**\n   * Adds credits to the receiver, respecting any state that\n   * indicates the receiver is closed or should not continue\n   * to receive more messages.\n   *\n   * @param credits - Number of credits to add.\n   * or `stopReceivingMessages` has been called.\n   */\n  addCredit(credits: number): void {\n    const currentReceiverOrError = this._getCurrentReceiverOrError();\n\n    if (typeof currentReceiverOrError === \"string\") {\n      const errorMessage = `Cannot request messages on the receiver since it ${currentReceiverOrError}.`;\n\n      if (currentReceiverOrError === \"is suspended\") {\n        // if a user has suspended the receiver we should consider this a non-retryable\n        // error since it absolutely requires user intervention.\n        throw new AbortError(errorMessage);\n      }\n\n      throw new ServiceBusError(errorMessage, \"GeneralError\");\n    }\n\n    if (currentReceiverOrError.receiver != null) {\n      logger.verbose(`${currentReceiverOrError.logPrefix} Adding ${credits} credits`);\n      currentReceiverOrError.receiver.addCredit(credits);\n    }\n  }\n\n  /**\n   * Drains the credits for the receiver and prevents the `receiverHelper.addCredit()` method from adding credits.\n   * Call `resume()` to enable the `addCredit()` method.\n   */\n  async suspend(): Promise<void> {\n    const { receiver, logPrefix } = this._getCurrentReceiver();\n\n    this._isSuspended = true;\n\n    if (!this._isValidReceiver(receiver)) {\n      return;\n    }\n\n    logger.verbose(\n      `${logPrefix} User has requested to stop receiving new messages, attempting to drain.`,\n    );\n\n    return this.drain();\n  }\n\n  /**\n   * Resets tracking so `addCredit` works again by toggling the `_isSuspended` flag.\n   */\n  resume(): void {\n    this._isSuspended = false;\n  }\n\n  isSuspended(): boolean {\n    return this._isSuspended;\n  }\n\n  /**\n   * Initiates a drain for the current receiver and resolves when\n   * the drain has completed.\n   *\n   * NOTE: This method returns immediately if the receiver is not valid or if there\n   * are no pending credits on the receiver (ie: `receiver.credit === 0`).\n   */\n  async drain(): Promise<void> {\n    const { receiver, logPrefix } = this._getCurrentReceiver();\n\n    if (!this._isValidReceiver(receiver)) {\n      // TODO: should we throw?\n      return;\n    }\n\n    if (receiver.credit === 0) {\n      // nothing to drain\n      return;\n    }\n\n    logger.verbose(\n      `${logPrefix} Receiver is starting drain. Remaining credits; ${receiver.credit}`,\n    );\n\n    const drainPromise = new Promise<void>((resolve) => {\n      const timer = setTimeout(async () => {\n        logger.warning(`${logPrefix} Time out when draining credits in suspend().`);\n        // Close the receiver link since we have not received the receiver_drained event\n        // to prevent out-of-sync link state between local and remote\n        await receiver?.close();\n        resolve();\n      }, receiveDrainTimeoutInMs);\n      receiver.once(ReceiverEvents.receiverDrained, () => {\n        logger.verbose(`${logPrefix} Receiver has been drained.`);\n        receiver.drain = false;\n        clearTimeout(timer);\n        resolve();\n      });\n      receiver.drainCredit();\n    });\n\n    return drainPromise;\n  }\n\n  private _isValidReceiver(receiver: Receiver | undefined): receiver is Receiver {\n    return receiver != null && receiver.isOpen();\n  }\n}\n"]}