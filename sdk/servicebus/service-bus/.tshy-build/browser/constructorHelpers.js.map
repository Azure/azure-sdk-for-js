{"version":3,"file":"constructorHelpers.js","sourceRoot":"","sources":["../../src/constructorHelpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { RetryOptions, SasTokenProvider, WebSocketOptions } from \"@azure/core-amqp\";\nimport { ConnectionConfig, createSasTokenProvider } from \"@azure/core-amqp\";\nimport type { NamedKeyCredential, SASCredential, TokenCredential } from \"@azure/core-auth\";\nimport { isNamedKeyCredential, isSASCredential } from \"@azure/core-auth\";\nimport { ConnectionContext } from \"./connectionContext.js\";\nimport type { UserAgentPolicyOptions } from \"@azure/core-rest-pipeline\";\nimport type { ServiceBusConnectionStringProperties } from \"./util/connectionStringUtils.js\";\nimport { parseServiceBusConnectionString } from \"./util/connectionStringUtils.js\";\n\n/**\n * Describes the options that can be provided while creating the ServiceBusClient.\n *\n * - `webSocketOptions` : Options to configure the channelling of the AMQP connection over Web Sockets.\n *    - `websocket`     : The WebSocket constructor used to create an AMQP connection if you choose to make the connection\n * over a WebSocket.\n *    - `webSocketConstructorOptions` : Options to pass to the Websocket constructor when you choose to make the connection\n * over a WebSocket.\n * - `retryOptions`     : The retry options for all the operations on the client.\n *    - `maxRetries` : The number of times the operation can be retried in case of a retryable error.\n *    - `maxRetryDelayInMs`: The maximum delay between retries. Applicable only when performing exponential retries.\n *    - `mode`: Which retry mode to apply, specified by the `RetryMode` enum. Options are `Exponential` and `Fixed`. Defaults to `Fixed`.\n *    - `retryDelayInMs`: Amount of time to wait in milliseconds before making the next attempt. When `mode` is set to `Exponential`,\n *       this is used to compute the exponentially increasing delays between retries. Default: 30000 milliseconds.\n *    - `timeoutInMs`: Amount of time in milliseconds to wait before the operation times out. This will trigger a retry if there are any\n *       retry attempts remaining. Minimum value: 60000 milliseconds.\n */\nexport interface ServiceBusClientOptions {\n  /**\n   * ID to identify this client. This can be used to correlate logs and exceptions.\n   */\n  identifier?: string;\n  /**\n   * A custom endpoint to use when connecting to the Service Bus service.\n   * This can be useful when your network does not allow connecting to the\n   * standard Azure Service Bus endpoint address, but does allow connecting\n   * through an intermediary.\n   *\n   * Example: \"https://my.custom.endpoint:100/\"\n   */\n  customEndpointAddress?: string;\n  /**\n   * Retry policy options that determine the mode, number of retries, retry interval etc.\n   */\n  retryOptions?: RetryOptions;\n  /**\n   * Options to configure the channelling of the AMQP connection over Web Sockets.\n   */\n  webSocketOptions?: WebSocketOptions;\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentPolicyOptions;\n}\n\n// TODO: extract parseEndpoint and setCustomEndpointAddress into core-amqp\n// ConnectionConfig so that it can be shared between Event Hubs and Service Bus\n/**\n * Parses the host, hostname, and port from an endpoint.\n * @param endpoint - And endpoint to parse.\n * @internal\n */\nexport function parseEndpoint(endpoint: string): { host: string; hostname: string; port?: string } {\n  const hostMatch = endpoint.match(/.*:\\/\\/([^/]*)/);\n  if (!hostMatch) {\n    throw new TypeError(`Invalid endpoint missing host: ${endpoint}`);\n  }\n\n  const [, host] = hostMatch;\n  const [hostname, port] = host.split(\":\");\n\n  return { host, hostname, port };\n}\n/**\n * Updates the provided ConnectionConfig to use the custom endpoint address.\n * @param config - An existing connection configuration to be updated.\n * @param customEndpointAddress - The custom endpoint address to use.\n */\nfunction setCustomEndpointAddress(config: ConnectionConfig, customEndpointAddress: string): void {\n  // The amqpHostname should match the host prior to using the custom endpoint.\n  config.amqpHostname = config.host;\n  const { hostname, port } = parseEndpoint(customEndpointAddress);\n  // Since we specify the port separately, set host to the customEndpointAddress hostname.\n  config.host = hostname;\n  if (port) {\n    config.port = parseInt(port, 10);\n  }\n}\n\n/**\n * @internal\n *\n */\nexport function createConnectionContext(\n  connectionString: string,\n  credential: SasTokenProvider | TokenCredential,\n  options: ServiceBusClientOptions,\n): ConnectionContext {\n  const config = ConnectionConfig.create(connectionString);\n\n  config.webSocket = options?.webSocketOptions?.webSocket;\n  config.webSocketEndpointPath = \"$servicebus/websocket\";\n  config.webSocketConstructorOptions = options?.webSocketOptions?.webSocketConstructorOptions;\n\n  if (options?.customEndpointAddress) {\n    setCustomEndpointAddress(config, options.customEndpointAddress);\n  }\n\n  return ConnectionContext.create(config, credential, options);\n}\n\n/**\n * @internal\n */\nexport function createConnectionContextForConnectionString(\n  connectionString: string,\n  options: ServiceBusClientOptions = {},\n): ConnectionContext {\n  const parsed = parseServiceBusConnectionString(connectionString) as Required<\n    | Pick<ServiceBusConnectionStringProperties, \"sharedAccessKey\" | \"sharedAccessKeyName\">\n    | Pick<ServiceBusConnectionStringProperties, \"sharedAccessSignature\">\n  >;\n  const sasTokenProvider = createSasTokenProvider(parsed);\n  return createConnectionContext(connectionString, sasTokenProvider, options);\n}\n\n/**\n *\n * @internal\n */\nexport function createConnectionContextForCredential(\n  credential: TokenCredential | NamedKeyCredential | SASCredential,\n  host: string,\n  options: ServiceBusClientOptions = {},\n): ConnectionContext {\n  if (typeof host !== \"string\") {\n    throw new TypeError(\"`host` parameter is not a string\");\n  }\n\n  let tokenProvider: TokenCredential | SasTokenProvider;\n\n  // host, credential and options based constructor was invoked\n  if (!host.endsWith(\"/\")) {\n    host += \"/\";\n  }\n  if (isNamedKeyCredential(credential) || isSASCredential(credential)) {\n    tokenProvider = createSasTokenProvider(credential);\n  } else {\n    tokenProvider = credential;\n  }\n  const connectionString = `Endpoint=sb://${host};SharedAccessKeyName=defaultKeyName;SharedAccessKey=defaultKeyValue;`;\n  return createConnectionContext(connectionString, tokenProvider, options);\n}\n\n/**\n * Parses a connection string and extracts the EntityPath named entity out.\n * @param connectionString - An entity specific Service Bus connection string.\n * @internal\n */\nexport function getEntityNameFromConnectionString(connectionString: string): string {\n  const entityPathMatch = connectionString.match(/^.+EntityPath=(.+?);{0,1}$/);\n\n  if (entityPathMatch != null && entityPathMatch.length === 2) {\n    return entityPathMatch[1];\n  } else {\n    throw new Error(\"No entity name present in the connection string\");\n  }\n}\n"]}