## API Report File for "@azure/service-bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { AmqpMessage } from '@azure/core-amqp';
import { delay } from '@azure/core-amqp';
import { Delivery } from 'rhea-promise';
import Long from 'long';
import { MessagingError } from '@azure/core-amqp';
import { RetryOptions } from '@azure/core-amqp';
import { SpanOptions } from '@opentelemetry/types';
import { TokenCredential } from '@azure/core-amqp';
import { TokenType } from '@azure/core-amqp';
import { WebSocketImpl } from 'rhea-promise';
import { WebSocketOptions } from '@azure/core-amqp';

// @public
export interface CorrelationFilter {
    contentType?: string;
    correlationId?: string;
    label?: string;
    messageId?: string;
    replyTo?: string;
    replyToSessionId?: string;
    sessionId?: string;
    to?: string;
    userProperties?: any;
}

// @public
export interface CreateBatchOptions extends OperationOptions {
    maxSizeInBytes?: number;
}

// @public
export interface DeadLetterOptions {
    deadLetterErrorDescription: string;
    deadLetterReason: string;
}

export { delay }

export { Delivery }

// @public
export interface GetMessageIteratorOptions extends OperationOptions, WaitTimeOptions {
}

// @public
export interface GetReceiverOptions {
    retryOptions?: RetryOptions;
}

// @public
export interface GetSenderOptions {
    retryOptions?: RetryOptions;
}

// @public
export interface GetSessionReceiverOptions extends SessionReceiverOptions, OperationOptions {
}

// @public
export interface GetSubscriptionRuleManagerOptions {
    retryOptions?: RetryOptions;
}

// @public
export interface MessageHandlerOptions {
    autoComplete?: boolean;
    maxConcurrentCalls?: number;
    maxMessageAutoRenewLockDurationInSeconds?: number;
}

// @public
export interface MessageHandlers<ReceivedMessageT> {
    processError(err: Error): Promise<void>;
    processMessage(message: ReceivedMessageT): Promise<void>;
}

export { MessagingError }

// @public
export interface OperationOptions extends TracingOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface ReceiveBatchOptions extends OperationOptions, WaitTimeOptions {
}

// @public
export interface ReceivedMessage extends ServiceBusMessage {
    readonly _amqpMessage: AmqpMessage;
    readonly deadLetterSource?: string;
    readonly deliveryCount?: number;
    readonly enqueuedSequenceNumber?: number;
    readonly enqueuedTimeUtc?: Date;
    readonly expiresAtUtc?: Date;
    lockedUntilUtc?: Date;
    readonly lockToken?: string;
    readonly sequenceNumber?: Long;
}

// @public
export interface ReceivedMessageWithLock extends ReceivedMessage {
    abandon(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    complete(): Promise<void>;
    deadLetter(options?: DeadLetterOptions & {
        [key: string]: any;
    }): Promise<void>;
    defer(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    renewLock(): Promise<Date>;
}

// @public
export interface Receiver<ReceivedMessageT> {
    close(): Promise<void>;
    diagnostics: {
        peek(maxMessageCount?: number): Promise<ReceivedMessage[]>;
        peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessage[]>;
    };
    entityPath: string;
    getMessageIterator(options?: GetMessageIteratorOptions): AsyncIterableIterator<ReceivedMessageT>;
    isReceivingMessages(): boolean;
    receiveBatch(maxMessages: number, options?: ReceiveBatchOptions): Promise<ReceivedMessageT[]>;
    receiveDeferredMessage(sequenceNumber: Long, options?: OperationOptions): Promise<ReceivedMessageT | undefined>;
    receiveDeferredMessages(sequenceNumbers: Long[], options?: OperationOptions): Promise<ReceivedMessageT[]>;
    receiveMode: "peekLock" | "receiveAndDelete";
    subscribe(handlers: MessageHandlers<ReceivedMessageT>, options?: SubscribeOptions): void;
}

export { RetryOptions }

// @public
export interface RuleDescription {
    action?: string;
    filter?: string | CorrelationFilter;
    name: string;
}

// @public
export interface Sender {
    cancelScheduledMessage(sequenceNumber: Long, options?: OperationOptions): Promise<void>;
    cancelScheduledMessages(sequenceNumbers: Long[], options?: OperationOptions): Promise<void>;
    close(): Promise<void>;
    createBatch(options?: CreateBatchOptions): Promise<ServiceBusMessageBatch>;
    isClosed: boolean;
    scheduleMessage(scheduledEnqueueTimeUtc: Date, message: ServiceBusMessage, options?: OperationOptions): Promise<Long>;
    scheduleMessages(scheduledEnqueueTimeUtc: Date, messages: ServiceBusMessage[], options?: OperationOptions): Promise<Long[]>;
    send(message: ServiceBusMessage): Promise<void>;
    sendBatch(messageBatch: ServiceBusMessageBatch): Promise<void>;
}

// @public
export class ServiceBusClient {
    constructor(connectionString: string, options?: ServiceBusClientOptions);
    constructor(fullyQualifiedNamespace: string, credential: TokenCredential, options?: ServiceBusClientOptions);
    close(): Promise<void>;
    getDeadLetterReceiver(queueName: string, receiveMode: "peekLock", options?: GetReceiverOptions): Receiver<ReceivedMessageWithLock>;
    getDeadLetterReceiver(queueName: string, receiveMode: "receiveAndDelete", options?: GetReceiverOptions): Receiver<ReceivedMessage>;
    getDeadLetterReceiver(topicName: string, subscriptionName: string, receiveMode: "peekLock", options?: GetReceiverOptions): Receiver<ReceivedMessageWithLock>;
    getDeadLetterReceiver(topicName: string, subscriptionName: string, receiveMode: "receiveAndDelete", options?: GetReceiverOptions): Receiver<ReceivedMessage>;
    getReceiver(queueName: string, receiveMode: "peekLock", options?: GetReceiverOptions): Receiver<ReceivedMessageWithLock>;
    getReceiver(queueName: string, receiveMode: "receiveAndDelete", options?: GetReceiverOptions): Receiver<ReceivedMessage>;
    getReceiver(topicName: string, subscriptionName: string, receiveMode: "peekLock", options?: GetReceiverOptions): Receiver<ReceivedMessageWithLock>;
    getReceiver(topicName: string, subscriptionName: string, receiveMode: "receiveAndDelete", options?: GetReceiverOptions): Receiver<ReceivedMessage>;
    getSender(queueOrTopicName: string, options?: GetSenderOptions): Sender;
    getSessionReceiver(queueName: string, receiveMode: "peekLock", options?: GetSessionReceiverOptions): SessionReceiver<ReceivedMessageWithLock>;
    getSessionReceiver(queueName: string, receiveMode: "receiveAndDelete", options?: GetSessionReceiverOptions): SessionReceiver<ReceivedMessage>;
    getSessionReceiver(topicName: string, subscriptionName: string, receiveMode: "peekLock", options?: GetSessionReceiverOptions): SessionReceiver<ReceivedMessageWithLock>;
    getSessionReceiver(topicName: string, subscriptionName: string, receiveMode: "receiveAndDelete", options?: GetSessionReceiverOptions): SessionReceiver<ReceivedMessage>;
    getSubscriptionRuleManager(topic: string, subscription: string, options?: GetSubscriptionRuleManagerOptions): SubscriptionRuleManager;
}

// @public
export interface ServiceBusClientOptions {
    retryOptions?: RetryOptions;
    webSocketOptions?: WebSocketOptions;
}

// @public
export interface ServiceBusMessage {
    body: any;
    contentType?: string;
    correlationId?: string | number | Buffer;
    label?: string;
    messageId?: string | number | Buffer;
    partitionKey?: string;
    replyTo?: string;
    replyToSessionId?: string;
    scheduledEnqueueTimeUtc?: Date;
    sessionId?: string;
    timeToLive?: number;
    to?: string;
    userProperties?: {
        [key: string]: any;
    };
    viaPartitionKey?: string;
}

// @public
export interface ServiceBusMessageBatch {
    readonly count: number;
    readonly maxSizeInBytes: number;
    readonly sizeInBytes: number;
    tryAdd(message: ServiceBusMessage): boolean;
}

// @public
export interface SessionMessageHandlerOptions {
    autoComplete?: boolean;
    maxConcurrentCalls?: number;
}

// @public
export interface SessionReceiver<ReceivedMessageT extends ReceivedMessage | ReceivedMessageWithLock> extends Receiver<ReceivedMessageT> {
    diagnostics: {
        peek(maxMessageCount?: number): Promise<ReceivedMessage[]>;
        peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessage[]>;
    };
    getState(options?: OperationOptions): Promise<any>;
    renewSessionLock(options?: OperationOptions): Promise<Date>;
    sessionId: string | undefined;
    sessionLockedUntilUtc: Date | undefined;
    setState(state: any, options?: OperationOptions): Promise<void>;
}

// @public
export interface SessionReceiverOptions {
    maxSessionAutoRenewLockDurationInSeconds?: number;
    retryOptions?: RetryOptions;
    sessionId: string | undefined;
}

// @public
export interface SubscribeOptions extends OperationOptions, MessageHandlerOptions {
}

// @public
export interface SubscriptionRuleManager {
    addRule(ruleName: string, filter: boolean | string | CorrelationFilter, sqlRuleActionExpression?: string, options?: OperationOptions): Promise<void>;
    close(): Promise<void>;
    readonly defaultRuleName: string;
    getRules(options?: OperationOptions): Promise<RuleDescription[]>;
    removeRule(ruleName: string, options?: OperationOptions): Promise<void>;
}

export { TokenCredential }

export { TokenType }

// @public
export interface TracingOptions {
    tracingOptions?: {
        spanOptions?: SpanOptions;
    };
}

// @public
export interface WaitTimeOptions {
    maxWaitTimeInMs: number;
}

export { WebSocketImpl }

export { WebSocketOptions }


// (No @packageDocumentation comment for this package)

```
