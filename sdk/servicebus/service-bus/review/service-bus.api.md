## API Report File for "@azure/service-bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { AmqpMessage } from "@azure/core-amqp";
import { DataTransformer } from "@azure/core-amqp";
import { delay } from "@azure/core-amqp";
import { Delivery } from "rhea-promise";
import { HttpOperationResponse } from "@azure/core-http";
import Long from "long";
import { MessagingError } from "@azure/core-amqp";
import { OperationOptions } from "@azure/core-auth";
import { RetryOptions } from "@azure/core-amqp";
import { TokenCredential } from "@azure/core-amqp";
import { TokenType } from "@azure/core-amqp";
import { WebSocketImpl } from "rhea-promise";
import { WebSocketOptions } from "@azure/core-amqp";

// @public
export type AuthorizationRule = {
  claimType: string;
  claimValue: string;
  rights: {
    accessRights?: string[];
  };
  keyName: string;
  primaryKey?: string;
  secondaryKey?: string;
};

// @public
export interface CorrelationFilter {
  contentType?: string;
  correlationId?: string;
  label?: string;
  messageId?: string;
  replyTo?: string;
  replyToSessionId?: string;
  sessionId?: string;
  to?: string;
  userProperties?: any;
}

// @public
export interface CreateBatchOptions {
  maxSizeInBytes?: number;
}

export { DataTransformer };

// @public
export interface DeadLetterOptions {
  deadLetterErrorDescription: string;
  deadletterReason: string;
}

export { delay };

export { Delivery };

// @public
export type EntityStatus =
  | "Active"
  | "Creating"
  | "Deleting"
  | "ReceiveDisabled"
  | "SendDisabled"
  | "Disabled"
  | "Renaming"
  | "Restoring"
  | "Unknown";

// @public
export interface GetMessageIteratorOptions extends OperationOptions, WaitTimeOptions {}

// @public
export interface GetSessionReceiverOptions extends OperationOptions {
  maxSessionAutoRenewLockDurationInSeconds?: number;
  sessionId?: string;
}

export { HttpOperationResponse };

// @public
export type MessageCountDetails = {
  activeMessageCount: number;
  deadLetterMessageCount: number;
  scheduledMessageCount: number;
  transferMessageCount: number;
  transferDeadLetterMessageCount: number;
};

// @public
export interface MessageHandlerOptions {
  autoComplete?: boolean;
  maxConcurrentCalls?: number;
  maxMessageAutoRenewLockDurationInSeconds?: number;
}

// @public
export interface MessageHandlers<ReceivedMessageT> {
  processError(err: Error): Promise<void>;
  processMessage(message: ReceivedMessageT): Promise<void>;
}

export { MessagingError };

// @public
export interface QueueDetails {
  accessedOn?: string;
  authorizationRules?: AuthorizationRule[];
  autoDeleteOnIdle: string;
  createdOn?: string;
  deadLetteringOnMessageExpiration: boolean;
  defaultMessageTtl: string;
  duplicateDetectionHistoryTimeWindow: string;
  enableBatchedOperations: boolean;
  enableExpress?: boolean;
  enablePartitioning: boolean;
  entityAvailabilityStatus?: string;
  forwardDeadLetteredMessagesTo?: string;
  forwardTo?: string;
  isAnonymousAccessible?: boolean;
  lockDuration: string;
  maxDeliveryCount: number;
  maxSizeInMegabytes: number;
  messageCount?: number;
  messageCountDetails?: MessageCountDetails;
  queueName: string;
  requiresDuplicateDetection: boolean;
  requiresSession: boolean;
  sizeInBytes?: number;
  status?: EntityStatus;
  supportOrdering?: boolean;
  updatedOn?: string;
  userMetadata?: string;
}

// @public
export interface QueueOptions {
  authorizationRules?: AuthorizationRule[];
  autoDeleteOnIdle?: string;
  deadLetteringOnMessageExpiration?: boolean;
  defaultMessageTtl?: string;
  duplicateDetectionHistoryTimeWindow?: string;
  enableBatchedOperations?: boolean;
  enablePartitioning?: boolean;
  forwardDeadLetteredMessagesTo?: string;
  forwardTo?: string;
  lockDuration?: string;
  maxDeliveryCount?: number;
  maxSizeInMegabytes?: number;
  requiresDuplicateDetection?: boolean;
  requiresSession?: boolean;
  status?: EntityStatus;
  userMetadata?: string;
}

// @public
export interface ReceiveBatchOptions extends OperationOptions, WaitTimeOptions {}

// @public
export interface ReceivedMessage extends ServiceBusMessage {
  readonly _amqpMessage: AmqpMessage;
  readonly deadLetterSource?: string;
  readonly deliveryCount?: number;
  readonly enqueuedSequenceNumber?: number;
  readonly enqueuedTimeUtc?: Date;
  readonly expiresAtUtc?: Date;
  lockedUntilUtc?: Date;
  readonly lockToken?: string;
  readonly sequenceNumber?: Long;
}

// @public
export interface ReceivedMessageWithLock extends ReceivedMessage {
  abandon(propertiesToModify?: { [key: string]: any }): Promise<void>;
  complete(): Promise<void>;
  deadLetter(options?: DeadLetterOptions): Promise<void>;
  defer(propertiesToModify?: { [key: string]: any }): Promise<void>;
  renewLock(): Promise<Date>;
}

// @public
export enum ReceiveMode {
  peekLock = 1,
  receiveAndDelete = 2
}

// @public
export interface Receiver<ReceivedMessageT> {
  close(): Promise<void>;
  diagnostics: {
    peek(maxMessageCount?: number): Promise<ReceivedMessage[]>;
    peekBySequenceNumber(
      fromSequenceNumber: Long,
      maxMessageCount?: number
    ): Promise<ReceivedMessage[]>;
  };
  entityPath: string;
  entityType: "queue" | "subscription";
  getDeadLetterPath(): string;
  getMessageIterator(options?: GetMessageIteratorOptions): AsyncIterableIterator<ReceivedMessageT>;
  isReceivingMessages(): boolean;
  receiveBatch(maxMessages: number, options?: ReceiveBatchOptions): Promise<ReceivedMessageT[]>;
  receiveDeferredMessage(
    sequenceNumber: Long,
    options?: OperationOptions
  ): Promise<ReceivedMessageT | undefined>;
  receiveDeferredMessages(
    sequenceNumbers: Long[],
    options?: OperationOptions
  ): Promise<ReceivedMessageT[]>;
  receiveMode: "peekLock" | "receiveAndDelete";
  subscribe(handlers: MessageHandlers<ReceivedMessageT>, options?: SubscribeOptions): void;
}

export { RetryOptions };

// @public
export interface RuleDescription {
  action?: string;
  filter?: string | CorrelationFilter;
  name: string;
}

// @public
export interface RuleDetails {
  action?: SqlAction;
  createdOn: string;
  filter?: SqlFilter | CorrelationFilter;
  ruleName: string;
  subscriptionName: string;
  topicName: string;
}

// @public
export interface RuleOptions {
  action?: SqlAction;
  filter?: SqlFilter | CorrelationFilter;
}

// @public
export interface SendableMessageInfo {
  body: any;
  contentType?: string;
  correlationId?: string | number | Buffer;
  label?: string;
  messageId?: string | number | Buffer;
  partitionKey?: string;
  replyTo?: string;
  replyToSessionId?: string;
  scheduledEnqueueTimeUtc?: Date;
  sessionId?: string;
  timeToLive?: number;
  to?: string;
  userProperties?: {
    [key: string]: any;
  };
  viaPartitionKey?: string;
}

// @public (undocumented)
export interface SendableMessageInfoBatch {
  readonly count: number;
  readonly maxSizeInBytes: number;
  readonly sizeInBytes: number;
  tryAdd(message: SendableMessageInfo): boolean;
}

// @public
export interface Sender {
  cancelScheduledMessage(sequenceNumber: Long): Promise<void>;
  cancelScheduledMessages(sequenceNumbers: Long[]): Promise<void>;
  close(): Promise<void>;
  createBatch(options?: CreateBatchOptions): Promise<SendableMessageInfoBatch>;
  isClosed: boolean;
  scheduleMessage(scheduledEnqueueTimeUtc: Date, message: SendableMessageInfo): Promise<Long>;
  scheduleMessages(scheduledEnqueueTimeUtc: Date, messages: SendableMessageInfo[]): Promise<Long[]>;
  send(message: SendableMessageInfo): Promise<void>;
  sendBatch(messages: SendableMessageInfo[]): Promise<void>;
  sendBatch2(messageBatch: SendableMessageInfoBatch): Promise<void>;
}

// @public
export class ServiceBusClient {
  constructor(connectionString: string, options?: ServiceBusClientOptions);
  constructor(
    hostName: string,
    tokenCredential: TokenCredential,
    options?: ServiceBusClientOptions
  );
  close(): Promise<void>;
  getReceiver(queueName: string, receiveMode: "peekLock"): Receiver<ReceivedMessageWithLock>;
  getReceiver(queueName: string, receiveMode: "receiveAndDelete"): Receiver<ReceivedMessage>;
  getReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "peekLock"
  ): Receiver<ReceivedMessageWithLock> & SubscriptionRuleManagement;
  getReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "receiveAndDelete"
  ): Receiver<ReceivedMessage> & SubscriptionRuleManagement;
  getSender(queueOrTopicName: string): Sender;
  getSessionReceiver(
    queueName: string,
    receiveMode: "peekLock",
    options?: GetSessionReceiverOptions
  ): SessionReceiver<ReceivedMessageWithLock>;
  getSessionReceiver(
    queueName: string,
    receiveMode: "receiveAndDelete",
    options?: GetSessionReceiverOptions
  ): SessionReceiver<ReceivedMessage>;
  getSessionReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "peekLock",
    options?: GetSessionReceiverOptions
  ): SessionReceiver<ReceivedMessageWithLock> & SubscriptionRuleManagement;
  getSessionReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "receiveAndDelete",
    options?: GetSessionReceiverOptions
  ): SessionReceiver<ReceivedMessage> & SubscriptionRuleManagement;
}

// @public
export interface ServiceBusClientOptions {
  dataTransformer?: DataTransformer;
  webSocketOptions?: WebSocketOptions;
}

// @public
export interface ServiceBusMessage {
  body: any;
  contentType?: string;
  correlationId?: string | number | Buffer;
  label?: string;
  messageId?: string | number | Buffer;
  partitionKey?: string;
  replyTo?: string;
  replyToSessionId?: string;
  scheduledEnqueueTimeUtc?: Date;
  sessionId?: string;
  timeToLive?: number;
  to?: string;
  userProperties?: {
    [key: string]: any;
  };
  viaPartitionKey?: string;
}

// @public
export interface SessionMessageHandlerOptions {
  autoComplete?: boolean;
  maxConcurrentCalls?: number;
}

// @public
export interface SessionReceiver<
  ReceivedMessageT extends ReceivedMessage | ReceivedMessageWithLock
> extends Receiver<ReceivedMessageT> {
  diagnostics: {
    peek(maxMessageCount?: number): Promise<ReceivedMessage[]>;
    peekBySequenceNumber(
      fromSequenceNumber: Long,
      maxMessageCount?: number
    ): Promise<ReceivedMessage[]>;
  };
  getState(): Promise<any>;
  renewSessionLock(): Promise<Date>;
  sessionId: string | undefined;
  sessionLockedUntilUtc: Date | undefined;
  setState(state: any): Promise<void>;
}

// @public
export interface SessionReceiverOptions {
  maxSessionAutoRenewLockDurationInSeconds?: number;
  sessionId: string | undefined;
}

// @public
export type SqlAction = SqlFilter;

// @public
export interface SqlFilter {
  compatibilityLevel?: number;
  requiresPreprocessing?: boolean;
  sqlExpression?: string;
  sqlParameters?: SqlParameter[];
}

// @public
export type SqlParameter = {
  key: string;
  value: string | number;
  type: string;
};

// @public
export interface SubscribeOptions extends OperationOptions, MessageHandlerOptions {}

// @public
export interface SubscriptionDetails {
  accessedOn?: string;
  autoDeleteOnIdle: string;
  createdOn: string;
  deadLetteringOnFilterEvaluationExceptions: boolean;
  deadLetteringOnMessageExpiration: boolean;
  defaultMessageTtl?: string;
  defaultRuleDescription?: any;
  enableBatchedOperations: boolean;
  enablePartitioning?: boolean;
  entityAvailabilityStatus: string;
  forwardDeadLetteredMessagesTo?: string;
  forwardTo?: string;
  lockDuration: string;
  maxDeliveryCount: number;
  maxSizeInMegabytes?: number;
  messageCount: number;
  messageCountDetails?: MessageCountDetails;
  requiresSession: boolean;
  sizeInBytes?: number;
  status?: EntityStatus;
  subscriptionName: string;
  topicName: string;
  updatedOn: string;
  userMetadata?: string;
}

// @public
export interface SubscriptionOptions {
  autoDeleteOnIdle?: string;
  deadLetteringOnFilterEvaluationExceptions?: boolean;
  deadLetteringOnMessageExpiration?: boolean;
  defaultMessageTtl?: string;
  enableBatchedOperations?: boolean;
  forwardDeadLetteredMessagesTo?: string;
  forwardTo?: string;
  lockDuration?: string;
  maxDeliveryCount?: number;
  requiresSession?: boolean;
  status?: EntityStatus;
  userMetadata?: string;
}

// @public
export interface SubscriptionRuleManagement {
  addRule(
    ruleName: string,
    filter: boolean | string | CorrelationFilter,
    sqlRuleActionExpression?: string
  ): Promise<void>;
  readonly defaultRuleName: string;
  getRules(): Promise<RuleDescription[]>;
  removeRule(ruleName: string): Promise<void>;
}

export { TokenCredential };

export { TokenType };

// @public
export interface TopicDetails {
  accessedOn?: string;
  authorizationRules?: AuthorizationRule[];
  autoDeleteOnIdle?: string;
  createdOn?: string;
  defaultMessageTtl: string;
  duplicateDetectionHistoryTimeWindow: string;
  enableBatchedOperations: boolean;
  enableExpress?: boolean;
  enablePartitioning: boolean;
  enableSubscriptionPartitioning?: boolean;
  entityAvailabilityStatus?: string;
  filteringMessagesBeforePublishing?: boolean;
  isAnonymousAccessible?: boolean;
  isExpress?: boolean;
  maxDeliveryCount?: number;
  maxSizeInMegabytes: number;
  messageCount?: number;
  messageCountDetails?: MessageCountDetails;
  requiresDuplicateDetection: boolean;
  sizeInBytes?: number;
  status?: EntityStatus;
  subscriptionCount?: number;
  supportOrdering: boolean;
  topicName: string;
  updatedOn?: string;
  userMetadata?: string;
}

// @public
export interface TopicOptions {
  authorizationRules?: AuthorizationRule[];
  autoDeleteOnIdle?: string;
  defaultMessageTtl?: string;
  duplicateDetectionHistoryTimeWindow?: string;
  enableBatchedOperations?: boolean;
  enablePartitioning?: boolean;
  maxSizeInMegabytes?: number;
  requiresDuplicateDetection?: boolean;
  status?: EntityStatus;
  supportOrdering?: boolean;
  userMetadata?: string;
}

// @public
export interface WaitTimeOptions {
  maxWaitTimeSeconds: number;
}

export { WebSocketImpl };

export { WebSocketOptions };

// (No @packageDocumentation comment for this package)
```
