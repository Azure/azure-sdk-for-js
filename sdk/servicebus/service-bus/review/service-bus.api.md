## API Report File for "@azure/service-bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AmqpMessage } from '@azure/core-amqp';
import { DataTransformer } from '@azure/core-amqp';
import { delay } from '@azure/core-amqp';
import { Delivery } from 'rhea-promise';
import { HttpOperationResponse } from '@azure/core-http';
import Long from 'long';
import { MessagingError } from '@azure/core-amqp';
import { OperationOptions } from '@azure/core-auth';
import { RetryOptions } from '@azure/core-amqp';
import { TokenCredential } from '@azure/core-amqp';
import { TokenType } from '@azure/core-amqp';
import { WebSocketImpl } from 'rhea-promise';
import { WebSocketOptions } from '@azure/core-amqp';

// @public
export type AuthorizationRule = {
    claimType: string;
    claimValue: string;
    rights: {
        accessRights?: string[];
    };
    keyName: string;
    primaryKey?: string;
    secondaryKey?: string;
};

// @public
export type ClientTypeT<ReceiveModeT extends "peekLock" | "receiveAndDelete", EntityTypeT extends "queue" | "subscription", SessionsEnabledT extends "sessions" | "nosessions"> = SessionsEnabledT extends "nosessions" ? EntityTypeT extends "queue" ? NonSessionReceiver<ReceiveModeT> : NonSessionReceiver<ReceiveModeT> & SubscriptionRuleManagement : EntityTypeT extends "queue" ? SessionReceiver<ReceiveModeT> : SessionReceiver<ReceiveModeT> & SubscriptionRuleManagement;

// @public
export interface Closeable {
    close(): Promise<void>;
}

// @public
export type ContextType<LockModeT> = LockModeT extends "peekLock" ? ContextWithSettlement : LockModeT extends "receiveAndDelete" ? {} : never;

// @public
export interface ContextWithSettlement {
    abandon(message: ReceivedMessage, propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    complete(message: ReceivedMessage): Promise<void>;
    deadLetter(message: ReceivedMessage, options?: DeadLetterOptions): Promise<void>;
    defer(message: ReceivedMessage, propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
}

// @public
export interface CorrelationFilter {
    contentType?: string;
    correlationId?: string;
    label?: string;
    messageId?: string;
    replyTo?: string;
    replyToSessionId?: string;
    sessionId?: string;
    to?: string;
    userProperties?: any;
}

export { DataTransformer }

// @public
export interface DeadLetterOptions {
    deadLetterErrorDescription: string;
    deadletterReason: string;
}

export { delay }

export { Delivery }

// @public
export type EntityStatus = "Active" | "Creating" | "Deleting" | "ReceiveDisabled" | "SendDisabled" | "Disabled" | "Renaming" | "Restoring" | "Unknown";

export { HttpOperationResponse }

// @public
export interface IterateMessagesOptions extends OperationOptions {
}

// @public
export interface MessageAndContext<ContextT> {
    context: ContextT;
    message: ReceivedMessage;
}

// @public
export type MessageCountDetails = {
    activeMessageCount: number;
    deadLetterMessageCount: number;
    scheduledMessageCount: number;
    transferMessageCount: number;
    transferDeadLetterMessageCount: number;
};

// @public
export interface MessageHandlerOptions {
    autoComplete?: boolean;
    maxConcurrentCalls?: number;
    maxMessageAutoRenewLockDurationInSeconds?: number;
}

// @public
export interface MessageHandlers<ContextT> {
    processError(err: Error): Promise<void>;
    processMessage(message: ReceivedMessage, context: ContextT): Promise<void>;
}

// @public
export type MessageIterator<ContextT> = AsyncIterable<MessageAndContext<ContextT>>;

export { MessagingError }

// @public
export interface NonSessionReceiver<LockModeT extends "peekLock" | "receiveAndDelete"> {
    // (undocumented)
    close(): Promise<void>;
    close(): Promise<void>;
    diagnostics: {
        peek(maxMessageCount?: number): Promise<ReceivedMessage[]>;
        peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessage[]>;
    };
    // (undocumented)
    entityPath: string;
    // (undocumented)
    entityType: "queue" | "subscription";
    // (undocumented)
    getDeadLetterPath(): string;
    // (undocumented)
    isReceivingMessages(): boolean;
    iterateMessages(options?: IterateMessagesOptions): MessageIterator<ContextType<LockModeT>>;
    receiveBatch(maxMessages: number, maxWaitTimeInSeconds?: number, options?: ReceiveBatchOptions): Promise<{
        messages: ReceivedMessage[];
        context: ContextType<LockModeT>;
    }>;
    // (undocumented)
    receiveDeferredMessage(sequenceNumber: Long): Promise<ServiceBusMessage | undefined>;
    // (undocumented)
    receiveDeferredMessages(sequenceNumbers: Long[]): Promise<ServiceBusMessage[]>;
    // (undocumented)
    receiveMode: "peekLock" | "receiveAndDelete";
    // (undocumented)
    renewMessageLock(lockTokenOrMessage: string | ReceivedMessage): Promise<Date>;
    subscribe(handler: MessageHandlers<ContextType<LockModeT>>, options?: SubscribeOptions): void;
}

// @public
export interface OnError {
    (error: MessagingError | Error): void;
}

// @public
export interface OnMessage {
    (message: ServiceBusMessage): Promise<void>;
}

// @public
export type QueueAuth = {
    connectionString: string;
    queueName: string;
} | {
    queueConnectionString: string;
} | {
    tokenCredential: TokenCredential;
    host: string;
    queueName: string;
};

// @public
export interface QueueDetails {
    accessedOn?: string;
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle: string;
    createdOn?: string;
    deadLetteringOnMessageExpiration: boolean;
    defaultMessageTtl: string;
    duplicateDetectionHistoryTimeWindow: string;
    enableBatchedOperations: boolean;
    enableExpress?: boolean;
    enablePartitioning: boolean;
    entityAvailabilityStatus?: string;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    isAnonymousAccessible?: boolean;
    lockDuration: string;
    maxDeliveryCount: number;
    maxSizeInMegabytes: number;
    messageCount?: number;
    messageCountDetails?: MessageCountDetails;
    queueName: string;
    requiresDuplicateDetection: boolean;
    requiresSession: boolean;
    sizeInBytes?: number;
    status?: EntityStatus;
    supportOrdering?: boolean;
    updatedOn?: string;
    userMetadata?: string;
}

// @public
export interface QueueOptions {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle?: string;
    deadLetteringOnMessageExpiration?: boolean;
    defaultMessageTtl?: string;
    duplicateDetectionHistoryTimeWindow?: string;
    enableBatchedOperations?: boolean;
    enablePartitioning?: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration?: string;
    maxDeliveryCount?: number;
    maxSizeInMegabytes?: number;
    requiresDuplicateDetection?: boolean;
    requiresSession?: boolean;
    status?: EntityStatus;
    userMetadata?: string;
}

// @public
export interface ReceiveBatchOptions extends OperationOptions {
}

// @public
export type ReceivedMessage = Omit<ServiceBusMessage, "complete" | "abandon" | "defer" | "deadletter" | "prototype">;

// @public
export interface ReceivedMessageInfo extends SendableMessageInfo {
    readonly _amqpMessage: AmqpMessage;
    readonly deadLetterSource?: string;
    readonly deliveryCount?: number;
    readonly enqueuedSequenceNumber?: number;
    readonly enqueuedTimeUtc?: Date;
    readonly expiresAtUtc?: Date;
    lockedUntilUtc?: Date;
    readonly lockToken?: string;
    readonly sequenceNumber?: Long;
}

// @public
export enum ReceiveMode {
    peekLock = 1,
    receiveAndDelete = 2
}

export { RetryOptions }

// @public
export interface RuleDescription {
    action?: string;
    filter?: string | CorrelationFilter;
    name: string;
}

// @public
export interface RuleDetails {
    action?: SqlAction;
    createdOn: string;
    filter?: SqlFilter | CorrelationFilter;
    ruleName: string;
    subscriptionName: string;
    topicName: string;
}

// @public
export interface RuleOptions {
    action?: SqlAction;
    filter?: SqlFilter | CorrelationFilter;
}

// @public
export interface SendableMessageInfo {
    body: any;
    contentType?: string;
    correlationId?: string | number | Buffer;
    label?: string;
    messageId?: string | number | Buffer;
    partitionKey?: string;
    replyTo?: string;
    replyToSessionId?: string;
    scheduledEnqueueTimeUtc?: Date;
    sessionId?: string;
    timeToLive?: number;
    to?: string;
    userProperties?: {
        [key: string]: any;
    };
    viaPartitionKey?: string;
}

// @public
export interface ServiceBusClientOptions {
    dataTransformer?: DataTransformer;
    webSocketOptions?: WebSocketOptions;
}

// @public
export class ServiceBusMessage implements ReceivedMessageInfo {
    abandon(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    readonly _amqpMessage: AmqpMessage;
    body: any;
    clone(): SendableMessageInfo;
    complete(): Promise<void>;
    contentType?: string;
    correlationId?: string | number | Buffer;
    deadLetter(options?: DeadLetterOptions): Promise<void>;
    readonly deadLetterSource?: string;
    defer(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    readonly delivery: Delivery;
    readonly deliveryCount?: number;
    readonly enqueuedSequenceNumber?: number;
    readonly enqueuedTimeUtc?: Date;
    readonly expiresAtUtc?: Date;
    get isSettled(): boolean;
    label?: string;
    lockedUntilUtc?: Date;
    readonly lockToken?: string;
    messageId?: string | number | Buffer;
    partitionKey?: string;
    replyTo?: string;
    replyToSessionId?: string;
    scheduledEnqueueTimeUtc?: Date;
    readonly sequenceNumber?: Long;
    sessionId?: string;
    timeToLive?: number;
    to?: string;
    userProperties?: {
        [key: string]: any;
    };
    viaPartitionKey?: string;
}

// @public
export interface ServiceBusReceiverClient {
    new (queueAuth: QueueAuth, receiveMode: "peekLock", options?: ServiceBusClientOptions): ClientTypeT<"peekLock", "queue", "nosessions">;
    new (queueAuth: QueueAuth, receiveMode: "receiveAndDelete", options?: ServiceBusClientOptions): ClientTypeT<"receiveAndDelete", "queue", "nosessions">;
    new (queueAuth: QueueAuth, receiveMode: "peekLock", session: Session, options?: ServiceBusClientOptions): ClientTypeT<"peekLock", "queue", "sessions">;
    new (queueAuth: QueueAuth, receiveMode: "receiveAndDelete", session: Session, options?: ServiceBusClientOptions): ClientTypeT<"receiveAndDelete", "queue", "sessions">;
    new (subscriptionAuth: SubscriptionAuth, receiveMode: "peekLock", options?: ServiceBusClientOptions): ClientTypeT<"peekLock", "subscription", "nosessions">;
    new (subscriptionAuth: SubscriptionAuth, receiveMode: "receiveAndDelete", options?: ServiceBusClientOptions): ClientTypeT<"receiveAndDelete", "subscription", "nosessions">;
    new (subscriptionAuth: SubscriptionAuth, receiveMode: "peekLock", session: Session, options?: ServiceBusClientOptions): ClientTypeT<"peekLock", "subscription", "sessions">;
    new (subscriptionAuth: SubscriptionAuth, receiveMode: "receiveAndDelete", session: Session, options?: ServiceBusClientOptions): ClientTypeT<"receiveAndDelete", "subscription", "sessions">;
}

// @public
export const ServiceBusReceiverClient: ServiceBusReceiverClient;

// @public
export class ServiceBusSenderClient {
    constructor(entityConnectionString: string, options?: ServiceBusClientOptions);
    constructor(serviceBusConnectionString: string, entityName: string, options?: ServiceBusClientOptions);
    constructor(host: string, entityName: string, credential: TokenCredential, options?: ServiceBusClientOptions);
    cancelScheduledMessage(sequenceNumber: Long): Promise<void>;
    cancelScheduledMessages(sequenceNumbers: Long[]): Promise<void>;
    close(): Promise<void>;
    scheduleMessage(scheduledEnqueueTimeUtc: Date, message: SendableMessageInfo): Promise<Long>;
    scheduleMessages(scheduledEnqueueTimeUtc: Date, messages: SendableMessageInfo[]): Promise<Long[]>;
    send(message: SendableMessageInfo): Promise<void>;
    sendBatch(messages: SendableMessageInfo[]): Promise<void>;
}

// @public
export interface Session {
    connections?: SessionConnections;
    id?: string;
    maxSessionAutoRenewLockDurationInSeconds?: number;
}

// @public
export class SessionConnections {
}

// @public
export interface SessionMessageHandlerOptions {
    autoComplete?: boolean;
    maxConcurrentCalls?: number;
}

// @public
export interface SessionReceiver<LockModeT extends "peekLock" | "receiveAndDelete"> {
    // (undocumented)
    close(): Promise<void>;
    close(): Promise<void>;
    diagnostics: {
        peek(maxMessageCount?: number): Promise<ReceivedMessage[]>;
        peekBySequenceNumber(fromSequenceNumber: Long, maxMessageCount?: number): Promise<ReceivedMessage[]>;
    };
    // (undocumented)
    entityPath: string;
    // (undocumented)
    entityType: "queue" | "subscription";
    // (undocumented)
    getDeadLetterPath(): string;
    // (undocumented)
    getState(): Promise<any>;
    // (undocumented)
    isReceivingMessages(): boolean;
    iterateMessages(options?: IterateMessagesOptions): MessageIterator<ContextType<LockModeT>>;
    receiveBatch(maxMessages: number, maxWaitTimeInSeconds?: number, options?: ReceiveBatchOptions): Promise<{
        messages: ReceivedMessage[];
        context: ContextType<LockModeT>;
    }>;
    // (undocumented)
    receiveDeferredMessage(sequenceNumber: Long): Promise<ServiceBusMessage | undefined>;
    // (undocumented)
    receiveDeferredMessages(sequenceNumbers: Long[]): Promise<ServiceBusMessage[]>;
    // (undocumented)
    receiveMode: "peekLock" | "receiveAndDelete";
    // (undocumented)
    renewSessionLock(): Promise<Date>;
    renewSessionLock(): Promise<Date>;
    // (undocumented)
    sessionId: string | undefined;
    // (undocumented)
    sessionLockedUntilUtc: Date | undefined;
    // (undocumented)
    setState(state: any): Promise<void>;
    subscribe(handlers: MessageHandlers<ContextType<LockModeT>>, options?: SubscribeOptions): void;
}

// @public
export interface SessionReceiverOptions {
    maxSessionAutoRenewLockDurationInSeconds?: number;
    sessionId: string | undefined;
}

// @public
export type SqlAction = SqlFilter;

// @public
export interface SqlFilter {
    compatibilityLevel?: number;
    requiresPreprocessing?: boolean;
    sqlExpression?: string;
    sqlParameters?: SqlParameter[];
}

// @public
export type SqlParameter = {
    key: string;
    value: string | number;
    type: string;
};

// @public
export interface SubscribeOptions extends OperationOptions, MessageHandlerOptions {
}

// @public
export type SubscriptionAuth = {
    connectionString: string;
    topicName: string;
    subscriptionName: string;
} | {
    topicConnectionString: string;
    subscriptionName: string;
} | {
    tokenCredential: TokenCredential;
    host: string;
    topicName: string;
    subscriptionName: string;
};

// @public
export interface SubscriptionDetails {
    accessedOn?: string;
    autoDeleteOnIdle: string;
    createdOn: string;
    deadLetteringOnFilterEvaluationExceptions: boolean;
    deadLetteringOnMessageExpiration: boolean;
    defaultMessageTtl?: string;
    defaultRuleDescription?: any;
    enableBatchedOperations: boolean;
    enablePartitioning?: boolean;
    entityAvailabilityStatus: string;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration: string;
    maxDeliveryCount: number;
    maxSizeInMegabytes?: number;
    messageCount: number;
    messageCountDetails?: MessageCountDetails;
    requiresSession: boolean;
    sizeInBytes?: number;
    status?: EntityStatus;
    subscriptionName: string;
    topicName: string;
    updatedOn: string;
    userMetadata?: string;
}

// @public
export interface SubscriptionOptions {
    autoDeleteOnIdle?: string;
    deadLetteringOnFilterEvaluationExceptions?: boolean;
    deadLetteringOnMessageExpiration?: boolean;
    defaultMessageTtl?: string;
    enableBatchedOperations?: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration?: string;
    maxDeliveryCount?: number;
    requiresSession?: boolean;
    status?: EntityStatus;
    userMetadata?: string;
}

// @public
export interface SubscriptionRuleManagement {
    addRule(ruleName: string, filter: boolean | string | CorrelationFilter, sqlRuleActionExpression?: string): Promise<void>;
    // (undocumented)
    readonly defaultRuleName: string;
    getRules(): Promise<RuleDescription[]>;
    removeRule(ruleName: string): Promise<void>;
}

export { TokenCredential }

export { TokenType }

// @public
export interface TopicDetails {
    accessedOn?: string;
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle?: string;
    createdOn?: string;
    defaultMessageTtl: string;
    duplicateDetectionHistoryTimeWindow: string;
    enableBatchedOperations: boolean;
    enableExpress?: boolean;
    enablePartitioning: boolean;
    enableSubscriptionPartitioning?: boolean;
    entityAvailabilityStatus?: string;
    filteringMessagesBeforePublishing?: boolean;
    isAnonymousAccessible?: boolean;
    isExpress?: boolean;
    maxDeliveryCount?: number;
    maxSizeInMegabytes: number;
    messageCount?: number;
    messageCountDetails?: MessageCountDetails;
    requiresDuplicateDetection: boolean;
    sizeInBytes?: number;
    status?: EntityStatus;
    subscriptionCount?: number;
    supportOrdering: boolean;
    topicName: string;
    updatedOn?: string;
    userMetadata?: string;
}

// @public
export interface TopicOptions {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle?: string;
    defaultMessageTtl?: string;
    duplicateDetectionHistoryTimeWindow?: string;
    enableBatchedOperations?: boolean;
    enablePartitioning?: boolean;
    maxSizeInMegabytes?: number;
    requiresDuplicateDetection?: boolean;
    status?: EntityStatus;
    supportOrdering?: boolean;
    userMetadata?: string;
}

export { WebSocketImpl }

export { WebSocketOptions }


// (No @packageDocumentation comment for this package)

```
