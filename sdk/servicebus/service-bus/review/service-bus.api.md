## API Report File for "@azure/service-bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { AmqpMessage } from "@azure/core-amqp";
import { delay } from "@azure/core-amqp";
import { Delivery } from "rhea-promise";
import Long from "long";
import { MessagingError } from "@azure/core-amqp";
import { OperationOptions } from "@azure/core-auth";
import { RetryOptions } from "@azure/core-amqp";
import { TokenCredential } from "@azure/core-amqp";
import { TokenType } from "@azure/core-amqp";
import { WebSocketImpl } from "rhea-promise";
import { WebSocketOptions } from "@azure/core-amqp";

// @public
export interface CorrelationFilter {
  contentType?: string;
  correlationId?: string;
  label?: string;
  messageId?: string;
  replyTo?: string;
  replyToSessionId?: string;
  sessionId?: string;
  to?: string;
  userProperties?: any;
}

// @public
export interface CreateBatchOptions extends OperationOptions {
  maxSizeInBytes?: number;
}

// @public
export interface DeadLetterOptions {
  deadLetterErrorDescription: string;
  deadLetterReason: string;
}

export { delay };

export { Delivery };

// @public
export interface GetMessageIteratorOptions extends OperationOptions, WaitTimeOptions {}

// @public
export interface GetReceiverOptions {
  retryOptions?: RetryOptions;
}

// @public
export interface GetSenderOptions {
  retryOptions?: RetryOptions;
}

// @public
export interface GetSessionReceiverOptions extends GetReceiverOptions, OperationOptions {
  maxSessionAutoRenewLockDurationInSeconds?: number;
  sessionId?: string;
}

// @public
export interface GetSubscriptionRuleManagerOptions {
  retryOptions?: RetryOptions;
}

// @public
export interface MessageHandlerOptions {
  autoComplete?: boolean;
  maxConcurrentCalls?: number;
  maxMessageAutoRenewLockDurationInSeconds?: number;
}

// @public
export interface MessageHandlers<ReceivedMessageT> {
  processError(err: Error): Promise<void>;
  processMessage(message: ReceivedMessageT): Promise<void>;
}

export { MessagingError };

// @public
export interface ReceiveBatchOptions extends OperationOptions, WaitTimeOptions {}

// @public
export interface ReceivedMessage extends ServiceBusMessage {
  readonly _amqpMessage: AmqpMessage;
  readonly deadLetterSource?: string;
  readonly deliveryCount?: number;
  readonly enqueuedSequenceNumber?: number;
  readonly enqueuedTimeUtc?: Date;
  readonly expiresAtUtc?: Date;
  lockedUntilUtc?: Date;
  readonly lockToken?: string;
  readonly sequenceNumber?: Long;
}

// @public
export interface ReceivedMessageWithLock extends ReceivedMessage {
  abandon(propertiesToModify?: { [key: string]: any }): Promise<void>;
  complete(): Promise<void>;
  deadLetter(
    options?: DeadLetterOptions & {
      [key: string]: any;
    }
  ): Promise<void>;
  defer(propertiesToModify?: { [key: string]: any }): Promise<void>;
  renewLock(): Promise<Date>;
}

// @public
export interface Receiver<ReceivedMessageT> {
  close(): Promise<void>;
  diagnostics: {
    peek(maxMessageCount?: number): Promise<ReceivedMessage[]>;
    peekBySequenceNumber(
      fromSequenceNumber: Long,
      maxMessageCount?: number
    ): Promise<ReceivedMessage[]>;
  };
  entityPath: string;
  getMessageIterator(options?: GetMessageIteratorOptions): AsyncIterableIterator<ReceivedMessageT>;
  isReceivingMessages(): boolean;
  receiveBatch(maxMessages: number, options?: ReceiveBatchOptions): Promise<ReceivedMessageT[]>;
  receiveDeferredMessage(
    sequenceNumber: Long,
    options?: OperationOptions
  ): Promise<ReceivedMessageT | undefined>;
  receiveDeferredMessages(
    sequenceNumbers: Long[],
    options?: OperationOptions
  ): Promise<ReceivedMessageT[]>;
  receiveMode: "peekLock" | "receiveAndDelete";
  subscribe(handlers: MessageHandlers<ReceivedMessageT>, options?: SubscribeOptions): void;
}

export { RetryOptions };

// @public
export interface RuleDescription {
  action?: string;
  filter?: string | CorrelationFilter;
  name: string;
}

// @public
export interface Sender {
  cancelScheduledMessage(sequenceNumber: Long): Promise<void>;
  cancelScheduledMessages(sequenceNumbers: Long[]): Promise<void>;
  close(): Promise<void>;
  createBatch(options?: CreateBatchOptions): Promise<ServiceBusMessageBatch>;
  isClosed: boolean;
  scheduleMessage(scheduledEnqueueTimeUtc: Date, message: ServiceBusMessage): Promise<Long>;
  scheduleMessages(scheduledEnqueueTimeUtc: Date, messages: ServiceBusMessage[]): Promise<Long[]>;
  send(message: ServiceBusMessage): Promise<void>;
  sendBatch(messageBatch: ServiceBusMessageBatch): Promise<void>;
}

// @public
export class ServiceBusClient {
  constructor(connectionString: string, options?: ServiceBusClientOptions);
  constructor(
    hostName: string,
    tokenCredential: TokenCredential,
    options?: ServiceBusClientOptions
  );
  close(): Promise<void>;
  getDeadLetterReceiver(
    queueName: string,
    receiveMode: "peekLock",
    options?: GetReceiverOptions
  ): Receiver<ReceivedMessageWithLock>;
  getDeadLetterReceiver(
    queueName: string,
    receiveMode: "receiveAndDelete",
    options?: GetReceiverOptions
  ): Receiver<ReceivedMessage>;
  getDeadLetterReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "peekLock",
    options?: GetReceiverOptions
  ): Receiver<ReceivedMessageWithLock>;
  getDeadLetterReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "receiveAndDelete",
    options?: GetReceiverOptions
  ): Receiver<ReceivedMessage>;
  getReceiver(
    queueName: string,
    receiveMode: "peekLock",
    options?: GetReceiverOptions
  ): Receiver<ReceivedMessageWithLock>;
  getReceiver(
    queueName: string,
    receiveMode: "receiveAndDelete",
    options?: GetReceiverOptions
  ): Receiver<ReceivedMessage>;
  getReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "peekLock",
    options?: GetReceiverOptions
  ): Receiver<ReceivedMessageWithLock>;
  getReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "receiveAndDelete",
    options?: GetReceiverOptions
  ): Receiver<ReceivedMessage>;
  getSender(queueOrTopicName: string, options?: GetSenderOptions): Sender;
  getSessionReceiver(
    queueName: string,
    receiveMode: "peekLock",
    options?: GetSessionReceiverOptions
  ): SessionReceiver<ReceivedMessageWithLock>;
  getSessionReceiver(
    queueName: string,
    receiveMode: "receiveAndDelete",
    options?: GetSessionReceiverOptions
  ): SessionReceiver<ReceivedMessage>;
  getSessionReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "peekLock",
    options?: GetSessionReceiverOptions
  ): SessionReceiver<ReceivedMessageWithLock>;
  getSessionReceiver(
    topicName: string,
    subscriptionName: string,
    receiveMode: "receiveAndDelete",
    options?: GetSessionReceiverOptions
  ): SessionReceiver<ReceivedMessage>;
  getSubscriptionRuleManager(
    topic: string,
    subscription: string,
    options?: GetSubscriptionRuleManagerOptions
  ): SubscriptionRuleManager;
}

// @public
export interface ServiceBusClientOptions {
  retryOptions?: RetryOptions;
  webSocketOptions?: WebSocketOptions;
}

// @public
export interface ServiceBusMessage {
  body: any;
  contentType?: string;
  correlationId?: string | number | Buffer;
  label?: string;
  messageId?: string | number | Buffer;
  partitionKey?: string;
  replyTo?: string;
  replyToSessionId?: string;
  scheduledEnqueueTimeUtc?: Date;
  sessionId?: string;
  timeToLive?: number;
  to?: string;
  userProperties?: {
    [key: string]: any;
  };
  viaPartitionKey?: string;
}

// @public
export interface ServiceBusMessageBatch {
  readonly count: number;
  readonly maxSizeInBytes: number;
  readonly sizeInBytes: number;
  tryAdd(message: ServiceBusMessage): boolean;
}

// @public
export interface SessionMessageHandlerOptions {
  autoComplete?: boolean;
  maxConcurrentCalls?: number;
}

// @public
export interface SessionReceiver<
  ReceivedMessageT extends ReceivedMessage | ReceivedMessageWithLock
> extends Receiver<ReceivedMessageT> {
  diagnostics: {
    peek(maxMessageCount?: number): Promise<ReceivedMessage[]>;
    peekBySequenceNumber(
      fromSequenceNumber: Long,
      maxMessageCount?: number
    ): Promise<ReceivedMessage[]>;
  };
  getState(): Promise<any>;
  renewSessionLock(): Promise<Date>;
  sessionId: string | undefined;
  sessionLockedUntilUtc: Date | undefined;
  setState(state: any): Promise<void>;
}

// @public
export interface SessionReceiverOptions {
  maxSessionAutoRenewLockDurationInSeconds?: number;
  sessionId: string | undefined;
}

// @public
export interface SubscribeOptions extends OperationOptions, MessageHandlerOptions {}

// @public
export interface SubscriptionRuleManager {
  addRule(
    ruleName: string,
    filter: boolean | string | CorrelationFilter,
    sqlRuleActionExpression?: string
  ): Promise<void>;
  close(): Promise<void>;
  readonly defaultRuleName: string;
  getRules(): Promise<RuleDescription[]>;
  removeRule(ruleName: string): Promise<void>;
}

export { TokenCredential };

export { TokenType };

// @public
export interface WaitTimeOptions {
  maxWaitTimeSeconds: number;
}

export { WebSocketImpl };

export { WebSocketOptions };

// (No @packageDocumentation comment for this package)
```
