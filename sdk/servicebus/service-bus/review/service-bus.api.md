## API Report File for "@azure/service-bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';
import { AmqpAnnotatedMessage } from '@azure/core-amqp';
import { CommonClientOptions } from '@azure/core-client';
import { delay } from '@azure/core-amqp';
import { Delivery } from 'rhea-promise';
import { HttpMethods } from '@azure/core-rest-pipeline';
import Long from 'long';
import { MessagingError } from '@azure/core-amqp';
import { NamedKeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure/core-client';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PageSettings } from '@azure/core-paging';
import { ProxySettings } from '@azure/core-rest-pipeline';
import { RetryMode } from '@azure/core-amqp';
import { RetryOptions } from '@azure/core-amqp';
import { SASCredential } from '@azure/core-auth';
import { ServiceClient } from '@azure/core-client';
import { TokenCredential } from '@azure/core-auth';
import { TokenType } from '@azure/core-amqp';
import { TracingContext } from '@azure/core-tracing';
import { UserAgentPolicyOptions } from '@azure/core-rest-pipeline';
import { WebSocketImpl } from 'rhea-promise';
import { WebSocketOptions } from '@azure/core-amqp';

// @public
export interface AuthorizationRule {
    accessRights?: ("Manage" | "Send" | "Listen")[];
    claimType: string;
    keyName: string;
    primaryKey?: string;
    secondaryKey?: string;
}

// @public
export interface CorrelationRuleFilter {
    applicationProperties?: {
        [key: string]: string | number | boolean | Date;
    };
    contentType?: string;
    correlationId?: string;
    messageId?: string;
    replyTo?: string;
    replyToSessionId?: string;
    sessionId?: string;
    subject?: string;
    to?: string;
}

// @public
export interface CreateMessageBatchOptions extends OperationOptionsBase {
    maxSizeInBytes?: number;
}

// @public
export interface CreateQueueOptions extends OperationOptions {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle?: string;
    availabilityStatus?: EntityAvailabilityStatus;
    deadLetteringOnMessageExpiration?: boolean;
    defaultMessageTimeToLive?: string;
    duplicateDetectionHistoryTimeWindow?: string;
    enableBatchedOperations?: boolean;
    enableExpress?: boolean;
    enablePartitioning?: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration?: string;
    maxDeliveryCount?: number;
    maxMessageSizeInKilobytes?: number;
    maxSizeInMegabytes?: number;
    requiresDuplicateDetection?: boolean;
    requiresSession?: boolean;
    status?: EntityStatus;
    userMetadata?: string;
}

// @public
export interface CreateSubscriptionOptions extends OperationOptions {
    autoDeleteOnIdle?: string;
    availabilityStatus?: EntityAvailabilityStatus;
    deadLetteringOnFilterEvaluationExceptions?: boolean;
    deadLetteringOnMessageExpiration?: boolean;
    defaultMessageTimeToLive?: string;
    defaultRuleOptions?: {
        name: string;
        filter?: SqlRuleFilter | CorrelationRuleFilter;
        action?: SqlRuleAction;
    };
    enableBatchedOperations?: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration?: string;
    maxDeliveryCount?: number;
    requiresSession?: boolean;
    status?: EntityStatus;
    userMetadata?: string;
}

// @public
export interface CreateTopicOptions extends OperationOptions {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle?: string;
    availabilityStatus?: EntityAvailabilityStatus;
    defaultMessageTimeToLive?: string;
    duplicateDetectionHistoryTimeWindow?: string;
    enableBatchedOperations?: boolean;
    enableExpress?: boolean;
    enablePartitioning?: boolean;
    maxMessageSizeInKilobytes?: number;
    maxSizeInMegabytes?: number;
    requiresDuplicateDetection?: boolean;
    status?: EntityStatus;
    supportOrdering?: boolean;
    userMetadata?: string;
}

// @public
export interface DeadLetterOptions {
    deadLetterErrorDescription: string;
    deadLetterReason: string;
}

export { delay }

export { Delivery }

// @public
export type EntitiesResponse<T extends object> = WithResponse<Array<T>> & Pick<PageSettings, "continuationToken">;

// @public
export type EntityAvailabilityStatus = "Available" | "Limited" | "Renaming" | "Restoring" | "Unknown";

// @public
export type EntityStatus = "Active" | "Creating" | "Deleting" | "ReceiveDisabled" | "SendDisabled" | "Disabled" | "Renaming" | "Restoring" | "Unknown";

// @public
export interface GetMessageIteratorOptions extends OperationOptionsBase {
}

// @public
export interface HttpHeader {
    name: string;
    value: string;
}

// @public
export interface HttpHeadersLike {
    clone(): HttpHeadersLike;
    contains(headerName: string): boolean;
    get(headerName: string): string | undefined;
    headerNames(): string[];
    headersArray(): HttpHeader[];
    headerValues(): string[];
    rawHeaders(): RawHttpHeaders;
    remove(headerName: string): boolean;
    set(headerName: string, headerValue: string | number): void;
    toJson(options?: {
        preserveCase?: boolean;
    }): RawHttpHeaders;
}

// @public
export interface HttpResponse {
    headers: HttpHeadersLike;
    request: WebResourceLike;
    status: number;
}

// @public
export function isServiceBusError(err: unknown): err is ServiceBusError;

// @public
export interface MessageHandlers {
    processError(args: ProcessErrorArgs): Promise<void>;
    processMessage(message: ServiceBusReceivedMessage): Promise<void>;
}

export { MessagingError }

// @public
export interface NamespaceProperties {
    createdAt: Date;
    messagingSku: "Basic" | "Premium" | "Standard";
    messagingUnits: number | undefined;
    modifiedAt: Date;
    name: string;
}

export { OperationOptions }

// @public
export type OperationOptionsBase = Pick<OperationOptions, "abortSignal" | "tracingOptions">;

// @public
export function parseServiceBusConnectionString(connectionString: string): ServiceBusConnectionStringProperties;

// @public
export interface PeekMessagesOptions extends OperationOptionsBase {
    fromSequenceNumber?: Long;
    // @beta
    omitMessageBody?: boolean;
}

// @public
export interface ProcessErrorArgs {
    entityPath: string;
    error: Error | ServiceBusError;
    errorSource: "abandon" | "complete" | "processMessageCallback" | "receive" | "renewLock";
    fullyQualifiedNamespace: string;
    identifier: string;
}

// @public
export interface QueueProperties {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle: string;
    readonly availabilityStatus: EntityAvailabilityStatus;
    deadLetteringOnMessageExpiration: boolean;
    defaultMessageTimeToLive: string;
    duplicateDetectionHistoryTimeWindow: string;
    enableBatchedOperations: boolean;
    readonly enableExpress: boolean;
    readonly enablePartitioning: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration: string;
    maxDeliveryCount: number;
    maxMessageSizeInKilobytes?: number;
    maxSizeInMegabytes: number;
    readonly name: string;
    readonly requiresDuplicateDetection: boolean;
    readonly requiresSession: boolean;
    status: EntityStatus;
    userMetadata: string;
}

// @public
export interface QueueRuntimeProperties {
    accessedAt: Date;
    activeMessageCount: number;
    createdAt: Date;
    deadLetterMessageCount: number;
    modifiedAt: Date;
    name: string;
    scheduledMessageCount: number;
    sizeInBytes?: number;
    totalMessageCount?: number;
    transferDeadLetterMessageCount: number;
    transferMessageCount: number;
}

// @public
export type RawHttpHeaders = {
    [headerName: string]: string;
};

// @public
export interface ReceiveMessagesOptions extends OperationOptionsBase {
    maxWaitTimeInMs?: number;
}

export { RetryMode }

export { RetryOptions }

// @public
export interface RuleProperties {
    action: SqlRuleAction;
    filter: SqlRuleFilter | CorrelationRuleFilter;
    readonly name: string;
}

// @public
export class ServiceBusAdministrationClient extends ServiceClient {
    constructor(connectionString: string, options?: ServiceBusAdministrationClientOptions);
    constructor(fullyQualifiedNamespace: string, credential: TokenCredential | NamedKeyCredential, options?: ServiceBusAdministrationClientOptions);
    createQueue(queueName: string, options?: CreateQueueOptions): Promise<WithResponse<QueueProperties>>;
    createRule(topicName: string, subscriptionName: string, ruleName: string, ruleFilter: SqlRuleFilter | CorrelationRuleFilter, operationOptions?: OperationOptions): Promise<WithResponse<RuleProperties>>;
    createRule(topicName: string, subscriptionName: string, ruleName: string, ruleFilter: SqlRuleFilter | CorrelationRuleFilter, ruleAction: SqlRuleAction, operationOptions?: OperationOptions): Promise<WithResponse<RuleProperties>>;
    createSubscription(topicName: string, subscriptionName: string, options?: CreateSubscriptionOptions): Promise<WithResponse<SubscriptionProperties>>;
    createTopic(topicName: string, options?: CreateTopicOptions): Promise<WithResponse<TopicProperties>>;
    deleteQueue(queueName: string, operationOptions?: OperationOptions): Promise<WithResponse<{}>>;
    deleteRule(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<WithResponse<{}>>;
    deleteSubscription(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<WithResponse<{}>>;
    deleteTopic(topicName: string, operationOptions?: OperationOptions): Promise<WithResponse<{}>>;
    getNamespaceProperties(operationOptions?: OperationOptions): Promise<WithResponse<NamespaceProperties>>;
    getQueue(queueName: string, operationOptions?: OperationOptions): Promise<WithResponse<QueueProperties>>;
    getQueueRuntimeProperties(queueName: string, operationOptions?: OperationOptions): Promise<WithResponse<QueueRuntimeProperties>>;
    getRule(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<WithResponse<RuleProperties>>;
    getSubscription(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<WithResponse<SubscriptionProperties>>;
    getSubscriptionRuntimeProperties(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<WithResponse<SubscriptionRuntimeProperties>>;
    getTopic(topicName: string, operationOptions?: OperationOptions): Promise<WithResponse<TopicProperties>>;
    getTopicRuntimeProperties(topicName: string, operationOptions?: OperationOptions): Promise<WithResponse<TopicRuntimeProperties>>;
    listQueues(options?: OperationOptions): PagedAsyncIterableIterator<QueueProperties, EntitiesResponse<QueueProperties>>;
    listQueuesRuntimeProperties(options?: OperationOptions): PagedAsyncIterableIterator<QueueRuntimeProperties, EntitiesResponse<QueueRuntimeProperties>>;
    listRules(topicName: string, subscriptionName: string, options?: OperationOptions): PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>>;
    listSubscriptions(topicName: string, options?: OperationOptions): PagedAsyncIterableIterator<SubscriptionProperties, EntitiesResponse<SubscriptionProperties>>;
    listSubscriptionsRuntimeProperties(topicName: string, options?: OperationOptions): PagedAsyncIterableIterator<SubscriptionRuntimeProperties, EntitiesResponse<SubscriptionRuntimeProperties>>;
    listTopics(options?: OperationOptions): PagedAsyncIterableIterator<TopicProperties, EntitiesResponse<TopicProperties>>;
    listTopicsRuntimeProperties(options?: OperationOptions): PagedAsyncIterableIterator<TopicRuntimeProperties, EntitiesResponse<TopicRuntimeProperties>>;
    queueExists(queueName: string, operationOptions?: OperationOptions): Promise<boolean>;
    ruleExists(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<boolean>;
    subscriptionExists(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<boolean>;
    topicExists(topicName: string, operationOptions?: OperationOptions): Promise<boolean>;
    updateQueue(queue: WithResponse<QueueProperties>, operationOptions?: OperationOptions): Promise<WithResponse<QueueProperties>>;
    updateRule(topicName: string, subscriptionName: string, rule: WithResponse<RuleProperties>, operationOptions?: OperationOptions): Promise<WithResponse<RuleProperties>>;
    updateSubscription(subscription: WithResponse<SubscriptionProperties>, operationOptions?: OperationOptions): Promise<WithResponse<SubscriptionProperties>>;
    updateTopic(topic: WithResponse<TopicProperties>, operationOptions?: OperationOptions): Promise<WithResponse<TopicProperties>>;
}

// @public
export interface ServiceBusAdministrationClientOptions extends CommonClientOptions {
    serviceVersion?: "2021-05" | "2017-04";
}

// @public
export class ServiceBusClient {
    constructor(connectionString: string, options?: ServiceBusClientOptions);
    constructor(fullyQualifiedNamespace: string, credential: TokenCredential | NamedKeyCredential | SASCredential, options?: ServiceBusClientOptions);
    acceptNextSession(queueName: string, options?: ServiceBusSessionReceiverOptions): Promise<ServiceBusSessionReceiver>;
    acceptNextSession(topicName: string, subscriptionName: string, options?: ServiceBusSessionReceiverOptions): Promise<ServiceBusSessionReceiver>;
    acceptSession(queueName: string, sessionId: string, options?: ServiceBusSessionReceiverOptions): Promise<ServiceBusSessionReceiver>;
    acceptSession(topicName: string, subscriptionName: string, sessionId: string, options?: ServiceBusSessionReceiverOptions): Promise<ServiceBusSessionReceiver>;
    close(): Promise<void>;
    createReceiver(queueName: string, options?: ServiceBusReceiverOptions): ServiceBusReceiver;
    createReceiver(topicName: string, subscriptionName: string, options?: ServiceBusReceiverOptions): ServiceBusReceiver;
    createRuleManager(topicName: string, subscriptionName: string): ServiceBusRuleManager;
    createSender(queueOrTopicName: string, options?: ServiceBusSenderOptions): ServiceBusSender;
    fullyQualifiedNamespace: string;
    identifier: string;
}

// @public
export interface ServiceBusClientOptions {
    customEndpointAddress?: string;
    identifier?: string;
    retryOptions?: RetryOptions;
    userAgentOptions?: UserAgentPolicyOptions;
    webSocketOptions?: WebSocketOptions;
}

// @public
export interface ServiceBusConnectionStringProperties {
    endpoint: string;
    entityPath?: string;
    fullyQualifiedNamespace: string;
    sharedAccessKey?: string;
    sharedAccessKeyName?: string;
    sharedAccessSignature?: string;
}

// @public
export class ServiceBusError extends MessagingError {
    constructor(message: string, code: ServiceBusErrorCode);
    constructor(messagingError: MessagingError);
    code: ServiceBusErrorCode;
}

// @public
export type ServiceBusErrorCode =
/**
* The exception was the result of a general error within the client library.
*/
"GeneralError"
/**
* A Service Bus resource cannot be found by the Service Bus service.
*/
| "MessagingEntityNotFound"
/**
* The lock on the message is lost. Callers should attempt to receive and process the message again.
*/
| "MessageLockLost"
/**
* The requested message was not found.
*/
| "MessageNotFound"
/**
* A message is larger than the maximum size allowed for its transport.
*/
| "MessageSizeExceeded"
/**
* An entity with the same name exists under the same namespace.
*/
| "MessagingEntityAlreadyExists"
/**
* The Messaging Entity is disabled. Enable the entity again using Portal.
*/
| "MessagingEntityDisabled"
/**
* The quota applied to an Service Bus resource has been exceeded while interacting with the Azure Service Bus service.
*/
| "QuotaExceeded"
/**
* The Azure Service Bus service reports that it is busy in response to a client request to perform an operation.
*/
| "ServiceBusy"
/**
* An operation or other request timed out while interacting with the Azure Service Bus service.
*/
| "ServiceTimeout"
/**
* There was a general communications error encountered when interacting with the Azure Service Bus service.
*/
| "ServiceCommunicationProblem"
/**
* The requested session cannot be locked.
*/
| "SessionCannotBeLocked"
/**
* The lock on the session has expired. Callers should request the session again.
*/
| "SessionLockLost"
/**
* The user doesn't have access to the entity.
*/
| "UnauthorizedAccess";

// @public
export interface ServiceBusMessage {
    applicationProperties?: {
        [key: string]: number | boolean | string | Date | null;
    };
    body: any;
    contentType?: string;
    correlationId?: string | number | Buffer;
    messageId?: string | number | Buffer;
    partitionKey?: string;
    replyTo?: string;
    replyToSessionId?: string;
    scheduledEnqueueTimeUtc?: Date;
    sessionId?: string;
    subject?: string;
    timeToLive?: number;
    to?: string;
}

// @public
export interface ServiceBusMessageBatch {
    readonly count: number;
    // @internal
    _generateMessage(): Buffer;
    readonly maxSizeInBytes: number;
    // @internal
    readonly _messageSpanContexts: TracingContext[];
    readonly sizeInBytes: number;
    tryAddMessage(message: ServiceBusMessage | AmqpAnnotatedMessage, options?: TryAddOptions): boolean;
}

// @public
export interface ServiceBusReceivedMessage extends ServiceBusMessage {
    readonly deadLetterErrorDescription?: string;
    readonly deadLetterReason?: string;
    readonly deadLetterSource?: string;
    readonly deliveryCount?: number;
    readonly enqueuedSequenceNumber?: number;
    readonly enqueuedTimeUtc?: Date;
    readonly expiresAtUtc?: Date;
    lockedUntilUtc?: Date;
    readonly lockToken?: string;
    readonly _rawAmqpMessage: AmqpAnnotatedMessage;
    readonly sequenceNumber?: Long;
    readonly state: "active" | "deferred" | "scheduled";
}

// @public
export interface ServiceBusReceiver {
    abandonMessage(message: ServiceBusReceivedMessage, propertiesToModify?: {
        [key: string]: number | boolean | string | Date | null;
    }): Promise<void>;
    close(): Promise<void>;
    completeMessage(message: ServiceBusReceivedMessage): Promise<void>;
    deadLetterMessage(message: ServiceBusReceivedMessage, options?: DeadLetterOptions & {
        [key: string]: number | boolean | string | Date | null;
    }): Promise<void>;
    deferMessage(message: ServiceBusReceivedMessage, propertiesToModify?: {
        [key: string]: number | boolean | string | Date | null;
    }): Promise<void>;
    entityPath: string;
    getMessageIterator(options?: GetMessageIteratorOptions): AsyncIterableIterator<ServiceBusReceivedMessage>;
    identifier: string;
    isClosed: boolean;
    peekMessages(maxMessageCount: number, options?: PeekMessagesOptions): Promise<ServiceBusReceivedMessage[]>;
    receiveDeferredMessages(sequenceNumbers: Long | Long[], options?: OperationOptionsBase): Promise<ServiceBusReceivedMessage[]>;
    receiveMessages(maxMessageCount: number, options?: ReceiveMessagesOptions): Promise<ServiceBusReceivedMessage[]>;
    receiveMode: "peekLock" | "receiveAndDelete";
    renewMessageLock(message: ServiceBusReceivedMessage): Promise<Date>;
    subscribe(handlers: MessageHandlers, options?: SubscribeOptions): {
        close(): Promise<void>;
    };
}

// @public
export interface ServiceBusReceiverOptions {
    identifier?: string;
    maxAutoLockRenewalDurationInMs?: number;
    receiveMode?: "peekLock" | "receiveAndDelete";
    skipParsingBodyAsJson?: boolean;
    subQueueType?: "deadLetter" | "transferDeadLetter";
}

// @public
export interface ServiceBusRuleManager {
    createRule(ruleName: string, filter: SqlRuleFilter | CorrelationRuleFilter, options?: OperationOptionsBase): Promise<void>;
    createRule(ruleName: string, filter: SqlRuleFilter | CorrelationRuleFilter, ruleAction?: SqlRuleAction, options?: OperationOptionsBase): Promise<void>;
    deleteRule(ruleName: string, options?: OperationOptionsBase): Promise<void>;
    listRules(options?: OperationOptions): PagedAsyncIterableIterator<RuleProperties>;
}

// @public
export interface ServiceBusSender {
    cancelScheduledMessages(sequenceNumbers: Long | Long[], options?: OperationOptionsBase): Promise<void>;
    close(): Promise<void>;
    createMessageBatch(options?: CreateMessageBatchOptions): Promise<ServiceBusMessageBatch>;
    entityPath: string;
    identifier: string;
    isClosed: boolean;
    scheduleMessages(messages: ServiceBusMessage | ServiceBusMessage[] | AmqpAnnotatedMessage | AmqpAnnotatedMessage[], scheduledEnqueueTimeUtc: Date, options?: OperationOptionsBase): Promise<Long[]>;
    sendMessages(messages: ServiceBusMessage | ServiceBusMessage[] | ServiceBusMessageBatch | AmqpAnnotatedMessage | AmqpAnnotatedMessage[], options?: OperationOptionsBase): Promise<void>;
}

// @public
export interface ServiceBusSenderOptions {
    identifier?: string;
}

// @public
export interface ServiceBusSessionReceiver extends ServiceBusReceiver {
    getSessionState(options?: OperationOptionsBase): Promise<any>;
    renewSessionLock(options?: OperationOptionsBase): Promise<Date>;
    readonly sessionId: string;
    readonly sessionLockedUntilUtc: Date;
    setSessionState(state: any, options?: OperationOptionsBase): Promise<void>;
    subscribe(handlers: MessageHandlers, options?: SubscribeOptions): {
        close(): Promise<void>;
    };
}

// @public
export interface ServiceBusSessionReceiverOptions extends OperationOptionsBase {
    identifier?: string;
    maxAutoLockRenewalDurationInMs?: number;
    receiveMode?: "peekLock" | "receiveAndDelete";
    skipParsingBodyAsJson?: boolean;
}

// @public
export type SqlRuleAction = {
    sqlExpression?: string;
    sqlParameters?: {
        [key: string]: string | number | boolean;
    };
};

// @public
export interface SqlRuleFilter {
    sqlExpression: string;
    sqlParameters?: {
        [key: string]: string | number | boolean;
    };
}

// @public
export interface SubscribeOptions extends OperationOptionsBase {
    autoCompleteMessages?: boolean;
    maxConcurrentCalls?: number;
}

// @public
export interface SubscriptionProperties {
    autoDeleteOnIdle: string;
    availabilityStatus?: EntityAvailabilityStatus;
    deadLetteringOnFilterEvaluationExceptions: boolean;
    deadLetteringOnMessageExpiration: boolean;
    defaultMessageTimeToLive: string;
    enableBatchedOperations: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration: string;
    maxDeliveryCount: number;
    readonly requiresSession: boolean;
    status: EntityStatus;
    readonly subscriptionName: string;
    readonly topicName: string;
    userMetadata?: string;
}

// @public
export interface SubscriptionRuntimeProperties {
    accessedAt: Date;
    activeMessageCount: number;
    createdAt: Date;
    deadLetterMessageCount: number;
    modifiedAt: Date;
    subscriptionName: string;
    topicName: string;
    totalMessageCount: number;
    transferDeadLetterMessageCount: number;
    transferMessageCount: number;
}

export { TokenCredential }

export { TokenType }

// @public
export interface TopicProperties {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle: string;
    readonly availabilityStatus: EntityAvailabilityStatus;
    defaultMessageTimeToLive: string;
    duplicateDetectionHistoryTimeWindow: string;
    enableBatchedOperations: boolean;
    readonly enableExpress: boolean;
    readonly enablePartitioning: boolean;
    maxMessageSizeInKilobytes?: number;
    maxSizeInMegabytes: number;
    readonly name: string;
    readonly requiresDuplicateDetection: boolean;
    status: EntityStatus;
    supportOrdering: boolean;
    userMetadata: string;
}

// @public
export interface TopicRuntimeProperties {
    accessedAt: Date;
    createdAt: Date;
    modifiedAt: Date;
    name: string;
    scheduledMessageCount: number;
    sizeInBytes?: number;
    subscriptionCount?: number;
}

// @public
export type TransferProgressEvent = {
    loadedBytes: number;
};

// @public
export interface TryAddOptions {
    tracingOptions?: OperationTracingOptions;
}

// @public
export interface WebResourceLike {
    abortSignal?: AbortSignalLike;
    body?: any;
    decompressResponse?: boolean;
    formData?: any;
    headers: HttpHeadersLike;
    keepAlive?: boolean;
    method: HttpMethods;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    proxySettings?: ProxySettings;
    query?: {
        [key: string]: any;
    };
    requestId: string;
    // @deprecated
    streamResponseBody?: boolean;
    streamResponseStatusCodes?: Set<number>;
    timeout: number;
    url: string;
    withCredentials: boolean;
}

export { WebSocketImpl }

export { WebSocketOptions }

// @public
export type WithResponse<T extends object> = T & {
    _response: HttpResponse;
};

// (No @packageDocumentation comment for this package)

```
