## API Report File for "@azure/service-bus"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { delay } from '@azure/core-amqp';
import { Delivery } from 'rhea-promise';
import { HttpOperationResponse } from '@azure/core-http';
import Long from 'long';
import { MessagingError } from '@azure/core-amqp';
import { OperationOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PageSettings } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';
import { RetryOptions } from '@azure/core-amqp';
import { ServiceClient } from '@azure/core-http';
import { TokenCredential } from '@azure/core-amqp';
import { TokenType } from '@azure/core-amqp';
import { UserAgentOptions } from '@azure/core-http';
import { WebSocketImpl } from 'rhea-promise';
import { WebSocketOptions } from '@azure/core-amqp';

// @public
export interface AmqpAnnotatedMessage {
    applicationProperties?: {
        [key: string]: any;
    };
    body: any;
    deliveryAnnotations?: {
        [key: string]: any;
    };
    footer?: {
        [key: string]: any;
    };
    header?: AmqpMessageHeader;
    messageAnnotations?: {
        [key: string]: any;
    };
    properties?: AmqpMessageProperties;
}

// @public
export interface AmqpMessageHeader {
    deliveryCount?: number;
    durable?: boolean;
    firstAcquirer?: boolean;
    priority?: number;
    timeToLive?: number;
}

// @public
export interface AmqpMessageProperties {
    absoluteExpiryTime?: number;
    contentEncoding?: string;
    contentType?: string;
    correlationId?: string | number | Buffer;
    creationTime?: number;
    groupId?: string;
    groupSequence?: number;
    messageId?: string | number | Buffer;
    replyTo?: string;
    replyToGroupId?: string;
    subject?: string;
    to?: string;
    userId?: string;
}

// @public
export type AuthorizationRule = {
    claimType: string;
    claimValue: string;
    accessRights?: ("Manage" | "Send" | "Listen")[];
    keyName: string;
    primaryKey?: string;
    secondaryKey?: string;
};

// @public
export interface CorrelationRuleFilter {
    contentType?: string;
    correlationId?: string;
    label?: string;
    messageId?: string;
    properties?: {
        [key: string]: string | number | boolean;
    };
    replyTo?: string;
    replyToSessionId?: string;
    sessionId?: string;
    to?: string;
}

// @public
export interface CreateBatchOptions extends OperationOptionsBase {
    maxSizeInBytes?: number;
}

// @public
export interface CreateQueueOptions extends OperationOptions {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle?: string;
    deadLetteringOnMessageExpiration?: boolean;
    defaultMessageTimeToLive?: string;
    duplicateDetectionHistoryTimeWindow?: string;
    enableBatchedOperations?: boolean;
    enablePartitioning?: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration?: string;
    maxDeliveryCount?: number;
    maxSizeInMegabytes?: number;
    requiresDuplicateDetection?: boolean;
    requiresSession?: boolean;
    status?: EntityStatus;
    userMetadata?: string;
}

// @public
export interface CreateReceiverOptions<ReceiveModeT extends ReceiveMode> {
    receiveMode?: ReceiveModeT;
    subQueue?: SubQueue;
}

// @public
export interface CreateSessionReceiverOptions<ReceiveModeT extends ReceiveMode> extends OperationOptionsBase {
    maxAutoRenewLockDurationInMs?: number;
    receiveMode?: ReceiveModeT;
    sessionId?: string;
}

// @public
export interface CreateSubscriptionOptions extends OperationOptions {
    autoDeleteOnIdle?: string;
    deadLetteringOnFilterEvaluationExceptions?: boolean;
    deadLetteringOnMessageExpiration?: boolean;
    defaultMessageTimeToLive?: string;
    enableBatchedOperations?: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration?: string;
    maxDeliveryCount?: number;
    requiresSession?: boolean;
    status?: EntityStatus;
    userMetadata?: string;
}

// @public
export interface CreateTopicOptions extends OperationOptions {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle?: string;
    defaultMessageTimeToLive?: string;
    duplicateDetectionHistoryTimeWindow?: string;
    enableBatchedOperations?: boolean;
    enablePartitioning?: boolean;
    maxSizeInMegabytes?: number;
    requiresDuplicateDetection?: boolean;
    status?: EntityStatus;
    supportOrdering?: boolean;
    userMetadata?: string;
}

// @public
export interface DeadLetterOptions {
    deadLetterErrorDescription: string;
    deadLetterReason: string;
}

export { delay }

export { Delivery }

// @public
export interface EntitiesResponse<T> extends Array<T>, Pick<PageSettings, "continuationToken">, Response {
}

// @public
export type EntityStatus = "Active" | "Creating" | "Deleting" | "ReceiveDisabled" | "SendDisabled" | "Disabled" | "Renaming" | "Restoring" | "Unknown";

// @public
export interface GetMessageIteratorOptions extends OperationOptionsBase {
}

// @public
export interface MessageHandlerOptions extends MessageHandlerOptionsBase {
    maxAutoRenewLockDurationInMs?: number;
}

// @public
export interface MessageHandlerOptionsBase {
    autoComplete?: boolean;
    maxConcurrentCalls?: number;
}

// @public
export interface MessageHandlers<ReceivedMessageT> {
    processError(err: Error): Promise<void>;
    processMessage(message: ReceivedMessageT): Promise<void>;
}

export { MessagingError }

// @public
export interface NamespaceProperties {
    createdAt: Date;
    messagingSku: string;
    messagingUnits: number | undefined;
    modifiedAt: Date;
    name: string;
    namespaceType: string;
}

// @public
export interface NamespacePropertiesResponse extends NamespaceProperties, Response {
}

export { OperationOptions }

// @public
export type OperationOptionsBase = Pick<OperationOptions, "abortSignal" | "tracingOptions">;

// @public
export interface PeekMessagesOptions extends OperationOptionsBase {
    fromSequenceNumber?: Long;
}

// @public
export interface QueueProperties {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle: string;
    deadLetteringOnMessageExpiration: boolean;
    defaultMessageTimeToLive: string;
    duplicateDetectionHistoryTimeWindow: string;
    enableBatchedOperations: boolean;
    readonly enablePartitioning: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration: string;
    maxDeliveryCount: number;
    maxSizeInMegabytes: number;
    readonly name: string;
    readonly requiresDuplicateDetection: boolean;
    readonly requiresSession: boolean;
    status: EntityStatus;
    userMetadata: string;
}

// @public
export interface QueueResponse extends QueueProperties, Response {
}

// @public
export interface QueueRuntimeProperties {
    accessedAt: Date;
    activeMessageCount: number;
    createdAt: Date;
    deadLetterMessageCount: number;
    modifiedAt: Date;
    name: string;
    scheduledMessageCount: number;
    sizeInBytes?: number;
    totalMessageCount?: number;
    transferDeadLetterMessageCount: number;
    transferMessageCount: number;
}

// @public
export interface QueueRuntimePropertiesResponse extends QueueRuntimeProperties, Response {
}

// @public
export interface ReceivedMessage extends ServiceBusMessage {
    readonly _amqpAnnotatedMessage: AmqpAnnotatedMessage;
    readonly deadLetterErrorDescription?: string;
    readonly deadLetterReason?: string;
    readonly deadLetterSource?: string;
    readonly deliveryCount?: number;
    readonly enqueuedSequenceNumber?: number;
    readonly enqueuedTimeUtc?: Date;
    readonly expiresAtUtc?: Date;
    lockedUntilUtc?: Date;
    readonly lockToken?: string;
    readonly sequenceNumber?: Long;
}

// @public
export interface ReceivedMessageWithLock extends ReceivedMessage {
    abandon(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    complete(): Promise<void>;
    deadLetter(options?: DeadLetterOptions & {
        [key: string]: any;
    }): Promise<void>;
    defer(propertiesToModify?: {
        [key: string]: any;
    }): Promise<void>;
    renewLock(): Promise<Date>;
}

// @public
export interface ReceiveMessagesOptions extends OperationOptionsBase {
    maxWaitTimeInMs?: number;
}

// @public
export type ReceiveMode = "peekLock" | "receiveAndDelete";

// @public
export interface Response {
    _response: HttpOperationResponse;
}

export { RetryOptions }

// @public
export interface RuleProperties {
    action: SqlRuleAction;
    filter: SqlRuleFilter | CorrelationRuleFilter;
    readonly name: string;
}

// @public
export interface RuleResponse extends RuleProperties, Response {
}

// @public
export class ServiceBusAdministrationClient extends ServiceClient {
    constructor(connectionString: string, options?: PipelineOptions);
    constructor(fullyQualifiedNamespace: string, credential: TokenCredential, options?: PipelineOptions);
    createQueue(queueName: string, options?: CreateQueueOptions): Promise<QueueResponse>;
    createRule(topicName: string, subscriptionName: string, ruleName: string, ruleFilter: SqlRuleFilter | CorrelationRuleFilter, operationOptions?: OperationOptions): Promise<RuleResponse>;
    createRule(topicName: string, subscriptionName: string, ruleName: string, ruleFilter: SqlRuleFilter | CorrelationRuleFilter, ruleAction: SqlRuleAction, operationOptions?: OperationOptions): Promise<RuleResponse>;
    createSubscription(topicName: string, subscriptionName: string, options?: CreateSubscriptionOptions): Promise<SubscriptionResponse>;
    createTopic(topicName: string, options?: CreateTopicOptions): Promise<TopicResponse>;
    deleteQueue(queueName: string, operationOptions?: OperationOptions): Promise<Response>;
    deleteRule(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<Response>;
    deleteSubscription(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<Response>;
    deleteTopic(topicName: string, operationOptions?: OperationOptions): Promise<Response>;
    getNamespaceProperties(operationOptions?: OperationOptions): Promise<NamespacePropertiesResponse>;
    getQueue(queueName: string, operationOptions?: OperationOptions): Promise<QueueResponse>;
    getQueueRuntimeProperties(queueName: string, operationOptions?: OperationOptions): Promise<QueueRuntimePropertiesResponse>;
    getRule(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<RuleResponse>;
    getSubscription(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<SubscriptionResponse>;
    getSubscriptionRuntimeProperties(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<SubscriptionRuntimePropertiesResponse>;
    getTopic(topicName: string, operationOptions?: OperationOptions): Promise<TopicResponse>;
    getTopicRuntimeProperties(topicName: string, operationOptions?: OperationOptions): Promise<TopicRuntimePropertiesResponse>;
    listQueues(options?: OperationOptions): PagedAsyncIterableIterator<QueueProperties, EntitiesResponse<QueueProperties>>;
    listQueuesRuntimeProperties(options?: OperationOptions): PagedAsyncIterableIterator<QueueRuntimeProperties, EntitiesResponse<QueueRuntimeProperties>>;
    listRules(topicName: string, subscriptionName: string, options?: OperationOptions): PagedAsyncIterableIterator<RuleProperties, EntitiesResponse<RuleProperties>>;
    listSubscriptions(topicName: string, options?: OperationOptions): PagedAsyncIterableIterator<SubscriptionProperties, EntitiesResponse<SubscriptionProperties>>;
    listSubscriptionsRuntimeProperties(topicName: string, options?: OperationOptions): PagedAsyncIterableIterator<SubscriptionRuntimeProperties, EntitiesResponse<SubscriptionRuntimeProperties>>;
    listTopics(options?: OperationOptions): PagedAsyncIterableIterator<TopicProperties, EntitiesResponse<TopicProperties>>;
    listTopicsRuntimeProperties(options?: OperationOptions): PagedAsyncIterableIterator<TopicRuntimeProperties, EntitiesResponse<TopicRuntimeProperties>>;
    queueExists(queueName: string, operationOptions?: OperationOptions): Promise<boolean>;
    ruleExists(topicName: string, subscriptionName: string, ruleName: string, operationOptions?: OperationOptions): Promise<boolean>;
    subscriptionExists(topicName: string, subscriptionName: string, operationOptions?: OperationOptions): Promise<boolean>;
    topicExists(topicName: string, operationOptions?: OperationOptions): Promise<boolean>;
    updateQueue(queue: QueueProperties, operationOptions?: OperationOptions): Promise<QueueResponse>;
    updateRule(topicName: string, subscriptionName: string, rule: RuleProperties, operationOptions?: OperationOptions): Promise<RuleResponse>;
    updateSubscription(subscription: SubscriptionProperties, operationOptions?: OperationOptions): Promise<SubscriptionResponse>;
    updateTopic(topic: TopicProperties, operationOptions?: OperationOptions): Promise<TopicResponse>;
}

// @public
export class ServiceBusClient {
    constructor(connectionString: string, options?: ServiceBusClientOptions);
    constructor(fullyQualifiedNamespace: string, credential: TokenCredential, options?: ServiceBusClientOptions);
    close(): Promise<void>;
    createReceiver(queueName: string, options?: CreateReceiverOptions<"peekLock">): ServiceBusReceiver<ReceivedMessageWithLock>;
    createReceiver(queueName: string, options: CreateReceiverOptions<"receiveAndDelete">): ServiceBusReceiver<ReceivedMessage>;
    createReceiver(topicName: string, subscriptionName: string, options?: CreateReceiverOptions<"peekLock">): ServiceBusReceiver<ReceivedMessageWithLock>;
    createReceiver(topicName: string, subscriptionName: string, options: CreateReceiverOptions<"receiveAndDelete">): ServiceBusReceiver<ReceivedMessage>;
    createSender(queueOrTopicName: string): ServiceBusSender;
    createSessionReceiver(queueName: string, options?: CreateSessionReceiverOptions<"peekLock">): Promise<ServiceBusSessionReceiver<ReceivedMessageWithLock>>;
    createSessionReceiver(queueName: string, options: CreateSessionReceiverOptions<"receiveAndDelete">): Promise<ServiceBusSessionReceiver<ReceivedMessage>>;
    createSessionReceiver(topicName: string, subscriptionName: string, options?: CreateSessionReceiverOptions<"peekLock">): Promise<ServiceBusSessionReceiver<ReceivedMessageWithLock>>;
    createSessionReceiver(topicName: string, subscriptionName: string, options: CreateSessionReceiverOptions<"receiveAndDelete">): Promise<ServiceBusSessionReceiver<ReceivedMessage>>;
    fullyQualifiedNamespace: string;
}

// @public
export interface ServiceBusClientOptions {
    retryOptions?: RetryOptions;
    userAgentOptions?: UserAgentOptions;
    webSocketOptions?: WebSocketOptions;
}

// @public
export interface ServiceBusMessage {
    body: any;
    contentType?: string;
    correlationId?: string | number | Buffer;
    label?: string;
    messageId?: string | number | Buffer;
    partitionKey?: string;
    properties?: {
        [key: string]: number | boolean | string | Date;
    };
    replyTo?: string;
    replyToSessionId?: string;
    scheduledEnqueueTimeUtc?: Date;
    sessionId?: string;
    timeToLive?: number;
    to?: string;
    viaPartitionKey?: string;
}

// @public
export interface ServiceBusMessageBatch {
    readonly count: number;
    // @internal
    _generateMessage(): Buffer;
    readonly maxSizeInBytes: number;
    readonly sizeInBytes: number;
    tryAdd(message: ServiceBusMessage): boolean;
}

// @public
export interface ServiceBusReceiver<ReceivedMessageT> {
    close(): Promise<void>;
    entityPath: string;
    getMessageIterator(options?: GetMessageIteratorOptions): AsyncIterableIterator<ReceivedMessageT>;
    isClosed: boolean;
    peekMessages(maxMessageCount: number, options?: PeekMessagesOptions): Promise<ReceivedMessage[]>;
    receiveDeferredMessages(sequenceNumbers: Long | Long[], options?: OperationOptionsBase): Promise<ReceivedMessageT[]>;
    receiveMessages(maxMessageCount: number, options?: ReceiveMessagesOptions): Promise<ReceivedMessageT[]>;
    receiveMode: "peekLock" | "receiveAndDelete";
    subscribe(handlers: MessageHandlers<ReceivedMessageT>, options?: SubscribeOptions): {
        close(): Promise<void>;
    };
}

// @public
export interface ServiceBusSender {
    cancelScheduledMessages(sequenceNumbers: Long | Long[], options?: OperationOptionsBase): Promise<void>;
    close(): Promise<void>;
    createBatch(options?: CreateBatchOptions): Promise<ServiceBusMessageBatch>;
    entityPath: string;
    isClosed: boolean;
    open(options?: OperationOptionsBase): Promise<void>;
    scheduleMessages(scheduledEnqueueTimeUtc: Date, messages: ServiceBusMessage | ServiceBusMessage[], options?: OperationOptionsBase): Promise<Long[]>;
    sendMessages(messages: ServiceBusMessage | ServiceBusMessage[] | ServiceBusMessageBatch, options?: OperationOptionsBase): Promise<void>;
}

// @public
export interface ServiceBusSessionReceiver<ReceivedMessageT extends ReceivedMessage | ReceivedMessageWithLock> extends ServiceBusReceiver<ReceivedMessageT> {
    getSessionState(options?: OperationOptionsBase): Promise<any>;
    renewSessionLock(options?: OperationOptionsBase): Promise<Date>;
    readonly sessionId: string;
    readonly sessionLockedUntilUtc: Date;
    setSessionState(state: any, options?: OperationOptionsBase): Promise<void>;
    subscribe(handlers: MessageHandlers<ReceivedMessageT>, options?: SessionSubscribeOptions): {
        close(): Promise<void>;
    };
}

// @public
export interface SessionSubscribeOptions extends OperationOptionsBase, MessageHandlerOptionsBase {
}

// @public
export type SqlRuleAction = {
    sqlExpression?: string;
    sqlParameters?: {
        [key: string]: string | number | boolean;
    };
};

// @public
export interface SqlRuleFilter {
    sqlExpression?: string;
    sqlParameters?: {
        [key: string]: string | number | boolean;
    };
}

// @public
export type SubQueue = "deadLetter" | "transferDeadLetter";

// @public
export interface SubscribeOptions extends OperationOptionsBase, MessageHandlerOptions {
}

// @public
export interface SubscriptionProperties {
    autoDeleteOnIdle: string;
    deadLetteringOnFilterEvaluationExceptions: boolean;
    deadLetteringOnMessageExpiration: boolean;
    defaultMessageTimeToLive: string;
    enableBatchedOperations: boolean;
    forwardDeadLetteredMessagesTo?: string;
    forwardTo?: string;
    lockDuration: string;
    maxDeliveryCount: number;
    readonly requiresSession: boolean;
    status: EntityStatus;
    readonly subscriptionName: string;
    readonly topicName: string;
    userMetadata: string;
}

// @public
export interface SubscriptionResponse extends SubscriptionProperties, Response {
}

// @public
export interface SubscriptionRuntimeProperties {
    accessedAt: Date;
    activeMessageCount: number;
    createdAt: Date;
    deadLetterMessageCount: number;
    modifiedAt: Date;
    subscriptionName: string;
    topicName: string;
    totalMessageCount: number;
    transferDeadLetterMessageCount: number;
    transferMessageCount: number;
}

// @public
export interface SubscriptionRuntimePropertiesResponse extends SubscriptionRuntimeProperties, Response {
}

export { TokenCredential }

export { TokenType }

// @public
export interface TopicProperties {
    authorizationRules?: AuthorizationRule[];
    autoDeleteOnIdle: string;
    defaultMessageTimeToLive: string;
    duplicateDetectionHistoryTimeWindow: string;
    enableBatchedOperations: boolean;
    readonly enablePartitioning: boolean;
    maxSizeInMegabytes: number;
    readonly name: string;
    readonly requiresDuplicateDetection: boolean;
    status: EntityStatus;
    supportOrdering: boolean;
    userMetadata: string;
}

// @public
export interface TopicResponse extends TopicProperties, Response {
}

// @public
export interface TopicRuntimeProperties {
    accessedAt: Date;
    createdAt: Date;
    modifiedAt: Date;
    name: string;
    scheduledMessageCount: number;
    sizeInBytes?: number;
    subscriptionCount?: number;
}

// @public
export interface TopicRuntimePropertiesResponse extends TopicRuntimeProperties, Response {
}

export { WebSocketImpl }

export { WebSocketOptions }


// (No @packageDocumentation comment for this package)

```
