## API Report File for "@azure/arm-iotoperations"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AccessTokenMethod = string;

// @public
export type ActionType = string;

// @public
export interface AdvancedSettings {
    clients?: ClientConfig;
    encryptInternalTraffic?: OperationalMode;
    internalCerts?: CertManagerCertOptions;
}

// @public
export type AnonymousMethod = string;

// @public
export interface AuthorizationConfig {
    cache?: OperationalMode;
    rules?: AuthorizationRule[];
}

// @public
export interface AuthorizationRule {
    brokerResources: BrokerResourceRule[];
    principals: PrincipalDefinition;
    stateStoreResources?: StateStoreResourceRule[];
}

// @public
export interface BackendChain {
    partitions: number;
    redundancyFactor: number;
    workers?: number;
}

// @public
export interface BatchingConfiguration {
    latencySeconds?: number;
    maxMessages?: number;
}

// @public
export type BrokerAuthenticationMethod = string;

// @public
export interface BrokerAuthenticationProperties {
    authenticationMethods: BrokerAuthenticatorMethods[];
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface BrokerAuthenticationResource extends ProxyResource {
    extendedLocation: ExtendedLocation;
    properties?: BrokerAuthenticationProperties;
}

// @public
export interface BrokerAuthenticatorCustomAuth {
    x509: X509ManualCertificate;
}

// @public
export interface BrokerAuthenticatorMethodCustom {
    auth?: BrokerAuthenticatorCustomAuth;
    caCertConfigMap?: string;
    endpoint: string;
    headers?: Record<string, string>;
}

// @public
export interface BrokerAuthenticatorMethods {
    customSettings?: BrokerAuthenticatorMethodCustom;
    method: BrokerAuthenticationMethod;
    serviceAccountTokenSettings?: BrokerAuthenticatorMethodSat;
    x509Settings?: BrokerAuthenticatorMethodX509;
}

// @public
export interface BrokerAuthenticatorMethodSat {
    audiences: string[];
}

// @public
export interface BrokerAuthenticatorMethodX509 {
    authorizationAttributes?: Record<string, BrokerAuthenticatorMethodX509Attributes>;
    trustedClientCaCert?: string;
}

// @public
export interface BrokerAuthenticatorMethodX509Attributes {
    attributes: Record<string, string>;
    subject: string;
}

// @public
export interface BrokerAuthorizationProperties {
    authorizationPolicies: AuthorizationConfig;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface BrokerAuthorizationResource extends ProxyResource {
    extendedLocation: ExtendedLocation;
    properties?: BrokerAuthorizationProperties;
}

// @public
export interface BrokerDiagnostics {
    logs?: DiagnosticsLogs;
    metrics?: Metrics;
    selfCheck?: SelfCheck;
    traces?: Traces;
}

// @public
export interface BrokerListenerProperties {
    ports: ListenerPort[];
    readonly provisioningState?: ProvisioningState;
    serviceName?: string;
    serviceType?: ServiceType;
}

// @public
export interface BrokerListenerResource extends ProxyResource {
    extendedLocation: ExtendedLocation;
    properties?: BrokerListenerProperties;
}

// @public
export type BrokerMemoryProfile = string;

// @public
export interface BrokerProperties {
    advanced?: AdvancedSettings;
    cardinality?: Cardinality;
    diagnostics?: BrokerDiagnostics;
    diskBackedMessageBuffer?: DiskBackedMessageBuffer;
    generateResourceLimits?: GenerateResourceLimits;
    memoryProfile?: BrokerMemoryProfile;
    readonly provisioningState?: ProvisioningState;
}

// @public
export type BrokerProtocolType = string;

// @public
export interface BrokerResource extends ProxyResource {
    extendedLocation: ExtendedLocation;
    properties?: BrokerProperties;
}

// @public
export type BrokerResourceDefinitionMethods = string;

// @public
export interface BrokerResourceRule {
    clientIds?: string[];
    method: BrokerResourceDefinitionMethods;
    topics?: string[];
}

// @public
export interface Cardinality {
    backendChain: BackendChain;
    frontend: Frontend;
}

// @public
export interface CertManagerCertificateSpec {
    duration?: string;
    issuerRef: CertManagerIssuerRef;
    privateKey?: CertManagerPrivateKey;
    renewBefore?: string;
    san?: SanForCert;
    secretName?: string;
}

// @public
export interface CertManagerCertOptions {
    duration: string;
    privateKey: CertManagerPrivateKey;
    renewBefore: string;
}

// @public
export type CertManagerIssuerKind = string;

// @public
export interface CertManagerIssuerRef {
    group: string;
    kind: CertManagerIssuerKind;
    name: string;
}

// @public
export interface CertManagerPrivateKey {
    algorithm: PrivateKeyAlgorithm;
    rotationPolicy: PrivateKeyRotationPolicy;
}

// @public
export interface ClientConfig {
    maxKeepAliveSeconds?: number;
    maxMessageExpirySeconds?: number;
    maxPacketSizeBytes?: number;
    maxReceiveMaximum?: number;
    maxSessionExpirySeconds?: number;
    subscriberQueueLimit?: SubscriberQueueLimit;
}

// @public
export type CloudEventAttributeType = string;

// @public
export type CreatedByType = string;

// @public
export type DataExplorerAuthMethod = ManagedIdentityMethod;

// @public
export interface DataflowBuiltInTransformationDataset {
    description?: string;
    expression?: string;
    inputs: string[];
    key: string;
    schemaRef?: string;
}

// @public
export interface DataflowBuiltInTransformationFilter {
    description?: string;
    expression: string;
    inputs: string[];
    type?: FilterType;
}

// @public
export interface DataflowBuiltInTransformationMap {
    description?: string;
    expression?: string;
    inputs: string[];
    output: string;
    type?: DataflowMappingType;
}

// @public
export interface DataflowBuiltInTransformationSettings {
    datasets?: DataflowBuiltInTransformationDataset[];
    filter?: DataflowBuiltInTransformationFilter[];
    map?: DataflowBuiltInTransformationMap[];
    schemaRef?: string;
    serializationFormat?: TransformationSerializationFormat;
}

// @public
export interface DataflowDestinationOperationSettings {
    dataDestination: string;
    endpointRef: string;
}

// @public
export interface DataflowEndpointAuthenticationAccessToken {
    secretRef: string;
}

// @public
export interface DataflowEndpointAuthenticationSasl {
    saslType: DataflowEndpointAuthenticationSaslType;
    secretRef: string;
}

// @public
export type DataflowEndpointAuthenticationSaslType = string;

// @public
export interface DataflowEndpointAuthenticationServiceAccountToken {
    audience: string;
}

// @public
export interface DataflowEndpointAuthenticationSystemAssignedManagedIdentity {
    audience?: string;
}

// @public
export interface DataflowEndpointAuthenticationUserAssignedManagedIdentity {
    clientId: string;
    scope?: string;
    tenantId: string;
}

// @public
export interface DataflowEndpointAuthenticationX509 {
    secretRef: string;
}

// @public
export interface DataflowEndpointDataExplorer {
    authentication: DataflowEndpointDataExplorerAuthentication;
    batching?: BatchingConfiguration;
    database: string;
    host: string;
}

// @public
export interface DataflowEndpointDataExplorerAuthentication {
    method: DataExplorerAuthMethod;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
}

// @public
export interface DataflowEndpointDataLakeStorage {
    authentication: DataflowEndpointDataLakeStorageAuthentication;
    batching?: BatchingConfiguration;
    host: string;
}

// @public
export interface DataflowEndpointDataLakeStorageAuthentication {
    accessTokenSettings?: DataflowEndpointAuthenticationAccessToken;
    method: DataLakeStorageAuthMethod;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
}

// @public
export interface DataflowEndpointFabricOneLake {
    authentication: DataflowEndpointFabricOneLakeAuthentication;
    batching?: BatchingConfiguration;
    host: string;
    names: DataflowEndpointFabricOneLakeNames;
    oneLakePathType: DataflowEndpointFabricPathType;
}

// @public
export interface DataflowEndpointFabricOneLakeAuthentication {
    method: FabricOneLakeAuthMethod;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
}

// @public
export interface DataflowEndpointFabricOneLakeNames {
    lakehouseName: string;
    workspaceName: string;
}

// @public
export type DataflowEndpointFabricPathType = string;

// @public
export interface DataflowEndpointKafka {
    authentication: DataflowEndpointKafkaAuthentication;
    batching?: DataflowEndpointKafkaBatching;
    cloudEventAttributes?: CloudEventAttributeType;
    compression?: DataflowEndpointKafkaCompression;
    consumerGroupId?: string;
    copyMqttProperties?: OperationalMode;
    host: string;
    kafkaAcks?: DataflowEndpointKafkaAcks;
    partitionStrategy?: DataflowEndpointKafkaPartitionStrategy;
    tls?: TlsProperties;
}

// @public
export type DataflowEndpointKafkaAcks = string;

// @public
export interface DataflowEndpointKafkaAuthentication {
    method: KafkaAuthMethod;
    saslSettings?: DataflowEndpointAuthenticationSasl;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
    x509CertificateSettings?: DataflowEndpointAuthenticationX509;
}

// @public
export interface DataflowEndpointKafkaBatching {
    latencyMs?: number;
    maxBytes?: number;
    maxMessages?: number;
    mode?: OperationalMode;
}

// @public
export type DataflowEndpointKafkaCompression = string;

// @public
export type DataflowEndpointKafkaPartitionStrategy = string;

// @public
export interface DataflowEndpointLocalStorage {
    persistentVolumeClaimRef: string;
}

// @public
export interface DataflowEndpointMqtt {
    authentication: DataflowEndpointMqttAuthentication;
    clientIdPrefix?: string;
    cloudEventAttributes?: CloudEventAttributeType;
    host?: string;
    keepAliveSeconds?: number;
    maxInflightMessages?: number;
    protocol?: BrokerProtocolType;
    qos?: number;
    retain?: MqttRetainType;
    sessionExpirySeconds?: number;
    tls?: TlsProperties;
}

// @public
export interface DataflowEndpointMqttAuthentication {
    method: MqttAuthMethod;
    serviceAccountTokenSettings?: DataflowEndpointAuthenticationServiceAccountToken;
    systemAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationSystemAssignedManagedIdentity;
    userAssignedManagedIdentitySettings?: DataflowEndpointAuthenticationUserAssignedManagedIdentity;
    x509CertificateSettings?: DataflowEndpointAuthenticationX509;
}

// @public
export interface DataflowEndpointProperties {
    dataExplorerSettings?: DataflowEndpointDataExplorer;
    dataLakeStorageSettings?: DataflowEndpointDataLakeStorage;
    endpointType: EndpointType;
    fabricOneLakeSettings?: DataflowEndpointFabricOneLake;
    kafkaSettings?: DataflowEndpointKafka;
    localStorageSettings?: DataflowEndpointLocalStorage;
    mqttSettings?: DataflowEndpointMqtt;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface DataflowEndpointResource extends ProxyResource {
    extendedLocation: ExtendedLocation;
    properties?: DataflowEndpointProperties;
}

// @public
export type DataflowMappingType = string;

// @public
export interface DataflowOperation {
    builtInTransformationSettings?: DataflowBuiltInTransformationSettings;
    destinationSettings?: DataflowDestinationOperationSettings;
    name?: string;
    operationType: OperationType;
    sourceSettings?: DataflowSourceOperationSettings;
}

// @public
export interface DataflowProfileProperties {
    diagnostics?: ProfileDiagnostics;
    instanceCount?: number;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface DataflowProfileResource extends ProxyResource {
    extendedLocation: ExtendedLocation;
    properties?: DataflowProfileProperties;
}

// @public
export interface DataflowProperties {
    mode?: OperationalMode;
    operations: DataflowOperation[];
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface DataflowResource extends ProxyResource {
    extendedLocation: ExtendedLocation;
    properties?: DataflowProperties;
}

// @public
export interface DataflowSourceOperationSettings {
    assetRef?: string;
    dataSources: string[];
    endpointRef: string;
    schemaRef?: string;
    serializationFormat?: SourceSerializationFormat;
}

// @public
export type DataLakeStorageAuthMethod = ManagedIdentityMethod | AccessTokenMethod;

// @public
export interface DiagnosticsLogs {
    level?: string;
}

// @public
export interface DiskBackedMessageBuffer {
    ephemeralVolumeClaimSpec?: VolumeClaimSpec;
    maxSize: string;
    persistentVolumeClaimSpec?: VolumeClaimSpec;
}

// @public
export type EndpointType = string;

// @public
export interface ExtendedLocation {
    name: string;
    type: ExtendedLocationType;
}

// @public
export type ExtendedLocationType = string;

// @public
export type FabricOneLakeAuthMethod = ManagedIdentityMethod;

// @public
export type FilterType = string;

// @public
export interface Frontend {
    replicas: number;
    workers?: number;
}

// @public
export interface GenerateResourceLimits {
    cpu?: OperationalMode;
}

// @public
export interface InstancePatchModel {
    identity?: ManagedServiceIdentity;
    tags?: Record<string, string>;
}

// @public
export interface InstanceProperties {
    description?: string;
    readonly provisioningState?: ProvisioningState;
    schemaRegistryRef: SchemaRegistryRef;
    readonly version?: string;
}

// @public
export interface InstanceResource extends TrackedResource {
    extendedLocation: ExtendedLocation;
    identity?: ManagedServiceIdentity;
    properties?: InstanceProperties;
}

// @public
export type KafkaAuthMethod = ManagedIdentityMethod | SaslMethod | X509CertificateMethod | AnonymousMethod;

// @public
export enum KnownAccessTokenMethod {
    AccessToken = "AccessToken"
}

// @public
export enum KnownActionType {
    Internal = "Internal"
}

// @public
export enum KnownAnonymousMethod {
    Anonymous = "Anonymous"
}

// @public
export enum KnownBrokerAuthenticationMethod {
    Custom = "Custom",
    ServiceAccountToken = "ServiceAccountToken",
    X509 = "X509"
}

// @public
export enum KnownBrokerMemoryProfile {
    High = "High",
    Low = "Low",
    Medium = "Medium",
    Tiny = "Tiny"
}

// @public
export enum KnownBrokerProtocolType {
    Mqtt = "Mqtt",
    WebSockets = "WebSockets"
}

// @public
export enum KnownBrokerResourceDefinitionMethods {
    Connect = "Connect",
    Publish = "Publish",
    Subscribe = "Subscribe"
}

// @public
export enum KnownCertManagerIssuerKind {
    ClusterIssuer = "ClusterIssuer",
    Issuer = "Issuer"
}

// @public
export enum KnownCloudEventAttributeType {
    CreateOrRemap = "CreateOrRemap",
    Propagate = "Propagate"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDataflowEndpointAuthenticationSaslType {
    Plain = "Plain",
    ScramSha256 = "ScramSha256",
    ScramSha512 = "ScramSha512"
}

// @public
export enum KnownDataflowEndpointFabricPathType {
    Files = "Files",
    Tables = "Tables"
}

// @public
export enum KnownDataflowEndpointKafkaAcks {
    All = "All",
    One = "One",
    Zero = "Zero"
}

// @public
export enum KnownDataflowEndpointKafkaCompression {
    Gzip = "Gzip",
    Lz4 = "Lz4",
    None = "None",
    Snappy = "Snappy"
}

// @public
export enum KnownDataflowEndpointKafkaPartitionStrategy {
    Default = "Default",
    Property = "Property",
    Static = "Static",
    Topic = "Topic"
}

// @public
export enum KnownDataflowMappingType {
    BuiltInFunction = "BuiltInFunction",
    Compute = "Compute",
    NewProperties = "NewProperties",
    PassThrough = "PassThrough",
    Rename = "Rename"
}

// @public
export enum KnownEndpointType {
    DataExplorer = "DataExplorer",
    DataLakeStorage = "DataLakeStorage",
    FabricOneLake = "FabricOneLake",
    Kafka = "Kafka",
    LocalStorage = "LocalStorage",
    Mqtt = "Mqtt"
}

// @public
export enum KnownExtendedLocationType {
    CustomLocation = "CustomLocation"
}

// @public
export enum KnownFilterType {
    Filter = "Filter"
}

// @public
export enum KnownManagedIdentityMethod {
    SystemAssignedManagedIdentity = "SystemAssignedManagedIdentity",
    UserAssignedManagedIdentity = "UserAssignedManagedIdentity"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownMqttRetainType {
    Keep = "Keep",
    Never = "Never"
}

// @public
export enum KnownOperationalMode {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownOperationType {
    BuiltInTransformation = "BuiltInTransformation",
    Destination = "Destination",
    Source = "Source"
}

// @public
export enum KnownOperatorValues {
    DoesNotExist = "DoesNotExist",
    Exists = "Exists",
    In = "In",
    NotIn = "NotIn"
}

// @public
export enum KnownOrigin {
    System = "system",
    User = "user",
    UserSystem = "user,system"
}

// @public
export enum KnownPrivateKeyAlgorithm {
    Ec256 = "Ec256",
    Ec384 = "Ec384",
    Ec521 = "Ec521",
    Ed25519 = "Ed25519",
    Rsa2048 = "Rsa2048",
    Rsa4096 = "Rsa4096",
    Rsa8192 = "Rsa8192"
}

// @public
export enum KnownPrivateKeyRotationPolicy {
    Always = "Always",
    Never = "Never"
}

// @public
export enum KnownProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Deleting = "Deleting",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownSaslMethod {
    Sasl = "Sasl"
}

// @public
export enum KnownServiceAccountTokenMethod {
    ServiceAccountToken = "ServiceAccountToken"
}

// @public
export enum KnownServiceType {
    ClusterIp = "ClusterIp",
    LoadBalancer = "LoadBalancer",
    NodePort = "NodePort"
}

// @public
export enum KnownSourceSerializationFormat {
    Json = "Json"
}

// @public
export enum KnownStateStoreResourceDefinitionMethods {
    Read = "Read",
    ReadWrite = "ReadWrite",
    Write = "Write"
}

// @public
export enum KnownStateStoreResourceKeyTypes {
    Binary = "Binary",
    Pattern = "Pattern",
    String = "String"
}

// @public
export enum KnownSubscriberMessageDropStrategy {
    DropOldest = "DropOldest",
    None = "None"
}

// @public
export enum KnownTlsCertMethodMode {
    Automatic = "Automatic",
    Manual = "Manual"
}

// @public
export enum KnownTransformationSerializationFormat {
    Delta = "Delta",
    Json = "Json",
    Parquet = "Parquet"
}

// @public
export enum KnownX509CertificateMethod {
    X509Certificate = "X509Certificate"
}

// @public
export interface KubernetesReference {
    apiGroup?: string;
    kind: string;
    name: string;
    namespace?: string;
}

// @public
export interface ListenerPort {
    authenticationRef?: string;
    authorizationRef?: string;
    nodePort?: number;
    port: number;
    protocol?: BrokerProtocolType;
    tls?: TlsCertMethod;
}

// @public
export interface LocalKubernetesReference {
    apiGroup?: string;
    kind: string;
    name: string;
}

// @public
export type ManagedIdentityMethod = string;

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentity | null>;
}

// @public
export type ManagedServiceIdentityType = string;

// @public
export interface Metrics {
    prometheusPort?: number;
}

// @public
export type MqttAuthMethod = ManagedIdentityMethod | ServiceAccountTokenMethod | X509CertificateMethod | AnonymousMethod;

// @public
export type MqttRetainType = string;

// @public
export interface Operation {
    actionType?: ActionType;
    readonly display?: OperationDisplay;
    readonly isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: Origin;
}

// @public
export type OperationalMode = string;

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export type OperationType = string;

// @public
export type OperatorValues = string;

// @public
export type Origin = string;

// @public
export interface PrincipalDefinition {
    attributes?: Record<string, string>[];
    clientIds?: string[];
    usernames?: string[];
}

// @public
export type PrivateKeyAlgorithm = string;

// @public
export type PrivateKeyRotationPolicy = string;

// @public
export interface ProfileDiagnostics {
    logs?: DiagnosticsLogs;
    metrics?: Metrics;
}

// @public
export type ProvisioningState = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface SanForCert {
    dns: string[];
    ip: string[];
}

// @public
export type SaslMethod = string;

// @public
export interface SchemaRegistryRef {
    resourceId: string;
}

// @public
export interface SelfCheck {
    intervalSeconds?: number;
    mode?: OperationalMode;
    timeoutSeconds?: number;
}

// @public
export interface SelfTracing {
    intervalSeconds?: number;
    mode?: OperationalMode;
}

// @public
export type ServiceAccountTokenMethod = string;

// @public
export type ServiceType = string;

// @public
export type SourceSerializationFormat = string;

// @public
export type StateStoreResourceDefinitionMethods = string;

// @public
export type StateStoreResourceKeyTypes = string;

// @public
export interface StateStoreResourceRule {
    keys: string[];
    keyType: StateStoreResourceKeyTypes;
    method: StateStoreResourceDefinitionMethods;
}

// @public
export type SubscriberMessageDropStrategy = string;

// @public
export interface SubscriberQueueLimit {
    length?: number;
    strategy?: SubscriberMessageDropStrategy;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TlsCertMethod {
    certManagerCertificateSpec?: CertManagerCertificateSpec;
    manual?: X509ManualCertificate;
    mode: TlsCertMethodMode;
}

// @public
export type TlsCertMethodMode = string;

// @public
export interface TlsProperties {
    mode?: OperationalMode;
    trustedCaCertificateConfigMapRef?: string;
}

// @public
export interface Traces {
    cacheSizeMegabytes?: number;
    mode?: OperationalMode;
    selfTracing?: SelfTracing;
    spanChannelCapacity?: number;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export type TransformationSerializationFormat = string;

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface VolumeClaimResourceRequirements {
    limits?: Record<string, string>;
    requests?: Record<string, string>;
}

// @public
export interface VolumeClaimSpec {
    accessModes?: string[];
    dataSource?: LocalKubernetesReference;
    dataSourceRef?: KubernetesReference;
    resources?: VolumeClaimResourceRequirements;
    selector?: VolumeClaimSpecSelector;
    storageClassName?: string;
    volumeMode?: string;
    volumeName?: string;
}

// @public
export interface VolumeClaimSpecSelector {
    matchExpressions?: VolumeClaimSpecSelectorMatchExpressions[];
    matchLabels?: Record<string, string>;
}

// @public
export interface VolumeClaimSpecSelectorMatchExpressions {
    key: string;
    operator: OperatorValues;
    values?: string[];
}

// @public
export type X509CertificateMethod = string;

// @public
export interface X509ManualCertificate {
    secretRef: string;
}

// (No @packageDocumentation comment for this package)

```
