/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError, AzureServiceClientOptions } from "@azure/ms-rest-azure-js";
import * as msRest from "@azure/ms-rest-js";

export { BaseResource, CloudError };

/**
 * The input parameters to generate registration token for the Azure Video Analyzer IoT edge
 * module.
 */
export interface ListProvisioningTokenInput {
  /**
   * The desired expiration date of the registration token. The Azure Video Analyzer IoT edge
   * module must be initialized and connected to the Internet prior to the token expiration date.
   */
  expirationDate: Date;
}

/**
 * Provisioning token properties. A provisioning token allows for a single instance of Azure Video
 * analyzer IoT edge module to be initialized and authorized to the cloud account. The provisioning
 * token itself is short lived and it is only used for the initial handshake between IoT edge
 * module and the cloud. After the initial handshake, the IoT edge module will agree on a set of
 * authentication keys which will be auto-rotated as long as the module is able to periodically
 * connect to the cloud. A new provisioning token can be generated for the same IoT edge module in
 * case the module state lost or reset.
 */
export interface EdgeModuleProvisioningToken {
  /**
   * The expiration date of the registration token. The Azure Video Analyzer IoT edge module must
   * be initialized and connected to the Internet prior to the token expiration date.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly expirationDate?: Date;
  /**
   * The token blob to be provided to the Azure Video Analyzer IoT edge module through the Azure
   * IoT Edge module twin properties.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly token?: string;
}

/**
 * Common fields that are returned in the response for all Azure Resource Manager resources
 * @summary Resource
 */
export interface Resource extends BaseResource {
  /**
   * Fully qualified resource ID for the resource. Ex -
   * /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
  /**
   * The name of the resource
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
   * "Microsoft.Storage/storageAccounts"
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
  /**
   * Azure Resource Manager metadata containing createdBy and modifiedBy information.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly systemData?: SystemData;
}

/**
 * The resource model definition for a Azure Resource Manager proxy resource. It will not have tags
 * and a location
 * @summary Proxy Resource
 */
export interface ProxyResource extends Resource {
}

/**
 * The representation of an edge module.
 */
export interface EdgeModuleEntity extends ProxyResource {
  /**
   * Internal ID generated for the instance of the Video Analyzer edge module.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly edgeModuleId?: string;
}

/**
 * The resource management error additional info.
 */
export interface ErrorAdditionalInfo {
  /**
   * The additional info type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
  /**
   * The additional info.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly info?: any;
}

/**
 * The error detail.
 */
export interface ErrorDetail {
  /**
   * The error code.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly code?: string;
  /**
   * The error message.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message?: string;
  /**
   * The error target.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly target?: string;
  /**
   * The error details.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly details?: ErrorDetail[];
  /**
   * The error additional info.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly additionalInfo?: ErrorAdditionalInfo[];
}

/**
 * Common error response for all Azure Resource Manager APIs to return error details for failed
 * operations. (This also follows the OData error response format.).
 * @summary Error response
 */
export interface ErrorResponse {
  /**
   * The error object.
   */
  error?: ErrorDetail;
}

/**
 * Metadata pertaining to creation and last modification of the resource.
 */
export interface SystemData {
  /**
   * The identity that created the resource.
   */
  createdBy?: string;
  /**
   * The type of identity that created the resource. Possible values include: 'User',
   * 'Application', 'ManagedIdentity', 'Key'
   */
  createdByType?: CreatedByType;
  /**
   * The timestamp of resource creation (UTC).
   */
  createdAt?: Date;
  /**
   * The identity that last modified the resource.
   */
  lastModifiedBy?: string;
  /**
   * The type of identity that last modified the resource. Possible values include: 'User',
   * 'Application', 'ManagedIdentity', 'Key'
   */
  lastModifiedByType?: CreatedByType;
  /**
   * The timestamp of resource last modification (UTC)
   */
  lastModifiedAt?: Date;
}

/**
 * The resource model definition for an Azure Resource Manager tracked top level resource which has
 * 'tags' and a 'location'
 * @summary Tracked Resource
 */
export interface TrackedResource extends Resource {
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * The geo-location where the resource lives
   */
  location: string;
}

/**
 * The resource model definition for an Azure Resource Manager resource with an etag.
 * @summary Entity Resource
 */
export interface AzureEntityResource extends Resource {
  /**
   * Resource Etag.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly etag?: string;
}

/**
 * The SKU details.
 */
export interface Sku {
  /**
   * The SKU name. Possible values include: 'Live_S1', 'Batch_S1'
   */
  name: SkuName;
  /**
   * The SKU tier. Possible values include: 'Standard'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly tier?: SkuTier;
}

/**
 * Single topology parameter declaration. Declared parameters can and must be referenced throughout
 * the topology and can optionally have default values to be used when they are not defined in the
 * pipelines.
 */
export interface ParameterDeclaration {
  /**
   * Name of the parameter.
   */
  name: string;
  /**
   * Type of the parameter. Possible values include: 'String', 'SecretString', 'Int', 'Double',
   * 'Bool'
   */
  type: ParameterType;
  /**
   * Description of the parameter.
   */
  description?: string;
  /**
   * The default value for the parameter to be used if the pipeline does not specify a value.
   */
  default?: string;
}

/**
 * Contains the possible cases for NodeBase.
 */
export type NodeBaseUnion = NodeBase | SourceNodeBaseUnion | ProcessorNodeBaseUnion | SinkNodeBaseUnion;

/**
 * Base class for nodes.
 */
export interface NodeBase {
  /**
   * Polymorphic Discriminator
   */
  type: "NodeBase";
  /**
   * Node name. Must be unique within the topology.
   */
  name: string;
}

/**
 * Contains the possible cases for SourceNodeBase.
 */
export type SourceNodeBaseUnion = SourceNodeBase | RtspSource | VideoSource;

/**
 * Base class for topology source nodes.
 */
export interface SourceNodeBase {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.SourceNodeBase";
  /**
   * Node name. Must be unique within the topology.
   */
  name: string;
}

/**
 * Describes an input signal to be used on a pipeline node.
 */
export interface NodeInput {
  /**
   * The name of the upstream node in the pipeline which output is used as input of the current
   * node.
   */
  nodeName: string;
}

/**
 * Contains the possible cases for ProcessorNodeBase.
 */
export type ProcessorNodeBaseUnion = ProcessorNodeBase | EncoderProcessor;

/**
 * Base class for topology processor nodes.
 */
export interface ProcessorNodeBase {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.ProcessorNodeBase";
  /**
   * Node name. Must be unique within the topology.
   */
  name: string;
  /**
   * An array of upstream node references within the topology to be used as inputs for this node.
   */
  inputs: NodeInput[];
}

/**
 * Contains the possible cases for SinkNodeBase.
 */
export type SinkNodeBaseUnion = SinkNodeBase | VideoSink;

/**
 * Base class for topology sink nodes.
 */
export interface SinkNodeBase {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.SinkNodeBase";
  /**
   * Node name. Must be unique within the topology.
   */
  name: string;
  /**
   * An array of upstream node references within the topology to be used as inputs for this node.
   */
  inputs: NodeInput[];
}

/**
 * Contains the possible cases for CredentialsBase.
 */
export type CredentialsBaseUnion = CredentialsBase | UsernamePasswordCredentials;

/**
 * Base class for credential objects.
 */
export interface CredentialsBase {
  /**
   * Polymorphic Discriminator
   */
  type: "CredentialsBase";
}

/**
 * Contains the possible cases for TunnelBase.
 */
export type TunnelBaseUnion = TunnelBase | SecureIotDeviceRemoteTunnel;

/**
 * Base class for tunnel objects.
 */
export interface TunnelBase {
  /**
   * Polymorphic Discriminator
   */
  type: "TunnelBase";
}

/**
 * Contains the possible cases for EndpointBase.
 */
export type EndpointBaseUnion = EndpointBase | UnsecuredEndpoint | TlsEndpoint;

/**
 * Base class for endpoints.
 */
export interface EndpointBase {
  /**
   * Polymorphic Discriminator
   */
  type: "EndpointBase";
  /**
   * Credentials to be presented to the endpoint.
   */
  credentials?: CredentialsBaseUnion;
  /**
   * The endpoint URL for Video Analyzer to connect to.
   */
  url: string;
  /**
   * Describes the tunnel through which Video Analyzer can connect to the endpoint URL. This is an
   * optional property, typically used when the endpoint is behind a firewall.
   */
  tunnel?: TunnelBaseUnion;
}

/**
 * RTSP source allows for media from an RTSP camera or generic RTSP server to be ingested into a
 * pipeline.
 */
export interface RtspSource {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.RtspSource";
  /**
   * Node name. Must be unique within the topology.
   */
  name: string;
  /**
   * Network transport utilized by the RTSP and RTP exchange: TCP or HTTP. When using TCP, the RTP
   * packets are interleaved on the TCP RTSP connection. When using HTTP, the RTSP messages are
   * exchanged through long lived HTTP connections, and the RTP packages are interleaved in the
   * HTTP connections alongside the RTSP messages. Possible values include: 'Http', 'Tcp'
   */
  transport?: RtspTransport;
  /**
   * RTSP endpoint information for Video Analyzer to connect to. This contains the required
   * information for Video Analyzer to connect to RTSP cameras and/or generic RTSP servers.
   */
  endpoint: EndpointBaseUnion;
}

/**
 * Username and password credentials.
 */
export interface UsernamePasswordCredentials {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.UsernamePasswordCredentials";
  /**
   * Username to be presented as part of the credentials.
   */
  username: string;
  /**
   * Password to be presented as part of the credentials. It is recommended that this value is
   * parameterized as a secret string in order to prevent this value to be returned as part of the
   * resource on API requests.
   */
  password: string;
}

/**
 * A remote tunnel securely established using IoT Hub device information.
 */
export interface SecureIotDeviceRemoteTunnel {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.SecureIotDeviceRemoteTunnel";
  /**
   * Name of the IoT Hub.
   */
  iotHubName: string;
  /**
   * The IoT device id to use when establishing the remote tunnel. This string is case-sensitive.
   */
  deviceId: string;
}

/**
 * Unsecured endpoint describes an endpoint that the pipeline can connect to over clear transport
 * (no encryption in transit).
 */
export interface UnsecuredEndpoint {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.UnsecuredEndpoint";
  /**
   * Credentials to be presented to the endpoint.
   */
  credentials?: CredentialsBaseUnion;
  /**
   * The endpoint URL for Video Analyzer to connect to.
   */
  url: string;
  /**
   * Describes the tunnel through which Video Analyzer can connect to the endpoint URL. This is an
   * optional property, typically used when the endpoint is behind a firewall.
   */
  tunnel?: TunnelBaseUnion;
}

/**
 * Contains the possible cases for CertificateSource.
 */
export type CertificateSourceUnion = CertificateSource | PemCertificateList;

/**
 * Base class for certificate sources.
 */
export interface CertificateSource {
  /**
   * Polymorphic Discriminator
   */
  type: "CertificateSource";
}

/**
 * Options for controlling the validation of TLS endpoints.
 */
export interface TlsValidationOptions {
  /**
   * When set to 'true' causes the certificate subject name validation to be skipped. Default is
   * 'false'.
   */
  ignoreHostname?: string;
  /**
   * When set to 'true' causes the certificate chain trust validation to be skipped. Default is
   * 'false'.
   */
  ignoreSignature?: string;
}

/**
 * TLS endpoint describes an endpoint that the pipeline can connect to over TLS transport (data is
 * encrypted in transit).
 */
export interface TlsEndpoint {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.TlsEndpoint";
  /**
   * Credentials to be presented to the endpoint.
   */
  credentials?: CredentialsBaseUnion;
  /**
   * The endpoint URL for Video Analyzer to connect to.
   */
  url: string;
  /**
   * Describes the tunnel through which Video Analyzer can connect to the endpoint URL. This is an
   * optional property, typically used when the endpoint is behind a firewall.
   */
  tunnel?: TunnelBaseUnion;
  /**
   * List of trusted certificate authorities when authenticating a TLS connection. A null list
   * designates that Azure Video Analyzer's list of trusted authorities should be used.
   */
  trustedCertificates?: CertificateSourceUnion;
  /**
   * Validation options to use when authenticating a TLS connection. By default, strict validation
   * is used.
   */
  validationOptions?: TlsValidationOptions;
}

/**
 * A list of PEM formatted certificates.
 */
export interface PemCertificateList {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.PemCertificateList";
  /**
   * PEM formatted public certificates. One certificate per entry.
   */
  certificates: string[];
}

/**
 * Contains the possible cases for TimeSequenceBase.
 */
export type TimeSequenceBaseUnion = TimeSequenceBase | VideoSequenceAbsoluteTimeMarkers;

/**
 * A sequence of datetime ranges as a string.
 */
export interface TimeSequenceBase {
  /**
   * Polymorphic Discriminator
   */
  type: "TimeSequenceBase";
}

/**
 * Video source allows for content from a Video Analyzer video resource to be ingested into a
 * pipeline. Currently supported only with batch pipelines.
 */
export interface VideoSource {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.VideoSource";
  /**
   * Node name. Must be unique within the topology.
   */
  name: string;
  /**
   * Name of the Video Analyzer video resource to be used as the source.
   */
  videoName: string;
  /**
   * Describes a sequence of datetime ranges. The video source only picks up recorded media within
   * these ranges.
   */
  timeSequences: TimeSequenceBaseUnion;
}

/**
 * A sequence of absolute datetime ranges as a string. The datetime values should follow IS08601,
 * and the sum of the ranges should add up to 24 hours or less. Currently, there can be only one
 * range specified in the sequence.
 */
export interface VideoSequenceAbsoluteTimeMarkers {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.VideoSequenceAbsoluteTimeMarkers";
  /**
   * The sequence of datetime ranges. Example: '[["2021-10-05T03:30:00Z",
   * "2021-10-05T03:40:00Z"]]'.
   */
  ranges: string;
}

/**
 * Contains the possible cases for EncoderPresetBase.
 */
export type EncoderPresetBaseUnion = EncoderPresetBase | EncoderSystemPreset | EncoderCustomPreset;

/**
 * Base type for all encoder presets, which define the recipe or instructions on how the input
 * content should be processed.
 */
export interface EncoderPresetBase {
  /**
   * Polymorphic Discriminator
   */
  type: "EncoderPresetBase";
}

/**
 * Encoder processor allows for encoding of the input content. For example, it can used to change
 * the resolution from 4K to 1280x720.
 */
export interface EncoderProcessor {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.EncoderProcessor";
  /**
   * Node name. Must be unique within the topology.
   */
  name: string;
  /**
   * An array of upstream node references within the topology to be used as inputs for this node.
   */
  inputs: NodeInput[];
  /**
   * The encoder preset, which defines the recipe or instructions on how the input content should
   * be processed.
   */
  preset: EncoderPresetBaseUnion;
}

/**
 * Describes a built-in preset for encoding the input content using the encoder processor.
 */
export interface EncoderSystemPreset {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.EncoderSystemPreset";
  /**
   * Name of the built-in encoding preset. Possible values include: 'SingleLayer_540p_H264_AAC',
   * 'SingleLayer_720p_H264_AAC', 'SingleLayer_1080p_H264_AAC', 'SingleLayer_2160p_H264_AAC'
   */
  name: EncoderSystemPresetType;
}

/**
 * Contains the possible cases for AudioEncoderBase.
 */
export type AudioEncoderBaseUnion = AudioEncoderBase | AudioEncoderAac;

/**
 * Base type for all audio encoder presets, which define the recipe or instructions on how audio
 * should be processed.
 */
export interface AudioEncoderBase {
  /**
   * Polymorphic Discriminator
   */
  type: "AudioEncoderBase";
  /**
   * Bitrate, in kilobits per second or Kbps, at which audio should be encoded (2-channel stereo
   * audio at a sampling rate of 48 kHz). Allowed values are 96, 112, 128, 160, 192, 224, and 256.
   * If omitted, the bitrate of the input audio is used.
   */
  bitrateKbps?: string;
}

/**
 * The video scaling information.
 */
export interface VideoScale {
  /**
   * The desired output video height.
   */
  height?: string;
  /**
   * The desired output video width.
   */
  width?: string;
  /**
   * Describes the video scaling mode to be applied. Default mode is 'Pad'. If the mode is 'Pad' or
   * 'Stretch' then both width and height must be specified. Else if the mode is
   * 'PreserveAspectRatio' then only one of width or height need be provided. Possible values
   * include: 'Pad', 'PreserveAspectRatio', 'Stretch'
   */
  mode?: VideoScaleMode;
}

/**
 * Contains the possible cases for VideoEncoderBase.
 */
export type VideoEncoderBaseUnion = VideoEncoderBase | VideoEncoderH264;

/**
 * Base type for all video encoding presets, which define the recipe or instructions on how the
 * input video should be processed.
 */
export interface VideoEncoderBase {
  /**
   * Polymorphic Discriminator
   */
  type: "VideoEncoderBase";
  /**
   * The maximum bitrate, in kilobits per second or Kbps, at which video should be encoded. If
   * omitted, encoder sets it automatically to try and match the quality of the input video.
   */
  bitrateKbps?: string;
  /**
   * The frame rate (in frames per second) of the encoded video. The value must be greater than
   * zero, and less than or equal to 300. If omitted, the encoder uses the average frame rate of
   * the input video.
   */
  frameRate?: string;
  /**
   * Describes the resolution of the encoded video. If omitted, the encoder uses the resolution of
   * the input video.
   */
  scale?: VideoScale;
}

/**
 * Describes a custom preset for encoding the input content using the encoder processor.
 */
export interface EncoderCustomPreset {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.EncoderCustomPreset";
  /**
   * Describes a custom preset for encoding audio.
   */
  audioEncoder?: AudioEncoderBaseUnion;
  /**
   * Describes a custom preset for encoding video.
   */
  videoEncoder?: VideoEncoderBaseUnion;
}

/**
 * A custom preset for encoding audio with the AAC codec.
 */
export interface AudioEncoderAac {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.AudioEncoderAac";
  /**
   * Bitrate, in kilobits per second or Kbps, at which audio should be encoded (2-channel stereo
   * audio at a sampling rate of 48 kHz). Allowed values are 96, 112, 128, 160, 192, 224, and 256.
   * If omitted, the bitrate of the input audio is used.
   */
  bitrateKbps?: string;
}

/**
 * A custom preset for encoding video with the H.264 (AVC) codec.
 */
export interface VideoEncoderH264 {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.VideoEncoderH264";
  /**
   * The maximum bitrate, in kilobits per second or Kbps, at which video should be encoded. If
   * omitted, encoder sets it automatically to try and match the quality of the input video.
   */
  bitrateKbps?: string;
  /**
   * The frame rate (in frames per second) of the encoded video. The value must be greater than
   * zero, and less than or equal to 300. If omitted, the encoder uses the average frame rate of
   * the input video.
   */
  frameRate?: string;
  /**
   * Describes the resolution of the encoded video. If omitted, the encoder uses the resolution of
   * the input video.
   */
  scale?: VideoScale;
}

/**
 * Optional properties to be used in case a new video resource needs to be created on the service.
 * These will not take effect if the video already exists.
 */
export interface VideoCreationProperties {
  /**
   * Optional title provided by the user. Value can be up to 256 characters long.
   */
  title?: string;
  /**
   * Optional description provided by the user. Value can be up to 2048 characters long.
   */
  description?: string;
  /**
   * Segment length indicates the length of individual content files (segments) which are persisted
   * to storage. Smaller segments provide lower archive playback latency but generate larger volume
   * of storage transactions. Larger segments reduce the amount of storage transactions while
   * increasing the archive playback latency. Value must be specified in ISO8601 duration format
   * (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes, in 30 seconds
   * increments. Changing this value after the initial call to create the video resource can lead
   * to errors when uploading content to the archive. Default value is 30 seconds. This property is
   * only allowed for topologies where "kind" is set to "live".
   */
  segmentLength?: string;
  /**
   * Video retention period indicates how long the video is kept in storage. Value must be
   * specified in ISO8601 duration format (i.e. "PT1D" equals 1 day) and can vary between 1 day to
   * 10 years, in 1 day increments. When absent (null), all video content is retained indefinitely.
   * This property is only allowed for topologies where "kind" is set to "live".
   */
  retentionPeriod?: string;
}

/**
 * Optional flags used to change how video is published. These are only allowed for topologies
 * where "kind" is set to "live".
 */
export interface VideoPublishingOptions {
  /**
   * When set to 'true' content will not be archived or recorded. This is used, for example, when
   * the topology is used only for low latency video streaming. Default is 'false'.  If set to
   * 'true', then "disableRtspPublishing" must be set to 'false'.
   */
  disableArchive?: string;
  /**
   * When set to 'true' the RTSP playback URL will not be published, disabling low latency
   * streaming. This is used, for example, when the topology is used only for archiving content.
   * Default is 'false'.  If set to 'true', then "disableArchive" must be set to 'false'.
   */
  disableRtspPublishing?: string;
}

/**
 * Video sink in a live topology allows for video and audio to be captured, optionally archived,
 * and published via a video resource. If archiving is enabled, this results in a video of type
 * 'archive'. If used in a batch topology, this allows for video and audio to be stored as a file,
 * and published via a video resource of type 'file'
 */
export interface VideoSink {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.VideoSink";
  /**
   * Node name. Must be unique within the topology.
   */
  name: string;
  /**
   * An array of upstream node references within the topology to be used as inputs for this node.
   */
  inputs: NodeInput[];
  /**
   * Name of a new or existing video resource used to capture and publish content. Note: if
   * downstream of RTSP source, and if disableArchive is set to true, then no content is archived.
   */
  videoName: string;
  /**
   * Optional video properties to be used in case a new video resource needs to be created on the
   * service.
   */
  videoCreationProperties?: VideoCreationProperties;
  /**
   * Options to change how the video sink publishes content via the video resource. This property
   * is only allowed for topologies where "kind" is set to "live".
   */
  videoPublishingOptions?: VideoPublishingOptions;
}

/**
 * Defines the parameter value of an specific pipeline topology parameter. See pipeline topology
 * parameters for more information.
 */
export interface ParameterDefinition {
  /**
   * Name of the parameter declared in the pipeline topology.
   */
  name: string;
  /**
   * Parameter value to be applied on this specific pipeline.
   */
  value?: string;
}

/**
 * Pipeline topology describes the processing steps to be applied when processing content for a
 * particular outcome. The topology should be defined according to the scenario to be achieved and
 * can be reused across many pipeline instances which share the same processing characteristics.
 * For instance, a pipeline topology which captures content from a RTSP camera and archives the
 * content can be reused across many different cameras, as long as the same processing is to be
 * applied across all the cameras. Individual instance properties can be defined through the use of
 * user-defined parameters, which allow for a topology to be parameterized. This allows  individual
 * pipelines refer to different values, such as individual cameras' RTSP endpoints and credentials.
 * Overall a topology is composed of the following:
 *
 * - Parameters: list of user defined parameters that can be references across the topology nodes.
 * - Sources: list of one or more data sources nodes such as an RTSP source which allows for
 * content to be ingested from cameras.
 * - Processors: list of nodes which perform data analysis or transformations.
 * - Sinks: list of one or more data sinks which allow for data to be stored or exported to other
 * destinations.
 */
export interface PipelineTopology extends ProxyResource {
  /**
   * An optional description of the pipeline topology. It is recommended that the expected use of
   * the topology to be described here.
   */
  description?: string;
  /**
   * List of the topology parameter declarations. Parameters declared here can be referenced
   * throughout the topology nodes through the use of "${PARAMETER_NAME}" string pattern.
   * Parameters can have optional default values and can later be defined in individual instances
   * of the pipeline.
   */
  parameters?: ParameterDeclaration[];
  /**
   * List of the topology source nodes. Source nodes enable external data to be ingested by the
   * pipeline.
   */
  sources: SourceNodeBaseUnion[];
  /**
   * List of the topology processor nodes. Processor nodes enable pipeline data to be analyzed,
   * processed or transformed.
   */
  processors?: ProcessorNodeBaseUnion[];
  /**
   * List of the topology sink nodes. Sink nodes allow pipeline data to be stored or exported.
   */
  sinks: SinkNodeBaseUnion[];
  /**
   * Topology kind. Possible values include: 'Live', 'Batch'
   */
  kind: Kind;
  /**
   * Describes the properties of a SKU.
   */
  sku: Sku;
}

/**
 * Pipeline topology describes the processing steps to be applied when processing content for a
 * particular outcome. The topology should be defined according to the scenario to be achieved and
 * can be reused across many pipeline instances which share the same processing characteristics.
 * For instance, a pipeline topology which captures content from a RTSP camera and archives the
 * content can be reused across many different cameras, as long as the same processing is to be
 * applied across all the cameras. Individual instance properties can be defined through the use of
 * user-defined parameters, which allow for a topology to be parameterized. This allows  individual
 * pipelines refer to different values, such as individual cameras' RTSP endpoints and credentials.
 * Overall a topology is composed of the following:
 *
 * - Parameters: list of user defined parameters that can be references across the topology nodes.
 * - Sources: list of one or more data sources nodes such as an RTSP source which allows for
 * content to be ingested from cameras.
 * - Processors: list of nodes which perform data analysis or transformations.
 * - Sinks: list of one or more data sinks which allow for data to be stored or exported to other
 * destinations.
 */
export interface PipelineTopologyUpdate extends ProxyResource {
  /**
   * An optional description of the pipeline topology. It is recommended that the expected use of
   * the topology to be described here.
   */
  description?: string;
  /**
   * List of the topology parameter declarations. Parameters declared here can be referenced
   * throughout the topology nodes through the use of "${PARAMETER_NAME}" string pattern.
   * Parameters can have optional default values and can later be defined in individual instances
   * of the pipeline.
   */
  parameters?: ParameterDeclaration[];
  /**
   * List of the topology source nodes. Source nodes enable external data to be ingested by the
   * pipeline.
   */
  sources?: SourceNodeBaseUnion[];
  /**
   * List of the topology processor nodes. Processor nodes enable pipeline data to be analyzed,
   * processed or transformed.
   */
  processors?: ProcessorNodeBaseUnion[];
  /**
   * List of the topology sink nodes. Sink nodes allow pipeline data to be stored or exported.
   */
  sinks?: SinkNodeBaseUnion[];
  /**
   * Topology kind. Possible values include: 'Live', 'Batch'
   */
  kind?: Kind;
  /**
   * Describes the properties of a SKU.
   */
  sku?: Sku;
}

/**
 * Live pipeline represents a unique instance of a live topology, used for real-time ingestion,
 * archiving and publishing of content for a unique RTSP camera.
 */
export interface LivePipeline extends ProxyResource {
  /**
   * The reference to an existing pipeline topology defined for real-time content processing. When
   * activated, this live pipeline will process content according to the pipeline topology
   * definition.
   */
  topologyName: string;
  /**
   * An optional description for the pipeline.
   */
  description?: string;
  /**
   * Maximum bitrate capacity in Kbps reserved for the live pipeline. The allowed range is from 500
   * to 3000 Kbps in increments of 100 Kbps. If the RTSP camera exceeds this capacity, then the
   * service will disconnect temporarily from the camera. It will retry to re-establish connection
   * (with exponential backoff), checking to see if the camera bitrate is now below the reserved
   * capacity. Doing so will ensure that one 'noisy neighbor' does not affect other live pipelines
   * in your account.
   */
  bitrateKbps: number;
  /**
   * Current state of the pipeline (read-only). Possible values include: 'Inactive', 'Activating',
   * 'Active', 'Deactivating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly state?: LivePipelineState;
  /**
   * List of the instance level parameter values for the user-defined topology parameters. A
   * pipeline can only define or override parameters values for parameters which have been declared
   * in the referenced topology. Topology parameters without a default value must be defined.
   * Topology parameters with a default value can be optionally be overridden.
   */
  parameters?: ParameterDefinition[];
}

/**
 * Live pipeline represents a unique instance of a live topology, used for real-time ingestion,
 * archiving and publishing of content for a unique RTSP camera.
 */
export interface LivePipelineUpdate extends ProxyResource {
  /**
   * The reference to an existing pipeline topology defined for real-time content processing. When
   * activated, this live pipeline will process content according to the pipeline topology
   * definition.
   */
  topologyName?: string;
  /**
   * An optional description for the pipeline.
   */
  description?: string;
  /**
   * Maximum bitrate capacity in Kbps reserved for the live pipeline. The allowed range is from 500
   * to 3000 Kbps in increments of 100 Kbps. If the RTSP camera exceeds this capacity, then the
   * service will disconnect temporarily from the camera. It will retry to re-establish connection
   * (with exponential backoff), checking to see if the camera bitrate is now below the reserved
   * capacity. Doing so will ensure that one 'noisy neighbor' does not affect other live pipelines
   * in your account.
   */
  bitrateKbps?: number;
  /**
   * Current state of the pipeline (read-only). Possible values include: 'Inactive', 'Activating',
   * 'Active', 'Deactivating'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly state?: LivePipelineState;
  /**
   * List of the instance level parameter values for the user-defined topology parameters. A
   * pipeline can only define or override parameters values for parameters which have been declared
   * in the referenced topology. Topology parameters without a default value must be defined.
   * Topology parameters with a default value can be optionally be overridden.
   */
  parameters?: ParameterDefinition[];
}

/**
 * Details about the error for a failed pipeline job.
 */
export interface PipelineJobError {
  /**
   * The error code.
   */
  code?: string;
  /**
   * The error message.
   */
  message?: string;
}

/**
 * Pipeline job represents a unique instance of a batch topology, used for offline processing of
 * selected portions of archived content.
 */
export interface PipelineJob extends ProxyResource {
  /**
   * Reference to an existing pipeline topology. When activated, this pipeline job will process
   * content according to the pipeline topology definition.
   */
  topologyName: string;
  /**
   * An optional description for the pipeline.
   */
  description?: string;
  /**
   * Current state of the pipeline (read-only). Possible values include: 'Processing', 'Canceled',
   * 'Completed', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly state?: PipelineJobState;
  /**
   * The date-time by when this pipeline job will be automatically deleted from your account.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly expiration?: Date;
  /**
   * Details about the error, in case the pipeline job fails.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly error?: PipelineJobError;
  /**
   * List of the instance level parameter values for the user-defined topology parameters. A
   * pipeline can only define or override parameters values for parameters which have been declared
   * in the referenced topology. Topology parameters without a default value must be defined.
   * Topology parameters with a default value can be optionally be overridden.
   */
  parameters?: ParameterDefinition[];
}

/**
 * Pipeline job represents a unique instance of a batch topology, used for offline processing of
 * selected portions of archived content.
 */
export interface PipelineJobUpdate extends ProxyResource {
  /**
   * Reference to an existing pipeline topology. When activated, this pipeline job will process
   * content according to the pipeline topology definition.
   */
  topologyName?: string;
  /**
   * An optional description for the pipeline.
   */
  description?: string;
  /**
   * Current state of the pipeline (read-only). Possible values include: 'Processing', 'Canceled',
   * 'Completed', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly state?: PipelineJobState;
  /**
   * The date-time by when this pipeline job will be automatically deleted from your account.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly expiration?: Date;
  /**
   * Details about the error, in case the pipeline job fails.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly error?: PipelineJobError;
  /**
   * List of the instance level parameter values for the user-defined topology parameters. A
   * pipeline can only define or override parameters values for parameters which have been declared
   * in the referenced topology. Topology parameters without a default value must be defined.
   * Topology parameters with a default value can be optionally be overridden.
   */
  parameters?: ParameterDefinition[];
}

/**
 * Used for tracking the status of an operation on the live pipeline.
 */
export interface LivePipelineOperationStatus {
  /**
   * The name of the live pipeline operation.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The status of the live pipeline operation.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: string;
  /**
   * The error details for the live pipeline operation.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly error?: ErrorDetail;
}

/**
 * Used for tracking the status of an operation on the pipeline job.
 */
export interface PipelineJobOperationStatus {
  /**
   * The name of the pipeline job operation.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The status of the pipeline job operation.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: string;
  /**
   * The error details for the pipeline job operation.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly error?: ErrorDetail;
}

/**
 * Operation details.
 */
export interface OperationDisplay {
  /**
   * The service provider.
   */
  provider?: string;
  /**
   * Resource on which the operation is performed.
   */
  resource?: string;
  /**
   * The operation type.
   */
  operation?: string;
  /**
   * The operation description.
   */
  description?: string;
}

/**
 * A metric dimension.
 */
export interface MetricDimension {
  /**
   * The metric dimension name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The display name for the dimension.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly displayName?: string;
  /**
   * Whether to export metric to shoebox.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly toBeExportedForShoebox?: boolean;
}

/**
 * A metric emitted by service.
 */
export interface MetricSpecification {
  /**
   * The metric name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The metric display name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly displayName?: string;
  /**
   * The metric display description.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly displayDescription?: string;
  /**
   * The metric unit. Possible values include: 'Bytes', 'Count', 'Milliseconds'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly unit?: MetricUnit;
  /**
   * The metric aggregation type. Possible values include: 'Average', 'Count', 'Total'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly aggregationType?: MetricAggregationType;
  /**
   * The metric lock aggregation type. Possible values include: 'Average', 'Count', 'Total'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly lockAggregationType?: MetricAggregationType;
  /**
   * Supported aggregation types.
   */
  supportedAggregationTypes?: string[];
  /**
   * The metric dimensions.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly dimensions?: MetricDimension[];
  /**
   * Indicates whether regional MDM account is enabled.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly enableRegionalMdmAccount?: boolean;
  /**
   * The source MDM account.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly sourceMdmAccount?: string;
  /**
   * The source MDM namespace.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly sourceMdmNamespace?: string;
  /**
   * The supported time grain types.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly supportedTimeGrainTypes?: string[];
}

/**
 * A diagnostic log emitted by service.
 */
export interface LogSpecification {
  /**
   * The diagnostic log category name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * The diagnostic log category display name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly displayName?: string;
  /**
   * The time range for requests in each blob.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly blobDuration?: string;
}

/**
 * The service metric specifications.
 */
export interface ServiceSpecification {
  /**
   * List of log specifications.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly logSpecifications?: LogSpecification[];
  /**
   * List of metric specifications.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly metricSpecifications?: MetricSpecification[];
}

/**
 * Metric properties.
 */
export interface Properties {
  /**
   * The service specifications.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly serviceSpecification?: ServiceSpecification;
}

/**
 * An operation.
 */
export interface Operation {
  /**
   * The operation name.
   */
  name: string;
  /**
   * The operation display name.
   */
  display?: OperationDisplay;
  /**
   * Origin of the operation.
   */
  origin?: string;
  /**
   * Operation properties format.
   */
  properties?: Properties;
  /**
   * Whether the operation applies to data-plane.
   */
  isDataAction?: boolean;
  /**
   * Indicates the action type. Possible values include: 'Internal'
   */
  actionType?: ActionType;
}

/**
 * The user assigned managed identity to use when accessing a resource.
 */
export interface ResourceIdentity {
  /**
   * The user assigned managed identity's resource identifier to use when accessing a resource.
   */
  userAssignedIdentity: string;
}

/**
 * The details about the associated storage account.
 */
export interface StorageAccount {
  /**
   * The ID of the storage account resource. Video Analyzer relies on tables, queues, and blobs.
   * The primary storage account must be a Standard Storage account (either
   * Microsoft.ClassicStorage or Microsoft.Storage).
   */
  id: string;
  /**
   * A managed identity that Video Analyzer will use to access the storage account.
   */
  identity?: ResourceIdentity;
  /**
   * The current status of the storage account mapping.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: string;
}

/**
 * The endpoint details.
 */
export interface Endpoint {
  /**
   * The URL of the endpoint.
   */
  endpointUrl?: string;
}

/**
 * The details for accessing the encryption keys in Key Vault.
 */
export interface KeyVaultProperties {
  /**
   * The URL of the Key Vault key used to encrypt the account. The key may either be versioned (for
   * example https://vault/keys/mykey/version1) or reference a key without a version (for example
   * https://vault/keys/mykey).
   */
  keyIdentifier: string;
  /**
   * The current key used to encrypt Video Analyzer account, including the key version.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly currentKeyIdentifier?: string;
}

/**
 * Defines how the Video Analyzer account is (optionally) encrypted.
 */
export interface AccountEncryption {
  /**
   * The type of key used to encrypt the Account Key. Possible values include: 'SystemKey',
   * 'CustomerKey'
   */
  type: AccountEncryptionKeyType;
  /**
   * The properties of the key used to encrypt the account.
   */
  keyVaultProperties?: KeyVaultProperties;
  /**
   * The Key Vault identity.
   */
  identity?: ResourceIdentity;
  /**
   * The current status of the Key Vault mapping.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: string;
}

/**
 * The IoT Hub details.
 */
export interface IotHub {
  /**
   * The IoT Hub resource identifier.
   */
  id: string;
  /**
   * The IoT Hub identity.
   */
  identity: ResourceIdentity;
  /**
   * The current status of the Iot Hub mapping.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: string;
}

/**
 * Group level network access control.
 */
export interface GroupLevelAccessControl {
  /**
   * Whether or not public network access is allowed for specified resources under the Video
   * Analyzer account. Possible values include: 'Enabled', 'Disabled'
   */
  publicNetworkAccess?: PublicNetworkAccess;
}

/**
 * Network access control for video analyzer account.
 */
export interface NetworkAccessControl {
  /**
   * Public network access for integration group.
   */
  integration?: GroupLevelAccessControl;
  /**
   * Public network access for ingestion group.
   */
  ingestion?: GroupLevelAccessControl;
  /**
   * Public network access for consumption group.
   */
  consumption?: GroupLevelAccessControl;
}

/**
 * The Private Endpoint resource.
 */
export interface PrivateEndpoint {
  /**
   * The ARM identifier for Private Endpoint
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
}

/**
 * A collection of information about the state of the connection between service consumer and
 * provider.
 */
export interface PrivateLinkServiceConnectionState {
  /**
   * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the
   * service. Possible values include: 'Pending', 'Approved', 'Rejected'
   */
  status?: PrivateEndpointServiceConnectionStatus;
  /**
   * The reason for approval/rejection of the connection.
   */
  description?: string;
  /**
   * A message indicating if changes on the service provider require any updates on the consumer.
   */
  actionsRequired?: string;
}

/**
 * The Private Endpoint Connection resource.
 */
export interface PrivateEndpointConnection extends Resource {
  /**
   * The resource of private end point.
   */
  privateEndpoint?: PrivateEndpoint;
  /**
   * A collection of information about the state of the connection between service consumer and
   * provider.
   */
  privateLinkServiceConnectionState: PrivateLinkServiceConnectionState;
  /**
   * The provisioning state of the private endpoint connection resource. Possible values include:
   * 'Succeeded', 'Creating', 'Deleting', 'Failed'
   */
  provisioningState?: PrivateEndpointConnectionProvisioningState;
}

/**
 * The details of the user assigned managed identity used by the Video Analyzer resource.
 */
export interface UserAssignedManagedIdentity {
  /**
   * The client ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clientId?: string;
  /**
   * The principal ID.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly principalId?: string;
}

/**
 * The managed identity for the Video Analyzer resource.
 */
export interface VideoAnalyzerIdentity {
  /**
   * The identity type.
   */
  type: string;
  /**
   * The User Assigned Managed Identities.
   */
  userAssignedIdentities?: { [propertyName: string]: UserAssignedManagedIdentity };
}

/**
 * The Video Analyzer account.
 */
export interface VideoAnalyzerModel extends TrackedResource {
  /**
   * The storage accounts for this resource.
   */
  storageAccounts: StorageAccount[];
  /**
   * The endpoints associated with this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly endpoints?: Endpoint[];
  /**
   * The account encryption properties.
   */
  encryption?: AccountEncryption;
  /**
   * The IoT Hubs for this resource.
   */
  iotHubs?: IotHub[];
  /**
   * Whether or not public network access is allowed for resources under the Video Analyzer
   * account. Possible values include: 'Enabled', 'Disabled'
   */
  publicNetworkAccess?: PublicNetworkAccess;
  /**
   * Network access control for Video Analyzer.
   */
  networkAccessControl?: NetworkAccessControl;
  /**
   * Provisioning state of the Video Analyzer account. Possible values include: 'Failed',
   * 'InProgress', 'Succeeded'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: ProvisioningState;
  /**
   * Private Endpoint Connections created under Video Analyzer account.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly privateEndpointConnections?: PrivateEndpointConnection[];
  /**
   * The identities associated to the Video Analyzer resource.
   */
  identity?: VideoAnalyzerIdentity;
}

/**
 * The update operation for a Video Analyzer account.
 */
export interface VideoAnalyzerUpdate {
  /**
   * Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * The storage accounts for this resource.
   */
  storageAccounts?: StorageAccount[];
  /**
   * The endpoints associated with this resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly endpoints?: Endpoint[];
  /**
   * The account encryption properties.
   */
  encryption?: AccountEncryption;
  /**
   * The IoT Hubs for this resource.
   */
  iotHubs?: IotHub[];
  /**
   * Whether or not public network access is allowed for resources under the Video Analyzer
   * account. Possible values include: 'Enabled', 'Disabled'
   */
  publicNetworkAccess?: PublicNetworkAccess;
  /**
   * Network access control for Video Analyzer.
   */
  networkAccessControl?: NetworkAccessControl;
  /**
   * Provisioning state of the Video Analyzer account. Possible values include: 'Failed',
   * 'InProgress', 'Succeeded'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: ProvisioningState;
  /**
   * Private Endpoint Connections created under Video Analyzer account.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly privateEndpointConnections?: PrivateEndpointConnection[];
  /**
   * The identities associated to the Video Analyzer resource.
   */
  identity?: VideoAnalyzerIdentity;
}

/**
 * Status of private endpoint connection operation.
 */
export interface VideoAnalyzerPrivateEndpointConnectionOperationStatus {
  /**
   * Operation identifier.
   */
  name: string;
  /**
   * Operation resource ID.
   */
  id?: string;
  /**
   * Operation start time.
   */
  startTime?: string;
  /**
   * Operation end time.
   */
  endTime?: string;
  /**
   * Operation status.
   */
  status?: string;
  error?: ErrorDetail;
}

/**
 * Status of video analyzer operation.
 */
export interface VideoAnalyzerOperationStatus {
  /**
   * Operation identifier.
   */
  name: string;
  /**
   * Operation resource ID.
   */
  id?: string;
  /**
   * Operation start time.
   */
  startTime?: string;
  /**
   * Operation end time.
   */
  endTime?: string;
  /**
   * Operation status.
   */
  status?: string;
  error?: ErrorDetail;
}

/**
 * A collection of Operation items.
 */
export interface OperationCollection {
  /**
   * A collection of Operation items.
   */
  value?: Operation[];
}

/**
 * A collection of VideoAnalyzer items.
 */
export interface VideoAnalyzerCollection {
  /**
   * A collection of VideoAnalyzer items.
   */
  value?: VideoAnalyzerModel[];
}

/**
 * The check availability request body.
 */
export interface CheckNameAvailabilityRequest {
  /**
   * The name of the resource for which availability needs to be checked.
   */
  name?: string;
  /**
   * The resource type.
   */
  type?: string;
}

/**
 * The check availability result.
 */
export interface CheckNameAvailabilityResponse {
  /**
   * Indicates if the resource name is available.
   */
  nameAvailable?: boolean;
  /**
   * The reason why the given name is not available. Possible values include: 'Invalid',
   * 'AlreadyExists'
   */
  reason?: CheckNameAvailabilityReason;
  /**
   * Detailed reason why the given name is available.
   */
  message?: string;
}

/**
 * List of private endpoint connection associated with the specified storage account
 */
export interface PrivateEndpointConnectionListResult {
  /**
   * Array of private endpoint connections
   */
  value?: PrivateEndpointConnection[];
}

/**
 * A private link resource
 */
export interface PrivateLinkResource extends Resource {
  /**
   * The private link resource group id.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly groupId?: string;
  /**
   * The private link resource required member names.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly requiredMembers?: string[];
  /**
   * The private link resource Private link DNS zone name.
   */
  requiredZoneNames?: string[];
}

/**
 * A list of private link resources
 */
export interface PrivateLinkResourceListResult {
  /**
   * Array of private link resources
   */
  value?: PrivateLinkResource[];
}

/**
 * Video preview image URLs. These URLs can be used in conjunction with the video content
 * authorization token to download the most recent still image from the video archive in different
 * resolutions. They are available when the video type is 'archive' and preview images are enabled.
 */
export interface VideoPreviewImageUrls {
  /**
   * Low resolution preview image URL.
   */
  small?: string;
  /**
   * Medium resolution preview image URL.
   */
  medium?: string;
  /**
   * High resolution preview image URL.
   */
  large?: string;
}

/**
 * Set of URLs to the video content.
 */
export interface VideoContentUrls {
  /**
   * Video file download URL. This URL can be used in conjunction with the video content
   * authorization token to download the video MP4 file. The resulting MP4 file can be played on
   * any standard media player. It is available when the video type is 'file' and video file is
   * available for consumption.
   */
  downloadUrl?: string;
  /**
   * Video archive streaming base URL. The archived content can be automatically played by the
   * Azure Video Analyzer player widget. Alternatively, this URL can be used in conjunction with
   * the video content authorization token on any compatible DASH or HLS players by appending the
   * following to the base URL:
   *
   * - HLSv4:     /manifest(format=m3u8-aapl).m3u8
   * - HLS CMAF:  /manifest(format=m3u8-cmaf)
   * - DASH CMAF: /manifest(format=mpd-time-cmaf)
   *
   * Moreover, an ongoing video recording can be played in "live mode" with latencies which are
   * approximately double of the chosen video segment length. It is available when the video type
   * is 'archive' and video archiving is enabled.
   */
  archiveBaseUrl?: string;
  /**
   * Video low-latency streaming URL. The live content can be automatically played by the Azure
   * Video Analyzer player widget. Alternatively, this URL can be used in conjunction with the
   * video content authorization token to expose a WebSocket tunneled RTSP stream. It is available
   * when the video type is 'archive' and a live, low-latency feed is available from the source.
   */
  rtspTunnelUrl?: string;
  /**
   * Video preview image URLs. These URLs can be used in conjunction with the video content
   * authorization token to download the most recent still image from the video archive in
   * different resolutions. They are available when the video type is 'archive' and preview images
   * are enabled.
   */
  previewImageUrls?: VideoPreviewImageUrls;
}

/**
 * Video flags contain information about the available video actions and its dynamic properties
 * based on the current video state.
 */
export interface VideoFlags {
  /**
   * Value indicating whether or not the video can be streamed. Only "archive" type videos can be
   * streamed.
   */
  canStream: boolean;
  /**
   * Value indicating whether or not there has ever been data recorded or uploaded into the video.
   * Newly created videos have this value set to false.
   */
  hasData: boolean;
  /**
   * Value indicating whether or not the video is currently being referenced be an active pipeline.
   * The fact that is being referenced, doesn't necessarily indicate that data is being received.
   * For example, video recording may be gated on events or camera may not be accessible at the
   * time.
   */
  isInUse: boolean;
}

/**
 * Contains information about the video and audio content.
 */
export interface VideoMediaInfo {
  /**
   * Video segment length indicates the length of individual video files (segments) which are
   * persisted to storage. Smaller segments provide lower archive playback latency but generate
   * larger volume of storage transactions. Larger segments reduce the amount of storage
   * transactions while increasing the archive playback latency. Value must be specified in ISO8601
   * duration format (i.e. "PT30S" equals 30 seconds) and can vary between 30 seconds to 5 minutes,
   * in 30 seconds increments.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly segmentLength?: string;
}

/**
 * "Video content token grants access to the video content URLs."
 */
export interface VideoContentToken {
  /**
   * The content token expiration date in ISO8601 format (eg. 2021-01-01T00:00:00Z).
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly expirationDate?: Date;
  /**
   * The content token value to be added to the video content URL as the value for the "token"
   * query string parameter. The token is specific to a single video.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly token?: string;
}

/**
 * Video archival properties.
 */
export interface VideoArchival {
  /**
   * Video retention period indicates the maximum age of the video archive segments which are
   * intended to be kept in storage. It must be provided in the ISO8601 duration format in the
   * granularity of days, up to a maximum of 10 years. For example, if this is set to P30D (30
   * days), content older than 30 days will be periodically deleted. This value can be updated at
   * any time and the new desired retention period will be effective within 24 hours.
   */
  retentionPeriod?: string;
}

/**
 * Contains the possible cases for AuthenticationBase.
 */
export type AuthenticationBaseUnion = AuthenticationBase | JwtAuthentication;

/**
 * Base class for access policies authentication methods.
 */
export interface AuthenticationBase {
  /**
   * Polymorphic Discriminator
   */
  type: "AuthenticationBase";
}

/**
 * Properties for expected token claims.
 */
export interface TokenClaim {
  /**
   * Name of the claim which must be present on the token.
   */
  name: string;
  /**
   * Expected value of the claim to be present on the token.
   */
  value: string;
}

/**
 * Contains the possible cases for TokenKey.
 */
export type TokenKeyUnion = TokenKey | RsaTokenKey | EccTokenKey;

/**
 * Key properties for JWT token validation.
 */
export interface TokenKey {
  /**
   * Polymorphic Discriminator
   */
  type: "TokenKey";
  /**
   * JWT token key id. Validation keys are looked up based on the key id present on the JWT token
   * header.
   */
  kid: string;
}

/**
 * Properties for access validation based on JSON Web Tokens (JWT).
 */
export interface JwtAuthentication {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.JwtAuthentication";
  /**
   * List of expected token issuers. Token issuer is valid if it matches at least one of the given
   * values.
   */
  issuers?: string[];
  /**
   * List of expected token audiences. Token audience is valid if it matches at least one of the
   * given values.
   */
  audiences?: string[];
  /**
   * List of additional token claims to be validated. Token must contains all claims and respective
   * values for it to be valid.
   */
  claims?: TokenClaim[];
  /**
   * List of keys which can be used to validate access tokens. Having multiple keys allow for
   * seamless key rotation of the token signing key. Token signature must match exactly one key.
   */
  keys?: TokenKeyUnion[];
}

/**
 * Required validation properties for tokens generated with RSA algorithm.
 */
export interface RsaTokenKey {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.RsaTokenKey";
  /**
   * JWT token key id. Validation keys are looked up based on the key id present on the JWT token
   * header.
   */
  kid: string;
  /**
   * RSA algorithm to be used: RS256, RS384 or RS512. Possible values include: 'RS256', 'RS384',
   * 'RS512'
   */
  alg: AccessPolicyRsaAlgo;
  /**
   * RSA public key modulus.
   */
  n: string;
  /**
   * RSA public key exponent.
   */
  e: string;
}

/**
 * Required validation properties for tokens generated with Elliptical Curve algorithm.
 */
export interface EccTokenKey {
  /**
   * Polymorphic Discriminator
   */
  type: "#Microsoft.VideoAnalyzer.EccTokenKey";
  /**
   * JWT token key id. Validation keys are looked up based on the key id present on the JWT token
   * header.
   */
  kid: string;
  /**
   * Elliptical curve algorithm to be used: ES256, ES384 or ES512. Possible values include:
   * 'ES256', 'ES384', 'ES512'
   */
  alg: AccessPolicyEccAlgo;
  /**
   * X coordinate.
   */
  x: string;
  /**
   * Y coordinate.
   */
  y: string;
}

/**
 * Represents a video resource within Azure Video Analyzer. Videos can be ingested from RTSP
 * cameras through live pipelines or can be created by exporting sequences from existing captured
 * video through a pipeline job. Videos ingested through live pipelines can be streamed through
 * Azure Video Analyzer Player Widget or compatible players. Exported videos can be downloaded as
 * MP4 files.
 */
export interface VideoEntity extends ProxyResource {
  /**
   * Optional video title provided by the user. Value can be up to 256 characters long.
   */
  title?: string;
  /**
   * Optional video description provided by the user. Value can be up to 2048 characters long.
   */
  description?: string;
  /**
   * Video content type. Different content types are suitable for different applications and
   * scenarios. Possible values include: 'Archive', 'File'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly videoEntityType?: VideoType;
  /**
   * Video flags contain information about the available video actions and its dynamic properties
   * based on the current video state.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly flags?: VideoFlags;
  /**
   * Set of URLs to the video content.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly contentUrls?: VideoContentUrls;
  /**
   * Contains information about the video and audio content.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly mediaInfo?: VideoMediaInfo;
  /**
   * Video archival properties.
   */
  archival?: VideoArchival;
}

/**
 * Access policies help define the authentication rules, and control access to specific video
 * resources.
 */
export interface AccessPolicyEntity extends ProxyResource {
  /**
   * Defines the access level granted by this policy. Possible values include: 'Reader'
   */
  role?: AccessPolicyRole;
  /**
   * Authentication method to be used when validating client API access.
   */
  authentication?: AuthenticationBaseUnion;
}

/**
 * Optional Parameters.
 */
export interface EdgeModulesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface EdgeModulesListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface PipelineTopologiesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface PipelineTopologiesListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface LivePipelinesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface LivePipelinesListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface PipelineJobsListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface PipelineJobsListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Restricts the set of items returned.
   */
  filter?: string;
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface VideosListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface VideosListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface AccessPoliciesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface AccessPoliciesListNextOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies a non-negative integer n that limits the number of items returned from a collection.
   * The service returns the number of available items up to but not greater than the specified
   * value n.
   */
  top?: number;
}

/**
 * An interface representing VideoAnalyzerOptions.
 */
export interface VideoAnalyzerOptions extends AzureServiceClientOptions {
  baseUri?: string;
}

/**
 * Defines headers for CreateOrUpdate operation.
 */
export interface VideoAnalyzersCreateOrUpdateHeaders {
  /**
   * The recommended number of seconds to wait before calling the URI specified in
   * Azure-AsyncOperation.
   */
  retryAfter: number;
  /**
   * The URI to poll for completion status.
   */
  locationHeader: string;
  /**
   * The URI to poll for completion status.
   */
  azureAsyncOperation: string;
}

/**
 * Defines headers for Update operation.
 */
export interface VideoAnalyzersUpdateHeaders {
  /**
   * The recommended number of seconds to wait before calling the URI specified in
   * Azure-AsyncOperation.
   */
  retryAfter: number;
  /**
   * The URI to poll for completion status.
   */
  locationHeader: string;
  /**
   * The URI to poll for completion status.
   */
  azureAsyncOperation: string;
}

/**
 * Defines headers for CreateOrUpdate operation.
 */
export interface PrivateEndpointConnectionsCreateOrUpdateHeaders {
  /**
   * The recommended number of seconds to wait before calling the URI specified in
   * Azure-AsyncOperation.
   */
  retryAfter: number;
  /**
   * The URI to poll for completion status.
   */
  location: string;
  /**
   * The URI to poll for completion status.
   */
  azureAsyncOperation: string;
}

/**
 * @interface
 * A collection of EdgeModuleEntity items.
 * @extends Array<EdgeModuleEntity>
 */
export interface EdgeModuleEntityCollection extends Array<EdgeModuleEntity> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  nextLink?: string;
}

/**
 * @interface
 * A collection of PipelineTopology items.
 * @extends Array<PipelineTopology>
 */
export interface PipelineTopologyCollection extends Array<PipelineTopology> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  nextLink?: string;
}

/**
 * @interface
 * A collection of LivePipeline items.
 * @extends Array<LivePipeline>
 */
export interface LivePipelineCollection extends Array<LivePipeline> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  nextLink?: string;
}

/**
 * @interface
 * A collection of PipelineJob items.
 * @extends Array<PipelineJob>
 */
export interface PipelineJobCollection extends Array<PipelineJob> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  nextLink?: string;
}

/**
 * @interface
 * A collection of VideoEntity items.
 * @extends Array<VideoEntity>
 */
export interface VideoEntityCollection extends Array<VideoEntity> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  nextLink?: string;
}

/**
 * @interface
 * A collection of AccessPolicyEntity items.
 * @extends Array<AccessPolicyEntity>
 */
export interface AccessPolicyEntityCollection extends Array<AccessPolicyEntity> {
  /**
   * A link to the next page of the collection (when the collection contains too many results to
   * return in one response).
   */
  nextLink?: string;
}

/**
 * Defines values for CreatedByType.
 * Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
 * @readonly
 * @enum {string}
 */
export type CreatedByType = 'User' | 'Application' | 'ManagedIdentity' | 'Key';

/**
 * Defines values for SkuName.
 * Possible values include: 'Live_S1', 'Batch_S1'
 * @readonly
 * @enum {string}
 */
export type SkuName = 'Live_S1' | 'Batch_S1';

/**
 * Defines values for SkuTier.
 * Possible values include: 'Standard'
 * @readonly
 * @enum {string}
 */
export type SkuTier = 'Standard';

/**
 * Defines values for ParameterType.
 * Possible values include: 'String', 'SecretString', 'Int', 'Double', 'Bool'
 * @readonly
 * @enum {string}
 */
export type ParameterType = 'String' | 'SecretString' | 'Int' | 'Double' | 'Bool';

/**
 * Defines values for RtspTransport.
 * Possible values include: 'Http', 'Tcp'
 * @readonly
 * @enum {string}
 */
export type RtspTransport = 'Http' | 'Tcp';

/**
 * Defines values for EncoderSystemPresetType.
 * Possible values include: 'SingleLayer_540p_H264_AAC', 'SingleLayer_720p_H264_AAC',
 * 'SingleLayer_1080p_H264_AAC', 'SingleLayer_2160p_H264_AAC'
 * @readonly
 * @enum {string}
 */
export type EncoderSystemPresetType = 'SingleLayer_540p_H264_AAC' | 'SingleLayer_720p_H264_AAC' | 'SingleLayer_1080p_H264_AAC' | 'SingleLayer_2160p_H264_AAC';

/**
 * Defines values for VideoScaleMode.
 * Possible values include: 'Pad', 'PreserveAspectRatio', 'Stretch'
 * @readonly
 * @enum {string}
 */
export type VideoScaleMode = 'Pad' | 'PreserveAspectRatio' | 'Stretch';

/**
 * Defines values for Kind.
 * Possible values include: 'Live', 'Batch'
 * @readonly
 * @enum {string}
 */
export type Kind = 'Live' | 'Batch';

/**
 * Defines values for LivePipelineState.
 * Possible values include: 'Inactive', 'Activating', 'Active', 'Deactivating'
 * @readonly
 * @enum {string}
 */
export type LivePipelineState = 'Inactive' | 'Activating' | 'Active' | 'Deactivating';

/**
 * Defines values for PipelineJobState.
 * Possible values include: 'Processing', 'Canceled', 'Completed', 'Failed'
 * @readonly
 * @enum {string}
 */
export type PipelineJobState = 'Processing' | 'Canceled' | 'Completed' | 'Failed';

/**
 * Defines values for MetricUnit.
 * Possible values include: 'Bytes', 'Count', 'Milliseconds'
 * @readonly
 * @enum {string}
 */
export type MetricUnit = 'Bytes' | 'Count' | 'Milliseconds';

/**
 * Defines values for MetricAggregationType.
 * Possible values include: 'Average', 'Count', 'Total'
 * @readonly
 * @enum {string}
 */
export type MetricAggregationType = 'Average' | 'Count' | 'Total';

/**
 * Defines values for ActionType.
 * Possible values include: 'Internal'
 * @readonly
 * @enum {string}
 */
export type ActionType = 'Internal';

/**
 * Defines values for AccountEncryptionKeyType.
 * Possible values include: 'SystemKey', 'CustomerKey'
 * @readonly
 * @enum {string}
 */
export type AccountEncryptionKeyType = 'SystemKey' | 'CustomerKey';

/**
 * Defines values for PublicNetworkAccess.
 * Possible values include: 'Enabled', 'Disabled'
 * @readonly
 * @enum {string}
 */
export type PublicNetworkAccess = 'Enabled' | 'Disabled';

/**
 * Defines values for ProvisioningState.
 * Possible values include: 'Failed', 'InProgress', 'Succeeded'
 * @readonly
 * @enum {string}
 */
export type ProvisioningState = 'Failed' | 'InProgress' | 'Succeeded';

/**
 * Defines values for PrivateEndpointServiceConnectionStatus.
 * Possible values include: 'Pending', 'Approved', 'Rejected'
 * @readonly
 * @enum {string}
 */
export type PrivateEndpointServiceConnectionStatus = 'Pending' | 'Approved' | 'Rejected';

/**
 * Defines values for PrivateEndpointConnectionProvisioningState.
 * Possible values include: 'Succeeded', 'Creating', 'Deleting', 'Failed'
 * @readonly
 * @enum {string}
 */
export type PrivateEndpointConnectionProvisioningState = 'Succeeded' | 'Creating' | 'Deleting' | 'Failed';

/**
 * Defines values for CheckNameAvailabilityReason.
 * Possible values include: 'Invalid', 'AlreadyExists'
 * @readonly
 * @enum {string}
 */
export type CheckNameAvailabilityReason = 'Invalid' | 'AlreadyExists';

/**
 * Defines values for VideoType.
 * Possible values include: 'Archive', 'File'
 * @readonly
 * @enum {string}
 */
export type VideoType = 'Archive' | 'File';

/**
 * Defines values for AccessPolicyRsaAlgo.
 * Possible values include: 'RS256', 'RS384', 'RS512'
 * @readonly
 * @enum {string}
 */
export type AccessPolicyRsaAlgo = 'RS256' | 'RS384' | 'RS512';

/**
 * Defines values for AccessPolicyEccAlgo.
 * Possible values include: 'ES256', 'ES384', 'ES512'
 * @readonly
 * @enum {string}
 */
export type AccessPolicyEccAlgo = 'ES256' | 'ES384' | 'ES512';

/**
 * Defines values for AccessPolicyRole.
 * Possible values include: 'Reader'
 * @readonly
 * @enum {string}
 */
export type AccessPolicyRole = 'Reader';

/**
 * Contains response data for the list operation.
 */
export type EdgeModulesListResponse = EdgeModuleEntityCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EdgeModuleEntityCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type EdgeModulesGetResponse = EdgeModuleEntity & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EdgeModuleEntity;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type EdgeModulesCreateOrUpdateResponse = EdgeModuleEntity & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EdgeModuleEntity;
    };
};

/**
 * Contains response data for the listProvisioningToken operation.
 */
export type EdgeModulesListProvisioningTokenResponse = EdgeModuleProvisioningToken & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EdgeModuleProvisioningToken;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type EdgeModulesListNextResponse = EdgeModuleEntityCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EdgeModuleEntityCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PipelineTopologiesListResponse = PipelineTopologyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineTopologyCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PipelineTopologiesGetResponse = PipelineTopology & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineTopology;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type PipelineTopologiesCreateOrUpdateResponse = PipelineTopology & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineTopology;
    };
};

/**
 * Contains response data for the update operation.
 */
export type PipelineTopologiesUpdateResponse = PipelineTopology & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineTopology;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type PipelineTopologiesListNextResponse = PipelineTopologyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineTopologyCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type LivePipelinesListResponse = LivePipelineCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LivePipelineCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type LivePipelinesGetResponse = LivePipeline & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LivePipeline;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type LivePipelinesCreateOrUpdateResponse = LivePipeline & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LivePipeline;
    };
};

/**
 * Contains response data for the update operation.
 */
export type LivePipelinesUpdateResponse = LivePipeline & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LivePipeline;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type LivePipelinesListNextResponse = LivePipelineCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LivePipelineCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PipelineJobsListResponse = PipelineJobCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineJobCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PipelineJobsGetResponse = PipelineJob & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineJob;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type PipelineJobsCreateOrUpdateResponse = PipelineJob & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineJob;
    };
};

/**
 * Contains response data for the update operation.
 */
export type PipelineJobsUpdateResponse = PipelineJob & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineJob;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type PipelineJobsListNextResponse = PipelineJobCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineJobCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type LivePipelineOperationStatusesGetResponse = LivePipelineOperationStatus & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LivePipelineOperationStatus;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PipelineJobOperationStatusesGetResponse = PipelineJobOperationStatus & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PipelineJobOperationStatus;
    };
};

/**
 * Contains response data for the list operation.
 */
export type OperationsListResponse = OperationCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type VideoAnalyzersListResponse = VideoAnalyzerCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoAnalyzerCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type VideoAnalyzersGetResponse = VideoAnalyzerModel & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoAnalyzerModel;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type VideoAnalyzersCreateOrUpdateResponse = VideoAnalyzerModel & VideoAnalyzersCreateOrUpdateHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: VideoAnalyzersCreateOrUpdateHeaders;

      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoAnalyzerModel;
    };
};

/**
 * Contains response data for the update operation.
 */
export type VideoAnalyzersUpdateResponse = VideoAnalyzerModel & VideoAnalyzersUpdateHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: VideoAnalyzersUpdateHeaders;

      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoAnalyzerModel;
    };
};

/**
 * Contains response data for the listBySubscription operation.
 */
export type VideoAnalyzersListBySubscriptionResponse = VideoAnalyzerCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoAnalyzerCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PrivateLinkResourcesListResponse = PrivateLinkResourceListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateLinkResourceListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PrivateLinkResourcesGetResponse = PrivateLinkResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateLinkResource;
    };
};

/**
 * Contains response data for the list operation.
 */
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateEndpointConnectionListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateEndpointConnection;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type PrivateEndpointConnectionsCreateOrUpdateResponse = PrivateEndpointConnection & PrivateEndpointConnectionsCreateOrUpdateHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: PrivateEndpointConnectionsCreateOrUpdateHeaders;

      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateEndpointConnection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type OperationStatusesGetResponse = VideoAnalyzerPrivateEndpointConnectionOperationStatus & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoAnalyzerPrivateEndpointConnectionOperationStatus;
    };
};

/**
 * Contains response data for the get operation.
 */
export type OperationResultsGetResponse = PrivateEndpointConnection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PrivateEndpointConnection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type VideoAnalyzerOperationStatusesGetResponse = VideoAnalyzerOperationStatus & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoAnalyzerOperationStatus;
    };
};

/**
 * Contains response data for the get operation.
 */
export type VideoAnalyzerOperationResultsGetResponse = VideoAnalyzerModel & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoAnalyzerModel;
    };
};

/**
 * Contains response data for the checkNameAvailability operation.
 */
export type LocationsCheckNameAvailabilityResponse = CheckNameAvailabilityResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: CheckNameAvailabilityResponse;
    };
};

/**
 * Contains response data for the list operation.
 */
export type VideosListResponse = VideoEntityCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoEntityCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type VideosGetResponse = VideoEntity & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoEntity;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type VideosCreateOrUpdateResponse = VideoEntity & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoEntity;
    };
};

/**
 * Contains response data for the update operation.
 */
export type VideosUpdateResponse = VideoEntity & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoEntity;
    };
};

/**
 * Contains response data for the listContentToken operation.
 */
export type VideosListContentTokenResponse = VideoContentToken & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoContentToken;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type VideosListNextResponse = VideoEntityCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VideoEntityCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type AccessPoliciesListResponse = AccessPolicyEntityCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccessPolicyEntityCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AccessPoliciesGetResponse = AccessPolicyEntity & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccessPolicyEntity;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type AccessPoliciesCreateOrUpdateResponse = AccessPolicyEntity & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccessPolicyEntity;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AccessPoliciesUpdateResponse = AccessPolicyEntity & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccessPolicyEntity;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type AccessPoliciesListNextResponse = AccessPolicyEntityCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccessPolicyEntityCollection;
    };
};
