/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { ServiceClientOptions } from "@azure/ms-rest-js";
import * as msRest from "@azure/ms-rest-js";

/**
 * Error object containing error code and error message.
 */
export interface FabricErrorError {
  /**
   * Defines the fabric error codes that be returned as part of the error object in response to
   * Service Fabric API operations that are not successful. Following are the error code values
   * that can be returned for a specific HTTP status code.
   *
   * - Possible values of the error code for HTTP status code 400 (Bad Request)
   * - "FABRIC_E_INVALID_PARTITION_KEY"
   * - "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
   * - "FABRIC_E_INVALID_ADDRESS"
   * - "FABRIC_E_APPLICATION_NOT_UPGRADING"
   * - "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
   * - "FABRIC_E_FABRIC_NOT_UPGRADING"
   * - "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
   * - "FABRIC_E_INVALID_CONFIGURATION"
   * - "FABRIC_E_INVALID_NAME_URI"
   * - "FABRIC_E_PATH_TOO_LONG"
   * - "FABRIC_E_KEY_TOO_LARGE"
   * - "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
   * - "FABRIC_E_INVALID_ATOMIC_GROUP"
   * - "FABRIC_E_VALUE_EMPTY"
   * - "FABRIC_E_BACKUP_IS_ENABLED"
   * - "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
   * - "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
   * - "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
   * - "E_INVALIDARG"
   *
   * - Possible values of the error code for HTTP status code 404 (Not Found)
   * - "FABRIC_E_NODE_NOT_FOUND"
   * - "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
   * - "FABRIC_E_APPLICATION_NOT_FOUND"
   * - "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
   * - "FABRIC_E_SERVICE_DOES_NOT_EXIST"
   * - "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
   * - "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
   * - "FABRIC_E_PARTITION_NOT_FOUND"
   * - "FABRIC_E_REPLICA_DOES_NOT_EXIST"
   * - "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
   * - "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
   * - "FABRIC_E_DIRECTORY_NOT_FOUND"
   * - "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
   * - "FABRIC_E_FILE_NOT_FOUND"
   * - "FABRIC_E_NAME_DOES_NOT_EXIST"
   * - "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
   * - "FABRIC_E_ENUMERATION_COMPLETED"
   * - "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
   * - "FABRIC_E_KEY_NOT_FOUND"
   * - "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
   * - "FABRIC_E_BACKUP_NOT_ENABLED"
   * - "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
   * - "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
   * - "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR"
   *
   * - Possible values of the error code for HTTP status code 409 (Conflict)
   * - "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
   * - "FABRIC_E_APPLICATION_ALREADY_EXISTS"
   * - "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
   * - "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
   * - "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
   * - "FABRIC_E_SERVICE_ALREADY_EXISTS"
   * - "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
   * - "FABRIC_E_APPLICATION_TYPE_IN_USE"
   * - "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
   * - "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
   * - "FABRIC_E_FABRIC_VERSION_IN_USE"
   * - "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
   * - "FABRIC_E_NAME_ALREADY_EXISTS"
   * - "FABRIC_E_NAME_NOT_EMPTY"
   * - "FABRIC_E_PROPERTY_CHECK_FAILED"
   * - "FABRIC_E_SERVICE_METADATA_MISMATCH"
   * - "FABRIC_E_SERVICE_TYPE_MISMATCH"
   * - "FABRIC_E_HEALTH_STALE_REPORT"
   * - "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
   * - "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
   * - "FABRIC_E_INSTANCE_ID_MISMATCH"
   * - "FABRIC_E_BACKUP_IN_PROGRESS"
   * - "FABRIC_E_RESTORE_IN_PROGRESS"
   * - "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
   *
   * - Possible values of the error code for HTTP status code 413 (Request Entity Too Large)
   * - "FABRIC_E_VALUE_TOO_LARGE"
   *
   * - Possible values of the error code for HTTP status code 500 (Internal Server Error)
   * - "FABRIC_E_NODE_IS_UP"
   * - "E_FAIL"
   * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
   * - "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
   * - "FABRIC_E_VOLUME_ALREADY_EXISTS"
   * - "FABRIC_E_VOLUME_NOT_FOUND"
   * - "SerializationError"
   *
   * - Possible values of the error code for HTTP status code 503 (Service Unavailable)
   * - "FABRIC_E_NO_WRITE_QUORUM"
   * - "FABRIC_E_NOT_PRIMARY"
   * - "FABRIC_E_NOT_READY"
   * - "FABRIC_E_RECONFIGURATION_PENDING"
   * - "FABRIC_E_SERVICE_OFFLINE"
   * - "E_ABORT"
   * - "FABRIC_E_VALUE_TOO_LARGE"
   *
   * - Possible values of the error code for HTTP status code 504 (Gateway Timeout)
   * - "FABRIC_E_COMMUNICATION_ERROR"
   * - "FABRIC_E_OPERATION_NOT_COMPLETE"
   * - "FABRIC_E_TIMEOUT". Possible values include: 'FABRIC_E_INVALID_PARTITION_KEY',
   * 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR', 'FABRIC_E_INVALID_ADDRESS',
   * 'FABRIC_E_APPLICATION_NOT_UPGRADING', 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
   * 'FABRIC_E_FABRIC_NOT_UPGRADING', 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
   * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI', 'FABRIC_E_PATH_TOO_LONG',
   * 'FABRIC_E_KEY_TOO_LARGE', 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
   * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY', 'FABRIC_E_NODE_NOT_FOUND',
   * 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND', 'FABRIC_E_APPLICATION_NOT_FOUND',
   * 'FABRIC_E_SERVICE_TYPE_NOT_FOUND', 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
   * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND', 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND',
   * 'FABRIC_E_PARTITION_NOT_FOUND', 'FABRIC_E_REPLICA_DOES_NOT_EXIST',
   * 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST', 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
   * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND',
   * 'FABRIC_E_FILE_NOT_FOUND', 'FABRIC_E_NAME_DOES_NOT_EXIST', 'FABRIC_E_PROPERTY_DOES_NOT_EXIST',
   * 'FABRIC_E_ENUMERATION_COMPLETED', 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND',
   * 'FABRIC_E_KEY_NOT_FOUND', 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
   * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS', 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
   * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
   * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS', 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
   * 'FABRIC_E_SERVICE_ALREADY_EXISTS', 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
   * 'FABRIC_E_APPLICATION_TYPE_IN_USE', 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
   * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS', 'FABRIC_E_FABRIC_VERSION_IN_USE',
   * 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS', 'FABRIC_E_NAME_ALREADY_EXISTS',
   * 'FABRIC_E_NAME_NOT_EMPTY', 'FABRIC_E_PROPERTY_CHECK_FAILED',
   * 'FABRIC_E_SERVICE_METADATA_MISMATCH', 'FABRIC_E_SERVICE_TYPE_MISMATCH',
   * 'FABRIC_E_HEALTH_STALE_REPORT', 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
   * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
   * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM', 'FABRIC_E_NOT_PRIMARY',
   * 'FABRIC_E_NOT_READY', 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE',
   * 'E_ABORT', 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE',
   * 'FABRIC_E_TIMEOUT', 'FABRIC_E_NODE_IS_UP', 'E_FAIL', 'FABRIC_E_BACKUP_IS_ENABLED',
   * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH',
   * 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES', 'FABRIC_E_BACKUP_NOT_ENABLED',
   * 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING', 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING',
   * 'FABRIC_E_BACKUP_IN_PROGRESS', 'FABRIC_E_RESTORE_IN_PROGRESS',
   * 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING', 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY',
   * 'E_INVALIDARG', 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
   * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND', 'FABRIC_E_VOLUME_ALREADY_EXISTS',
   * 'FABRIC_E_VOLUME_NOT_FOUND', 'SerializationError',
   * 'FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR'
   */
  code: FabricErrorCodes;
  /**
   * Error message.
   */
  message?: string;
}

/**
 * The REST API operations for Service Fabric return standard HTTP status codes. This type defines
 * the additional information returned from the Service Fabric API operations that are not
 * successful.
 */
export interface FabricError {
  /**
   * Error object containing error code and error message.
   */
  error: FabricErrorError;
}

/**
 * Container logs.
 */
export interface ContainerLogs {
  /**
   * Container logs.
   */
  content?: string;
}

/**
 * Azure Active Directory metadata used for secured connection to cluster.
 */
export interface AadMetadata {
  /**
   * The AAD authority url.
   */
  authority?: string;
  /**
   * The AAD client application Id.
   */
  client?: string;
  /**
   * The AAD cluster application Id.
   */
  cluster?: string;
  /**
   * The AAD login url.
   */
  login?: string;
  /**
   * The client application redirect address.
   */
  redirect?: string;
  /**
   * The AAD tenant Id.
   */
  tenant?: string;
}

/**
 * Azure Active Directory metadata object used for secured connection to cluster.
 */
export interface AadMetadataObject {
  /**
   * The client authentication method.
   */
  type?: string;
  /**
   * Azure Active Directory metadata used for secured connection to cluster.
   */
  metadata?: AadMetadata;
}

/**
 * Metadata about an Analysis Event.
 */
export interface AnalysisEventMetadata {
  /**
   * The analysis delay.
   */
  delay?: string;
  /**
   * The duration of analysis.
   */
  duration?: string;
}

/**
 * Contains the possible cases for FabricEvent.
 */
export type FabricEventUnion = FabricEvent | ApplicationEventUnion | ClusterEventUnion | ContainerInstanceEvent | NodeEventUnion | PartitionEventUnion | ReplicaEventUnion | ServiceEventUnion;

/**
 * Represents the base for all Fabric Events.
 */
export interface FabricEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "FabricEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
}

/**
 * Contains the possible cases for ApplicationEvent.
 */
export type ApplicationEventUnion = ApplicationEvent | ApplicationCreatedEvent | ApplicationDeletedEvent | ApplicationNewHealthReportEvent | ApplicationHealthReportExpiredEvent | ApplicationUpgradeCompletedEvent | ApplicationUpgradeDomainCompletedEvent | ApplicationUpgradeRollbackCompletedEvent | ApplicationUpgradeRollbackStartedEvent | ApplicationUpgradeStartedEvent | DeployedApplicationNewHealthReportEvent | DeployedApplicationHealthReportExpiredEvent | ApplicationProcessExitedEvent | ApplicationContainerInstanceExitedEvent | DeployedServicePackageNewHealthReportEvent | DeployedServicePackageHealthReportExpiredEvent | ChaosCodePackageRestartScheduledEvent;

/**
 * Represents the base for all Application Events.
 */
export interface ApplicationEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
}

/**
 * A base type for the health state of various entities in the cluster. It contains the aggregated
 * health state.
 */
export interface EntityHealthState {
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
}

/**
 * Represents the health state of a service, which contains the service identifier and its
 * aggregated health state.
 */
export interface ServiceHealthState extends EntityHealthState {
  /**
   * Name of the service whose health state is represented by this object.
   */
  serviceName?: string;
}

/**
 * Represents the health state of a deployed application, which contains the entity identifier and
 * the aggregated health state.
 */
export interface DeployedApplicationHealthState extends EntityHealthState {
  /**
   * Name of the node on which the service package is deployed.
   */
  nodeName?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
}

/**
 * Health information common to all entities in the cluster. It contains the aggregated health
 * state, health events and unhealthy evaluation.
 */
export interface EntityHealth {
  /**
   * The HealthState representing the aggregated health state of the entity computed by Health
   * Manager.
   * The health evaluation of the entity reflects all events reported on the entity and its
   * children (if any).
   * The aggregation is done by applying the desired health policy. Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * The list of health events reported on the entity.
   */
  healthEvents?: HealthEvent[];
  /**
   * The unhealthy evaluations that show why the current aggregated health state was returned by
   * Health Manager.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * Shows the health statistics for all children types of the queried entity.
   */
  healthStatistics?: HealthStatistics;
}

/**
 * Represents the health of the application. Contains the application aggregated health state and
 * the service and deployed application health states.
 */
export interface ApplicationHealth extends EntityHealth {
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * Service health states as found in the health store.
   */
  serviceHealthStates?: ServiceHealthState[];
  /**
   * Deployed application health states as found in the health store.
   */
  deployedApplicationHealthStates?: DeployedApplicationHealthState[];
}

/**
 * Contains the possible cases for HealthEvaluation.
 */
export type HealthEvaluationUnion = HealthEvaluation | ApplicationHealthEvaluation | ApplicationsHealthEvaluation | ApplicationTypeApplicationsHealthEvaluation | DeltaNodesCheckHealthEvaluation | DeployedApplicationHealthEvaluation | DeployedApplicationsHealthEvaluation | DeployedServicePackageHealthEvaluation | DeployedServicePackagesHealthEvaluation | EventHealthEvaluation | NodeHealthEvaluation | NodesHealthEvaluation | PartitionHealthEvaluation | PartitionsHealthEvaluation | ReplicaHealthEvaluation | ReplicasHealthEvaluation | ServiceHealthEvaluation | ServicesHealthEvaluation | SystemApplicationHealthEvaluation | UpgradeDomainDeltaNodesCheckHealthEvaluation | UpgradeDomainNodesHealthEvaluation;

/**
 * Represents a health evaluation which describes the data and the algorithm used by health manager
 * to evaluate the health of an entity.
 */
export interface HealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "HealthEvaluation";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
}

/**
 * Wrapper object for health evaluation.
 */
export interface HealthEvaluationWrapper {
  /**
   * Represents a health evaluation which describes the data and the algorithm used by health
   * manager to evaluate the health of an entity.
   */
  healthEvaluation?: HealthEvaluationUnion;
}

/**
 * Represents health evaluation for an application, containing information about the data and the
 * algorithm used by the health store to evaluate health.
 */
export interface ApplicationHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Application";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * List of unhealthy evaluations that led to the current aggregated health state of the
   * application. The types of the unhealthy evaluations can be
   * DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Represents the health policy used to evaluate the health of services belonging to a service
 * type.
 */
export interface ServiceTypeHealthPolicy {
  /**
   * The maximum allowed percentage of unhealthy partitions per service. Allowed values are Byte
   * values from zero to 100
   *
   * The percentage represents the maximum tolerated percentage of partitions that can be unhealthy
   * before the service is considered in error.
   * If the percentage is respected but there is at least one unhealthy partition, the health is
   * evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy partitions over the total
   * number of partitions in the service.
   * The computation rounds up to tolerate one failure on small numbers of partitions. Default
   * percentage is zero. Default value: 0.
   */
  maxPercentUnhealthyPartitionsPerService?: number;
  /**
   * The maximum allowed percentage of unhealthy replicas per partition. Allowed values are Byte
   * values from zero to 100.
   *
   * The percentage represents the maximum tolerated percentage of replicas that can be unhealthy
   * before the partition is considered in error.
   * If the percentage is respected but there is at least one unhealthy replica, the health is
   * evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy replicas over the total
   * number of replicas in the partition.
   * The computation rounds up to tolerate one failure on small numbers of replicas. Default
   * percentage is zero. Default value: 0.
   */
  maxPercentUnhealthyReplicasPerPartition?: number;
  /**
   * The maximum allowed percentage of unhealthy services. Allowed values are Byte values from zero
   * to 100.
   *
   * The percentage represents the maximum tolerated percentage of services that can be unhealthy
   * before the application is considered in error.
   * If the percentage is respected but there is at least one unhealthy service, the health is
   * evaluated as Warning.
   * This is calculated by dividing the number of unhealthy services of the specific service type
   * over the total number of services of the specific service type.
   * The computation rounds up to tolerate one failure on small numbers of services. Default
   * percentage is zero. Default value: 0.
   */
  maxPercentUnhealthyServices?: number;
}

/**
 * Defines an item in ServiceTypeHealthPolicyMap.
 */
export interface ServiceTypeHealthPolicyMapItem {
  /**
   * The key of the service type health policy map item. This is the name of the service type.
   */
  key: string;
  /**
   * The value of the service type health policy map item. This is the ServiceTypeHealthPolicy for
   * this service type.
   */
  value: ServiceTypeHealthPolicy;
}

/**
 * Defines a health policy used to evaluate the health of an application or one of its children
 * entities.
 */
export interface ApplicationHealthPolicy {
  /**
   * Indicates whether warnings are treated with the same severity as errors. Default value: false.
   */
  considerWarningAsError?: boolean;
  /**
   * The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte
   * values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed applications that can
   * be unhealthy before the application is considered in error.
   * This is calculated by dividing the number of unhealthy deployed applications over the number
   * of nodes where the application is currently deployed on in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes. Default
   * percentage is zero. Default value: 0.
   */
  maxPercentUnhealthyDeployedApplications?: number;
  /**
   * The health policy used by default to evaluate the health of a service type.
   */
  defaultServiceTypeHealthPolicy?: ServiceTypeHealthPolicy;
  /**
   * The map with service type health policy per service type name. The map is empty by default.
   */
  serviceTypeHealthPolicyMap?: ServiceTypeHealthPolicyMapItem[];
}

/**
 * Defines an item in ApplicationHealthPolicyMap.
 */
export interface ApplicationHealthPolicyMapItem {
  /**
   * The key of the application health policy map item. This is the name of the application.
   */
  key: string;
  /**
   * The value of the application health policy map item. This is the ApplicationHealthPolicy for
   * this application.
   */
  value: ApplicationHealthPolicy;
}

/**
 * Defines the application health policy map used to evaluate the health of an application or one
 * of its children entities.
 */
export interface ApplicationHealthPolicies {
  /**
   * The wrapper that contains the map with application health policies used to evaluate specific
   * applications in the cluster.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
}

/**
 * Represents the health state of an application, which contains the application identifier and the
 * aggregated health state.
 */
export interface ApplicationHealthState extends EntityHealthState {
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  name?: string;
}

/**
 * A base type for the health state chunk of various entities in the cluster. It contains the
 * aggregated health state.
 */
export interface EntityHealthStateChunk {
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
}

/**
 * Represents the health state chunk of a stateful service replica or a stateless service instance.
 * The replica health state contains the replica ID and its aggregated health state.
 */
export interface ReplicaHealthStateChunk extends EntityHealthStateChunk {
  /**
   * Id of a stateful service replica or a stateless service instance. This ID is used in the
   * queries that apply to both stateful and stateless services. It is used by Service Fabric to
   * uniquely identify a replica of a partition of a stateful service or an instance of a stateless
   * service partition. It is unique within a partition and does not change for the lifetime of the
   * replica or the instance. If a stateful replica gets dropped and another replica gets created
   * on the same node for the same partition, it will get a different value for the ID. If a
   * stateless instance is failed over on the same or different node it will get a different value
   * for the ID.
   */
  replicaOrInstanceId?: string;
}

/**
 * The list of replica health state chunks that respect the input filters in the chunk query.
 * Returned by get cluster health state chunks query.
 */
export interface ReplicaHealthStateChunkList {
  /**
   * The list of replica health state chunks that respect the input filters in the chunk query.
   */
  items?: ReplicaHealthStateChunk[];
}

/**
 * Represents the health state chunk of a partition, which contains the partition ID, its
 * aggregated health state and any replicas that respect the filters in the cluster health chunk
 * query description.
 */
export interface PartitionHealthStateChunk extends EntityHealthStateChunk {
  /**
   * The Id of the partition.
   */
  partitionId?: string;
  /**
   * The list of replica health state chunks belonging to the partition that respect the filters in
   * the cluster health chunk query description.
   */
  replicaHealthStateChunks?: ReplicaHealthStateChunkList;
}

/**
 * The list of partition health state chunks that respect the input filters in the chunk query
 * description.
 * Returned by get cluster health state chunks query as part of the parent application hierarchy.
 */
export interface PartitionHealthStateChunkList {
  /**
   * The list of partition health state chunks that respect the input filters in the chunk query.
   */
  items?: PartitionHealthStateChunk[];
}

/**
 * Represents the health state chunk of a service, which contains the service name, its aggregated
 * health state and any partitions that respect the filters in the cluster health chunk query
 * description.
 */
export interface ServiceHealthStateChunk extends EntityHealthStateChunk {
  /**
   * The name of the service whose health state chunk is provided in this object.
   */
  serviceName?: string;
  /**
   * The list of partition health state chunks belonging to the service that respect the filters in
   * the cluster health chunk query description.
   */
  partitionHealthStateChunks?: PartitionHealthStateChunkList;
}

/**
 * The list of service health state chunks that respect the input filters in the chunk query.
 * Returned by get cluster health state chunks query.
 */
export interface ServiceHealthStateChunkList {
  /**
   * The list of service health state chunks that respect the input filters in the chunk query.
   */
  items?: ServiceHealthStateChunk[];
}

/**
 * Represents the health state chunk of a deployed service package, which contains the service
 * manifest name and the service package aggregated health state.
 */
export interface DeployedServicePackageHealthStateChunk extends EntityHealthStateChunk {
  /**
   * The name of the service manifest.
   */
  serviceManifestName?: string;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
}

/**
 * The list of deployed service package health state chunks that respect the input filters in the
 * chunk query. Returned by get cluster health state chunks query.
 */
export interface DeployedServicePackageHealthStateChunkList {
  /**
   * The list of deployed service package health state chunks that respect the input filters in the
   * chunk query.
   */
  items?: DeployedServicePackageHealthStateChunk[];
}

/**
 * Represents the health state chunk of a deployed application, which contains the node where the
 * application is deployed, the aggregated health state and any deployed service packages that
 * respect the chunk query description filters.
 */
export interface DeployedApplicationHealthStateChunk extends EntityHealthStateChunk {
  /**
   * The name of node where the application is deployed.
   */
  nodeName?: string;
  /**
   * The list of deployed service package health state chunks belonging to the deployed application
   * that respect the filters in the cluster health chunk query description.
   */
  deployedServicePackageHealthStateChunks?: DeployedServicePackageHealthStateChunkList;
}

/**
 * The list of deployed application health state chunks that respect the input filters in the chunk
 * query. Returned by get cluster health state chunks query.
 */
export interface DeployedApplicationHealthStateChunkList {
  /**
   * The list of deployed application health state chunks that respect the input filters in the
   * chunk query.
   */
  items?: DeployedApplicationHealthStateChunk[];
}

/**
 * Represents the health state chunk of a application.
 * The application health state chunk contains the application name, its aggregated health state
 * and any children services and deployed applications that respect the filters in cluster health
 * chunk query description.
 */
export interface ApplicationHealthStateChunk extends EntityHealthStateChunk {
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * The application type name as defined in the application manifest.
   */
  applicationTypeName?: string;
  /**
   * The list of service health state chunks in the cluster that respect the filters in the cluster
   * health chunk query description.
   */
  serviceHealthStateChunks?: ServiceHealthStateChunkList;
  /**
   * The list of deployed application health state chunks in the cluster that respect the filters
   * in the cluster health chunk query description.
   */
  deployedApplicationHealthStateChunks?: DeployedApplicationHealthStateChunkList;
}

/**
 * A base type for the list of health state chunks found in the cluster. It contains the total
 * number of health states that match the input filters.
 */
export interface EntityHealthStateChunkList {
  /**
   * Total number of entity health state objects that match the specified filters from the cluster
   * health chunk query description.
   */
  totalCount?: number;
}

/**
 * The list of application health state chunks in the cluster that respect the input filters in the
 * chunk query. Returned by get cluster health state chunks query.
 */
export interface ApplicationHealthStateChunkList extends EntityHealthStateChunkList {
  /**
   * The list of application health state chunks that respect the input filters in the chunk query.
   */
  items?: ApplicationHealthStateChunk[];
}

/**
 * Defines matching criteria to determine whether a replica should be included as a child of a
 * partition in the cluster health chunk.
 * The replicas are only returned if the parent entities match a filter specified in the cluster
 * health chunk query description. The parent partition, service and application must be included
 * in the cluster health chunk.
 * One filter can match zero, one or multiple replicas, depending on its properties.
 */
export interface ReplicaHealthStateFilter {
  /**
   * Id of the stateful service replica or stateless service instance that matches the filter. The
   * filter is applied only to the specified replica, if it exists.
   * If the replica doesn't exist, no replica is returned in the cluster health chunk based on this
   * filter.
   * If the replica exists, it is included in the cluster health chunk if it respects the other
   * filter properties.
   * If not specified, all replicas that match the parent filters (if any) are taken into
   * consideration and matched against the other filter members, like health state filter.
   */
  replicaOrInstanceIdFilter?: string;
  /**
   * The filter for the health state of the replicas. It allows selecting replicas if they match
   * the desired health states.
   * The possible values are integer value of one of the following health states. Only replicas
   * that match the filter are returned. All replicas are used to evaluate the parent partition
   * aggregated health state.
   * If not specified, default value is None, unless the replica ID is specified. If the filter has
   * default value and replica ID is specified, the matching replica is returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches replicas with HealthState value of OK (2)
   * and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  healthStateFilter?: number;
}

/**
 * Defines matching criteria to determine whether a partition should be included as a child of a
 * service in the cluster health chunk.
 * The partitions are only returned if the parent entities match a filter specified in the cluster
 * health chunk query description. The parent service and application must be included in the
 * cluster health chunk.
 * One filter can match zero, one or multiple partitions, depending on its properties.
 */
export interface PartitionHealthStateFilter {
  /**
   * ID of the partition that matches the filter. The filter is applied only to the specified
   * partition, if it exists.
   * If the partition doesn't exist, no partition is returned in the cluster health chunk based on
   * this filter.
   * If the partition exists, it is included in the cluster health chunk if it respects the other
   * filter properties.
   * If not specified, all partitions that match the parent filters (if any) are taken into
   * consideration and matched against the other filter members, like health state filter.
   */
  partitionIdFilter?: string;
  /**
   * The filter for the health state of the partitions. It allows selecting partitions if they
   * match the desired health states.
   * The possible values are integer value of one of the following health states. Only partitions
   * that match the filter are returned. All partitions are used to evaluate the cluster aggregated
   * health state.
   * If not specified, default value is None, unless the partition ID is specified. If the filter
   * has default value and partition ID is specified, the matching partition is returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches partitions with HealthState value of OK
   * (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  healthStateFilter?: number;
  /**
   * Defines a list of filters that specify which replicas to be included in the returned cluster
   * health chunk as children of the parent partition. The replicas are returned only if the parent
   * partition matches a filter.
   * If the list is empty, no replicas are returned. All the replicas are used to evaluate the
   * parent partition aggregated health state, regardless of the input filters.
   * The partition filter may specify multiple replica filters.
   * For example, it can specify a filter to return all replicas with health state Error and
   * another filter to always include a replica identified by its replica id.
   */
  replicaFilters?: ReplicaHealthStateFilter[];
}

/**
 * Defines matching criteria to determine whether a service should be included as a child of an
 * application in the cluster health chunk.
 * The services are only returned if the parent application matches a filter specified in the
 * cluster health chunk query description.
 * One filter can match zero, one or multiple services, depending on its properties.
 */
export interface ServiceHealthStateFilter {
  /**
   * The name of the service that matches the filter. The filter is applied only to the specified
   * service, if it exists.
   * If the service doesn't exist, no service is returned in the cluster health chunk based on this
   * filter.
   * If the service exists, it is included as the application's child if the health state matches
   * the other filter properties.
   * If not specified, all services that match the parent filters (if any) are taken into
   * consideration and matched against the other filter members, like health state filter.
   */
  serviceNameFilter?: string;
  /**
   * The filter for the health state of the services. It allows selecting services if they match
   * the desired health states.
   * The possible values are integer value of one of the following health states. Only services
   * that match the filter are returned. All services are used to evaluate the cluster aggregated
   * health state.
   * If not specified, default value is None, unless the service name is specified. If the filter
   * has default value and service name is specified, the matching service is returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches services with HealthState value of OK (2)
   * and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  healthStateFilter?: number;
  /**
   * Defines a list of filters that specify which partitions to be included in the returned cluster
   * health chunk as children of the service. The partitions are returned only if the parent
   * service matches a filter.
   * If the list is empty, no partitions are returned. All the partitions are used to evaluate the
   * parent service aggregated health state, regardless of the input filters.
   * The service filter may specify multiple partition filters.
   * For example, it can specify a filter to return all partitions with health state Error and
   * another filter to always include a partition identified by its partition ID.
   */
  partitionFilters?: PartitionHealthStateFilter[];
}

/**
 * Defines matching criteria to determine whether a deployed service package should be included as
 * a child of a deployed application in the cluster health chunk.
 * The deployed service packages are only returned if the parent entities match a filter specified
 * in the cluster health chunk query description. The parent deployed application and its parent
 * application must be included in the cluster health chunk.
 * One filter can match zero, one or multiple deployed service packages, depending on its
 * properties.
 */
export interface DeployedServicePackageHealthStateFilter {
  /**
   * The name of the service manifest which identifies the deployed service packages that matches
   * the filter.
   * If specified, the filter is applied only to the specified deployed service packages, if any.
   * If no deployed service packages with specified manifest name exist, nothing is returned in the
   * cluster health chunk based on this filter.
   * If any deployed service package exists, they are included in the cluster health chunk if it
   * respects the other filter properties.
   * If not specified, all deployed service packages that match the parent filters (if any) are
   * taken into consideration and matched against the other filter members, like health state
   * filter.
   */
  serviceManifestNameFilter?: string;
  /**
   * The activation ID of a deployed service package that matches the filter.
   * If not specified, the filter applies to all deployed service packages that match the other
   * parameters.
   * If specified, the filter matches only the deployed service package with the specified
   * activation ID.
   */
  servicePackageActivationIdFilter?: string;
  /**
   * The filter for the health state of the deployed service packages. It allows selecting deployed
   * service packages if they match the desired health states.
   * The possible values are integer value of one of the following health states. Only deployed
   * service packages that match the filter are returned. All deployed service packages are used to
   * evaluate the parent deployed application aggregated health state.
   * If not specified, default value is None, unless the deployed service package ID is specified.
   * If the filter has default value and deployed service package ID is specified, the matching
   * deployed service package is returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches deployed service packages with HealthState
   * value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  healthStateFilter?: number;
}

/**
 * Defines matching criteria to determine whether a deployed application should be included as a
 * child of an application in the cluster health chunk.
 * The deployed applications are only returned if the parent application matches a filter specified
 * in the cluster health chunk query description.
 * One filter can match zero, one or multiple deployed applications, depending on its properties.
 */
export interface DeployedApplicationHealthStateFilter {
  /**
   * The name of the node where the application is deployed in order to match the filter.
   * If specified, the filter is applied only to the application deployed on the specified node.
   * If the application is not deployed on the node with the specified name, no deployed
   * application is returned in the cluster health chunk based on this filter.
   * Otherwise, the deployed application is included in the cluster health chunk if it respects the
   * other filter properties.
   * If not specified, all deployed applications that match the parent filters (if any) are taken
   * into consideration and matched against the other filter members, like health state filter.
   */
  nodeNameFilter?: string;
  /**
   * The filter for the health state of the deployed applications. It allows selecting deployed
   * applications if they match the desired health states.
   * The possible values are integer value of one of the following health states. Only deployed
   * applications that match the filter are returned. All deployed applications are used to
   * evaluate the cluster aggregated health state.
   * If not specified, default value is None, unless the node name is specified. If the filter has
   * default value and node name is specified, the matching deployed application is returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches deployed applications with HealthState
   * value of OK (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  healthStateFilter?: number;
  /**
   * Defines a list of filters that specify which deployed service packages to be included in the
   * returned cluster health chunk as children of the parent deployed application. The deployed
   * service packages are returned only if the parent deployed application matches a filter.
   * If the list is empty, no deployed service packages are returned. All the deployed service
   * packages are used to evaluate the parent deployed application aggregated health state,
   * regardless of the input filters.
   * The deployed application filter may specify multiple deployed service package filters.
   * For example, it can specify a filter to return all deployed service packages with health state
   * Error and another filter to always include a deployed service package on a node.
   */
  deployedServicePackageFilters?: DeployedServicePackageHealthStateFilter[];
}

/**
 * Defines matching criteria to determine whether a application should be included in the cluster
 * health chunk.
 * One filter can match zero, one or multiple applications, depending on its properties.
 */
export interface ApplicationHealthStateFilter {
  /**
   * The name of the application that matches the filter, as a fabric uri. The filter is applied
   * only to the specified application, if it exists.
   * If the application doesn't exist, no application is returned in the cluster health chunk based
   * on this filter.
   * If the application exists, it is included in the cluster health chunk if it respects the other
   * filter properties.
   * If not specified, all applications are matched against the other filter members, like health
   * state filter.
   */
  applicationNameFilter?: string;
  /**
   * The name of the application type that matches the filter.
   * If specified, the filter is applied only to applications of the selected application type, if
   * any exists.
   * If no applications of the specified application type exists, no application is returned in the
   * cluster health chunk based on this filter.
   * Each application of the specified application type is included in the cluster health chunk if
   * it respects the other filter properties.
   * If not specified, all applications are matched against the other filter members, like health
   * state filter.
   */
  applicationTypeNameFilter?: string;
  /**
   * The filter for the health state of the applications. It allows selecting applications if they
   * match the desired health states.
   * The possible values are integer value of one of the following health states. Only applications
   * that match the filter are returned. All applications are used to evaluate the cluster
   * aggregated health state.
   * If not specified, default value is None, unless the application name or the application type
   * name are specified. If the filter has default value and application name is specified, the
   * matching application is returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches applications with HealthState value of OK
   * (2) and Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  healthStateFilter?: number;
  /**
   * Defines a list of filters that specify which services to be included in the returned cluster
   * health chunk as children of the application. The services are returned only if the parent
   * application matches a filter.
   * If the list is empty, no services are returned. All the services are used to evaluate the
   * parent application aggregated health state, regardless of the input filters.
   * The application filter may specify multiple service filters.
   * For example, it can specify a filter to return all services with health state Error and
   * another filter to always include a service identified by its service name.
   */
  serviceFilters?: ServiceHealthStateFilter[];
  /**
   * Defines a list of filters that specify which deployed applications to be included in the
   * returned cluster health chunk as children of the application. The deployed applications are
   * returned only if the parent application matches a filter.
   * If the list is empty, no deployed applications are returned. All the deployed applications are
   * used to evaluate the parent application aggregated health state, regardless of the input
   * filters.
   * The application filter may specify multiple deployed application filters.
   * For example, it can specify a filter to return all deployed applications with health state
   * Error and another filter to always include a deployed application on a specified node.
   */
  deployedApplicationFilters?: DeployedApplicationHealthStateFilter[];
}

/**
 * Describes an application parameter override to be applied when creating or upgrading an
 * application.
 */
export interface ApplicationParameter {
  /**
   * The name of the parameter.
   */
  key: string;
  /**
   * The value of the parameter.
   */
  value: string;
}

/**
 * Information about a Service Fabric application.
 */
export interface ApplicationInfo {
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  id?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * The application type name as defined in the application manifest.
   */
  typeName?: string;
  /**
   * The version of the application type as defined in the application manifest.
   */
  typeVersion?: string;
  /**
   * The status of the application. Possible values include: 'Invalid', 'Ready', 'Upgrading',
   * 'Creating', 'Deleting', 'Failed'
   */
  status?: ApplicationStatus;
  /**
   * List of application parameters with overridden values from their default values specified in
   * the application manifest.
   */
  parameters?: ApplicationParameter[];
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The mechanism used to define a Service Fabric application. Possible values include: 'Invalid',
   * 'ServiceFabricApplicationDescription', 'Compose'
   */
  applicationDefinitionKind?: ApplicationDefinitionKind;
}

/**
 * Describes load information for a custom resource balancing metric. This can be used to limit the
 * total consumption of this metric by the services of this application.
 */
export interface ApplicationLoadMetricInformation {
  /**
   * The name of the metric.
   */
  name?: string;
  /**
   * This is the capacity reserved in the cluster for the application.
   * It's the product of NodeReservationCapacity and MinimumNodes.
   * If set to zero, no capacity is reserved for this metric.
   * When setting application capacity or when updating application capacity this value must be
   * smaller than or equal to MaximumCapacity for each metric.
   */
  reservationCapacity?: number;
  /**
   * Total capacity for this metric in this application instance.
   */
  applicationCapacity?: number;
  /**
   * Current load for this metric in this application instance.
   */
  applicationLoad?: number;
}

/**
 * Load Information about a Service Fabric application.
 */
export interface ApplicationLoadInfo {
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  id?: string;
  /**
   * The minimum number of nodes for this application.
   * It is the number of nodes where Service Fabric will reserve Capacity in the cluster which
   * equals to ReservedLoad * MinimumNodes for this Application instance.
   * For applications that do not have application capacity defined this value will be zero.
   */
  minimumNodes?: number;
  /**
   * The maximum number of nodes where this application can be instantiated.
   * It is the number of nodes this application is allowed to span.
   * For applications that do not have application capacity defined this value will be zero.
   */
  maximumNodes?: number;
  /**
   * The number of nodes on which this application is instantiated.
   * For applications that do not have application capacity defined this value will be zero.
   */
  nodeCount?: number;
  /**
   * List of application load metric information.
   */
  applicationLoadMetricInformation?: ApplicationLoadMetricInformation[];
}

/**
 * Information about the application name.
 */
export interface ApplicationNameInfo {
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  id?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  name?: string;
}

/**
 * Represents health evaluation for applications, containing health evaluations for each unhealthy
 * application that impacted current aggregated health state.
 */
export interface ApplicationsHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Applications";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Maximum allowed percentage of unhealthy applications from the ClusterHealthPolicy.
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * Total number of applications from the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy ApplicationHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Represents health evaluation for applications of a particular application type. The application
 * type applications evaluation can be returned when cluster health evaluation returns unhealthy
 * aggregated health state, either Error or Warning. It contains health evaluations for each
 * unhealthy application of the included application type that impacted current aggregated health
 * state.
 */
export interface ApplicationTypeApplicationsHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationTypeApplications";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * The application type name as defined in the application manifest.
   */
  applicationTypeName?: string;
  /**
   * Maximum allowed percentage of unhealthy applications for the application type, specified as an
   * entry in ApplicationTypeHealthPolicyMap.
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * Total number of applications of the application type found in the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy ApplicationHealthEvaluation of this application type that impacted the aggregated
   * health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Defines an item in ApplicationTypeHealthPolicyMap.
 */
export interface ApplicationTypeHealthPolicyMapItem {
  /**
   * The key of the application type health policy map item. This is the name of the application
   * type.
   */
  key: string;
  /**
   * The value of the application type health policy map item.
   * The max percent unhealthy applications allowed for the application type. Must be between zero
   * and 100.
   */
  value: number;
}

/**
 * Information about an application type.
 */
export interface ApplicationTypeInfo {
  /**
   * The application type name as defined in the application manifest.
   */
  name?: string;
  /**
   * The version of the application type as defined in the application manifest.
   */
  version?: string;
  /**
   * List of application type parameters that can be overridden when creating or updating the
   * application.
   */
  defaultParameterList?: ApplicationParameter[];
  /**
   * The status of the application type. Possible values include: 'Invalid', 'Provisioning',
   * 'Available', 'Unprovisioning', 'Failed'
   */
  status?: ApplicationTypeStatus;
  /**
   * Additional detailed information about the status of the application type.
   */
  statusDetails?: string;
  /**
   * The mechanism used to define a Service Fabric application type. Possible values include:
   * 'Invalid', 'ServiceFabricApplicationPackage', 'Compose'
   */
  applicationTypeDefinitionKind?: ApplicationTypeDefinitionKind;
}

/**
 * The list of application types that are provisioned or being provisioned in the cluster. The list
 * is paged when all of the results cannot fit in a single message. The next set of results can be
 * obtained by executing the same query with the continuation token provided in this list.
 */
export interface PagedApplicationTypeInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of application type information.
   */
  items?: ApplicationTypeInfo[];
}

/**
 * Contains the manifest describing an application type registered in a Service Fabric cluster.
 */
export interface ApplicationTypeManifest {
  /**
   * The XML manifest as a string.
   */
  manifest?: string;
}

/**
 * Describes the parameters for monitoring an upgrade in Monitored mode.
 */
export interface MonitoringPolicyDescription {
  /**
   * The compensating action to perform when a Monitored upgrade encounters monitoring policy or
   * health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will
   * start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode. Possible
   * values include: 'Invalid', 'Rollback', 'Manual'
   */
  failureAction?: FailureAction;
  /**
   * The amount of time to wait after completing an upgrade domain before applying health policies.
   * It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it
   * is interpreted as a number representing the total number of milliseconds.
   */
  healthCheckWaitDurationInMilliseconds?: string;
  /**
   * The amount of time that the application or cluster must remain healthy before the upgrade
   * proceeds to the next upgrade domain. It is first interpreted as a string representing an ISO
   * 8601 duration. If that fails, then it is interpreted as a number representing the total number
   * of milliseconds.
   */
  healthCheckStableDurationInMilliseconds?: string;
  /**
   * The amount of time to retry health evaluation when the application or cluster is unhealthy
   * before FailureAction is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the total number of
   * milliseconds.
   */
  healthCheckRetryTimeoutInMilliseconds?: string;
  /**
   * The amount of time the overall upgrade has to complete before FailureAction is executed. It is
   * first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  upgradeTimeoutInMilliseconds?: string;
  /**
   * The amount of time each upgrade domain has to complete before FailureAction is executed. It is
   * first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  upgradeDomainTimeoutInMilliseconds?: string;
}

/**
 * Describes the parameters for an application upgrade. Note that upgrade description replaces the
 * existing application description. This means that if the parameters are not specified, the
 * existing parameters on the applications will be overwritten with the empty parameters list. This
 * would result in the application using the default value of the parameters from the application
 * manifest. If you do not want to change any existing parameter values, please get the application
 * parameters first using the GetApplicationInfo query and then supply those values as Parameters
 * in this ApplicationUpgradeDescription.
 */
export interface ApplicationUpgradeDescription {
  /**
   * The name of the target application, including the 'fabric:' URI scheme.
   */
  name: string;
  /**
   * The target application type version (found in the application manifest) for the application
   * upgrade.
   */
  targetApplicationTypeVersion: string;
  /**
   * List of application parameters with overridden values from their default values specified in
   * the application manifest.
   */
  parameters?: ApplicationParameter[];
  /**
   * The kind of upgrade out of the following possible values. Possible values include: 'Invalid',
   * 'Rolling'. Default value: 'Rolling'.
   */
  upgradeKind: UpgradeKind;
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto'.
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has
   * not changed (the upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * Defines the order in which an upgrade proceeds through the cluster. Possible values include:
   * 'Invalid', 'Default', 'Numeric', 'Lexicographical', 'ReverseNumeric',
   * 'ReverseLexicographical'. Default value: 'Default'.
   */
  sortOrder?: UpgradeSortOrder;
  /**
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * Defines a health policy used to evaluate the health of an application or one of its children
   * entities.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * Duration in seconds, to wait before a stateless instance is closed, to allow the active
   * requests to drain gracefully. This would be effective when the instance is closing during the
   * application/cluster
   * upgrade, only for those instances which have a non-zero delay duration configured in the
   * service description. See InstanceCloseDelayDurationSeconds property in $ref:
   * "#/definitions/StatelessServiceDescription.yaml" for details.
   * Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
   * that the behavior will entirely depend on the delay configured in the stateless service
   * description.
   */
  instanceCloseDelayDurationInSeconds?: number;
}

/**
 * Information about an upgrade domain.
 */
export interface UpgradeDomainInfo {
  /**
   * The name of the upgrade domain
   */
  name?: string;
  /**
   * The state of the upgrade domain. Possible values include: 'Invalid', 'Pending', 'InProgress',
   * 'Completed'
   */
  state?: UpgradeDomainState;
}

/**
 * Contains the possible cases for SafetyCheck.
 */
export type SafetyCheckUnion = SafetyCheck | PartitionSafetyCheckUnion | SeedNodeSafetyCheck;

/**
 * Represents a safety check performed by service fabric before continuing with the operations.
 * These checks ensure the availability of the service and the reliability of the state.
 */
export interface SafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "SafetyCheck";
}

/**
 * A wrapper for the safety check object. Safety checks are performed by service fabric before
 * continuing with the operations. These checks ensure the availability of the service and the
 * reliability of the state.
 */
export interface SafetyCheckWrapper {
  /**
   * Represents a safety check performed by service fabric before continuing with the operations.
   * These checks ensure the availability of the service and the reliability of the state.
   */
  safetyCheck?: SafetyCheckUnion;
}

/**
 * Information about the upgrading node and its status
 */
export interface NodeUpgradeProgressInfo {
  /**
   * The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * The state of the upgrading node. Possible values include: 'Invalid', 'PreUpgradeSafetyCheck',
   * 'Upgrading', 'PostUpgradeSafetyCheck'
   */
  upgradePhase?: NodeUpgradePhase;
  /**
   * List of pending safety checks
   */
  pendingSafetyChecks?: SafetyCheckWrapper[];
}

/**
 * Information about the current in-progress upgrade domain.
 */
export interface CurrentUpgradeDomainProgressInfo {
  /**
   * The name of the upgrade domain
   */
  domainName?: string;
  /**
   * List of upgrading nodes and their statuses
   */
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * Information about the upgrade domain progress at the time of upgrade failure.
 */
export interface FailureUpgradeDomainProgressInfo {
  /**
   * The name of the upgrade domain
   */
  domainName?: string;
  /**
   * List of upgrading nodes and their statuses
   */
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * Describes the parameters for an application upgrade.
 */
export interface ApplicationUpgradeProgressInfo {
  /**
   * The name of the target application, including the 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * The application type name as defined in the application manifest.
   */
  typeName?: string;
  /**
   * The target application type version (found in the application manifest) for the application
   * upgrade.
   */
  targetApplicationTypeVersion?: string;
  /**
   * List of upgrade domains and their statuses.
   */
  upgradeDomains?: UpgradeDomainInfo[];
  /**
   * The state of the upgrade domain. Possible values include: 'Invalid', 'RollingBackInProgress',
   * 'RollingBackCompleted', 'RollingForwardPending', 'RollingForwardInProgress',
   * 'RollingForwardCompleted', 'Failed'
   */
  upgradeState?: UpgradeState;
  /**
   * The name of the next upgrade domain to be processed.
   */
  nextUpgradeDomain?: string;
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto'.
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * Describes the parameters for an application upgrade. Note that upgrade description replaces
   * the existing application description. This means that if the parameters are not specified, the
   * existing parameters on the applications will be overwritten with the empty parameters list.
   * This would result in the application using the default value of the parameters from the
   * application manifest. If you do not want to change any existing parameter values, please get
   * the application parameters first using the GetApplicationInfo query and then supply those
   * values as Parameters in this ApplicationUpgradeDescription.
   */
  upgradeDescription?: ApplicationUpgradeDescription;
  /**
   * The estimated total amount of time spent processing the overall upgrade.
   */
  upgradeDurationInMilliseconds?: string;
  /**
   * The estimated total amount of time spent processing the current upgrade domain.
   */
  upgradeDomainDurationInMilliseconds?: string;
  /**
   * List of health evaluations that resulted in the current aggregated health state.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * Information about the current in-progress upgrade domain.
   */
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  /**
   * The estimated UTC datetime when the upgrade started.
   */
  startTimestampUtc?: string;
  /**
   * The estimated UTC datetime when the upgrade failed and FailureAction was executed.
   */
  failureTimestampUtc?: string;
  /**
   * The cause of an upgrade failure that resulted in FailureAction being executed. Possible values
   * include: 'None', 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout', 'OverallUpgradeTimeout'
   */
  failureReason?: FailureReason;
  /**
   * Information about the upgrade domain progress at the time of upgrade failure.
   */
  upgradeDomainProgressAtFailure?: FailureUpgradeDomainProgressInfo;
  /**
   * Additional detailed information about the status of the pending upgrade.
   */
  upgradeStatusDetails?: string;
}

/**
 * Information about the standalone cluster configuration.
 */
export interface ClusterConfiguration {
  /**
   * The contents of the cluster configuration file.
   */
  clusterConfiguration?: string;
}

/**
 * Contains the possible cases for ClusterEvent.
 */
export type ClusterEventUnion = ClusterEvent | ClusterNewHealthReportEvent | ClusterHealthReportExpiredEvent | ClusterUpgradeCompletedEvent | ClusterUpgradeDomainCompletedEvent | ClusterUpgradeRollbackCompletedEvent | ClusterUpgradeRollbackStartedEvent | ClusterUpgradeStartedEvent | ChaosStoppedEvent | ChaosStartedEvent;

/**
 * Represents the base for all Cluster Events.
 */
export interface ClusterEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ClusterEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
}

/**
 * An internal ID used by Service Fabric to uniquely identify a node. Node Id is deterministically
 * generated from node name.
 */
export interface NodeId {
  /**
   * Value of the node Id. This is a 128 bit integer.
   */
  id?: string;
}

/**
 * Represents the health state of a node, which contains the node identifier and its aggregated
 * health state.
 */
export interface NodeHealthState extends EntityHealthState {
  /**
   * The name of a Service Fabric node.
   */
  name?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a node. Node Id is
   * deterministically generated from node name.
   */
  id?: NodeId;
}

/**
 * Represents the health of the cluster.
 * Contains the cluster aggregated health state, the cluster application and node health states as
 * well as the health events and the unhealthy evaluations.
 */
export interface ClusterHealth extends EntityHealth {
  /**
   * Cluster node health states as found in the health store.
   */
  nodeHealthStates?: NodeHealthState[];
  /**
   * Cluster application health states as found in the health store.
   */
  applicationHealthStates?: ApplicationHealthState[];
}

/**
 * Represents the health state chunk of a node, which contains the node name and its aggregated
 * health state.
 */
export interface NodeHealthStateChunk extends EntityHealthStateChunk {
  /**
   * The name of a Service Fabric node.
   */
  nodeName?: string;
}

/**
 * The list of node health state chunks in the cluster that respect the input filters in the chunk
 * query. Returned by get cluster health state chunks query.
 */
export interface NodeHealthStateChunkList extends EntityHealthStateChunkList {
  /**
   * The list of node health state chunks that respect the input filters in the chunk query.
   */
  items?: NodeHealthStateChunk[];
}

/**
 * Represents the health chunk of the cluster.
 * Contains the cluster aggregated health state, and the cluster entities that respect the input
 * filter.
 */
export interface ClusterHealthChunk {
  /**
   * The HealthState representing the aggregated health state of the cluster computed by Health
   * Manager.
   * The health evaluation of the entity reflects all events reported on the entity and its
   * children (if any).
   * The aggregation is done by applying the desired cluster health policy and the application
   * health policies. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The list of node health state chunks in the cluster that respect the filters in the cluster
   * health chunk query description.
   */
  nodeHealthStateChunks?: NodeHealthStateChunkList;
  /**
   * The list of application health state chunks in the cluster that respect the filters in the
   * cluster health chunk query description.
   */
  applicationHealthStateChunks?: ApplicationHealthStateChunkList;
}

/**
 * Defines matching criteria to determine whether a node should be included in the returned cluster
 * health chunk.
 * One filter can match zero, one or multiple nodes, depending on its properties.
 * Can be specified in the cluster health chunk query description.
 */
export interface NodeHealthStateFilter {
  /**
   * Name of the node that matches the filter. The filter is applied only to the specified node, if
   * it exists.
   * If the node doesn't exist, no node is returned in the cluster health chunk based on this
   * filter.
   * If the node exists, it is included in the cluster health chunk if the health state matches the
   * other filter properties.
   * If not specified, all nodes that match the parent filters (if any) are taken into
   * consideration and matched against the other filter members, like health state filter.
   */
  nodeNameFilter?: string;
  /**
   * The filter for the health state of the nodes. It allows selecting nodes if they match the
   * desired health states.
   * The possible values are integer value of one of the following health states. Only nodes that
   * match the filter are returned. All nodes are used to evaluate the cluster aggregated health
   * state.
   * If not specified, default value is None, unless the node name is specified. If the filter has
   * default value and node name is specified, the matching node is returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6, it matches nodes with HealthState value of OK (2) and
   * Warning (4).
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  healthStateFilter?: number;
}

/**
 * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
 */
export interface ClusterHealthPolicy {
  /**
   * Indicates whether warnings are treated with the same severity as errors. Default value: false.
   */
  considerWarningAsError?: boolean;
  /**
   * The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to
   * allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can be unhealthy
   * before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the health is
   * evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over the total number
   * of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes. Default
   * percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so this percentage
   * should be configured to tolerate that. Default value: 0.
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * The maximum allowed percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications that can be
   * unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy application, the health is
   * evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the total number of
   * application instances in the cluster, excluding applications of application types that are
   * included in the ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of applications. Default
   * percentage is zero. Default value: 0.
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * Defines a map with max percentage unhealthy applications for specific application types.
   * Each entry specifies as key the application type name and as value an integer that represents
   * the MaxPercentUnhealthyApplications percentage used to evaluate the applications of the
   * specified application type.
   *
   * The application type health policy map can be used during cluster health evaluation to
   * describe special application types.
   * The application types included in the map are evaluated against the percentage specified in
   * the map, and not with the global MaxPercentUnhealthyApplications defined in the cluster health
   * policy.
   * The applications of application types specified in the map are not counted against the global
   * pool of applications.
   * For example, if some applications of a type are critical, the cluster administrator can add an
   * entry to the map for that application type
   * and assign it a value of 0% (that is, do not tolerate any failures).
   * All other applications can be evaluated with MaxPercentUnhealthyApplications set to 20% to
   * tolerate some failures out of the thousands of application instances.
   * The application type health policy map is used only if the cluster manifest enables
   * application type health evaluation using the configuration entry for
   * HealthManager/EnableApplicationTypeHealthEvaluation.
   */
  applicationTypeHealthPolicyMap?: ApplicationTypeHealthPolicyMapItem[];
}

/**
 * The cluster health chunk query description, which can specify the health policies to evaluate
 * cluster health and very expressive filters to select which cluster entities to include in
 * response.
 */
export interface ClusterHealthChunkQueryDescription {
  /**
   * Defines a list of filters that specify which nodes to be included in the returned cluster
   * health chunk.
   * If no filters are specified, no nodes are returned. All the nodes are used to evaluate the
   * cluster's aggregated health state, regardless of the input filters.
   * The cluster health chunk query may specify multiple node filters.
   * For example, it can specify a filter to return all nodes with health state Error and another
   * filter to always include a node identified by its NodeName.
   */
  nodeFilters?: NodeHealthStateFilter[];
  /**
   * Defines a list of filters that specify which applications to be included in the returned
   * cluster health chunk.
   * If no filters are specified, no applications are returned. All the applications are used to
   * evaluate the cluster's aggregated health state, regardless of the input filters.
   * The cluster health chunk query may specify multiple application filters.
   * For example, it can specify a filter to return all applications with health state Error and
   * another filter to always include applications of a specified application type.
   */
  applicationFilters?: ApplicationHealthStateFilter[];
  /**
   * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * Defines the application health policy map used to evaluate the health of an application or one
   * of its children entities.
   */
  applicationHealthPolicies?: ApplicationHealthPolicies;
}

/**
 * Health policies to evaluate cluster health.
 */
export interface ClusterHealthPolicies {
  /**
   * Defines a map that contains specific application health policies for different applications.
   * Each entry specifies as key the application name and as value an ApplicationHealthPolicy used
   * to evaluate the application health.
   * If an application is not specified in the map, the application health evaluation uses the
   * ApplicationHealthPolicy found in its application manifest or the default application health
   * policy (if no health policy is defined in the manifest).
   * The map is empty by default.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
  /**
   * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
}

/**
 * Information about the cluster manifest.
 */
export interface ClusterManifest {
  /**
   * The contents of the cluster manifest file.
   */
  manifest?: string;
}

/**
 * Represents data structure that contains load information for a certain metric in a cluster.
 */
export interface LoadMetricInformation {
  /**
   * Name of the metric for which this load information is provided.
   */
  name?: string;
  /**
   * Value that indicates whether the metrics is balanced or not before resource balancer run
   */
  isBalancedBefore?: boolean;
  /**
   * Value that indicates whether the metrics is balanced or not after resource balancer run.
   */
  isBalancedAfter?: boolean;
  /**
   * The standard average deviation of the metrics before resource balancer run.
   */
  deviationBefore?: string;
  /**
   * The standard average deviation of the metrics after resource balancer run.
   */
  deviationAfter?: string;
  /**
   * The balancing threshold for a certain metric.
   */
  balancingThreshold?: string;
  /**
   * The current action being taken with regard to this metric
   */
  action?: string;
  /**
   * The Activity Threshold specified for this metric in the system Cluster Manifest.
   */
  activityThreshold?: string;
  /**
   * The total cluster capacity for a given metric
   */
  clusterCapacity?: string;
  /**
   * The total cluster load. In future releases of Service Fabric this parameter will be deprecated
   * in favor of CurrentClusterLoad.
   */
  clusterLoad?: string;
  /**
   * The total cluster load.
   */
  currentClusterLoad?: string;
  /**
   * The remaining capacity for the metric in the cluster. In future releases of Service Fabric
   * this parameter will be deprecated in favor of ClusterCapacityRemaining.
   */
  clusterRemainingCapacity?: string;
  /**
   * The remaining capacity for the metric in the cluster.
   */
  clusterCapacityRemaining?: string;
  /**
   * Indicates that the metric is currently over capacity in the cluster.
   */
  isClusterCapacityViolation?: boolean;
  /**
   * The reserved percentage of total node capacity for this metric.
   */
  nodeBufferPercentage?: string;
  /**
   * Remaining capacity in the cluster excluding the reserved space. In future releases of Service
   * Fabric this parameter will be deprecated in favor of BufferedClusterCapacityRemaining.
   */
  clusterBufferedCapacity?: string;
  /**
   * Remaining capacity in the cluster excluding the reserved space.
   */
  bufferedClusterCapacityRemaining?: string;
  /**
   * The remaining percentage of cluster total capacity for this metric.
   */
  clusterRemainingBufferedCapacity?: string;
  /**
   * The minimum load on any node for this metric. In future releases of Service Fabric this
   * parameter will be deprecated in favor of MinimumNodeLoad.
   */
  minNodeLoadValue?: string;
  /**
   * The minimum load on any node for this metric.
   */
  minimumNodeLoad?: string;
  /**
   * The node id of the node with the minimum load for this metric.
   */
  minNodeLoadNodeId?: NodeId;
  /**
   * The maximum load on any node for this metric. In future releases of Service Fabric this
   * parameter will be deprecated in favor of MaximumNodeLoad.
   */
  maxNodeLoadValue?: string;
  /**
   * The maximum load on any node for this metric.
   */
  maximumNodeLoad?: string;
  /**
   * The node id of the node with the maximum load for this metric.
   */
  maxNodeLoadNodeId?: NodeId;
  /**
   * This value represents the load of the replicas that are planned to be removed in the future
   * within the cluster.
   * This kind of load is reported for replicas that are currently being moving to other nodes and
   * for replicas that are currently being dropped but still use the load on the source node.
   */
  plannedLoadRemoval?: string;
}

/**
 * Information about load in a Service Fabric cluster. It holds a summary of all metrics and their
 * load in a cluster.
 */
export interface ClusterLoadInfo {
  /**
   * The starting time of last resource balancing run.
   */
  lastBalancingStartTimeUtc?: Date;
  /**
   * The end time of last resource balancing run.
   */
  lastBalancingEndTimeUtc?: Date;
  /**
   * List that contains metrics and their load information in this cluster.
   */
  loadMetricInformation?: LoadMetricInformation[];
}

/**
 * The cluster version.
 */
export interface ClusterVersion {
  /**
   * The Service Fabric cluster runtime version.
   */
  version?: string;
}

/**
 * parameters for making container API call.
 */
export interface ContainerApiRequestBody {
  /**
   * HTTP verb of container REST API, defaults to "GET"
   */
  httpVerb?: string;
  /**
   * URI path of container REST API
   */
  uriPath: string;
  /**
   * Content type of container REST API request, defaults to "application/json"
   */
  contentType?: string;
  /**
   * HTTP request body of container REST API
   */
  body?: string;
}

/**
 * Container API result.
 */
export interface ContainerApiResult {
  /**
   * HTTP status code returned by the target container API
   */
  status: number;
  /**
   * HTTP content type
   */
  contentType?: string;
  /**
   * HTTP content encoding
   */
  contentEncoding?: string;
  /**
   * container API result body
   */
  body?: string;
}

/**
 * Response body that wraps container API result.
 */
export interface ContainerApiResponse {
  /**
   * Container API result.
   */
  containerApiResult: ContainerApiResult;
}

/**
 * Represents the base for all Container Events.
 */
export interface ContainerInstanceEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ContainerInstanceEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
}

/**
 * Information about a configuration parameter override.
 */
export interface ConfigParameterOverride {
  /**
   * Name of the section for the parameter override.
   */
  sectionName: string;
  /**
   * Name of the parameter that has been overridden.
   */
  parameterName: string;
  /**
   * Value of the overridden parameter.
   */
  parameterValue: string;
  /**
   * The duration until config override is considered as valid.
   */
  timeout?: string;
  /**
   * A value that indicates whether config override will be removed on upgrade or will still be
   * considered as valid.
   */
  persistAcrossUpgrade?: boolean;
}

/**
 * Describes the intent or reason for deactivating the node.
 */
export interface DeactivationIntentDescription {
  /**
   * Describes the intent or reason for deactivating the node. The possible values are following.
   * Possible values include: 'Pause', 'Restart', 'RemoveData'
   */
  deactivationIntent?: DeactivationIntent;
}

/**
 * Represents health evaluation for delta nodes, containing health evaluations for each unhealthy
 * node that impacted current aggregated health state.
 * Can be returned during cluster upgrade when the aggregated health state of the cluster is
 * Warning or Error.
 */
export interface DeltaNodesCheckHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeltaNodesCheck";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Number of nodes with aggregated heath state Error in the health store at the beginning of the
   * cluster upgrade.
   */
  baselineErrorCount?: number;
  /**
   * Total number of nodes in the health store at the beginning of the cluster upgrade.
   */
  baselineTotalCount?: number;
  /**
   * Maximum allowed percentage of delta unhealthy nodes from the ClusterUpgradeHealthPolicy.
   */
  maxPercentDeltaUnhealthyNodes?: number;
  /**
   * Total number of nodes in the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state.
   * Includes all the unhealthy NodeHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Represents the health state of a deployed service package, containing the entity identifier and
 * the aggregated health state.
 */
export interface DeployedServicePackageHealthState extends EntityHealthState {
  /**
   * Name of the node on which the service package is deployed.
   */
  nodeName?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * Name of the manifest describing the service package.
   */
  serviceManifestName?: string;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
}

/**
 * Information about the health of an application deployed on a Service Fabric node.
 */
export interface DeployedApplicationHealth extends EntityHealth {
  /**
   * Name of the application deployed on the node whose health information is described by this
   * object.
   */
  name?: string;
  /**
   * Name of the node where this application is deployed.
   */
  nodeName?: string;
  /**
   * Deployed service package health states for the current deployed application as found in the
   * health store.
   */
  deployedServicePackageHealthStates?: DeployedServicePackageHealthState[];
}

/**
 * Represents health evaluation for a deployed application, containing information about the data
 * and the algorithm used by the health store to evaluate health.
 */
export interface DeployedApplicationHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeployedApplication";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Name of the node where the application is deployed to.
   */
  nodeName?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * List of  unhealthy evaluations that led to the current aggregated health state of the deployed
   * application.
   * The types of the unhealthy evaluations can be DeployedServicePackagesHealthEvaluation or
   * EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Information about application deployed on the node.
 */
export interface DeployedApplicationInfo {
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  id?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * The application type name as defined in the application manifest.
   */
  typeName?: string;
  /**
   * The status of the application deployed on the node. Following are the possible values.
   * Possible values include: 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
   * 'Deactivating'
   */
  status?: DeployedApplicationStatus;
  /**
   * The work directory of the application on the node. The work directory can be used to store
   * application data.
   */
  workDirectory?: string;
  /**
   * The log directory of the application on the node. The log directory can be used to store
   * application logs.
   */
  logDirectory?: string;
  /**
   * The temp directory of the application on the node. The code packages belonging to the
   * application are forked with this directory set as their temporary directory.
   */
  tempDirectory?: string;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
}

/**
 * Represents health evaluation for deployed applications, containing health evaluations for each
 * unhealthy deployed application that impacted current aggregated health state.
 * Can be returned when evaluating application health and the aggregated health state is either
 * Error or Warning.
 */
export interface DeployedApplicationsHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeployedApplications";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Maximum allowed percentage of unhealthy deployed applications from the
   * ApplicationHealthPolicy.
   */
  maxPercentUnhealthyDeployedApplications?: number;
  /**
   * Total number of deployed applications of the application in the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy DeployedApplicationHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Information about the health of a service package for a specific application deployed on a
 * Service Fabric node.
 */
export interface DeployedServicePackageHealth extends EntityHealth {
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * Name of the service manifest.
   */
  serviceManifestName?: string;
  /**
   * Name of the node where this service package is deployed.
   */
  nodeName?: string;
}

/**
 * Represents health evaluation for a deployed service package, containing information about the
 * data and the algorithm used by health store to evaluate health. The evaluation is returned only
 * when the aggregated health state is either Error or Warning.
 */
export interface DeployedServicePackageHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeployedServicePackage";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * The name of the service manifest.
   */
  serviceManifestName?: string;
  /**
   * List of unhealthy evaluations that led to the current aggregated health state. The type of the
   * unhealthy evaluations can be EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Represents health evaluation for deployed service packages, containing health evaluations for
 * each unhealthy deployed service package that impacted current aggregated health state. Can be
 * returned when evaluating deployed application health and the aggregated health state is either
 * Error or Warning.
 */
export interface DeployedServicePackagesHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeployedServicePackages";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Total number of deployed service packages of the deployed application in the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy DeployedServicePackageHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Contains the possible cases for DeployedServiceReplicaInfo.
 */
export type DeployedServiceReplicaInfoUnion = DeployedServiceReplicaInfo | DeployedStatefulServiceReplicaInfo | DeployedStatelessServiceInstanceInfo;

/**
 * Information about a Service Fabric service replica deployed on a node.
 */
export interface DeployedServiceReplicaInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "DeployedServiceReplicaInfo";
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName?: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * The name of the service manifest in which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * The name of the code package that hosts this replica.
   */
  codePackageName?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId?: string;
  /**
   * The status of a replica of a service. Possible values include: 'Invalid', 'InBuild',
   * 'Standby', 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * The last address returned by the replica in Open or ChangeRole.
   */
  address?: string;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * Host process ID of the process that is hosting the replica. This will be zero if the replica
   * is down. In hyper-v containers this host process ID will be from different kernel.
   */
  hostProcessId?: string;
}

/**
 * Information about current reconfiguration like phase, type, previous configuration role of
 * replica and reconfiguration start date time.
 */
export interface ReconfigurationInformation {
  /**
   * Replica role before reconfiguration started. Possible values include: 'Unknown', 'None',
   * 'Primary', 'IdleSecondary', 'ActiveSecondary'
   */
  previousConfigurationRole?: ReplicaRole;
  /**
   * Current phase of ongoing reconfiguration. If no reconfiguration is taking place then this
   * value will be "None". Possible values include: 'Unknown', 'None', 'Phase0', 'Phase1',
   * 'Phase2', 'Phase3', 'Phase4', 'AbortPhaseZero'
   */
  reconfigurationPhase?: ReconfigurationPhase;
  /**
   * Type of current ongoing reconfiguration. If no reconfiguration is taking place then this value
   * will be "None". Possible values include: 'Unknown', 'SwapPrimary', 'Failover', 'Other'
   */
  reconfigurationType?: ReconfigurationType;
  /**
   * Start time (in UTC) of the ongoing reconfiguration. If no reconfiguration is taking place then
   * this value will be zero date-time.
   */
  reconfigurationStartTimeUtc?: Date;
}

/**
 * Information about a stateful service replica deployed on a node.
 */
export interface DeployedStatefulServiceReplicaInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName?: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * The name of the service manifest in which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * The name of the code package that hosts this replica.
   */
  codePackageName?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId?: string;
  /**
   * The status of a replica of a service. Possible values include: 'Invalid', 'InBuild',
   * 'Standby', 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * The last address returned by the replica in Open or ChangeRole.
   */
  address?: string;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * Host process ID of the process that is hosting the replica. This will be zero if the replica
   * is down. In hyper-v containers this host process ID will be from different kernel.
   */
  hostProcessId?: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId?: string;
  /**
   * The role of a replica of a stateful service. Possible values include: 'Unknown', 'None',
   * 'Primary', 'IdleSecondary', 'ActiveSecondary'
   */
  replicaRole?: ReplicaRole;
  /**
   * Information about current reconfiguration like phase, type, previous configuration role of
   * replica and reconfiguration start date time.
   */
  reconfigurationInformation?: ReconfigurationInformation;
}

/**
 * Information about a stateless service instance deployed on a node.
 */
export interface DeployedStatelessServiceInstanceInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName?: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * The name of the service manifest in which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * The name of the code package that hosts this replica.
   */
  codePackageName?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId?: string;
  /**
   * The status of a replica of a service. Possible values include: 'Invalid', 'InBuild',
   * 'Standby', 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * The last address returned by the replica in Open or ChangeRole.
   */
  address?: string;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * Host process ID of the process that is hosting the replica. This will be zero if the replica
   * is down. In hyper-v containers this host process ID will be from different kernel.
   */
  hostProcessId?: string;
  /**
   * Id of a stateless service instance. InstanceId is used by Service Fabric to uniquely identify
   * an instance of a partition of a stateless service. It is unique within a partition and does
   * not change for the lifetime of the instance. If the instance has failed over on the same or
   * different node, it will get a different value for the InstanceId.
   */
  instanceId?: string;
}

/**
 * Represents common health report information. It is included in all health reports sent to health
 * store and in all health events returned by health queries.
 */
export interface HealthInformation {
  /**
   * The source name that identifies the client/watchdog/system component that generated the health
   * information.
   */
  sourceId: string;
  /**
   * The property of the health information. An entity can have health reports for different
   * properties.
   * The property is a string and not a fixed enumeration to allow the reporter flexibility to
   * categorize the state condition that triggers the report.
   * For example, a reporter with SourceId "LocalWatchdog" can monitor the state of the available
   * disk on a node,
   * so it can report "AvailableDisk" property on that node.
   * The same reporter can monitor the node connectivity, so it can report a property
   * "Connectivity" on the same node.
   * In the health store, these reports are treated as separate health events for the specified
   * node.
   *
   * Together with the SourceId, the property uniquely identifies the health information.
   */
  property: string;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState: HealthState;
  /**
   * The duration for which this health report is valid. This field uses ISO8601 format for
   * specifying the duration.
   * When clients report periodically, they should send reports with higher frequency than time to
   * live.
   * If clients report on transition, they can set the time to live to infinite.
   * When time to live expires, the health event that contains the health information
   * is either removed from health store, if RemoveWhenExpired is true, or evaluated at error, if
   * RemoveWhenExpired false.
   *
   * If not specified, time to live defaults to infinite value.
   */
  timeToLiveInMilliSeconds?: string;
  /**
   * The description of the health information. It represents free text used to add human readable
   * information about the report.
   * The maximum string length for the description is 4096 characters.
   * If the provided string is longer, it will be automatically truncated.
   * When truncated, the last characters of the description contain a marker "[Truncated]", and
   * total string size is 4096 characters.
   * The presence of the marker indicates to users that truncation occurred.
   * Note that when truncated, the description has less than 4096 characters from the original
   * string.
   */
  description?: string;
  /**
   * The sequence number for this health report as a numeric string.
   * The report sequence number is used by the health store to detect stale reports.
   * If not specified, a sequence number is auto-generated by the health client when a report is
   * added.
   */
  sequenceNumber?: string;
  /**
   * Value that indicates whether the report is removed from health store when it expires.
   * If set to true, the report is removed from the health store after it expires.
   * If set to false, the report is treated as an error when expired. The value of this property is
   * false by default.
   * When clients report periodically, they should set RemoveWhenExpired false (default).
   * This way, if the reporter has issues (e.g. deadlock) and can't report, the entity is evaluated
   * at error when the health report expires.
   * This flags the entity as being in Error health state.
   */
  removeWhenExpired?: boolean;
  /**
   * A health report ID which identifies the health report and can be used to find more detailed
   * information about a specific health event at
   * aka.ms/sfhealthid
   */
  healthReportId?: string;
}

/**
 * Represents health information reported on a health entity, such as cluster, application or node,
 * with additional metadata added by the Health Manager.
 */
export interface HealthEvent extends HealthInformation {
  /**
   * Returns true if the health event is expired, otherwise false.
   */
  isExpired?: boolean;
  /**
   * The date and time when the health report was sent by the source.
   */
  sourceUtcTimestamp?: Date;
  /**
   * The date and time when the health report was last modified by the health store.
   */
  lastModifiedUtcTimestamp?: Date;
  /**
   * If the current health state is 'Ok', this property returns the time at which the health report
   * was first reported with 'Ok'.
   * For periodic reporting, many reports with the same state may have been generated.
   * This property returns the date and time when the first 'Ok' health report was received.
   *
   * If the current health state is 'Error' or 'Warning', returns the date and time at which the
   * health state was last in 'Ok', before transitioning to a different state.
   *
   * If the health state was never 'Ok', the value will be zero date-time.
   */
  lastOkTransitionAt?: Date;
  /**
   * If the current health state is 'Warning', this property returns the time at which the health
   * report was first reported with 'Warning'. For periodic reporting, many reports with the same
   * state may have been generated however, this property returns only the date and time at the
   * first 'Warning' health report was received.
   *
   * If the current health state is 'Ok' or 'Error', returns the date and time at which the health
   * state was last in 'Warning', before transitioning to a different state.
   *
   * If the health state was never 'Warning', the value will be zero date-time.
   */
  lastWarningTransitionAt?: Date;
  /**
   * If the current health state is 'Error', this property returns the time at which the health
   * report was first reported with 'Error'. For periodic reporting, many reports with the same
   * state may have been generated however, this property returns only the date and time at the
   * first 'Error' health report was received.
   *
   * If the current health state is 'Ok' or 'Warning', returns the date and time at which the
   * health state was last in 'Error', before transitioning to a different state.
   *
   * If the health state was never 'Error', the value will be zero date-time.
   */
  lastErrorTransitionAt?: Date;
}

/**
 * Represents information about how many health entities are in Ok, Warning and Error health state.
 */
export interface HealthStateCount {
  /**
   * The number of health entities with aggregated health state Ok.
   */
  okCount?: number;
  /**
   * The number of health entities with aggregated health state Warning.
   */
  warningCount?: number;
  /**
   * The number of health entities with aggregated health state Error.
   */
  errorCount?: number;
}

/**
 * Represents health state count for entities of the specified entity kind.
 */
export interface EntityKindHealthStateCount {
  /**
   * The entity kind for which health states are evaluated. Possible values include: 'Invalid',
   * 'Node', 'Partition', 'Service', 'Application', 'Replica', 'DeployedApplication',
   * 'DeployedServicePackage', 'Cluster'
   */
  entityKind?: EntityKind;
  /**
   * The health state count for the entities of the specified kind.
   */
  healthStateCount?: HealthStateCount;
}

/**
 * The health statistics of an entity, returned as part of the health query result when the query
 * description is configured to include statistics.
 * The statistics include health state counts for all children types of the current entity.
 * For example, for cluster, the health statistics include health state counts for nodes,
 * applications, services, partitions, replicas, deployed applications and deployed service
 * packages.
 * For partition, the health statistics include health counts for replicas.
 */
export interface HealthStatistics {
  /**
   * List of health state counts per entity kind, which keeps track of how many children of the
   * queried entity are in Ok, Warning and Error state.
   */
  healthStateCountList?: EntityKindHealthStateCount[];
}

/**
 * An Epoch is a configuration number for the partition as a whole. When the configuration of the
 * replica set changes, for example when the Primary replica changes, the operations that are
 * replicated from the new Primary replica are said to be a new Epoch from the ones which were sent
 * by the old Primary replica.
 */
export interface Epoch {
  /**
   * The current configuration number of this Epoch. The configuration number is an increasing
   * value that is updated whenever the configuration of this replica set changes.
   */
  configurationVersion?: string;
  /**
   * The current data loss number of this Epoch. The data loss number property is an increasing
   * value which is updated whenever data loss is suspected, as when loss of a quorum of replicas
   * in the replica set that includes the Primary replica.
   */
  dataLossVersion?: string;
}

/**
 * Represents health evaluation of a HealthEvent that was reported on the entity.
 * The health evaluation is returned when evaluating health of an entity results in Error or
 * Warning.
 */
export interface EventHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Event";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Indicates whether warnings are treated with the same severity as errors. The field is
   * specified in the health policy used to evaluate the entity.
   */
  considerWarningAsError?: boolean;
  /**
   * Represents health information reported on a health entity, such as cluster, application or
   * node, with additional metadata added by the Health Manager.
   */
  unhealthyEvent?: HealthEvent;
}

/**
 * Information about a Service Fabric code version.
 */
export interface FabricCodeVersionInfo {
  /**
   * The product version of Service Fabric.
   */
  codeVersion?: string;
}

/**
 * Information about a Service Fabric config version.
 */
export interface FabricConfigVersionInfo {
  /**
   * The config version of Service Fabric.
   */
  configVersion?: string;
}

/**
 * Information about a standalone cluster configuration upgrade status.
 */
export interface ClusterConfigurationUpgradeStatusInfo {
  /**
   * The state of the upgrade domain. Possible values include: 'Invalid', 'RollingBackInProgress',
   * 'RollingBackCompleted', 'RollingForwardPending', 'RollingForwardInProgress',
   * 'RollingForwardCompleted', 'Failed'
   */
  upgradeState?: UpgradeState;
  /**
   * The cluster manifest version.
   */
  progressStatus?: number;
  /**
   * The cluster configuration version.
   */
  configVersion?: string;
  /**
   * The cluster upgrade status details.
   */
  details?: string;
}

/**
 * Contains the possible cases for PartitionInformation.
 */
export type PartitionInformationUnion = PartitionInformation | Int64RangePartitionInformation | NamedPartitionInformation | SingletonPartitionInformation;

/**
 * Information about the partition identity, partitioning scheme and keys supported by it.
 */
export interface PartitionInformation {
  /**
   * Polymorphic Discriminator
   */
  servicePartitionKind: "PartitionInformation";
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  id?: string;
}

/**
 * Describes the partition information for the integer range that is based on partition schemes.
 */
export interface Int64RangePartitionInformation {
  /**
   * Polymorphic Discriminator
   */
  servicePartitionKind: "Int64Range";
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  id?: string;
  /**
   * Specifies the minimum key value handled by this partition.
   */
  lowKey?: string;
  /**
   * Specifies the maximum key value handled by this partition.
   */
  highKey?: string;
}

/**
 * Describes the partition information for the name as a string that is based on partition schemes.
 */
export interface NamedPartitionInformation {
  /**
   * Polymorphic Discriminator
   */
  servicePartitionKind: "Named";
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  id?: string;
  /**
   * Name of the partition.
   */
  name?: string;
}

/**
 * Identity of the task related to deactivation operation on the node.
 */
export interface NodeDeactivationTaskId {
  /**
   * Value of the task id.
   */
  id?: string;
  /**
   * The type of the task that performed the node deactivation. Following are the possible values.
   * Possible values include: 'Invalid', 'Infrastructure', 'Repair', 'Client'
   */
  nodeDeactivationTaskType?: NodeDeactivationTaskType;
}

/**
 * The task representing the deactivation operation on the node.
 */
export interface NodeDeactivationTask {
  /**
   * Identity of the task related to deactivation operation on the node.
   */
  nodeDeactivationTaskId?: NodeDeactivationTaskId;
  /**
   * The intent or the reason for deactivating the node. Following are the possible values for it.
   * Possible values include: 'Invalid', 'Pause', 'Restart', 'RemoveData', 'RemoveNode'
   */
  nodeDeactivationIntent?: NodeDeactivationIntent;
}

/**
 * Information about the node deactivation. This information is valid for a node that is undergoing
 * deactivation or has already been deactivated.
 */
export interface NodeDeactivationInfo {
  /**
   * The intent or the reason for deactivating the node. Following are the possible values for it.
   * Possible values include: 'Invalid', 'Pause', 'Restart', 'RemoveData', 'RemoveNode'
   */
  nodeDeactivationIntent?: NodeDeactivationIntent;
  /**
   * The status of node deactivation operation. Following are the possible values. Possible values
   * include: 'None', 'SafetyCheckInProgress', 'SafetyCheckComplete', 'Completed'
   */
  nodeDeactivationStatus?: NodeDeactivationStatus;
  /**
   * List of tasks representing the deactivation operation on the node.
   */
  nodeDeactivationTask?: NodeDeactivationTask[];
  /**
   * List of pending safety checks
   */
  pendingSafetyChecks?: SafetyCheckWrapper[];
}

/**
 * Contains the possible cases for NodeEvent.
 */
export type NodeEventUnion = NodeEvent | NodeAbortedEvent | NodeAddedToClusterEvent | NodeClosedEvent | NodeDeactivateCompletedEvent | NodeDeactivateStartedEvent | NodeDownEvent | NodeNewHealthReportEvent | NodeHealthReportExpiredEvent | NodeOpenSucceededEvent | NodeOpenFailedEvent | NodeRemovedFromClusterEvent | NodeUpEvent | ChaosNodeRestartScheduledEvent;

/**
 * Represents the base for all Node Events.
 */
export interface NodeEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
}

/**
 * Information about the health of a Service Fabric node.
 */
export interface NodeHealth extends EntityHealth {
  /**
   * Name of the node whose health information is described by this object.
   */
  name?: string;
}

/**
 * Represents health evaluation for a node, containing information about the data and the algorithm
 * used by health store to evaluate health. The evaluation is returned only when the aggregated
 * health state is either Error or Warning.
 */
export interface NodeHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Node";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * List of unhealthy evaluations that led to the current aggregated health state of the node. The
   * types of the unhealthy evaluations can be EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Information about a node in Service Fabric cluster.
 */
export interface NodeInfo {
  /**
   * The name of a Service Fabric node.
   */
  name?: string;
  /**
   * The IP address or fully qualified domain name of the node.
   */
  ipAddressOrFQDN?: string;
  /**
   * The type of the node.
   */
  type?: string;
  /**
   * The version of Service Fabric binaries that the node is running.
   */
  codeVersion?: string;
  /**
   * The version of Service Fabric cluster manifest that the node is using.
   */
  configVersion?: string;
  /**
   * The status of the node. Possible values include: 'Invalid', 'Up', 'Down', 'Enabling',
   * 'Disabling', 'Disabled', 'Unknown', 'Removed'
   */
  nodeStatus?: NodeStatus;
  /**
   * Time in seconds since the node has been in NodeStatus Up. Value zero indicates that the node
   * is not Up.
   */
  nodeUpTimeInSeconds?: string;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * Indicates if the node is a seed node or not. Returns true if the node is a seed node,
   * otherwise false. A quorum of seed nodes are required for proper operation of Service Fabric
   * cluster.
   */
  isSeedNode?: boolean;
  /**
   * The upgrade domain of the node.
   */
  upgradeDomain?: string;
  /**
   * The fault domain of the node.
   */
  faultDomain?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a node. Node Id is
   * deterministically generated from node name.
   */
  id?: NodeId;
  /**
   * The ID representing the node instance. While the ID of the node is deterministically generated
   * from the node name and remains same across restarts, the InstanceId changes every time node
   * restarts.
   */
  instanceId?: string;
  /**
   * Information about the node deactivation. This information is valid for a node that is
   * undergoing deactivation or has already been deactivated.
   */
  nodeDeactivationInfo?: NodeDeactivationInfo;
  /**
   * Indicates if the node is stopped by calling stop node API or not. Returns true if the node is
   * stopped, otherwise false.
   */
  isStopped?: boolean;
  /**
   * Time in seconds since the node has been in NodeStatus Down. Value zero indicates node is not
   * NodeStatus Down.
   */
  nodeDownTimeInSeconds?: string;
  /**
   * Date time in UTC when the node came up. If the node has never been up then this value will be
   * zero date time.
   */
  nodeUpAt?: Date;
  /**
   * Date time in UTC when the node went down. If node has never been down then this value will be
   * zero date time.
   */
  nodeDownAt?: Date;
}

/**
 * Represents data structure that contains load information for a certain metric on a node.
 */
export interface NodeLoadMetricInformation {
  /**
   * Name of the metric for which this load information is provided.
   */
  name?: string;
  /**
   * Total capacity on the node for this metric.
   */
  nodeCapacity?: string;
  /**
   * Current load on the node for this metric. In future releases of Service Fabric this parameter
   * will be deprecated in favor of CurrentNodeLoad.
   */
  nodeLoad?: string;
  /**
   * The remaining capacity on the node for this metric. In future releases of Service Fabric this
   * parameter will be deprecated in favor of NodeCapacityRemaining.
   */
  nodeRemainingCapacity?: string;
  /**
   * Indicates if there is a capacity violation for this metric on the node.
   */
  isCapacityViolation?: boolean;
  /**
   * The value that indicates the reserved capacity for this metric on the node.
   */
  nodeBufferedCapacity?: string;
  /**
   * The remaining reserved capacity for this metric on the node. In future releases of Service
   * Fabric this parameter will be deprecated in favor of BufferedNodeCapacityRemaining.
   */
  nodeRemainingBufferedCapacity?: string;
  /**
   * Current load on the node for this metric.
   */
  currentNodeLoad?: string;
  /**
   * The remaining capacity on the node for the metric.
   */
  nodeCapacityRemaining?: string;
  /**
   * The remaining capacity which is not reserved by NodeBufferPercentage for this metric on the
   * node.
   */
  bufferedNodeCapacityRemaining?: string;
  /**
   * This value represents the load of the replicas that are planned to be removed in the future.
   * This kind of load is reported for replicas that are currently being moving to other nodes and
   * for replicas that are currently being dropped but still use the load on the source node.
   */
  plannedNodeLoadRemoval?: string;
}

/**
 * Information about load on a Service Fabric node. It holds a summary of all metrics and their
 * load on a node.
 */
export interface NodeLoadInfo {
  /**
   * Name of the node for which the load information is provided by this object.
   */
  nodeName?: string;
  /**
   * List that contains metrics and their load information on this node.
   */
  nodeLoadMetricInformation?: NodeLoadMetricInformation[];
}

/**
 * Represents health evaluation for nodes, containing health evaluations for each unhealthy node
 * that impacted current aggregated health state. Can be returned when evaluating cluster health
 * and the aggregated health state is either Error or Warning.
 */
export interface NodesHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Nodes";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Maximum allowed percentage of unhealthy nodes from the ClusterHealthPolicy.
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * Total number of nodes found in the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy NodeHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * The list of applications in the cluster. The list is paged when all of the results cannot fit in
 * a single message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedApplicationInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of application information.
   */
  items?: ApplicationInfo[];
}

/**
 * The list of deployed applications in activating, downloading, or active states on a node.
 * The list is paged when all of the results cannot fit in a single message.
 * The next set of results can be obtained by executing the same query with the continuation token
 * provided in this list.
 */
export interface PagedDeployedApplicationInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of deployed application information.
   */
  items?: DeployedApplicationInfo[];
}

/**
 * The list of nodes in the cluster. The list is paged when all of the results cannot fit in a
 * single message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedNodeInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of node information.
   */
  items?: NodeInfo[];
}

/**
 * Contains the possible cases for ServicePartitionInfo.
 */
export type ServicePartitionInfoUnion = ServicePartitionInfo | StatefulServicePartitionInfo | StatelessServicePartitionInfo;

/**
 * Information about a partition of a Service Fabric service.
 */
export interface ServicePartitionInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ServicePartitionInfo";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The status of the service fabric service partition. Possible values include: 'Invalid',
   * 'Ready', 'NotReady', 'InQuorumLoss', 'Reconfiguring', 'Deleting'
   */
  partitionStatus?: ServicePartitionStatus;
  /**
   * Information about the partition identity, partitioning scheme and keys supported by it.
   */
  partitionInformation?: PartitionInformationUnion;
}

/**
 * The list of partition in the cluster for a service. The list is paged when all of the results
 * cannot fit in a single message. The next set of results can be obtained by executing the same
 * query with the continuation token provided in this list.
 */
export interface PagedServicePartitionInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of service partition information.
   */
  items?: ServicePartitionInfoUnion[];
}

/**
 * Contains the possible cases for ReplicaInfo.
 */
export type ReplicaInfoUnion = ReplicaInfo | StatefulServiceReplicaInfo | StatelessServiceInstanceInfo;

/**
 * Information about the identity, status, health, node name, uptime, and other details about the
 * replica.
 */
export interface ReplicaInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ReplicaInfo";
  /**
   * The status of a replica of a service. Possible values include: 'Invalid', 'InBuild',
   * 'Standby', 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * The address the replica is listening on.
   */
  address?: string;
  /**
   * The last in build duration of the replica in seconds.
   */
  lastInBuildDurationInSeconds?: string;
}

/**
 * The list of replicas in the cluster for a given partition. The list is paged when all of the
 * results cannot fit in a single message. The next set of results can be obtained by executing the
 * same query with the continuation token provided in this list.
 */
export interface PagedReplicaInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of replica information.
   */
  items?: ReplicaInfoUnion[];
}

/**
 * Contains the possible cases for ServiceInfo.
 */
export type ServiceInfoUnion = ServiceInfo | StatefulServiceInfo | StatelessServiceInfo;

/**
 * Information about a Service Fabric service.
 */
export interface ServiceInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ServiceInfo";
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  id?: string;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  typeName?: string;
  /**
   * The version of the service manifest.
   */
  manifestVersion?: string;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The status of the application. Possible values include: 'Unknown', 'Active', 'Upgrading',
   * 'Deleting', 'Creating', 'Failed'
   */
  serviceStatus?: ServiceStatus;
  /**
   * Whether the service is in a service group.
   */
  isServiceGroup?: boolean;
}

/**
 * The list of services in the cluster for an application. The list is paged when all of the
 * results cannot fit in a single message. The next set of results can be obtained by executing the
 * same query with the continuation token provided in this list.
 */
export interface PagedServiceInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of service information.
   */
  items?: ServiceInfoUnion[];
}

/**
 * Contains the possible cases for PartitionEvent.
 */
export type PartitionEventUnion = PartitionEvent | PartitionAnalysisEventUnion | PartitionNewHealthReportEvent | PartitionHealthReportExpiredEvent | PartitionReconfiguredEvent | ChaosPartitionSecondaryMoveScheduledEvent | ChaosPartitionPrimaryMoveScheduledEvent;

/**
 * Represents the base for all Partition Events.
 */
export interface PartitionEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "PartitionEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
}

/**
 * Contains the possible cases for PartitionAnalysisEvent.
 */
export type PartitionAnalysisEventUnion = PartitionAnalysisEvent | PartitionPrimaryMoveAnalysisEvent;

/**
 * Represents the base for all Partition Analysis Events.
 */
export interface PartitionAnalysisEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "PartitionAnalysisEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Metadata about an Analysis Event.
   */
  metadata: AnalysisEventMetadata;
}

/**
 * Contains the possible cases for ReplicaHealthState.
 */
export type ReplicaHealthStateUnion = ReplicaHealthState | StatefulServiceReplicaHealthState | StatelessServiceInstanceHealthState;

/**
 * Represents a base class for stateful service replica or stateless service instance health state.
 */
export interface ReplicaHealthState {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ReplicaHealthState";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * The ID of the partition to which this replica belongs.
   */
  partitionId?: string;
}

/**
 * Information about the health of a Service Fabric partition.
 */
export interface PartitionHealth extends EntityHealth {
  /**
   * ID of the partition whose health information is described by this object.
   */
  partitionId?: string;
  /**
   * The list of replica health states associated with the partition.
   */
  replicaHealthStates?: ReplicaHealthStateUnion[];
}

/**
 * Represents health evaluation for a partition, containing information about the data and the
 * algorithm used by health store to evaluate health. The evaluation is returned only when the
 * aggregated health state is either Error or Warning.
 */
export interface PartitionHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Partition";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Id of the partition whose health evaluation is described by this object.
   */
  partitionId?: string;
  /**
   * List of unhealthy evaluations that led to the current aggregated health state of the
   * partition. The types of the unhealthy evaluations can be ReplicasHealthEvaluation or
   * EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Represents the health state of a partition, which contains the partition identifier and its
 * aggregated health state.
 */
export interface PartitionHealthState extends EntityHealthState {
  /**
   * Id of the partition whose health state is described by this object.
   */
  partitionId?: string;
}

/**
 * Describes the parameters for provisioning a cluster.
 */
export interface ProvisionFabricDescription {
  /**
   * The cluster code package file path.
   */
  codeFilePath?: string;
  /**
   * The cluster manifest file path.
   */
  clusterManifestFilePath?: string;
}

/**
 * Contains the possible cases for ProvisionApplicationTypeDescriptionBase.
 */
export type ProvisionApplicationTypeDescriptionBaseUnion = ProvisionApplicationTypeDescriptionBase | ProvisionApplicationTypeDescription | ExternalStoreProvisionApplicationTypeDescription;

/**
 * Represents the type of registration or provision requested, and if the operation needs to be
 * asynchronous or not. Supported types of provision operations are from either image store or
 * external store.
 */
export interface ProvisionApplicationTypeDescriptionBase {
  /**
   * Polymorphic Discriminator
   */
  kind: "ProvisionApplicationTypeDescriptionBase";
  /**
   * Indicates whether or not provisioning should occur asynchronously. When set to true, the
   * provision operation returns when the request is accepted by the system, and the provision
   * operation continues without any timeout limit. The default value is false. For large
   * application packages, we recommend setting the value to true.
   */
  async: boolean;
}

/**
 * Describes the operation to register or provision an application type using an application
 * package uploaded to the Service Fabric image store.
 */
export interface ProvisionApplicationTypeDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "ImageStorePath";
  /**
   * Indicates whether or not provisioning should occur asynchronously. When set to true, the
   * provision operation returns when the request is accepted by the system, and the provision
   * operation continues without any timeout limit. The default value is false. For large
   * application packages, we recommend setting the value to true.
   */
  async: boolean;
  /**
   * The relative path for the application package in the image store specified during the prior
   * upload operation.
   */
  applicationTypeBuildPath: string;
  /**
   * The kind of action that needs to be taken for cleaning up the application package after
   * successful provision. Possible values include: 'Invalid', 'Default', 'Automatic', 'Manual'
   */
  applicationPackageCleanupPolicy?: ApplicationPackageCleanupPolicy;
}

/**
 * Describes the operation to register or provision an application type using an application
 * package from an external store instead of a package uploaded to the Service Fabric image store.
 */
export interface ExternalStoreProvisionApplicationTypeDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "ExternalStore";
  /**
   * Indicates whether or not provisioning should occur asynchronously. When set to true, the
   * provision operation returns when the request is accepted by the system, and the provision
   * operation continues without any timeout limit. The default value is false. For large
   * application packages, we recommend setting the value to true.
   */
  async: boolean;
  /**
   * The path to the '.sfpkg' application package from where the application package can be
   * downloaded using HTTP or HTTPS protocols. The application package can be stored in an external
   * store that provides GET operation to download the file. Supported protocols are HTTP and
   * HTTPS, and the path must allow READ access.
   */
  applicationPackageDownloadUri: string;
  /**
   * The application type name represents the name of the application type found in the application
   * manifest.
   */
  applicationTypeName: string;
  /**
   * The application type version represents the version of the application type found in the
   * application manifest.
   */
  applicationTypeVersion: string;
}

/**
 * Describes the parameters for unprovisioning a cluster.
 */
export interface UnprovisionFabricDescription {
  /**
   * The cluster code package version.
   */
  codeVersion?: string;
  /**
   * The cluster manifest version.
   */
  configVersion?: string;
}

/**
 * Describes the parameters for resuming a cluster upgrade.
 */
export interface ResumeClusterUpgradeDescription {
  /**
   * The next upgrade domain for this cluster upgrade.
   */
  upgradeDomain: string;
}

/**
 * Defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
 */
export interface ClusterUpgradeHealthPolicyObject {
  /**
   * The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
   * The delta is measured between the state of the nodes at the beginning of upgrade and the state
   * of the nodes at the time of the health evaluation. The check is performed after every upgrade
   * domain upgrade completion to make sure the global state of the cluster is within tolerated
   * limits. The default value is 10%.
   */
  maxPercentDeltaUnhealthyNodes?: number;
  /**
   * The maximum allowed percentage of upgrade domain nodes health degradation allowed during
   * cluster upgrades. The delta is measured between the state of the upgrade domain nodes at the
   * beginning of upgrade and the state of the upgrade domain nodes at the time of the health
   * evaluation. The check is performed after every upgrade domain upgrade completion for all
   * completed upgrade domains to make sure the state of the upgrade domains is within tolerated
   * limits. The default value is 15%.
   */
  maxPercentUpgradeDomainDeltaUnhealthyNodes?: number;
}

/**
 * Describes the parameters for starting a cluster upgrade.
 */
export interface StartClusterUpgradeDescription {
  /**
   * The cluster code version.
   */
  codeVersion?: string;
  /**
   * The cluster configuration version.
   */
  configVersion?: string;
  /**
   * The kind of upgrade out of the following possible values. Possible values include: 'Invalid',
   * 'Rolling'. Default value: 'Rolling'.
   */
  upgradeKind?: UpgradeKind;
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto'.
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has
   * not changed (the upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * Defines the order in which an upgrade proceeds through the cluster. Possible values include:
   * 'Invalid', 'Default', 'Numeric', 'Lexicographical', 'ReverseNumeric',
   * 'ReverseLexicographical'. Default value: 'Default'.
   */
  sortOrder?: UpgradeSortOrder;
  /**
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * When true, enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   */
  enableDeltaHealthEvaluation?: boolean;
  /**
   * Defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
   */
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  /**
   * Defines the application health policy map used to evaluate the health of an application or one
   * of its children entities.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicies;
  /**
   * Duration in seconds, to wait before a stateless instance is closed, to allow the active
   * requests to drain gracefully. This would be effective when the instance is closing during the
   * application/cluster
   * upgrade, only for those instances which have a non-zero delay duration configured in the
   * service description. See InstanceCloseDelayDurationSeconds property in $ref:
   * "#/definitions/StatelessServiceDescription.yaml" for details.
   * Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
   * that the behavior will entirely depend on the delay configured in the stateless service
   * description.
   */
  instanceCloseDelayDurationInSeconds?: number;
}

/**
 * Describes the parameters for updating a rolling upgrade of application or cluster.
 */
export interface RollingUpgradeUpdateDescription {
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto'.
   */
  rollingUpgradeMode: UpgradeMode;
  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has
   * not changed (the upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  replicaSetCheckTimeoutInMilliseconds?: number;
  /**
   * The compensating action to perform when a Monitored upgrade encounters monitoring policy or
   * health policy violations.
   * Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will
   * start rolling back automatically.
   * Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode. Possible
   * values include: 'Invalid', 'Rollback', 'Manual'
   */
  failureAction?: FailureAction;
  /**
   * The amount of time to wait after completing an upgrade domain before applying health policies.
   * It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it
   * is interpreted as a number representing the total number of milliseconds.
   */
  healthCheckWaitDurationInMilliseconds?: string;
  /**
   * The amount of time that the application or cluster must remain healthy before the upgrade
   * proceeds to the next upgrade domain. It is first interpreted as a string representing an ISO
   * 8601 duration. If that fails, then it is interpreted as a number representing the total number
   * of milliseconds.
   */
  healthCheckStableDurationInMilliseconds?: string;
  /**
   * The amount of time to retry health evaluation when the application or cluster is unhealthy
   * before FailureAction is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the total number of
   * milliseconds.
   */
  healthCheckRetryTimeoutInMilliseconds?: string;
  /**
   * The amount of time the overall upgrade has to complete before FailureAction is executed. It is
   * first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  upgradeTimeoutInMilliseconds?: string;
  /**
   * The amount of time each upgrade domain has to complete before FailureAction is executed. It is
   * first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  upgradeDomainTimeoutInMilliseconds?: string;
  /**
   * Duration in seconds, to wait before a stateless instance is closed, to allow the active
   * requests to drain gracefully. This would be effective when the instance is closing during the
   * application/cluster
   * upgrade, only for those instances which have a non-zero delay duration configured in the
   * service description. See InstanceCloseDelayDurationSeconds property in $ref:
   * "#/definitions/StatelessServiceDescription.yaml" for details.
   * Note, the default value of InstanceCloseDelayDurationInSeconds is 4294967295, which indicates
   * that the behavior will entirely depend on the delay configured in the stateless service
   * description.
   */
  instanceCloseDelayDurationInSeconds?: number;
}

/**
 * Parameters for updating a cluster upgrade.
 */
export interface UpdateClusterUpgradeDescription {
  /**
   * The type of upgrade out of the following possible values. Possible values include: 'Invalid',
   * 'Rolling', 'Rolling_ForceRestart'. Default value: 'Rolling'.
   */
  upgradeKind?: UpgradeType;
  /**
   * Describes the parameters for updating a rolling upgrade of application or cluster.
   */
  updateDescription?: RollingUpgradeUpdateDescription;
  /**
   * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * When true, enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   */
  enableDeltaHealthEvaluation?: boolean;
  /**
   * Defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
   */
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  /**
   * Defines the application health policy map used to evaluate the health of an application or one
   * of its children entities.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicies;
}

/**
 * Contains the possible cases for PartitionSafetyCheck.
 */
export type PartitionSafetyCheckUnion = PartitionSafetyCheck | EnsureAvailabilitySafetyCheck | EnsurePartitionQuorumSafetyCheck | WaitForInbuildReplicaSafetyCheck | WaitForPrimaryPlacementSafetyCheck | WaitForPrimarySwapSafetyCheck | WaitForReconfigurationSafetyCheck;

/**
 * Represents a safety check for the service partition being performed by service fabric before
 * continuing with operations.
 */
export interface PartitionSafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "PartitionSafetyCheck";
  /**
   * Id of the partition which is undergoing the safety check.
   */
  partitionId?: string;
}

/**
 * Safety check that waits to ensure the availability of the partition. It waits until there are
 * replicas available such that bringing down this replica will not cause availability loss for the
 * partition.
 */
export interface EnsureAvailabilitySafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "EnsureAvailability";
  /**
   * Id of the partition which is undergoing the safety check.
   */
  partitionId?: string;
}

/**
 * Safety check that ensures that a quorum of replicas are not lost for a partition.
 */
export interface EnsurePartitionQuorumSafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "EnsurePartitionQuorum";
  /**
   * Id of the partition which is undergoing the safety check.
   */
  partitionId?: string;
}

/**
 * Represents a safety check for the seed nodes being performed by service fabric before continuing
 * with node level operations.
 */
export interface SeedNodeSafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "EnsureSeedNodeQuorum";
}

/**
 * Represents health evaluation for the partitions of a service, containing health evaluations for
 * each unhealthy partition that impacts current aggregated health state. Can be returned when
 * evaluating service health and the aggregated health state is either Error or Warning.
 */
export interface PartitionsHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Partitions";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Maximum allowed percentage of unhealthy partitions per service from the
   * ServiceTypeHealthPolicy.
   */
  maxPercentUnhealthyPartitionsPerService?: number;
  /**
   * Total number of partitions of the service from the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy PartitionHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Contains the possible cases for ReplicaEvent.
 */
export type ReplicaEventUnion = ReplicaEvent | StatefulReplicaNewHealthReportEvent | StatefulReplicaHealthReportExpiredEvent | StatelessReplicaNewHealthReportEvent | StatelessReplicaHealthReportExpiredEvent | ChaosReplicaRemovalScheduledEvent | ChaosReplicaRestartScheduledEvent;

/**
 * Represents the base for all Replica Events.
 */
export interface ReplicaEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ReplicaEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId: number;
}

/**
 * Contains the possible cases for ReplicaHealth.
 */
export type ReplicaHealthUnion = ReplicaHealth | StatefulServiceReplicaHealth | StatelessServiceInstanceHealth;

/**
 * Represents a base class for stateful service replica or stateless service instance health.
 * Contains the replica aggregated health state, the health events and the unhealthy evaluations.
 */
export interface ReplicaHealth {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ReplicaHealth";
  /**
   * The HealthState representing the aggregated health state of the entity computed by Health
   * Manager.
   * The health evaluation of the entity reflects all events reported on the entity and its
   * children (if any).
   * The aggregation is done by applying the desired health policy. Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * The list of health events reported on the entity.
   */
  healthEvents?: HealthEvent[];
  /**
   * The unhealthy evaluations that show why the current aggregated health state was returned by
   * Health Manager.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * Shows the health statistics for all children types of the queried entity.
   */
  healthStatistics?: HealthStatistics;
  /**
   * Id of the partition to which this replica belongs.
   */
  partitionId?: string;
}

/**
 * Represents health evaluation for a replica, containing information about the data and the
 * algorithm used by health store to evaluate health. The evaluation is returned only when the
 * aggregated health state is either Error or Warning.
 */
export interface ReplicaHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Replica";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Id of the partition to which the replica belongs.
   */
  partitionId?: string;
  /**
   * Id of a stateful service replica or a stateless service instance. This ID is used in the
   * queries that apply to both stateful and stateless services. It is used by Service Fabric to
   * uniquely identify a replica of a partition of a stateful service or an instance of a stateless
   * service partition. It is unique within a partition and does not change for the lifetime of the
   * replica or the instance. If a stateful replica gets dropped and another replica gets created
   * on the same node for the same partition, it will get a different value for the ID. If a
   * stateless instance is failed over on the same or different node it will get a different value
   * for the ID.
   */
  replicaOrInstanceId?: string;
  /**
   * List of unhealthy evaluations that led to the current aggregated health state of the replica.
   * The types of the unhealthy evaluations can be EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Represents health evaluation for replicas, containing health evaluations for each unhealthy
 * replica that impacted current aggregated health state. Can be returned when evaluating partition
 * health and the aggregated health state is either Error or Warning.
 */
export interface ReplicasHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Replicas";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Maximum allowed percentage of unhealthy replicas per partition from the
   * ApplicationHealthPolicy.
   */
  maxPercentUnhealthyReplicasPerPartition?: number;
  /**
   * Total number of replicas in the partition from the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy ReplicaHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Describes the parameters to restart a Service Fabric node.
 */
export interface RestartNodeDescription {
  /**
   * The instance ID of the target node. If instance ID is specified the node is restarted only if
   * it matches with the current instance of the node. A default value of "0" would match any
   * instance ID. The instance ID can be obtained using get node query. Default value: '0'.
   */
  nodeInstanceId: string;
  /**
   * Specify True to create a dump of the fabric node process. This is case-sensitive. Possible
   * values include: 'False', 'True'. Default value: 'False'.
   */
  createFabricDump?: CreateFabricDump;
}

/**
 * Contains the possible cases for ServiceEvent.
 */
export type ServiceEventUnion = ServiceEvent | ServiceCreatedEvent | ServiceDeletedEvent | ServiceNewHealthReportEvent | ServiceHealthReportExpiredEvent;

/**
 * Represents the base for all Service Events.
 */
export interface ServiceEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ServiceEvent";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  serviceId: string;
}

/**
 * Defines description for creating a Service Fabric service from a template defined in the
 * application manifest.
 */
export interface ServiceFromTemplateDescription {
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName: string;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName: string;
  /**
   * The initialization data for the newly created service instance.
   */
  initializationData?: number[];
  /**
   * The activation mode of service package to be used for a service. Possible values include:
   * 'SharedProcess', 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ServicePackageActivationMode;
  /**
   * The DNS name of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   */
  serviceDnsName?: string;
}

/**
 * Represents health evaluation for a service, containing information about the data and the
 * algorithm used by health store to evaluate health. The evaluation is returned only when the
 * aggregated health state is either Error or Warning.
 */
export interface ServiceHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Service";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Name of the service whose health evaluation is described by this object.
   */
  serviceName?: string;
  /**
   * List of unhealthy evaluations that led to the current aggregated health state of the service.
   * The types of the unhealthy evaluations can be PartitionsHealthEvaluation or
   * EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Information about the health of a Service Fabric service.
 */
export interface ServiceHealth extends EntityHealth {
  /**
   * The name of the service whose health information is described by this object.
   */
  name?: string;
  /**
   * The list of partition health states associated with the service.
   */
  partitionHealthStates?: PartitionHealthState[];
}

/**
 * Information about the service name.
 */
export interface ServiceNameInfo {
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  id?: string;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  name?: string;
}

/**
 * Contains the possible cases for ServicePlacementPolicyDescription.
 */
export type ServicePlacementPolicyDescriptionUnion = ServicePlacementPolicyDescription | ServicePlacementInvalidDomainPolicyDescription | ServicePlacementNonPartiallyPlaceServicePolicyDescription | ServicePlacementPreferPrimaryDomainPolicyDescription | ServicePlacementRequiredDomainPolicyDescription | ServicePlacementRequireDomainDistributionPolicyDescription;

/**
 * Describes the policy to be used for placement of a Service Fabric service.
 */
export interface ServicePlacementPolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  type: "ServicePlacementPolicyDescription";
}

/**
 * Describes the policy to be used for placement of a Service Fabric service where a particular
 * fault or upgrade domain should not be used for placement of the instances or replicas of that
 * service.
 */
export interface ServicePlacementInvalidDomainPolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  type: "InvalidDomain";
  /**
   * The name of the domain that should not be used for placement.
   */
  domainName?: string;
}

/**
 * Describes the policy to be used for placement of a Service Fabric service where all replicas
 * must be able to be placed in order for any replicas to be created.
 */
export interface ServicePlacementNonPartiallyPlaceServicePolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  type: "NonPartiallyPlaceService";
}

/**
 * Describes the policy to be used for placement of a Service Fabric service where the service's
 * Primary replicas should optimally be placed in a particular domain.
 *
 * This placement policy is usually used with fault domains in scenarios where the Service Fabric
 * cluster is geographically distributed in order to indicate that a service's primary replica
 * should be located in a particular fault domain, which in geo-distributed scenarios usually
 * aligns with regional or datacenter boundaries. Note that since this is an optimization it is
 * possible that the Primary replica may not end up located in this domain due to failures,
 * capacity limits, or other constraints.
 */
export interface ServicePlacementPreferPrimaryDomainPolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  type: "PreferPrimaryDomain";
  /**
   * The name of the domain that should used for placement as per this policy.
   */
  domainName?: string;
}

/**
 * Describes the policy to be used for placement of a Service Fabric service where the instances or
 * replicas of that service must be placed in a particular domain
 */
export interface ServicePlacementRequiredDomainPolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  type: "RequireDomain";
  /**
   * The name of the domain that should used for placement as per this policy.
   */
  domainName?: string;
}

/**
 * Describes the policy to be used for placement of a Service Fabric service where two replicas
 * from the same partition should never be placed in the same fault or upgrade domain.
 *
 * While this is not common it can expose the service to an increased risk of concurrent failures
 * due to unplanned outages or other cases of subsequent/concurrent failures. As an example,
 * consider a case where replicas are deployed across different data center, with one replica per
 * location. In the event that one of the datacenters goes offline, normally the replica that was
 * placed in that datacenter will be packed into one of the remaining datacenters. If this is not
 * desirable then this policy should be set.
 */
export interface ServicePlacementRequireDomainDistributionPolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  type: "RequireDomainDistribution";
  /**
   * The name of the domain that should used for placement as per this policy.
   */
  domainName?: string;
}

/**
 * Represents health evaluation for services of a certain service type belonging to an application,
 * containing health evaluations for each unhealthy service that impacted current aggregated health
 * state. Can be returned when evaluating application health and the aggregated health state is
 * either Error or Warning.
 */
export interface ServicesHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Services";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Name of the service type of the services.
   */
  serviceTypeName?: string;
  /**
   * Maximum allowed percentage of unhealthy services from the ServiceTypeHealthPolicy.
   */
  maxPercentUnhealthyServices?: number;
  /**
   * Total number of services of the current service type in the application from the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy ServiceHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Specifies a metric to load balance a service during runtime.
 */
export interface ServiceLoadMetricDescription {
  /**
   * The name of the metric. If the service chooses to report load during runtime, the load metric
   * name should match the name that is specified in Name exactly. Note that metric names are
   * case-sensitive.
   */
  name: string;
  /**
   * The service load metric relative weight, compared to other metrics configured for this
   * service, as a number. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  weight?: ServiceLoadMetricWeight;
  /**
   * Used only for Stateful services. The default amount of load, as a number, that this service
   * creates for this metric when it is a Primary replica.
   */
  primaryDefaultLoad?: number;
  /**
   * Used only for Stateful services. The default amount of load, as a number, that this service
   * creates for this metric when it is a Secondary replica.
   */
  secondaryDefaultLoad?: number;
  /**
   * Used only for Stateless services. The default amount of load, as a number, that this service
   * creates for this metric.
   */
  defaultLoad?: number;
}

/**
 * Describes extension of a service type defined in the service manifest.
 */
export interface ServiceTypeExtensionDescription {
  /**
   * The name of the extension.
   */
  key?: string;
  /**
   * The extension value.
   */
  value?: string;
}

/**
 * Contains the possible cases for ServiceTypeDescription.
 */
export type ServiceTypeDescriptionUnion = ServiceTypeDescription | StatefulServiceTypeDescription | StatelessServiceTypeDescription;

/**
 * Describes a service type defined in the service manifest of a provisioned application type. The
 * properties the ones defined in the service manifest.
 */
export interface ServiceTypeDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "ServiceTypeDescription";
  /**
   * Indicates whether the service type is a stateful service type or a stateless service type.
   * This property is true if the service type is a stateful service type, false otherwise.
   */
  isStateful?: boolean;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * The placement constraint to be used when instantiating this service in a Service Fabric
   * cluster.
   */
  placementConstraints?: string;
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * List of service placement policy descriptions.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * List of service type extensions.
   */
  extensions?: ServiceTypeExtensionDescription[];
}

/**
 * Information about a service type that is defined in a service manifest of a provisioned
 * application type.
 */
export interface ServiceTypeInfo {
  /**
   * Describes a service type defined in the service manifest of a provisioned application type.
   * The properties the ones defined in the service manifest.
   */
  serviceTypeDescription?: ServiceTypeDescriptionUnion;
  /**
   * The name of the service manifest in which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * The version of the service manifest in which this service type is defined.
   */
  serviceManifestVersion?: string;
  /**
   * Indicates whether the service is a service group. If it is, the property value is true
   * otherwise false.
   */
  isServiceGroup?: boolean;
}

/**
 * Contains the manifest describing a service type registered as part of an application in a
 * Service Fabric cluster.
 */
export interface ServiceTypeManifest {
  /**
   * The XML manifest as a string.
   */
  manifest?: string;
}

/**
 * Information about a partition that is singleton. The services with singleton partitioning scheme
 * are effectively non-partitioned. They only have one partition.
 */
export interface SingletonPartitionInformation {
  /**
   * Polymorphic Discriminator
   */
  servicePartitionKind: "Singleton";
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  id?: string;
}

/**
 * Information about a stateful Service Fabric service.
 */
export interface StatefulServiceInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  id?: string;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  typeName?: string;
  /**
   * The version of the service manifest.
   */
  manifestVersion?: string;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The status of the application. Possible values include: 'Unknown', 'Active', 'Upgrading',
   * 'Deleting', 'Creating', 'Failed'
   */
  serviceStatus?: ServiceStatus;
  /**
   * Whether the service is in a service group.
   */
  isServiceGroup?: boolean;
  /**
   * Whether the service has persisted state.
   */
  hasPersistedState?: boolean;
}

/**
 * Information about a partition of a stateful Service Fabric service..
 */
export interface StatefulServicePartitionInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The status of the service fabric service partition. Possible values include: 'Invalid',
   * 'Ready', 'NotReady', 'InQuorumLoss', 'Reconfiguring', 'Deleting'
   */
  partitionStatus?: ServicePartitionStatus;
  /**
   * Information about the partition identity, partitioning scheme and keys supported by it.
   */
  partitionInformation?: PartitionInformationUnion;
  /**
   * The target replica set size as a number.
   */
  targetReplicaSetSize?: number;
  /**
   * The minimum replica set size as a number.
   */
  minReplicaSetSize?: number;
  /**
   * The duration for which this partition was in quorum loss. If the partition is currently in
   * quorum loss, it returns the duration since it has been in that state. This field is using
   * ISO8601 format for specifying the duration.
   */
  lastQuorumLossDuration?: string;
  /**
   * An Epoch is a configuration number for the partition as a whole. When the configuration of the
   * replica set changes, for example when the Primary replica changes, the operations that are
   * replicated from the new Primary replica are said to be a new Epoch from the ones which were
   * sent by the old Primary replica.
   */
  primaryEpoch?: Epoch;
}

/**
 * Represents the health of the stateful service replica.
 * Contains the replica aggregated health state, the health events and the unhealthy evaluations.
 */
export interface StatefulServiceReplicaHealth {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The HealthState representing the aggregated health state of the entity computed by Health
   * Manager.
   * The health evaluation of the entity reflects all events reported on the entity and its
   * children (if any).
   * The aggregation is done by applying the desired health policy. Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * The list of health events reported on the entity.
   */
  healthEvents?: HealthEvent[];
  /**
   * The unhealthy evaluations that show why the current aggregated health state was returned by
   * Health Manager.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * Shows the health statistics for all children types of the queried entity.
   */
  healthStatistics?: HealthStatistics;
  /**
   * Id of the partition to which this replica belongs.
   */
  partitionId?: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId?: string;
}

/**
 * Represents the health state of the stateful service replica, which contains the replica ID and
 * the aggregated health state.
 */
export interface StatefulServiceReplicaHealthState {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * The ID of the partition to which this replica belongs.
   */
  partitionId?: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId?: string;
}

/**
 * Describes a stateful service type defined in the service manifest of a provisioned application
 * type.
 */
export interface StatefulServiceTypeDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "Stateful";
  /**
   * Indicates whether the service type is a stateful service type or a stateless service type.
   * This property is true if the service type is a stateful service type, false otherwise.
   */
  isStateful?: boolean;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * The placement constraint to be used when instantiating this service in a Service Fabric
   * cluster.
   */
  placementConstraints?: string;
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * List of service placement policy descriptions.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * List of service type extensions.
   */
  extensions?: ServiceTypeExtensionDescription[];
  /**
   * A flag indicating whether this is a persistent service which stores states on the local disk.
   * If it is then the value of this property is true, if not it is false.
   */
  hasPersistedState?: boolean;
}

/**
 * Information about a stateless Service Fabric service.
 */
export interface StatelessServiceInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  id?: string;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  name?: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  typeName?: string;
  /**
   * The version of the service manifest.
   */
  manifestVersion?: string;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The status of the application. Possible values include: 'Unknown', 'Active', 'Upgrading',
   * 'Deleting', 'Creating', 'Failed'
   */
  serviceStatus?: ServiceStatus;
  /**
   * Whether the service is in a service group.
   */
  isServiceGroup?: boolean;
}

/**
 * Represents the health of the stateless service instance.
 * Contains the instance aggregated health state, the health events and the unhealthy evaluations.
 */
export interface StatelessServiceInstanceHealth {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The HealthState representing the aggregated health state of the entity computed by Health
   * Manager.
   * The health evaluation of the entity reflects all events reported on the entity and its
   * children (if any).
   * The aggregation is done by applying the desired health policy. Possible values include:
   * 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * The list of health events reported on the entity.
   */
  healthEvents?: HealthEvent[];
  /**
   * The unhealthy evaluations that show why the current aggregated health state was returned by
   * Health Manager.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * Shows the health statistics for all children types of the queried entity.
   */
  healthStatistics?: HealthStatistics;
  /**
   * Id of the partition to which this replica belongs.
   */
  partitionId?: string;
  /**
   * Id of a stateless service instance. InstanceId is used by Service Fabric to uniquely identify
   * an instance of a partition of a stateless service. It is unique within a partition and does
   * not change for the lifetime of the instance. If the instance has failed over on the same or
   * different node, it will get a different value for the InstanceId.
   */
  instanceId?: string;
}

/**
 * Represents the health state of the stateless service instance, which contains the instance ID
 * and the aggregated health state.
 */
export interface StatelessServiceInstanceHealthState {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * The ID of the partition to which this replica belongs.
   */
  partitionId?: string;
  /**
   * Id of the stateless service instance on the wire this field is called ReplicaId.
   */
  replicaId?: string;
}

/**
 * Information about a partition of a stateless Service Fabric service.
 */
export interface StatelessServicePartitionInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The status of the service fabric service partition. Possible values include: 'Invalid',
   * 'Ready', 'NotReady', 'InQuorumLoss', 'Reconfiguring', 'Deleting'
   */
  partitionStatus?: ServicePartitionStatus;
  /**
   * Information about the partition identity, partitioning scheme and keys supported by it.
   */
  partitionInformation?: PartitionInformationUnion;
  /**
   * Number of instances of this partition.
   */
  instanceCount?: number;
  /**
   * MinInstanceCount is the minimum number of instances that must be up to meet the
   * EnsureAvailability safety check during operations like upgrade or deactivate node.
   * The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
   * InstanceCount) ).
   * Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
   * into the number of nodes on which the instances are allowed to be placed according to the
   * placement constraints on the service.
   */
  minInstanceCount?: number;
  /**
   * MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the
   * EnsureAvailability safety check during operations like upgrade or deactivate node.
   * The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
   * InstanceCount) ).
   * Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
   * converted into the number of nodes on which the instances are allowed to be placed according
   * to the placement constraints on the service.
   */
  minInstancePercentage?: number;
}

/**
 * Describes a stateless service type defined in the service manifest of a provisioned application
 * type.
 */
export interface StatelessServiceTypeDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "Stateless";
  /**
   * Indicates whether the service type is a stateful service type or a stateless service type.
   * This property is true if the service type is a stateful service type, false otherwise.
   */
  isStateful?: boolean;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * The placement constraint to be used when instantiating this service in a Service Fabric
   * cluster.
   */
  placementConstraints?: string;
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * List of service placement policy descriptions.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * List of service type extensions.
   */
  extensions?: ServiceTypeExtensionDescription[];
  /**
   * A flag indicating if this type is not implemented and hosted by a user service process, but is
   * implicitly hosted by a system created process. This value is true for services using the guest
   * executable services, false otherwise.
   */
  useImplicitHost?: boolean;
}

/**
 * Represents health evaluation for the fabric:/System application, containing information about
 * the data and the algorithm used by health store to evaluate health. The evaluation is returned
 * only when the aggregated health state of the cluster is either Error or Warning.
 */
export interface SystemApplicationHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "SystemApplication";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * List of unhealthy evaluations that led to the current aggregated health state of the system
   * application. The types of the unhealthy evaluations can be
   * DeployedApplicationsHealthEvaluation, ServicesHealthEvaluation or EventHealthEvaluation.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Represents health evaluation for delta unhealthy cluster nodes in an upgrade domain, containing
 * health evaluations for each unhealthy node that impacted current aggregated health state.
 * Can be returned during cluster upgrade when cluster aggregated health state is Warning or Error.
 */
export interface UpgradeDomainDeltaNodesCheckHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "UpgradeDomainDeltaNodesCheck";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Name of the upgrade domain where nodes health is currently evaluated.
   */
  upgradeDomainName?: string;
  /**
   * Number of upgrade domain nodes with aggregated heath state Error in the health store at the
   * beginning of the cluster upgrade.
   */
  baselineErrorCount?: number;
  /**
   * Total number of upgrade domain nodes in the health store at the beginning of the cluster
   * upgrade.
   */
  baselineTotalCount?: number;
  /**
   * Maximum allowed percentage of upgrade domain delta unhealthy nodes from the
   * ClusterUpgradeHealthPolicy.
   */
  maxPercentDeltaUnhealthyNodes?: number;
  /**
   * Total number of upgrade domain nodes in the health store.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy NodeHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Represents health evaluation for cluster nodes in an upgrade domain, containing health
 * evaluations for each unhealthy node that impacted current aggregated health state. Can be
 * returned when evaluating cluster health during cluster upgrade and the aggregated health state
 * is either Error or Warning.
 */
export interface UpgradeDomainNodesHealthEvaluation {
  /**
   * Polymorphic Discriminator
   */
  kind: "UpgradeDomainNodes";
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  aggregatedHealthState?: HealthState;
  /**
   * Description of the health evaluation, which represents a summary of the evaluation process.
   */
  description?: string;
  /**
   * Name of the upgrade domain where nodes health is currently evaluated.
   */
  upgradeDomainName?: string;
  /**
   * Maximum allowed percentage of unhealthy nodes from the ClusterHealthPolicy.
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * Total number of nodes in the current upgrade domain.
   */
  totalCount?: number;
  /**
   * List of unhealthy evaluations that led to the aggregated health state. Includes all the
   * unhealthy NodeHealthEvaluation that impacted the aggregated health.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
}

/**
 * Safety check that waits for the replica build operation to finish. This indicates that there is
 * a replica that is going through the copy or is providing data for building another replica.
 * Bring the node down will abort this copy operation which are typically expensive involving data
 * movements.
 */
export interface WaitForInbuildReplicaSafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "WaitForInbuildReplica";
  /**
   * Id of the partition which is undergoing the safety check.
   */
  partitionId?: string;
}

/**
 * Safety check that waits for the primary replica that was moved out of the node due to upgrade to
 * be placed back again on that node.
 */
export interface WaitForPrimaryPlacementSafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "WaitForPrimaryPlacement";
  /**
   * Id of the partition which is undergoing the safety check.
   */
  partitionId?: string;
}

/**
 * Safety check that waits for the primary replica to be moved out of the node before starting an
 * upgrade to ensure the availability of the primary replica for the partition.
 */
export interface WaitForPrimarySwapSafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "WaitForPrimarySwap";
  /**
   * Id of the partition which is undergoing the safety check.
   */
  partitionId?: string;
}

/**
 * Safety check that waits for the current reconfiguration of the partition to be completed before
 * starting an upgrade.
 */
export interface WaitForReconfigurationSafetyCheck {
  /**
   * Polymorphic Discriminator
   */
  kind: "WaitForReconfiguration";
  /**
   * Id of the partition which is undergoing the safety check.
   */
  partitionId?: string;
}

/**
 * Represents the load metric report which contains the time metric was reported, its name and
 * value.
 */
export interface LoadMetricReport {
  /**
   * Gets the UTC time when the load was reported.
   */
  lastReportedUtc?: Date;
  /**
   * The name of the load metric.
   */
  name?: string;
  /**
   * The value of the load metric. In future releases of Service Fabric this parameter will be
   * deprecated in favor of CurrentValue.
   */
  value?: string;
  /**
   * The value of the load metric.
   */
  currentValue?: string;
}

/**
 * Represents load information for a partition, which contains the primary and secondary reported
 * load metrics.
 * In case there is no load reported, PartitionLoadInformation will contain the default load for
 * the service of the partition.
 * For default loads, LoadMetricReport's LastReportedUtc is set to 0.
 */
export interface PartitionLoadInformation {
  /**
   * Id of the partition.
   */
  partitionId?: string;
  /**
   * Array of load reports from the primary replica for this partition.
   */
  primaryLoadMetricReports?: LoadMetricReport[];
  /**
   * Array of aggregated load reports from all secondary replicas for this partition.
   * Array only contains the latest reported load for each metric.
   */
  secondaryLoadMetricReports?: LoadMetricReport[];
}

/**
 * Represents a stateful service replica. This includes information about the identity, role,
 * status, health, node name, uptime, and other details about the replica.
 */
export interface StatefulServiceReplicaInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The status of a replica of a service. Possible values include: 'Invalid', 'InBuild',
   * 'Standby', 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * The address the replica is listening on.
   */
  address?: string;
  /**
   * The last in build duration of the replica in seconds.
   */
  lastInBuildDurationInSeconds?: string;
  /**
   * The role of a replica of a stateful service. Possible values include: 'Unknown', 'None',
   * 'Primary', 'IdleSecondary', 'ActiveSecondary'
   */
  replicaRole?: ReplicaRole;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId?: string;
}

/**
 * Represents a stateless service instance. This includes information about the identity, status,
 * health, node name, uptime, and other details about the instance.
 */
export interface StatelessServiceInstanceInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The status of a replica of a service. Possible values include: 'Invalid', 'InBuild',
   * 'Standby', 'Ready', 'Down', 'Dropped'
   */
  replicaStatus?: ReplicaStatus;
  /**
   * The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
   * Partition, Replica etc. Possible values include: 'Invalid', 'Ok', 'Warning', 'Error',
   * 'Unknown'
   */
  healthState?: HealthState;
  /**
   * The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * The address the replica is listening on.
   */
  address?: string;
  /**
   * The last in build duration of the replica in seconds.
   */
  lastInBuildDurationInSeconds?: string;
  /**
   * Id of a stateless service instance. InstanceId is used by Service Fabric to uniquely identify
   * an instance of a partition of a stateless service. It is unique within a partition and does
   * not change for the lifetime of the instance. If the instance has failed over on the same or
   * different node, it will get a different value for the InstanceId.
   */
  instanceId?: string;
}

/**
 * Represents a ServiceFabric cluster upgrade
 */
export interface ClusterUpgradeDescriptionObject {
  /**
   * The cluster configuration version (specified in the cluster manifest).
   */
  configVersion?: string;
  /**
   * The ServiceFabric code version of the cluster.
   */
  codeVersion?: string;
  /**
   * The kind of upgrade out of the following possible values. Possible values include: 'Invalid',
   * 'Rolling'. Default value: 'Rolling'.
   */
  upgradeKind?: UpgradeKind;
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto'.
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has
   * not changed (the upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * Defines the order in which an upgrade proceeds through the cluster. Possible values include:
   * 'Invalid', 'Default', 'Numeric', 'Lexicographical', 'ReverseNumeric',
   * 'ReverseLexicographical'. Default value: 'Default'.
   */
  sortOrder?: UpgradeSortOrder;
  /**
   * When true, enables delta health evaluation rather than absolute health evaluation after
   * completion of each upgrade domain.
   */
  enableDeltaHealthEvaluation?: boolean;
  /**
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * Defines a health policy used to evaluate the health of the cluster or of a cluster node.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * Defines a health policy used to evaluate the health of the cluster during a cluster upgrade.
   */
  clusterUpgradeHealthPolicy?: ClusterUpgradeHealthPolicyObject;
  /**
   * Defines a map that contains specific application health policies for different applications.
   * Each entry specifies as key the application name and as value an ApplicationHealthPolicy used
   * to evaluate the application health.
   * If an application is not specified in the map, the application health evaluation uses the
   * ApplicationHealthPolicy found in its application manifest or the default application health
   * policy (if no health policy is defined in the manifest).
   * The map is empty by default.
   */
  applicationHealthPolicyMap?: ApplicationHealthPolicyMapItem[];
}

/**
 * The detailed upgrade progress for nodes in the current upgrade domain at the point of failure.
 */
export interface FailedUpgradeDomainProgressObject {
  /**
   * The name of the upgrade domain
   */
  domainName?: string;
  /**
   * List of upgrading nodes and their statuses
   */
  nodeUpgradeProgressList?: NodeUpgradeProgressInfo[];
}

/**
 * Information about a cluster upgrade.
 */
export interface ClusterUpgradeProgressObject {
  /**
   * The ServiceFabric code version of the cluster.
   */
  codeVersion?: string;
  /**
   * The cluster configuration version (specified in the cluster manifest).
   */
  configVersion?: string;
  /**
   * List of upgrade domains and their statuses.
   */
  upgradeDomains?: UpgradeDomainInfo[];
  /**
   * The state of the upgrade domain. Possible values include: 'Invalid', 'RollingBackInProgress',
   * 'RollingBackCompleted', 'RollingForwardPending', 'RollingForwardInProgress',
   * 'RollingForwardCompleted', 'Failed'
   */
  upgradeState?: UpgradeState;
  /**
   * The name of the next upgrade domain to be processed.
   */
  nextUpgradeDomain?: string;
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto'.
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * Represents a ServiceFabric cluster upgrade
   */
  upgradeDescription?: ClusterUpgradeDescriptionObject;
  /**
   * The estimated elapsed time spent processing the current overall upgrade.
   */
  upgradeDurationInMilliseconds?: string;
  /**
   * The estimated elapsed time spent processing the current upgrade domain.
   */
  upgradeDomainDurationInMilliseconds?: string;
  /**
   * List of health evaluations that resulted in the current aggregated health state.
   */
  unhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * Information about the current in-progress upgrade domain.
   */
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  /**
   * The start time of the upgrade in UTC.
   */
  startTimestampUtc?: string;
  /**
   * The failure time of the upgrade in UTC.
   */
  failureTimestampUtc?: string;
  /**
   * The cause of an upgrade failure that resulted in FailureAction being executed. Possible values
   * include: 'None', 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout', 'OverallUpgradeTimeout'
   */
  failureReason?: FailureReason;
  /**
   * The detailed upgrade progress for nodes in the current upgrade domain at the point of failure.
   */
  upgradeDomainProgressAtFailure?: FailedUpgradeDomainProgressObject;
}

/**
 * Describes the parameters for a standalone cluster configuration upgrade.
 */
export interface ClusterConfigurationUpgradeDescription {
  /**
   * The cluster configuration as a JSON string. For example, [this
   * file](https://github.com/Azure-Samples/service-fabric-dotnet-standalone-cluster-configuration/blob/master/Samples/ClusterConfig.Unsecure.DevCluster.json)
   * contains JSON describing the [nodes and other properties of the
   * cluster](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-manifest).
   */
  clusterConfig: string;
  /**
   * The length of time between attempts to perform health checks if the application or cluster is
   * not healthy. Default value: 'PT0H0M0S'.
   */
  healthCheckRetryTimeout?: string;
  /**
   * The length of time to wait after completing an upgrade domain before starting the health
   * checks process. Default value: 'PT0H0M0S'.
   */
  healthCheckWaitDurationInSeconds?: string;
  /**
   * The length of time that the application or cluster must remain healthy before the upgrade
   * proceeds to the next upgrade domain. Default value: 'PT0H0M0S'.
   */
  healthCheckStableDurationInSeconds?: string;
  /**
   * The timeout for the upgrade domain. Default value: 'PT0H0M0S'.
   */
  upgradeDomainTimeoutInSeconds?: string;
  /**
   * The upgrade timeout. Default value: 'PT0H0M0S'.
   */
  upgradeTimeoutInSeconds?: string;
  /**
   * The maximum allowed percentage of unhealthy applications during the upgrade. Allowed values
   * are integer values from zero to 100. Default value: 0.
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * The maximum allowed percentage of unhealthy nodes during the upgrade. Allowed values are
   * integer values from zero to 100. Default value: 0.
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * The maximum allowed percentage of delta health degradation during the upgrade. Allowed values
   * are integer values from zero to 100. Default value: 0.
   */
  maxPercentDeltaUnhealthyNodes?: number;
  /**
   * The maximum allowed percentage of upgrade domain delta health degradation during the upgrade.
   * Allowed values are integer values from zero to 100. Default value: 0.
   */
  maxPercentUpgradeDomainDeltaUnhealthyNodes?: number;
  /**
   * Defines the application health policy map used to evaluate the health of an application or one
   * of its children entities.
   */
  applicationHealthPolicies?: ApplicationHealthPolicies;
}

/**
 * Service state of Service Fabric Upgrade Orchestration Service.
 */
export interface UpgradeOrchestrationServiceState {
  /**
   * The state of Service Fabric Upgrade Orchestration Service.
   */
  serviceState?: string;
}

/**
 * Service state summary of Service Fabric Upgrade Orchestration Service.
 */
export interface UpgradeOrchestrationServiceStateSummary {
  /**
   * The current code version of the cluster.
   */
  currentCodeVersion?: string;
  /**
   * The current manifest version of the cluster.
   */
  currentManifestVersion?: string;
  /**
   * The target code version of  the cluster.
   */
  targetCodeVersion?: string;
  /**
   * The target manifest version of the cluster.
   */
  targetManifestVersion?: string;
  /**
   * The type of the pending upgrade of the cluster.
   */
  pendingUpgradeType?: string;
}

/**
 * Path description for the application package in the image store specified during the prior copy
 * operation.
 */
export interface ApplicationTypeImageStorePath {
  /**
   * The relative image store path to the application package.
   */
  applicationTypeBuildPath: string;
}

/**
 * Describes the operation to unregister or unprovision an application type and its version that
 * was registered with the Service Fabric.
 */
export interface UnprovisionApplicationTypeDescriptionInfo {
  /**
   * The version of the application type as defined in the application manifest.
   */
  applicationTypeVersion: string;
  /**
   * The flag indicating whether or not unprovision should occur asynchronously. When set to true,
   * the unprovision operation returns when the request is accepted by the system, and the
   * unprovision operation continues without any timeout limit. The default value is false.
   * However, we recommend setting it to true for large application packages that were provisioned.
   */
  async?: boolean;
}

/**
 * Statistics about setup or main entry point  of a code package deployed on a Service Fabric node.
 */
export interface CodePackageEntryPointStatistics {
  /**
   * The last exit code of the entry point.
   */
  lastExitCode?: string;
  /**
   * The last time (in UTC) when Service Fabric attempted to run the entry point.
   */
  lastActivationTime?: Date;
  /**
   * The last time (in UTC) when the entry point finished running.
   */
  lastExitTime?: Date;
  /**
   * The last time (in UTC) when the entry point ran successfully.
   */
  lastSuccessfulActivationTime?: Date;
  /**
   * The last time (in UTC) when the entry point finished running gracefully.
   */
  lastSuccessfulExitTime?: Date;
  /**
   * Number of times the entry point has run.
   */
  activationCount?: string;
  /**
   * Number of times the entry point failed to run.
   */
  activationFailureCount?: string;
  /**
   * Number of times the entry point continuously failed to run.
   */
  continuousActivationFailureCount?: string;
  /**
   * Number of times the entry point finished running.
   */
  exitCount?: string;
  /**
   * Number of times the entry point failed to exit gracefully.
   */
  exitFailureCount?: string;
  /**
   * Number of times the entry point continuously failed to exit gracefully.
   */
  continuousExitFailureCount?: string;
}

/**
 * Information about setup or main entry point of a code package deployed on a Service Fabric node.
 */
export interface CodePackageEntryPoint {
  /**
   * The location of entry point executable on the node.
   */
  entryPointLocation?: string;
  /**
   * The process ID of the entry point.
   */
  processId?: string;
  /**
   * The user name under which entry point executable is run on the node.
   */
  runAsUserName?: string;
  /**
   * Statistics about setup or main entry point  of a code package deployed on a Service Fabric
   * node.
   */
  codePackageEntryPointStatistics?: CodePackageEntryPointStatistics;
  /**
   * Specifies the status of the code package entry point deployed on a Service Fabric node.
   * Possible values include: 'Invalid', 'Pending', 'Starting', 'Started', 'Stopping', 'Stopped'
   */
  status?: EntryPointStatus;
  /**
   * The time (in UTC) when the entry point executable will be run next.
   */
  nextActivationTime?: Date;
  /**
   * The instance ID for current running entry point. For a code package setup entry point (if
   * specified) runs first and after it finishes main entry point is started. Each time entry point
   * executable is run, its instance id will change.
   */
  instanceId?: string;
}

/**
 * Information about code package deployed on a Service Fabric node.
 */
export interface DeployedCodePackageInfo {
  /**
   * The name of the code package.
   */
  name?: string;
  /**
   * The version of the code package specified in service manifest.
   */
  version?: string;
  /**
   * The name of service manifest that specified this code package.
   */
  serviceManifestName?: string;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * Specifies the type of host for main entry point of a code package as specified in service
   * manifest. Possible values include: 'Invalid', 'ExeHost', 'ContainerHost'
   */
  hostType?: HostType;
  /**
   * Specifies the isolation mode of main entry point of a code package when it's host type is
   * ContainerHost. This is specified as part of container host policies in application manifest
   * while importing service manifest. Possible values include: 'None', 'Process', 'HyperV'
   */
  hostIsolationMode?: HostIsolationMode;
  /**
   * Specifies the status of a deployed application or service package on a Service Fabric node.
   * Possible values include: 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
   * 'Deactivating', 'RanToCompletion', 'Failed'
   */
  status?: DeploymentStatus;
  /**
   * The interval at which code package is run. This is used for periodic code package.
   */
  runFrequencyInterval?: string;
  /**
   * Information about setup or main entry point of a code package deployed on a Service Fabric
   * node.
   */
  setupEntryPoint?: CodePackageEntryPoint;
  /**
   * Information about setup or main entry point of a code package deployed on a Service Fabric
   * node.
   */
  mainEntryPoint?: CodePackageEntryPoint;
}

/**
 * Describes a map, which is a collection of (string, string) type key-value pairs. The map can be
 * used to record information about
 * the Chaos run. There cannot be more than 100 such pairs and each string (key or value) can be at
 * most 4095 characters long.
 * This map is set by the starter of the Chaos run to optionally store the context about the
 * specific run.
 */
export interface ChaosContext {
  /**
   * Describes a map that contains a collection of ChaosContextMapItem's.
   */
  map?: { [propertyName: string]: string };
}

/**
 * Defines all filters for targeted Chaos faults, for example, faulting only certain node types or
 * faulting only certain applications.
 * If ChaosTargetFilter is not used, Chaos faults all cluster entities. If ChaosTargetFilter is
 * used, Chaos faults only the entities that meet the ChaosTargetFilter
 * specification. NodeTypeInclusionList and ApplicationInclusionList allow a union semantics only.
 * It is not possible to specify an intersection
 * of NodeTypeInclusionList and ApplicationInclusionList. For example, it is not possible to
 * specify "fault this application only when it is on that node type."
 * Once an entity is included in either NodeTypeInclusionList or ApplicationInclusionList, that
 * entity cannot be excluded using ChaosTargetFilter. Even if
 * applicationX does not appear in ApplicationInclusionList, in some Chaos iteration applicationX
 * can be faulted because it happens to be on a node of nodeTypeY that is included
 * in NodeTypeInclusionList. If both NodeTypeInclusionList and ApplicationInclusionList are null or
 * empty, an ArgumentException is thrown.
 */
export interface ChaosTargetFilter {
  /**
   * A list of node types to include in Chaos faults.
   * All types of faults (restart node, restart code package, remove replica, restart replica, move
   * primary, and move secondary) are enabled for the nodes of these node types.
   * If a node type (say NodeTypeX) does not appear in the NodeTypeInclusionList, then node level
   * faults (like NodeRestart) will never be enabled for the nodes of
   * NodeTypeX, but code package and replica faults can still be enabled for NodeTypeX if an
   * application in the ApplicationInclusionList.
   * happens to reside on a node of NodeTypeX.
   * At most 100 node type names can be included in this list, to increase this number, a config
   * upgrade is required for MaxNumberOfNodeTypesInChaosEntityFilter configuration.
   */
  nodeTypeInclusionList?: string[];
  /**
   * A list of application URIs to include in Chaos faults.
   * All replicas belonging to services of these applications are amenable to replica faults
   * (restart replica, remove replica, move primary, and move secondary) by Chaos.
   * Chaos may restart a code package only if the code package hosts replicas of these applications
   * only.
   * If an application does not appear in this list, it can still be faulted in some Chaos
   * iteration if the application ends up on a node of a node type that is included in
   * NodeTypeInclusionList.
   * However, if applicationX is tied to nodeTypeY through placement constraints and applicationX
   * is absent from ApplicationInclusionList and nodeTypeY is absent from NodeTypeInclusionList,
   * then applicationX will never be faulted.
   * At most 1000 application names can be included in this list, to increase this number, a config
   * upgrade is required for MaxNumberOfApplicationsInChaosEntityFilter configuration.
   */
  applicationInclusionList?: string[];
}

/**
 * Defines all the parameters to configure a Chaos run.
 */
export interface ChaosParameters {
  /**
   * Total time (in seconds) for which Chaos will run before automatically stopping. The maximum
   * allowed value is 4,294,967,295 (System.UInt32.MaxValue). Default value: '4294967295'.
   */
  timeToRunInSeconds?: string;
  /**
   * The maximum amount of time to wait for all cluster entities to become stable and healthy.
   * Chaos executes in iterations and at the start of each iteration it validates the health of
   * cluster entities.
   * During validation if a cluster entity is not stable and healthy within
   * MaxClusterStabilizationTimeoutInSeconds, Chaos generates a validation failed event. Default
   * value: 60.
   */
  maxClusterStabilizationTimeoutInSeconds?: number;
  /**
   * MaxConcurrentFaults is the maximum number of concurrent faults induced per iteration.
   * Chaos executes in iterations and two consecutive iterations are separated by a validation
   * phase.
   * The higher the concurrency, the more aggressive the injection of faults, leading to inducing
   * more complex series of states to uncover bugs.
   * The recommendation is to start with a value of 2 or 3 and to exercise caution while moving up.
   * Default value: 1.
   */
  maxConcurrentFaults?: number;
  /**
   * Enables or disables the move primary and move secondary faults. Default value: true.
   */
  enableMoveReplicaFaults?: boolean;
  /**
   * Wait time (in seconds) between consecutive faults within a single iteration.
   * The larger the value, the lower the overlapping between faults and the simpler the sequence of
   * state transitions that the cluster goes through.
   * The recommendation is to start with a value between 1 and 5 and exercise caution while moving
   * up. Default value: 20.
   */
  waitTimeBetweenFaultsInSeconds?: number;
  /**
   * Time-separation (in seconds) between two consecutive iterations of Chaos.
   * The larger the value, the lower the fault injection rate. Default value: 30.
   */
  waitTimeBetweenIterationsInSeconds?: number;
  /**
   * Passed-in cluster health policy is used to validate health of the cluster in between Chaos
   * iterations. If the cluster health is in error or if an unexpected exception happens during
   * fault execution--to provide the cluster with some time to recuperate--Chaos will wait for 30
   * minutes before the next health-check.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * Describes a map, which is a collection of (string, string) type key-value pairs. The map can
   * be used to record information about
   * the Chaos run. There cannot be more than 100 such pairs and each string (key or value) can be
   * at most 4095 characters long.
   * This map is set by the starter of the Chaos run to optionally store the context about the
   * specific run.
   */
  context?: ChaosContext;
  /**
   * List of cluster entities to target for Chaos faults.
   * This filter can be used to target Chaos faults only to certain node types or only to certain
   * application instances. If ChaosTargetFilter is not used, Chaos faults all cluster entities.
   * If ChaosTargetFilter is used, Chaos faults only the entities that meet the ChaosTargetFilter
   * specification.
   */
  chaosTargetFilter?: ChaosTargetFilter;
}

/**
 * Contains a description of Chaos.
 */
export interface Chaos {
  /**
   * If Chaos is running, these are the parameters Chaos is running with.
   */
  chaosParameters?: ChaosParameters;
  /**
   * Current status of the Chaos run. Possible values include: 'Invalid', 'Running', 'Stopped'
   */
  status?: ChaosStatus;
  /**
   * Current status of the schedule. Possible values include: 'Invalid', 'Stopped', 'Active',
   * 'Expired', 'Pending'
   */
  scheduleStatus?: ChaosScheduleStatus;
}

/**
 * Defines an item in ChaosParametersDictionary of the Chaos Schedule.
 */
export interface ChaosParametersDictionaryItem {
  /**
   * The key identifying the Chaos Parameter in the dictionary. This key is referenced by Chaos
   * Schedule Jobs.
   */
  key: string;
  /**
   * Defines all the parameters to configure a Chaos run.
   */
  value: ChaosParameters;
}

/**
 * Contains the possible cases for ChaosEvent.
 */
export type ChaosEventUnion = ChaosEvent | ExecutingFaultsChaosEvent | StartedChaosEvent | StoppedChaosEvent | TestErrorChaosEvent | ValidationFailedChaosEvent | WaitingChaosEvent;

/**
 * Represents an event generated during a Chaos run.
 */
export interface ChaosEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosEvent";
  /**
   * The UTC timestamp when this Chaos event was generated.
   */
  timeStampUtc: Date;
}

/**
 * Wrapper object for Chaos event.
 */
export interface ChaosEventWrapper {
  /**
   * Represents an event generated during a Chaos run.
   */
  chaosEvent?: ChaosEventUnion;
}

/**
 * Contains the list of Chaos events and the continuation token to get the next segment.
 */
export interface ChaosEventsSegment {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of Chaos events that meet the user-supplied criteria.
   */
  history?: ChaosEventWrapper[];
}

/**
 * Defines the days of the week that a Chaos Schedule Job will run for.
 */
export interface ChaosScheduleJobActiveDaysOfWeek {
  /**
   * Indicates if the Chaos Schedule Job will run on Sunday. Default value: false.
   */
  sunday?: boolean;
  /**
   * Indicates if the Chaos Schedule Job will run on Monday. Default value: false.
   */
  monday?: boolean;
  /**
   * Indicates if the Chaos Schedule Job will run on Tuesday. Default value: false.
   */
  tuesday?: boolean;
  /**
   * Indicates if the Chaos Schedule Job will run on Wednesday. Default value: false.
   */
  wednesday?: boolean;
  /**
   * Indicates if the Chaos Schedule Job will run on Thursday. Default value: false.
   */
  thursday?: boolean;
  /**
   * Indicates if the Chaos Schedule Job will run on Friday. Default value: false.
   */
  friday?: boolean;
  /**
   * Indicates if the Chaos Schedule Job will run on Saturday. Default value: false.
   */
  saturday?: boolean;
}

/**
 * Defines an hour and minute of the day specified in 24 hour time.
 */
export interface TimeOfDay {
  /**
   * Represents the hour of the day. Value must be between 0 and 23 inclusive.
   */
  hour?: number;
  /**
   * Represents the minute of the hour. Value must be between 0 to 59 inclusive.
   */
  minute?: number;
}

/**
 * Defines a time range in a 24 hour day specified by a start and end time.
 */
export interface TimeRange {
  /**
   * Defines an hour and minute of the day specified in 24 hour time.
   */
  startTime?: TimeOfDay;
  /**
   * Defines an hour and minute of the day specified in 24 hour time.
   */
  endTime?: TimeOfDay;
}

/**
 * Defines a repetition rule and parameters of Chaos to be used with the Chaos Schedule.
 */
export interface ChaosScheduleJob {
  /**
   * A reference to which Chaos Parameters of the Chaos Schedule to use.
   */
  chaosParameters?: string;
  /**
   * Defines the days of the week that a Chaos Schedule Job will run for.
   */
  days?: ChaosScheduleJobActiveDaysOfWeek;
  /**
   * A list of Time Ranges that specify when during active days that this job will run. The times
   * are interpreted as UTC.
   */
  times?: TimeRange[];
}

/**
 * Defines the schedule used by Chaos.
 */
export interface ChaosSchedule {
  /**
   * The date and time Chaos will start using this schedule. Default value: new
   * Date('1601-01-01T00:00:00Z').
   */
  startDate?: Date;
  /**
   * The date and time Chaos will continue to use this schedule until. Default value: new
   * Date('9999-12-31T23:59:59.999Z').
   */
  expiryDate?: Date;
  /**
   * A mapping of string names to Chaos Parameters to be referenced by Chaos Schedule Jobs.
   */
  chaosParametersDictionary?: ChaosParametersDictionaryItem[];
  /**
   * A list of all Chaos Schedule Jobs that will be automated by the schedule.
   */
  jobs?: ChaosScheduleJob[];
}

/**
 * Defines the Chaos Schedule used by Chaos and the version of the Chaos Schedule. The version
 * value wraps back to 0 after surpassing 2,147,483,647.
 */
export interface ChaosScheduleDescription {
  /**
   * The version number of the Schedule.
   */
  version?: number;
  /**
   * Defines the schedule used by Chaos.
   */
  schedule?: ChaosSchedule;
}

/**
 * Describes a Chaos event that gets generated when Chaos has decided on the faults for an
 * iteration. This Chaos event contains the details of the faults as a list of strings.
 */
export interface ExecutingFaultsChaosEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ExecutingFaults";
  /**
   * The UTC timestamp when this Chaos event was generated.
   */
  timeStampUtc: Date;
  /**
   * List of string description of the faults that Chaos decided to execute in an iteration.
   */
  faults?: string[];
}

/**
 * Describes a Chaos event that gets generated when Chaos is started.
 */
export interface StartedChaosEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "Started";
  /**
   * The UTC timestamp when this Chaos event was generated.
   */
  timeStampUtc: Date;
  /**
   * Defines all the parameters to configure a Chaos run.
   */
  chaosParameters?: ChaosParameters;
}

/**
 * Describes a Chaos event that gets generated when Chaos stops because either the user issued a
 * stop or the time to run was up.
 */
export interface StoppedChaosEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "Stopped";
  /**
   * The UTC timestamp when this Chaos event was generated.
   */
  timeStampUtc: Date;
  /**
   * Describes why Chaos stopped. Chaos can stop because of StopChaos API call or the timeToRun
   * provided in ChaosParameters is over.
   */
  reason?: string;
}

/**
 * Describes a Chaos event that gets generated when an unexpected event occurs in the Chaos engine.
 * For example, due to the cluster snapshot being inconsistent, while faulting an entity, Chaos
 * found that the entity was already faulted -- which would be an unexpected event.
 */
export interface TestErrorChaosEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "TestError";
  /**
   * The UTC timestamp when this Chaos event was generated.
   */
  timeStampUtc: Date;
  /**
   * Describes why TestErrorChaosEvent was generated. For example, Chaos tries to fault a partition
   * but finds that the partition is no longer fault tolerant, then a TestErrorEvent gets generated
   * with the reason stating that the partition is not fault tolerant.
   */
  reason?: string;
}

/**
 * Chaos event corresponding to a failure during validation.
 */
export interface ValidationFailedChaosEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ValidationFailed";
  /**
   * The UTC timestamp when this Chaos event was generated.
   */
  timeStampUtc: Date;
  /**
   * Describes why the ValidationFailedChaosEvent was generated. This may happen because more than
   * MaxPercentUnhealthyNodes are unhealthy for more than MaxClusterStabilizationTimeout. This
   * reason will be in the Reason property of the ValidationFailedChaosEvent as a string.
   */
  reason?: string;
}

/**
 * Describes a Chaos event that gets generated when Chaos is waiting for the cluster to become
 * ready for faulting, for example, Chaos may be waiting for the on-going upgrade to finish.
 */
export interface WaitingChaosEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "Waiting";
  /**
   * The UTC timestamp when this Chaos event was generated.
   */
  timeStampUtc: Date;
  /**
   * Describes why the WaitingChaosEvent was generated, for example, due to a cluster upgrade.
   */
  reason?: string;
}

/**
 * Describes capacity information for a custom resource balancing metric. This can be used to limit
 * the total consumption of this metric by the services of this application.
 */
export interface ApplicationMetricDescription {
  /**
   * The name of the metric.
   */
  name?: string;
  /**
   * The maximum node capacity for Service Fabric application.
   * This is the maximum Load for an instance of this application on a single node. Even if the
   * capacity of node is greater than this value, Service Fabric will limit the total load of
   * services within the application on each node to this value.
   * If set to zero, capacity for this metric is unlimited on each node.
   * When creating a new application with application capacity defined, the product of MaximumNodes
   * and this value must always be smaller than or equal to TotalApplicationCapacity.
   * When updating existing application with application capacity, the product of MaximumNodes and
   * this value must always be smaller than or equal to TotalApplicationCapacity.
   */
  maximumCapacity?: number;
  /**
   * The node reservation capacity for Service Fabric application.
   * This is the amount of load which is reserved on nodes which have instances of this
   * application.
   * If MinimumNodes is specified, then the product of these values will be the capacity reserved
   * in the cluster for the application.
   * If set to zero, no capacity is reserved for this metric.
   * When setting application capacity or when updating application capacity; this value must be
   * smaller than or equal to MaximumCapacity for each metric.
   */
  reservationCapacity?: number;
  /**
   * The total metric capacity for Service Fabric application.
   * This is the total metric capacity for this application in the cluster. Service Fabric will try
   * to limit the sum of loads of services within the application to this value.
   * When creating a new application with application capacity defined, the product of MaximumNodes
   * and MaximumCapacity must always be smaller than or equal to this value.
   */
  totalApplicationCapacity?: number;
}

/**
 * Describes capacity information for services of this application. This description can be used
 * for describing the following.
 * - Reserving the capacity for the services on the nodes
 * - Limiting the total number of nodes that services of this application can run on
 * - Limiting the custom capacity metrics to limit the total consumption of this metric by the
 * services of this application
 */
export interface ApplicationCapacityDescription {
  /**
   * The minimum number of nodes where Service Fabric will reserve capacity for this application.
   * Note that this does not mean that the services of this application will be placed on all of
   * those nodes. If this property is set to zero, no capacity will be reserved. The value of this
   * property cannot be more than the value of the MaximumNodes property.
   */
  minimumNodes?: number;
  /**
   * The maximum number of nodes where Service Fabric will reserve capacity for this application.
   * Note that this does not mean that the services of this application will be placed on all of
   * those nodes. By default, the value of this property is zero and it means that the services can
   * be placed on any node. Default value: 0.
   */
  maximumNodes?: number;
  /**
   * List of application capacity metric description.
   */
  applicationMetrics?: ApplicationMetricDescription[];
}

/**
 * Describes a managed application identity.
 */
export interface ManagedApplicationIdentity {
  /**
   * The name of the identity.
   */
  name: string;
  /**
   * The identity's PrincipalId.
   */
  principalId?: string;
}

/**
 * Managed application identity description.
 */
export interface ManagedApplicationIdentityDescription {
  /**
   * Token service endpoint.
   */
  tokenServiceEndpoint?: string;
  /**
   * A list of managed application identity objects.
   */
  managedIdentities?: ManagedApplicationIdentity[];
}

/**
 * Describes a Service Fabric application.
 */
export interface ApplicationDescription {
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  name: string;
  /**
   * The application type name as defined in the application manifest.
   */
  typeName: string;
  /**
   * The version of the application type as defined in the application manifest.
   */
  typeVersion: string;
  /**
   * List of application parameters with overridden values from their default values specified in
   * the application manifest.
   */
  parameterList?: ApplicationParameter[];
  /**
   * Describes capacity information for services of this application. This description can be used
   * for describing the following.
   * - Reserving the capacity for the services on the nodes
   * - Limiting the total number of nodes that services of this application can run on
   * - Limiting the custom capacity metrics to limit the total consumption of this metric by the
   * services of this application
   */
  applicationCapacity?: ApplicationCapacityDescription;
  /**
   * Managed application identity description.
   */
  managedApplicationIdentity?: ManagedApplicationIdentityDescription;
}

/**
 * Information about a Service Fabric compose deployment.
 */
export interface ComposeDeploymentStatusInfo {
  /**
   * The name of the deployment.
   */
  name?: string;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * The status of the compose deployment. Possible values include: 'Invalid', 'Provisioning',
   * 'Creating', 'Ready', 'Unprovisioning', 'Deleting', 'Failed', 'Upgrading'
   */
  status?: ComposeDeploymentStatus;
  /**
   * The status details of compose deployment including failure message.
   */
  statusDetails?: string;
}

/**
 * Credential information to connect to container registry.
 */
export interface RegistryCredential {
  /**
   * The user name to connect to container registry.
   */
  registryUserName?: string;
  /**
   * The password for supplied username to connect to container registry.
   */
  registryPassword?: string;
  /**
   * Indicates that supplied container registry password is encrypted.
   */
  passwordEncrypted?: boolean;
}

/**
 * Describes the parameters for a compose deployment upgrade.
 */
export interface ComposeDeploymentUpgradeDescription {
  /**
   * The name of the deployment.
   */
  deploymentName: string;
  /**
   * The content of the compose file that describes the deployment to create.
   */
  composeFileContent: string;
  /**
   * Credential information to connect to container registry.
   */
  registryCredential?: RegistryCredential;
  /**
   * The kind of upgrade out of the following possible values. Possible values include: 'Invalid',
   * 'Rolling'. Default value: 'Rolling'.
   */
  upgradeKind: UpgradeKind;
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto'.
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has
   * not changed (the upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * Defines a health policy used to evaluate the health of an application or one of its children
   * entities.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
}

/**
 * Describes the parameters for a compose deployment upgrade.
 */
export interface ComposeDeploymentUpgradeProgressInfo {
  /**
   * The name of the target deployment.
   */
  deploymentName?: string;
  /**
   * The name of the target application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * The state of the compose deployment upgrade. Possible values include: 'Invalid',
   * 'ProvisioningTarget', 'RollingForwardInProgress', 'RollingForwardPending',
   * 'UnprovisioningCurrent', 'RollingForwardCompleted', 'RollingBackInProgress',
   * 'UnprovisioningTarget', 'RollingBackCompleted', 'Failed'
   */
  upgradeState?: ComposeDeploymentUpgradeState;
  /**
   * Additional detailed information about the status of the pending upgrade.
   */
  upgradeStatusDetails?: string;
  /**
   * The kind of upgrade out of the following possible values. Possible values include: 'Invalid',
   * 'Rolling'. Default value: 'Rolling'.
   */
  upgradeKind?: UpgradeKind;
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'UnmonitoredAuto'.
   */
  rollingUpgradeMode?: UpgradeMode;
  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has
   * not changed (the upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * Describes the parameters for monitoring an upgrade in Monitored mode.
   */
  monitoringPolicy?: MonitoringPolicyDescription;
  /**
   * Defines a health policy used to evaluate the health of an application or one of its children
   * entities.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * The target application type version (found in the application manifest) for the application
   * upgrade.
   */
  targetApplicationTypeVersion?: string;
  /**
   * The estimated amount of time that the overall upgrade elapsed. It is first interpreted as a
   * string representing an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds.
   */
  upgradeDuration?: string;
  /**
   * The estimated amount of time spent processing current Upgrade Domain. It is first interpreted
   * as a string representing an ISO 8601 duration. If that fails, then it is interpreted as a
   * number representing the total number of milliseconds.
   */
  currentUpgradeDomainDuration?: string;
  /**
   * List of health evaluations that resulted in the current aggregated health state.
   */
  applicationUnhealthyEvaluations?: HealthEvaluationWrapper[];
  /**
   * Information about the current in-progress upgrade domain.
   */
  currentUpgradeDomainProgress?: CurrentUpgradeDomainProgressInfo;
  /**
   * The estimated UTC datetime when the upgrade started.
   */
  startTimestampUtc?: string;
  /**
   * The estimated UTC datetime when the upgrade failed and FailureAction was executed.
   */
  failureTimestampUtc?: string;
  /**
   * The cause of an upgrade failure that resulted in FailureAction being executed. Possible values
   * include: 'None', 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout', 'OverallUpgradeTimeout'
   */
  failureReason?: FailureReason;
  /**
   * Information about the upgrade domain progress at the time of upgrade failure.
   */
  upgradeDomainProgressAtFailure?: FailureUpgradeDomainProgressInfo;
  /**
   * Additional details of application upgrade including failure message.
   */
  applicationUpgradeStatusDetails?: string;
}

/**
 * The list of compose deployments in the cluster. The list is paged when all of the results cannot
 * fit in a single message. The next set of results can be obtained by executing the same query
 * with the continuation token provided in this list.
 */
export interface PagedComposeDeploymentStatusInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of compose deployment status information.
   */
  items?: ComposeDeploymentStatusInfo[];
}

/**
 * Defines description for creating a Service Fabric compose deployment.
 */
export interface CreateComposeDeploymentDescription {
  /**
   * The name of the deployment.
   */
  deploymentName: string;
  /**
   * The content of the compose file that describes the deployment to create.
   */
  composeFileContent: string;
  /**
   * Credential information to connect to container registry.
   */
  registryCredential?: RegistryCredential;
}

/**
 * Information about service package deployed on a Service Fabric node.
 */
export interface DeployedServicePackageInfo {
  /**
   * The name of the service package as specified in the service manifest.
   */
  name?: string;
  /**
   * The version of the service package specified in service manifest.
   */
  version?: string;
  /**
   * Specifies the status of a deployed application or service package on a Service Fabric node.
   * Possible values include: 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
   * 'Deactivating', 'RanToCompletion', 'Failed'
   */
  status?: DeploymentStatus;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
}

/**
 * Creates a particular correlation between services.
 */
export interface ServiceCorrelationDescription {
  /**
   * The ServiceCorrelationScheme which describes the relationship between this service and the
   * service specified via ServiceName. Possible values include: 'Invalid', 'Affinity',
   * 'AlignedAffinity', 'NonAlignedAffinity'
   */
  scheme: ServiceCorrelationScheme;
  /**
   * The name of the service that the correlation relationship is established with.
   */
  serviceName: string;
}

/**
 * Contains the possible cases for PartitionSchemeDescription.
 */
export type PartitionSchemeDescriptionUnion = PartitionSchemeDescription | NamedPartitionSchemeDescription | SingletonPartitionSchemeDescription | UniformInt64RangePartitionSchemeDescription;

/**
 * Describes how the service is partitioned.
 */
export interface PartitionSchemeDescription {
  /**
   * Polymorphic Discriminator
   */
  partitionScheme: "PartitionSchemeDescription";
}

/**
 * Describes the named partition scheme of the service.
 */
export interface NamedPartitionSchemeDescription {
  /**
   * Polymorphic Discriminator
   */
  partitionScheme: "Named";
  /**
   * The number of partitions.
   */
  count: number;
  /**
   * Array of size specified by the Count parameter, for the names of the partitions.
   */
  names: string[];
}

/**
 * Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
 */
export interface SingletonPartitionSchemeDescription {
  /**
   * Polymorphic Discriminator
   */
  partitionScheme: "Singleton";
}

/**
 * Describes a partitioning scheme where an integer range is allocated evenly across a number of
 * partitions.
 */
export interface UniformInt64RangePartitionSchemeDescription {
  /**
   * Polymorphic Discriminator
   */
  partitionScheme: "UniformInt64Range";
  /**
   * The number of partitions.
   */
  count: number;
  /**
   * String indicating the lower bound of the partition key range that
   * should be split between the partitions.
   */
  lowKey: string;
  /**
   * String indicating the upper bound of the partition key range that
   * should be split between the partitions.
   */
  highKey: string;
}

/**
 * Contains the possible cases for ScalingTriggerDescription.
 */
export type ScalingTriggerDescriptionUnion = ScalingTriggerDescription | AveragePartitionLoadScalingTrigger | AverageServiceLoadScalingTrigger;

/**
 * Describes the trigger for performing a scaling operation.
 */
export interface ScalingTriggerDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "ScalingTriggerDescription";
}

/**
 * Contains the possible cases for ScalingMechanismDescription.
 */
export type ScalingMechanismDescriptionUnion = ScalingMechanismDescription | PartitionInstanceCountScaleMechanism | AddRemoveIncrementalNamedPartitionScalingMechanism;

/**
 * Describes the mechanism for performing a scaling operation.
 */
export interface ScalingMechanismDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "ScalingMechanismDescription";
}

/**
 * Describes how the scaling should be performed
 */
export interface ScalingPolicyDescription {
  /**
   * Specifies the trigger associated with this scaling policy
   */
  scalingTrigger: ScalingTriggerDescriptionUnion;
  /**
   * Specifies the mechanism associated with this scaling policy
   */
  scalingMechanism: ScalingMechanismDescriptionUnion;
}

/**
 * Contains the possible cases for ServiceDescription.
 */
export type ServiceDescriptionUnion = ServiceDescription | StatefulServiceDescription | StatelessServiceDescription;

/**
 * A ServiceDescription contains all of the information necessary to create a service.
 */
export interface ServiceDescription {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ServiceDescription";
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName: string;
  /**
   * The initialization data as an array of bytes. Initialization data is passed to service
   * instances or replicas when they are created.
   */
  initializationData?: number[];
  /**
   * The partition description as an object.
   */
  partitionDescription: PartitionSchemeDescriptionUnion;
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * The correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * The move cost for the service. Possible values include: 'Zero', 'Low', 'Medium', 'High',
   * 'VeryHigh'
   */
  defaultMoveCost?: MoveCost;
  /**
   * Indicates if the DefaultMoveCost property is specified.
   */
  isDefaultMoveCostSpecified?: boolean;
  /**
   * The activation mode of service package to be used for a service. Possible values include:
   * 'SharedProcess', 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ServicePackageActivationMode;
  /**
   * The DNS name of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   */
  serviceDnsName?: string;
  /**
   * Scaling policies for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
}

/**
 * Describes a stateful service.
 */
export interface StatefulServiceDescription {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName: string;
  /**
   * The initialization data as an array of bytes. Initialization data is passed to service
   * instances or replicas when they are created.
   */
  initializationData?: number[];
  /**
   * The partition description as an object.
   */
  partitionDescription: PartitionSchemeDescriptionUnion;
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * The correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * The move cost for the service. Possible values include: 'Zero', 'Low', 'Medium', 'High',
   * 'VeryHigh'
   */
  defaultMoveCost?: MoveCost;
  /**
   * Indicates if the DefaultMoveCost property is specified.
   */
  isDefaultMoveCostSpecified?: boolean;
  /**
   * The activation mode of service package to be used for a service. Possible values include:
   * 'SharedProcess', 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ServicePackageActivationMode;
  /**
   * The DNS name of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   */
  serviceDnsName?: string;
  /**
   * Scaling policies for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
  /**
   * The target replica set size as a number.
   */
  targetReplicaSetSize: number;
  /**
   * The minimum replica set size as a number.
   */
  minReplicaSetSize: number;
  /**
   * A flag indicating whether this is a persistent service which stores states on the local disk.
   * If it is then the value of this property is true, if not it is false.
   */
  hasPersistedState: boolean;
  /**
   * Flags indicating whether other properties are set. Each of the associated properties
   * corresponds to a flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then the flags for QuorumLossWaitDuration (2) and
   * StandByReplicaKeepDuration(4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
   * value is 1.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
   * 2.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
   * value is 4.
   * - ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
   * value is 8.
   */
  flags?: number;
  /**
   * The duration, in seconds, between when a replica goes down and when a new replica is created.
   */
  replicaRestartWaitDurationSeconds?: number;
  /**
   * The maximum duration, in seconds, for which a partition is allowed to be in a state of quorum
   * loss.
   */
  quorumLossWaitDurationSeconds?: number;
  /**
   * The definition on how long StandBy replicas should be maintained before being removed.
   */
  standByReplicaKeepDurationSeconds?: number;
  /**
   * The duration for which replicas can stay InBuild before reporting that build is stuck.
   */
  servicePlacementTimeLimitSeconds?: number;
}

/**
 * Describes a stateless service.
 */
export interface StatelessServiceDescription {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName: string;
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName: string;
  /**
   * The initialization data as an array of bytes. Initialization data is passed to service
   * instances or replicas when they are created.
   */
  initializationData?: number[];
  /**
   * The partition description as an object.
   */
  partitionDescription: PartitionSchemeDescriptionUnion;
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * The correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * The move cost for the service. Possible values include: 'Zero', 'Low', 'Medium', 'High',
   * 'VeryHigh'
   */
  defaultMoveCost?: MoveCost;
  /**
   * Indicates if the DefaultMoveCost property is specified.
   */
  isDefaultMoveCostSpecified?: boolean;
  /**
   * The activation mode of service package to be used for a service. Possible values include:
   * 'SharedProcess', 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ServicePackageActivationMode;
  /**
   * The DNS name of the service. It requires the DNS system service to be enabled in Service
   * Fabric cluster.
   */
  serviceDnsName?: string;
  /**
   * Scaling policies for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
  /**
   * The instance count.
   */
  instanceCount: number;
  /**
   * MinInstanceCount is the minimum number of instances that must be up to meet the
   * EnsureAvailability safety check during operations like upgrade or deactivate node.
   * The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
   * InstanceCount) ).
   * Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
   * into the number of nodes on which the instances are allowed to be placed according to the
   * placement constraints on the service.
   */
  minInstanceCount?: number;
  /**
   * MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the
   * EnsureAvailability safety check during operations like upgrade or deactivate node.
   * The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
   * InstanceCount) ).
   * Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
   * converted into the number of nodes on which the instances are allowed to be placed according
   * to the placement constraints on the service.
   */
  minInstancePercentage?: number;
  /**
   * Flags indicating whether other properties are set. Each of the associated properties
   * corresponds to a flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise 'OR' operator.
   * For example, if the provided value is 1 then the flags for InstanceCloseDelayDuration is set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
   * value is 1.
   */
  flags?: number;
  /**
   * Duration in seconds, to wait before a stateless instance is closed, to allow the active
   * requests to drain gracefully. This would be effective when the instance is closing during the
   * application/cluster upgrade and disabling node.
   * The endpoint exposed on this instance is removed prior to starting the delay, which prevents
   * new connections to this instance.
   * In addition, clients that have subscribed to service endpoint change
   * events(https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.servicemanagementclient.registerservicenotificationfilterasync),
   * can do
   * the following upon receiving the endpoint removal notification:
   * - Stop sending new requests to this instance.
   * - Close existing connections after in-flight requests have completed.
   * - Connect to a different instance of the service partition for future requests.
   * Note, the default value of InstanceCloseDelayDuration is 0, which indicates that there won't
   * be any delay or removal of the endpoint prior to closing the instance.
   */
  instanceCloseDelayDurationSeconds?: number;
}

/**
 * Provides various statistics of the queue used in the service fabric replicator.
 * Contains information about the service fabric replicator like the replication/copy queue
 * utilization, last acknowledgement received timestamp, etc.
 * Depending on the role of the replicator, the properties in this type imply different meanings.
 */
export interface ReplicatorQueueStatus {
  /**
   * Represents the utilization of the queue. A value of 0 indicates that the queue is empty and a
   * value of 100 indicates the queue is full.
   */
  queueUtilizationPercentage?: number;
  /**
   * Represents the virtual memory consumed by the queue in bytes.
   */
  queueMemorySize?: string;
  /**
   * On a primary replicator, this is semantically the sequence number of the operation for which
   * all the secondary replicas have sent an acknowledgement.
   * On a secondary replicator, this is the smallest sequence number of the operation that is
   * present in the queue.
   */
  firstSequenceNumber?: string;
  /**
   * On a primary replicator, this is semantically the highest sequence number of the operation for
   * which all the secondary replicas have sent an acknowledgement.
   * On a secondary replicator, this is semantically the highest sequence number that has been
   * applied to the persistent state.
   */
  completedSequenceNumber?: string;
  /**
   * On a primary replicator, this is semantically the highest sequence number of the operation for
   * which a write quorum of the secondary replicas have sent an acknowledgement.
   * On a secondary replicator, this is semantically the highest sequence number of the in-order
   * operation received from the primary.
   */
  committedSequenceNumber?: string;
  /**
   * Represents the latest sequence number of the operation that is available in the queue.
   */
  lastSequenceNumber?: string;
}

/**
 * Contains the possible cases for ReplicatorStatus.
 */
export type ReplicatorStatusUnion = ReplicatorStatus | PrimaryReplicatorStatus | SecondaryReplicatorStatusUnion;

/**
 * Represents a base class for primary or secondary replicator status.
 * Contains information about the service fabric replicator like the replication/copy queue
 * utilization, last acknowledgement received timestamp, etc.
 */
export interface ReplicatorStatus {
  /**
   * Polymorphic Discriminator
   */
  kind: "ReplicatorStatus";
}

/**
 * Provides various statistics of the acknowledgements that are being received from the remote
 * replicator.
 */
export interface RemoteReplicatorAcknowledgementDetail {
  /**
   * Represents the average duration it takes for the remote replicator to receive an operation.
   */
  averageReceiveDuration?: string;
  /**
   * Represents the average duration it takes for the remote replicator to apply an operation. This
   * usually entails writing the operation to disk.
   */
  averageApplyDuration?: string;
  /**
   * Represents the number of operations not yet received by a remote replicator.
   */
  notReceivedCount?: string;
  /**
   * Represents the number of operations received and not yet applied by a remote replicator.
   */
  receivedAndNotAppliedCount?: string;
}

/**
 * Provides details about the remote replicators from the primary replicator's point of view.
 */
export interface RemoteReplicatorAcknowledgementStatus {
  /**
   * Details about the acknowledgements for operations that are part of the replication stream
   * data.
   */
  replicationStreamAcknowledgementDetail?: RemoteReplicatorAcknowledgementDetail;
  /**
   * Details about the acknowledgements for operations that are part of the copy stream data.
   */
  copyStreamAcknowledgementDetail?: RemoteReplicatorAcknowledgementDetail;
}

/**
 * Represents the state of the secondary replicator from the primary replicators point of view.
 */
export interface RemoteReplicatorStatus {
  /**
   * Represents the replica ID of the remote secondary replicator.
   */
  replicaId?: string;
  /**
   * The last timestamp (in UTC) when an acknowledgement from the secondary replicator was
   * processed on the primary.
   * UTC 0 represents an invalid value, indicating that no acknowledgement messages were ever
   * processed.
   */
  lastAcknowledgementProcessedTimeUtc?: Date;
  /**
   * The highest replication operation sequence number that the secondary has received from the
   * primary.
   */
  lastReceivedReplicationSequenceNumber?: string;
  /**
   * The highest replication operation sequence number that the secondary has applied to its state.
   */
  lastAppliedReplicationSequenceNumber?: string;
  /**
   * A value that indicates whether the secondary replica is in the process of being built.
   */
  isInBuild?: boolean;
  /**
   * The highest copy operation sequence number that the secondary has received from the primary.
   * A value of -1 implies that the secondary has received all copy operations.
   */
  lastReceivedCopySequenceNumber?: string;
  /**
   * The highest copy operation sequence number that the secondary has applied to its state.
   * A value of -1 implies that the secondary has applied all copy operations and the copy process
   * is complete.
   */
  lastAppliedCopySequenceNumber?: string;
  /**
   * Represents the acknowledgment status for the remote secondary replicator.
   */
  remoteReplicatorAcknowledgementStatus?: RemoteReplicatorAcknowledgementStatus;
}

/**
 * Provides statistics about the Service Fabric Replicator, when it is functioning in a Primary
 * role.
 */
export interface PrimaryReplicatorStatus {
  /**
   * Polymorphic Discriminator
   */
  kind: "Primary";
  /**
   * Details about the replication queue on the primary replicator.
   */
  replicationQueueStatus?: ReplicatorQueueStatus;
  /**
   * The status of all the active and idle secondary replicators that the primary is aware of.
   */
  remoteReplicators?: RemoteReplicatorStatus[];
}

/**
 * Contains the possible cases for SecondaryReplicatorStatus.
 */
export type SecondaryReplicatorStatusUnion = SecondaryReplicatorStatus | SecondaryActiveReplicatorStatus | SecondaryIdleReplicatorStatus;

/**
 * Provides statistics about the Service Fabric Replicator, when it is functioning in a
 * ActiveSecondary role.
 */
export interface SecondaryReplicatorStatus {
  /**
   * Polymorphic Discriminator
   */
  kind: "SecondaryReplicatorStatus";
  /**
   * Details about the replication queue on the secondary replicator.
   */
  replicationQueueStatus?: ReplicatorQueueStatus;
  /**
   * The last time-stamp (UTC) at which a replication operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a replication operation message was never
   * received.
   */
  lastReplicationOperationReceivedTimeUtc?: Date;
  /**
   * Value that indicates whether the replica is currently being built.
   */
  isInBuild?: boolean;
  /**
   * Details about the copy queue on the secondary replicator.
   */
  copyQueueStatus?: ReplicatorQueueStatus;
  /**
   * The last time-stamp (UTC) at which a copy operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a copy operation message was never
   * received.
   */
  lastCopyOperationReceivedTimeUtc?: Date;
  /**
   * The last time-stamp (UTC) at which an acknowledgment was sent to the primary replicator.
   * UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
   */
  lastAcknowledgementSentTimeUtc?: Date;
}

/**
 * Status of the secondary replicator when it is in active mode and is part of the replica set.
 */
export interface SecondaryActiveReplicatorStatus {
  /**
   * Polymorphic Discriminator
   */
  kind: "ActiveSecondary";
  /**
   * Details about the replication queue on the secondary replicator.
   */
  replicationQueueStatus?: ReplicatorQueueStatus;
  /**
   * The last time-stamp (UTC) at which a replication operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a replication operation message was never
   * received.
   */
  lastReplicationOperationReceivedTimeUtc?: Date;
  /**
   * Value that indicates whether the replica is currently being built.
   */
  isInBuild?: boolean;
  /**
   * Details about the copy queue on the secondary replicator.
   */
  copyQueueStatus?: ReplicatorQueueStatus;
  /**
   * The last time-stamp (UTC) at which a copy operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a copy operation message was never
   * received.
   */
  lastCopyOperationReceivedTimeUtc?: Date;
  /**
   * The last time-stamp (UTC) at which an acknowledgment was sent to the primary replicator.
   * UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
   */
  lastAcknowledgementSentTimeUtc?: Date;
}

/**
 * Status of the secondary replicator when it is in idle mode and is being built by the primary.
 */
export interface SecondaryIdleReplicatorStatus {
  /**
   * Polymorphic Discriminator
   */
  kind: "IdleSecondary";
  /**
   * Details about the replication queue on the secondary replicator.
   */
  replicationQueueStatus?: ReplicatorQueueStatus;
  /**
   * The last time-stamp (UTC) at which a replication operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a replication operation message was never
   * received.
   */
  lastReplicationOperationReceivedTimeUtc?: Date;
  /**
   * Value that indicates whether the replica is currently being built.
   */
  isInBuild?: boolean;
  /**
   * Details about the copy queue on the secondary replicator.
   */
  copyQueueStatus?: ReplicatorQueueStatus;
  /**
   * The last time-stamp (UTC) at which a copy operation was received from the primary.
   * UTC 0 represents an invalid value, indicating that a copy operation message was never
   * received.
   */
  lastCopyOperationReceivedTimeUtc?: Date;
  /**
   * The last time-stamp (UTC) at which an acknowledgment was sent to the primary replicator.
   * UTC 0 represents an invalid value, indicating that an acknowledgment message was never sent.
   */
  lastAcknowledgementSentTimeUtc?: Date;
}

/**
 * Information about load reported by replica.
 */
export interface LoadMetricReportInfo {
  /**
   * The name of the metric.
   */
  name?: string;
  /**
   * The value of the load for the metric. In future releases of Service Fabric this parameter will
   * be deprecated in favor of CurrentValue.
   */
  value?: number;
  /**
   * The double value of the load for the metric.
   */
  currentValue?: string;
  /**
   * The UTC time when the load is reported.
   */
  lastReportedUtc?: Date;
}

/**
 * Contains the possible cases for DeployedServiceReplicaDetailInfo.
 */
export type DeployedServiceReplicaDetailInfoUnion = DeployedServiceReplicaDetailInfo | DeployedStatefulServiceReplicaDetailInfo | DeployedStatelessServiceInstanceDetailInfo;

/**
 * Information about a Service Fabric service replica deployed on a node.
 */
export interface DeployedServiceReplicaDetailInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "DeployedServiceReplicaDetailInfo";
  /**
   * Full hierarchical name of the service in URI format starting with `fabric:`.
   */
  serviceName?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId?: string;
  /**
   * Specifies the current active life-cycle operation on a stateful service replica or stateless
   * service instance. Possible values include: 'Unknown', 'None', 'Open', 'ChangeRole', 'Close',
   * 'Abort'
   */
  currentServiceOperation?: ServiceOperationName;
  /**
   * The start time of the current service operation in UTC format.
   */
  currentServiceOperationStartTimeUtc?: Date;
  /**
   * List of load reported by replica.
   */
  reportedLoad?: LoadMetricReportInfo[];
}

/**
 * Contains the possible cases for ReplicaStatusBase.
 */
export type ReplicaStatusBaseUnion = ReplicaStatusBase | KeyValueStoreReplicaStatus;

/**
 * Information about the replica.
 */
export interface ReplicaStatusBase {
  /**
   * Polymorphic Discriminator
   */
  kind: "ReplicaStatusBase";
}

/**
 * Key value store related information for the replica.
 */
export interface KeyValueStoreReplicaStatus {
  /**
   * Polymorphic Discriminator
   */
  kind: "KeyValueStore";
  /**
   * Value indicating the estimated number of rows in the underlying database.
   */
  databaseRowCountEstimate?: string;
  /**
   * Value indicating the estimated size of the underlying database.
   */
  databaseLogicalSizeEstimate?: string;
  /**
   * Value indicating the latest key-prefix filter applied to enumeration during the callback. Null
   * if there is no pending callback.
   */
  copyNotificationCurrentKeyFilter?: string;
  /**
   * Value indicating the latest number of keys enumerated during the callback. 0 if there is no
   * pending callback.
   */
  copyNotificationCurrentProgress?: string;
  /**
   * Value indicating the current status details of the replica.
   */
  statusDetails?: string;
}

/**
 * Information about a stateful replica running in a code package. Note
 * DeployedServiceReplicaQueryResult will contain duplicate data like ServiceKind, ServiceName,
 * PartitionId and replicaId.
 */
export interface DeployedStatefulServiceReplicaDetailInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * Full hierarchical name of the service in URI format starting with `fabric:`.
   */
  serviceName?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId?: string;
  /**
   * Specifies the current active life-cycle operation on a stateful service replica or stateless
   * service instance. Possible values include: 'Unknown', 'None', 'Open', 'ChangeRole', 'Close',
   * 'Abort'
   */
  currentServiceOperation?: ServiceOperationName;
  /**
   * The start time of the current service operation in UTC format.
   */
  currentServiceOperationStartTimeUtc?: Date;
  /**
   * List of load reported by replica.
   */
  reportedLoad?: LoadMetricReportInfo[];
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId?: string;
  /**
   * Specifies the operation currently being executed by the Replicator. Possible values include:
   * 'Invalid', 'None', 'Open', 'ChangeRole', 'UpdateEpoch', 'Close', 'Abort', 'OnDataLoss',
   * 'WaitForCatchup', 'Build'
   */
  currentReplicatorOperation?: ReplicatorOperationName;
  /**
   * Specifies the access status of the partition. Possible values include: 'Invalid', 'Granted',
   * 'ReconfigurationPending', 'NotPrimary', 'NoWriteQuorum'
   */
  readStatus?: PartitionAccessStatus;
  /**
   * Specifies the access status of the partition. Possible values include: 'Invalid', 'Granted',
   * 'ReconfigurationPending', 'NotPrimary', 'NoWriteQuorum'
   */
  writeStatus?: PartitionAccessStatus;
  /**
   * Represents a base class for primary or secondary replicator status.
   * Contains information about the service fabric replicator like the replication/copy queue
   * utilization, last acknowledgement received timestamp, etc.
   */
  replicatorStatus?: ReplicatorStatusUnion;
  /**
   * Key value store related information for the replica.
   */
  replicaStatus?: KeyValueStoreReplicaStatus;
  /**
   * Information about a stateful service replica deployed on a node.
   */
  deployedServiceReplicaQueryResult?: DeployedStatefulServiceReplicaInfo;
}

/**
 * Information about a stateless instance running in a code package. Note that
 * DeployedServiceReplicaQueryResult will contain duplicate data like ServiceKind, ServiceName,
 * PartitionId and InstanceId.
 */
export interface DeployedStatelessServiceInstanceDetailInfo {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * Full hierarchical name of the service in URI format starting with `fabric:`.
   */
  serviceName?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId?: string;
  /**
   * Specifies the current active life-cycle operation on a stateful service replica or stateless
   * service instance. Possible values include: 'Unknown', 'None', 'Open', 'ChangeRole', 'Close',
   * 'Abort'
   */
  currentServiceOperation?: ServiceOperationName;
  /**
   * The start time of the current service operation in UTC format.
   */
  currentServiceOperationStartTimeUtc?: Date;
  /**
   * List of load reported by replica.
   */
  reportedLoad?: LoadMetricReportInfo[];
  /**
   * Id of a stateless service instance. InstanceId is used by Service Fabric to uniquely identify
   * an instance of a partition of a stateless service. It is unique within a partition and does
   * not change for the lifetime of the instance. If the instance has failed over on the same or
   * different node, it will get a different value for the InstanceId.
   */
  instanceId?: string;
  /**
   * Information about a stateless service instance deployed on a node.
   */
  deployedServiceReplicaQueryResult?: DeployedStatelessServiceInstanceInfo;
}

/**
 * Contains the possible cases for ServiceUpdateDescription.
 */
export type ServiceUpdateDescriptionUnion = ServiceUpdateDescription | StatefulServiceUpdateDescription | StatelessServiceUpdateDescription;

/**
 * A ServiceUpdateDescription contains all of the information necessary to update a service.
 */
export interface ServiceUpdateDescription {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ServiceUpdateDescription";
  /**
   * Flags indicating whether other properties are set. Each of the associated properties
   * corresponds to a flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
   * QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
   * (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
   * value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
   * value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
   * 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
   * value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
   * 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
   * - ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
   * value is 2048.
   * - MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
   * - MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
   * 8192.
   * - InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
   * value is 16384.
   */
  flags?: string;
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * The correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * The move cost for the service. Possible values include: 'Zero', 'Low', 'Medium', 'High',
   * 'VeryHigh'
   */
  defaultMoveCost?: MoveCost;
  /**
   * Scaling policies for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
}

/**
 * Describes an update for a stateful service.
 */
export interface StatefulServiceUpdateDescription {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * Flags indicating whether other properties are set. Each of the associated properties
   * corresponds to a flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
   * QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
   * (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
   * value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
   * value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
   * 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
   * value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
   * 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
   * - ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
   * value is 2048.
   * - MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
   * - MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
   * 8192.
   * - InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
   * value is 16384.
   */
  flags?: string;
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * The correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * The move cost for the service. Possible values include: 'Zero', 'Low', 'Medium', 'High',
   * 'VeryHigh'
   */
  defaultMoveCost?: MoveCost;
  /**
   * Scaling policies for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
  /**
   * The target replica set size as a number.
   */
  targetReplicaSetSize?: number;
  /**
   * The minimum replica set size as a number.
   */
  minReplicaSetSize?: number;
  /**
   * The duration, in seconds, between when a replica goes down and when a new replica is created.
   */
  replicaRestartWaitDurationSeconds?: string;
  /**
   * The maximum duration, in seconds, for which a partition is allowed to be in a state of quorum
   * loss.
   */
  quorumLossWaitDurationSeconds?: string;
  /**
   * The definition on how long StandBy replicas should be maintained before being removed.
   */
  standByReplicaKeepDurationSeconds?: string;
  /**
   * The duration for which replicas can stay InBuild before reporting that build is stuck.
   */
  servicePlacementTimeLimitSeconds?: string;
}

/**
 * Describes an update for a stateless service.
 */
export interface StatelessServiceUpdateDescription {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * Flags indicating whether other properties are set. Each of the associated properties
   * corresponds to a flag, specified below, which, if set, indicate that the property is
   * specified.
   * This property can be a combination of those flags obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then the flags for ReplicaRestartWaitDuration (2) and
   * QuorumLossWaitDuration (4) are set.
   *
   * - None - Does not indicate any other properties are set. The value is zero.
   * - TargetReplicaSetSize/InstanceCount - Indicates whether the TargetReplicaSetSize property
   * (for Stateful services) or the InstanceCount property (for Stateless services) is set. The
   * value is 1.
   * - ReplicaRestartWaitDuration - Indicates the ReplicaRestartWaitDuration property is set. The
   * value is  2.
   * - QuorumLossWaitDuration - Indicates the QuorumLossWaitDuration property is set. The value is
   * 4.
   * - StandByReplicaKeepDuration - Indicates the StandByReplicaKeepDuration property is set. The
   * value is 8.
   * - MinReplicaSetSize - Indicates the MinReplicaSetSize property is set. The value is 16.
   * - PlacementConstraints - Indicates the PlacementConstraints property is set. The value is 32.
   * - PlacementPolicyList - Indicates the ServicePlacementPolicies property is set. The value is
   * 64.
   * - Correlation - Indicates the CorrelationScheme property is set. The value is 128.
   * - Metrics - Indicates the ServiceLoadMetrics property is set. The value is 256.
   * - DefaultMoveCost - Indicates the DefaultMoveCost property is set. The value is 512.
   * - ScalingPolicy - Indicates the ScalingPolicies property is set. The value is 1024.
   * - ServicePlacementTimeLimit - Indicates the ServicePlacementTimeLimit property is set. The
   * value is 2048.
   * - MinInstanceCount - Indicates the MinInstanceCount property is set. The value is 4096.
   * - MinInstancePercentage - Indicates the MinInstancePercentage property is set. The value is
   * 8192.
   * - InstanceCloseDelayDuration - Indicates the InstanceCloseDelayDuration property is set. The
   * value is 16384.
   */
  flags?: string;
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * The correlation scheme.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics.
   */
  loadMetrics?: ServiceLoadMetricDescription[];
  /**
   * The service placement policies.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescriptionUnion[];
  /**
   * The move cost for the service. Possible values include: 'Zero', 'Low', 'Medium', 'High',
   * 'VeryHigh'
   */
  defaultMoveCost?: MoveCost;
  /**
   * Scaling policies for this service.
   */
  scalingPolicies?: ScalingPolicyDescription[];
  /**
   * The instance count.
   */
  instanceCount?: number;
  /**
   * MinInstanceCount is the minimum number of instances that must be up to meet the
   * EnsureAvailability safety check during operations like upgrade or deactivate node.
   * The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
   * InstanceCount) ).
   * Note, if InstanceCount is set to -1, during MinInstanceCount computation -1 is first converted
   * into the number of nodes on which the instances are allowed to be placed according to the
   * placement constraints on the service.
   */
  minInstanceCount?: number;
  /**
   * MinInstancePercentage is the minimum percentage of InstanceCount that must be up to meet the
   * EnsureAvailability safety check during operations like upgrade or deactivate node.
   * The actual number that is used is max( MinInstanceCount, ceil( MinInstancePercentage/100.0 *
   * InstanceCount) ).
   * Note, if InstanceCount is set to -1, during MinInstancePercentage computation, -1 is first
   * converted into the number of nodes on which the instances are allowed to be placed according
   * to the placement constraints on the service.
   */
  minInstancePercentage?: number;
  /**
   * Duration in seconds, to wait before a stateless instance is closed, to allow the active
   * requests to drain gracefully. This would be effective when the instance is closing during the
   * application/cluster upgrade and disabling node.
   * The endpoint exposed on this instance is removed prior to starting the delay, which prevents
   * new connections to this instance.
   * In addition, clients that have subscribed to service endpoint change
   * events(https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.servicemanagementclient.registerservicenotificationfilterasync),
   * can do
   * the following upon receiving the endpoint removal notification:
   * - Stop sending new requests to this instance.
   * - Close existing connections after in-flight requests have completed.
   * - Connect to a different instance of the service partition for future requests.
   */
  instanceCloseDelayDurationSeconds?: string;
}

/**
 * Information about the version of image store file.
 */
export interface FileVersion {
  /**
   * The current image store version number for the file is used in image store for checking
   * whether it need to be updated.
   */
  versionNumber?: string;
  /**
   * The epoch data loss number of image store replica when this file entry was updated or created.
   */
  epochDataLossNumber?: string;
  /**
   * The epoch configuration version number of the image store replica when this file entry was
   * created or updated.
   */
  epochConfigurationNumber?: string;
}

/**
 * Information about the disk
 */
export interface DiskInfo {
  /**
   * the disk size in bytes
   */
  capacity?: string;
  /**
   * the available disk space in bytes
   */
  availableSpace?: string;
}

/**
 * Information about a image store file.
 */
export interface FileInfo {
  /**
   * The size of file in bytes.
   */
  fileSize?: string;
  /**
   * Information about the version of image store file.
   */
  fileVersion?: FileVersion;
  /**
   * The date and time when the image store file was last modified.
   */
  modifiedDate?: Date;
  /**
   * The file path relative to the image store root path.
   */
  storeRelativePath?: string;
}

/**
 * Information about a image store folder. It includes how many files this folder contains and its
 * image store relative path.
 */
export interface FolderInfo {
  /**
   * The remote location within image store. This path is relative to the image store root.
   */
  storeRelativePath?: string;
  /**
   * The number of files from within the image store folder.
   */
  fileCount?: string;
}

/**
 * Information of a image store folder size
 */
export interface FolderSizeInfo {
  /**
   * The remote location within image store. This path is relative to the image store root.
   */
  storeRelativePath?: string;
  /**
   * The size of folder in bytes.
   */
  folderSize?: string;
}

/**
 * Information about how much space and how many files in the file system the ImageStore is using
 * in this category
 */
export interface UsageInfo {
  /**
   * the size of all files in this category
   */
  usedSpace?: string;
  /**
   * the number of all files in this category
   */
  fileCount?: string;
}

/**
 * Information about the image store content.
 */
export interface ImageStoreContent {
  /**
   * The list of image store file info objects represents files found under the given image store
   * relative path.
   */
  storeFiles?: FileInfo[];
  /**
   * The list of image store folder info objects represents subfolders found under the given image
   * store relative path.
   */
  storeFolders?: FolderInfo[];
}

/**
 * Information about how to copy image store content from one image store relative path to another
 * image store relative path.
 */
export interface ImageStoreCopyDescription {
  /**
   * The relative path of source image store content to be copied from.
   */
  remoteSource: string;
  /**
   * The relative path of destination image store content to be copied to.
   */
  remoteDestination: string;
  /**
   * The list of the file names to be skipped for copying.
   */
  skipFiles?: string[];
  /**
   * Indicates whether to check mark file during copying. The property is true if checking mark
   * file is required, false otherwise. The mark file is used to check whether the folder is well
   * constructed. If the property is true and mark file does not exist, the copy is skipped.
   */
  checkMarkFile?: boolean;
}

/**
 * Information about the ImageStore's resource usage
 */
export interface ImageStoreInfo {
  /**
   * disk capacity and available disk space on the node where the ImageStore primary is placed.
   */
  diskInfo?: DiskInfo;
  /**
   * the ImageStore's file system usage for metadata.
   */
  usedByMetadata?: UsageInfo;
  /**
   * The ImageStore's file system usage for staging files that are being uploaded.
   */
  usedByStaging?: UsageInfo;
  /**
   * the ImageStore's file system usage for copied application and cluster packages. [Removing
   * application and cluster
   * packages](https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-deleteimagestorecontent)
   * will free up this space.
   */
  usedByCopy?: UsageInfo;
  /**
   * the ImageStore's file system usage for registered and cluster packages. [Unregistering
   * application](https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-unprovisionapplicationtype)
   * and [cluster
   * packages](https://docs.microsoft.com/rest/api/servicefabric/sfclient-api-unprovisionapplicationtype)
   * will free up this space.
   */
  usedByRegister?: UsageInfo;
}

/**
 * Defines description for restarting a deployed code package on Service Fabric node.
 */
export interface RestartDeployedCodePackageDescription {
  /**
   * The name of service manifest that specified this code package.
   */
  serviceManifestName: string;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
  /**
   * The name of the code package defined in the service manifest.
   */
  codePackageName: string;
  /**
   * The instance ID for currently running entry point. For a code package setup entry point (if
   * specified) runs first and after it finishes main entry point is started.
   * Each time entry point executable is run, its instance ID will change. If 0 is passed in as the
   * code package instance ID, the API will restart the code package with whatever instance ID it
   * is currently running.
   * If an instance ID other than 0 is passed in, the API will restart the code package only if the
   * current Instance ID matches the passed in instance ID.
   * Note, passing in the exact instance ID (not 0) in the API is safer, because if ensures at most
   * one restart of the code package.
   */
  codePackageInstanceId: string;
}

/**
 * Information about service type deployed on a node, information such as the status of the service
 * type registration on a node.
 */
export interface DeployedServiceTypeInfo {
  /**
   * Name of the service type as specified in the service manifest.
   */
  serviceTypeName?: string;
  /**
   * The name of the service manifest in which this service type is defined.
   */
  serviceManifestName?: string;
  /**
   * The name of the code package that registered the service type.
   */
  codePackageName?: string;
  /**
   * The status of the service type registration on the node. Possible values include: 'Invalid',
   * 'Disabled', 'Enabled', 'Registered'
   */
  status?: ServiceTypeRegistrationStatus;
  /**
   * The ActivationId of a deployed service package. If ServicePackageActivationMode specified at
   * the time of creating the service
   * is 'SharedProcess' (or if it is not specified, in which case it defaults to 'SharedProcess'),
   * then value of ServicePackageActivationId
   * is always an empty string.
   */
  servicePackageActivationId?: string;
}

/**
 * Endpoint of a resolved service partition.
 */
export interface ResolvedServiceEndpoint {
  /**
   * The role of the replica where the endpoint is reported. Possible values include: 'Invalid',
   * 'Stateless', 'StatefulPrimary', 'StatefulSecondary'
   */
  kind?: ServiceEndpointRole;
  /**
   * The address of the endpoint. If the endpoint has multiple listeners the address is a JSON
   * object with one property per listener with the value as the address of that listener.
   */
  address?: string;
}

/**
 * Information about a service partition and its associated endpoints.
 */
export interface ResolvedServicePartition {
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  name: string;
  /**
   * A representation of the resolved partition.
   */
  partitionInformation: PartitionInformationUnion;
  /**
   * List of resolved service endpoints of a service partition.
   */
  endpoints: ResolvedServiceEndpoint[];
  /**
   * The version of this resolved service partition result. This version should be passed in the
   * next time the ResolveService call is made via the PreviousRspVersion query parameter.
   */
  version: string;
}

/**
 * This class returns information about the partition that the user-induced operation acted upon.
 */
export interface SelectedPartition {
  /**
   * The name of the service the partition belongs to.
   */
  serviceName?: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId?: string;
}

/**
 * Represents information about an operation in a terminal state (Completed or Faulted).
 */
export interface InvokeDataLossResult {
  /**
   * If OperationState is Completed, this is 0.  If OperationState is Faulted, this is an error
   * code indicating the reason.
   */
  errorCode?: number;
  /**
   * This class returns information about the partition that the user-induced operation acted upon.
   */
  selectedPartition?: SelectedPartition;
}

/**
 * Represents information about an operation in a terminal state (Completed or Faulted).
 */
export interface InvokeQuorumLossResult {
  /**
   * If OperationState is Completed, this is 0.  If OperationState is Faulted, this is an error
   * code indicating the reason.
   */
  errorCode?: number;
  /**
   * This class returns information about the partition that the user-induced operation acted upon.
   */
  selectedPartition?: SelectedPartition;
}

/**
 * Contains information about a node that was targeted by a user-induced operation.
 */
export interface NodeResult {
  /**
   * The name of a Service Fabric node.
   */
  nodeName?: string;
  /**
   * The node instance id.
   */
  nodeInstanceId?: string;
}

/**
 * Represents information about an operation in a terminal state (Completed or Faulted).
 */
export interface NodeTransitionResult {
  /**
   * If OperationState is Completed, this is 0.  If OperationState is Faulted, this is an error
   * code indicating the reason.
   */
  errorCode?: number;
  /**
   * Contains information about a node that was targeted by a user-induced operation.
   */
  nodeResult?: NodeResult;
}

/**
 * Information about an NodeTransition operation.  This class contains an OperationState and a
 * NodeTransitionResult.  The NodeTransitionResult is not valid until OperationState
 * is Completed or Faulted.
 */
export interface NodeTransitionProgress {
  /**
   * The state of the operation. Possible values include: 'Invalid', 'Running', 'RollingBack',
   * 'Completed', 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * Represents information about an operation in a terminal state (Completed or Faulted).
   */
  nodeTransitionResult?: NodeTransitionResult;
}

/**
 * Contains the OperationId, OperationState, and OperationType for user-induced operations.
 */
export interface OperationStatus {
  /**
   * A GUID that identifies a call to this API.  This is also passed into the corresponding
   * GetProgress API.
   */
  operationId?: string;
  /**
   * The state of the operation. Possible values include: 'Invalid', 'Running', 'RollingBack',
   * 'Completed', 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * The type of the operation. Possible values include: 'Invalid', 'PartitionDataLoss',
   * 'PartitionQuorumLoss', 'PartitionRestart', 'NodeTransition'
   */
  type?: OperationType;
}

/**
 * Information about a partition data loss user-induced operation.
 */
export interface PartitionDataLossProgress {
  /**
   * The state of the operation. Possible values include: 'Invalid', 'Running', 'RollingBack',
   * 'Completed', 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * Represents information about an operation in a terminal state (Completed or Faulted).
   */
  invokeDataLossResult?: InvokeDataLossResult;
}

/**
 * Information about a partition quorum loss user-induced operation.
 */
export interface PartitionQuorumLossProgress {
  /**
   * The state of the operation. Possible values include: 'Invalid', 'Running', 'RollingBack',
   * 'Completed', 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * Represents information about an operation in a terminal state (Completed or Faulted).
   */
  invokeQuorumLossResult?: InvokeQuorumLossResult;
}

/**
 * Represents information about an operation in a terminal state (Completed or Faulted).
 */
export interface RestartPartitionResult {
  /**
   * If OperationState is Completed, this is 0.  If OperationState is Faulted, this is an error
   * code indicating the reason.
   */
  errorCode?: number;
  /**
   * This class returns information about the partition that the user-induced operation acted upon.
   */
  selectedPartition?: SelectedPartition;
}

/**
 * Information about a partition restart user-induced operation.
 */
export interface PartitionRestartProgress {
  /**
   * The state of the operation. Possible values include: 'Invalid', 'Running', 'RollingBack',
   * 'Completed', 'Faulted', 'Cancelled', 'ForceCancelled'
   */
  state?: OperationState;
  /**
   * Represents information about an operation in a terminal state (Completed or Faulted).
   */
  restartPartitionResult?: RestartPartitionResult;
}

/**
 * Represents a policy for the package sharing.
 */
export interface PackageSharingPolicyInfo {
  /**
   * The name of code, configuration or data package that should be shared.
   */
  sharedPackageName?: string;
  /**
   * Represents the scope for PackageSharingPolicy. This is specified during
   * DeployServicePackageToNode operation. Possible values include: 'None', 'All', 'Code',
   * 'Config', 'Data'
   */
  packageSharingScope?: PackageSharingPolicyScope;
}

/**
 * Defines description for downloading packages associated with a service manifest to image cache
 * on a Service Fabric node.
 */
export interface DeployServicePackageToNodeDescription {
  /**
   * The name of service manifest whose packages need to be downloaded.
   */
  serviceManifestName: string;
  /**
   * The application type name as defined in the application manifest.
   */
  applicationTypeName: string;
  /**
   * The version of the application type as defined in the application manifest.
   */
  applicationTypeVersion: string;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * List of package sharing policy information.
   */
  packageSharingPolicy?: PackageSharingPolicyInfo[];
}

/**
 * Describes the parameters for resuming an unmonitored manual Service Fabric application upgrade
 */
export interface ResumeApplicationUpgradeDescription {
  /**
   * The name of the upgrade domain in which to resume the upgrade.
   */
  upgradeDomainName: string;
}

/**
 * Describes the parameters for updating an ongoing application upgrade.
 */
export interface ApplicationUpgradeUpdateDescription {
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  name: string;
  /**
   * The kind of upgrade out of the following possible values. Possible values include: 'Invalid',
   * 'Rolling'. Default value: 'Rolling'.
   */
  upgradeKind: UpgradeKind;
  /**
   * Defines a health policy used to evaluate the health of an application or one of its children
   * entities.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * Describes the parameters for updating a rolling upgrade of application or cluster.
   */
  updateDescription?: RollingUpgradeUpdateDescription;
}

/**
 * Describes a Service Fabric name.
 */
export interface NameDescription {
  /**
   * The Service Fabric name, including the 'fabric:' URI scheme.
   */
  name: string;
}

/**
 * A paged list of Service Fabric names. The list is paged when all of the results cannot fit in a
 * single message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedSubNameInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * Indicates whether any name under the given name has been modified during the enumeration. If
   * there was a modification, this property value is false.
   */
  isConsistent?: boolean;
  /**
   * List of the child names.
   */
  subNames?: string[];
}

/**
 * Contains the possible cases for PropertyValue.
 */
export type PropertyValueUnion = PropertyValue | BinaryPropertyValue | Int64PropertyValue | DoublePropertyValue | StringPropertyValue | GuidPropertyValue;

/**
 * Describes a Service Fabric property value.
 */
export interface PropertyValue {
  /**
   * Polymorphic Discriminator
   */
  kind: "PropertyValue";
}

/**
 * Describes a Service Fabric property value of type Binary.
 */
export interface BinaryPropertyValue {
  /**
   * Polymorphic Discriminator
   */
  kind: "Binary";
  /**
   * Array of bytes to be sent as an integer array. Each element of array is a number between 0 and
   * 255.
   */
  data: number[];
}

/**
 * Describes a Service Fabric property value of type Int64.
 */
export interface Int64PropertyValue {
  /**
   * Polymorphic Discriminator
   */
  kind: "Int64";
  /**
   * The data of the property value.
   */
  data: string;
}

/**
 * Describes a Service Fabric property value of type Double.
 */
export interface DoublePropertyValue {
  /**
   * Polymorphic Discriminator
   */
  kind: "Double";
  /**
   * The data of the property value.
   */
  data: number;
}

/**
 * Describes a Service Fabric property value of type String.
 */
export interface StringPropertyValue {
  /**
   * Polymorphic Discriminator
   */
  kind: "String";
  /**
   * The data of the property value.
   */
  data: string;
}

/**
 * Describes a Service Fabric property value of type Guid.
 */
export interface GuidPropertyValue {
  /**
   * Polymorphic Discriminator
   */
  kind: "Guid";
  /**
   * The data of the property value.
   */
  data: string;
}

/**
 * The metadata associated with a property, including the property's name.
 */
export interface PropertyMetadata {
  /**
   * The kind of property, determined by the type of data. Following are the possible values.
   * Possible values include: 'Invalid', 'Binary', 'Int64', 'Double', 'String', 'Guid'
   */
  typeId?: PropertyValueKind;
  /**
   * The property's custom type ID.
   */
  customTypeId?: string;
  /**
   * The name of the parent Service Fabric Name for the property. It could be thought of as the
   * name-space/table under which the property exists.
   */
  parent?: string;
  /**
   * The length of the serialized property value.
   */
  sizeInBytes?: number;
  /**
   * Represents when the Property was last modified. Only write operations will cause this field to
   * be updated.
   */
  lastModifiedUtcTimestamp?: Date;
  /**
   * The version of the property. Every time a property is modified, its sequence number is
   * increased.
   */
  sequenceNumber?: string;
}

/**
 * Information about a Service Fabric property.
 */
export interface PropertyInfo {
  /**
   * The name of the Service Fabric property.
   */
  name: string;
  /**
   * Describes a Service Fabric property value.
   */
  value?: PropertyValueUnion;
  /**
   * The metadata associated with a property, including the property's name.
   */
  metadata: PropertyMetadata;
}

/**
 * The paged list of Service Fabric properties under a given name. The list is paged when all of
 * the results cannot fit in a single message. The next set of results can be obtained by executing
 * the same query with the continuation token provided in this list.
 */
export interface PagedPropertyInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * Indicates whether any property under the given name has been modified during the enumeration.
   * If there was a modification, this property value is false.
   */
  isConsistent?: boolean;
  /**
   * List of property information.
   */
  properties?: PropertyInfo[];
}

/**
 * Description of a Service Fabric property.
 */
export interface PropertyDescription {
  /**
   * The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * The property's custom type ID. Using this property, the user is able to tag the type of the
   * value of the property.
   */
  customTypeId?: string;
  /**
   * Describes a Service Fabric property value.
   */
  value: PropertyValueUnion;
}

/**
 * Contains the possible cases for PropertyBatchOperation.
 */
export type PropertyBatchOperationUnion = PropertyBatchOperation | CheckExistsPropertyBatchOperation | CheckSequencePropertyBatchOperation | CheckValuePropertyBatchOperation | DeletePropertyBatchOperation | GetPropertyBatchOperation | PutPropertyBatchOperation;

/**
 * Represents the base type for property operations that can be put into a batch and submitted.
 */
export interface PropertyBatchOperation {
  /**
   * Polymorphic Discriminator
   */
  kind: "PropertyBatchOperation";
  /**
   * The name of the Service Fabric property.
   */
  propertyName: string;
}

/**
 * Describes a list of property batch operations to be executed. Either all or none of the
 * operations will be committed.
 */
export interface PropertyBatchDescriptionList {
  /**
   * A list of the property batch operations to be executed.
   */
  operations?: PropertyBatchOperationUnion[];
}

/**
 * Represents a PropertyBatchOperation that compares the Boolean existence of a property with the
 * Exists argument.
 * The PropertyBatchOperation operation fails if the property's existence is not equal to the
 * Exists argument.
 * The CheckExistsPropertyBatchOperation is generally used as a precondition for the write
 * operations in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 */
export interface CheckExistsPropertyBatchOperation {
  /**
   * Polymorphic Discriminator
   */
  kind: "CheckExists";
  /**
   * The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * Whether or not the property should exist for the operation to pass.
   */
  exists: boolean;
}

/**
 * Compares the Sequence Number of a property with the SequenceNumber argument.
 * A property's sequence number can be thought of as that property's version.
 * Every time the property is modified, its sequence number is increased.
 * The sequence number can be found in a property's metadata.
 * The comparison fails if the sequence numbers are not equal.
 * CheckSequencePropertyBatchOperation is generally used as a precondition for the write operations
 * in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 */
export interface CheckSequencePropertyBatchOperation {
  /**
   * Polymorphic Discriminator
   */
  kind: "CheckSequence";
  /**
   * The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * The expected sequence number.
   */
  sequenceNumber: string;
}

/**
 * Represents a PropertyBatchOperation that compares the value of the property with the expected
 * value.
 * The CheckValuePropertyBatchOperation is generally used as a precondition for the write
 * operations in the batch.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 */
export interface CheckValuePropertyBatchOperation {
  /**
   * Polymorphic Discriminator
   */
  kind: "CheckValue";
  /**
   * The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * The expected property value.
   */
  value: PropertyValueUnion;
}

/**
 * Represents a PropertyBatchOperation that deletes a specified property if it exists.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 */
export interface DeletePropertyBatchOperation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Delete";
  /**
   * The name of the Service Fabric property.
   */
  propertyName: string;
}

/**
 * Represents a PropertyBatchOperation that gets the specified property if it exists.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 */
export interface GetPropertyBatchOperation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Get";
  /**
   * The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * Whether or not to return the property value with the metadata.
   * True if values should be returned with the metadata; False to return only property metadata.
   * Default value: false.
   */
  includeValue?: boolean;
}

/**
 * Puts the specified property under the specified name.
 * Note that if one PropertyBatchOperation in a PropertyBatch fails,
 * the entire batch fails and cannot be committed in a transactional manner.
 */
export interface PutPropertyBatchOperation {
  /**
   * Polymorphic Discriminator
   */
  kind: "Put";
  /**
   * The name of the Service Fabric property.
   */
  propertyName: string;
  /**
   * Describes a Service Fabric property value.
   */
  value: PropertyValueUnion;
  /**
   * The property's custom type ID. Using this property, the user is able to tag the type of the
   * value of the property.
   */
  customTypeId?: string;
}

/**
 * Contains the possible cases for PropertyBatchInfo.
 */
export type PropertyBatchInfoUnion = PropertyBatchInfo | SuccessfulPropertyBatchInfo | FailedPropertyBatchInfo;

/**
 * Information about the results of a property batch.
 */
export interface PropertyBatchInfo {
  /**
   * Polymorphic Discriminator
   */
  kind: "PropertyBatchInfo";
}

/**
 * Derived from PropertyBatchInfo. Represents the property batch succeeding. Contains the results
 * of any "Get" operations in the batch.
 */
export interface SuccessfulPropertyBatchInfo {
  /**
   * Polymorphic Discriminator
   */
  kind: "Successful";
  /**
   * A map containing the properties that were requested through any "Get" property batch
   * operations. The key represents the index of the "Get" operation in the original request, in
   * string form. The value is the property. If a property is not found, it will not be in the map.
   */
  properties?: { [propertyName: string]: PropertyInfo };
}

/**
 * Derived from PropertyBatchInfo. Represents the property batch failing. Contains information
 * about the specific batch failure.
 */
export interface FailedPropertyBatchInfo {
  /**
   * Polymorphic Discriminator
   */
  kind: "Failed";
  /**
   * The error message of the failed operation. Describes the exception thrown due to the first
   * unsuccessful operation in the property batch.
   */
  errorMessage?: string;
  /**
   * The index of the unsuccessful operation in the property batch.
   */
  operationIndex?: number;
}

/**
 * Contains the possible cases for BackupScheduleDescription.
 */
export type BackupScheduleDescriptionUnion = BackupScheduleDescription | FrequencyBasedBackupScheduleDescription | TimeBasedBackupScheduleDescription;

/**
 * Describes the backup schedule parameters.
 */
export interface BackupScheduleDescription {
  /**
   * Polymorphic Discriminator
   */
  scheduleKind: "BackupScheduleDescription";
}

/**
 * Contains the possible cases for BackupStorageDescription.
 */
export type BackupStorageDescriptionUnion = BackupStorageDescription | AzureBlobBackupStorageDescription | FileShareBackupStorageDescription;

/**
 * Describes the parameters for the backup storage.
 */
export interface BackupStorageDescription {
  /**
   * Polymorphic Discriminator
   */
  storageKind: "BackupStorageDescription";
  /**
   * Friendly name for this backup storage.
   */
  friendlyName?: string;
}

/**
 * Contains the possible cases for RetentionPolicyDescription.
 */
export type RetentionPolicyDescriptionUnion = RetentionPolicyDescription | BasicRetentionPolicyDescription;

/**
 * Describes the retention policy configured.
 */
export interface RetentionPolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  retentionPolicyType: "RetentionPolicyDescription";
}

/**
 * Describes a backup policy for configuring periodic backup.
 */
export interface BackupPolicyDescription {
  /**
   * The unique name identifying this backup policy.
   */
  name: string;
  /**
   * Specifies whether to trigger restore automatically using the latest available backup in case
   * the partition experiences a data loss event.
   */
  autoRestoreOnDataLoss: boolean;
  /**
   * Defines the maximum number of incremental backups to be taken between two full backups. This
   * is just the upper limit. A full backup may be taken before specified number of incremental
   * backups are completed in one of the following conditions
   * - The replica has never taken a full backup since it has become primary,
   * - Some of the log records since the last backup has been truncated, or
   * - Replica passed the MaxAccumulatedBackupLogSizeInMB limit.
   */
  maxIncrementalBackups: number;
  /**
   * Describes the backup schedule parameters.
   */
  schedule: BackupScheduleDescriptionUnion;
  /**
   * Describes the details of backup storage where to store the periodic backups.
   */
  storage: BackupStorageDescriptionUnion;
  /**
   * Describes the policy to retain backups in storage.
   */
  retentionPolicy?: RetentionPolicyDescriptionUnion;
}

/**
 * The list of backup policies configured in the cluster. The list is paged when all of the results
 * cannot fit in a single message. The next set of results can be obtained by executing the same
 * query with the continuation token provided in this list.
 */
export interface PagedBackupPolicyDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * The list of backup policies information.
   */
  items?: BackupPolicyDescription[];
}

/**
 * Describes basic retention policy.
 */
export interface BasicRetentionPolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  retentionPolicyType: "Basic";
  /**
   * It is the minimum duration for which a backup created, will remain stored in the storage and
   * might get deleted after that span of time. It should be specified in ISO8601 format.
   */
  retentionDuration: string;
  /**
   * It is the minimum number of backups to be retained at any point of time. If specified with a
   * non zero value, backups will not be deleted even if the backups have gone past retention
   * duration and have number of backups less than or equal to it.
   */
  minimumNumberOfBackups?: number;
}

/**
 * It describes the body parameters while disabling backup of a backup
 * entity(Application/Service/Partition).
 */
export interface DisableBackupDescription {
  /**
   * Boolean flag to delete backups. It can be set to true for deleting all the backups which were
   * created for the backup entity that is getting disabled for backup.
   */
  cleanBackup: boolean;
}

/**
 * Contains the possible cases for BackupConfigurationInfo.
 */
export type BackupConfigurationInfoUnion = BackupConfigurationInfo | ApplicationBackupConfigurationInfo | ServiceBackupConfigurationInfo | PartitionBackupConfigurationInfo;

/**
 * Describes the backup configuration information.
 */
export interface BackupConfigurationInfo {
  /**
   * Polymorphic Discriminator
   */
  kind: "BackupConfigurationInfo";
  /**
   * The name of the backup policy which is applicable to this Service Fabric application or
   * service or partition.
   */
  policyName?: string;
  /**
   * Specifies the scope at which the backup policy is applied. Possible values include: 'Invalid',
   * 'Partition', 'Service', 'Application'
   */
  policyInheritedFrom?: BackupPolicyScope;
  /**
   * Describes the backup suspension details.
   */
  suspensionInfo?: BackupSuspensionInfo;
}

/**
 * Backup configuration information for a specific Service Fabric application specifying what
 * backup policy is being applied and suspend description, if any.
 */
export interface ApplicationBackupConfigurationInfo {
  /**
   * Polymorphic Discriminator
   */
  kind: "Application";
  /**
   * The name of the backup policy which is applicable to this Service Fabric application or
   * service or partition.
   */
  policyName?: string;
  /**
   * Specifies the scope at which the backup policy is applied. Possible values include: 'Invalid',
   * 'Partition', 'Service', 'Application'
   */
  policyInheritedFrom?: BackupPolicyScope;
  /**
   * Describes the backup suspension details.
   */
  suspensionInfo?: BackupSuspensionInfo;
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
}

/**
 * Backup configuration information for a specific Service Fabric service specifying what backup
 * policy is being applied and suspend description, if any.
 */
export interface ServiceBackupConfigurationInfo {
  /**
   * Polymorphic Discriminator
   */
  kind: "Service";
  /**
   * The name of the backup policy which is applicable to this Service Fabric application or
   * service or partition.
   */
  policyName?: string;
  /**
   * Specifies the scope at which the backup policy is applied. Possible values include: 'Invalid',
   * 'Partition', 'Service', 'Application'
   */
  policyInheritedFrom?: BackupPolicyScope;
  /**
   * Describes the backup suspension details.
   */
  suspensionInfo?: BackupSuspensionInfo;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName?: string;
}

/**
 * Describes the backup suspension details.
 */
export interface BackupSuspensionInfo {
  /**
   * Indicates whether periodic backup is suspended at this level or not.
   */
  isSuspended?: boolean;
  /**
   * Specifies the scope at which the backup suspension was applied. Possible values include:
   * 'Invalid', 'Partition', 'Service', 'Application'
   */
  suspensionInheritedFrom?: BackupSuspensionScope;
}

/**
 * The list of backup configuration information. The list is paged when all of the results cannot
 * fit in a single message. The next set of results can be obtained by executing the same query
 * with the continuation token provided in this list.
 */
export interface PagedBackupConfigurationInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of backup configuration information.
   */
  items?: BackupConfigurationInfoUnion[];
}

/**
 * Specifies the parameters needed to trigger a restore of a specific partition.
 */
export interface RestorePartitionDescription {
  /**
   * Unique backup ID.
   */
  backupId: string;
  /**
   * Location of the backup relative to the backup storage specified/ configured.
   */
  backupLocation: string;
  /**
   * Location of the backup from where the partition will be restored.
   */
  backupStorage?: BackupStorageDescriptionUnion;
}

/**
 * Describes the progress of a restore operation on a partition.
 */
export interface RestoreProgressInfo {
  /**
   * Represents the current state of the partition restore operation. Possible values include:
   * 'Invalid', 'Accepted', 'RestoreInProgress', 'Success', 'Failure', 'Timeout'
   */
  restoreState?: RestoreState;
  /**
   * Timestamp when operation succeeded or failed.
   */
  timeStampUtc?: Date;
  /**
   * Describes the epoch at which the partition is restored.
   */
  restoredEpoch?: Epoch;
  /**
   * Restored LSN.
   */
  restoredLsn?: string;
  /**
   * Denotes the failure encountered in performing restore operation.
   */
  failureError?: FabricErrorError;
}

/**
 * Describes the parameters for triggering partition's backup.
 */
export interface BackupPartitionDescription {
  /**
   * Specifies the details of the backup storage where to save the backup.
   */
  backupStorage?: BackupStorageDescriptionUnion;
}

/**
 * Represents a backup point which can be used to trigger a restore.
 */
export interface BackupInfo {
  /**
   * Unique backup ID .
   */
  backupId?: string;
  /**
   * Unique backup chain ID. All backups part of the same chain has the same backup chain id. A
   * backup chain is comprised of 1 full backup and multiple incremental backups.
   */
  backupChainId?: string;
  /**
   * Name of the Service Fabric application this partition backup belongs to.
   */
  applicationName?: string;
  /**
   * Name of the Service Fabric service this partition backup belongs to.
   */
  serviceName?: string;
  /**
   * Information about the partition to which this backup belongs to
   */
  partitionInformation?: PartitionInformationUnion;
  /**
   * Location of the backup, relative to the backup store.
   */
  backupLocation?: string;
  /**
   * Describes the type of backup, whether its full or incremental. Possible values include:
   * 'Invalid', 'Full', 'Incremental'
   */
  backupType?: BackupType;
  /**
   * Epoch of the last record in this backup.
   */
  epochOfLastBackupRecord?: Epoch;
  /**
   * LSN of the last record in this backup.
   */
  lsnOfLastBackupRecord?: string;
  /**
   * The date time when this backup was taken.
   */
  creationTimeUtc?: Date;
  /**
   * Manifest Version of the service this partition backup belongs to.
   */
  serviceManifestVersion?: string;
  /**
   * Denotes the failure encountered in getting backup point information.
   */
  failureError?: FabricErrorError;
}

/**
 * The list of backups. The list is paged when all of the results cannot fit in a single message.
 * The next set of results can be obtained by executing the same query with the continuation token
 * provided in this list.
 */
export interface PagedBackupInfoList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of backup information.
   */
  items?: BackupInfo[];
}

/**
 * Describes the parameters for Azure blob store used for storing and enumerating backups.
 */
export interface AzureBlobBackupStorageDescription {
  /**
   * Polymorphic Discriminator
   */
  storageKind: "AzureBlobStore";
  /**
   * Friendly name for this backup storage.
   */
  friendlyName?: string;
  /**
   * The connection string to connect to the Azure blob store.
   */
  connectionString: string;
  /**
   * The name of the container in the blob store to store and enumerate backups from.
   */
  containerName: string;
}

/**
 * Describes the parameters for file share storage used for storing or enumerating backups.
 */
export interface FileShareBackupStorageDescription {
  /**
   * Polymorphic Discriminator
   */
  storageKind: "FileShare";
  /**
   * Friendly name for this backup storage.
   */
  friendlyName?: string;
  /**
   * UNC path of the file share where to store or enumerate backups from.
   */
  path: string;
  /**
   * Primary user name to access the file share.
   */
  primaryUserName?: string;
  /**
   * Primary password to access the share location.
   */
  primaryPassword?: string;
  /**
   * Secondary user name to access the file share.
   */
  secondaryUserName?: string;
  /**
   * Secondary password to access the share location
   */
  secondaryPassword?: string;
}

/**
 * Describes the frequency based backup schedule.
 */
export interface FrequencyBasedBackupScheduleDescription {
  /**
   * Polymorphic Discriminator
   */
  scheduleKind: "FrequencyBased";
  /**
   * Defines the interval with which backups are periodically taken. It should be specified in
   * ISO8601 format. Timespan in seconds is not supported and will be ignored while creating the
   * policy.
   */
  interval: string;
}

/**
 * Describes the time based backup schedule.
 */
export interface TimeBasedBackupScheduleDescription {
  /**
   * Polymorphic Discriminator
   */
  scheduleKind: "TimeBased";
  /**
   * Describes the frequency with which to run the time based backup schedule. Possible values
   * include: 'Invalid', 'Daily', 'Weekly'
   */
  scheduleFrequencyType: BackupScheduleFrequencyType;
  /**
   * List of days of a week when to trigger the periodic backup. This is valid only when the backup
   * schedule frequency type is weekly.
   */
  runDays?: DayOfWeek[];
  /**
   * Represents the list of exact time during the day in ISO8601 format. Like '19:00:00' will
   * represent '7PM' during the day. Date specified along with time will be ignored.
   */
  runTimes: Date[] | string[];
}

/**
 * Describes the progress of a partition's backup.
 */
export interface BackupProgressInfo {
  /**
   * Represents the current state of the partition backup operation. Possible values include:
   * 'Invalid', 'Accepted', 'BackupInProgress', 'Success', 'Failure', 'Timeout'
   */
  backupState?: BackupState;
  /**
   * TimeStamp in UTC when operation succeeded or failed.
   */
  timeStampUtc?: Date;
  /**
   * Unique ID of the newly created backup.
   */
  backupId?: string;
  /**
   * Location, relative to the backup store, of the newly created backup.
   */
  backupLocation?: string;
  /**
   * Specifies the epoch of the last record included in backup.
   */
  epochOfLastBackupRecord?: Epoch;
  /**
   * The LSN of last record included in backup.
   */
  lsnOfLastBackupRecord?: string;
  /**
   * Denotes the failure encountered in performing backup operation.
   */
  failureError?: FabricErrorError;
}

/**
 * Backup configuration information, for a specific partition, specifying what backup policy is
 * being applied and suspend description, if any.
 */
export interface PartitionBackupConfigurationInfo {
  /**
   * Polymorphic Discriminator
   */
  kind: "Partition";
  /**
   * The name of the backup policy which is applicable to this Service Fabric application or
   * service or partition.
   */
  policyName?: string;
  /**
   * Specifies the scope at which the backup policy is applied. Possible values include: 'Invalid',
   * 'Partition', 'Service', 'Application'
   */
  policyInheritedFrom?: BackupPolicyScope;
  /**
   * Describes the backup suspension details.
   */
  suspensionInfo?: BackupSuspensionInfo;
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName?: string;
  /**
   * The partition ID identifying the partition.
   */
  partitionId?: string;
}

/**
 * Contains the possible cases for BackupEntity.
 */
export type BackupEntityUnion = BackupEntity | ApplicationBackupEntity | ServiceBackupEntity | PartitionBackupEntity;

/**
 * Describes the Service Fabric entity that is configured for backup.
 */
export interface BackupEntity {
  /**
   * Polymorphic Discriminator
   */
  entityKind: "BackupEntity";
}

/**
 * Identifies the Service Fabric application which is being backed up.
 */
export interface ApplicationBackupEntity {
  /**
   * Polymorphic Discriminator
   */
  entityKind: "Application";
  /**
   * The name of the application, including the 'fabric:' URI scheme.
   */
  applicationName?: string;
}

/**
 * Identifies the Service Fabric stateful service which is being backed up.
 */
export interface ServiceBackupEntity {
  /**
   * Polymorphic Discriminator
   */
  entityKind: "Service";
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName?: string;
}

/**
 * Identifies the Service Fabric stateful partition which is being backed up.
 */
export interface PartitionBackupEntity {
  /**
   * Polymorphic Discriminator
   */
  entityKind: "Partition";
  /**
   * The full name of the service with 'fabric:' URI scheme.
   */
  serviceName?: string;
  /**
   * The partition ID identifying the partition.
   */
  partitionId?: string;
}

/**
 * Specifies the parameters needed to enable periodic backup.
 */
export interface EnableBackupDescription {
  /**
   * Name of the backup policy to be used for enabling periodic backups.
   */
  backupPolicyName: string;
}

/**
 * The list of backup entities that are being periodically backed. The list is paged when all of
 * the results cannot fit in a single message. The next set of results can be obtained by executing
 * the same query with the continuation token provided in this list.
 */
export interface PagedBackupEntityList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of backup entity information.
   */
  items?: BackupEntityUnion[];
}

/**
 * Describes additional filters to be applied, while listing backups, and backup storage details
 * from where to fetch the backups.
 */
export interface GetBackupByStorageQueryDescription {
  /**
   * Specifies the start date time in ISO8601 from which to enumerate backups. If not specified,
   * backups are enumerated from the beginning.
   */
  startDateTimeFilter?: Date;
  /**
   * Specifies the end date time in ISO8601 till which to enumerate backups. If not specified,
   * backups are enumerated till the end.
   */
  endDateTimeFilter?: Date;
  /**
   * If specified as true, gets the most recent backup (within the specified time range) for every
   * partition under the specified backup entity. Default value: false.
   */
  latest?: boolean;
  /**
   * Describes the parameters for the backup storage from where to enumerate backups. This is
   * optional and by default backups are enumerated from the backup storage where this backup
   * entity is currently being backed up (as specified in backup policy). This parameter is useful
   * to be able to enumerate backups from another cluster where you may intend to restore.
   */
  storage: BackupStorageDescriptionUnion;
  /**
   * Indicates the entity for which to enumerate backups.
   */
  backupEntity: BackupEntityUnion;
}

/**
 * Describes the expected impact of a repair to a particular node.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface NodeImpact {
  /**
   * The name of the impacted node.
   */
  nodeName: string;
  /**
   * The level of impact expected. Possible values include: 'Invalid', 'None', 'Restart',
   * 'RemoveData', 'RemoveNode'
   */
  impactLevel?: ImpactLevel;
}

/**
 * Contains the possible cases for RepairImpactDescriptionBase.
 */
export type RepairImpactDescriptionBaseUnion = RepairImpactDescriptionBase | NodeRepairImpactDescription;

/**
 * Describes the expected impact of executing a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairImpactDescriptionBase {
  /**
   * Polymorphic Discriminator
   */
  kind: "RepairImpactDescriptionBase";
}

/**
 * Describes the expected impact of a repair on a set of nodes.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface NodeRepairImpactDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "Node";
  /**
   * The list of nodes impacted by a repair action and their respective expected impact.
   */
  nodeImpactList?: NodeImpact[];
}

/**
 * Contains the possible cases for RepairTargetDescriptionBase.
 */
export type RepairTargetDescriptionBaseUnion = RepairTargetDescriptionBase | NodeRepairTargetDescription;

/**
 * Describes the entities targeted by a repair action.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairTargetDescriptionBase {
  /**
   * Polymorphic Discriminator
   */
  kind: "RepairTargetDescriptionBase";
}

/**
 * Describes the list of nodes targeted by a repair action.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface NodeRepairTargetDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "Node";
  /**
   * The list of nodes targeted by a repair action.
   */
  nodeNames?: string[];
}

/**
 * A record of the times when the repair task entered each state.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairTaskHistory {
  /**
   * The time when the repair task entered the Created state.
   */
  createdUtcTimestamp?: Date;
  /**
   * The time when the repair task entered the Claimed state.
   */
  claimedUtcTimestamp?: Date;
  /**
   * The time when the repair task entered the Preparing state.
   */
  preparingUtcTimestamp?: Date;
  /**
   * The time when the repair task entered the Approved state
   */
  approvedUtcTimestamp?: Date;
  /**
   * The time when the repair task entered the Executing state
   */
  executingUtcTimestamp?: Date;
  /**
   * The time when the repair task entered the Restoring state
   */
  restoringUtcTimestamp?: Date;
  /**
   * The time when the repair task entered the Completed state
   */
  completedUtcTimestamp?: Date;
  /**
   * The time when the repair task started the health check in the Preparing state.
   */
  preparingHealthCheckStartUtcTimestamp?: Date;
  /**
   * The time when the repair task completed the health check in the Preparing state.
   */
  preparingHealthCheckEndUtcTimestamp?: Date;
  /**
   * The time when the repair task started the health check in the Restoring state.
   */
  restoringHealthCheckStartUtcTimestamp?: Date;
  /**
   * The time when the repair task completed the health check in the Restoring state.
   */
  restoringHealthCheckEndUtcTimestamp?: Date;
}

/**
 * Represents a repair task, which includes information about what kind of repair was requested,
 * what its progress is, and what its final result was.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairTask {
  /**
   * The ID of the repair task.
   */
  taskId: string;
  /**
   * The version of the repair task.
   * When creating a new repair task, the version must be set to zero.  When updating a repair
   * task,
   * the version is used for optimistic concurrency checks.  If the version is
   * set to zero, the update will not check for write conflicts.  If the version is set to a
   * non-zero value, then the
   * update will only succeed if the actual current version of the repair task matches this value.
   */
  version?: string;
  /**
   * A description of the purpose of the repair task, or other informational details.
   * May be set when the repair task is created, and is immutable once set.
   */
  description?: string;
  /**
   * The workflow state of the repair task. Valid initial states are Created, Claimed, and
   * Preparing. Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved',
   * 'Executing', 'Restoring', 'Completed'
   */
  state: State;
  /**
   * A bitwise-OR of the following values, which gives additional details about the status of the
   * repair task.
   * - 1 - Cancellation of the repair has been requested
   * - 2 - Abort of the repair has been requested
   * - 4 - Approval of the repair was forced via client request
   */
  flags?: number;
  /**
   * The requested repair action. Must be specified when the repair task is created, and is
   * immutable once set.
   */
  action: string;
  /**
   * The target object determines what actions the system will take to prepare for the impact of
   * the repair, prior to approving execution of the repair.
   * May be set when the repair task is created, and is immutable once set.
   */
  target?: RepairTargetDescriptionBaseUnion;
  /**
   * The name of the repair executor. Must be specified in Claimed and later states, and is
   * immutable once set.
   */
  executor?: string;
  /**
   * A data string that the repair executor can use to store its internal state.
   */
  executorData?: string;
  /**
   * The impact object determines what actions the system will take to prepare for the impact of
   * the repair, prior to approving execution of the repair.
   * Impact must be specified by the repair executor when transitioning to the Preparing state, and
   * is immutable once set.
   */
  impact?: RepairImpactDescriptionBaseUnion;
  /**
   * A value describing the overall result of the repair task execution. Must be specified in the
   * Restoring and later states, and is immutable once set. Possible values include: 'Invalid',
   * 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
   */
  resultStatus?: ResultStatus;
  /**
   * A numeric value providing additional details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once set.
   */
  resultCode?: number;
  /**
   * A string providing additional details about the result of the repair task execution.
   * May be specified in the Restoring and later states, and is immutable once set.
   */
  resultDetails?: string;
  /**
   * An object that contains timestamps of the repair task's state transitions.
   * These timestamps are updated by the system, and cannot be directly modified.
   */
  history?: RepairTaskHistory;
  /**
   * The workflow state of the health check when the repair task is in the Preparing state.
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   */
  preparingHealthCheckState?: RepairTaskHealthCheckState;
  /**
   * The workflow state of the health check when the repair task is in the Restoring state.
   * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
   */
  restoringHealthCheckState?: RepairTaskHealthCheckState;
  /**
   * A value to determine if health checks will be performed when the repair task enters the
   * Preparing state.
   */
  performPreparingHealthCheck?: boolean;
  /**
   * A value to determine if health checks will be performed when the repair task enters the
   * Restoring state.
   */
  performRestoringHealthCheck?: boolean;
}

/**
 * Describes a request for forced approval of a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairTaskApproveDescription {
  /**
   * The ID of the repair task.
   */
  taskId: string;
  /**
   * The current version number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If zero, then no version
   * check is performed.
   */
  version?: string;
}

/**
 * Describes a request to cancel a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairTaskCancelDescription {
  /**
   * The ID of the repair task.
   */
  taskId: string;
  /**
   * The current version number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If zero, then no version
   * check is performed.
   */
  version?: string;
  /**
   * _True_ if the repair should be stopped as soon as possible even if it has already started
   * executing. _False_ if the repair should be cancelled only if execution has not yet started.
   */
  requestAbort?: boolean;
}

/**
 * Describes a request to delete a completed repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairTaskDeleteDescription {
  /**
   * The ID of the completed repair task to be deleted.
   */
  taskId: string;
  /**
   * The current version number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current version of the repair task. If zero, then no version
   * check is performed.
   */
  version?: string;
}

/**
 * Describes a request to update the health policy of a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairTaskUpdateHealthPolicyDescription {
  /**
   * The ID of the repair task to be updated.
   */
  taskId: string;
  /**
   * The current version number of the repair task. If non-zero, then the request will only succeed
   * if this value matches the actual current value of the repair task. If zero, then no version
   * check is performed.
   */
  version?: string;
  /**
   * A boolean indicating if health check is to be performed in the Preparing stage of the repair
   * task. If not specified the existing value should not be altered. Otherwise, specify the
   * desired new value.
   */
  performPreparingHealthCheck?: boolean;
  /**
   * A boolean indicating if health check is to be performed in the Restoring stage of the repair
   * task. If not specified the existing value should not be altered. Otherwise, specify the
   * desired new value.
   */
  performRestoringHealthCheck?: boolean;
}

/**
 * Describes the result of an operation that created or updated a repair task.
 *
 * This type supports the Service Fabric platform; it is not meant to be used directly from your
 * code.
 */
export interface RepairTaskUpdateInfo {
  /**
   * The new version of the repair task.
   */
  version: string;
}

/**
 * Information about which portion of the file to upload.
 */
export interface UploadChunkRange {
  /**
   * The start position of the portion of the file. It's represented by the number of bytes.
   */
  startPosition?: string;
  /**
   * The end position of the portion of the file. It's represented by the number of bytes.
   */
  endPosition?: string;
}

/**
 * Information about an image store upload session. A session is associated with a relative path in
 * the image store.
 */
export interface UploadSessionInfo {
  /**
   * The remote location within image store. This path is relative to the image store root.
   */
  storeRelativePath?: string;
  /**
   * A unique ID of the upload session. A session ID can be reused only if the session was
   * committed or removed.
   */
  sessionId?: string;
  /**
   * The date and time when the upload session was last modified.
   */
  modifiedDate?: Date;
  /**
   * The size in bytes of the uploading file.
   */
  fileSize?: string;
  /**
   * List of chunk ranges that image store has not received yet.
   */
  expectedRanges?: UploadChunkRange[];
}

/**
 * Information about a image store upload session
 */
export interface UploadSession {
  /**
   * When querying upload session by upload session ID, the result contains only one upload
   * session. When querying upload session by image store relative path, the result might contain
   * multiple upload sessions.
   */
  uploadSessions?: UploadSessionInfo[];
}

/**
 * Represents a scaling trigger related to an average load of a metric/resource of a partition.
 */
export interface AveragePartitionLoadScalingTrigger {
  /**
   * Polymorphic Discriminator
   */
  kind: "AveragePartitionLoad";
  /**
   * The name of the metric for which usage should be tracked.
   */
  metricName: string;
  /**
   * The lower limit of the load below which a scale in operation should be performed.
   */
  lowerLoadThreshold: string;
  /**
   * The upper limit of the load beyond which a scale out operation should be performed.
   */
  upperLoadThreshold: string;
  /**
   * The period in seconds on which a decision is made whether to scale or not.
   */
  scaleIntervalInSeconds: number;
}

/**
 * Represents a scaling policy related to an average load of a metric/resource of a service.
 */
export interface AverageServiceLoadScalingTrigger {
  /**
   * Polymorphic Discriminator
   */
  kind: "AverageServiceLoad";
  /**
   * The name of the metric for which usage should be tracked.
   */
  metricName: string;
  /**
   * The lower limit of the load below which a scale in operation should be performed.
   */
  lowerLoadThreshold: string;
  /**
   * The upper limit of the load beyond which a scale out operation should be performed.
   */
  upperLoadThreshold: string;
  /**
   * The period in seconds on which a decision is made whether to scale or not.
   */
  scaleIntervalInSeconds: number;
}

/**
 * Represents a scaling mechanism for adding or removing instances of stateless service partition.
 */
export interface PartitionInstanceCountScaleMechanism {
  /**
   * Polymorphic Discriminator
   */
  kind: "PartitionInstanceCount";
  /**
   * Minimum number of instances of the partition.
   */
  minInstanceCount: number;
  /**
   * Maximum number of instances of the partition.
   */
  maxInstanceCount: number;
  /**
   * The number of instances to add or remove during a scaling operation.
   */
  scaleIncrement: number;
}

/**
 * Represents a scaling mechanism for adding or removing named partitions of a stateless service.
 * Partition names are in the format '0','1''N-1'
 */
export interface AddRemoveIncrementalNamedPartitionScalingMechanism {
  /**
   * Polymorphic Discriminator
   */
  kind: "AddRemoveIncrementalNamedPartition";
  /**
   * Minimum number of named partitions of the service.
   */
  minPartitionCount: number;
  /**
   * Maximum number of named partitions of the service.
   */
  maxPartitionCount: number;
  /**
   * The number of instances to add or remove during a scaling operation.
   */
  scaleIncrement: number;
}

/**
 * Contains information for an unplaced replica.
 */
export interface UnplacedReplicaInformation {
  /**
   * The name of the service.
   */
  serviceName?: string;
  /**
   * The ID of the partition.
   */
  partitionId?: string;
  /**
   * List of reasons due to which a replica cannot be placed.
   */
  unplacedReplicaDetails?: string[];
}

/**
 * Application Created event.
 */
export interface ApplicationCreatedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationCreated";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Application type version.
   */
  applicationTypeVersion: string;
  /**
   * Application definition kind.
   */
  applicationDefinitionKind: string;
}

/**
 * Application Deleted event.
 */
export interface ApplicationDeletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationDeleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Application type version.
   */
  applicationTypeVersion: string;
}

/**
 * Application Health Report Created event.
 */
export interface ApplicationNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Id of Application instance.
   */
  applicationInstanceId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Application Health Report Expired event.
 */
export interface ApplicationHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Id of Application instance.
   */
  applicationInstanceId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Application Upgrade Completed event.
 */
export interface ApplicationUpgradeCompletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeCompleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Application type version.
   */
  applicationTypeVersion: string;
  /**
   * Overall upgrade time in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * Application Upgrade Domain Completed event.
 */
export interface ApplicationUpgradeDomainCompletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeDomainCompleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Current Application type version.
   */
  currentApplicationTypeVersion: string;
  /**
   * Target Application type version.
   */
  applicationTypeVersion: string;
  /**
   * State of upgrade.
   */
  upgradeState: string;
  /**
   * Upgrade domains.
   */
  upgradeDomains: string;
  /**
   * Upgrade time of domain in milli-seconds.
   */
  upgradeDomainElapsedTimeInMs: number;
}

/**
 * Application Upgrade Rollback Completed event.
 */
export interface ApplicationUpgradeRollbackCompletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeRollbackCompleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Application type version.
   */
  applicationTypeVersion: string;
  /**
   * Describes reason of failure.
   */
  failureReason: string;
  /**
   * Overall upgrade time in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * Application Upgrade Rollback Started event.
 */
export interface ApplicationUpgradeRollbackStartedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeRollbackStarted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Current Application type version.
   */
  currentApplicationTypeVersion: string;
  /**
   * Target Application type version.
   */
  applicationTypeVersion: string;
  /**
   * Describes reason of failure.
   */
  failureReason: string;
  /**
   * Overall upgrade time in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * Application Upgrade Started event.
 */
export interface ApplicationUpgradeStartedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationUpgradeStarted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Current Application type version.
   */
  currentApplicationTypeVersion: string;
  /**
   * Target Application type version.
   */
  applicationTypeVersion: string;
  /**
   * Type of upgrade.
   */
  upgradeType: string;
  /**
   * Mode of upgrade.
   */
  rollingUpgradeMode: string;
  /**
   * Action if failed.
   */
  failureAction: string;
}

/**
 * Deployed Application Health Report Created event.
 */
export interface DeployedApplicationNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeployedApplicationNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Id of Application instance.
   */
  applicationInstanceId: number;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Deployed Application Health Report Expired event.
 */
export interface DeployedApplicationHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeployedApplicationHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Id of Application instance.
   */
  applicationInstanceId: number;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Process Exited event.
 */
export interface ApplicationProcessExitedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationProcessExited";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Name of Service.
   */
  serviceName: string;
  /**
   * Name of Service package.
   */
  servicePackageName: string;
  /**
   * Activation Id of Service package.
   */
  servicePackageActivationId: string;
  /**
   * Indicates IsExclusive flag.
   */
  isExclusive: boolean;
  /**
   * Name of Code package.
   */
  codePackageName: string;
  /**
   * Type of EntryPoint.
   */
  entryPointType: string;
  /**
   * Name of executable.
   */
  exeName: string;
  /**
   * Process Id.
   */
  processId: number;
  /**
   * Host Id.
   */
  hostId: string;
  /**
   * Exit code of process.
   */
  exitCode: number;
  /**
   * Indicates if termination is unexpected.
   */
  unexpectedTermination: boolean;
  /**
   * Start time of process.
   */
  startTime: Date;
}

/**
 * Container Exited event.
 */
export interface ApplicationContainerInstanceExitedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationContainerInstanceExited";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Name of Service.
   */
  serviceName: string;
  /**
   * Name of Service package.
   */
  servicePackageName: string;
  /**
   * Activation Id of Service package.
   */
  servicePackageActivationId: string;
  /**
   * Indicates IsExclusive flag.
   */
  isExclusive: boolean;
  /**
   * Name of Code package.
   */
  codePackageName: string;
  /**
   * Type of EntryPoint.
   */
  entryPointType: string;
  /**
   * Name of Container image.
   */
  imageName: string;
  /**
   * Name of Container.
   */
  containerName: string;
  /**
   * Host Id.
   */
  hostId: string;
  /**
   * Exit code of process.
   */
  exitCode: number;
  /**
   * Indicates if termination is unexpected.
   */
  unexpectedTermination: boolean;
  /**
   * Start time of process.
   */
  startTime: Date;
}

/**
 * Node Aborted event.
 */
export interface NodeAbortedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeAborted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Id of Node.
   */
  nodeId: string;
  /**
   * Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * Fault domain of Node.
   */
  faultDomain: string;
  /**
   * IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * Name of Host.
   */
  hostname: string;
  /**
   * Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * Version of Node.
   */
  nodeVersion: string;
}

/**
 * Node Added event.
 */
export interface NodeAddedToClusterEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeAddedToCluster";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node.
   */
  nodeId: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Type of Node.
   */
  nodeType: string;
  /**
   * Fabric version.
   */
  fabricVersion: string;
  /**
   * IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * Capacities.
   */
  nodeCapacities: string;
}

/**
 * Node Closed event.
 */
export interface NodeClosedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeClosed";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node.
   */
  nodeId: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Describes error.
   */
  error: string;
}

/**
 * Node Deactivate Completed event.
 */
export interface NodeDeactivateCompletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeDeactivateCompleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Describes deactivate intent.
   */
  effectiveDeactivateIntent: string;
  /**
   * Batch Ids.
   */
  batchIdsWithDeactivateIntent: string;
  /**
   * Start time.
   */
  startTime: Date;
}

/**
 * Node Deactivate Started event.
 */
export interface NodeDeactivateStartedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeDeactivateStarted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Batch Id.
   */
  batchId: string;
  /**
   * Describes deactivate intent.
   */
  deactivateIntent: string;
}

/**
 * Node Down event.
 */
export interface NodeDownEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeDown";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Time when Node was last up.
   */
  lastNodeUpAt: Date;
}

/**
 * Node Health Report Created event.
 */
export interface NodeNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstanceId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Node Health Report Expired event.
 */
export interface NodeHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstanceId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Node Opened Succeeded event.
 */
export interface NodeOpenSucceededEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeOpenSucceeded";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Id of Node.
   */
  nodeId: string;
  /**
   * Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * Fault domain of Node.
   */
  faultDomain: string;
  /**
   * IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * Name of Host.
   */
  hostname: string;
  /**
   * Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * Version of Node.
   */
  nodeVersion: string;
}

/**
 * Node Open Failed event.
 */
export interface NodeOpenFailedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeOpenFailed";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Id of Node.
   */
  nodeId: string;
  /**
   * Upgrade domain of Node.
   */
  upgradeDomain: string;
  /**
   * Fault domain of Node.
   */
  faultDomain: string;
  /**
   * IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * Name of Host.
   */
  hostname: string;
  /**
   * Indicates if it is seed node.
   */
  isSeedNode: boolean;
  /**
   * Version of Node.
   */
  nodeVersion: string;
  /**
   * Describes the error.
   */
  error: string;
}

/**
 * Node Removed event.
 */
export interface NodeRemovedFromClusterEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeRemovedFromCluster";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node.
   */
  nodeId: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Type of Node.
   */
  nodeType: string;
  /**
   * Fabric version.
   */
  fabricVersion: string;
  /**
   * IP address or FQDN.
   */
  ipAddressOrFQDN: string;
  /**
   * Capacities.
   */
  nodeCapacities: string;
}

/**
 * Node Up event.
 */
export interface NodeUpEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "NodeUp";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstance: number;
  /**
   * Time when Node was last down.
   */
  lastNodeDownAt: Date;
}

/**
 * Partition Health Report Created event.
 */
export interface PartitionNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "PartitionNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Partition Health Report Expired event.
 */
export interface PartitionHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "PartitionHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Partition Reconfiguration event.
 */
export interface PartitionReconfiguredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "PartitionReconfigured";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstanceId: string;
  /**
   * Type of Service.
   */
  serviceType: string;
  /**
   * CcEpochDataLoss version.
   */
  ccEpochDataLossVersion: number;
  /**
   * CcEpochConfig version.
   */
  ccEpochConfigVersion: number;
  /**
   * Type of reconfiguration.
   */
  reconfigType: string;
  /**
   * Describes reconfiguration result.
   */
  result: string;
  /**
   * Duration of Phase0 in milli-seconds.
   */
  phase0DurationMs: number;
  /**
   * Duration of Phase1 in milli-seconds.
   */
  phase1DurationMs: number;
  /**
   * Duration of Phase2 in milli-seconds.
   */
  phase2DurationMs: number;
  /**
   * Duration of Phase3 in milli-seconds.
   */
  phase3DurationMs: number;
  /**
   * Duration of Phase4 in milli-seconds.
   */
  phase4DurationMs: number;
  /**
   * Total duration in milli-seconds.
   */
  totalDurationMs: number;
}

/**
 * Partition Primary Move Analysis event.
 */
export interface PartitionPrimaryMoveAnalysisEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "PartitionPrimaryMoveAnalysis";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Metadata about an Analysis Event.
   */
  metadata: AnalysisEventMetadata;
  /**
   * Time when the move was completed.
   */
  whenMoveCompleted: Date;
  /**
   * The name of a Service Fabric node.
   */
  previousNode: string;
  /**
   * The name of a Service Fabric node.
   */
  currentNode: string;
  /**
   * Move reason.
   */
  moveReason: string;
  /**
   * Relevant traces.
   */
  relevantTraces: string;
}

/**
 * Service Created event.
 */
export interface ServiceCreatedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ServiceCreated";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  serviceId: string;
  /**
   * Service type name.
   */
  serviceTypeName: string;
  /**
   * Application name.
   */
  applicationName: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Id of Service instance.
   */
  serviceInstance: number;
  /**
   * Indicates if Service is stateful.
   */
  isStateful: boolean;
  /**
   * Number of partitions.
   */
  partitionCount: number;
  /**
   * Size of target replicas set.
   */
  targetReplicaSetSize: number;
  /**
   * Minimum size of replicas set.
   */
  minReplicaSetSize: number;
  /**
   * Version of Service package.
   */
  servicePackageVersion: string;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
}

/**
 * Service Deleted event.
 */
export interface ServiceDeletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ServiceDeleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  serviceId: string;
  /**
   * Service type name.
   */
  serviceTypeName: string;
  /**
   * Application name.
   */
  applicationName: string;
  /**
   * Application type name.
   */
  applicationTypeName: string;
  /**
   * Id of Service instance.
   */
  serviceInstance: number;
  /**
   * Indicates if Service is stateful.
   */
  isStateful: boolean;
  /**
   * Number of partitions.
   */
  partitionCount: number;
  /**
   * Size of target replicas set.
   */
  targetReplicaSetSize: number;
  /**
   * Minimum size of replicas set.
   */
  minReplicaSetSize: number;
  /**
   * Version of Service package.
   */
  servicePackageVersion: string;
}

/**
 * Service Health Report Created event.
 */
export interface ServiceNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ServiceNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  serviceId: string;
  /**
   * Id of Service instance.
   */
  instanceId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Service Health Report Expired event.
 */
export interface ServiceHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ServiceHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the service. This ID is an encoded representation of the service name. This is
   * used in the REST APIs to identify the service resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the service name is "fabric:/myapp/app1/svc1",
   * the service identity would be "myapp~app1\~svc1" in 6.0+ and "myapp/app1/svc1" in previous
   * versions.
   */
  serviceId: string;
  /**
   * Id of Service instance.
   */
  instanceId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Deployed Service Health Report Created event.
 */
export interface DeployedServicePackageNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeployedServicePackageNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Service manifest name.
   */
  serviceManifestName: string;
  /**
   * Id of Service package instance.
   */
  servicePackageInstanceId: number;
  /**
   * Id of Service package activation.
   */
  servicePackageActivationId: string;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Deployed Service Health Report Expired event.
 */
export interface DeployedServicePackageHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "DeployedServicePackageHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Service manifest name.
   */
  serviceManifest: string;
  /**
   * Id of Service package instance.
   */
  servicePackageInstanceId: number;
  /**
   * Id of Service package activation.
   */
  servicePackageActivationId: string;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Stateful Replica Health Report Created event.
 */
export interface StatefulReplicaNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "StatefulReplicaNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId: number;
  /**
   * Id of Replica instance.
   */
  replicaInstanceId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Stateful Replica Health Report Expired event.
 */
export interface StatefulReplicaHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "StatefulReplicaHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId: number;
  /**
   * Id of Replica instance.
   */
  replicaInstanceId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Stateless Replica Health Report Created event.
 */
export interface StatelessReplicaNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "StatelessReplicaNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Stateless Replica Health Report Expired event.
 */
export interface StatelessReplicaHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "StatelessReplicaHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId: number;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Cluster Health Report Created event.
 */
export interface ClusterNewHealthReportEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ClusterNewHealthReport";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Cluster Health Report Expired event.
 */
export interface ClusterHealthReportExpiredEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ClusterHealthReportExpired";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Id of report source.
   */
  sourceId: string;
  /**
   * Describes the property.
   */
  property: string;
  /**
   * Describes the property health state.
   */
  healthState: string;
  /**
   * Time to live in milli-seconds.
   */
  timeToLiveMs: number;
  /**
   * Sequence number of report.
   */
  sequenceNumber: number;
  /**
   * Description of report.
   */
  description: string;
  /**
   * Indicates the removal when it expires.
   */
  removeWhenExpired: boolean;
  /**
   * Source time.
   */
  sourceUtcTimestamp: Date;
}

/**
 * Cluster Upgrade Completed event.
 */
export interface ClusterUpgradeCompletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ClusterUpgradeCompleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * Overall duration of upgrade in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * Cluster Upgrade Domain Completed event.
 */
export interface ClusterUpgradeDomainCompletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ClusterUpgradeDomainCompleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * State of upgrade.
   */
  upgradeState: string;
  /**
   * Upgrade domains.
   */
  upgradeDomains: string;
  /**
   * Duration of domain upgrade in milli-seconds.
   */
  upgradeDomainElapsedTimeInMs: number;
}

/**
 * Cluster Upgrade Rollback Completed event.
 */
export interface ClusterUpgradeRollbackCompletedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ClusterUpgradeRollbackCompleted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * Describes failure.
   */
  failureReason: string;
  /**
   * Overall duration of upgrade in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * Cluster Upgrade Rollback Started event.
 */
export interface ClusterUpgradeRollbackStartedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ClusterUpgradeRollbackStarted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * Describes failure.
   */
  failureReason: string;
  /**
   * Overall duration of upgrade in milli-seconds.
   */
  overallUpgradeElapsedTimeInMs: number;
}

/**
 * Cluster Upgrade Started event.
 */
export interface ClusterUpgradeStartedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ClusterUpgradeStarted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Current Cluster version.
   */
  currentClusterVersion: string;
  /**
   * Target Cluster version.
   */
  targetClusterVersion: string;
  /**
   * Type of upgrade.
   */
  upgradeType: string;
  /**
   * Mode of upgrade.
   */
  rollingUpgradeMode: string;
  /**
   * Action if failed.
   */
  failureAction: string;
}

/**
 * Chaos Stopped event.
 */
export interface ChaosStoppedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosStopped";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Describes reason.
   */
  reason: string;
}

/**
 * Chaos Started event.
 */
export interface ChaosStartedEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosStarted";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * Maximum number of concurrent faults.
   */
  maxConcurrentFaults: number;
  /**
   * Time to run in seconds.
   */
  timeToRunInSeconds: number;
  /**
   * Maximum timeout for cluster stabilization in seconds.
   */
  maxClusterStabilizationTimeoutInSeconds: number;
  /**
   * Wait time between iterations in seconds.
   */
  waitTimeBetweenIterationsInSeconds: number;
  /**
   * Wait time between faults in seconds.
   */
  waitTimeBetweenFaultsInSeconds: number;
  /**
   * Indicates MoveReplica fault is enabled.
   */
  moveReplicaFaultEnabled: boolean;
  /**
   * List of included Node types.
   */
  includedNodeTypeList: string;
  /**
   * List of included Applications.
   */
  includedApplicationList: string;
  /**
   * Health policy.
   */
  clusterHealthPolicy: string;
  /**
   * Chaos Context.
   */
  chaosContext: string;
}

/**
 * Chaos Restart Code Package Fault Scheduled event.
 */
export interface ChaosCodePackageRestartScheduledEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosCodePackageRestartScheduled";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The identity of the application. This is an encoded representation of the application name.
   * This is used in the REST APIs to identify the application resource.
   * Starting in version 6.0, hierarchical names are delimited with the "\~" character. For
   * example, if the application name is "fabric:/myapp/app1",
   * the application identity would be "myapp\~app1" in 6.0+ and "myapp/app1" in previous versions.
   */
  applicationId: string;
  /**
   * Id of fault group.
   */
  faultGroupId: string;
  /**
   * Id of fault.
   */
  faultId: string;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Service manifest name.
   */
  serviceManifestName: string;
  /**
   * Code package name.
   */
  codePackageName: string;
  /**
   * Id of Service package activation.
   */
  servicePackageActivationId: string;
}

/**
 * Chaos Remove Replica Fault Scheduled event.
 */
export interface ChaosReplicaRemovalScheduledEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosReplicaRemovalScheduled";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId: number;
  /**
   * Id of fault group.
   */
  faultGroupId: string;
  /**
   * Id of fault.
   */
  faultId: string;
  /**
   * Service name.
   */
  serviceUri: string;
}

/**
 * Chaos Move Secondary Fault Scheduled event.
 */
export interface ChaosPartitionSecondaryMoveScheduledEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosPartitionSecondaryMoveScheduled";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of fault group.
   */
  faultGroupId: string;
  /**
   * Id of fault.
   */
  faultId: string;
  /**
   * Service name.
   */
  serviceName: string;
  /**
   * The name of a Service Fabric node.
   */
  sourceNode: string;
  /**
   * The name of a Service Fabric node.
   */
  destinationNode: string;
  /**
   * Indicates a forced move.
   */
  forcedMove: boolean;
}

/**
 * Chaos Move Primary Fault Scheduled event.
 */
export interface ChaosPartitionPrimaryMoveScheduledEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosPartitionPrimaryMoveScheduled";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of fault group.
   */
  faultGroupId: string;
  /**
   * Id of fault.
   */
  faultId: string;
  /**
   * Service name.
   */
  serviceName: string;
  /**
   * The name of a Service Fabric node.
   */
  nodeTo: string;
  /**
   * Indicates a forced move.
   */
  forcedMove: boolean;
}

/**
 * Chaos Restart Replica Fault Scheduled event.
 */
export interface ChaosReplicaRestartScheduledEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosReplicaRestartScheduled";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * An internal ID used by Service Fabric to uniquely identify a partition. This is a randomly
   * generated GUID when the service was created. The partition ID is unique and does not change
   * for the lifetime of the service. If the same service was deleted and recreated the IDs of its
   * partitions would be different.
   */
  partitionId: string;
  /**
   * Id of a stateful service replica. ReplicaId is used by Service Fabric to uniquely identify a
   * replica of a partition. It is unique within a partition and does not change for the lifetime
   * of the replica. If a replica gets dropped and another replica gets created on the same node
   * for the same partition, it will get a different value for the id. Sometimes the id of a
   * stateless service instance is also referred as a replica id.
   */
  replicaId: number;
  /**
   * Id of fault group.
   */
  faultGroupId: string;
  /**
   * Id of fault.
   */
  faultId: string;
  /**
   * Service name.
   */
  serviceUri: string;
}

/**
 * Chaos Restart Node Fault Scheduled event.
 */
export interface ChaosNodeRestartScheduledEvent {
  /**
   * Polymorphic Discriminator
   */
  kind: "ChaosNodeRestartScheduled";
  /**
   * The identifier for the FabricEvent instance.
   */
  eventInstanceId: string;
  /**
   * The category of event.
   */
  category?: string;
  /**
   * The time event was logged.
   */
  timeStamp: Date;
  /**
   * Shows there is existing related events available.
   */
  hasCorrelatedEvents?: boolean;
  /**
   * The name of a Service Fabric node.
   */
  nodeName: string;
  /**
   * Id of Node instance.
   */
  nodeInstanceId: number;
  /**
   * Id of fault group.
   */
  faultGroupId: string;
  /**
   * Id of fault.
   */
  faultId: string;
}

/**
 * Contains the possible cases for SecretResourcePropertiesBase.
 */
export type SecretResourcePropertiesBaseUnion = SecretResourcePropertiesBase | SecretResourcePropertiesUnion;

/**
 * This type describes the properties of a secret resource, including its kind.
 */
export interface SecretResourcePropertiesBase {
  /**
   * Polymorphic Discriminator
   */
  kind: "SecretResourcePropertiesBase";
}

/**
 * Contains the possible cases for SecretResourceProperties.
 */
export type SecretResourcePropertiesUnion = SecretResourceProperties | InlinedValueSecretResourceProperties;

/**
 * Describes the properties of a secret resource.
 */
export interface SecretResourceProperties {
  /**
   * Polymorphic Discriminator
   */
  kind: "SecretResourceProperties";
  /**
   * User readable description of the secret.
   */
  description?: string;
  /**
   * Status of the resource. Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the secret.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
  /**
   * The type of the content stored in the secret value. The value of this property is opaque to
   * Service Fabric. Once set, the value of this property cannot be changed.
   */
  contentType?: string;
}

/**
 * Describes the properties of a secret resource whose value is provided explicitly as plaintext.
 * The secret resource may have multiple values, each being uniquely versioned. The secret value of
 * each version is stored encrypted, and delivered as plaintext into the context of applications
 * referencing it.
 */
export interface InlinedValueSecretResourceProperties {
  /**
   * Polymorphic Discriminator
   */
  kind: "inlinedValue";
  /**
   * User readable description of the secret.
   */
  description?: string;
  /**
   * Status of the resource. Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the secret.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
  /**
   * The type of the content stored in the secret value. The value of this property is opaque to
   * Service Fabric. Once set, the value of this property cannot be changed.
   */
  contentType?: string;
}

/**
 * This type describes a secret resource.
 */
export interface SecretResourceDescription {
  /**
   * Describes the properties of a secret resource.
   */
  properties: SecretResourcePropertiesUnion;
  /**
   * Name of the Secret resource.
   */
  name: string;
}

/**
 * The list of secret resources. The list is paged when all of the results cannot fit in a single
 * message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedSecretResourceDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * One page of the list.
   */
  items?: SecretResourceDescription[];
}

/**
 * This type represents the unencrypted value of the secret.
 */
export interface SecretValue {
  /**
   * The actual value of the secret.
   */
  value?: string;
}

/**
 * This type describes properties of secret value resource.
 */
export interface SecretValueProperties {
  /**
   * The actual value of the secret.
   */
  value?: string;
}

/**
 * This type describes a value of a secret resource. The name of this resource is the version
 * identifier corresponding to this secret value.
 */
export interface SecretValueResourceDescription {
  /**
   * Version identifier of the secret value.
   */
  name: string;
  /**
   * The actual value of the secret.
   */
  value?: string;
}

/**
 * The list of values of a secret resource, paged if the number of results exceeds the limits of a
 * single message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in the previous page.
 */
export interface PagedSecretValueResourceDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * One page of the list.
   */
  items?: SecretValueResourceDescription[];
}

/**
 * This type describes a volume provided by an Azure Files file share.
 */
export interface VolumeProviderParametersAzureFile {
  /**
   * Name of the Azure storage account for the File Share.
   */
  accountName: string;
  /**
   * Access key of the Azure storage account for the File Share.
   */
  accountKey?: string;
  /**
   * Name of the Azure Files file share that provides storage for the volume.
   */
  shareName: string;
}

/**
 * Describes a reference to a volume resource.
 */
export interface VolumeReference {
  /**
   * Name of the volume being referenced.
   */
  name: string;
  /**
   * The flag indicating whether the volume is read only. Default is 'false'.
   */
  readOnly?: boolean;
  /**
   * The path within the container at which the volume should be mounted. Only valid path
   * characters are allowed.
   */
  destinationPath: string;
}

/**
 * Contains the possible cases for ApplicationScopedVolumeCreationParameters.
 */
export type ApplicationScopedVolumeCreationParametersUnion = ApplicationScopedVolumeCreationParameters | ApplicationScopedVolumeCreationParametersServiceFabricVolumeDisk;

/**
 * Describes parameters for creating application-scoped volumes.
 */
export interface ApplicationScopedVolumeCreationParameters {
  /**
   * Polymorphic Discriminator
   */
  kind: "ApplicationScopedVolumeCreationParameters";
  /**
   * User readable description of the volume.
   */
  description?: string;
}

/**
 * Describes a volume whose lifetime is scoped to the application's lifetime.
 */
export interface ApplicationScopedVolume extends VolumeReference {
  /**
   * Describes parameters for creating application-scoped volumes.
   */
  creationParameters: ApplicationScopedVolumeCreationParametersUnion;
}

/**
 * Describes parameters for creating application-scoped volumes provided by Service Fabric Volume
 * Disks
 */
export interface ApplicationScopedVolumeCreationParametersServiceFabricVolumeDisk {
  /**
   * Polymorphic Discriminator
   */
  kind: "ServiceFabricVolumeDisk";
  /**
   * User readable description of the volume.
   */
  description?: string;
  /**
   * Volume size. Possible values include: 'Small', 'Medium', 'Large'
   */
  sizeDisk: SizeTypes;
}

/**
 * This type describes a volume resource.
 */
export interface VolumeResourceDescription {
  /**
   * Name of the Volume resource.
   */
  name: string;
  /**
   * User readable description of the volume.
   */
  description?: string;
  /**
   * Status of the volume. Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the volume.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
  /**
   * This type describes a volume provided by an Azure Files file share.
   */
  azureFileParameters?: VolumeProviderParametersAzureFile;
}

/**
 * The list of volume resources. The list is paged when all of the results cannot fit in a single
 * message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedVolumeResourceDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * One page of the list.
   */
  items?: VolumeResourceDescription[];
}

/**
 * Describes a reference to a service endpoint.
 */
export interface EndpointRef {
  /**
   * Name of the endpoint.
   */
  name?: string;
}

/**
 * Describes a network reference in a service.
 */
export interface NetworkRef {
  /**
   * Name of the network
   */
  name?: string;
  /**
   * A list of endpoints that are exposed on this network.
   */
  endpointRefs?: EndpointRef[];
}

/**
 * Contains the possible cases for NetworkResourcePropertiesBase.
 */
export type NetworkResourcePropertiesBaseUnion = NetworkResourcePropertiesBase | NetworkResourcePropertiesUnion;

/**
 * This type describes the properties of a network resource, including its kind.
 */
export interface NetworkResourcePropertiesBase {
  /**
   * Polymorphic Discriminator
   */
  kind: "NetworkResourcePropertiesBase";
}

/**
 * Contains the possible cases for NetworkResourceProperties.
 */
export type NetworkResourcePropertiesUnion = NetworkResourceProperties | LocalNetworkResourceProperties;

/**
 * Describes properties of a network resource.
 */
export interface NetworkResourceProperties {
  /**
   * Polymorphic Discriminator
   */
  kind: "NetworkResourceProperties";
  /**
   * User readable description of the network.
   */
  description?: string;
  /**
   * Status of the network. Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the network.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
}

/**
 * Information about a Service Fabric container network local to a single Service Fabric cluster.
 */
export interface LocalNetworkResourceProperties {
  /**
   * Polymorphic Discriminator
   */
  kind: "Local";
  /**
   * User readable description of the network.
   */
  description?: string;
  /**
   * Status of the network. Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the network.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
  /**
   * Address space for the local container network.
   */
  networkAddressPrefix?: string;
}

/**
 * This type describes a network resource.
 */
export interface NetworkResourceDescription {
  /**
   * Name of the Network resource.
   */
  name: string;
  /**
   * Describes properties of a network resource.
   */
  properties: NetworkResourcePropertiesUnion;
}

/**
 * The list of network resources. The list is paged when all of the results cannot fit in a single
 * message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedNetworkResourceDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * One page of the list.
   */
  items?: NetworkResourceDescription[];
}

/**
 * Describes destination endpoint for routing traffic.
 */
export interface GatewayDestination {
  /**
   * Name of the service fabric Mesh application.
   */
  applicationName: string;
  /**
   * service that contains the endpoint.
   */
  serviceName: string;
  /**
   * name of the endpoint in the service.
   */
  endpointName: string;
}

/**
 * Describes the tcp configuration for external connectivity for this network.
 */
export interface TcpConfig {
  /**
   * tcp gateway config name.
   */
  name: string;
  /**
   * Specifies the port at which the service endpoint below needs to be exposed.
   */
  port: number;
  /**
   * Describes destination endpoint for routing traffic.
   */
  destination: GatewayDestination;
}

/**
 * Path to match for routing.
 */
export interface HttpRouteMatchPath {
  /**
   * Uri path to match for request.
   */
  value: string;
  /**
   * replacement string for matched part of the Uri.
   */
  rewrite?: string;
}

/**
 * Describes header information for http route matching.
 */
export interface HttpRouteMatchHeader {
  /**
   * Name of header to match in request.
   */
  name: string;
  /**
   * Value of header to match in request.
   */
  value?: string;
  /**
   * how to match header value. Possible values include: 'exact'
   */
  type?: HeaderMatchType;
}

/**
 * Describes a rule for http route matching.
 */
export interface HttpRouteMatchRule {
  /**
   * Path to match for routing.
   */
  path: HttpRouteMatchPath;
  /**
   * headers and their values to match in request.
   */
  headers?: HttpRouteMatchHeader[];
}

/**
 * Describes the hostname properties for http routing.
 */
export interface HttpRouteConfig {
  /**
   * http route name.
   */
  name: string;
  /**
   * Describes a rule for http route matching.
   */
  match: HttpRouteMatchRule;
  /**
   * Describes destination endpoint for routing traffic.
   */
  destination: GatewayDestination;
}

/**
 * Describes the hostname properties for http routing.
 */
export interface HttpHostConfig {
  /**
   * http hostname config name.
   */
  name: string;
  /**
   * Route information to use for routing. Routes are processed in the order they are specified.
   * Specify routes that are more specific before routes that can handle general cases.
   */
  routes: HttpRouteConfig[];
}

/**
 * Describes the http configuration for external connectivity for this network.
 */
export interface HttpConfig {
  /**
   * http gateway config name.
   */
  name: string;
  /**
   * Specifies the port at which the service endpoint below needs to be exposed.
   */
  port: number;
  /**
   * description for routing.
   */
  hosts: HttpHostConfig[];
}

/**
 * This type describes a gateway resource.
 */
export interface GatewayResourceDescription {
  /**
   * Name of the Gateway resource.
   */
  name: string;
  /**
   * User readable description of the gateway.
   */
  description?: string;
  /**
   * Network the gateway should listen on for requests.
   */
  sourceNetwork: NetworkRef;
  /**
   * Network that the Application is using.
   */
  destinationNetwork: NetworkRef;
  /**
   * Configuration for tcp connectivity for this gateway.
   */
  tcp?: TcpConfig[];
  /**
   * Configuration for http connectivity for this gateway.
   */
  http?: HttpConfig[];
  /**
   * Status of the resource. Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the gateway.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
  /**
   * IP address of the gateway. This is populated in the response and is ignored for incoming
   * requests.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly ipAddress?: string;
}

/**
 * The list of gateway resources. The list is paged when all of the results cannot fit in a single
 * message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedGatewayResourceDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * One page of the list.
   */
  items?: GatewayResourceDescription[];
}

/**
 * Image registry credential.
 */
export interface ImageRegistryCredential {
  /**
   * Docker image registry server, without protocol such as `http` and `https`.
   */
  server: string;
  /**
   * The username for the private registry.
   */
  username: string;
  /**
   * The type of the image registry password being given in password. Possible values include:
   * 'ClearText', 'KeyVaultReference', 'SecretValueReference'. Default value: 'ClearText'.
   */
  passwordType?: ImageRegistryPasswordType;
  /**
   * The password for the private registry. The password is required for create or update
   * operations, however it is not returned in the get or list operations. Will be processed based
   * on the type provided.
   */
  password?: string;
}

/**
 * Describes an environment variable for the container.
 */
export interface EnvironmentVariable {
  /**
   * The type of the environment variable being given in value. Possible values include:
   * 'ClearText', 'KeyVaultReference', 'SecretValueReference'. Default value: 'ClearText'.
   */
  type?: EnvironmentVariableType;
  /**
   * The name of the environment variable.
   */
  name?: string;
  /**
   * The value of the environment variable, will be processed based on the type provided.
   */
  value?: string;
}

/**
 * Describes a setting for the container. The setting file path can be fetched from environment
 * variable "Fabric_SettingPath". The path for Windows container is "C:\\secrets". The path for
 * Linux container is "/var/secrets".
 */
export interface Setting {
  /**
   * The type of the setting being given in value. Possible values include: 'ClearText',
   * 'KeyVaultReference', 'SecretValueReference'. Default value: 'ClearText'.
   */
  type?: SettingType;
  /**
   * The name of the setting.
   */
  name?: string;
  /**
   * The value of the setting, will be processed based on the type provided.
   */
  value?: string;
}

/**
 * Describes a container label.
 */
export interface ContainerLabel {
  /**
   * The name of the container label.
   */
  name: string;
  /**
   * The value of the container label.
   */
  value: string;
}

/**
 * Describes a container endpoint.
 */
export interface EndpointProperties {
  /**
   * The name of the endpoint.
   */
  name: string;
  /**
   * Port used by the container.
   */
  port?: number;
}

/**
 * This type describes the requested resources for a given container. It describes the least amount
 * of resources required for the container. A container can consume more than requested resources
 * up to the specified limits before being restarted. Currently, the requested resources are
 * treated as limits.
 */
export interface ResourceRequests {
  /**
   * The memory request in GB for this container.
   */
  memoryInGB: number;
  /**
   * Requested number of CPU cores. At present, only full cores are supported.
   */
  cpu: number;
}

/**
 * This type describes the resource limits for a given container. It describes the most amount of
 * resources a container is allowed to use before being restarted.
 */
export interface ResourceLimits {
  /**
   * The memory limit in GB.
   */
  memoryInGB?: number;
  /**
   * CPU limits in cores. At present, only full cores are supported.
   */
  cpu?: number;
}

/**
 * This type describes the resource requirements for a container or a service.
 */
export interface ResourceRequirements {
  /**
   * Describes the requested resources for a given container.
   */
  requests: ResourceRequests;
  /**
   * Describes the maximum limits on the resources for a given container.
   */
  limits?: ResourceLimits;
}

/**
 * Reference to sinks in DiagnosticsDescription.
 */
export interface DiagnosticsRef {
  /**
   * Status of whether or not sinks are enabled.
   */
  enabled?: boolean;
  /**
   * List of sinks to be used if enabled. References the list of sinks in DiagnosticsDescription.
   */
  sinkRefs?: string[];
}

/**
 * Specifying this parameter adds support for reliable collections
 */
export interface ReliableCollectionsRef {
  /**
   * Name of ReliableCollection resource. Right now it's not used and you can use any string.
   */
  name: string;
  /**
   * False (the default) if ReliableCollections state is persisted to disk as usual. True if you do
   * not want to persist state, in which case replication is still enabled and you can use
   * ReliableCollections as distributed cache.
   */
  doNotPersistState?: boolean;
}

/**
 * The container state.
 */
export interface ContainerState {
  /**
   * The state of this container
   */
  state?: string;
  /**
   * Date/time when the container state started.
   */
  startTime?: Date;
  /**
   * The container exit code.
   */
  exitCode?: string;
  /**
   * Date/time when the container state finished.
   */
  finishTime?: Date;
  /**
   * Human-readable status of this state.
   */
  detailStatus?: string;
}

/**
 * A container event.
 */
export interface ContainerEvent {
  /**
   * The name of the container event.
   */
  name?: string;
  /**
   * The count of the event.
   */
  count?: number;
  /**
   * Date/time of the first event.
   */
  firstTimestamp?: string;
  /**
   * Date/time of the last event.
   */
  lastTimestamp?: string;
  /**
   * The event message
   */
  message?: string;
  /**
   * The event type.
   */
  type?: string;
}

/**
 * Runtime information of a container instance.
 */
export interface ContainerInstanceView {
  /**
   * The number of times the container has been restarted.
   */
  restartCount?: number;
  /**
   * Current container instance state.
   */
  currentState?: ContainerState;
  /**
   * Previous container instance state.
   */
  previousState?: ContainerState;
  /**
   * The events of this container instance.
   */
  events?: ContainerEvent[];
}

/**
 * Exec command to run inside the container.
 */
export interface ProbeExec {
  /**
   * Comma separated command to run inside the container for example "sh, -c, echo hello world".
   */
  command: string;
}

/**
 * Http headers.
 */
export interface ProbeHttpGetHeaders {
  /**
   * The name of the header.
   */
  name: string;
  /**
   * The value of the header.
   */
  value: string;
}

/**
 * Http probe for the container.
 */
export interface ProbeHttpGet {
  /**
   * Port to access for probe.
   */
  port: number;
  /**
   * Path to access on the HTTP request.
   */
  path?: string;
  /**
   * Host IP to connect to.
   */
  host?: string;
  /**
   * Headers to set in the request.
   */
  httpHeaders?: ProbeHttpGetHeaders[];
  /**
   * Scheme for the http probe. Can be Http or Https. Possible values include: 'http', 'https'
   */
  scheme?: Scheme;
}

/**
 * Tcp port to probe inside the container.
 */
export interface ProbeTcpSocket {
  /**
   * Port to access for probe.
   */
  port: number;
}

/**
 * Probes have a number of fields that you can use to control their behavior.
 */
export interface Probe {
  /**
   * The initial delay in seconds to start executing probe once codepackage has started. Default
   * value: 0.
   */
  initialDelaySeconds?: number;
  /**
   * Periodic seconds to execute probe. Default value: 10.
   */
  periodSeconds?: number;
  /**
   * Period after which probe is considered as failed if it hasn't completed successfully. Default
   * value: 1.
   */
  timeoutSeconds?: number;
  /**
   * The count of successful probe executions after which probe is considered success. Default
   * value: 1.
   */
  successThreshold?: number;
  /**
   * The count of failures after which probe is considered failed. Default value: 3.
   */
  failureThreshold?: number;
  /**
   * Exec command to run inside the container.
   */
  exec?: ProbeExec;
  /**
   * Http probe for the container.
   */
  httpGet?: ProbeHttpGet;
  /**
   * Tcp port to probe inside the container.
   */
  tcpSocket?: ProbeTcpSocket;
}

/**
 * Describes a container and its runtime properties.
 */
export interface ContainerCodePackageProperties {
  /**
   * The name of the code package.
   */
  name: string;
  /**
   * The Container image to use.
   */
  image: string;
  /**
   * Image registry credential.
   */
  imageRegistryCredential?: ImageRegistryCredential;
  /**
   * Override for the default entry point in the container.
   */
  entryPoint?: string;
  /**
   * Command array to execute within the container in exec form.
   */
  commands?: string[];
  /**
   * The environment variables to set in this container
   */
  environmentVariables?: EnvironmentVariable[];
  /**
   * The settings to set in this container. The setting file path can be fetched from environment
   * variable "Fabric_SettingPath". The path for Windows container is "C:\\secrets". The path for
   * Linux container is "/var/secrets".
   */
  settings?: Setting[];
  /**
   * The labels to set in this container.
   */
  labels?: ContainerLabel[];
  /**
   * The endpoints exposed by this container.
   */
  endpoints?: EndpointProperties[];
  /**
   * The resources required by this container.
   */
  resources: ResourceRequirements;
  /**
   * Volumes to be attached to the container. The lifetime of these volumes is independent of the
   * application's lifetime.
   */
  volumeRefs?: VolumeReference[];
  /**
   * Volumes to be attached to the container. The lifetime of these volumes is scoped to the
   * application's lifetime.
   */
  volumes?: ApplicationScopedVolume[];
  /**
   * Reference to sinks in DiagnosticsDescription.
   */
  diagnostics?: DiagnosticsRef;
  /**
   * A list of ReliableCollection resources used by this particular code package. Please refer to
   * ReliableCollectionsRef for more details.
   */
  reliableCollectionsRefs?: ReliableCollectionsRef[];
  /**
   * Runtime information of a container instance.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly instanceView?: ContainerInstanceView;
  /**
   * An array of liveness probes for a code package. It determines when to restart a code package.
   */
  livenessProbe?: Probe[];
  /**
   * An array of readiness probes for a code package. It determines when to unpublish an endpoint.
   */
  readinessProbe?: Probe[];
}

/**
 * Contains the possible cases for ExecutionPolicy.
 */
export type ExecutionPolicyUnion = ExecutionPolicy | DefaultExecutionPolicy | RunToCompletionExecutionPolicy;

/**
 * The execution policy of the service
 */
export interface ExecutionPolicy {
  /**
   * Polymorphic Discriminator
   */
  type: "ExecutionPolicy";
}

/**
 * Contains the possible cases for AutoScalingTrigger.
 */
export type AutoScalingTriggerUnion = AutoScalingTrigger | AverageLoadScalingTrigger;

/**
 * Describes the trigger for performing auto scaling operation.
 */
export interface AutoScalingTrigger {
  /**
   * Polymorphic Discriminator
   */
  kind: "AutoScalingTrigger";
}

/**
 * Contains the possible cases for AutoScalingMechanism.
 */
export type AutoScalingMechanismUnion = AutoScalingMechanism | AddRemoveReplicaScalingMechanism;

/**
 * Describes the mechanism for performing auto scaling operation. Derived classes will describe the
 * actual mechanism.
 */
export interface AutoScalingMechanism {
  /**
   * Polymorphic Discriminator
   */
  kind: "AutoScalingMechanism";
}

/**
 * Describes the auto scaling policy
 */
export interface AutoScalingPolicy {
  /**
   * The name of the auto scaling policy.
   */
  name: string;
  /**
   * Determines when auto scaling operation will be invoked.
   */
  trigger: AutoScalingTriggerUnion;
  /**
   * The mechanism that is used to scale when auto scaling operation is invoked.
   */
  mechanism: AutoScalingMechanismUnion;
}

/**
 * Map service identity friendly name to an application identity.
 */
export interface ServiceIdentity {
  /**
   * The identity friendly name.
   */
  name?: string;
  /**
   * The application identity name.
   */
  identityRef?: string;
}

/**
 * This type describes a service resource.
 */
export interface ServiceResourceDescription {
  /**
   * Name of the Service resource.
   */
  name: string;
  /**
   * The operation system required by the code in service. Possible values include: 'Linux',
   * 'Windows'
   */
  osType: OperatingSystemType;
  /**
   * Describes the set of code packages that forms the service. A code package describes the
   * container and the properties for running it. All the code packages are started together on the
   * same host and share the same context (network, process etc.).
   */
  codePackages: ContainerCodePackageProperties[];
  /**
   * The names of the private networks that this service needs to be part of.
   */
  networkRefs?: NetworkRef[];
  /**
   * Reference to sinks in DiagnosticsDescription.
   */
  diagnostics?: DiagnosticsRef;
  /**
   * User readable description of the service.
   */
  description?: string;
  /**
   * The number of replicas of the service to create. Defaults to 1 if not specified.
   */
  replicaCount?: number;
  /**
   * The execution policy of the service
   */
  executionPolicy?: ExecutionPolicyUnion;
  /**
   * Auto scaling policies
   */
  autoScalingPolicies?: AutoScalingPolicy[];
  /**
   * Status of the service. Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the service.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
  /**
   * Describes the health state of an application resource. Possible values include: 'Invalid',
   * 'Ok', 'Warning', 'Error', 'Unknown'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly healthState?: HealthState;
  /**
   * When the service's health state is not 'Ok', this additional details from service fabric
   * Health Manager for the user to know why the service is marked unhealthy.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly unhealthyEvaluation?: string;
  /**
   * The service identity list.
   */
  identityRefs?: ServiceIdentity[];
  /**
   * Dns name of the service.
   */
  dnsName?: string;
}

/**
 * Contains the possible cases for DiagnosticsSinkProperties.
 */
export type DiagnosticsSinkPropertiesUnion = DiagnosticsSinkProperties | AzureInternalMonitoringPipelineSinkDescription;

/**
 * Properties of a DiagnosticsSink.
 */
export interface DiagnosticsSinkProperties {
  /**
   * Polymorphic Discriminator
   */
  kind: "DiagnosticsSinkProperties";
  /**
   * Name of the sink. This value is referenced by DiagnosticsReferenceDescription
   */
  name?: string;
  /**
   * A description of the sink.
   */
  description?: string;
}

/**
 * Describes the diagnostics options available
 */
export interface DiagnosticsDescription {
  /**
   * List of supported sinks that can be referenced.
   */
  sinks?: DiagnosticsSinkPropertiesUnion[];
  /**
   * Status of whether or not sinks are enabled.
   */
  enabled?: boolean;
  /**
   * The sinks to be used if diagnostics is enabled. Sink choices can be overridden at the service
   * and code package level.
   */
  defaultSinkRefs?: string[];
}

/**
 * Information about how many replicas are completed or pending for a specific service during
 * upgrade.
 */
export interface ServiceUpgradeProgress {
  /**
   * Name of the Service resource.
   */
  serviceName?: string;
  /**
   * The number of replicas that completes the upgrade in the service.
   */
  completedReplicaCount?: string;
  /**
   * The number of replicas that are waiting to be upgraded in the service.
   */
  pendingReplicaCount?: string;
}

/**
 * This type describes an application resource upgrade.
 */
export interface ApplicationResourceUpgradeProgressInfo {
  /**
   * Name of the Application resource.
   */
  name?: string;
  /**
   * The target application version for the application upgrade.
   */
  targetApplicationTypeVersion?: string;
  /**
   * The estimated UTC datetime when the upgrade started.
   */
  startTimestampUtc?: string;
  /**
   * The state of the application resource upgrade. Possible values include: 'Invalid',
   * 'ProvisioningTarget', 'RollingForward', 'UnprovisioningCurrent', 'CompletedRollforward',
   * 'RollingBack', 'UnprovisioningTarget', 'CompletedRollback', 'Failed'
   */
  upgradeState?: ApplicationResourceUpgradeState;
  /**
   * The estimated percent of replicas are completed in the upgrade.
   */
  percentCompleted?: string;
  /**
   * List of service upgrade progresses.
   */
  serviceUpgradeProgress?: ServiceUpgradeProgress[];
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'Monitored'.
   */
  rollingUpgradeMode?: RollingUpgradeMode;
  /**
   * The estimated amount of time that the overall upgrade elapsed. It is first interpreted as a
   * string representing an ISO 8601 duration. If that fails, then it is interpreted as a number
   * representing the total number of milliseconds. Default value: 'PT0H2M0S'.
   */
  upgradeDuration?: string;
  /**
   * Additional detailed information about the status of the pending upgrade.
   */
  applicationUpgradeStatusDetails?: string;
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer). Default value: 42949672925.
   */
  upgradeReplicaSetCheckTimeoutInSeconds?: number;
  /**
   * The estimated UTC datetime when the upgrade failed and FailureAction was executed.
   */
  failureTimestampUtc?: string;
}

/**
 * Diagnostics settings for Geneva.
 */
export interface AzureInternalMonitoringPipelineSinkDescription {
  /**
   * Polymorphic Discriminator
   */
  kind: "AzureInternalMonitoringPipeline";
  /**
   * Name of the sink. This value is referenced by DiagnosticsReferenceDescription
   */
  name?: string;
  /**
   * A description of the sink.
   */
  description?: string;
  /**
   * Azure Internal monitoring pipeline account.
   */
  accountName?: string;
  /**
   * Azure Internal monitoring pipeline account namespace.
   */
  namespace?: string;
  /**
   * Azure Internal monitoring agent configuration.
   */
  maConfigUrl?: string;
  /**
   * Azure Internal monitoring agent fluentd configuration.
   */
  fluentdConfigUrl?: string;
  /**
   * Azure Internal monitoring pipeline autokey associated with the certificate.
   */
  autoKeyConfigUrl?: string;
}

/**
 * Describes a single user-assigned identity associated with the application.
 */
export interface IdentityItemDescription {
  /**
   * the object identifier of the Service Principal which this identity represents.
   */
  principalId?: string;
  /**
   * the client identifier of the Service Principal which this identity represents.
   */
  clientId?: string;
}

/**
 * Information describing the identities associated with this application.
 */
export interface IdentityDescription {
  /**
   * the endpoint for the token service managing this identity
   */
  tokenServiceEndpoint?: string;
  /**
   * the types of identities associated with this resource; currently restricted to 'SystemAssigned
   * and UserAssigned'
   */
  type: string;
  /**
   * the identifier of the tenant containing the application's identity.
   */
  tenantId?: string;
  /**
   * the object identifier of the Service Principal of the identity associated with this resource.
   */
  principalId?: string;
  /**
   * represents user assigned identities map.
   */
  userAssignedIdentities?: { [propertyName: string]: IdentityItemDescription };
}

/**
 * Describes the horizontal auto scaling mechanism that adds or removes replicas (containers or
 * container groups).
 */
export interface AddRemoveReplicaScalingMechanism {
  /**
   * Polymorphic Discriminator
   */
  kind: "AddRemoveReplica";
  /**
   * Minimum number of containers (scale down won't be performed below this number).
   */
  minCount: number;
  /**
   * Maximum number of containers (scale up won't be performed above this number).
   */
  maxCount: number;
  /**
   * Each time auto scaling is performed, this number of containers will be added or removed.
   */
  scaleIncrement: number;
}

/**
 * Contains the possible cases for AutoScalingMetric.
 */
export type AutoScalingMetricUnion = AutoScalingMetric | AutoScalingResourceMetric;

/**
 * Describes the metric that is used for triggering auto scaling operation. Derived classes will
 * describe resources or metrics.
 */
export interface AutoScalingMetric {
  /**
   * Polymorphic Discriminator
   */
  kind: "AutoScalingMetric";
}

/**
 * Describes the resource that is used for triggering auto scaling.
 */
export interface AutoScalingResourceMetric {
  /**
   * Polymorphic Discriminator
   */
  kind: "Resource";
  /**
   * Name of the resource. Possible values include: 'cpu', 'memoryInGB'
   */
  name: AutoScalingResourceMetricName;
}

/**
 * The default execution policy. Always restart the service if an exit occurs.
 */
export interface DefaultExecutionPolicy {
  /**
   * Polymorphic Discriminator
   */
  type: "Default";
}

/**
 * The run to completion execution policy, the service will perform its desired operation and
 * complete successfully. If the service encounters failure, it will restarted based on restart
 * policy specified. If the service completes its operation successfully, it will not be restarted
 * again.
 */
export interface RunToCompletionExecutionPolicy {
  /**
   * Polymorphic Discriminator
   */
  type: "RunToCompletion";
  /**
   * Enumerates the restart policy for RunToCompletionExecutionPolicy. Possible values include:
   * 'OnFailure', 'Never'
   */
  restart: RestartPolicy;
}

/**
 * Describes properties of a service resource.
 */
export interface ServiceProperties {
  /**
   * User readable description of the service.
   */
  description?: string;
  /**
   * The number of replicas of the service to create. Defaults to 1 if not specified.
   */
  replicaCount?: number;
  /**
   * The execution policy of the service
   */
  executionPolicy?: ExecutionPolicyUnion;
  /**
   * Auto scaling policies
   */
  autoScalingPolicies?: AutoScalingPolicy[];
  /**
   * Status of the service. Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating',
   * 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the service.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
  /**
   * Describes the health state of an application resource. Possible values include: 'Invalid',
   * 'Ok', 'Warning', 'Error', 'Unknown'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly healthState?: HealthState;
  /**
   * When the service's health state is not 'Ok', this additional details from service fabric
   * Health Manager for the user to know why the service is marked unhealthy.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly unhealthyEvaluation?: string;
  /**
   * The service identity list.
   */
  identityRefs?: ServiceIdentity[];
  /**
   * Dns name of the service.
   */
  dnsName?: string;
}

/**
 * Describes the properties of a service replica.
 */
export interface ServiceReplicaProperties {
  /**
   * The operation system required by the code in service. Possible values include: 'Linux',
   * 'Windows'
   */
  osType: OperatingSystemType;
  /**
   * Describes the set of code packages that forms the service. A code package describes the
   * container and the properties for running it. All the code packages are started together on the
   * same host and share the same context (network, process etc.).
   */
  codePackages: ContainerCodePackageProperties[];
  /**
   * The names of the private networks that this service needs to be part of.
   */
  networkRefs?: NetworkRef[];
  /**
   * Reference to sinks in DiagnosticsDescription.
   */
  diagnostics?: DiagnosticsRef;
}

/**
 * Describes a replica of a service resource.
 */
export interface ServiceReplicaDescription extends ServiceReplicaProperties {
  /**
   * Name of the replica.
   */
  replicaName: string;
}

/**
 * Describes the average load trigger used for auto scaling.
 */
export interface AverageLoadScalingTrigger {
  /**
   * Polymorphic Discriminator
   */
  kind: "AverageLoad";
  /**
   * Description of the metric that is used for scaling.
   */
  metric: AutoScalingMetricUnion;
  /**
   * Lower load threshold (if average load is below this threshold, service will scale down).
   */
  lowerLoadThreshold: number;
  /**
   * Upper load threshold (if average load is above this threshold, service will scale up).
   */
  upperLoadThreshold: number;
  /**
   * Scale interval that indicates how often will this trigger be checked.
   */
  scaleIntervalInSeconds: number;
}

/**
 * The list of service resources. The list is paged when all of the results cannot fit in a single
 * message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedServiceResourceDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * One page of the list.
   */
  items?: ServiceResourceDescription[];
}

/**
 * The list of service resource replicas in the cluster. The list is paged when all of the results
 * cannot fit in a single message. The next set of results can be obtained by executing the same
 * query with the continuation token provided in this list.
 */
export interface PagedServiceReplicaDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * List of service resource replica description.
   */
  items?: ServiceReplicaDescription[];
}

/**
 * This type describes a application resource.
 */
export interface ApplicationResourceDescription {
  /**
   * Name of the Application resource.
   */
  name: string;
  /**
   * User readable description of the application.
   */
  description?: string;
  /**
   * Describes the services in the application. This property is used to create or modify services
   * of the application. On get only the name of the service is returned. The service description
   * can be obtained by querying for the service resource.
   */
  services?: ServiceResourceDescription[];
  /**
   * Describes the diagnostics definition and usage for an application resource.
   */
  diagnostics?: DiagnosticsDescription;
  /**
   * Internal - used by Visual Studio to setup the debugging session on the local development
   * environment.
   */
  debugParams?: string;
  /**
   * Names of the services in the application.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly serviceNames?: string[];
  /**
   * Status of the application. Possible values include: 'Unknown', 'Ready', 'Upgrading',
   * 'Creating', 'Deleting', 'Failed'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly status?: ResourceStatus;
  /**
   * Gives additional information about the current status of the application.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusDetails?: string;
  /**
   * Describes the health state of an application resource. Possible values include: 'Invalid',
   * 'Ok', 'Warning', 'Error', 'Unknown'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly healthState?: HealthState;
  /**
   * When the application's health state is not 'Ok', this additional details from service fabric
   * Health Manager for the user to know why the application is marked unhealthy.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly unhealthyEvaluation?: string;
  /**
   * Describes the identity of the application.
   */
  identity?: IdentityDescription;
}

/**
 * The list of application resources. The list is paged when all of the results cannot fit in a
 * single message. The next set of results can be obtained by executing the same query with the
 * continuation token provided in this list.
 */
export interface PagedApplicationResourceDescriptionList {
  /**
   * The continuation token parameter is used to obtain next set of results. The continuation token
   * is included in the response of the API when the results from the system do not fit in a single
   * response. When this value is passed to the next API call, the API returns next set of results.
   * If there are no further results, then the continuation token is not included in the response.
   */
  continuationToken?: string;
  /**
   * One page of the list.
   */
  items?: ApplicationResourceDescription[];
}

/**
 * An interface representing ServiceFabricClientOptions.
 */
export interface ServiceFabricClientOptions extends ServiceClientOptions {
  baseUri?: string;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterManifestOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering of the node health state objects returned in the result of cluster health
   * query
   * based on their health state. The possible values for this parameter include integer value of
   * one of the
   * following health states. Only nodes that match the filter are returned. All nodes are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with HealthState value of
   * OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  nodesHealthStateFilter?: number;
  /**
   * Allows filtering of the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from members or bitwise
   * operations
   * on members of HealthStateFilter enumeration. Only applications that match the filter are
   * returned.
   * All applications are used to evaluate the aggregated health state. If not specified, all
   * entries are returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications with HealthState
   * value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  applicationsHealthStateFilter?: number;
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * Indicates whether the health statistics should include the fabric:/System application health
   * statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the
   * entities that belong to the fabric:/System application.
   * Otherwise, the query result includes health statistics only for user applications.
   * The health statistics must be included in the query result for this parameter to be applied.
   * Default value: false.
   */
  includeSystemApplicationHealthStatistics?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering of the node health state objects returned in the result of cluster health
   * query
   * based on their health state. The possible values for this parameter include integer value of
   * one of the
   * following health states. Only nodes that match the filter are returned. All nodes are used to
   * evaluate the aggregated health state.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of nodes with HealthState value of
   * OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  nodesHealthStateFilter?: number;
  /**
   * Allows filtering of the application health state objects returned in the result of cluster
   * health
   * query based on their health state.
   * The possible values for this parameter include integer value obtained from members or bitwise
   * operations
   * on members of HealthStateFilter enumeration. Only applications that match the filter are
   * returned.
   * All applications are used to evaluate the aggregated health state. If not specified, all
   * entries are returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of applications with HealthState
   * value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  applicationsHealthStateFilter?: number;
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * Indicates whether the health statistics should include the fabric:/System application health
   * statistics. False by default.
   * If IncludeSystemApplicationHealthStatistics is set to true, the health statistics include the
   * entities that belong to the fabric:/System application.
   * Otherwise, the query result includes health statistics only for user applications.
   * The health statistics must be included in the query result for this parameter to be applied.
   * Default value: false.
   */
  includeSystemApplicationHealthStatistics?: boolean;
  /**
   * Describes the health policies used to evaluate the cluster health.
   * If not present, the health evaluation uses the cluster health policy defined in the cluster
   * manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application health policy,
   * defined in the application manifest, or the default health policy, if no policy is defined in
   * manifest.
   * If the application health policy map is specified, and it has an entry for an application, the
   * specified application health policy
   * is used to evaluate the application health.
   */
  clusterHealthPolicies?: ClusterHealthPolicies;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterHealthChunkOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterHealthChunkUsingPolicyAndAdvancedFiltersOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Describes the cluster and application health policies used to evaluate the cluster health and
   * the filters to select which cluster entities to be returned.
   * If the cluster health policy is present, it is used to evaluate the cluster events and the
   * cluster nodes. If not present, the health evaluation uses the cluster health policy defined in
   * the cluster manifest or the default cluster health policy.
   * By default, each application is evaluated using its specific application health policy,
   * defined in the application manifest, or the default health policy, if no policy is defined in
   * manifest.
   * If the application health policy map is specified, and it has an entry for an application, the
   * specified application health policy
   * is used to evaluate the application health.
   * Users can specify very flexible filters to select which cluster entities to include in
   * response. The selection can be done based on the entities health state and based on the
   * hierarchy.
   * The query can return multi-level children of the entities based on the specified filters. For
   * example, it can return one application with a specified name, and for this application, return
   * only services that are in Error or Warning, and all partitions and replicas for one of these
   * services.
   */
  clusterHealthChunkQueryDescription?: ClusterHealthChunkQueryDescription;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientReportClusterHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A flag that indicates whether the report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which forwards to the health
   * store.
   * If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
   * store, regardless of the fabric client settings that the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail, for example if
   * the HTTP Gateway is closed or the message doesn't reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health client settings from the
   * HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
   * configuration.
   * This is the recommended setting because it allows the health client to optimize health
   * reporting messages to health store as well as health report processing.
   * By default, reports are not sent immediately. Default value: false.
   */
  immediate?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetProvisionedFabricCodeVersionInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The product version of Service Fabric.
   */
  codeVersion?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetProvisionedFabricConfigVersionInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The config version of Service Fabric.
   */
  configVersion?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterUpgradeProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterConfigurationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterConfigurationUpgradeStatusOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetUpgradeOrchestrationServiceStateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientSetUpgradeOrchestrationServiceStateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientProvisionClusterOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientUnprovisionClusterOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRollbackClusterUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientResumeClusterUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartClusterUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartClusterConfigurationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientUpdateClusterUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetAadMetadataOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterVersionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterLoadOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientToggleVerboseServicePlacementHealthReportingOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNodeInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * Allows filtering the nodes based on the NodeStatus. Only the nodes that are matching the
   * specified filter value will be returned. The filter value can be one of the following.
   * Possible values include: 'default', 'all', 'up', 'down', 'enabling', 'disabling', 'disabled',
   * 'unknown', 'removed'. Default value: 'default'.
   */
  nodeStatusFilter?: NodeStatusFilter;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNodeInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNodeHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNodeHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Describes the health policies used to evaluate the health of a cluster or node. If not
   * present, the health evaluation uses the health policy from cluster manifest or the default
   * health policy.
   */
  clusterHealthPolicy?: ClusterHealthPolicy;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientReportNodeHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A flag that indicates whether the report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which forwards to the health
   * store.
   * If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
   * store, regardless of the fabric client settings that the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail, for example if
   * the HTTP Gateway is closed or the message doesn't reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health client settings from the
   * HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
   * configuration.
   * This is the recommended setting because it allows the health client to optimize health
   * reporting messages to health store as well as health report processing.
   * By default, reports are not sent immediately. Default value: false.
   */
  immediate?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNodeLoadInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDisableNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientEnableNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRemoveNodeStateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRestartNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRemoveConfigurationOverridesOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetConfigurationOverridesOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientAddConfigurationParameterOverridesOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Force adding configuration overrides on specified nodes.
   */
  force?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationTypeInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Used to filter on ApplicationTypeDefinitionKind which is the mechanism used to define a
   * Service Fabric application type.
   * - Default - Default value, which performs the same function as selecting "All". The value is
   * 0.
   * - All - Filter that matches input with any ApplicationTypeDefinitionKind value. The value is
   * 65535.
   * - ServiceFabricApplicationPackage - Filter that matches input with
   * ApplicationTypeDefinitionKind value ServiceFabricApplicationPackage. The value is 1.
   * - Compose - Filter that matches input with ApplicationTypeDefinitionKind value Compose. The
   * value is 2. Default value: 0.
   */
  applicationTypeDefinitionKindFilter?: number;
  /**
   * The flag that specifies whether application parameters will be excluded from the result.
   * Default value: false.
   */
  excludeApplicationParameters?: boolean;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationTypeInfoListByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The version of the application type.
   */
  applicationTypeVersion?: string;
  /**
   * The flag that specifies whether application parameters will be excluded from the result.
   * Default value: false.
   */
  excludeApplicationParameters?: boolean;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientProvisionApplicationTypeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientUnprovisionApplicationTypeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceTypeInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceTypeInfoByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceManifestOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServiceTypeInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The name of the service manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service types that are defined
   * in this service manifest.
   */
  serviceManifestName?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServiceTypeInfoByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The name of the service manifest to filter the list of deployed service type information. If
   * specified, the response will only contain the information about service types that are defined
   * in this service manifest.
   */
  serviceManifestName?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCreateApplicationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDeleteApplicationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Remove a Service Fabric application or service forcefully without going through the graceful
   * shutdown sequence. This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that prevents graceful close
   * of replicas.
   */
  forceRemove?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationLoadInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Used to filter on ApplicationDefinitionKind, which is the mechanism used to define a Service
   * Fabric application.
   * - Default - Default value, which performs the same function as selecting "All". The value is
   * 0.
   * - All - Filter that matches input with any ApplicationDefinitionKind value. The value is
   * 65535.
   * - ServiceFabricApplicationDescription - Filter that matches input with
   * ApplicationDefinitionKind value ServiceFabricApplicationDescription. The value is 1.
   * - Compose - Filter that matches input with ApplicationDefinitionKind value Compose. The value
   * is 2. Default value: 0.
   */
  applicationDefinitionKindFilter?: number;
  /**
   * The application type name used to filter the applications to query for. This value should not
   * contain the application type version.
   */
  applicationTypeName?: string;
  /**
   * The flag that specifies whether application parameters will be excluded from the result.
   * Default value: false.
   */
  excludeApplicationParameters?: boolean;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The flag that specifies whether application parameters will be excluded from the result.
   * Default value: false.
   */
  excludeApplicationParameters?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Allows filtering of the deployed applications health state objects returned in the result of
   * application health query based on their health state.
   * The possible values for this parameter include integer value of one of the following health
   * states. Only deployed applications that match the filter will be returned.
   * All deployed applications are used to evaluate the aggregated health state. If not specified,
   * all entries are returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed applications with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  deployedApplicationsHealthStateFilter?: number;
  /**
   * Allows filtering of the services health state objects returned in the result of services
   * health query based on their health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only services that match the filter are returned. All services are used to evaluate the
   * aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health
   * state of services with HealthState value of OK (2) and Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  servicesHealthStateFilter?: number;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Allows filtering of the deployed applications health state objects returned in the result of
   * application health query based on their health state.
   * The possible values for this parameter include integer value of one of the following health
   * states. Only deployed applications that match the filter will be returned.
   * All deployed applications are used to evaluate the aggregated health state. If not specified,
   * all entries are returned.
   * The state values are flag-based enumeration, so the value could be a combination of these
   * values, obtained using bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of deployed applications with
   * HealthState value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  deployedApplicationsHealthStateFilter?: number;
  /**
   * Allows filtering of the services health state objects returned in the result of services
   * health query based on their health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only services that match the filter are returned. All services are used to evaluate the
   * aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values,
   * obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health
   * state of services with HealthState value of OK (2) and Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  servicesHealthStateFilter?: number;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * Describes the health policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from application manifest or the
   * default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientReportApplicationHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A flag that indicates whether the report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which forwards to the health
   * store.
   * If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
   * store, regardless of the fabric client settings that the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail, for example if
   * the HTTP Gateway is closed or the message doesn't reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health client settings from the
   * HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
   * configuration.
   * This is the recommended setting because it allows the health client to optimize health
   * reporting messages to health store as well as health report processing.
   * By default, reports are not sent immediately. Default value: false.
   */
  immediate?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientUpdateApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientResumeApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRollbackApplicationUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedApplicationInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * Include the health state of an entity.
   * If this parameter is false or not specified, then the health state returned is "Unknown".
   * When set to true, the query goes in parallel to the node and the health system service before
   * the results are merged.
   * As a result, the query is more expensive and may take a longer time. Default value: false.
   */
  includeHealthState?: boolean;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedApplicationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * Include the health state of an entity.
   * If this parameter is false or not specified, then the health state returned is "Unknown".
   * When set to true, the query goes in parallel to the node and the health system service before
   * the results are merged.
   * As a result, the query is more expensive and may take a longer time. Default value: false.
   */
  includeHealthState?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedApplicationHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Allows filtering of the deployed service package health state objects returned in the result
   * of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only deployed service packages that match the filter are returned. All deployed service
   * packages are used to evaluate the aggregated health state of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a combination of these
   * values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service packages with HealthState
   * value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  deployedServicePackagesHealthStateFilter?: number;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedApplicationHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Allows filtering of the deployed service package health state objects returned in the result
   * of deployed application health query based on their health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only deployed service packages that match the filter are returned. All deployed service
   * packages are used to evaluate the aggregated health state of the deployed application.
   * If not specified, all entries are returned.
   * The state values are flag-based enumeration, so the value can be a combination of these
   * values, obtained using the bitwise 'OR' operator.
   * For example, if the provided value is 6 then health state of service packages with HealthState
   * value of OK (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  deployedServicePackagesHealthStateFilter?: number;
  /**
   * Describes the health policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from application manifest or the
   * default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientReportDeployedApplicationHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A flag that indicates whether the report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which forwards to the health
   * store.
   * If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
   * store, regardless of the fabric client settings that the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail, for example if
   * the HTTP Gateway is closed or the message doesn't reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health client settings from the
   * HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
   * configuration.
   * This is the recommended setting because it allows the health client to optimize health
   * reporting messages to health store as well as health report processing.
   * By default, reports are not sent immediately. Default value: false.
   */
  immediate?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationManifestOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The service type name used to filter the services to query for.
   */
  serviceTypeName?: string;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationNameInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCreateServiceOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCreateServiceFromTemplateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDeleteServiceOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Remove a Service Fabric application or service forcefully without going through the graceful
   * shutdown sequence. This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that prevents graceful close
   * of replicas.
   */
  forceRemove?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientUpdateServiceOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceDescriptionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Allows filtering of the partitions health state objects returned in the result of service
   * health query based on their health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only partitions that match the filter are returned. All partitions are used to evaluate the
   * aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health
   * state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  partitionsHealthStateFilter?: number;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Allows filtering of the partitions health state objects returned in the result of service
   * health query based on their health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only partitions that match the filter are returned. All partitions are used to evaluate the
   * aggregated health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these value
   * obtained using bitwise 'OR' operator. For example, if the provided value is 6 then health
   * state of partitions with HealthState value of OK (2) and Warning (4) will be returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  partitionsHealthStateFilter?: number;
  /**
   * Describes the health policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from application manifest or the
   * default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientReportServiceHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A flag that indicates whether the report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which forwards to the health
   * store.
   * If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
   * store, regardless of the fabric client settings that the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail, for example if
   * the HTTP Gateway is closed or the message doesn't reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health client settings from the
   * HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
   * configuration.
   * This is the recommended setting because it allows the health client to optimize health
   * reporting messages to health store as well as health report processing.
   * By default, reports are not sent immediately. Default value: false.
   */
  immediate?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientResolveServiceOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Key type for the partition. This parameter is required if the partition scheme for the service
   * is Int64Range or Named. The possible values are following.
   * - None (1) - Indicates that the PartitionKeyValue parameter is not specified. This is valid
   * for the partitions with partitioning scheme as Singleton. This is the default value. The value
   * is 1.
   * - Int64Range (2) - Indicates that the PartitionKeyValue parameter is an int64 partition key.
   * This is valid for the partitions with partitioning scheme as Int64Range. The value is 2.
   * - Named (3) - Indicates that the PartitionKeyValue parameter is a name of the partition. This
   * is valid for the partitions with partitioning scheme as Named. The value is 3.
   */
  partitionKeyType?: number;
  /**
   * Partition key. This is required if the partition scheme for the service is Int64Range or
   * Named.
   * This is not the partition ID, but rather, either the integer key value, or the name of the
   * partition ID.
   * For example, if your service is using ranged partitions from 0 to 10, then they
   * PartitionKeyValue would be an
   * integer in that range. Query service description to see the range or name.
   */
  partitionKeyValue?: string;
  /**
   * The value in the Version field of the response that was received previously. This is required
   * if the user knows that the result that was gotten previously is stale.
   */
  previousRspVersion?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetUnplacedReplicaInformationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The identity of the partition.
   */
  partitionId?: string;
  /**
   * Indicates that unplaced replica information will be queries only for primary replicas. Default
   * value: false.
   */
  onlyQueryPrimaries?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceNameInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Allows filtering the collection of ReplicaHealthState objects on the partition. The value can
   * be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas
   * that match the filter will be returned. All replicas will be used to evaluate the aggregated
   * health state. If not specified, all entries will be returned.The state values are flag-based
   * enumeration, so the value could be a combination of these values obtained using bitwise 'OR'
   * operator. For example, If the provided value is 6 then all of the events with HealthState
   * value of OK (2) and Warning (4) will be returned. The possible values for this parameter
   * include integer value of one of the following health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  replicasHealthStateFilter?: number;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Allows filtering the collection of ReplicaHealthState objects on the partition. The value can
   * be obtained from members or bitwise operations on members of HealthStateFilter. Only replicas
   * that match the filter will be returned. All replicas will be used to evaluate the aggregated
   * health state. If not specified, all entries will be returned.The state values are flag-based
   * enumeration, so the value could be a combination of these values obtained using bitwise 'OR'
   * operator. For example, If the provided value is 6 then all of the events with HealthState
   * value of OK (2) and Warning (4) will be returned. The possible values for this parameter
   * include integer value of one of the following health states.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  replicasHealthStateFilter?: number;
  /**
   * Describes the health policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from application manifest or the
   * default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * Indicates whether the health statistics should be returned as part of the query result. False
   * by default.
   * The statistics show the number of children entities in health state Ok, Warning, and Error.
   * Default value: false.
   */
  excludeHealthStatistics?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientReportPartitionHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A flag that indicates whether the report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which forwards to the health
   * store.
   * If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
   * store, regardless of the fabric client settings that the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail, for example if
   * the HTTP Gateway is closed or the message doesn't reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health client settings from the
   * HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
   * configuration.
   * This is the recommended setting because it allows the health client to optimize health
   * reporting messages to health store as well as health report processing.
   * By default, reports are not sent immediately. Default value: false.
   */
  immediate?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionLoadInformationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientResetPartitionLoadOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRecoverPartitionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRecoverServicePartitionsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRecoverSystemPartitionsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRecoverAllPartitionsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientMovePrimaryReplicaOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The name of the node.
   */
  nodeName?: string;
  /**
   * Ignore constraints when moving a replica. If this parameter is not specified, all constraints
   * are honored. Default value: false.
   */
  ignoreConstraints?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientMoveSecondaryReplicaOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The name of the target node for secondary replica move. If not specified, replica is moved to
   * a random node.
   */
  newNodeName?: string;
  /**
   * Ignore constraints when moving a replica. If this parameter is not specified, all constraints
   * are honored. Default value: false.
   */
  ignoreConstraints?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetRepairTaskListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The repair task ID prefix to be matched.
   */
  taskIdFilter?: string;
  /**
   * A bitwise-OR of the following values, specifying which task states should be included in the
   * result list.
   *
   * - 1 - Created
   * - 2 - Claimed
   * - 4 - Preparing
   * - 8 - Approved
   * - 16 - Executing
   * - 32 - Restoring
   * - 64 - Completed
   */
  stateFilter?: number;
  /**
   * The name of the repair executor whose claimed tasks should be included in the list.
   */
  executorFilter?: string;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetReplicaInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetReplicaInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetReplicaHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetReplicaHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Describes the health policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from application manifest or the
   * default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientReportReplicaHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A flag that indicates whether the report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which forwards to the health
   * store.
   * If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
   * store, regardless of the fabric client settings that the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail, for example if
   * the HTTP Gateway is closed or the message doesn't reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health client settings from the
   * HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
   * configuration.
   * This is the recommended setting because it allows the health client to optimize health
   * reporting messages to health store as well as health report processing.
   * By default, reports are not sent immediately. Default value: false.
   */
  immediate?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServiceReplicaInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The identity of the partition.
   */
  partitionId?: string;
  /**
   * The name of a service manifest registered as part of an application type in a Service Fabric
   * cluster.
   */
  serviceManifestName?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServiceReplicaDetailInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServiceReplicaDetailInfoByPartitionIdOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRestartReplicaOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRemoveReplicaOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Remove a Service Fabric application or service forcefully without going through the graceful
   * shutdown sequence. This parameter can be used to forcefully delete an application or service
   * for which delete is timing out due to issues in the service code that prevents graceful close
   * of replicas.
   */
  forceRemove?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServicePackageInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServicePackageInfoListByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServicePackageHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedServicePackageHealthUsingPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows filtering the collection of HealthEvent objects returned based on health state.
   * The possible values for this parameter include integer value of one of the following health
   * states.
   * Only events that match the filter are returned. All events are used to evaluate the aggregated
   * health state.
   * If not specified, all entries are returned. The state values are flag-based enumeration, so
   * the value could be a combination of these values, obtained using the bitwise 'OR' operator.
   * For example, If the provided value is 6 then all of the events with HealthState value of OK
   * (2) and Warning (4) are returned.
   *
   * - Default - Default value. Matches any HealthState. The value is zero.
   * - None - Filter that doesn't match any HealthState value. Used in order to return no results
   * on a given collection of states. The value is 1.
   * - Ok - Filter that matches input with HealthState value Ok. The value is 2.
   * - Warning - Filter that matches input with HealthState value Warning. The value is 4.
   * - Error - Filter that matches input with HealthState value Error. The value is 8.
   * - All - Filter that matches input with any HealthState value. The value is 65535. Default
   * value: 0.
   */
  eventsHealthStateFilter?: number;
  /**
   * Describes the health policies used to evaluate the health of an application or one of its
   * children.
   * If not present, the health evaluation uses the health policy from application manifest or the
   * default health policy.
   */
  applicationHealthPolicy?: ApplicationHealthPolicy;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientReportDeployedServicePackageHealthOptionalParams extends msRest.RequestOptionsBase {
  /**
   * A flag that indicates whether the report should be sent immediately.
   * A health report is sent to a Service Fabric gateway Application, which forwards to the health
   * store.
   * If Immediate is set to true, the report is sent immediately from HTTP Gateway to the health
   * store, regardless of the fabric client settings that the HTTP Gateway Application is using.
   * This is useful for critical reports that should be sent as soon as possible.
   * Depending on timing and other conditions, sending the report may still fail, for example if
   * the HTTP Gateway is closed or the message doesn't reach the Gateway.
   * If Immediate is set to false, the report is sent based on the health client settings from the
   * HTTP Gateway. Therefore, it will be batched according to the HealthReportSendInterval
   * configuration.
   * This is the recommended setting because it allows the health client to optimize health
   * reporting messages to health store as well as health report processing.
   * By default, reports are not sent immediately. Default value: false.
   */
  immediate?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDeployServicePackageToNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDeployedCodePackageInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The name of a service manifest registered as part of an application type in a Service Fabric
   * cluster.
   */
  serviceManifestName?: string;
  /**
   * The name of code package specified in service manifest registered as part of an application
   * type in a Service Fabric cluster.
   */
  codePackageName?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRestartDeployedCodePackageOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetContainerLogsDeployedOnNodeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Number of lines to show from the end of the logs. Default is 100. 'all' to show the complete
   * logs.
   */
  tail?: string;
  /**
   * Specifies whether to get container logs from exited/dead containers of the code package
   * instance. Default value: false.
   */
  previous?: boolean;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientInvokeContainerApiOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCreateComposeDeploymentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetComposeDeploymentStatusOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetComposeDeploymentStatusListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetComposeDeploymentUpgradeProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRemoveComposeDeploymentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartComposeDeploymentUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartRollbackComposeDeploymentUpgradeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetChaosOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartChaosOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStopChaosOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetChaosEventsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The Windows file time representing the start time of the time range for which a Chaos report
   * is to be generated. Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for
   * details.
   */
  startTimeUtc?: string;
  /**
   * The Windows file time representing the end time of the time range for which a Chaos report is
   * to be generated. Consult [DateTime.ToFileTimeUtc
   * Method](https://msdn.microsoft.com/library/system.datetime.tofiletimeutc(v=vs.110).aspx) for
   * details.
   */
  endTimeUtc?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetChaosScheduleOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientPostChaosScheduleOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientUploadFileOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetImageStoreContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDeleteImageStoreContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetImageStoreRootContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCopyImageStoreContentOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDeleteImageStoreUploadSessionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCommitImageStoreUploadSessionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetImageStoreUploadSessionByIdOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetImageStoreUploadSessionByPathOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientUploadFileChunkOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetImageStoreRootFolderSizeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetImageStoreFolderSizeOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetImageStoreInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientInvokeInfrastructureCommandOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The identity of the infrastructure service. This is the full name of the infrastructure
   * service without the 'fabric:' URI scheme. This parameter required only for the cluster that
   * has more than one instance of infrastructure service running.
   */
  serviceId?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientInvokeInfrastructureQueryOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The identity of the infrastructure service. This is the full name of the infrastructure
   * service without the 'fabric:' URI scheme. This parameter required only for the cluster that
   * has more than one instance of infrastructure service running.
   */
  serviceId?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartDataLossOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetDataLossProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartQuorumLossOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetQuorumLossProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartPartitionRestartOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionRestartProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientStartNodeTransitionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNodeTransitionProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetFaultOperationListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCancelOperationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCreateBackupPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDeleteBackupPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetBackupPolicyListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetBackupPolicyByNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetAllEntitiesBackedUpByPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientUpdateBackupPolicyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientEnableApplicationBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDisableApplicationBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * Specifies the parameters to disable backup for any backup entity.
   */
  disableBackupDescription?: DisableBackupDescription;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationBackupConfigurationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationBackupListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * Specifies whether to get only the most recent backup available for a partition for the
   * specified time range. Default value: false.
   */
  latest?: boolean;
  /**
   * Specify the start date time from which to enumerate backups, in datetime format. The date time
   * must be specified in ISO8601 format. This is an optional parameter. If not specified, all
   * backups from the beginning are enumerated.
   */
  startDateTimeFilter?: Date;
  /**
   * Specify the end date time till which to enumerate backups, in datetime format. The date time
   * must be specified in ISO8601 format. This is an optional parameter. If not specified,
   * enumeration is done till the most recent backup.
   */
  endDateTimeFilter?: Date;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientSuspendApplicationBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientResumeApplicationBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientEnableServiceBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDisableServiceBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies the parameters to disable backup for any backup entity.
   */
  disableBackupDescription?: DisableBackupDescription;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceBackupConfigurationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceBackupListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * Specifies whether to get only the most recent backup available for a partition for the
   * specified time range. Default value: false.
   */
  latest?: boolean;
  /**
   * Specify the start date time from which to enumerate backups, in datetime format. The date time
   * must be specified in ISO8601 format. This is an optional parameter. If not specified, all
   * backups from the beginning are enumerated.
   */
  startDateTimeFilter?: Date;
  /**
   * Specify the end date time till which to enumerate backups, in datetime format. The date time
   * must be specified in ISO8601 format. This is an optional parameter. If not specified,
   * enumeration is done till the most recent backup.
   */
  endDateTimeFilter?: Date;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientSuspendServiceBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientResumeServiceBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientEnablePartitionBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDisablePartitionBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies the parameters to disable backup for any backup entity.
   */
  disableBackupDescription?: DisableBackupDescription;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionBackupConfigurationInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionBackupListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * Specifies whether to get only the most recent backup available for a partition for the
   * specified time range. Default value: false.
   */
  latest?: boolean;
  /**
   * Specify the start date time from which to enumerate backups, in datetime format. The date time
   * must be specified in ISO8601 format. This is an optional parameter. If not specified, all
   * backups from the beginning are enumerated.
   */
  startDateTimeFilter?: Date;
  /**
   * Specify the end date time till which to enumerate backups, in datetime format. The date time
   * must be specified in ISO8601 format. This is an optional parameter. If not specified,
   * enumeration is done till the most recent backup.
   */
  endDateTimeFilter?: Date;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientSuspendPartitionBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientResumePartitionBackupOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientBackupPartitionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Describes the parameters to backup the partition now. If not present, backup operation uses
   * default parameters from the backup policy current associated with this partition.
   */
  backupPartitionDescription?: BackupPartitionDescription;
  /**
   * Specifies the maximum amount of time, in minutes, to wait for the backup operation to
   * complete. Post that, the operation completes with timeout error. However, in certain corner
   * cases it could be that though the operation returns back timeout, the backup actually goes
   * through. In case of timeout error, its recommended to invoke this operation again with a
   * greater timeout value. The default value for the same is 10 minutes. Default value: 10.
   */
  backupTimeout?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionBackupProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientRestorePartitionOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Specifies the maximum amount of time to wait, in minutes, for the restore operation to
   * complete. Post that, the operation returns back with timeout error. However, in certain corner
   * cases it could be that the restore operation goes through even though it completes with
   * timeout. In case of timeout error, its recommended to invoke this operation again with a
   * greater timeout value. the default value for the same is 10 minutes. Default value: 10.
   */
  restoreTimeout?: number;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionRestoreProgressOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetBackupsFromBackupLocationOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The maximum number of results to be returned as part of the paged queries. This parameter
   * defines the upper bound on the number of results returned. The results returned can be less
   * than the specified maximum results if they do not fit in the message as per the max message
   * size restrictions defined in the configuration. If this parameter is zero or not specified,
   * the paged query includes as many results as possible that fit in the return message. Default
   * value: 0.
   */
  maxResults?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientCreateNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNameExistsInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDeleteNameOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetSubNameInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows specifying that the search performed should be recursive. Default value: false.
   */
  recursive?: boolean;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPropertyInfoListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Allows specifying whether to include the values of the properties returned. True if values
   * should be returned with the metadata; False to return only property metadata. Default value:
   * false.
   */
  includeValues?: boolean;
  /**
   * The continuation token parameter is used to obtain next set of results. A continuation token
   * with a non-empty value is included in the response of the API when the results from the system
   * do not fit in a single response. When this value is passed to the next API call, the API
   * returns next set of results. If there are no further results, then the continuation token does
   * not contain a value. The value of this parameter should not be URL encoded.
   */
  continuationToken?: string;
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientPutPropertyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPropertyInfoOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientDeletePropertyOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientSubmitPropertyBatchOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetClusterEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetContainersEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNodeEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetNodesEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetApplicationsEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServiceEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetServicesEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionsEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionReplicaEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetPartitionReplicasEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
  /**
   * This is a comma separated string specifying the types of FabricEvents that should only be
   * included in the response.
   */
  eventsTypesFilter?: string;
  /**
   * This param disables the retrieval of AnalysisEvents if true is passed.
   */
  excludeAnalysisEvents?: boolean;
  /**
   * This param disables the search of CorrelatedEvents information if true is passed. otherwise
   * the CorrelationEvents get processed and HasCorrelatedEvents field in every FabricEvent gets
   * populated.
   */
  skipCorrelationLookup?: boolean;
}

/**
 * Optional Parameters.
 */
export interface ServiceFabricClientGetCorrelatedEventListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * The server timeout for performing the operation in seconds. This timeout specifies the time
   * duration that the client is willing to wait for the requested operation to complete. The
   * default value for this parameter is 60 seconds. Default value: 60.
   */
  timeoutParameter?: number;
}

/**
 * Optional Parameters.
 */
export interface MeshCodePackageGetContainerLogsOptionalParams extends msRest.RequestOptionsBase {
  /**
   * Number of lines to show from the end of the logs. Default is 100. 'all' to show the complete
   * logs.
   */
  tail?: string;
}

/**
 * Defines values for HealthState.
 * Possible values include: 'Invalid', 'Ok', 'Warning', 'Error', 'Unknown'
 * @readonly
 * @enum {string}
 */
export type HealthState = 'Invalid' | 'Ok' | 'Warning' | 'Error' | 'Unknown';

/**
 * Defines values for FabricErrorCodes.
 * Possible values include: 'FABRIC_E_INVALID_PARTITION_KEY',
 * 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR', 'FABRIC_E_INVALID_ADDRESS',
 * 'FABRIC_E_APPLICATION_NOT_UPGRADING', 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_FABRIC_NOT_UPGRADING', 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR',
 * 'FABRIC_E_INVALID_CONFIGURATION', 'FABRIC_E_INVALID_NAME_URI', 'FABRIC_E_PATH_TOO_LONG',
 * 'FABRIC_E_KEY_TOO_LARGE', 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED',
 * 'FABRIC_E_INVALID_ATOMIC_GROUP', 'FABRIC_E_VALUE_EMPTY', 'FABRIC_E_NODE_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND', 'FABRIC_E_APPLICATION_NOT_FOUND',
 * 'FABRIC_E_SERVICE_TYPE_NOT_FOUND', 'FABRIC_E_SERVICE_DOES_NOT_EXIST',
 * 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND', 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND',
 * 'FABRIC_E_PARTITION_NOT_FOUND', 'FABRIC_E_REPLICA_DOES_NOT_EXIST',
 * 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST', 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND',
 * 'FABRIC_E_DIRECTORY_NOT_FOUND', 'FABRIC_E_FABRIC_VERSION_NOT_FOUND', 'FABRIC_E_FILE_NOT_FOUND',
 * 'FABRIC_E_NAME_DOES_NOT_EXIST', 'FABRIC_E_PROPERTY_DOES_NOT_EXIST',
 * 'FABRIC_E_ENUMERATION_COMPLETED', 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND',
 * 'FABRIC_E_KEY_NOT_FOUND', 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND',
 * 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS', 'FABRIC_E_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS', 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS',
 * 'FABRIC_E_SERVICE_ALREADY_EXISTS', 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS',
 * 'FABRIC_E_APPLICATION_TYPE_IN_USE', 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION',
 * 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS', 'FABRIC_E_FABRIC_VERSION_IN_USE',
 * 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS', 'FABRIC_E_NAME_ALREADY_EXISTS',
 * 'FABRIC_E_NAME_NOT_EMPTY', 'FABRIC_E_PROPERTY_CHECK_FAILED',
 * 'FABRIC_E_SERVICE_METADATA_MISMATCH', 'FABRIC_E_SERVICE_TYPE_MISMATCH',
 * 'FABRIC_E_HEALTH_STALE_REPORT', 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED',
 * 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET', 'FABRIC_E_INSTANCE_ID_MISMATCH',
 * 'FABRIC_E_VALUE_TOO_LARGE', 'FABRIC_E_NO_WRITE_QUORUM', 'FABRIC_E_NOT_PRIMARY',
 * 'FABRIC_E_NOT_READY', 'FABRIC_E_RECONFIGURATION_PENDING', 'FABRIC_E_SERVICE_OFFLINE', 'E_ABORT',
 * 'FABRIC_E_COMMUNICATION_ERROR', 'FABRIC_E_OPERATION_NOT_COMPLETE', 'FABRIC_E_TIMEOUT',
 * 'FABRIC_E_NODE_IS_UP', 'E_FAIL', 'FABRIC_E_BACKUP_IS_ENABLED',
 * 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH', 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES',
 * 'FABRIC_E_BACKUP_NOT_ENABLED', 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING',
 * 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING', 'FABRIC_E_BACKUP_IN_PROGRESS',
 * 'FABRIC_E_RESTORE_IN_PROGRESS', 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING',
 * 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY', 'E_INVALIDARG',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS',
 * 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND', 'FABRIC_E_VOLUME_ALREADY_EXISTS',
 * 'FABRIC_E_VOLUME_NOT_FOUND', 'SerializationError',
 * 'FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR'
 * @readonly
 * @enum {string}
 */
export type FabricErrorCodes = 'FABRIC_E_INVALID_PARTITION_KEY' | 'FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR' | 'FABRIC_E_INVALID_ADDRESS' | 'FABRIC_E_APPLICATION_NOT_UPGRADING' | 'FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR' | 'FABRIC_E_FABRIC_NOT_UPGRADING' | 'FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR' | 'FABRIC_E_INVALID_CONFIGURATION' | 'FABRIC_E_INVALID_NAME_URI' | 'FABRIC_E_PATH_TOO_LONG' | 'FABRIC_E_KEY_TOO_LARGE' | 'FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED' | 'FABRIC_E_INVALID_ATOMIC_GROUP' | 'FABRIC_E_VALUE_EMPTY' | 'FABRIC_E_NODE_NOT_FOUND' | 'FABRIC_E_APPLICATION_TYPE_NOT_FOUND' | 'FABRIC_E_APPLICATION_NOT_FOUND' | 'FABRIC_E_SERVICE_TYPE_NOT_FOUND' | 'FABRIC_E_SERVICE_DOES_NOT_EXIST' | 'FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND' | 'FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND' | 'FABRIC_E_PARTITION_NOT_FOUND' | 'FABRIC_E_REPLICA_DOES_NOT_EXIST' | 'FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST' | 'FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND' | 'FABRIC_E_DIRECTORY_NOT_FOUND' | 'FABRIC_E_FABRIC_VERSION_NOT_FOUND' | 'FABRIC_E_FILE_NOT_FOUND' | 'FABRIC_E_NAME_DOES_NOT_EXIST' | 'FABRIC_E_PROPERTY_DOES_NOT_EXIST' | 'FABRIC_E_ENUMERATION_COMPLETED' | 'FABRIC_E_SERVICE_MANIFEST_NOT_FOUND' | 'FABRIC_E_KEY_NOT_FOUND' | 'FABRIC_E_HEALTH_ENTITY_NOT_FOUND' | 'FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS' | 'FABRIC_E_APPLICATION_ALREADY_EXISTS' | 'FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION' | 'FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS' | 'FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS' | 'FABRIC_E_SERVICE_ALREADY_EXISTS' | 'FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS' | 'FABRIC_E_APPLICATION_TYPE_IN_USE' | 'FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION' | 'FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS' | 'FABRIC_E_FABRIC_VERSION_IN_USE' | 'FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS' | 'FABRIC_E_NAME_ALREADY_EXISTS' | 'FABRIC_E_NAME_NOT_EMPTY' | 'FABRIC_E_PROPERTY_CHECK_FAILED' | 'FABRIC_E_SERVICE_METADATA_MISMATCH' | 'FABRIC_E_SERVICE_TYPE_MISMATCH' | 'FABRIC_E_HEALTH_STALE_REPORT' | 'FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED' | 'FABRIC_E_NODE_HAS_NOT_STOPPED_YET' | 'FABRIC_E_INSTANCE_ID_MISMATCH' | 'FABRIC_E_VALUE_TOO_LARGE' | 'FABRIC_E_NO_WRITE_QUORUM' | 'FABRIC_E_NOT_PRIMARY' | 'FABRIC_E_NOT_READY' | 'FABRIC_E_RECONFIGURATION_PENDING' | 'FABRIC_E_SERVICE_OFFLINE' | 'E_ABORT' | 'FABRIC_E_COMMUNICATION_ERROR' | 'FABRIC_E_OPERATION_NOT_COMPLETE' | 'FABRIC_E_TIMEOUT' | 'FABRIC_E_NODE_IS_UP' | 'E_FAIL' | 'FABRIC_E_BACKUP_IS_ENABLED' | 'FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH' | 'FABRIC_E_INVALID_FOR_STATELESS_SERVICES' | 'FABRIC_E_BACKUP_NOT_ENABLED' | 'FABRIC_E_BACKUP_POLICY_NOT_EXISTING' | 'FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING' | 'FABRIC_E_BACKUP_IN_PROGRESS' | 'FABRIC_E_RESTORE_IN_PROGRESS' | 'FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING' | 'FABRIC_E_INVALID_SERVICE_SCALING_POLICY' | 'E_INVALIDARG' | 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS' | 'FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND' | 'FABRIC_E_VOLUME_ALREADY_EXISTS' | 'FABRIC_E_VOLUME_NOT_FOUND' | 'SerializationError' | 'FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR';

/**
 * Defines values for ApplicationDefinitionKind.
 * Possible values include: 'Invalid', 'ServiceFabricApplicationDescription', 'Compose'
 * @readonly
 * @enum {string}
 */
export type ApplicationDefinitionKind = 'Invalid' | 'ServiceFabricApplicationDescription' | 'Compose';

/**
 * Defines values for ApplicationStatus.
 * Possible values include: 'Invalid', 'Ready', 'Upgrading', 'Creating', 'Deleting', 'Failed'
 * @readonly
 * @enum {string}
 */
export type ApplicationStatus = 'Invalid' | 'Ready' | 'Upgrading' | 'Creating' | 'Deleting' | 'Failed';

/**
 * Defines values for ApplicationPackageCleanupPolicy.
 * Possible values include: 'Invalid', 'Default', 'Automatic', 'Manual'
 * @readonly
 * @enum {string}
 */
export type ApplicationPackageCleanupPolicy = 'Invalid' | 'Default' | 'Automatic' | 'Manual';

/**
 * Defines values for ApplicationTypeDefinitionKind.
 * Possible values include: 'Invalid', 'ServiceFabricApplicationPackage', 'Compose'
 * @readonly
 * @enum {string}
 */
export type ApplicationTypeDefinitionKind = 'Invalid' | 'ServiceFabricApplicationPackage' | 'Compose';

/**
 * Defines values for ApplicationTypeStatus.
 * Possible values include: 'Invalid', 'Provisioning', 'Available', 'Unprovisioning', 'Failed'
 * @readonly
 * @enum {string}
 */
export type ApplicationTypeStatus = 'Invalid' | 'Provisioning' | 'Available' | 'Unprovisioning' | 'Failed';

/**
 * Defines values for UpgradeKind.
 * Possible values include: 'Invalid', 'Rolling'
 * @readonly
 * @enum {string}
 */
export type UpgradeKind = 'Invalid' | 'Rolling';

/**
 * Defines values for UpgradeMode.
 * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 * @readonly
 * @enum {string}
 */
export type UpgradeMode = 'Invalid' | 'UnmonitoredAuto' | 'UnmonitoredManual' | 'Monitored';

/**
 * Defines values for UpgradeSortOrder.
 * Possible values include: 'Invalid', 'Default', 'Numeric', 'Lexicographical', 'ReverseNumeric',
 * 'ReverseLexicographical'
 * @readonly
 * @enum {string}
 */
export type UpgradeSortOrder = 'Invalid' | 'Default' | 'Numeric' | 'Lexicographical' | 'ReverseNumeric' | 'ReverseLexicographical';

/**
 * Defines values for FailureAction.
 * Possible values include: 'Invalid', 'Rollback', 'Manual'
 * @readonly
 * @enum {string}
 */
export type FailureAction = 'Invalid' | 'Rollback' | 'Manual';

/**
 * Defines values for UpgradeDomainState.
 * Possible values include: 'Invalid', 'Pending', 'InProgress', 'Completed'
 * @readonly
 * @enum {string}
 */
export type UpgradeDomainState = 'Invalid' | 'Pending' | 'InProgress' | 'Completed';

/**
 * Defines values for UpgradeState.
 * Possible values include: 'Invalid', 'RollingBackInProgress', 'RollingBackCompleted',
 * 'RollingForwardPending', 'RollingForwardInProgress', 'RollingForwardCompleted', 'Failed'
 * @readonly
 * @enum {string}
 */
export type UpgradeState = 'Invalid' | 'RollingBackInProgress' | 'RollingBackCompleted' | 'RollingForwardPending' | 'RollingForwardInProgress' | 'RollingForwardCompleted' | 'Failed';

/**
 * Defines values for NodeUpgradePhase.
 * Possible values include: 'Invalid', 'PreUpgradeSafetyCheck', 'Upgrading',
 * 'PostUpgradeSafetyCheck'
 * @readonly
 * @enum {string}
 */
export type NodeUpgradePhase = 'Invalid' | 'PreUpgradeSafetyCheck' | 'Upgrading' | 'PostUpgradeSafetyCheck';

/**
 * Defines values for FailureReason.
 * Possible values include: 'None', 'Interrupted', 'HealthCheck', 'UpgradeDomainTimeout',
 * 'OverallUpgradeTimeout'
 * @readonly
 * @enum {string}
 */
export type FailureReason = 'None' | 'Interrupted' | 'HealthCheck' | 'UpgradeDomainTimeout' | 'OverallUpgradeTimeout';

/**
 * Defines values for DeactivationIntent.
 * Possible values include: 'Pause', 'Restart', 'RemoveData'
 * @readonly
 * @enum {string}
 */
export type DeactivationIntent = 'Pause' | 'Restart' | 'RemoveData';

/**
 * Defines values for DeployedApplicationStatus.
 * Possible values include: 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
 * 'Deactivating'
 * @readonly
 * @enum {string}
 */
export type DeployedApplicationStatus = 'Invalid' | 'Downloading' | 'Activating' | 'Active' | 'Upgrading' | 'Deactivating';

/**
 * Defines values for ReplicaStatus.
 * Possible values include: 'Invalid', 'InBuild', 'Standby', 'Ready', 'Down', 'Dropped'
 * @readonly
 * @enum {string}
 */
export type ReplicaStatus = 'Invalid' | 'InBuild' | 'Standby' | 'Ready' | 'Down' | 'Dropped';

/**
 * Defines values for ReplicaRole.
 * Possible values include: 'Unknown', 'None', 'Primary', 'IdleSecondary', 'ActiveSecondary'
 * @readonly
 * @enum {string}
 */
export type ReplicaRole = 'Unknown' | 'None' | 'Primary' | 'IdleSecondary' | 'ActiveSecondary';

/**
 * Defines values for ReconfigurationPhase.
 * Possible values include: 'Unknown', 'None', 'Phase0', 'Phase1', 'Phase2', 'Phase3', 'Phase4',
 * 'AbortPhaseZero'
 * @readonly
 * @enum {string}
 */
export type ReconfigurationPhase = 'Unknown' | 'None' | 'Phase0' | 'Phase1' | 'Phase2' | 'Phase3' | 'Phase4' | 'AbortPhaseZero';

/**
 * Defines values for ReconfigurationType.
 * Possible values include: 'Unknown', 'SwapPrimary', 'Failover', 'Other'
 * @readonly
 * @enum {string}
 */
export type ReconfigurationType = 'Unknown' | 'SwapPrimary' | 'Failover' | 'Other';

/**
 * Defines values for EntityKind.
 * Possible values include: 'Invalid', 'Node', 'Partition', 'Service', 'Application', 'Replica',
 * 'DeployedApplication', 'DeployedServicePackage', 'Cluster'
 * @readonly
 * @enum {string}
 */
export type EntityKind = 'Invalid' | 'Node' | 'Partition' | 'Service' | 'Application' | 'Replica' | 'DeployedApplication' | 'DeployedServicePackage' | 'Cluster';

/**
 * Defines values for FabricEventKind.
 * Possible values include: 'ClusterEvent', 'ContainerInstanceEvent', 'NodeEvent',
 * 'ApplicationEvent', 'ServiceEvent', 'PartitionEvent', 'ReplicaEvent', 'PartitionAnalysisEvent',
 * 'ApplicationCreated', 'ApplicationDeleted', 'ApplicationNewHealthReport',
 * 'ApplicationHealthReportExpired', 'ApplicationUpgradeCompleted',
 * 'ApplicationUpgradeDomainCompleted', 'ApplicationUpgradeRollbackCompleted',
 * 'ApplicationUpgradeRollbackStarted', 'ApplicationUpgradeStarted',
 * 'DeployedApplicationNewHealthReport', 'DeployedApplicationHealthReportExpired',
 * 'ApplicationProcessExited', 'ApplicationContainerInstanceExited', 'NodeAborted',
 * 'NodeAddedToCluster', 'NodeClosed', 'NodeDeactivateCompleted', 'NodeDeactivateStarted',
 * 'NodeDown', 'NodeNewHealthReport', 'NodeHealthReportExpired', 'NodeOpenSucceeded',
 * 'NodeOpenFailed', 'NodeRemovedFromCluster', 'NodeUp', 'PartitionNewHealthReport',
 * 'PartitionHealthReportExpired', 'PartitionReconfigured', 'PartitionPrimaryMoveAnalysis',
 * 'ServiceCreated', 'ServiceDeleted', 'ServiceNewHealthReport', 'ServiceHealthReportExpired',
 * 'DeployedServicePackageNewHealthReport', 'DeployedServicePackageHealthReportExpired',
 * 'StatefulReplicaNewHealthReport', 'StatefulReplicaHealthReportExpired',
 * 'StatelessReplicaNewHealthReport', 'StatelessReplicaHealthReportExpired',
 * 'ClusterNewHealthReport', 'ClusterHealthReportExpired', 'ClusterUpgradeCompleted',
 * 'ClusterUpgradeDomainCompleted', 'ClusterUpgradeRollbackCompleted',
 * 'ClusterUpgradeRollbackStarted', 'ClusterUpgradeStarted', 'ChaosStopped', 'ChaosStarted',
 * 'ChaosCodePackageRestartScheduled', 'ChaosReplicaRemovalScheduled',
 * 'ChaosPartitionSecondaryMoveScheduled', 'ChaosPartitionPrimaryMoveScheduled',
 * 'ChaosReplicaRestartScheduled', 'ChaosNodeRestartScheduled'
 * @readonly
 * @enum {string}
 */
export type FabricEventKind = 'ClusterEvent' | 'ContainerInstanceEvent' | 'NodeEvent' | 'ApplicationEvent' | 'ServiceEvent' | 'PartitionEvent' | 'ReplicaEvent' | 'PartitionAnalysisEvent' | 'ApplicationCreated' | 'ApplicationDeleted' | 'ApplicationNewHealthReport' | 'ApplicationHealthReportExpired' | 'ApplicationUpgradeCompleted' | 'ApplicationUpgradeDomainCompleted' | 'ApplicationUpgradeRollbackCompleted' | 'ApplicationUpgradeRollbackStarted' | 'ApplicationUpgradeStarted' | 'DeployedApplicationNewHealthReport' | 'DeployedApplicationHealthReportExpired' | 'ApplicationProcessExited' | 'ApplicationContainerInstanceExited' | 'NodeAborted' | 'NodeAddedToCluster' | 'NodeClosed' | 'NodeDeactivateCompleted' | 'NodeDeactivateStarted' | 'NodeDown' | 'NodeNewHealthReport' | 'NodeHealthReportExpired' | 'NodeOpenSucceeded' | 'NodeOpenFailed' | 'NodeRemovedFromCluster' | 'NodeUp' | 'PartitionNewHealthReport' | 'PartitionHealthReportExpired' | 'PartitionReconfigured' | 'PartitionPrimaryMoveAnalysis' | 'ServiceCreated' | 'ServiceDeleted' | 'ServiceNewHealthReport' | 'ServiceHealthReportExpired' | 'DeployedServicePackageNewHealthReport' | 'DeployedServicePackageHealthReportExpired' | 'StatefulReplicaNewHealthReport' | 'StatefulReplicaHealthReportExpired' | 'StatelessReplicaNewHealthReport' | 'StatelessReplicaHealthReportExpired' | 'ClusterNewHealthReport' | 'ClusterHealthReportExpired' | 'ClusterUpgradeCompleted' | 'ClusterUpgradeDomainCompleted' | 'ClusterUpgradeRollbackCompleted' | 'ClusterUpgradeRollbackStarted' | 'ClusterUpgradeStarted' | 'ChaosStopped' | 'ChaosStarted' | 'ChaosCodePackageRestartScheduled' | 'ChaosReplicaRemovalScheduled' | 'ChaosPartitionSecondaryMoveScheduled' | 'ChaosPartitionPrimaryMoveScheduled' | 'ChaosReplicaRestartScheduled' | 'ChaosNodeRestartScheduled';

/**
 * Defines values for HealthEvaluationKind.
 * Possible values include: 'Invalid', 'Event', 'Replicas', 'Partitions',
 * 'DeployedServicePackages', 'DeployedApplications', 'Services', 'Nodes', 'Applications',
 * 'SystemApplication', 'UpgradeDomainDeployedApplications', 'UpgradeDomainNodes', 'Replica',
 * 'Partition', 'DeployedServicePackage', 'DeployedApplication', 'Service', 'Node', 'Application',
 * 'DeltaNodesCheck', 'UpgradeDomainDeltaNodesCheck', 'ApplicationTypeApplications'
 * @readonly
 * @enum {string}
 */
export type HealthEvaluationKind = 'Invalid' | 'Event' | 'Replicas' | 'Partitions' | 'DeployedServicePackages' | 'DeployedApplications' | 'Services' | 'Nodes' | 'Applications' | 'SystemApplication' | 'UpgradeDomainDeployedApplications' | 'UpgradeDomainNodes' | 'Replica' | 'Partition' | 'DeployedServicePackage' | 'DeployedApplication' | 'Service' | 'Node' | 'Application' | 'DeltaNodesCheck' | 'UpgradeDomainDeltaNodesCheck' | 'ApplicationTypeApplications';

/**
 * Defines values for NodeDeactivationIntent.
 * Possible values include: 'Invalid', 'Pause', 'Restart', 'RemoveData', 'RemoveNode'
 * @readonly
 * @enum {string}
 */
export type NodeDeactivationIntent = 'Invalid' | 'Pause' | 'Restart' | 'RemoveData' | 'RemoveNode';

/**
 * Defines values for NodeDeactivationStatus.
 * Possible values include: 'None', 'SafetyCheckInProgress', 'SafetyCheckComplete', 'Completed'
 * @readonly
 * @enum {string}
 */
export type NodeDeactivationStatus = 'None' | 'SafetyCheckInProgress' | 'SafetyCheckComplete' | 'Completed';

/**
 * Defines values for NodeDeactivationTaskType.
 * Possible values include: 'Invalid', 'Infrastructure', 'Repair', 'Client'
 * @readonly
 * @enum {string}
 */
export type NodeDeactivationTaskType = 'Invalid' | 'Infrastructure' | 'Repair' | 'Client';

/**
 * Defines values for NodeStatus.
 * Possible values include: 'Invalid', 'Up', 'Down', 'Enabling', 'Disabling', 'Disabled',
 * 'Unknown', 'Removed'
 * @readonly
 * @enum {string}
 */
export type NodeStatus = 'Invalid' | 'Up' | 'Down' | 'Enabling' | 'Disabling' | 'Disabled' | 'Unknown' | 'Removed';

/**
 * Defines values for ServicePartitionStatus.
 * Possible values include: 'Invalid', 'Ready', 'NotReady', 'InQuorumLoss', 'Reconfiguring',
 * 'Deleting'
 * @readonly
 * @enum {string}
 */
export type ServicePartitionStatus = 'Invalid' | 'Ready' | 'NotReady' | 'InQuorumLoss' | 'Reconfiguring' | 'Deleting';

/**
 * Defines values for ServiceStatus.
 * Possible values include: 'Unknown', 'Active', 'Upgrading', 'Deleting', 'Creating', 'Failed'
 * @readonly
 * @enum {string}
 */
export type ServiceStatus = 'Unknown' | 'Active' | 'Upgrading' | 'Deleting' | 'Creating' | 'Failed';

/**
 * Defines values for ProvisionApplicationTypeKind.
 * Possible values include: 'Invalid', 'ImageStorePath', 'ExternalStore'
 * @readonly
 * @enum {string}
 */
export type ProvisionApplicationTypeKind = 'Invalid' | 'ImageStorePath' | 'ExternalStore';

/**
 * Defines values for UpgradeType.
 * Possible values include: 'Invalid', 'Rolling', 'Rolling_ForceRestart'
 * @readonly
 * @enum {string}
 */
export type UpgradeType = 'Invalid' | 'Rolling' | 'Rolling_ForceRestart';

/**
 * Defines values for SafetyCheckKind.
 * Possible values include: 'Invalid', 'EnsureSeedNodeQuorum', 'EnsurePartitionQuorum',
 * 'WaitForPrimaryPlacement', 'WaitForPrimarySwap', 'WaitForReconfiguration',
 * 'WaitForInbuildReplica', 'EnsureAvailability'
 * @readonly
 * @enum {string}
 */
export type SafetyCheckKind = 'Invalid' | 'EnsureSeedNodeQuorum' | 'EnsurePartitionQuorum' | 'WaitForPrimaryPlacement' | 'WaitForPrimarySwap' | 'WaitForReconfiguration' | 'WaitForInbuildReplica' | 'EnsureAvailability';

/**
 * Defines values for CreateFabricDump.
 * Possible values include: 'False', 'True'
 * @readonly
 * @enum {string}
 */
export type CreateFabricDump = 'False' | 'True';

/**
 * Defines values for ServicePackageActivationMode.
 * Possible values include: 'SharedProcess', 'ExclusiveProcess'
 * @readonly
 * @enum {string}
 */
export type ServicePackageActivationMode = 'SharedProcess' | 'ExclusiveProcess';

/**
 * Defines values for ServiceKind.
 * Possible values include: 'Invalid', 'Stateless', 'Stateful'
 * @readonly
 * @enum {string}
 */
export type ServiceKind = 'Invalid' | 'Stateless' | 'Stateful';

/**
 * Defines values for ServicePartitionKind.
 * Possible values include: 'Invalid', 'Singleton', 'Int64Range', 'Named'
 * @readonly
 * @enum {string}
 */
export type ServicePartitionKind = 'Invalid' | 'Singleton' | 'Int64Range' | 'Named';

/**
 * Defines values for ServicePlacementPolicyType.
 * Possible values include: 'Invalid', 'InvalidDomain', 'RequireDomain', 'PreferPrimaryDomain',
 * 'RequireDomainDistribution', 'NonPartiallyPlaceService'
 * @readonly
 * @enum {string}
 */
export type ServicePlacementPolicyType = 'Invalid' | 'InvalidDomain' | 'RequireDomain' | 'PreferPrimaryDomain' | 'RequireDomainDistribution' | 'NonPartiallyPlaceService';

/**
 * Defines values for ServiceLoadMetricWeight.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High'
 * @readonly
 * @enum {string}
 */
export type ServiceLoadMetricWeight = 'Zero' | 'Low' | 'Medium' | 'High';

/**
 * Defines values for HostType.
 * Possible values include: 'Invalid', 'ExeHost', 'ContainerHost'
 * @readonly
 * @enum {string}
 */
export type HostType = 'Invalid' | 'ExeHost' | 'ContainerHost';

/**
 * Defines values for HostIsolationMode.
 * Possible values include: 'None', 'Process', 'HyperV'
 * @readonly
 * @enum {string}
 */
export type HostIsolationMode = 'None' | 'Process' | 'HyperV';

/**
 * Defines values for DeploymentStatus.
 * Possible values include: 'Invalid', 'Downloading', 'Activating', 'Active', 'Upgrading',
 * 'Deactivating', 'RanToCompletion', 'Failed'
 * @readonly
 * @enum {string}
 */
export type DeploymentStatus = 'Invalid' | 'Downloading' | 'Activating' | 'Active' | 'Upgrading' | 'Deactivating' | 'RanToCompletion' | 'Failed';

/**
 * Defines values for EntryPointStatus.
 * Possible values include: 'Invalid', 'Pending', 'Starting', 'Started', 'Stopping', 'Stopped'
 * @readonly
 * @enum {string}
 */
export type EntryPointStatus = 'Invalid' | 'Pending' | 'Starting' | 'Started' | 'Stopping' | 'Stopped';

/**
 * Defines values for ChaosStatus.
 * Possible values include: 'Invalid', 'Running', 'Stopped'
 * @readonly
 * @enum {string}
 */
export type ChaosStatus = 'Invalid' | 'Running' | 'Stopped';

/**
 * Defines values for ChaosScheduleStatus.
 * Possible values include: 'Invalid', 'Stopped', 'Active', 'Expired', 'Pending'
 * @readonly
 * @enum {string}
 */
export type ChaosScheduleStatus = 'Invalid' | 'Stopped' | 'Active' | 'Expired' | 'Pending';

/**
 * Defines values for ChaosEventKind.
 * Possible values include: 'Invalid', 'Started', 'ExecutingFaults', 'Waiting', 'ValidationFailed',
 * 'TestError', 'Stopped'
 * @readonly
 * @enum {string}
 */
export type ChaosEventKind = 'Invalid' | 'Started' | 'ExecutingFaults' | 'Waiting' | 'ValidationFailed' | 'TestError' | 'Stopped';

/**
 * Defines values for ComposeDeploymentStatus.
 * Possible values include: 'Invalid', 'Provisioning', 'Creating', 'Ready', 'Unprovisioning',
 * 'Deleting', 'Failed', 'Upgrading'
 * @readonly
 * @enum {string}
 */
export type ComposeDeploymentStatus = 'Invalid' | 'Provisioning' | 'Creating' | 'Ready' | 'Unprovisioning' | 'Deleting' | 'Failed' | 'Upgrading';

/**
 * Defines values for ComposeDeploymentUpgradeState.
 * Possible values include: 'Invalid', 'ProvisioningTarget', 'RollingForwardInProgress',
 * 'RollingForwardPending', 'UnprovisioningCurrent', 'RollingForwardCompleted',
 * 'RollingBackInProgress', 'UnprovisioningTarget', 'RollingBackCompleted', 'Failed'
 * @readonly
 * @enum {string}
 */
export type ComposeDeploymentUpgradeState = 'Invalid' | 'ProvisioningTarget' | 'RollingForwardInProgress' | 'RollingForwardPending' | 'UnprovisioningCurrent' | 'RollingForwardCompleted' | 'RollingBackInProgress' | 'UnprovisioningTarget' | 'RollingBackCompleted' | 'Failed';

/**
 * Defines values for ServiceCorrelationScheme.
 * Possible values include: 'Invalid', 'Affinity', 'AlignedAffinity', 'NonAlignedAffinity'
 * @readonly
 * @enum {string}
 */
export type ServiceCorrelationScheme = 'Invalid' | 'Affinity' | 'AlignedAffinity' | 'NonAlignedAffinity';

/**
 * Defines values for MoveCost.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High', 'VeryHigh'
 * @readonly
 * @enum {string}
 */
export type MoveCost = 'Zero' | 'Low' | 'Medium' | 'High' | 'VeryHigh';

/**
 * Defines values for PartitionScheme.
 * Possible values include: 'Invalid', 'Singleton', 'UniformInt64Range', 'Named'
 * @readonly
 * @enum {string}
 */
export type PartitionScheme = 'Invalid' | 'Singleton' | 'UniformInt64Range' | 'Named';

/**
 * Defines values for ServiceOperationName.
 * Possible values include: 'Unknown', 'None', 'Open', 'ChangeRole', 'Close', 'Abort'
 * @readonly
 * @enum {string}
 */
export type ServiceOperationName = 'Unknown' | 'None' | 'Open' | 'ChangeRole' | 'Close' | 'Abort';

/**
 * Defines values for ReplicatorOperationName.
 * Possible values include: 'Invalid', 'None', 'Open', 'ChangeRole', 'UpdateEpoch', 'Close',
 * 'Abort', 'OnDataLoss', 'WaitForCatchup', 'Build'
 * @readonly
 * @enum {string}
 */
export type ReplicatorOperationName = 'Invalid' | 'None' | 'Open' | 'ChangeRole' | 'UpdateEpoch' | 'Close' | 'Abort' | 'OnDataLoss' | 'WaitForCatchup' | 'Build';

/**
 * Defines values for PartitionAccessStatus.
 * Possible values include: 'Invalid', 'Granted', 'ReconfigurationPending', 'NotPrimary',
 * 'NoWriteQuorum'
 * @readonly
 * @enum {string}
 */
export type PartitionAccessStatus = 'Invalid' | 'Granted' | 'ReconfigurationPending' | 'NotPrimary' | 'NoWriteQuorum';

/**
 * Defines values for FabricReplicaStatus.
 * Possible values include: 'Invalid', 'Down', 'Up'
 * @readonly
 * @enum {string}
 */
export type FabricReplicaStatus = 'Invalid' | 'Down' | 'Up';

/**
 * Defines values for ReplicaKind.
 * Possible values include: 'Invalid', 'KeyValueStore'
 * @readonly
 * @enum {string}
 */
export type ReplicaKind = 'Invalid' | 'KeyValueStore';

/**
 * Defines values for ServiceTypeRegistrationStatus.
 * Possible values include: 'Invalid', 'Disabled', 'Enabled', 'Registered'
 * @readonly
 * @enum {string}
 */
export type ServiceTypeRegistrationStatus = 'Invalid' | 'Disabled' | 'Enabled' | 'Registered';

/**
 * Defines values for ServiceEndpointRole.
 * Possible values include: 'Invalid', 'Stateless', 'StatefulPrimary', 'StatefulSecondary'
 * @readonly
 * @enum {string}
 */
export type ServiceEndpointRole = 'Invalid' | 'Stateless' | 'StatefulPrimary' | 'StatefulSecondary';

/**
 * Defines values for OperationState.
 * Possible values include: 'Invalid', 'Running', 'RollingBack', 'Completed', 'Faulted',
 * 'Cancelled', 'ForceCancelled'
 * @readonly
 * @enum {string}
 */
export type OperationState = 'Invalid' | 'Running' | 'RollingBack' | 'Completed' | 'Faulted' | 'Cancelled' | 'ForceCancelled';

/**
 * Defines values for OperationType.
 * Possible values include: 'Invalid', 'PartitionDataLoss', 'PartitionQuorumLoss',
 * 'PartitionRestart', 'NodeTransition'
 * @readonly
 * @enum {string}
 */
export type OperationType = 'Invalid' | 'PartitionDataLoss' | 'PartitionQuorumLoss' | 'PartitionRestart' | 'NodeTransition';

/**
 * Defines values for PackageSharingPolicyScope.
 * Possible values include: 'None', 'All', 'Code', 'Config', 'Data'
 * @readonly
 * @enum {string}
 */
export type PackageSharingPolicyScope = 'None' | 'All' | 'Code' | 'Config' | 'Data';

/**
 * Defines values for PropertyValueKind.
 * Possible values include: 'Invalid', 'Binary', 'Int64', 'Double', 'String', 'Guid'
 * @readonly
 * @enum {string}
 */
export type PropertyValueKind = 'Invalid' | 'Binary' | 'Int64' | 'Double' | 'String' | 'Guid';

/**
 * Defines values for PropertyBatchOperationKind.
 * Possible values include: 'Invalid', 'Put', 'Get', 'CheckExists', 'CheckSequence', 'Delete',
 * 'CheckValue'
 * @readonly
 * @enum {string}
 */
export type PropertyBatchOperationKind = 'Invalid' | 'Put' | 'Get' | 'CheckExists' | 'CheckSequence' | 'Delete' | 'CheckValue';

/**
 * Defines values for PropertyBatchInfoKind.
 * Possible values include: 'Invalid', 'Successful', 'Failed'
 * @readonly
 * @enum {string}
 */
export type PropertyBatchInfoKind = 'Invalid' | 'Successful' | 'Failed';

/**
 * Defines values for RetentionPolicyType.
 * Possible values include: 'Basic', 'Invalid'
 * @readonly
 * @enum {string}
 */
export type RetentionPolicyType = 'Basic' | 'Invalid';

/**
 * Defines values for BackupStorageKind.
 * Possible values include: 'Invalid', 'FileShare', 'AzureBlobStore'
 * @readonly
 * @enum {string}
 */
export type BackupStorageKind = 'Invalid' | 'FileShare' | 'AzureBlobStore';

/**
 * Defines values for BackupScheduleKind.
 * Possible values include: 'Invalid', 'TimeBased', 'FrequencyBased'
 * @readonly
 * @enum {string}
 */
export type BackupScheduleKind = 'Invalid' | 'TimeBased' | 'FrequencyBased';

/**
 * Defines values for BackupPolicyScope.
 * Possible values include: 'Invalid', 'Partition', 'Service', 'Application'
 * @readonly
 * @enum {string}
 */
export type BackupPolicyScope = 'Invalid' | 'Partition' | 'Service' | 'Application';

/**
 * Defines values for BackupSuspensionScope.
 * Possible values include: 'Invalid', 'Partition', 'Service', 'Application'
 * @readonly
 * @enum {string}
 */
export type BackupSuspensionScope = 'Invalid' | 'Partition' | 'Service' | 'Application';

/**
 * Defines values for RestoreState.
 * Possible values include: 'Invalid', 'Accepted', 'RestoreInProgress', 'Success', 'Failure',
 * 'Timeout'
 * @readonly
 * @enum {string}
 */
export type RestoreState = 'Invalid' | 'Accepted' | 'RestoreInProgress' | 'Success' | 'Failure' | 'Timeout';

/**
 * Defines values for BackupType.
 * Possible values include: 'Invalid', 'Full', 'Incremental'
 * @readonly
 * @enum {string}
 */
export type BackupType = 'Invalid' | 'Full' | 'Incremental';

/**
 * Defines values for BackupScheduleFrequencyType.
 * Possible values include: 'Invalid', 'Daily', 'Weekly'
 * @readonly
 * @enum {string}
 */
export type BackupScheduleFrequencyType = 'Invalid' | 'Daily' | 'Weekly';

/**
 * Defines values for DayOfWeek.
 * Possible values include: 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
 * 'Saturday'
 * @readonly
 * @enum {string}
 */
export type DayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';

/**
 * Defines values for BackupState.
 * Possible values include: 'Invalid', 'Accepted', 'BackupInProgress', 'Success', 'Failure',
 * 'Timeout'
 * @readonly
 * @enum {string}
 */
export type BackupState = 'Invalid' | 'Accepted' | 'BackupInProgress' | 'Success' | 'Failure' | 'Timeout';

/**
 * Defines values for BackupEntityKind.
 * Possible values include: 'Invalid', 'Partition', 'Service', 'Application'
 * @readonly
 * @enum {string}
 */
export type BackupEntityKind = 'Invalid' | 'Partition' | 'Service' | 'Application';

/**
 * Defines values for ImpactLevel.
 * Possible values include: 'Invalid', 'None', 'Restart', 'RemoveData', 'RemoveNode'
 * @readonly
 * @enum {string}
 */
export type ImpactLevel = 'Invalid' | 'None' | 'Restart' | 'RemoveData' | 'RemoveNode';

/**
 * Defines values for RepairImpactKind.
 * Possible values include: 'Invalid', 'Node'
 * @readonly
 * @enum {string}
 */
export type RepairImpactKind = 'Invalid' | 'Node';

/**
 * Defines values for RepairTargetKind.
 * Possible values include: 'Invalid', 'Node'
 * @readonly
 * @enum {string}
 */
export type RepairTargetKind = 'Invalid' | 'Node';

/**
 * Defines values for State.
 * Possible values include: 'Invalid', 'Created', 'Claimed', 'Preparing', 'Approved', 'Executing',
 * 'Restoring', 'Completed'
 * @readonly
 * @enum {string}
 */
export type State = 'Invalid' | 'Created' | 'Claimed' | 'Preparing' | 'Approved' | 'Executing' | 'Restoring' | 'Completed';

/**
 * Defines values for ResultStatus.
 * Possible values include: 'Invalid', 'Succeeded', 'Cancelled', 'Interrupted', 'Failed', 'Pending'
 * @readonly
 * @enum {string}
 */
export type ResultStatus = 'Invalid' | 'Succeeded' | 'Cancelled' | 'Interrupted' | 'Failed' | 'Pending';

/**
 * Defines values for RepairTaskHealthCheckState.
 * Possible values include: 'NotStarted', 'InProgress', 'Succeeded', 'Skipped', 'TimedOut'
 * @readonly
 * @enum {string}
 */
export type RepairTaskHealthCheckState = 'NotStarted' | 'InProgress' | 'Succeeded' | 'Skipped' | 'TimedOut';

/**
 * Defines values for ScalingTriggerKind.
 * Possible values include: 'Invalid', 'AveragePartitionLoad', 'AverageServiceLoad'
 * @readonly
 * @enum {string}
 */
export type ScalingTriggerKind = 'Invalid' | 'AveragePartitionLoad' | 'AverageServiceLoad';

/**
 * Defines values for ScalingMechanismKind.
 * Possible values include: 'Invalid', 'PartitionInstanceCount',
 * 'AddRemoveIncrementalNamedPartition'
 * @readonly
 * @enum {string}
 */
export type ScalingMechanismKind = 'Invalid' | 'PartitionInstanceCount' | 'AddRemoveIncrementalNamedPartition';

/**
 * Defines values for ResourceStatus.
 * Possible values include: 'Unknown', 'Ready', 'Upgrading', 'Creating', 'Deleting', 'Failed'
 * @readonly
 * @enum {string}
 */
export type ResourceStatus = 'Unknown' | 'Ready' | 'Upgrading' | 'Creating' | 'Deleting' | 'Failed';

/**
 * Defines values for SecretKind.
 * Possible values include: 'inlinedValue', 'keyVaultVersionedReference'
 * @readonly
 * @enum {string}
 */
export type SecretKind = 'inlinedValue' | 'keyVaultVersionedReference';

/**
 * Defines values for VolumeProvider.
 * Possible values include: 'SFAzureFile'
 * @readonly
 * @enum {string}
 */
export type VolumeProvider = 'SFAzureFile';

/**
 * Defines values for SizeTypes.
 * Possible values include: 'Small', 'Medium', 'Large'
 * @readonly
 * @enum {string}
 */
export type SizeTypes = 'Small' | 'Medium' | 'Large';

/**
 * Defines values for ApplicationScopedVolumeKind.
 * Possible values include: 'ServiceFabricVolumeDisk'
 * @readonly
 * @enum {string}
 */
export type ApplicationScopedVolumeKind = 'ServiceFabricVolumeDisk';

/**
 * Defines values for NetworkKind.
 * Possible values include: 'Local'
 * @readonly
 * @enum {string}
 */
export type NetworkKind = 'Local';

/**
 * Defines values for HeaderMatchType.
 * Possible values include: 'exact'
 * @readonly
 * @enum {string}
 */
export type HeaderMatchType = 'exact';

/**
 * Defines values for OperatingSystemType.
 * Possible values include: 'Linux', 'Windows'
 * @readonly
 * @enum {string}
 */
export type OperatingSystemType = 'Linux' | 'Windows';

/**
 * Defines values for ImageRegistryPasswordType.
 * Possible values include: 'ClearText', 'KeyVaultReference', 'SecretValueReference'
 * @readonly
 * @enum {string}
 */
export type ImageRegistryPasswordType = 'ClearText' | 'KeyVaultReference' | 'SecretValueReference';

/**
 * Defines values for EnvironmentVariableType.
 * Possible values include: 'ClearText', 'KeyVaultReference', 'SecretValueReference'
 * @readonly
 * @enum {string}
 */
export type EnvironmentVariableType = 'ClearText' | 'KeyVaultReference' | 'SecretValueReference';

/**
 * Defines values for SettingType.
 * Possible values include: 'ClearText', 'KeyVaultReference', 'SecretValueReference'
 * @readonly
 * @enum {string}
 */
export type SettingType = 'ClearText' | 'KeyVaultReference' | 'SecretValueReference';

/**
 * Defines values for Scheme.
 * Possible values include: 'http', 'https'
 * @readonly
 * @enum {string}
 */
export type Scheme = 'http' | 'https';

/**
 * Defines values for ApplicationResourceUpgradeState.
 * Possible values include: 'Invalid', 'ProvisioningTarget', 'RollingForward',
 * 'UnprovisioningCurrent', 'CompletedRollforward', 'RollingBack', 'UnprovisioningTarget',
 * 'CompletedRollback', 'Failed'
 * @readonly
 * @enum {string}
 */
export type ApplicationResourceUpgradeState = 'Invalid' | 'ProvisioningTarget' | 'RollingForward' | 'UnprovisioningCurrent' | 'CompletedRollforward' | 'RollingBack' | 'UnprovisioningTarget' | 'CompletedRollback' | 'Failed';

/**
 * Defines values for RollingUpgradeMode.
 * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 * @readonly
 * @enum {string}
 */
export type RollingUpgradeMode = 'Invalid' | 'UnmonitoredAuto' | 'UnmonitoredManual' | 'Monitored';

/**
 * Defines values for DiagnosticsSinkKind.
 * Possible values include: 'Invalid', 'AzureInternalMonitoringPipeline'
 * @readonly
 * @enum {string}
 */
export type DiagnosticsSinkKind = 'Invalid' | 'AzureInternalMonitoringPipeline';

/**
 * Defines values for AutoScalingMechanismKind.
 * Possible values include: 'AddRemoveReplica'
 * @readonly
 * @enum {string}
 */
export type AutoScalingMechanismKind = 'AddRemoveReplica';

/**
 * Defines values for AutoScalingMetricKind.
 * Possible values include: 'Resource'
 * @readonly
 * @enum {string}
 */
export type AutoScalingMetricKind = 'Resource';

/**
 * Defines values for AutoScalingResourceMetricName.
 * Possible values include: 'cpu', 'memoryInGB'
 * @readonly
 * @enum {string}
 */
export type AutoScalingResourceMetricName = 'cpu' | 'memoryInGB';

/**
 * Defines values for AutoScalingTriggerKind.
 * Possible values include: 'AverageLoad'
 * @readonly
 * @enum {string}
 */
export type AutoScalingTriggerKind = 'AverageLoad';

/**
 * Defines values for ExecutionPolicyType.
 * Possible values include: 'Default', 'RunToCompletion'
 * @readonly
 * @enum {string}
 */
export type ExecutionPolicyType = 'Default' | 'RunToCompletion';

/**
 * Defines values for RestartPolicy.
 * Possible values include: 'OnFailure', 'Never'
 * @readonly
 * @enum {string}
 */
export type RestartPolicy = 'OnFailure' | 'Never';

/**
 * Defines values for NodeStatusFilter.
 * Possible values include: 'default', 'all', 'up', 'down', 'enabling', 'disabling', 'disabled',
 * 'unknown', 'removed'
 * @readonly
 * @enum {string}
 */
export type NodeStatusFilter = 'default' | 'all' | 'up' | 'down' | 'enabling' | 'disabling' | 'disabled' | 'unknown' | 'removed';

/**
 * Defines values for ReplicaHealthReportServiceKind.
 * Possible values include: 'Stateless', 'Stateful'
 * @readonly
 * @enum {string}
 */
export type ReplicaHealthReportServiceKind = 'Stateless' | 'Stateful';

/**
 * Defines values for DataLossMode.
 * Possible values include: 'Invalid', 'PartialDataLoss', 'FullDataLoss'
 * @readonly
 * @enum {string}
 */
export type DataLossMode = 'Invalid' | 'PartialDataLoss' | 'FullDataLoss';

/**
 * Defines values for NodeTransitionType.
 * Possible values include: 'Invalid', 'Start', 'Stop'
 * @readonly
 * @enum {string}
 */
export type NodeTransitionType = 'Invalid' | 'Start' | 'Stop';

/**
 * Defines values for QuorumLossMode.
 * Possible values include: 'Invalid', 'QuorumReplicas', 'AllReplicas'
 * @readonly
 * @enum {string}
 */
export type QuorumLossMode = 'Invalid' | 'QuorumReplicas' | 'AllReplicas';

/**
 * Defines values for RestartPartitionMode.
 * Possible values include: 'Invalid', 'AllReplicasOrInstances', 'OnlyActiveSecondaries'
 * @readonly
 * @enum {string}
 */
export type RestartPartitionMode = 'Invalid' | 'AllReplicasOrInstances' | 'OnlyActiveSecondaries';

/**
 * Contains response data for the getClusterManifest operation.
 */
export type GetClusterManifestResponse = ClusterManifest & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterManifest;
    };
};

/**
 * Contains response data for the getClusterHealth operation.
 */
export type GetClusterHealthResponse = ClusterHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterHealth;
    };
};

/**
 * Contains response data for the getClusterHealthUsingPolicy operation.
 */
export type GetClusterHealthUsingPolicyResponse = ClusterHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterHealth;
    };
};

/**
 * Contains response data for the getClusterHealthChunk operation.
 */
export type GetClusterHealthChunkResponse = ClusterHealthChunk & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterHealthChunk;
    };
};

/**
 * Contains response data for the getClusterHealthChunkUsingPolicyAndAdvancedFilters operation.
 */
export type GetClusterHealthChunkUsingPolicyAndAdvancedFiltersResponse = ClusterHealthChunk & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterHealthChunk;
    };
};

/**
 * Contains response data for the getProvisionedFabricCodeVersionInfoList operation.
 */
export type GetProvisionedFabricCodeVersionInfoListResponse = Array<FabricCodeVersionInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FabricCodeVersionInfo[];
    };
};

/**
 * Contains response data for the getProvisionedFabricConfigVersionInfoList operation.
 */
export type GetProvisionedFabricConfigVersionInfoListResponse = Array<FabricConfigVersionInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FabricConfigVersionInfo[];
    };
};

/**
 * Contains response data for the getClusterUpgradeProgress operation.
 */
export type GetClusterUpgradeProgressResponse = ClusterUpgradeProgressObject & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterUpgradeProgressObject;
    };
};

/**
 * Contains response data for the getClusterConfiguration operation.
 */
export type GetClusterConfigurationResponse = ClusterConfiguration & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterConfiguration;
    };
};

/**
 * Contains response data for the getClusterConfigurationUpgradeStatus operation.
 */
export type GetClusterConfigurationUpgradeStatusResponse = ClusterConfigurationUpgradeStatusInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterConfigurationUpgradeStatusInfo;
    };
};

/**
 * Contains response data for the getUpgradeOrchestrationServiceState operation.
 */
export type GetUpgradeOrchestrationServiceStateResponse = UpgradeOrchestrationServiceState & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UpgradeOrchestrationServiceState;
    };
};

/**
 * Contains response data for the setUpgradeOrchestrationServiceState operation.
 */
export type SetUpgradeOrchestrationServiceStateResponse = UpgradeOrchestrationServiceStateSummary & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UpgradeOrchestrationServiceStateSummary;
    };
};

/**
 * Contains response data for the getAadMetadata operation.
 */
export type GetAadMetadataResponse = AadMetadataObject & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AadMetadataObject;
    };
};

/**
 * Contains response data for the getClusterVersion operation.
 */
export type GetClusterVersionResponse = ClusterVersion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterVersion;
    };
};

/**
 * Contains response data for the getClusterLoad operation.
 */
export type GetClusterLoadResponse = ClusterLoadInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterLoadInfo;
    };
};

/**
 * Contains response data for the getNodeInfoList operation.
 */
export type GetNodeInfoListResponse = PagedNodeInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedNodeInfoList;
    };
};

/**
 * Contains response data for the getNodeInfo operation.
 */
export type GetNodeInfoResponse = NodeInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeInfo;
    };
};

/**
 * Contains response data for the getNodeHealth operation.
 */
export type GetNodeHealthResponse = NodeHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeHealth;
    };
};

/**
 * Contains response data for the getNodeHealthUsingPolicy operation.
 */
export type GetNodeHealthUsingPolicyResponse = NodeHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeHealth;
    };
};

/**
 * Contains response data for the getNodeLoadInfo operation.
 */
export type GetNodeLoadInfoResponse = NodeLoadInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeLoadInfo;
    };
};

/**
 * Contains response data for the getConfigurationOverrides operation.
 */
export type GetConfigurationOverridesResponse = Array<ConfigParameterOverride> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ConfigParameterOverride[];
    };
};

/**
 * Contains response data for the getApplicationTypeInfoList operation.
 */
export type GetApplicationTypeInfoListResponse = PagedApplicationTypeInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedApplicationTypeInfoList;
    };
};

/**
 * Contains response data for the getApplicationTypeInfoListByName operation.
 */
export type GetApplicationTypeInfoListByNameResponse = PagedApplicationTypeInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedApplicationTypeInfoList;
    };
};

/**
 * Contains response data for the getServiceTypeInfoList operation.
 */
export type GetServiceTypeInfoListResponse = Array<ServiceTypeInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceTypeInfo[];
    };
};

/**
 * Contains response data for the getServiceTypeInfoByName operation.
 */
export type GetServiceTypeInfoByNameResponse = ServiceTypeInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceTypeInfo;
    };
};

/**
 * Contains response data for the getServiceManifest operation.
 */
export type GetServiceManifestResponse = ServiceTypeManifest & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceTypeManifest;
    };
};

/**
 * Contains response data for the getDeployedServiceTypeInfoList operation.
 */
export type GetDeployedServiceTypeInfoListResponse = Array<DeployedServiceTypeInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceTypeInfo[];
    };
};

/**
 * Contains response data for the getDeployedServiceTypeInfoByName operation.
 */
export type GetDeployedServiceTypeInfoByNameResponse = Array<DeployedServiceTypeInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceTypeInfo[];
    };
};

/**
 * Contains response data for the getApplicationLoadInfo operation.
 */
export type GetApplicationLoadInfoResponse = ApplicationLoadInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationLoadInfo;
    };
};

/**
 * Contains response data for the getApplicationInfoList operation.
 */
export type GetApplicationInfoListResponse = PagedApplicationInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedApplicationInfoList;
    };
};

/**
 * Contains response data for the getApplicationInfo operation.
 */
export type GetApplicationInfoResponse = ApplicationInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationInfo;
    };
};

/**
 * Contains response data for the getApplicationHealth operation.
 */
export type GetApplicationHealthResponse = ApplicationHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationHealth;
    };
};

/**
 * Contains response data for the getApplicationHealthUsingPolicy operation.
 */
export type GetApplicationHealthUsingPolicyResponse = ApplicationHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationHealth;
    };
};

/**
 * Contains response data for the getApplicationUpgrade operation.
 */
export type GetApplicationUpgradeResponse = ApplicationUpgradeProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationUpgradeProgressInfo;
    };
};

/**
 * Contains response data for the getDeployedApplicationInfoList operation.
 */
export type GetDeployedApplicationInfoListResponse = PagedDeployedApplicationInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedDeployedApplicationInfoList;
    };
};

/**
 * Contains response data for the getDeployedApplicationInfo operation.
 */
export type GetDeployedApplicationInfoResponse = DeployedApplicationInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedApplicationInfo;
    };
};

/**
 * Contains response data for the getDeployedApplicationHealth operation.
 */
export type GetDeployedApplicationHealthResponse = DeployedApplicationHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedApplicationHealth;
    };
};

/**
 * Contains response data for the getDeployedApplicationHealthUsingPolicy operation.
 */
export type GetDeployedApplicationHealthUsingPolicyResponse = DeployedApplicationHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedApplicationHealth;
    };
};

/**
 * Contains response data for the getApplicationManifest operation.
 */
export type GetApplicationManifestResponse = ApplicationTypeManifest & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeManifest;
    };
};

/**
 * Contains response data for the getServiceInfoList operation.
 */
export type GetServiceInfoListResponse = PagedServiceInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedServiceInfoList;
    };
};

/**
 * Contains response data for the getServiceInfo operation.
 */
export type GetServiceInfoResponse = ServiceInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceInfoUnion;
    };
};

/**
 * Contains response data for the getApplicationNameInfo operation.
 */
export type GetApplicationNameInfoResponse = ApplicationNameInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationNameInfo;
    };
};

/**
 * Contains response data for the getServiceDescription operation.
 */
export type GetServiceDescriptionResponse = ServiceDescriptionUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceDescriptionUnion;
    };
};

/**
 * Contains response data for the getServiceHealth operation.
 */
export type GetServiceHealthResponse = ServiceHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceHealth;
    };
};

/**
 * Contains response data for the getServiceHealthUsingPolicy operation.
 */
export type GetServiceHealthUsingPolicyResponse = ServiceHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceHealth;
    };
};

/**
 * Contains response data for the resolveService operation.
 */
export type ResolveServiceResponse = ResolvedServicePartition & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ResolvedServicePartition;
    };
};

/**
 * Contains response data for the getUnplacedReplicaInformation operation.
 */
export type GetUnplacedReplicaInformationResponse = UnplacedReplicaInformation & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UnplacedReplicaInformation;
    };
};

/**
 * Contains response data for the getPartitionInfoList operation.
 */
export type GetPartitionInfoListResponse = PagedServicePartitionInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedServicePartitionInfoList;
    };
};

/**
 * Contains response data for the getPartitionInfo operation.
 */
export type GetPartitionInfoResponse = ServicePartitionInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServicePartitionInfoUnion;
    };
};

/**
 * Contains response data for the getServiceNameInfo operation.
 */
export type GetServiceNameInfoResponse = ServiceNameInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceNameInfo;
    };
};

/**
 * Contains response data for the getPartitionHealth operation.
 */
export type GetPartitionHealthResponse = PartitionHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionHealth;
    };
};

/**
 * Contains response data for the getPartitionHealthUsingPolicy operation.
 */
export type GetPartitionHealthUsingPolicyResponse = PartitionHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionHealth;
    };
};

/**
 * Contains response data for the getPartitionLoadInformation operation.
 */
export type GetPartitionLoadInformationResponse = PartitionLoadInformation & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionLoadInformation;
    };
};

/**
 * Contains response data for the createRepairTask operation.
 */
export type CreateRepairTaskResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the cancelRepairTask operation.
 */
export type CancelRepairTaskResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the getRepairTaskList operation.
 */
export type GetRepairTaskListResponse = Array<RepairTask> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTask[];
    };
};

/**
 * Contains response data for the forceApproveRepairTask operation.
 */
export type ForceApproveRepairTaskResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the updateRepairTaskHealthPolicy operation.
 */
export type UpdateRepairTaskHealthPolicyResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the updateRepairExecutionState operation.
 */
export type UpdateRepairExecutionStateResponse = RepairTaskUpdateInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RepairTaskUpdateInfo;
    };
};

/**
 * Contains response data for the getReplicaInfoList operation.
 */
export type GetReplicaInfoListResponse = PagedReplicaInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedReplicaInfoList;
    };
};

/**
 * Contains response data for the getReplicaInfo operation.
 */
export type GetReplicaInfoResponse = ReplicaInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaInfoUnion;
    };
};

/**
 * Contains response data for the getReplicaHealth operation.
 */
export type GetReplicaHealthResponse = ReplicaHealthUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaHealthUnion;
    };
};

/**
 * Contains response data for the getReplicaHealthUsingPolicy operation.
 */
export type GetReplicaHealthUsingPolicyResponse = ReplicaHealthUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaHealthUnion;
    };
};

/**
 * Contains response data for the getDeployedServiceReplicaInfoList operation.
 */
export type GetDeployedServiceReplicaInfoListResponse = Array<DeployedServiceReplicaInfoUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceReplicaInfoUnion[];
    };
};

/**
 * Contains response data for the getDeployedServiceReplicaDetailInfo operation.
 */
export type GetDeployedServiceReplicaDetailInfoResponse = DeployedServiceReplicaDetailInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceReplicaDetailInfoUnion;
    };
};

/**
 * Contains response data for the getDeployedServiceReplicaDetailInfoByPartitionId operation.
 */
export type GetDeployedServiceReplicaDetailInfoByPartitionIdResponse = DeployedServiceReplicaDetailInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServiceReplicaDetailInfoUnion;
    };
};

/**
 * Contains response data for the getDeployedServicePackageInfoList operation.
 */
export type GetDeployedServicePackageInfoListResponse = Array<DeployedServicePackageInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServicePackageInfo[];
    };
};

/**
 * Contains response data for the getDeployedServicePackageInfoListByName operation.
 */
export type GetDeployedServicePackageInfoListByNameResponse = Array<DeployedServicePackageInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServicePackageInfo[];
    };
};

/**
 * Contains response data for the getDeployedServicePackageHealth operation.
 */
export type GetDeployedServicePackageHealthResponse = DeployedServicePackageHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServicePackageHealth;
    };
};

/**
 * Contains response data for the getDeployedServicePackageHealthUsingPolicy operation.
 */
export type GetDeployedServicePackageHealthUsingPolicyResponse = DeployedServicePackageHealth & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedServicePackageHealth;
    };
};

/**
 * Contains response data for the getDeployedCodePackageInfoList operation.
 */
export type GetDeployedCodePackageInfoListResponse = Array<DeployedCodePackageInfo> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: DeployedCodePackageInfo[];
    };
};

/**
 * Contains response data for the getContainerLogsDeployedOnNode operation.
 */
export type GetContainerLogsDeployedOnNodeResponse = ContainerLogs & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContainerLogs;
    };
};

/**
 * Contains response data for the invokeContainerApi operation.
 */
export type InvokeContainerApiResponse = ContainerApiResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContainerApiResponse;
    };
};

/**
 * Contains response data for the getComposeDeploymentStatus operation.
 */
export type GetComposeDeploymentStatusResponse = ComposeDeploymentStatusInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ComposeDeploymentStatusInfo;
    };
};

/**
 * Contains response data for the getComposeDeploymentStatusList operation.
 */
export type GetComposeDeploymentStatusListResponse = PagedComposeDeploymentStatusInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedComposeDeploymentStatusInfoList;
    };
};

/**
 * Contains response data for the getComposeDeploymentUpgradeProgress operation.
 */
export type GetComposeDeploymentUpgradeProgressResponse = ComposeDeploymentUpgradeProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ComposeDeploymentUpgradeProgressInfo;
    };
};

/**
 * Contains response data for the getChaos operation.
 */
export type GetChaosResponse = Chaos & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Chaos;
    };
};

/**
 * Contains response data for the getChaosEvents operation.
 */
export type GetChaosEventsResponse = ChaosEventsSegment & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ChaosEventsSegment;
    };
};

/**
 * Contains response data for the getChaosSchedule operation.
 */
export type GetChaosScheduleResponse = ChaosScheduleDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ChaosScheduleDescription;
    };
};

/**
 * Contains response data for the getImageStoreContent operation.
 */
export type GetImageStoreContentResponse = ImageStoreContent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ImageStoreContent;
    };
};

/**
 * Contains response data for the getImageStoreRootContent operation.
 */
export type GetImageStoreRootContentResponse = ImageStoreContent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ImageStoreContent;
    };
};

/**
 * Contains response data for the getImageStoreUploadSessionById operation.
 */
export type GetImageStoreUploadSessionByIdResponse = UploadSession & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UploadSession;
    };
};

/**
 * Contains response data for the getImageStoreUploadSessionByPath operation.
 */
export type GetImageStoreUploadSessionByPathResponse = UploadSession & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: UploadSession;
    };
};

/**
 * Contains response data for the getImageStoreRootFolderSize operation.
 */
export type GetImageStoreRootFolderSizeResponse = FolderSizeInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FolderSizeInfo;
    };
};

/**
 * Contains response data for the getImageStoreFolderSize operation.
 */
export type GetImageStoreFolderSizeResponse = FolderSizeInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FolderSizeInfo;
    };
};

/**
 * Contains response data for the getImageStoreInfo operation.
 */
export type GetImageStoreInfoResponse = ImageStoreInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ImageStoreInfo;
    };
};

/**
 * Contains response data for the invokeInfrastructureCommand operation.
 */
export type InvokeInfrastructureCommandResponse = {
  /**
   * The parsed response body.
   */
  body: string;

  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: string;
    };
};

/**
 * Contains response data for the invokeInfrastructureQuery operation.
 */
export type InvokeInfrastructureQueryResponse = {
  /**
   * The parsed response body.
   */
  body: string;

  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: string;
    };
};

/**
 * Contains response data for the getDataLossProgress operation.
 */
export type GetDataLossProgressResponse = PartitionDataLossProgress & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionDataLossProgress;
    };
};

/**
 * Contains response data for the getQuorumLossProgress operation.
 */
export type GetQuorumLossProgressResponse = PartitionQuorumLossProgress & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionQuorumLossProgress;
    };
};

/**
 * Contains response data for the getPartitionRestartProgress operation.
 */
export type GetPartitionRestartProgressResponse = PartitionRestartProgress & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionRestartProgress;
    };
};

/**
 * Contains response data for the getNodeTransitionProgress operation.
 */
export type GetNodeTransitionProgressResponse = NodeTransitionProgress & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeTransitionProgress;
    };
};

/**
 * Contains response data for the getFaultOperationList operation.
 */
export type GetFaultOperationListResponse = Array<OperationStatus> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationStatus[];
    };
};

/**
 * Contains response data for the getBackupPolicyList operation.
 */
export type GetBackupPolicyListResponse = PagedBackupPolicyDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupPolicyDescriptionList;
    };
};

/**
 * Contains response data for the getBackupPolicyByName operation.
 */
export type GetBackupPolicyByNameResponse = BackupPolicyDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: BackupPolicyDescription;
    };
};

/**
 * Contains response data for the getAllEntitiesBackedUpByPolicy operation.
 */
export type GetAllEntitiesBackedUpByPolicyResponse = PagedBackupEntityList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupEntityList;
    };
};

/**
 * Contains response data for the getApplicationBackupConfigurationInfo operation.
 */
export type GetApplicationBackupConfigurationInfoResponse = PagedBackupConfigurationInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupConfigurationInfoList;
    };
};

/**
 * Contains response data for the getApplicationBackupList operation.
 */
export type GetApplicationBackupListResponse = PagedBackupInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupInfoList;
    };
};

/**
 * Contains response data for the getServiceBackupConfigurationInfo operation.
 */
export type GetServiceBackupConfigurationInfoResponse = PagedBackupConfigurationInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupConfigurationInfoList;
    };
};

/**
 * Contains response data for the getServiceBackupList operation.
 */
export type GetServiceBackupListResponse = PagedBackupInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupInfoList;
    };
};

/**
 * Contains response data for the getPartitionBackupConfigurationInfo operation.
 */
export type GetPartitionBackupConfigurationInfoResponse = PartitionBackupConfigurationInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionBackupConfigurationInfo;
    };
};

/**
 * Contains response data for the getPartitionBackupList operation.
 */
export type GetPartitionBackupListResponse = PagedBackupInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupInfoList;
    };
};

/**
 * Contains response data for the getPartitionBackupProgress operation.
 */
export type GetPartitionBackupProgressResponse = BackupProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: BackupProgressInfo;
    };
};

/**
 * Contains response data for the getPartitionRestoreProgress operation.
 */
export type GetPartitionRestoreProgressResponse = RestoreProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: RestoreProgressInfo;
    };
};

/**
 * Contains response data for the getBackupsFromBackupLocation operation.
 */
export type GetBackupsFromBackupLocationResponse = PagedBackupInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedBackupInfoList;
    };
};

/**
 * Contains response data for the getSubNameInfoList operation.
 */
export type GetSubNameInfoListResponse = PagedSubNameInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedSubNameInfoList;
    };
};

/**
 * Contains response data for the getPropertyInfoList operation.
 */
export type GetPropertyInfoListResponse = PagedPropertyInfoList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedPropertyInfoList;
    };
};

/**
 * Contains response data for the getPropertyInfo operation.
 */
export type GetPropertyInfoResponse = PropertyInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PropertyInfo;
    };
};

/**
 * Contains response data for the submitPropertyBatch operation.
 */
export type SubmitPropertyBatchResponse = PropertyBatchInfoUnion & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PropertyBatchInfoUnion;
    };
};

/**
 * Contains response data for the getClusterEventList operation.
 */
export type GetClusterEventListResponse = Array<ClusterEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterEventUnion[];
    };
};

/**
 * Contains response data for the getContainersEventList operation.
 */
export type GetContainersEventListResponse = Array<ContainerInstanceEvent> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContainerInstanceEvent[];
    };
};

/**
 * Contains response data for the getNodeEventList operation.
 */
export type GetNodeEventListResponse = Array<NodeEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeEventUnion[];
    };
};

/**
 * Contains response data for the getNodesEventList operation.
 */
export type GetNodesEventListResponse = Array<NodeEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeEventUnion[];
    };
};

/**
 * Contains response data for the getApplicationEventList operation.
 */
export type GetApplicationEventListResponse = Array<ApplicationEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationEventUnion[];
    };
};

/**
 * Contains response data for the getApplicationsEventList operation.
 */
export type GetApplicationsEventListResponse = Array<ApplicationEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationEventUnion[];
    };
};

/**
 * Contains response data for the getServiceEventList operation.
 */
export type GetServiceEventListResponse = Array<ServiceEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceEventUnion[];
    };
};

/**
 * Contains response data for the getServicesEventList operation.
 */
export type GetServicesEventListResponse = Array<ServiceEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceEventUnion[];
    };
};

/**
 * Contains response data for the getPartitionEventList operation.
 */
export type GetPartitionEventListResponse = Array<PartitionEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionEventUnion[];
    };
};

/**
 * Contains response data for the getPartitionsEventList operation.
 */
export type GetPartitionsEventListResponse = Array<PartitionEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PartitionEventUnion[];
    };
};

/**
 * Contains response data for the getPartitionReplicaEventList operation.
 */
export type GetPartitionReplicaEventListResponse = Array<ReplicaEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaEventUnion[];
    };
};

/**
 * Contains response data for the getPartitionReplicasEventList operation.
 */
export type GetPartitionReplicasEventListResponse = Array<ReplicaEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ReplicaEventUnion[];
    };
};

/**
 * Contains response data for the getCorrelatedEventList operation.
 */
export type GetCorrelatedEventListResponse = Array<FabricEventUnion> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: FabricEventUnion[];
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type MeshSecretCreateOrUpdateResponse = SecretResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecretResourceDescription;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MeshSecretGetResponse = SecretResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecretResourceDescription;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MeshSecretListResponse = PagedSecretResourceDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedSecretResourceDescriptionList;
    };
};

/**
 * Contains response data for the addValue operation.
 */
export type MeshSecretValueAddValueResponse = SecretValueResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecretValueResourceDescription;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MeshSecretValueGetResponse = SecretValueResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecretValueResourceDescription;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MeshSecretValueListResponse = PagedSecretValueResourceDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedSecretValueResourceDescriptionList;
    };
};

/**
 * Contains response data for the show operation.
 */
export type MeshSecretValueShowResponse = SecretValue & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SecretValue;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type MeshVolumeCreateOrUpdateResponse = VolumeResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VolumeResourceDescription;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MeshVolumeGetResponse = VolumeResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: VolumeResourceDescription;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MeshVolumeListResponse = PagedVolumeResourceDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedVolumeResourceDescriptionList;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type MeshNetworkCreateOrUpdateResponse = NetworkResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NetworkResourceDescription;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MeshNetworkGetResponse = NetworkResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NetworkResourceDescription;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MeshNetworkListResponse = PagedNetworkResourceDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedNetworkResourceDescriptionList;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type MeshApplicationCreateOrUpdateResponse = ApplicationResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResourceDescription;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MeshApplicationGetResponse = ApplicationResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResourceDescription;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MeshApplicationListResponse = PagedApplicationResourceDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedApplicationResourceDescriptionList;
    };
};

/**
 * Contains response data for the getUpgradeProgress operation.
 */
export type MeshApplicationGetUpgradeProgressResponse = ApplicationResourceUpgradeProgressInfo & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResourceUpgradeProgressInfo;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MeshServiceGetResponse = ServiceResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResourceDescription;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MeshServiceListResponse = PagedServiceResourceDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedServiceResourceDescriptionList;
    };
};

/**
 * Contains response data for the getContainerLogs operation.
 */
export type MeshCodePackageGetContainerLogsResponse = ContainerLogs & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContainerLogs;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MeshServiceReplicaGetResponse = ServiceReplicaDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceReplicaDescription;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MeshServiceReplicaListResponse = PagedServiceReplicaDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedServiceReplicaDescriptionList;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type MeshGatewayCreateOrUpdateResponse = GatewayResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: GatewayResourceDescription;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MeshGatewayGetResponse = GatewayResourceDescription & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: GatewayResourceDescription;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MeshGatewayListResponse = PagedGatewayResourceDescriptionList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: PagedGatewayResourceDescriptionList;
    };
};
