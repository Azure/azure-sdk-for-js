/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { BaseResource, CloudError, AzureServiceClientOptions } from "@azure/ms-rest-azure-js";
import * as msRest from "@azure/ms-rest-js";

export { BaseResource, CloudError };

/**
 * An interface representing ApplicationTypeVersionsCleanupPolicy.
 */
export interface ApplicationTypeVersionsCleanupPolicy {
  /**
   * Number of unused versions per application type to keep.
   */
  maxUnusedVersionsToKeep: number;
}

/**
 * Represents the delta health policy used to evaluate the health of services belonging to a
 * service type when upgrading the cluster.

 */
export interface ServiceTypeDeltaHealthPolicy {
  /**
   * The maximum allowed percentage of services health degradation allowed during cluster upgrades.
   * The delta is measured between the state of the services at the beginning of upgrade and the
   * state of the services at the time of the health evaluation.
   * The check is performed after every upgrade domain upgrade completion to make sure the global
   * state of the cluster is within tolerated limits. Default value: 0.
   */
  maxPercentDeltaUnhealthyServices?: number;
}

/**
 * Defines a delta health policy used to evaluate the health of an application or one of its child
 * entities when upgrading the cluster.

 */
export interface ApplicationDeltaHealthPolicy {
  /**
   * The delta health policy used by default to evaluate the health of a service type when
   * upgrading the cluster.
   */
  defaultServiceTypeDeltaHealthPolicy?: ServiceTypeDeltaHealthPolicy;
  /**
   * The map with service type delta health policy per service type name. The map is empty by
   * default.
   */
  serviceTypeDeltaHealthPolicies?: { [propertyName: string]: ServiceTypeDeltaHealthPolicy };
}

/**
 * Represents the health policy used to evaluate the health of services belonging to a service
 * type.

 */
export interface ServiceTypeHealthPolicy {
  /**
   * The maximum percentage of services allowed to be unhealthy before your application is
   * considered in error. Default value: 0.
   */
  maxPercentUnhealthyServices?: number;
}

/**
 * Defines a health policy used to evaluate the health of an application or one of its children
 * entities.

 */
export interface ApplicationHealthPolicy {
  /**
   * The health policy used by default to evaluate the health of a service type.
   */
  defaultServiceTypeHealthPolicy?: ServiceTypeHealthPolicy;
  /**
   * The map with service type health policy per service type name. The map is empty by default.
   */
  serviceTypeHealthPolicies?: { [propertyName: string]: ServiceTypeHealthPolicy };
}

/**
 * Operation supported by the Service Fabric resource provider
 */
export interface AvailableOperationDisplay {
  /**
   * The name of the provider.
   */
  provider?: string;
  /**
   * The resource on which the operation is performed
   */
  resource?: string;
  /**
   * The operation that can be performed.
   */
  operation?: string;
  /**
   * Operation description
   */
  description?: string;
}

/**
 * The settings to enable AAD authentication on the cluster.
 */
export interface AzureActiveDirectory {
  /**
   * Azure active directory tenant id.
   */
  tenantId?: string;
  /**
   * Azure active directory cluster application id.
   */
  clusterApplication?: string;
  /**
   * Azure active directory client application id.
   */
  clientApplication?: string;
}

/**
 * Describes the certificate details.
 */
export interface CertificateDescription {
  /**
   * Thumbprint of the primary certificate.
   */
  thumbprint: string;
  /**
   * Thumbprint of the secondary certificate.
   */
  thumbprintSecondary?: string;
  /**
   * The local certificate store location. Possible values include: 'AddressBook', 'AuthRoot',
   * 'CertificateAuthority', 'Disallowed', 'My', 'Root', 'TrustedPeople', 'TrustedPublisher'
   */
  x509StoreName?: X509StoreName;
}

/**
 * Describes the client certificate details using common name.
 */
export interface ClientCertificateCommonName {
  /**
   * Indicates if the client certificate has admin access to the cluster. Non admin clients can
   * perform only read only operations on the cluster.
   */
  isAdmin: boolean;
  /**
   * The common name of the client certificate.
   */
  certificateCommonName: string;
  /**
   * The issuer thumbprint of the client certificate.
   */
  certificateIssuerThumbprint: string;
}

/**
 * Describes the client certificate details using thumbprint.
 */
export interface ClientCertificateThumbprint {
  /**
   * Indicates if the client certificate has admin access to the cluster. Non admin clients can
   * perform only read only operations on the cluster.
   */
  isAdmin: boolean;
  /**
   * The thumbprint of the client certificate.
   */
  certificateThumbprint: string;
}

/**
 * The detail of the Service Fabric runtime version result
 */
export interface ClusterVersionDetails {
  /**
   * The Service Fabric runtime version of the cluster.
   */
  codeVersion?: string;
  /**
   * The date of expiry of support of the version.
   */
  supportExpiryUtc?: string;
  /**
   * Indicates if this version is for Windows or Linux operating system. Possible values include:
   * 'Windows', 'Linux'
   */
  environment?: Environment;
}

/**
 * Describes the server certificate details using common name.
 */
export interface ServerCertificateCommonName {
  /**
   * The common name of the server certificate.
   */
  certificateCommonName: string;
  /**
   * The issuer thumbprint of the server certificate.
   */
  certificateIssuerThumbprint: string;
}

/**
 * Describes a list of server certificates referenced by common name that are used to secure the
 * cluster.
 */
export interface ServerCertificateCommonNames {
  /**
   * The list of server certificates referenced by common name that are used to secure the cluster.
   */
  commonNames?: ServerCertificateCommonName[];
  /**
   * The local certificate store location. Possible values include: 'AddressBook', 'AuthRoot',
   * 'CertificateAuthority', 'Disallowed', 'My', 'Root', 'TrustedPeople', 'TrustedPublisher'
   */
  x509StoreName?: X509StoreName1;
}

/**
 * The storage account information for storing Service Fabric diagnostic logs.
 */
export interface DiagnosticsStorageAccountConfig {
  /**
   * The Azure storage account name.
   */
  storageAccountName: string;
  /**
   * The protected diagnostics storage key name.
   */
  protectedAccountKeyName: string;
  /**
   * The secondary protected diagnostics storage key name. If one of the storage account keys is
   * rotated the cluster will fallback to using the other.
   */
  protectedAccountKeyName2?: string;
  /**
   * The blob endpoint of the azure storage account.
   */
  blobEndpoint: string;
  /**
   * The queue endpoint of the azure storage account.
   */
  queueEndpoint: string;
  /**
   * The table endpoint of the azure storage account.
   */
  tableEndpoint: string;
}

/**
 * Describes a parameter in fabric settings of the cluster.
 */
export interface SettingsParameterDescription {
  /**
   * The parameter name of fabric setting.
   */
  name: string;
  /**
   * The parameter value of fabric setting.
   */
  value: string;
}

/**
 * Describes a section in the fabric settings of the cluster.
 */
export interface SettingsSectionDescription {
  /**
   * The section name of the fabric settings.
   */
  name: string;
  /**
   * The collection of parameters in the section.
   */
  parameters: SettingsParameterDescription[];
}

/**
 * Port range details
 */
export interface EndpointRangeDescription {
  /**
   * Starting port of a range of ports
   */
  startPort: number;
  /**
   * End port of a range of ports
   */
  endPort: number;
}

/**
 * Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
 */
export interface NodeTypeDescription {
  /**
   * The name of the node type.
   */
  name: string;
  /**
   * The placement tags applied to nodes in the node type, which can be used to indicate where
   * certain services (workload) should run.
   */
  placementProperties?: { [propertyName: string]: string };
  /**
   * The capacity tags applied to the nodes in the node type, the cluster resource manager uses
   * these tags to understand how much resource a node has.
   */
  capacities?: { [propertyName: string]: string };
  /**
   * The TCP cluster management endpoint port.
   */
  clientConnectionEndpointPort: number;
  /**
   * The HTTP cluster management endpoint port.
   */
  httpGatewayEndpointPort: number;
  /**
   * The durability level of the node type. Learn about
   * [DurabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
   *
   * - Bronze - No privileges. This is the default.
   * - Silver - The infrastructure jobs can be paused for a duration of 10 minutes per UD.
   * - Gold - The infrastructure jobs can be paused for a duration of 2 hours per UD. Gold
   * durability can be enabled only on full node VM skus like D15_V2, G5 etc.
   * . Possible values include: 'Bronze', 'Silver', 'Gold'
   */
  durabilityLevel?: DurabilityLevel;
  /**
   * The range of ports from which cluster assigned port to Service Fabric applications.
   */
  applicationPorts?: EndpointRangeDescription;
  /**
   * The range of ephemeral ports that nodes in this node type should be configured with.
   */
  ephemeralPorts?: EndpointRangeDescription;
  /**
   * The node type on which system services will run. Only one node type should be marked as
   * primary. Primary node type cannot be deleted or changed for existing clusters.
   */
  isPrimary: boolean;
  /**
   * The number of nodes in the node type. This count should match the capacity property in the
   * corresponding VirtualMachineScaleSet resource.
   */
  vmInstanceCount: number;
  /**
   * The endpoint used by reverse proxy.
   */
  reverseProxyEndpointPort?: number;
}

/**
 * Defines a health policy used to evaluate the health of the cluster or of a cluster node.

 */
export interface ClusterHealthPolicy {
  /**
   * The maximum allowed percentage of unhealthy nodes before reporting an error. For example, to
   * allow 10% of nodes to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of nodes that can be unhealthy
   * before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy node, the health is
   * evaluated as Warning.
   * The percentage is calculated by dividing the number of unhealthy nodes over the total number
   * of nodes in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes. Default
   * percentage is zero.
   *
   * In large clusters, some nodes will always be down or out for repairs, so this percentage
   * should be configured to tolerate that. Default value: 0.
   */
  maxPercentUnhealthyNodes?: number;
  /**
   * The maximum allowed percentage of unhealthy applications before reporting an error. For
   * example, to allow 10% of applications to be unhealthy, this value would be 10.
   *
   * The percentage represents the maximum tolerated percentage of applications that can be
   * unhealthy before the cluster is considered in error.
   * If the percentage is respected but there is at least one unhealthy application, the health is
   * evaluated as Warning.
   * This is calculated by dividing the number of unhealthy applications over the total number of
   * application instances in the cluster, excluding applications of application types that are
   * included in the ApplicationTypeHealthPolicyMap.
   * The computation rounds up to tolerate one failure on small numbers of applications. Default
   * percentage is zero. Default value: 0.
   */
  maxPercentUnhealthyApplications?: number;
  /**
   * Defines the application health policy map used to evaluate the health of an application or one
   * of its children entities.
   */
  applicationHealthPolicies?: { [propertyName: string]: ApplicationHealthPolicy };
}

/**
 * Describes the delta health policies for the cluster upgrade.
 */
export interface ClusterUpgradeDeltaHealthPolicy {
  /**
   * The maximum allowed percentage of nodes health degradation allowed during cluster upgrades.
   * The delta is measured between the state of the nodes at the beginning of upgrade and the state
   * of the nodes at the time of the health evaluation.
   * The check is performed after every upgrade domain upgrade completion to make sure the global
   * state of the cluster is within tolerated limits.
   */
  maxPercentDeltaUnhealthyNodes: number;
  /**
   * The maximum allowed percentage of upgrade domain nodes health degradation allowed during
   * cluster upgrades.
   * The delta is measured between the state of the upgrade domain nodes at the beginning of
   * upgrade and the state of the upgrade domain nodes at the time of the health evaluation.
   * The check is performed after every upgrade domain upgrade completion for all completed upgrade
   * domains to make sure the state of the upgrade domains is within tolerated limits.
   */
  maxPercentUpgradeDomainDeltaUnhealthyNodes: number;
  /**
   * The maximum allowed percentage of applications health degradation allowed during cluster
   * upgrades.
   * The delta is measured between the state of the applications at the beginning of upgrade and
   * the state of the applications at the time of the health evaluation.
   * The check is performed after every upgrade domain upgrade completion to make sure the global
   * state of the cluster is within tolerated limits. System services are not included in this.
   */
  maxPercentDeltaUnhealthyApplications: number;
  /**
   * Defines the application delta health policy map used to evaluate the health of an application
   * or one of its child entities when upgrading the cluster.
   */
  applicationDeltaHealthPolicies?: { [propertyName: string]: ApplicationDeltaHealthPolicy };
}

/**
 * Describes the policy used when upgrading the cluster.
 */
export interface ClusterUpgradePolicy {
  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has
   * not changed (the upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
   * format.
   */
  upgradeReplicaSetCheckTimeout: string;
  /**
   * The length of time to wait after completing an upgrade domain before performing health checks.
   * The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
   */
  healthCheckWaitDuration: string;
  /**
   * The amount of time that the application or cluster must remain healthy before the upgrade
   * proceeds to the next upgrade domain. The duration can be in either hh:mm:ss or in
   * d.hh:mm:ss.ms format.
   */
  healthCheckStableDuration: string;
  /**
   * The amount of time to retry health evaluation when the application or cluster is unhealthy
   * before the upgrade rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
   * format.
   */
  healthCheckRetryTimeout: string;
  /**
   * The amount of time the overall upgrade has to complete before the upgrade rolls back. The
   * timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
   */
  upgradeTimeout: string;
  /**
   * The amount of time each upgrade domain has to complete before the upgrade rolls back. The
   * timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
   */
  upgradeDomainTimeout: string;
  /**
   * The cluster health policy used when upgrading the cluster.
   */
  healthPolicy: ClusterHealthPolicy;
  /**
   * The cluster delta health policy used when upgrading the cluster.
   */
  deltaHealthPolicy?: ClusterUpgradeDeltaHealthPolicy;
}

/**
 * The resource model definition.
 */
export interface Resource extends BaseResource {
  /**
   * Azure resource identifier.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
  /**
   * Azure resource name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * Azure resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
  /**
   * Azure resource location.
   */
  location: string;
  /**
   * Azure resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * Azure resource etag.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly etag?: string;
}

/**
 * The cluster resource

 */
export interface Cluster extends Resource {
  /**
   * The list of add-on features to enable in the cluster.
   */
  addOnFeatures?: string[];
  /**
   * The Service Fabric runtime versions available for this cluster.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly availableClusterVersions?: ClusterVersionDetails[];
  /**
   * The AAD authentication settings of the cluster.
   */
  azureActiveDirectory?: AzureActiveDirectory;
  /**
   * The certificate to use for securing the cluster. The certificate provided will be used for
   * node to node security within the cluster, SSL certificate for cluster management endpoint and
   * default admin client.
   */
  certificate?: CertificateDescription;
  /**
   * Describes a list of server certificates referenced by common name that are used to secure the
   * cluster.
   */
  certificateCommonNames?: ServerCertificateCommonNames;
  /**
   * The list of client certificates referenced by common name that are allowed to manage the
   * cluster.
   */
  clientCertificateCommonNames?: ClientCertificateCommonName[];
  /**
   * The list of client certificates referenced by thumbprint that are allowed to manage the
   * cluster.
   */
  clientCertificateThumbprints?: ClientCertificateThumbprint[];
  /**
   * The Service Fabric runtime version of the cluster. This property can only by set the user when
   * **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new
   * clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of available version
   * for existing clusters use **availableClusterVersions**.
   */
  clusterCodeVersion?: string;
  /**
   * The Azure Resource Provider endpoint. A system service in the cluster connects to this
   * endpoint.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clusterEndpoint?: string;
  /**
   * A service generated unique identifier for the cluster resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clusterId?: string;
  /**
   * The current state of the cluster.
   *
   * - WaitingForNodes - Indicates that the cluster resource is created and the resource provider
   * is waiting for Service Fabric VM extension to boot up and report to it.
   * - Deploying - Indicates that the Service Fabric runtime is being installed on the VMs. Cluster
   * resource will be in this state until the cluster boots up and system services are up.
   * - BaselineUpgrade - Indicates that the cluster is upgrading to establishes the cluster
   * version. This upgrade is automatically initiated when the cluster boots up for the first time.
   * - UpdatingUserConfiguration - Indicates that the cluster is being upgraded with the user
   * provided configuration.
   * - UpdatingUserCertificate - Indicates that the cluster is being upgraded with the user
   * provided certificate.
   * - UpdatingInfrastructure - Indicates that the cluster is being upgraded with the latest
   * Service Fabric runtime version. This happens only when the **upgradeMode** is set to
   * 'Automatic'.
   * - EnforcingClusterVersion - Indicates that cluster is on a different version than expected and
   * the cluster is being upgraded to the expected version.
   * - UpgradeServiceUnreachable - Indicates that the system service in the cluster is no longer
   * polling the Resource Provider. Clusters in this state cannot be managed by the Resource
   * Provider.
   * - AutoScale - Indicates that the ReliabilityLevel of the cluster is being adjusted.
   * - Ready - Indicates that the cluster is in a stable state.
   * . Possible values include: 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
   * 'UpdatingUserConfiguration', 'UpdatingUserCertificate', 'UpdatingInfrastructure',
   * 'EnforcingClusterVersion', 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clusterState?: ClusterState;
  /**
   * The storage account information for storing Service Fabric diagnostic logs.
   */
  diagnosticsStorageAccountConfig?: DiagnosticsStorageAccountConfig;
  /**
   * Indicates if the event store service is enabled.
   */
  eventStoreServiceEnabled?: boolean;
  /**
   * The list of custom fabric settings to configure the cluster.
   */
  fabricSettings?: SettingsSectionDescription[];
  /**
   * The http management endpoint of the cluster.
   */
  managementEndpoint: string;
  /**
   * The list of node types in the cluster.
   */
  nodeTypes: NodeTypeDescription[];
  /**
   * The provisioning state of the cluster resource. Possible values include: 'Updating',
   * 'Succeeded', 'Failed', 'Canceled'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: ProvisioningState;
  /**
   * The reliability level sets the replica set size of system services. Learn about
   * [ReliabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
   *
   * - None - Run the System services with a target replica set count of 1. This should only be
   * used for test clusters.
   * - Bronze - Run the System services with a target replica set count of 3. This should only be
   * used for test clusters.
   * - Silver - Run the System services with a target replica set count of 5.
   * - Gold - Run the System services with a target replica set count of 7.
   * - Platinum - Run the System services with a target replica set count of 9.
   * . Possible values include: 'None', 'Bronze', 'Silver', 'Gold', 'Platinum'
   */
  reliabilityLevel?: ReliabilityLevel;
  /**
   * The server certificate used by reverse proxy.
   */
  reverseProxyCertificate?: CertificateDescription;
  /**
   * Describes a list of server certificates referenced by common name that are used to secure the
   * cluster.
   */
  reverseProxyCertificateCommonNames?: ServerCertificateCommonNames;
  /**
   * The policy to use when upgrading the cluster.
   */
  upgradeDescription?: ClusterUpgradePolicy;
  /**
   * The upgrade mode of the cluster when new Service Fabric runtime version is available.
   *
   * - Automatic - The cluster will be automatically upgraded to the latest Service Fabric runtime
   * version as soon as it is available.
   * - Manual - The cluster will not be automatically upgraded to the latest Service Fabric runtime
   * version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster
   * resource.
   * . Possible values include: 'Automatic', 'Manual'
   */
  upgradeMode?: UpgradeMode;
  /**
   * The policy used to clean up unused versions.
   */
  applicationTypeVersionsCleanupPolicy?: ApplicationTypeVersionsCleanupPolicy;
  /**
   * The VM image VMSS has been configured with. Generic names such as Windows or Linux can be
   * used.
   */
  vmImage?: string;
}

/**
 * The result of the Service Fabric runtime versions
 */
export interface ClusterCodeVersionsResult {
  /**
   * The identification of the result
   */
  id?: string;
  /**
   * The name of the result
   */
  name?: string;
  /**
   * The result resource type
   */
  type?: string;
  /**
   * The Service Fabric runtime version of the cluster.
   */
  codeVersion?: string;
  /**
   * The date of expiry of support of the version.
   */
  supportExpiryUtc?: string;
  /**
   * Indicates if this version is for Windows or Linux operating system. Possible values include:
   * 'Windows', 'Linux'
   */
  environment?: Environment;
}

/**
 * The list results of the Service Fabric runtime versions.
 */
export interface ClusterCodeVersionsListResult {
  value?: ClusterCodeVersionsResult[];
  /**
   * The URL to use for getting the next set of results.
   */
  nextLink?: string;
}

/**
 * Cluster list results
 */
export interface ClusterListResult {
  value?: Cluster[];
  /**
   * The URL to use for getting the next set of results.
   */
  nextLink?: string;
}

/**
 * Cluster update request
 */
export interface ClusterUpdateParameters {
  /**
   * The list of add-on features to enable in the cluster.
   */
  addOnFeatures?: string[];
  /**
   * The certificate to use for securing the cluster. The certificate provided will be used for
   * node to node security within the cluster, SSL certificate for cluster management endpoint and
   * default  admin client.
   */
  certificate?: CertificateDescription;
  /**
   * Describes a list of server certificates referenced by common name that are used to secure the
   * cluster.
   */
  certificateCommonNames?: ServerCertificateCommonNames;
  /**
   * The list of client certificates referenced by common name that are allowed to manage the
   * cluster. This will overwrite the existing list.
   */
  clientCertificateCommonNames?: ClientCertificateCommonName[];
  /**
   * The list of client certificates referenced by thumbprint that are allowed to manage the
   * cluster. This will overwrite the existing list.
   */
  clientCertificateThumbprints?: ClientCertificateThumbprint[];
  /**
   * The Service Fabric runtime version of the cluster. This property can only by set the user when
   * **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new
   * clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of available version
   * for existing clusters use **availableClusterVersions**.
   */
  clusterCodeVersion?: string;
  /**
   * Indicates if the event store service is enabled.
   */
  eventStoreServiceEnabled?: boolean;
  /**
   * The list of custom fabric settings to configure the cluster. This will overwrite the existing
   * list.
   */
  fabricSettings?: SettingsSectionDescription[];
  /**
   * The list of node types in the cluster. This will overwrite the existing list.
   */
  nodeTypes?: NodeTypeDescription[];
  /**
   * The reliability level sets the replica set size of system services. Learn about
   * [ReliabilityLevel](https://docs.microsoft.com/azure/service-fabric/service-fabric-cluster-capacity).
   *
   * - None - Run the System services with a target replica set count of 1. This should only be
   * used for test clusters.
   * - Bronze - Run the System services with a target replica set count of 3. This should only be
   * used for test clusters.
   * - Silver - Run the System services with a target replica set count of 5.
   * - Gold - Run the System services with a target replica set count of 7.
   * - Platinum - Run the System services with a target replica set count of 9.
   * . Possible values include: 'None', 'Bronze', 'Silver', 'Gold', 'Platinum'
   */
  reliabilityLevel?: ReliabilityLevel1;
  /**
   * The server certificate used by reverse proxy.
   */
  reverseProxyCertificate?: CertificateDescription;
  /**
   * The policy to use when upgrading the cluster.
   */
  upgradeDescription?: ClusterUpgradePolicy;
  /**
   * The upgrade mode of the cluster when new Service Fabric runtime version is available.
   *
   * - Automatic - The cluster will be automatically upgraded to the latest Service Fabric runtime
   * version as soon as it is available.
   * - Manual - The cluster will not be automatically upgraded to the latest Service Fabric runtime
   * version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster
   * resource.
   * . Possible values include: 'Automatic', 'Manual'
   */
  upgradeMode?: UpgradeMode1;
  /**
   * The policy used to clean up unused versions.
   */
  applicationTypeVersionsCleanupPolicy?: ApplicationTypeVersionsCleanupPolicy;
  /**
   * Cluster update parameters
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Available operation list result
 */
export interface OperationResult {
  /**
   * The name of the operation.
   */
  name?: string;
  /**
   * The object that represents the operation.
   */
  display?: AvailableOperationDisplay;
  /**
   * Origin result
   */
  origin?: string;
  /**
   * The URL to use for getting the next set of results.
   */
  nextLink?: string;
}

/**
 * The error details.
 */
export interface ErrorModelError {
  /**
   * The error code.
   */
  code?: string;
  /**
   * The error message.
   */
  message?: string;
}

/**
 * The structure of the error.
 */
export interface ErrorModel {
  /**
   * The error details.
   */
  error?: ErrorModelError;
}

/**
 * Describes capacity information for a custom resource balancing metric. This can be used to limit
 * the total consumption of this metric by the services of this application.

 */
export interface ApplicationMetricDescription {
  /**
   * The name of the metric.
   */
  name?: string;
  /**
   * The maximum node capacity for Service Fabric application.
   * This is the maximum Load for an instance of this application on a single node. Even if the
   * capacity of node is greater than this value, Service Fabric will limit the total load of
   * services within the application on each node to this value.
   * If set to zero, capacity for this metric is unlimited on each node.
   * When creating a new application with application capacity defined, the product of MaximumNodes
   * and this value must always be smaller than or equal to TotalApplicationCapacity.
   * When updating existing application with application capacity, the product of MaximumNodes and
   * this value must always be smaller than or equal to TotalApplicationCapacity.
   */
  maximumCapacity?: number;
  /**
   * The node reservation capacity for Service Fabric application.
   * This is the amount of load which is reserved on nodes which have instances of this
   * application.
   * If MinimumNodes is specified, then the product of these values will be the capacity reserved
   * in the cluster for the application.
   * If set to zero, no capacity is reserved for this metric.
   * When setting application capacity or when updating application capacity; this value must be
   * smaller than or equal to MaximumCapacity for each metric.
   */
  reservationCapacity?: number;
  /**
   * The total metric capacity for Service Fabric application.
   * This is the total metric capacity for this application in the cluster. Service Fabric will try
   * to limit the sum of loads of services within the application to this value.
   * When creating a new application with application capacity defined, the product of MaximumNodes
   * and MaximumCapacity must always be smaller than or equal to this value.
   */
  totalApplicationCapacity?: number;
}

/**
 * An interface representing UserAssignedIdentity.
 */
export interface UserAssignedIdentity {
  /**
   * The principal id of user assigned identity.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly principalId?: string;
  /**
   * The client id of user assigned identity.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clientId?: string;
}

/**
 * Describes the managed identities for an Azure resource.
 */
export interface ManagedIdentity {
  /**
   * The principal id of the managed identity. This property will only be provided for a system
   * assigned identity.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly principalId?: string;
  /**
   * The tenant id of the managed identity. This property will only be provided for a system
   * assigned identity.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly tenantId?: string;
  /**
   * The type of managed identity for the resource. Possible values include: 'SystemAssigned',
   * 'UserAssigned', 'SystemAssigned, UserAssigned', 'None'
   */
  type?: ManagedIdentityType;
  /**
   * The list of user identities associated with the resource. The user identity dictionary key
   * references will be ARM resource ids in the form:
   * '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
   */
  userAssignedIdentities?: { [propertyName: string]: UserAssignedIdentity };
}

/**
 * The resource model definition for proxy-only resource.
 */
export interface ProxyResource extends BaseResource {
  /**
   * Azure resource identifier.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
  /**
   * Azure resource name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * Azure resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
  /**
   * It will be deprecated in New API, resource location depends on the parent resource.
   */
  location?: string;
  /**
   * Azure resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * Azure resource etag.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly etag?: string;
}

/**
 * The application resource.
 */
export interface ApplicationResource extends ProxyResource {
  /**
   * Describes the managed identities for an Azure resource.
   */
  identity?: ManagedIdentity;
  /**
   * The version of the application type as defined in the application manifest.
   */
  typeVersion?: string;
  /**
   * List of application parameters with overridden values from their default values specified in
   * the application manifest.
   */
  parameters?: { [propertyName: string]: string };
  /**
   * Describes the policy for a monitored application upgrade.
   */
  upgradePolicy?: ApplicationUpgradePolicy;
  /**
   * The minimum number of nodes where Service Fabric will reserve capacity for this application.
   * Note that this does not mean that the services of this application will be placed on all of
   * those nodes. If this property is set to zero, no capacity will be reserved. The value of this
   * property cannot be more than the value of the MaximumNodes property.
   */
  minimumNodes?: number;
  /**
   * The maximum number of nodes where Service Fabric will reserve capacity for this application.
   * Note that this does not mean that the services of this application will be placed on all of
   * those nodes. By default, the value of this property is zero and it means that the services can
   * be placed on any node. Default value: 0.
   */
  maximumNodes?: number;
  /**
   * Remove the current application capacity settings.
   */
  removeApplicationCapacity?: boolean;
  /**
   * List of application capacity metric description.
   */
  metrics?: ApplicationMetricDescription[];
  /**
   * List of user assigned identities for the application, each mapped to a friendly name.
   */
  managedIdentities?: ApplicationUserAssignedIdentity[];
  /**
   * The current deployment or provisioning state, which only appears in the response
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The application type name as defined in the application manifest.
   */
  typeName?: string;
}

/**
 * The list of application resources.
 */
export interface ApplicationResourceList {
  value?: ApplicationResource[];
  /**
   * URL to get the next set of application list results if there are any.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nextLink?: string;
}

/**
 * The policy used for monitoring the application upgrade
 */
export interface ArmRollingUpgradeMonitoringPolicy {
  /**
   * The activation Mode of the service package. Possible values include: 'Rollback', 'Manual'
   */
  failureAction?: ArmUpgradeFailureAction;
  /**
   * The amount of time to wait after completing an upgrade domain before applying health policies.
   * It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it
   * is interpreted as a number representing the total number of milliseconds.
   */
  healthCheckWaitDuration?: string;
  /**
   * The amount of time that the application or cluster must remain healthy before the upgrade
   * proceeds to the next upgrade domain. It is first interpreted as a string representing an ISO
   * 8601 duration. If that fails, then it is interpreted as a number representing the total number
   * of milliseconds.
   */
  healthCheckStableDuration?: string;
  /**
   * The amount of time to retry health evaluation when the application or cluster is unhealthy
   * before FailureAction is executed. It is first interpreted as a string representing an ISO 8601
   * duration. If that fails, then it is interpreted as a number representing the total number of
   * milliseconds.
   */
  healthCheckRetryTimeout?: string;
  /**
   * The amount of time the overall upgrade has to complete before FailureAction is executed. It is
   * first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  upgradeTimeout?: string;
  /**
   * The amount of time each upgrade domain has to complete before FailureAction is executed. It is
   * first interpreted as a string representing an ISO 8601 duration. If that fails, then it is
   * interpreted as a number representing the total number of milliseconds.
   */
  upgradeDomainTimeout?: string;
}

/**
 * Represents the health policy used to evaluate the health of services belonging to a service
 * type.

 */
export interface ArmServiceTypeHealthPolicy {
  /**
   * The maximum percentage of services allowed to be unhealthy before your application is
   * considered in error. Default value: 0.
   */
  maxPercentUnhealthyServices?: number;
  /**
   * The maximum percentage of partitions per service allowed to be unhealthy before your
   * application is considered in error. Default value: 0.
   */
  maxPercentUnhealthyPartitionsPerService?: number;
  /**
   * The maximum percentage of replicas per partition allowed to be unhealthy before your
   * application is considered in error. Default value: 0.
   */
  maxPercentUnhealthyReplicasPerPartition?: number;
}

/**
 * Defines a health policy used to evaluate the health of an application or one of its children
 * entities.

 */
export interface ArmApplicationHealthPolicy {
  /**
   * Indicates whether warnings are treated with the same severity as errors. Default value: false.
   */
  considerWarningAsError?: boolean;
  /**
   * The maximum allowed percentage of unhealthy deployed applications. Allowed values are Byte
   * values from zero to 100.
   * The percentage represents the maximum tolerated percentage of deployed applications that can
   * be unhealthy before the application is considered in error.
   * This is calculated by dividing the number of unhealthy deployed applications over the number
   * of nodes where the application is currently deployed on in the cluster.
   * The computation rounds up to tolerate one failure on small numbers of nodes. Default
   * percentage is zero. Default value: 0.
   */
  maxPercentUnhealthyDeployedApplications?: number;
  /**
   * The health policy used by default to evaluate the health of a service type.
   */
  defaultServiceTypeHealthPolicy?: ArmServiceTypeHealthPolicy;
  /**
   * The map with service type health policy per service type name. The map is empty by default.
   */
  serviceTypeHealthPolicyMap?: { [propertyName: string]: ArmServiceTypeHealthPolicy };
}

/**
 * Describes the policy for a monitored application upgrade.
 */
export interface ApplicationUpgradePolicy {
  /**
   * The maximum amount of time to block processing of an upgrade domain and prevent loss of
   * availability when there are unexpected issues. When this timeout expires, processing of the
   * upgrade domain will proceed regardless of availability loss issues. The timeout is reset at
   * the start of each upgrade domain. Valid values are between 0 and 42949672925 inclusive.
   * (unsigned 32-bit integer).
   */
  upgradeReplicaSetCheckTimeout?: string;
  /**
   * If true, then processes are forcefully restarted during upgrade even when the code version has
   * not changed (the upgrade only changes configuration or data).
   */
  forceRestart?: boolean;
  /**
   * The policy used for monitoring the application upgrade
   */
  rollingUpgradeMonitoringPolicy?: ArmRollingUpgradeMonitoringPolicy;
  /**
   * Defines a health policy used to evaluate the health of an application or one of its children
   * entities.
   */
  applicationHealthPolicy?: ArmApplicationHealthPolicy;
  /**
   * The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
   * UnmonitoredManual, and Monitored. Possible values include: 'Invalid', 'UnmonitoredAuto',
   * 'UnmonitoredManual', 'Monitored'. Default value: 'Monitored'.
   */
  upgradeMode?: RollingUpgradeMode;
}

/**
 * An interface representing ApplicationUserAssignedIdentity.
 */
export interface ApplicationUserAssignedIdentity {
  /**
   * The friendly name of user assigned identity.
   */
  name: string;
  /**
   * The principal id of user assigned identity.
   */
  principalId: string;
}

/**
 * The application resource for patch operations.
 */
export interface ApplicationResourceUpdate extends ProxyResource {
  /**
   * The version of the application type as defined in the application manifest.
   */
  typeVersion?: string;
  /**
   * List of application parameters with overridden values from their default values specified in
   * the application manifest.
   */
  parameters?: { [propertyName: string]: string };
  /**
   * Describes the policy for a monitored application upgrade.
   */
  upgradePolicy?: ApplicationUpgradePolicy;
  /**
   * The minimum number of nodes where Service Fabric will reserve capacity for this application.
   * Note that this does not mean that the services of this application will be placed on all of
   * those nodes. If this property is set to zero, no capacity will be reserved. The value of this
   * property cannot be more than the value of the MaximumNodes property.
   */
  minimumNodes?: number;
  /**
   * The maximum number of nodes where Service Fabric will reserve capacity for this application.
   * Note that this does not mean that the services of this application will be placed on all of
   * those nodes. By default, the value of this property is zero and it means that the services can
   * be placed on any node. Default value: 0.
   */
  maximumNodes?: number;
  /**
   * Remove the current application capacity settings.
   */
  removeApplicationCapacity?: boolean;
  /**
   * List of application capacity metric description.
   */
  metrics?: ApplicationMetricDescription[];
  /**
   * List of user assigned identities for the application, each mapped to a friendly name.
   */
  managedIdentities?: ApplicationUserAssignedIdentity[];
}

/**
 * The application type name resource
 */
export interface ApplicationTypeResource extends ProxyResource {
  /**
   * The current deployment or provisioning state, which only appears in the response.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
}

/**
 * The list of application type names.
 */
export interface ApplicationTypeResourceList {
  value?: ApplicationTypeResource[];
  /**
   * URL to get the next set of application type list results if there are any.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nextLink?: string;
}

/**
 * An application type version resource for the specified application type name resource.
 */
export interface ApplicationTypeVersionResource extends ProxyResource {
  /**
   * The current deployment or provisioning state, which only appears in the response
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The URL to the application package
   */
  appPackageUrl: string;
  /**
   * List of application type parameters that can be overridden when creating or updating the
   * application.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly defaultParameterList?: { [propertyName: string]: string };
}

/**
 * The list of application type version resources for the specified application type name resource.
 */
export interface ApplicationTypeVersionResourceList {
  value?: ApplicationTypeVersionResource[];
  /**
   * URL to get the next set of application type version list results if there are any.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nextLink?: string;
}

/**
 * Creates a particular correlation between services.
 */
export interface ServiceCorrelationDescription {
  /**
   * The ServiceCorrelationScheme which describes the relationship between this service and the
   * service specified via ServiceName. Possible values include: 'Invalid', 'Affinity',
   * 'AlignedAffinity', 'NonAlignedAffinity'
   */
  scheme: ServiceCorrelationScheme;
  /**
   * The name of the service that the correlation relationship is established with.
   */
  serviceName: string;
}

/**
 * Contains the possible cases for PartitionSchemeDescription.
 */
export type PartitionSchemeDescriptionUnion = PartitionSchemeDescription | NamedPartitionSchemeDescription | SingletonPartitionSchemeDescription | UniformInt64RangePartitionSchemeDescription;

/**
 * Describes how the service is partitioned.
 */
export interface PartitionSchemeDescription {
  /**
   * Polymorphic Discriminator
   */
  partitionScheme: "PartitionSchemeDescription";
}

/**
 * Describes the named partition scheme of the service.
 */
export interface NamedPartitionSchemeDescription {
  /**
   * Polymorphic Discriminator
   */
  partitionScheme: "Named";
  /**
   * The number of partitions.
   */
  count: number;
  /**
   * Array of size specified by the ‘count’ parameter, for the names of the partitions.
   */
  names: string[];
}

/**
 * Specifies a metric to load balance a service during runtime.
 */
export interface ServiceLoadMetricDescription {
  /**
   * The name of the metric. If the service chooses to report load during runtime, the load metric
   * name should match the name that is specified in Name exactly. Note that metric names are case
   * sensitive.
   */
  name: string;
  /**
   * The service load metric relative weight, compared to other metrics configured for this
   * service, as a number. Possible values include: 'Zero', 'Low', 'Medium', 'High'
   */
  weight?: ServiceLoadMetricWeight;
  /**
   * Used only for Stateful services. The default amount of load, as a number, that this service
   * creates for this metric when it is a Primary replica.
   */
  primaryDefaultLoad?: number;
  /**
   * Used only for Stateful services. The default amount of load, as a number, that this service
   * creates for this metric when it is a Secondary replica.
   */
  secondaryDefaultLoad?: number;
  /**
   * Used only for Stateless services. The default amount of load, as a number, that this service
   * creates for this metric.
   */
  defaultLoad?: number;
}

/**
 * Describes the policy to be used for placement of a Service Fabric service.
 */
export interface ServicePlacementPolicyDescription {
  /**
   * Polymorphic Discriminator
   */
  type: "ServicePlacementPolicyDescription";
}

/**
 * The common service resource properties.
 */
export interface ServiceResourcePropertiesBase {
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
}

/**
 * Contains the possible cases for ServiceResourceProperties.
 */
export type ServiceResourcePropertiesUnion = ServiceResourceProperties | StatefulServiceProperties | StatelessServiceProperties;

/**
 * The service resource properties.
 */
export interface ServiceResourceProperties {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ServiceResourceProperties";
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * The current deployment or provisioning state, which only appears in the response
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The name of the service type
   */
  serviceTypeName?: string;
  /**
   * Describes how the service is partitioned.
   */
  partitionDescription?: PartitionSchemeDescriptionUnion;
  /**
   * The activation Mode of the service package. Possible values include: 'SharedProcess',
   * 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ArmServicePackageActivationMode;
  /**
   * Dns name used for the service. If this is specified, then the service can be accessed via its
   * DNS name instead of service name.
   */
  serviceDnsName?: string;
}

/**
 * The service resource.
 */
export interface ServiceResource extends ProxyResource {
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * The current deployment or provisioning state, which only appears in the response
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The name of the service type
   */
  serviceTypeName?: string;
  /**
   * Describes how the service is partitioned.
   */
  partitionDescription?: PartitionSchemeDescriptionUnion;
  /**
   * The activation Mode of the service package. Possible values include: 'SharedProcess',
   * 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ArmServicePackageActivationMode;
  /**
   * Dns name used for the service. If this is specified, then the service can be accessed via its
   * DNS name instead of service name.
   */
  serviceDnsName?: string;
  /**
   * Polymorphic Discriminator
   */
  serviceKind: string;
}

/**
 * The list of service resources.
 */
export interface ServiceResourceList {
  value?: ServiceResource[];
  /**
   * URL to get the next set of service list results if there are any.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nextLink?: string;
}

/**
 * Contains the possible cases for ServiceResourceUpdateProperties.
 */
export type ServiceResourceUpdatePropertiesUnion = ServiceResourceUpdateProperties | StatefulServiceUpdateProperties | StatelessServiceUpdateProperties;

/**
 * The service resource properties for patch operations.
 */
export interface ServiceResourceUpdateProperties {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "ServiceResourceUpdateProperties";
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
}

/**
 * The service resource for patch operations.
 */
export interface ServiceResourceUpdate extends ProxyResource {
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * Polymorphic Discriminator
   */
  serviceKind: string;
}

/**
 * Describes the partition scheme of a singleton-partitioned, or non-partitioned service.
 */
export interface SingletonPartitionSchemeDescription {
  /**
   * Polymorphic Discriminator
   */
  partitionScheme: "Singleton";
}

/**
 * The properties of a stateful service resource.
 */
export interface StatefulServiceProperties {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * The current deployment or provisioning state, which only appears in the response
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The name of the service type
   */
  serviceTypeName?: string;
  /**
   * Describes how the service is partitioned.
   */
  partitionDescription?: PartitionSchemeDescriptionUnion;
  /**
   * The activation Mode of the service package. Possible values include: 'SharedProcess',
   * 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ArmServicePackageActivationMode;
  /**
   * Dns name used for the service. If this is specified, then the service can be accessed via its
   * DNS name instead of service name.
   */
  serviceDnsName?: string;
  /**
   * A flag indicating whether this is a persistent service which stores states on the local disk.
   * If it is then the value of this property is true, if not it is false.
   */
  hasPersistedState?: boolean;
  /**
   * The target replica set size as a number.
   */
  targetReplicaSetSize?: number;
  /**
   * The minimum replica set size as a number.
   */
  minReplicaSetSize?: number;
  /**
   * The duration between when a replica goes down and when a new replica is created, represented
   * in ISO 8601 format (hh:mm:ss.s).
   */
  replicaRestartWaitDuration?: Date;
  /**
   * The maximum duration for which a partition is allowed to be in a state of quorum loss,
   * represented in ISO 8601 format (hh:mm:ss.s).
   */
  quorumLossWaitDuration?: Date;
  /**
   * The definition on how long StandBy replicas should be maintained before being removed,
   * represented in ISO 8601 format (hh:mm:ss.s).
   */
  standByReplicaKeepDuration?: Date;
}

/**
 * The properties of a stateful service resource for patch operations.
 */
export interface StatefulServiceUpdateProperties {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateful";
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * The target replica set size as a number.
   */
  targetReplicaSetSize?: number;
  /**
   * The minimum replica set size as a number.
   */
  minReplicaSetSize?: number;
  /**
   * The duration between when a replica goes down and when a new replica is created, represented
   * in ISO 8601 format (hh:mm:ss.s).
   */
  replicaRestartWaitDuration?: Date;
  /**
   * The maximum duration for which a partition is allowed to be in a state of quorum loss,
   * represented in ISO 8601 format (hh:mm:ss.s).
   */
  quorumLossWaitDuration?: Date;
  /**
   * The definition on how long StandBy replicas should be maintained before being removed,
   * represented in ISO 8601 format (hh:mm:ss.s).
   */
  standByReplicaKeepDuration?: Date;
}

/**
 * The properties of a stateless service resource.
 */
export interface StatelessServiceProperties {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * The current deployment or provisioning state, which only appears in the response
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * The name of the service type
   */
  serviceTypeName?: string;
  /**
   * Describes how the service is partitioned.
   */
  partitionDescription?: PartitionSchemeDescriptionUnion;
  /**
   * The activation Mode of the service package. Possible values include: 'SharedProcess',
   * 'ExclusiveProcess'
   */
  servicePackageActivationMode?: ArmServicePackageActivationMode;
  /**
   * Dns name used for the service. If this is specified, then the service can be accessed via its
   * DNS name instead of service name.
   */
  serviceDnsName?: string;
  /**
   * The instance count.
   */
  instanceCount?: number;
  /**
   * Delay duration for RequestDrain feature to ensures that the endpoint advertised by the
   * stateless instance is removed before the delay starts prior to closing the instance. This
   * delay enables existing requests to drain gracefully before the instance actually goes down
   * (https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview).
   * It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it
   * is interpreted as a number representing the total number of milliseconds.
   */
  instanceCloseDelayDuration?: string;
}

/**
 * The properties of a stateless service resource for patch operations.
 */
export interface StatelessServiceUpdateProperties {
  /**
   * Polymorphic Discriminator
   */
  serviceKind: "Stateless";
  /**
   * The placement constraints as a string. Placement constraints are boolean expressions on node
   * properties and allow for restricting a service to particular nodes based on the service
   * requirements. For example, to place a service on nodes where NodeType is blue specify the
   * following: "NodeColor == blue)".
   */
  placementConstraints?: string;
  /**
   * A list that describes the correlation of the service with other services.
   */
  correlationScheme?: ServiceCorrelationDescription[];
  /**
   * The service load metrics is given as an array of ServiceLoadMetricDescription objects.
   */
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  /**
   * A list that describes the correlation of the service with other services.
   */
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  /**
   * Specifies the move cost for the service. Possible values include: 'Zero', 'Low', 'Medium',
   * 'High'
   */
  defaultMoveCost?: MoveCost;
  /**
   * The instance count.
   */
  instanceCount?: number;
  /**
   * Delay duration for RequestDrain feature to ensures that the endpoint advertised by the
   * stateless instance is removed before the delay starts prior to closing the instance. This
   * delay enables existing requests to drain gracefully before the instance actually goes down
   * (https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-application-upgrade-advanced#avoid-connection-drops-during-stateless-service-planned-downtime-preview).
   * It is first interpreted as a string representing an ISO 8601 duration. If that fails, then it
   * is interpreted as a number representing the total number of milliseconds.
   */
  instanceCloseDelayDuration?: string;
}

/**
 * Describes a partitioning scheme where an integer range is allocated evenly across a number of
 * partitions.
 */
export interface UniformInt64RangePartitionSchemeDescription {
  /**
   * Polymorphic Discriminator
   */
  partitionScheme: "UniformInt64Range";
  /**
   * The number of partitions.
   */
  count: number;
  /**
   * String indicating the lower bound of the partition key range that
   * should be split between the partition ‘count’
   */
  lowKey: string;
  /**
   * String indicating the upper bound of the partition key range that
   * should be split between the partition ‘count’
   */
  highKey: string;
}

/**
 * Client Certificate definition.
 */
export interface ClientCertificate {
  /**
   * Whether the certificate is admin or not.
   */
  isAdmin: boolean;
  /**
   * Certificate Thumbprint.
   */
  thumbprint?: string;
  /**
   * Certificate Common name.
   */
  commonName?: string;
  /**
   * Issuer thumbprint for the certificate. Its only use CommonName is used.
   */
  issuerThumbprint?: string;
}

/**
 * The detail of the Service Fabric runtime version.
 */
export interface ManagedClusterVersionDetails {
  /**
   * The Service Fabric runtime version of the cluster.
   */
  msiVersion?: string;
  /**
   * The date of expiry of support of the version.
   */
  supportExpiryUtc?: string;
  /**
   * Indicates the operating system of the cluster. Possible values include: 'Windows', 'Ubuntu',
   * 'RedHat', 'Ubuntu18_04'
   */
  osType?: OsType;
}

/**
 * Describes a load balancing rule.
 */
export interface LoadBalancingRule {
  /**
   * The port for the external endpoint. Port numbers for each rule must be unique within the Load
   * Balancer. Acceptable values are between 1 and 65534.
   */
  frontendPort: number;
  /**
   * The port used for internal connections on the endpoint. Acceptable values are between 1 and
   * 65535.
   */
  backendPort: number;
  /**
   * The reference to the transport protocol used by the load balancing rule. Possible values
   * include: 'tcp', 'udp'
   */
  protocol: Protocol;
  /**
   * the reference to the load balancer probe used by the load balancing rule. Possible values
   * include: 'tcp', 'http', 'https'
   */
  probeProtocol: ProbeProtocol;
  /**
   * The probe request path. Only supported for HTTP/HTTPS probes.
   */
  probeRequestPath?: string;
}

/**
 * Sku definition
 */
export interface Sku {
  /**
   * Sku Name. Basic will have a minimum of 3 seed nodes and Standard a minimum of 5. Basic only
   * allows 1 node type. Possible values include: 'Basic', 'Standard'
   */
  name: Name;
}

/**
 * The manged cluster resource

 */
export interface ManagedCluster extends Resource {
  /**
   * The cluster dns name.
   */
  dnsName: string;
  /**
   * the cluster Fully qualified domain name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly fqdn?: string;
  /**
   * A service generated unique identifier for the cluster resource.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clusterId?: string;
  /**
   * The current state of the cluster.
   *
   * - WaitingForNodes - Indicates that the cluster resource is created and the resource provider
   * is waiting for Service Fabric VM extension to boot up and report to it.
   * - Deploying - Indicates that the Service Fabric runtime is being installed on the VMs. Cluster
   * resource will be in this state until the cluster boots up and system services are up.
   * - BaselineUpgrade - Indicates that the cluster is upgrading to establishes the cluster
   * version. This upgrade is automatically initiated when the cluster boots up for the first time.
   * - UpdatingUserConfiguration - Indicates that the cluster is being upgraded with the user
   * provided configuration.
   * - UpdatingUserCertificate - Indicates that the cluster is being upgraded with the user
   * provided certificate.
   * - UpdatingInfrastructure - Indicates that the cluster is being upgraded with the latest
   * Service Fabric runtime version. This happens only when the **upgradeMode** is set to
   * 'Automatic'.
   * - EnforcingClusterVersion - Indicates that cluster is on a different version than expected and
   * the cluster is being upgraded to the expected version.
   * - UpgradeServiceUnreachable - Indicates that the system service in the cluster is no longer
   * polling the Resource Provider. Clusters in this state cannot be managed by the Resource
   * Provider.
   * - AutoScale - Indicates that the ReliabilityLevel of the cluster is being adjusted.
   * - Ready - Indicates that the cluster is in a stable state.
   * . Possible values include: 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
   * 'UpdatingUserConfiguration', 'UpdatingUserCertificate', 'UpdatingInfrastructure',
   * 'EnforcingClusterVersion', 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clusterState?: ClusterState1;
  /**
   * The cluster certificate thumbprint used node to node communication.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly clusterCertificateThumbprint?: string;
  /**
   * The port used for client connections to the cluster. Default value: 19000.
   */
  clientConnectionPort?: number;
  /**
   * The port used for http connections to the cluster. Default value: 19080.
   */
  httpGatewayConnectionPort?: number;
  /**
   * vm admin user name.
   */
  adminUserName: string;
  /**
   * vm admin user password.
   */
  adminPassword?: string;
  /**
   * Describes load balancing rules.
   */
  loadBalancingRules?: LoadBalancingRule[];
  /**
   * client certificates for the cluster.
   */
  clients?: ClientCertificate[];
  /**
   * Azure active directory.
   */
  azureActiveDirectory?: AzureActiveDirectory;
  /**
   * The list of custom fabric settings to configure the cluster.
   */
  fabricSettings?: SettingsSectionDescription[];
  /**
   * The provisioning state of the managed cluster resource. Possible values include: 'None',
   * 'Creating', 'Created', 'Updating', 'Succeeded', 'Failed', 'Canceled', 'Deleting', 'Deleted',
   * 'Other'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: ProvisioningState1;
  /**
   * The Service Fabric runtime version of the cluster. This property can only by set the user when
   * **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new
   * clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of available version
   * for existing clusters use **availableClusterVersions**.
   */
  clusterCodeVersion?: string;
  /**
   * The upgrade mode of the cluster when new Service Fabric runtime version is available.
   *
   * - Automatic - The cluster will be automatically upgraded to the latest Service Fabric runtime
   * version as soon as it is available.
   * - Manual - The cluster will not be automatically upgraded to the latest Service Fabric runtime
   * version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster
   * resource.
   * . Possible values include: 'Automatic', 'Manual'
   */
  clusterUpgradeMode?: ClusterUpgradeMode;
  /**
   * Describes the policy used when upgrading the cluster.
   */
  clusterUpgradeDescription?: ClusterUpgradePolicy;
  /**
   * The sku of the managed cluster
   */
  sku?: Sku;
}

/**
 * Managed cluster update request
 */
export interface ManagedClusterUpdateParameters {
  /**
   * The port used for client connections to the cluster.
   */
  clientConnectionPort?: number;
  /**
   * The port used for http connections to the cluster.
   */
  httpGatewayConnectionPort?: number;
  /**
   * Describes a load balancing rule.
   */
  loadBalancingRules?: LoadBalancingRule[];
  /**
   * client certificates for the cluster.
   */
  clients?: ClientCertificate[];
  /**
   * Azure active directory.
   */
  azureActiveDirectory?: AzureActiveDirectory;
  /**
   * The list of custom fabric settings to configure the cluster.
   */
  fabricSettings?: SettingsSectionDescription[];
  /**
   * The Service Fabric runtime version of the cluster. This property can only by set the user when
   * **upgradeMode** is set to 'Manual'. To get list of available Service Fabric versions for new
   * clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of available version
   * for existing clusters use **availableClusterVersions**.
   */
  clusterCodeVersion?: string;
  /**
   * The upgrade mode of the cluster when new Service Fabric runtime version is available.
   *
   * - Automatic - The cluster will be automatically upgraded to the latest Service Fabric runtime
   * version as soon as it is available.
   * - Manual - The cluster will not be automatically upgraded to the latest Service Fabric runtime
   * version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster
   * resource.
   * . Possible values include: 'Automatic', 'Manual'
   */
  clusterUpgradeMode?: ClusterUpgradeMode1;
  /**
   * Describes the policy used when upgrading the cluster.
   */
  clusterUpgradeDescription?: ClusterUpgradePolicy;
  /**
   * Managed cluster update parameters
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Azure resource identifier.
 */
export interface SubResource extends BaseResource {
  /**
   * Azure resource identifier.
   */
  id?: string;
}

/**
 * Describes a single certificate reference in a Key Vault, and where the certificate should reside
 * on the VM.
 */
export interface VaultCertificate {
  /**
   * This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a
   * secret to the Key Vault, see [Add a key or secret to the key
   * vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case,
   * your certificate needs to be It is the Base64 encoding of the following JSON Object which is
   * encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>
   * "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
   */
  certificateUrl: string;
  /**
   * For Windows VMs, specifies the certificate store on the Virtual Machine to which the
   * certificate should be added. The specified certificate store is implicitly in the LocalMachine
   * account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent
   * directory, with the file name <UppercaseThumbprint>.crt for the X509 certificate file and
   * <UppercaseThumbprint>.prv for private key. Both of these files are .pem formatted.
   */
  certificateStore: string;
}

/**
 * Specifies set of certificates that should be installed onto the virtual machines.
 */
export interface VaultSecretGroup {
  /**
   * The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
   */
  sourceVault: SubResource;
  /**
   * The list of key vault references in SourceVault which contain certificates.
   */
  vaultCertificates: VaultCertificate[];
}

/**
 * Specifies set of extensions that should be installed onto the virtual machines.
 */
export interface VMSSExtension {
  /**
   * The name of the extension.
   */
  name: string;
  /**
   * If a value is provided and is different from the previous value, the extension handler will be
   * forced to update even if the extension configuration has not changed.
   */
  forceUpdateTag?: string;
  /**
   * The name of the extension handler publisher.
   */
  publisher: string;
  /**
   * Specifies the type of the extension; an example is "CustomScriptExtension".
   */
  type: string;
  /**
   * Specifies the version of the script handler.
   */
  typeHandlerVersion: string;
  /**
   * Indicates whether the extension should use a newer minor version if one is available at
   * deployment time. Once deployed, however, the extension will not upgrade minor versions unless
   * redeployed, even with this property set to true.
   */
  autoUpgradeMinorVersion?: boolean;
  /**
   * Json formatted public settings for the extension.
   */
  settings?: any;
  /**
   * The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no
   * protected settings at all.
   */
  protectedSettings?: any;
  /**
   * The provisioning state, which only appears in the response.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: string;
  /**
   * Collection of extension names after which this extension needs to be provisioned.
   */
  provisionAfterExtensions?: string[];
}

/**
 * The resource model definition for proxy-only resource.
 */
export interface ManagedProxyResource extends BaseResource {
  /**
   * Azure resource identifier.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly id?: string;
  /**
   * Azure resource name.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly name?: string;
  /**
   * Azure resource type.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly type?: string;
  /**
   * Azure resource tags.
   */
  tags?: { [propertyName: string]: string };
}

/**
 * Describes a node type in the cluster, each node type represents sub set of nodes in the cluster.
 */
export interface NodeType extends ManagedProxyResource {
  /**
   * The node type on which system services will run. Only one node type should be marked as
   * primary. Primary node type cannot be deleted or changed for existing clusters.
   */
  isPrimary: boolean;
  /**
   * The number of nodes in the node type.
   */
  vmInstanceCount: number;
  /**
   * Disk size for each vm in the node type in GBs.
   */
  dataDiskSizeGB: number;
  /**
   * The placement tags applied to nodes in the node type, which can be used to indicate where
   * certain services (workload) should run.
   */
  placementProperties?: { [propertyName: string]: string };
  /**
   * The capacity tags applied to the nodes in the node type, the cluster resource manager uses
   * these tags to understand how much resource a node has.
   */
  capacities?: { [propertyName: string]: string };
  /**
   * The range of ports from which cluster assigned port to Service Fabric applications.
   */
  applicationPorts?: EndpointRangeDescription;
  /**
   * The range of ephemeral ports that nodes in this node type should be configured with.
   */
  ephemeralPorts?: EndpointRangeDescription;
  /**
   * The size of virtual machines in the pool. All virtual machines in a pool are the same size.
   * For example, Standard_D3.
   */
  vmSize?: string;
  /**
   * The publisher of the Azure Virtual Machines Marketplace image. For example, Canonical or
   * MicrosoftWindowsServer.
   */
  vmImagePublisher?: string;
  /**
   * The offer type of the Azure Virtual Machines Marketplace image. For example, UbuntuServer or
   * WindowsServer.
   */
  vmImageOffer?: string;
  /**
   * The SKU of the Azure Virtual Machines Marketplace image. For example, 14.04.0-LTS or
   * 2012-R2-Datacenter.
   */
  vmImageSku?: string;
  /**
   * The version of the Azure Virtual Machines Marketplace image. A value of 'latest' can be
   * specified to select the latest version of an image. If omitted, the default is 'latest'.
   */
  vmImageVersion?: string;
  /**
   * virtual machine secretes. The secrets to install in the virtual machines.
   */
  vmSecrets?: VaultSecretGroup[];
  /**
   * virtual machine extensions. Set of extensions that should be installed onto the virtual
   * machines.
   */
  vmExtensions?: VMSSExtension[];
  /**
   * The provisioning state of the managed cluster resource. Possible values include: 'None',
   * 'Creating', 'Created', 'Updating', 'Succeeded', 'Failed', 'Canceled', 'Deleting', 'Deleted',
   * 'Other'
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly provisioningState?: ProvisioningState2;
}

/**
 * Parameters for Node type action.
 */
export interface NodeTypeActionParameters {
  /**
   * List of node names from the node type.
   */
  nodes: string[];
  /**
   * Force the action to go through.
   */
  force?: boolean;
}

/**
 * Node type update request
 */
export interface NodeTypeUpdateParameters {
  /**
   * The number of nodes in the node type. This count should match the capacity property in the
   * corresponding VirtualMachineScaleSet resource.
   */
  vmInstanceCount?: number;
  /**
   * The placement tags applied to nodes in the node type, which can be used to indicate where
   * certain services (workload) should run.
   */
  placementProperties?: { [propertyName: string]: string };
  /**
   * The capacity tags applied to the nodes in the node type, the cluster resource manager uses
   * these tags to understand how much resource a node has.
   */
  capacities?: { [propertyName: string]: string };
  /**
   * The range of ports from which cluster assigned port to Service Fabric applications.
   */
  applicationPorts?: EndpointRangeDescription;
  /**
   * The range of ephemeral ports that nodes in this node type should be configured with.
   */
  ephemeralPorts?: EndpointRangeDescription;
  /**
   * virtual machine secretes. The secrets to install in the virtual machines.
   */
  vmSecrets?: VaultSecretGroup[];
  /**
   * virtual machine extensions. Set of extensions that should be installed onto the virtual
   * machines.
   */
  vmExtensions?: VMSSExtension[];
  /**
   * Node type update parameters
   */
  tags?: { [propertyName: string]: string };
}

/**
 * An interface representing ServiceFabricManagementClientOptions.
 */
export interface ServiceFabricManagementClientOptions extends AzureServiceClientOptions {
  baseUri?: string;
}

/**
 * @interface
 * Describes the result of the request to list Service Fabric resource provider operations.
 * @extends Array<OperationResult>
 */
export interface OperationListResult extends Array<OperationResult> {
  /**
   * URL to get the next set of operation list results if there are any.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nextLink?: string;
}

/**
 * @interface
 * Managed Cluster list results
 * @extends Array<ManagedCluster>
 */
export interface ManagedClusterListResult extends Array<ManagedCluster> {
  /**
   * The URL to use for getting the next set of results.
   */
  nextLink?: string;
}

/**
 * @interface
 * Node type list results
 * @extends Array<NodeType>
 */
export interface NodeTypeListResult extends Array<NodeType> {
  /**
   * The URL to use for getting the next set of results.
   */
  nextLink?: string;
}

/**
 * Defines values for ProvisioningState.
 * Possible values include: 'Updating', 'Succeeded', 'Failed', 'Canceled'
 * @readonly
 * @enum {string}
 */
export type ProvisioningState = 'Updating' | 'Succeeded' | 'Failed' | 'Canceled';

/**
 * Defines values for ManagedIdentityType.
 * Possible values include: 'SystemAssigned', 'UserAssigned', 'SystemAssigned, UserAssigned',
 * 'None'
 * @readonly
 * @enum {string}
 */
export type ManagedIdentityType = 'SystemAssigned' | 'UserAssigned' | 'SystemAssigned, UserAssigned' | 'None';

/**
 * Defines values for ArmUpgradeFailureAction.
 * Possible values include: 'Rollback', 'Manual'
 * @readonly
 * @enum {string}
 */
export type ArmUpgradeFailureAction = 'Rollback' | 'Manual';

/**
 * Defines values for RollingUpgradeMode.
 * Possible values include: 'Invalid', 'UnmonitoredAuto', 'UnmonitoredManual', 'Monitored'
 * @readonly
 * @enum {string}
 */
export type RollingUpgradeMode = 'Invalid' | 'UnmonitoredAuto' | 'UnmonitoredManual' | 'Monitored';

/**
 * Defines values for ServiceCorrelationScheme.
 * Possible values include: 'Invalid', 'Affinity', 'AlignedAffinity', 'NonAlignedAffinity'
 * @readonly
 * @enum {string}
 */
export type ServiceCorrelationScheme = 'Invalid' | 'Affinity' | 'AlignedAffinity' | 'NonAlignedAffinity';

/**
 * Defines values for MoveCost.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High'
 * @readonly
 * @enum {string}
 */
export type MoveCost = 'Zero' | 'Low' | 'Medium' | 'High';

/**
 * Defines values for PartitionScheme.
 * Possible values include: 'Invalid', 'Singleton', 'UniformInt64Range', 'Named'
 * @readonly
 * @enum {string}
 */
export type PartitionScheme = 'Invalid' | 'Singleton' | 'UniformInt64Range' | 'Named';

/**
 * Defines values for ServiceKind.
 * Possible values include: 'Invalid', 'Stateless', 'Stateful'
 * @readonly
 * @enum {string}
 */
export type ServiceKind = 'Invalid' | 'Stateless' | 'Stateful';

/**
 * Defines values for ServiceLoadMetricWeight.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High'
 * @readonly
 * @enum {string}
 */
export type ServiceLoadMetricWeight = 'Zero' | 'Low' | 'Medium' | 'High';

/**
 * Defines values for ServicePlacementPolicyType.
 * Possible values include: 'Invalid', 'InvalidDomain', 'RequiredDomain', 'PreferredPrimaryDomain',
 * 'RequiredDomainDistribution', 'NonPartiallyPlaceService'
 * @readonly
 * @enum {string}
 */
export type ServicePlacementPolicyType = 'Invalid' | 'InvalidDomain' | 'RequiredDomain' | 'PreferredPrimaryDomain' | 'RequiredDomainDistribution' | 'NonPartiallyPlaceService';

/**
 * Defines values for ArmServicePackageActivationMode.
 * Possible values include: 'SharedProcess', 'ExclusiveProcess'
 * @readonly
 * @enum {string}
 */
export type ArmServicePackageActivationMode = 'SharedProcess' | 'ExclusiveProcess';

/**
 * Defines values for Protocol.
 * Possible values include: 'tcp', 'udp'
 * @readonly
 * @enum {string}
 */
export type Protocol = 'tcp' | 'udp';

/**
 * Defines values for ProbeProtocol.
 * Possible values include: 'tcp', 'http', 'https'
 * @readonly
 * @enum {string}
 */
export type ProbeProtocol = 'tcp' | 'http' | 'https';

/**
 * Defines values for X509StoreName.
 * Possible values include: 'AddressBook', 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My',
 * 'Root', 'TrustedPeople', 'TrustedPublisher'
 * @readonly
 * @enum {string}
 */
export type X509StoreName = 'AddressBook' | 'AuthRoot' | 'CertificateAuthority' | 'Disallowed' | 'My' | 'Root' | 'TrustedPeople' | 'TrustedPublisher';

/**
 * Defines values for Environment.
 * Possible values include: 'Windows', 'Linux'
 * @readonly
 * @enum {string}
 */
export type Environment = 'Windows' | 'Linux';

/**
 * Defines values for X509StoreName1.
 * Possible values include: 'AddressBook', 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My',
 * 'Root', 'TrustedPeople', 'TrustedPublisher'
 * @readonly
 * @enum {string}
 */
export type X509StoreName1 = 'AddressBook' | 'AuthRoot' | 'CertificateAuthority' | 'Disallowed' | 'My' | 'Root' | 'TrustedPeople' | 'TrustedPublisher';

/**
 * Defines values for DurabilityLevel.
 * Possible values include: 'Bronze', 'Silver', 'Gold'
 * @readonly
 * @enum {string}
 */
export type DurabilityLevel = 'Bronze' | 'Silver' | 'Gold';

/**
 * Defines values for ClusterState.
 * Possible values include: 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
 * 'UpdatingUserConfiguration', 'UpdatingUserCertificate', 'UpdatingInfrastructure',
 * 'EnforcingClusterVersion', 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
 * @readonly
 * @enum {string}
 */
export type ClusterState = 'WaitingForNodes' | 'Deploying' | 'BaselineUpgrade' | 'UpdatingUserConfiguration' | 'UpdatingUserCertificate' | 'UpdatingInfrastructure' | 'EnforcingClusterVersion' | 'UpgradeServiceUnreachable' | 'AutoScale' | 'Ready';

/**
 * Defines values for ReliabilityLevel.
 * Possible values include: 'None', 'Bronze', 'Silver', 'Gold', 'Platinum'
 * @readonly
 * @enum {string}
 */
export type ReliabilityLevel = 'None' | 'Bronze' | 'Silver' | 'Gold' | 'Platinum';

/**
 * Defines values for UpgradeMode.
 * Possible values include: 'Automatic', 'Manual'
 * @readonly
 * @enum {string}
 */
export type UpgradeMode = 'Automatic' | 'Manual';

/**
 * Defines values for ReliabilityLevel1.
 * Possible values include: 'None', 'Bronze', 'Silver', 'Gold', 'Platinum'
 * @readonly
 * @enum {string}
 */
export type ReliabilityLevel1 = 'None' | 'Bronze' | 'Silver' | 'Gold' | 'Platinum';

/**
 * Defines values for UpgradeMode1.
 * Possible values include: 'Automatic', 'Manual'
 * @readonly
 * @enum {string}
 */
export type UpgradeMode1 = 'Automatic' | 'Manual';

/**
 * Defines values for OsType.
 * Possible values include: 'Windows', 'Ubuntu', 'RedHat', 'Ubuntu18_04'
 * @readonly
 * @enum {string}
 */
export type OsType = 'Windows' | 'Ubuntu' | 'RedHat' | 'Ubuntu18_04';

/**
 * Defines values for Name.
 * Possible values include: 'Basic', 'Standard'
 * @readonly
 * @enum {string}
 */
export type Name = 'Basic' | 'Standard';

/**
 * Defines values for ClusterState1.
 * Possible values include: 'WaitingForNodes', 'Deploying', 'BaselineUpgrade',
 * 'UpdatingUserConfiguration', 'UpdatingUserCertificate', 'UpdatingInfrastructure',
 * 'EnforcingClusterVersion', 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
 * @readonly
 * @enum {string}
 */
export type ClusterState1 = 'WaitingForNodes' | 'Deploying' | 'BaselineUpgrade' | 'UpdatingUserConfiguration' | 'UpdatingUserCertificate' | 'UpdatingInfrastructure' | 'EnforcingClusterVersion' | 'UpgradeServiceUnreachable' | 'AutoScale' | 'Ready';

/**
 * Defines values for ProvisioningState1.
 * Possible values include: 'None', 'Creating', 'Created', 'Updating', 'Succeeded', 'Failed',
 * 'Canceled', 'Deleting', 'Deleted', 'Other'
 * @readonly
 * @enum {string}
 */
export type ProvisioningState1 = 'None' | 'Creating' | 'Created' | 'Updating' | 'Succeeded' | 'Failed' | 'Canceled' | 'Deleting' | 'Deleted' | 'Other';

/**
 * Defines values for ClusterUpgradeMode.
 * Possible values include: 'Automatic', 'Manual'
 * @readonly
 * @enum {string}
 */
export type ClusterUpgradeMode = 'Automatic' | 'Manual';

/**
 * Defines values for ClusterUpgradeMode1.
 * Possible values include: 'Automatic', 'Manual'
 * @readonly
 * @enum {string}
 */
export type ClusterUpgradeMode1 = 'Automatic' | 'Manual';

/**
 * Defines values for ProvisioningState2.
 * Possible values include: 'None', 'Creating', 'Created', 'Updating', 'Succeeded', 'Failed',
 * 'Canceled', 'Deleting', 'Deleted', 'Other'
 * @readonly
 * @enum {string}
 */
export type ProvisioningState2 = 'None' | 'Creating' | 'Created' | 'Updating' | 'Succeeded' | 'Failed' | 'Canceled' | 'Deleting' | 'Deleted' | 'Other';

/**
 * Defines values for Environment1.
 * Possible values include: 'Windows', 'Linux'
 * @readonly
 * @enum {string}
 */
export type Environment1 = 'Windows' | 'Linux';

/**
 * Defines values for Environment2.
 * Possible values include: 'Windows', 'Linux'
 * @readonly
 * @enum {string}
 */
export type Environment2 = 'Windows' | 'Linux';

/**
 * Defines values for OsType1.
 * Possible values include: 'Windows', 'Ubuntu', 'RedHat', 'Ubuntu18_04'
 * @readonly
 * @enum {string}
 */
export type OsType1 = 'Windows' | 'Ubuntu' | 'RedHat' | 'Ubuntu18_04';

/**
 * Contains response data for the get operation.
 */
export type ClustersGetResponse = Cluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Cluster;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ClustersCreateOrUpdateResponse = Cluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Cluster;
    };
};

/**
 * Contains response data for the update operation.
 */
export type ClustersUpdateResponse = Cluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Cluster;
    };
};

/**
 * Contains response data for the listByResourceGroup operation.
 */
export type ClustersListByResourceGroupResponse = ClusterListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ClustersListResponse = ClusterListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterListResult;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type ClustersBeginCreateOrUpdateResponse = Cluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Cluster;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type ClustersBeginUpdateResponse = Cluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Cluster;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ClusterVersionsGetResponse = ClusterCodeVersionsListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterCodeVersionsListResult;
    };
};

/**
 * Contains response data for the getByEnvironment operation.
 */
export type ClusterVersionsGetByEnvironmentResponse = ClusterCodeVersionsListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterCodeVersionsListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ClusterVersionsListResponse = ClusterCodeVersionsListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterCodeVersionsListResult;
    };
};

/**
 * Contains response data for the listByEnvironment operation.
 */
export type ClusterVersionsListByEnvironmentResponse = ClusterCodeVersionsListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ClusterCodeVersionsListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type OperationsListResponse = OperationListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationListResult;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type OperationsListNextResponse = OperationListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ApplicationTypesGetResponse = ApplicationTypeResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeResource;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ApplicationTypesCreateOrUpdateResponse = ApplicationTypeResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeResource;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ApplicationTypesListResponse = ApplicationTypeResourceList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeResourceList;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ApplicationTypeVersionsGetResponse = ApplicationTypeVersionResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeVersionResource;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ApplicationTypeVersionsCreateOrUpdateResponse = ApplicationTypeVersionResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeVersionResource;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ApplicationTypeVersionsListResponse = ApplicationTypeVersionResourceList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeVersionResourceList;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type ApplicationTypeVersionsBeginCreateOrUpdateResponse = ApplicationTypeVersionResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationTypeVersionResource;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ApplicationsGetResponse = ApplicationResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResource;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ApplicationsCreateOrUpdateResponse = ApplicationResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResource;
    };
};

/**
 * Contains response data for the update operation.
 */
export type ApplicationsUpdateResponse = ApplicationResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResource;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ApplicationsListResponse = ApplicationResourceList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResourceList;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type ApplicationsBeginCreateOrUpdateResponse = ApplicationResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResource;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type ApplicationsBeginUpdateResponse = ApplicationResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ApplicationResource;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ServicesGetResponse = ServiceResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResource;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ServicesCreateOrUpdateResponse = ServiceResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResource;
    };
};

/**
 * Contains response data for the update operation.
 */
export type ServicesUpdateResponse = ServiceResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResource;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ServicesListResponse = ServiceResourceList & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResourceList;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type ServicesBeginCreateOrUpdateResponse = ServiceResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResource;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type ServicesBeginUpdateResponse = ServiceResource & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ServiceResource;
    };
};

/**
 * Contains response data for the listByResourceGroup operation.
 */
export type ManagedClustersListByResourceGroupResponse = ManagedClusterListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedClusterListResult;
    };
};

/**
 * Contains response data for the listBySubscription operation.
 */
export type ManagedClustersListBySubscriptionResponse = ManagedClusterListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedClusterListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ManagedClustersGetResponse = ManagedCluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedCluster;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ManagedClustersCreateOrUpdateResponse = ManagedCluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedCluster;
    };
};

/**
 * Contains response data for the update operation.
 */
export type ManagedClustersUpdateResponse = ManagedCluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedCluster;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type ManagedClustersBeginCreateOrUpdateResponse = ManagedCluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedCluster;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type ManagedClustersBeginUpdateResponse = ManagedCluster & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedCluster;
    };
};

/**
 * Contains response data for the listByResourceGroupNext operation.
 */
export type ManagedClustersListByResourceGroupNextResponse = ManagedClusterListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedClusterListResult;
    };
};

/**
 * Contains response data for the listBySubscriptionNext operation.
 */
export type ManagedClustersListBySubscriptionNextResponse = ManagedClusterListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedClusterListResult;
    };
};

/**
 * Contains response data for the listByOS operation.
 */
export type ManagedClusterVersionsListByOSResponse = Array<ManagedClusterVersionDetails> & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ManagedClusterVersionDetails[];
    };
};

/**
 * Contains response data for the listByManagedClusters operation.
 */
export type NodeTypesListByManagedClustersResponse = NodeTypeListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeTypeListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type NodeTypesGetResponse = NodeType & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeType;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type NodeTypesCreateOrUpdateResponse = NodeType & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeType;
    };
};

/**
 * Contains response data for the update operation.
 */
export type NodeTypesUpdateResponse = NodeType & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeType;
    };
};

/**
 * Contains response data for the beginCreateOrUpdate operation.
 */
export type NodeTypesBeginCreateOrUpdateResponse = NodeType & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeType;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type NodeTypesBeginUpdateResponse = NodeType & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeType;
    };
};

/**
 * Contains response data for the listByManagedClustersNext operation.
 */
export type NodeTypesListByManagedClustersNextResponse = NodeTypeListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: NodeTypeListResult;
    };
};
