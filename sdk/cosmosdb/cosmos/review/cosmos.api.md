## API Report File for "@azure/cosmos"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export class ClientSideMetrics {
    constructor(requestCharge: number);
    add(...clientSideMetricsArray: ClientSideMetrics[]): ClientSideMetrics;
    // (undocumented)
    static createFromArray(...clientSideMetricsArray: ClientSideMetrics[]): ClientSideMetrics;
    // (undocumented)
    readonly requestCharge: number;
    // (undocumented)
    static readonly zero: ClientSideMetrics;
}

// @public
export class Conflict {
    // Warning: (ae-forgotten-export) The symbol "ClientContext" needs to be exported by the entry point index.d.ts
    constructor(container: Container, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete(options?: RequestOptions): Promise<ConflictResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<ConflictResponse>;
    readonly url: string;
}

// @public (undocumented)
export interface ConflictDefinition {
    // (undocumented)
    content?: string;
    id?: string;
    // (undocumented)
    operationType?: OperationType;
    resourceId?: string;
    // Warning: (ae-forgotten-export) The symbol "ResourceType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    resourceType?: ResourceType;
}

// @public (undocumented)
export enum ConflictResolutionMode {
    // (undocumented)
    Custom = "Custom",
    // (undocumented)
    LastWriterWins = "LastWriterWins"
}

// @public
export interface ConflictResolutionPolicy {
    conflictResolutionPath?: string;
    conflictResolutionProcedure?: string;
    mode?: keyof typeof ConflictResolutionMode;
}

// @public (undocumented)
export class ConflictResponse extends ResourceResponse<ConflictDefinition & Resource> {
    constructor(resource: ConflictDefinition & Resource, headers: CosmosHeaders, statusCode: number, conflict: Conflict);
    readonly conflict: Conflict;
}

// @public
export class Conflicts {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<ConflictDefinition & Resource>;
}

// @public
export enum ConnectionMode {
    Gateway = 0
}

// @public
export interface ConnectionPolicy {
    connectionMode?: ConnectionMode;
    enableEndpointDiscovery?: boolean;
    preferredLocations?: string[];
    requestTimeout?: number;
    retryOptions?: RetryOptions;
    useMultipleWriteLocations?: boolean;
}

// @public
export enum ConsistencyLevel {
    BoundedStaleness = "BoundedStaleness",
    ConsistentPrefix = "ConsistentPrefix",
    Eventual = "Eventual",
    Session = "Session",
    Strong = "Strong"
}

// @public (undocumented)
export const Constants: {
    HttpHeaders: {
        Authorization: string;
        ETag: string;
        MethodOverride: string;
        Slug: string;
        ContentType: string;
        LastModified: string;
        ContentEncoding: string;
        CharacterSet: string;
        UserAgent: string;
        IfModifiedSince: string;
        IfMatch: string;
        IfNoneMatch: string;
        ContentLength: string;
        AcceptEncoding: string;
        KeepAlive: string;
        CacheControl: string;
        TransferEncoding: string;
        ContentLanguage: string;
        ContentLocation: string;
        ContentMd5: string;
        ContentRange: string;
        Accept: string;
        AcceptCharset: string;
        AcceptLanguage: string;
        IfRange: string;
        IfUnmodifiedSince: string;
        MaxForwards: string;
        ProxyAuthorization: string;
        AcceptRanges: string;
        ProxyAuthenticate: string;
        RetryAfter: string;
        SetCookie: string;
        WwwAuthenticate: string;
        Origin: string;
        Host: string;
        AccessControlAllowOrigin: string;
        AccessControlAllowHeaders: string;
        KeyValueEncodingFormat: string;
        WrapAssertionFormat: string;
        WrapAssertion: string;
        WrapScope: string;
        SimpleToken: string;
        HttpDate: string;
        Prefer: string;
        Location: string;
        Referer: string;
        A_IM: string;
        Query: string;
        IsQuery: string;
        IsQueryPlan: string;
        SupportedQueryFeatures: string;
        QueryVersion: string;
        Continuation: string;
        PageSize: string;
        ItemCount: string;
        ActivityId: string;
        PreTriggerInclude: string;
        PreTriggerExclude: string;
        PostTriggerInclude: string;
        PostTriggerExclude: string;
        IndexingDirective: string;
        SessionToken: string;
        ConsistencyLevel: string;
        XDate: string;
        CollectionPartitionInfo: string;
        CollectionServiceInfo: string;
        RetryAfterInMilliseconds: string;
        RetryAfterInMs: string;
        IsFeedUnfiltered: string;
        ResourceTokenExpiry: string;
        EnableScanInQuery: string;
        EmitVerboseTracesInQuery: string;
        EnableCrossPartitionQuery: string;
        ParallelizeCrossPartitionQuery: string;
        ResponseContinuationTokenLimitInKB: string;
        PopulateQueryMetrics: string;
        QueryMetrics: string;
        Version: string;
        OwnerFullName: string;
        OwnerId: string;
        PartitionKey: string;
        PartitionKeyRangeID: string;
        MaxEntityCount: string;
        CurrentEntityCount: string;
        CollectionQuotaInMb: string;
        CollectionCurrentUsageInMb: string;
        MaxMediaStorageUsageInMB: string;
        CurrentMediaStorageUsageInMB: string;
        RequestCharge: string;
        PopulateQuotaInfo: string;
        MaxResourceQuota: string;
        OfferType: string;
        OfferThroughput: string;
        DisableRUPerMinuteUsage: string;
        IsRUPerMinuteUsed: string;
        OfferIsRUPerMinuteThroughputEnabled: string;
        IndexTransformationProgress: string;
        LazyIndexingProgress: string;
        IsUpsert: string;
        SubStatus: string;
        EnableScriptLogging: string;
        ScriptLogResults: string;
        ALLOW_MULTIPLE_WRITES: string;
    };
    WritableLocations: string;
    ReadableLocations: string;
    ENABLE_MULTIPLE_WRITABLE_LOCATIONS: string;
    DefaultUnavailableLocationExpirationTimeMS: number;
    ThrottleRetryCount: string;
    ThrottleRetryWaitTimeInMs: string;
    CurrentVersion: string;
    SDKName: string;
    SDKVersion: string;
    Quota: {
        CollectionSize: string;
    };
    Path: {
        DatabasesPathSegment: string;
        CollectionsPathSegment: string;
        UsersPathSegment: string;
        DocumentsPathSegment: string;
        PermissionsPathSegment: string;
        StoredProceduresPathSegment: string;
        TriggersPathSegment: string;
        UserDefinedFunctionsPathSegment: string;
        ConflictsPathSegment: string;
        AttachmentsPathSegment: string;
        PartitionKeyRangesPathSegment: string;
        SchemasPathSegment: string;
        OffersPathSegment: string;
        TopologyPathSegment: string;
        DatabaseAccountPathSegment: string;
    };
    PartitionKeyRange: {
        MinInclusive: string;
        MaxExclusive: string;
        Id: string;
    };
    QueryRangeConstants: {
        MinInclusive: string;
        MaxExclusive: string;
        min: string;
    };
    EffectiveParitionKeyConstants: {
        MinimumInclusiveEffectivePartitionKey: string;
        MaximumExclusiveEffectivePartitionKey: string;
    };
};

// @public
export class Container {
    constructor(database: Database, id: string, clientContext: ClientContext);
    conflict(id: string): Conflict;
    readonly conflicts: Conflicts;
    // (undocumented)
    readonly database: Database;
    delete(options?: RequestOptions): Promise<ContainerResponse>;
    // @deprecated
    getPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>>;
    // Warning: (ae-forgotten-export) The symbol "PartitionedQueryExecutionInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getQueryPlan(query: string | SqlQuerySpec): Promise<Response<PartitionedQueryExecutionInfo>>;
    // (undocumented)
    readonly id: string;
    item(id: string, partitionKeyValue?: any): Item;
    readonly items: Items;
    read(options?: RequestOptions): Promise<ContainerResponse>;
    readPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>>;
    // (undocumented)
    readPartitionKeyRanges(feedOptions?: FeedOptions): QueryIterator<PartitionKeyRange>;
    replace(body: ContainerDefinition, options?: RequestOptions): Promise<ContainerResponse>;
    // Warning: (ae-forgotten-export) The symbol "Scripts" needs to be exported by the entry point index.d.ts
    readonly scripts: Scripts;
    readonly url: string;
}

// @public (undocumented)
export interface ContainerDefinition {
    conflictResolutionPolicy?: ConflictResolutionPolicy;
    defaultTtl?: number;
    id?: string;
    indexingPolicy?: IndexingPolicy;
    partitionKey?: PartitionKeyDefinition;
    uniqueKeyPolicy?: UniqueKeyPolicy;
}

// @public
export class ContainerResponse extends ResourceResponse<ContainerDefinition & Resource> {
    constructor(resource: ContainerDefinition & Resource, headers: CosmosHeaders, statusCode: number, container: Container);
    readonly container: Container;
}

// @public
export class Containers {
    constructor(database: Database, clientContext: ClientContext);
    // Warning: (ae-forgotten-export) The symbol "ContainerRequest" needs to be exported by the entry point index.d.ts
    create(body: ContainerRequest, options?: RequestOptions): Promise<ContainerResponse>;
    createIfNotExists(body: ContainerRequest, options?: RequestOptions): Promise<ContainerResponse>;
    // (undocumented)
    readonly database: Database;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<ContainerDefinition & Resource>;
}

// @public
export class CosmosClient {
    constructor(connectionString: string);
    constructor(options: CosmosClientOptions);
    database(id: string): Database;
    readonly databases: Databases;
    getDatabaseAccount(options?: RequestOptions): Promise<ResourceResponse<DatabaseAccount>>;
    getReadEndpoint(): Promise<string>;
    getWriteEndpoint(): Promise<string>;
    offer(id: string): Offer;
    readonly offers: Offers;
}

// @public (undocumented)
export interface CosmosClientOptions {
    // Warning: (ae-forgotten-export) The symbol "Agent" needs to be exported by the entry point index.d.ts
    agent?: Agent;
    connectionPolicy?: ConnectionPolicy;
    consistencyLevel?: keyof typeof ConsistencyLevel;
    // Warning: (ae-forgotten-export) The symbol "CosmosHeaders" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    defaultHeaders?: CosmosHeaders_2;
    endpoint: string;
    key?: string;
    permissionFeed?: PermissionDefinition[];
    resourceTokens?: {
        [resourcePath: string]: string;
    };
    tokenProvider?: TokenProvider;
    userAgentSuffix?: string;
}

// @public (undocumented)
export interface CosmosHeaders {
    // (undocumented)
    [key: string]: any;
}

// @public
export class Database {
    constructor(client: CosmosClient, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly client: CosmosClient;
    container(id: string): Container;
    readonly containers: Containers;
    delete(options?: RequestOptions): Promise<DatabaseResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<DatabaseResponse>;
    readonly url: string;
    user(id: string): User;
    readonly users: Users;
}

// @public
export class DatabaseAccount {
    constructor(body: {
        [key: string]: any;
    }, headers: CosmosHeaders);
    // @deprecated
    readonly ConsistencyPolicy: ConsistencyLevel;
    readonly consistencyPolicy: ConsistencyLevel;
    // @deprecated
    readonly CurrentMediaStorageUsageInMB: number;
    readonly currentMediaStorageUsageInMB: number;
    // @deprecated
    readonly DatabasesLink: string;
    readonly databasesLink: string;
    // (undocumented)
    readonly enableMultipleWritableLocations: boolean;
    // @deprecated
    readonly MaxMediaStorageUsageInMB: number;
    readonly maxMediaStorageUsageInMB: number;
    // @deprecated
    readonly MediaLink: string;
    readonly mediaLink: string;
    readonly readableLocations: Location[];
    readonly writableLocations: Location[];
}

// @public (undocumented)
export interface DatabaseDefinition {
    id?: string;
}

// @public
export class DatabaseResponse extends ResourceResponse<DatabaseDefinition & Resource> {
    constructor(resource: DatabaseDefinition & Resource, headers: CosmosHeaders, statusCode: number, database: Database);
    readonly database: Database;
}

// @public
export class Databases {
    constructor(client: CosmosClient, clientContext: ClientContext);
    // (undocumented)
    readonly client: CosmosClient;
    // Warning: (ae-forgotten-export) The symbol "DatabaseRequest" needs to be exported by the entry point index.d.ts
    create(body: DatabaseRequest, options?: RequestOptions): Promise<DatabaseResponse>;
    createIfNotExists(body: DatabaseRequest, options?: RequestOptions): Promise<DatabaseResponse>;
    query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<DatabaseDefinition & Resource>;
}

// @public
export enum DataType {
    LineString = "LineString",
    MultiPolygon = "MultiPolygon",
    Number = "Number",
    Point = "Point",
    Polygon = "Polygon",
    String = "String"
}

// @public (undocumented)
export const DEFAULT_PARTITION_KEY_PATH: "/_partitionKey";

// @public (undocumented)
export interface ErrorResponse extends Error {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    activityId?: string;
    // Warning: (ae-forgotten-export) The symbol "ErrorBody" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    body?: ErrorBody;
    // (undocumented)
    code?: number;
    // (undocumented)
    headers?: CosmosHeaders;
    // (undocumented)
    retryAfterInMilliseconds?: number;
    // (undocumented)
    retryAfterInMs?: number;
    // (undocumented)
    substatus?: number;
}

// @public (undocumented)
export function extractPartitionKey(document: any, partitionKeyDefinition: PartitionKeyDefinition): PartitionKey[];

// Warning: (ae-forgotten-export) The symbol "SharedOptions" needs to be exported by the entry point index.d.ts
//
// @public
export interface FeedOptions extends SharedOptions {
    accessCondition?: {
        type: string;
        condition: string;
    };
    bufferItems?: boolean;
    // @deprecated
    continuation?: string;
    continuationToken?: string;
    continuationTokenLimitInKB?: number;
    enableScanInQuery?: boolean;
    forceQueryPlan?: boolean;
    maxDegreeOfParallelism?: number;
    maxItemCount?: number;
    populateQueryMetrics?: boolean;
    useIncrementalFeed?: boolean;
}

// @public (undocumented)
export class FeedResponse<TResource> {
    constructor(resources: TResource[], headers: CosmosHeaders, hasMoreResults: boolean);
    // (undocumented)
    readonly activityId: string;
    // (undocumented)
    readonly continuation: string;
    // (undocumented)
    readonly continuationToken: string;
    // (undocumented)
    readonly hasMoreResults: boolean;
    // (undocumented)
    readonly queryMetrics: string;
    // (undocumented)
    readonly requestCharge: number;
    // (undocumented)
    readonly resources: TResource[];
}

// @public (undocumented)
export interface Index {
    // (undocumented)
    dataType: keyof typeof DataType;
    // (undocumented)
    kind: keyof typeof IndexKind;
    // (undocumented)
    precision?: number;
}

// @public (undocumented)
export interface IndexedPath {
    // (undocumented)
    indexes?: Index[];
    // (undocumented)
    path: string;
}

// @public
export enum IndexingMode {
    consistent = "consistent",
    lazy = "lazy",
    none = "none"
}

// @public (undocumented)
export interface IndexingPolicy {
    // (undocumented)
    automatic?: boolean;
    excludedPaths?: IndexedPath[];
    includedPaths?: IndexedPath[];
    indexingMode?: keyof typeof IndexingMode;
}

// @public
export enum IndexKind {
    Range = "Range",
    Spatial = "Spatial"
}

// @public
export class Item {
    constructor(container: Container, id: string, partitionKey: PartitionKey, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete<T extends ItemDefinition = any>(options?: RequestOptions): Promise<ItemResponse<T>>;
    // (undocumented)
    readonly id: string;
    read<T extends ItemDefinition = any>(options?: RequestOptions): Promise<ItemResponse<T>>;
    replace(body: ItemDefinition, options?: RequestOptions): Promise<ItemResponse<ItemDefinition>>;
    replace<T extends ItemDefinition>(body: T, options?: RequestOptions): Promise<ItemResponse<T>>;
    readonly url: string;
}

// @public
export interface ItemDefinition {
    // (undocumented)
    [key: string]: any;
    id?: string;
    ttl?: number;
}

// @public (undocumented)
export class ItemResponse<T extends ItemDefinition> extends ResourceResponse<T & Resource> {
    constructor(resource: T & Resource, headers: CosmosHeaders, statusCode: number, subsstatusCode: number, item: Item);
    readonly item: Item;
}

// @public
export class Items {
    constructor(container: Container, clientContext: ClientContext);
    changeFeed(partitionKey: string | number | boolean, changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;
    changeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;
    changeFeed<T>(partitionKey: string | number | boolean, changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;
    changeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;
    // (undocumented)
    readonly container: Container;
    create<T extends ItemDefinition = any>(body: T, options?: RequestOptions): Promise<ItemResponse<T>>;
    query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<ItemDefinition>;
    readAll<T extends ItemDefinition>(options?: FeedOptions): QueryIterator<T>;
    // Warning: (ae-forgotten-export) The symbol "ChangeFeedOptions" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "ChangeFeedIterator" needs to be exported by the entry point index.d.ts
    //
    // @deprecated
    readChangeFeed(partitionKey: string | number | boolean, changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;
    // @deprecated
    readChangeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;
    // @deprecated
    readChangeFeed<T>(partitionKey: string | number | boolean, changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;
    // @deprecated
    readChangeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;
    upsert(body: any, options?: RequestOptions): Promise<ItemResponse<ItemDefinition>>;
    upsert<T extends ItemDefinition>(body: T, options?: RequestOptions): Promise<ItemResponse<T>>;
}

// @public
export interface Location {
    // (undocumented)
    databaseAccountEndpoint: string;
    // (undocumented)
    name: string;
    // (undocumented)
    unavailable?: boolean;
}

// @public
export type Next<T> = (context: RequestContext) => Promise<Response<T>>;

// @public
export class Offer {
    constructor(client: CosmosClient, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly client: CosmosClient;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<OfferResponse>;
    replace(body: OfferDefinition, options?: RequestOptions): Promise<OfferResponse>;
    readonly url: string;
}

// @public (undocumented)
export interface OfferDefinition {
    // (undocumented)
    content?: {
        offerThroughput: number;
        offerIsRUPerMinuteThroughputEnabled: boolean;
    };
    // (undocumented)
    id?: string;
    // (undocumented)
    offerResourceId?: string;
    // (undocumented)
    offerType?: string;
    // (undocumented)
    offerVersion?: string;
    // (undocumented)
    resource?: string;
}

// @public (undocumented)
export class OfferResponse extends ResourceResponse<OfferDefinition & Resource> {
    constructor(resource: OfferDefinition & Resource, headers: CosmosHeaders, statusCode: number, offer: Offer);
    readonly offer: Offer;
}

// @public
export class Offers {
    constructor(client: CosmosClient, clientContext: ClientContext);
    // (undocumented)
    readonly client: CosmosClient;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<OfferDefinition & Resource>;
}

// @public (undocumented)
export enum OperationType {
    // (undocumented)
    Create = "create",
    // (undocumented)
    Delete = "delete",
    // (undocumented)
    Execute = "execute",
    // (undocumented)
    Query = "query",
    // (undocumented)
    Read = "read",
    // (undocumented)
    Replace = "replace",
    // (undocumented)
    Upsert = "upsert"
}

// @public (undocumented)
export type PartitionKey = PartitionKeyDefinition | string | number | {};

// @public (undocumented)
export interface PartitionKeyDefinition {
    paths: string[];
    // (undocumented)
    systemKey?: boolean;
    version?: number;
}

// @public (undocumented)
export interface PartitionKeyRange {
    // (undocumented)
    id: string;
    // (undocumented)
    maxExclusive: string;
    // (undocumented)
    minInclusive: string;
    // (undocumented)
    parents: string[];
    // (undocumented)
    ridPrefix: number;
    // (undocumented)
    status: string;
    // (undocumented)
    throughputFraction: number;
}

// @public
export class Permission {
    constructor(user: User, id: string, clientContext: ClientContext);
    delete(options?: RequestOptions): Promise<PermissionResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<PermissionResponse>;
    replace(body: PermissionDefinition, options?: RequestOptions): Promise<PermissionResponse>;
    readonly url: string;
    // (undocumented)
    readonly user: User;
}

// @public (undocumented)
export interface PermissionDefinition {
    id: string;
    permissionMode: PermissionMode;
    resource: string;
    // (undocumented)
    resourcePartitionKey?: string | any[];
}

// @public
export enum PermissionMode {
    All = "all",
    None = "none",
    Read = "read"
}

// Warning: (ae-forgotten-export) The symbol "PermissionBody" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class PermissionResponse extends ResourceResponse<PermissionDefinition & PermissionBody & Resource> {
    constructor(resource: PermissionDefinition & PermissionBody & Resource, headers: CosmosHeaders, statusCode: number, permission: Permission);
    readonly permission: Permission;
}

// @public
export class Permissions {
    constructor(user: User, clientContext: ClientContext);
    create(body: PermissionDefinition, options?: RequestOptions): Promise<PermissionResponse>;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<PermissionDefinition & Resource>;
    upsert(body: PermissionDefinition, options?: RequestOptions): Promise<PermissionResponse>;
    // (undocumented)
    readonly user: User;
}

// @public
export type Plugin<T> = (context: RequestContext, next: Next<T>) => Promise<Response<T>>;

// @public
export interface PluginConfig {
    on: keyof typeof PluginOn;
    plugin: Plugin<any>;
}

// @public
export enum PluginOn {
    operation = "operation",
    request = "request"
}

// @public
export class QueryIterator<T> {
    // Warning: (ae-forgotten-export) The symbol "FetchFunctionCallback" needs to be exported by the entry point index.d.ts
    constructor(clientContext: ClientContext, query: SqlQuerySpec | string, options: FeedOptions, fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[], resourceLink?: string, resourceType?: ResourceType);
    fetchAll(): Promise<FeedResponse<T>>;
    fetchNext(): Promise<FeedResponse<T>>;
    getAsyncIterator(): AsyncIterable<FeedResponse<T>>;
    hasMoreResults(): boolean;
    reset(): void;
    }

// @public (undocumented)
export class QueryMetrics {
    constructor(retrievedDocumentCount: number, retrievedDocumentSize: number, outputDocumentCount: number, outputDocumentSize: number, indexHitDocumentCount: number, totalQueryExecutionTime: TimeSpan, queryPreparationTimes: QueryPreparationTimes, indexLookupTime: TimeSpan, documentLoadTime: TimeSpan, vmExecutionTime: TimeSpan, runtimeExecutionTimes: RuntimeExecutionTimes, documentWriteTime: TimeSpan, clientSideMetrics: ClientSideMetrics);
    add(queryMetricsArray: QueryMetrics[]): QueryMetrics;
    // (undocumented)
    readonly clientSideMetrics: ClientSideMetrics;
    static createFromArray(queryMetricsArray: QueryMetrics[]): QueryMetrics;
    static createFromDelimitedString(delimitedString: string, clientSideMetrics?: ClientSideMetrics): QueryMetrics;
    // (undocumented)
    readonly documentLoadTime: TimeSpan;
    // (undocumented)
    readonly documentWriteTime: TimeSpan;
    // (undocumented)
    readonly indexHitDocumentCount: number;
    readonly indexHitRatio: number;
    // (undocumented)
    readonly indexLookupTime: TimeSpan;
    // (undocumented)
    readonly outputDocumentCount: number;
    // (undocumented)
    readonly outputDocumentSize: number;
    // (undocumented)
    readonly queryPreparationTimes: QueryPreparationTimes;
    // (undocumented)
    readonly retrievedDocumentCount: number;
    // (undocumented)
    readonly retrievedDocumentSize: number;
    // (undocumented)
    readonly runtimeExecutionTimes: RuntimeExecutionTimes;
    toDelimitedString(): string;
    // (undocumented)
    readonly totalQueryExecutionTime: TimeSpan;
    // (undocumented)
    readonly vmExecutionTime: TimeSpan;
    // (undocumented)
    static readonly zero: QueryMetrics;
}

// @public (undocumented)
export const QueryMetricsConstants: {
    RetrievedDocumentCount: string;
    RetrievedDocumentSize: string;
    OutputDocumentCount: string;
    OutputDocumentSize: string;
    IndexHitRatio: string;
    IndexHitDocumentCount: string;
    TotalQueryExecutionTimeInMs: string;
    QueryCompileTimeInMs: string;
    LogicalPlanBuildTimeInMs: string;
    PhysicalPlanBuildTimeInMs: string;
    QueryOptimizationTimeInMs: string;
    IndexLookupTimeInMs: string;
    DocumentLoadTimeInMs: string;
    VMExecutionTimeInMs: string;
    DocumentWriteTimeInMs: string;
    QueryEngineTimes: string;
    SystemFunctionExecuteTimeInMs: string;
    UserDefinedFunctionExecutionTimeInMs: string;
    RetrievedDocumentCountText: string;
    RetrievedDocumentSizeText: string;
    OutputDocumentCountText: string;
    OutputDocumentSizeText: string;
    IndexUtilizationText: string;
    TotalQueryExecutionTimeText: string;
    QueryPreparationTimesText: string;
    QueryCompileTimeText: string;
    LogicalPlanBuildTimeText: string;
    PhysicalPlanBuildTimeText: string;
    QueryOptimizationTimeText: string;
    QueryEngineTimesText: string;
    IndexLookupTimeText: string;
    DocumentLoadTimeText: string;
    WriteOutputTimeText: string;
    RuntimeExecutionTimesText: string;
    TotalExecutionTimeText: string;
    SystemFunctionExecuteTimeText: string;
    UserDefinedFunctionExecutionTimeText: string;
    ClientSideQueryMetricsText: string;
    RetriesText: string;
    RequestChargeText: string;
    FetchExecutionRangesText: string;
    SchedulingMetricsText: string;
};

// @public (undocumented)
export class QueryPreparationTimes {
    constructor(queryCompilationTime: TimeSpan, logicalPlanBuildTime: TimeSpan, physicalPlanBuildTime: TimeSpan, queryOptimizationTime: TimeSpan);
    add(...queryPreparationTimesArray: QueryPreparationTimes[]): QueryPreparationTimes;
    static createFromArray(queryPreparationTimesArray: QueryPreparationTimes[]): QueryPreparationTimes;
    static createFromDelimitedString(delimitedString: string): QueryPreparationTimes;
    // (undocumented)
    readonly logicalPlanBuildTime: TimeSpan;
    // (undocumented)
    readonly physicalPlanBuildTime: TimeSpan;
    // (undocumented)
    readonly queryCompilationTime: TimeSpan;
    // (undocumented)
    readonly queryOptimizationTime: TimeSpan;
    toDelimitedString(): string;
    // (undocumented)
    static readonly zero: QueryPreparationTimes;
}

// @public (undocumented)
export interface RequestContext {
    // (undocumented)
    body?: any;
    // (undocumented)
    client?: ClientContext;
    // (undocumented)
    connectionPolicy: ConnectionPolicy;
    // (undocumented)
    endpoint?: string;
    // Warning: (ae-forgotten-export) The symbol "GlobalEndpointManager" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    globalEndpointManager: GlobalEndpointManager;
    // (undocumented)
    headers?: CosmosHeaders_2;
    // Warning: (ae-forgotten-export) The symbol "HTTPMethod" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    method: HTTPMethod;
    // (undocumented)
    operationType?: OperationType;
    // (undocumented)
    options: FeedOptions | RequestOptions;
    // (undocumented)
    partitionKey?: PartitionKey;
    // (undocumented)
    partitionKeyRangeId?: string;
    // (undocumented)
    path?: string;
    // (undocumented)
    plugins: PluginConfig[];
    // (undocumented)
    requestAgent: Agent;
    // (undocumented)
    resourceId?: string;
    // (undocumented)
    resourceType?: ResourceType;
    // (undocumented)
    retryCount?: number;
}

// @public (undocumented)
export interface RequestInfo {
    // (undocumented)
    headers: CosmosHeaders;
    // (undocumented)
    path: string;
    // (undocumented)
    resourceId: string;
    // (undocumented)
    resourceType: ResourceType;
    // (undocumented)
    verb: HTTPMethod;
}

// @public
export interface RequestOptions extends SharedOptions {
    accessCondition?: {
        type: string;
        condition: string;
    };
    consistencyLevel?: string;
    disableAutomaticIdGeneration?: boolean;
    disableRUPerMinuteUsage?: boolean;
    enableScriptLogging?: boolean;
    indexingDirective?: string;
    offerThroughput?: number;
    offerType?: string;
    populateQuotaInfo?: boolean;
    postTriggerInclude?: string | string[];
    preTriggerInclude?: string | string[];
    resourceTokenExpirySeconds?: number;
    urlConnection?: string;
}

// @public (undocumented)
export interface Resource {
    _etag: string;
    id: string;
    _rid: string;
    _self: string;
    _ts: number;
}

// @public (undocumented)
export class ResourceResponse<TResource> {
    constructor(resource: TResource, headers: CosmosHeaders_2, statusCode: StatusCode, substatus?: SubStatusCode);
    // (undocumented)
    readonly activityId: string;
    // (undocumented)
    readonly etag: string;
    // (undocumented)
    readonly headers: CosmosHeaders_2;
    // (undocumented)
    readonly requestCharge: number;
    // (undocumented)
    readonly resource: TResource;
    // Warning: (ae-forgotten-export) The symbol "StatusCode" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly statusCode: StatusCode;
    // Warning: (ae-forgotten-export) The symbol "SubStatusCode" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly substatus?: SubStatusCode;
}

// @public (undocumented)
export interface Response<T> {
    // (undocumented)
    code?: number;
    // (undocumented)
    headers: CosmosHeaders;
    // (undocumented)
    result?: T;
    // (undocumented)
    substatus?: number;
}

// @public
export interface RetryOptions {
    fixedRetryIntervalInMilliseconds: number;
    maxRetryAttemptCount: number;
    maxWaitTimeInSeconds: number;
}

// @public (undocumented)
export class RuntimeExecutionTimes {
    constructor(queryEngineExecutionTime: TimeSpan, systemFunctionExecutionTime: TimeSpan, userDefinedFunctionExecutionTime: TimeSpan);
    add(...runtimeExecutionTimesArray: RuntimeExecutionTimes[]): RuntimeExecutionTimes;
    static createFromArray(runtimeExecutionTimesArray: RuntimeExecutionTimes[]): RuntimeExecutionTimes;
    static createFromDelimitedString(delimitedString: string): RuntimeExecutionTimes;
    // (undocumented)
    readonly queryEngineExecutionTime: TimeSpan;
    // (undocumented)
    readonly systemFunctionExecutionTime: TimeSpan;
    toDelimitedString(): string;
    // (undocumented)
    readonly userDefinedFunctionExecutionTime: TimeSpan;
    // (undocumented)
    static readonly zero: RuntimeExecutionTimes;
}

// @public
export function setAuthorizationTokenHeaderUsingMasterKey(verb: HTTPMethod, resourceId: string, resourceType: ResourceType, headers: CosmosHeaders, masterKey: string): Promise<void>;

// @public
export interface SqlParameter {
    name: string;
    // Warning: (ae-forgotten-export) The symbol "JSONValue" needs to be exported by the entry point index.d.ts
    value: JSONValue;
}

// @public
export interface SqlQuerySpec {
    parameters?: SqlParameter[];
    query: string;
}

// @public (undocumented)
export const StatusCodes: {
    Ok: 200;
    Created: 201;
    Accepted: 202;
    NoContent: 204;
    NotModified: 304;
    BadRequest: 400;
    Unauthorized: 401;
    Forbidden: 403;
    NotFound: 404;
    MethodNotAllowed: 405;
    RequestTimeout: 408;
    Conflict: 409;
    Gone: 410;
    PreconditionFailed: 412;
    RequestEntityTooLarge: 413;
    TooManyRequests: 429;
    RetryWith: 449;
    InternalServerError: 500;
    ServiceUnavailable: 503;
    OperationPaused: 1200;
    OperationCancelled: 1201;
};

// @public
export class StoredProcedure {
    constructor(container: Container, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete(options?: RequestOptions): Promise<StoredProcedureResponse>;
    execute<T = any>(partitionKey: any, params?: any[], options?: RequestOptions): Promise<ResourceResponse<T>>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<StoredProcedureResponse>;
    replace(body: StoredProcedureDefinition, options?: RequestOptions): Promise<StoredProcedureResponse>;
    readonly url: string;
}

// @public (undocumented)
export interface StoredProcedureDefinition {
    body?: string | ((...inputs: any[]) => void);
    id?: string;
}

// @public (undocumented)
export class StoredProcedureResponse extends ResourceResponse<StoredProcedureDefinition & Resource> {
    constructor(resource: StoredProcedureDefinition & Resource, headers: CosmosHeaders, statusCode: number, storedProcedure: StoredProcedure);
    readonly sproc: StoredProcedure;
    readonly storedProcedure: StoredProcedure;
}

// @public
export class StoredProcedures {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    create(body: StoredProcedureDefinition, options?: RequestOptions): Promise<StoredProcedureResponse>;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<StoredProcedureDefinition & Resource>;
}

// @public
export class TimeSpan {
    constructor(days: number, hours: number, minutes: number, seconds: number, milliseconds: number);
    add(ts: TimeSpan): TimeSpan;
    // (undocumented)
    static additionDoesOverflow(a: number, b: number): boolean;
    // (undocumented)
    static compare(t1: TimeSpan, t2: TimeSpan): 0 | 1 | -1;
    compareTo(value: TimeSpan): 0 | 1 | -1;
    // (undocumented)
    days(): number;
    duration(): TimeSpan;
    equals(value: TimeSpan): boolean;
    // (undocumented)
    static fromDays(value: number): TimeSpan;
    // (undocumented)
    static fromHours(value: number): TimeSpan;
    // (undocumented)
    static fromMilliseconds(value: number): TimeSpan;
    // (undocumented)
    static fromMinutes(value: number): TimeSpan;
    // (undocumented)
    static fromSeconds(value: number): TimeSpan;
    // (undocumented)
    static fromTicks(value: number): TimeSpan;
    // (undocumented)
    hours(): number;
    // (undocumented)
    static interval(value: number, scale: number): TimeSpan;
    // (undocumented)
    static isTimeSpan(timespan: TimeSpan): number;
    // (undocumented)
    static readonly maxValue: TimeSpan;
    // (undocumented)
    milliseconds(): number;
    // (undocumented)
    static readonly minValue: TimeSpan;
    negate(): TimeSpan;
    // (undocumented)
    seconds(): number;
    subtract(ts: TimeSpan): TimeSpan;
    // (undocumented)
    static subtractionDoesUnderflow(a: number, b: number): boolean;
    // (undocumented)
    ticks(): number;
    // (undocumented)
    protected _ticks: number;
    // (undocumented)
    totalDays(): number;
    // (undocumented)
    totalHours(): number;
    // (undocumented)
    totalMilliseconds(): number;
    // (undocumented)
    totalMinutes(): number;
    // (undocumented)
    totalSeconds(): number;
    // (undocumented)
    static readonly zero: TimeSpan;
}

// @public (undocumented)
export type TokenProvider = (requestInfo: RequestInfo) => Promise<string>;

// @public
export class Trigger {
    constructor(container: Container, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete(options?: RequestOptions): Promise<TriggerResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<TriggerResponse>;
    replace(body: TriggerDefinition, options?: RequestOptions): Promise<TriggerResponse>;
    readonly url: string;
}

// @public (undocumented)
export interface TriggerDefinition {
    body: (() => void) | string;
    id?: string;
    triggerOperation: TriggerOperation;
    triggerType: TriggerType;
}

// @public
export enum TriggerOperation {
    All = "all",
    Create = "create",
    Delete = "delete",
    Replace = "replace",
    Update = "update"
}

// @public (undocumented)
export class TriggerResponse extends ResourceResponse<TriggerDefinition & Resource> {
    constructor(resource: TriggerDefinition & Resource, headers: CosmosHeaders, statusCode: number, trigger: Trigger);
    readonly trigger: Trigger;
}

// @public
export class Triggers {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    create(body: TriggerDefinition, options?: RequestOptions): Promise<TriggerResponse>;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<TriggerDefinition & Resource>;
}

// @public
export enum TriggerType {
    Post = "post",
    Pre = "pre"
}

// @public
export interface UniqueKey {
    // (undocumented)
    paths: string[];
}

// @public
export interface UniqueKeyPolicy {
    // (undocumented)
    uniqueKeys: UniqueKey[];
}

// @public
export class User {
    constructor(database: Database, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly database: Database;
    delete(options?: RequestOptions): Promise<UserResponse>;
    // (undocumented)
    readonly id: string;
    permission(id: string): Permission;
    readonly permissions: Permissions;
    read(options?: RequestOptions): Promise<UserResponse>;
    replace(body: UserDefinition, options?: RequestOptions): Promise<UserResponse>;
    readonly url: string;
}

// @public
export class UserDefinedFunction {
    constructor(container: Container, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete(options?: RequestOptions): Promise<UserDefinedFunctionResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<UserDefinedFunctionResponse>;
    replace(body: UserDefinedFunctionDefinition, options?: RequestOptions): Promise<UserDefinedFunctionResponse>;
    readonly url: string;
}

// @public (undocumented)
export interface UserDefinedFunctionDefinition {
    body?: string | (() => void);
    id?: string;
}

// @public (undocumented)
export class UserDefinedFunctionResponse extends ResourceResponse<UserDefinedFunctionDefinition & Resource> {
    constructor(resource: UserDefinedFunctionDefinition & Resource, headers: CosmosHeaders, statusCode: number, udf: UserDefinedFunction);
    readonly udf: UserDefinedFunction;
    readonly userDefinedFunction: UserDefinedFunction;
}

// @public
export class UserDefinedFunctions {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    create(body: UserDefinedFunctionDefinition, options?: RequestOptions): Promise<UserDefinedFunctionResponse>;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<UserDefinedFunctionDefinition & Resource>;
}

// @public
export enum UserDefinedFunctionType {
    Javascript = "Javascript"
}

// @public (undocumented)
export interface UserDefinition {
    id?: string;
}

// @public (undocumented)
export class UserResponse extends ResourceResponse<UserDefinition & Resource> {
    constructor(resource: UserDefinition & Resource, headers: CosmosHeaders, statusCode: number, user: User);
    readonly user: User;
}

// @public
export class Users {
    constructor(database: Database, clientContext: ClientContext);
    create(body: UserDefinition, options?: RequestOptions): Promise<UserResponse>;
    // (undocumented)
    readonly database: Database;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<UserDefinition & Resource>;
    upsert(body: UserDefinition, options?: RequestOptions): Promise<UserResponse>;
}


// (No @packageDocumentation comment for this package)

```
