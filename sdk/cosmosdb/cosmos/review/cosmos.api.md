## API Report File for "@azure/cosmos"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference lib="dom" />
/// <reference lib="esnext.asynciterable" />

import { AbortError } from '@azure/abort-controller';
import { AbortSignal as AbortSignal_2 } from 'node-abort-controller';
import { Pipeline } from '@azure/core-rest-pipeline';
import { RestError } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

export { AbortError }

// @public (undocumented)
export interface Agent {
    // (undocumented)
    destroy(): void;
    // (undocumented)
    maxFreeSockets: number;
    // (undocumented)
    maxSockets: number;
    // (undocumented)
    requests: any;
    // (undocumented)
    sockets: any;
}

// @public (undocumented)
export type AggregateType = "Average" | "Count" | "Max" | "Min" | "Sum";

// @public (undocumented)
export const BulkOperationType: {
    readonly Create: "Create";
    readonly Upsert: "Upsert";
    readonly Read: "Read";
    readonly Delete: "Delete";
    readonly Replace: "Replace";
    readonly Patch: "Patch";
};

// @public
export interface BulkOptions {
    // (undocumented)
    continueOnError?: boolean;
}

// @public (undocumented)
export type BulkPatchOperation = OperationBase & {
    operationType: typeof BulkOperationType.Patch;
    id: string;
};

// @public
export class ChangeFeedIterator<T> {
    fetchNext(): Promise<ChangeFeedResponse<Array<T & Resource>>>;
    getAsyncIterator(): AsyncIterable<ChangeFeedResponse<Array<T & Resource>>>;
    get hasMoreResults(): boolean;
}

// @public
export interface ChangeFeedOptions {
    continuation?: string;
    maxItemCount?: number;
    sessionToken?: string;
    startFromBeginning?: boolean;
    startTime?: Date;
}

// @public
export class ChangeFeedResponse<T> {
    get activityId(): string;
    get continuation(): string;
    readonly count: number;
    get etag(): string;
    headers: CosmosHeaders;
    get requestCharge(): number;
    readonly result: T;
    get sessionToken(): string;
    readonly statusCode: number;
}

// @public (undocumented)
export class ClientContext {
    constructor(cosmosClientOptions: CosmosClientOptions, globalEndpointManager: GlobalEndpointManager);
    // (undocumented)
    batch<T>({ body, path, partitionKey, resourceId, options, diagnosticContext, }: {
        body: T;
        path: string;
        partitionKey: string;
        resourceId: string;
        options?: RequestOptions;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<any>>;
    // (undocumented)
    bulk<T>({ body, path, partitionKeyRangeId, resourceId, bulkOptions, options, diagnosticContext, }: {
        body: T;
        path: string;
        partitionKeyRangeId: string;
        resourceId: string;
        bulkOptions?: BulkOptions;
        options?: RequestOptions;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<any>>;
    // (undocumented)
    clearSessionToken(path: string): void;
    // (undocumented)
    create<T, U = T>({ body, path, resourceType, resourceId, options, partitionKey, diagnosticContext, }: {
        body: T;
        path: string;
        resourceType: ResourceType;
        resourceId: string;
        options?: RequestOptions;
        partitionKey?: PartitionKey;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<T & U & Resource>>;
    // (undocumented)
    delete<T>({ path, resourceType, resourceId, options, partitionKey, method, diagnosticContext, }: {
        path: string;
        resourceType: ResourceType;
        resourceId: string;
        options?: RequestOptions;
        partitionKey?: PartitionKey;
        method?: HTTPMethod;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<T & Resource>>;
    // (undocumented)
    execute<T>({ sprocLink, params, options, partitionKey, diagnosticContext, }: {
        sprocLink: string;
        params?: any[];
        options?: RequestOptions;
        partitionKey?: PartitionKey;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<T>>;
    getDatabaseAccount(options?: RequestOptions, diagnosticContext?: CosmosDiagnosticContext): Promise<Response_2<DatabaseAccount>>;
    // (undocumented)
    getQueryPlan(path: string, resourceType: ResourceType, resourceId: string, query: SqlQuerySpec | string, options?: FeedOptions, diagnosticContext?: CosmosDiagnosticContext): Promise<Response_2<PartitionedQueryExecutionInfo>>;
    // (undocumented)
    getReadEndpoint(): Promise<string>;
    // (undocumented)
    getReadEndpoints(): Promise<readonly string[]>;
    // (undocumented)
    getWriteEndpoint(): Promise<string>;
    // (undocumented)
    getWriteEndpoints(): Promise<readonly string[]>;
    // (undocumented)
    partitionKeyDefinitionCache: {
        [containerUrl: string]: any;
    };
    // (undocumented)
    patch<T>({ body, path, resourceType, resourceId, options, partitionKey, diagnosticContext, }: {
        body: any;
        path: string;
        resourceType: ResourceType;
        resourceId: string;
        options?: RequestOptions;
        partitionKey?: PartitionKey;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<T & Resource>>;
    // (undocumented)
    queryFeed<T>({ path, resourceType, resourceId, resultFn, query, options, partitionKeyRangeId, partitionKey, diagnosticContext, }: {
        path: string;
        resourceType: ResourceType;
        resourceId: string;
        resultFn: (result: {
            [key: string]: any;
        }) => any[];
        query: SqlQuerySpec | string;
        options: FeedOptions;
        partitionKeyRangeId?: string;
        partitionKey?: PartitionKey;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<T & Resource>>;
    // (undocumented)
    queryPartitionKeyRanges(collectionLink: string, query?: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<PartitionKeyRange>;
    // (undocumented)
    read<T>({ path, resourceType, resourceId, options, partitionKey, diagnosticContext, }: {
        path: string;
        resourceType: ResourceType;
        resourceId: string;
        options?: RequestOptions;
        partitionKey?: PartitionKey;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<T & Resource>>;
    // (undocumented)
    replace<T>({ body, path, resourceType, resourceId, options, partitionKey, diagnosticContext, }: {
        body: any;
        path: string;
        resourceType: ResourceType;
        resourceId: string;
        options?: RequestOptions;
        partitionKey?: PartitionKey;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<T & Resource>>;
    // (undocumented)
    upsert<T, U = T>({ body, path, resourceType, resourceId, options, partitionKey, diagnosticContext, }: {
        body: T;
        path: string;
        resourceType: ResourceType;
        resourceId: string;
        options?: RequestOptions;
        partitionKey?: PartitionKey;
        diagnosticContext?: CosmosDiagnosticContext;
    }): Promise<Response_2<T & U & Resource>>;
}

// @public (undocumented)
export class ClientSideMetrics {
    constructor(requestCharge: number);
    add(...clientSideMetricsArray: ClientSideMetrics[]): ClientSideMetrics;
    // (undocumented)
    static createFromArray(...clientSideMetricsArray: ClientSideMetrics[]): ClientSideMetrics;
    // (undocumented)
    readonly requestCharge: number;
    // (undocumented)
    static readonly zero: ClientSideMetrics;
}

// @public
export type ClientSideRequestStatistics = {
    requestStartTimeUTCInMs: number;
    requestEndTimeUTCInMs: number;
    activityId: string;
    locationEndpointsContacted: Location_2[];
    retryDiagnostics: RetryDiagnostics;
    metadataDiagnostics: MetadataLookUpDiagnostics;
    requestPayloadLengthInBytes: number;
    responsePayloadLengthInBytes: number;
};

// @public
export class Conflict {
    constructor(container: Container, id: string, clientContext: ClientContext, partitionKey?: PartitionKey);
    // (undocumented)
    readonly container: Container;
    delete(options?: RequestOptions): Promise<ConflictResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<ConflictResponse>;
    get url(): string;
}

// @public (undocumented)
export interface ConflictDefinition {
    // (undocumented)
    content?: string;
    id?: string;
    // (undocumented)
    operationType?: OperationType;
    resourceId?: string;
    // (undocumented)
    resourceType?: ResourceType;
}

// @public (undocumented)
export enum ConflictResolutionMode {
    // (undocumented)
    Custom = "Custom",
    // (undocumented)
    LastWriterWins = "LastWriterWins"
}

// @public
export interface ConflictResolutionPolicy {
    conflictResolutionPath?: string;
    conflictResolutionProcedure?: string;
    mode?: keyof typeof ConflictResolutionMode;
}

// @public (undocumented)
export class ConflictResponse extends ResourceResponse<ConflictDefinition & Resource> {
    constructor(resource: ConflictDefinition & Resource, headers: CosmosHeaders, statusCode: number, conflict: Conflict, diagnostics: CosmosDiagnostics);
    readonly conflict: Conflict;
}

// @public
export class Conflicts {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<ConflictDefinition & Resource>;
}

// @public
export enum ConnectionMode {
    Gateway = 0
}

// @public
export interface ConnectionPolicy {
    connectionMode?: ConnectionMode;
    enableBackgroundEndpointRefreshing?: boolean;
    enableEndpointDiscovery?: boolean;
    endpointRefreshRateInMs?: number;
    preferredLocations?: string[];
    requestTimeout?: number;
    retryOptions?: RetryOptions;
    useMultipleWriteLocations?: boolean;
}

// @public
export enum ConsistencyLevel {
    BoundedStaleness = "BoundedStaleness",
    ConsistentPrefix = "ConsistentPrefix",
    Eventual = "Eventual",
    Session = "Session",
    Strong = "Strong"
}

// @public (undocumented)
export const Constants: {
    HttpHeaders: {
        Authorization: string;
        ETag: string;
        MethodOverride: string;
        Slug: string;
        ContentType: string;
        LastModified: string;
        ContentEncoding: string;
        CharacterSet: string;
        UserAgent: string;
        IfModifiedSince: string;
        IfMatch: string;
        IfNoneMatch: string;
        ContentLength: string;
        AcceptEncoding: string;
        KeepAlive: string;
        CacheControl: string;
        TransferEncoding: string;
        ContentLanguage: string;
        ContentLocation: string;
        ContentMd5: string;
        ContentRange: string;
        Accept: string;
        AcceptCharset: string;
        AcceptLanguage: string;
        IfRange: string;
        IfUnmodifiedSince: string;
        MaxForwards: string;
        ProxyAuthorization: string;
        AcceptRanges: string;
        ProxyAuthenticate: string;
        RetryAfter: string;
        SetCookie: string;
        WwwAuthenticate: string;
        Origin: string;
        Host: string;
        AccessControlAllowOrigin: string;
        AccessControlAllowHeaders: string;
        KeyValueEncodingFormat: string;
        WrapAssertionFormat: string;
        WrapAssertion: string;
        WrapScope: string;
        SimpleToken: string;
        HttpDate: string;
        Prefer: string;
        Location: string;
        Referer: string;
        A_IM: string;
        Query: string;
        IsQuery: string;
        IsQueryPlan: string;
        SupportedQueryFeatures: string;
        QueryVersion: string;
        Continuation: string;
        PageSize: string;
        ItemCount: string;
        ActivityId: string;
        PreTriggerInclude: string;
        PreTriggerExclude: string;
        PostTriggerInclude: string;
        PostTriggerExclude: string;
        IndexingDirective: string;
        SessionToken: string;
        ConsistencyLevel: string;
        XDate: string;
        CollectionPartitionInfo: string;
        CollectionServiceInfo: string;
        RetryAfterInMilliseconds: string;
        RetryAfterInMs: string;
        IsFeedUnfiltered: string;
        ResourceTokenExpiry: string;
        EnableScanInQuery: string;
        EmitVerboseTracesInQuery: string;
        EnableCrossPartitionQuery: string;
        ParallelizeCrossPartitionQuery: string;
        ResponseContinuationTokenLimitInKB: string;
        PopulateQueryMetrics: string;
        QueryMetrics: string;
        PopulateIndexMetrics: string;
        IndexUtilization: string;
        Version: string;
        OwnerFullName: string;
        OwnerId: string;
        PartitionKey: string;
        PartitionKeyRangeID: string;
        MaxEntityCount: string;
        CurrentEntityCount: string;
        CollectionQuotaInMb: string;
        CollectionCurrentUsageInMb: string;
        MaxMediaStorageUsageInMB: string;
        CurrentMediaStorageUsageInMB: string;
        RequestCharge: string;
        PopulateQuotaInfo: string;
        MaxResourceQuota: string;
        OfferType: string;
        OfferThroughput: string;
        AutoscaleSettings: string;
        DisableRUPerMinuteUsage: string;
        IsRUPerMinuteUsed: string;
        OfferIsRUPerMinuteThroughputEnabled: string;
        IndexTransformationProgress: string;
        LazyIndexingProgress: string;
        IsUpsert: string;
        SubStatus: string;
        EnableScriptLogging: string;
        ScriptLogResults: string;
        ALLOW_MULTIPLE_WRITES: string;
        IsBatchRequest: string;
        IsBatchAtomic: string;
        BatchContinueOnError: string;
        DedicatedGatewayPerRequestCacheStaleness: string;
        ForceRefresh: string;
    };
    WritableLocations: string;
    ReadableLocations: string;
    LocationUnavailableExpirationTimeInMs: number;
    ENABLE_MULTIPLE_WRITABLE_LOCATIONS: string;
    DefaultUnavailableLocationExpirationTimeMS: number;
    ThrottleRetryCount: string;
    ThrottleRetryWaitTimeInMs: string;
    CurrentVersion: string;
    AzureNamespace: string;
    AzurePackageName: string;
    SDKName: string;
    SDKVersion: string;
    DefaultMaxBulkRequestBodySizeInBytes: number;
    Quota: {
        CollectionSize: string;
    };
    Path: {
        Root: string;
        DatabasesPathSegment: string;
        CollectionsPathSegment: string;
        UsersPathSegment: string;
        DocumentsPathSegment: string;
        PermissionsPathSegment: string;
        StoredProceduresPathSegment: string;
        TriggersPathSegment: string;
        UserDefinedFunctionsPathSegment: string;
        ConflictsPathSegment: string;
        AttachmentsPathSegment: string;
        PartitionKeyRangesPathSegment: string;
        SchemasPathSegment: string;
        OffersPathSegment: string;
        TopologyPathSegment: string;
        DatabaseAccountPathSegment: string;
    };
    PartitionKeyRange: PartitionKeyRangePropertiesNames;
    QueryRangeConstants: {
        MinInclusive: string;
        MaxExclusive: string;
        min: string;
    };
    EffectiveParitionKeyConstants: {
        MinimumInclusiveEffectivePartitionKey: string;
        MaximumExclusiveEffectivePartitionKey: string;
    };
    EffectivePartitionKeyConstants: {
        MinimumInclusiveEffectivePartitionKey: string;
        MaximumExclusiveEffectivePartitionKey: string;
    };
};

// @public
export class Container {
    constructor(database: Database, id: string, clientContext: ClientContext);
    conflict(id: string, partitionKey?: PartitionKey): Conflict;
    get conflicts(): Conflicts;
    // (undocumented)
    readonly database: Database;
    delete(options?: RequestOptions): Promise<ContainerResponse>;
    deleteAllItemsForPartitionKey(partitionKey: PartitionKey, options?: RequestOptions): Promise<ContainerResponse>;
    // @deprecated
    getPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>>;
    // (undocumented)
    getQueryPlan(query: string | SqlQuerySpec): Promise<Response_2<PartitionedQueryExecutionInfo>>;
    // (undocumented)
    readonly id: string;
    item(id: string, partitionKeyValue?: PartitionKey): Item;
    get items(): Items;
    read(options?: RequestOptions): Promise<ContainerResponse>;
    readOffer(options?: RequestOptions): Promise<OfferResponse>;
    readPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>>;
    // (undocumented)
    readPartitionKeyRanges(feedOptions?: FeedOptions): QueryIterator<PartitionKeyRange>;
    replace(body: ContainerDefinition, options?: RequestOptions): Promise<ContainerResponse>;
    get scripts(): Scripts;
    get url(): string;
}

// @public (undocumented)
export interface ContainerDefinition {
    conflictResolutionPolicy?: ConflictResolutionPolicy;
    defaultTtl?: number;
    geospatialConfig?: {
        type: GeospatialType;
    };
    id?: string;
    indexingPolicy?: IndexingPolicy;
    partitionKey?: PartitionKeyDefinition;
    uniqueKeyPolicy?: UniqueKeyPolicy;
}

// Warning: (ae-forgotten-export) The symbol "VerboseOmit" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface ContainerRequest extends VerboseOmit<ContainerDefinition, "partitionKey"> {
    // (undocumented)
    autoUpgradePolicy?: {
        throughputPolicy: {
            incrementPercent: number;
        };
    };
    // (undocumented)
    maxThroughput?: number;
    // (undocumented)
    partitionKey?: string | PartitionKeyDefinition;
    // (undocumented)
    throughput?: number;
}

// @public
export class ContainerResponse extends ResourceResponse<ContainerDefinition & Resource> {
    constructor(resource: ContainerDefinition & Resource, headers: CosmosHeaders, statusCode: number, container: Container, diagnostics: CosmosDiagnostics);
    readonly container: Container;
}

// @public
export class Containers {
    constructor(database: Database, clientContext: ClientContext);
    create(body: ContainerRequest, options?: RequestOptions): Promise<ContainerResponse>;
    createIfNotExists(body: ContainerRequest, options?: RequestOptions): Promise<ContainerResponse>;
    // (undocumented)
    readonly database: Database;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<ContainerDefinition & Resource>;
}

// @public
export class CosmosClient {
    constructor(connectionString: string);
    constructor(options: CosmosClientOptions);
    database(id: string): Database;
    readonly databases: Databases;
    dispose(): void;
    getDatabaseAccount(options?: RequestOptions): Promise<ResourceResponse<DatabaseAccount>>;
    getReadEndpoint(): Promise<string>;
    getReadEndpoints(): Promise<readonly string[]>;
    getWriteEndpoint(): Promise<string>;
    getWriteEndpoints(): Promise<readonly string[]>;
    offer(id: string): Offer;
    readonly offers: Offers;
}

// @public (undocumented)
export interface CosmosClientOptions {
    aadCredentials?: TokenCredential;
    agent?: Agent;
    connectionPolicy?: ConnectionPolicy;
    consistencyLevel?: keyof typeof ConsistencyLevel;
    // Warning: (ae-forgotten-export) The symbol "CosmosHeaders_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    defaultHeaders?: CosmosHeaders_2;
    endpoint: string;
    key?: string;
    permissionFeed?: PermissionDefinition[];
    resourceTokens?: {
        [resourcePath: string]: string;
    };
    tokenProvider?: TokenProvider;
    userAgentSuffix?: string;
}

// @public
export class CosmosDiagnostics {
    // (undocumented)
    readonly clientSideRequestStatistics: ClientSideRequestStatistics;
    // (undocumented)
    get getContactedRegionNames(): Set<string>;
    // (undocumented)
    readonly id: string;
}

// @public (undocumented)
export interface CosmosHeaders {
    // (undocumented)
    [key: string]: any;
}

// @public
export function createAuthorizationSasToken(masterKey: string, sasTokenProperties: SasTokenProperties): Promise<string>;

// @public (undocumented)
export type CreateOperation = OperationWithItem & {
    operationType: typeof BulkOperationType.Create;
};

// @public (undocumented)
export interface CreateOperationInput {
    // (undocumented)
    ifMatch?: string;
    // (undocumented)
    ifNoneMatch?: string;
    // (undocumented)
    operationType: typeof BulkOperationType.Create;
    // (undocumented)
    partitionKey?: string | number | null | Record<string, unknown> | undefined;
    // (undocumented)
    resourceBody: JSONObject;
}

// @public
export class Database {
    constructor(client: CosmosClient, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly client: CosmosClient;
    container(id: string): Container;
    readonly containers: Containers;
    delete(options?: RequestOptions): Promise<DatabaseResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<DatabaseResponse>;
    readOffer(options?: RequestOptions): Promise<OfferResponse>;
    get url(): string;
    user(id: string): User;
    readonly users: Users;
}

// @public
export class DatabaseAccount {
    constructor(body: {
        [key: string]: any;
    }, headers: CosmosHeaders);
    // @deprecated
    get ConsistencyPolicy(): ConsistencyLevel;
    readonly consistencyPolicy: ConsistencyLevel;
    // @deprecated
    get CurrentMediaStorageUsageInMB(): number;
    readonly currentMediaStorageUsageInMB: number;
    // @deprecated
    get DatabasesLink(): string;
    readonly databasesLink: string;
    // (undocumented)
    readonly enableMultipleWritableLocations: boolean;
    // @deprecated
    get MaxMediaStorageUsageInMB(): number;
    readonly maxMediaStorageUsageInMB: number;
    // @deprecated
    get MediaLink(): string;
    readonly mediaLink: string;
    readonly readableLocations: Location_2[];
    readonly writableLocations: Location_2[];
}

// @public (undocumented)
export interface DatabaseDefinition {
    id?: string;
}

// @public (undocumented)
export interface DatabaseRequest extends DatabaseDefinition {
    // (undocumented)
    autoUpgradePolicy?: {
        throughputPolicy: {
            incrementPercent: number;
        };
    };
    // (undocumented)
    maxThroughput?: number;
    throughput?: number;
}

// @public
export class DatabaseResponse extends ResourceResponse<DatabaseDefinition & Resource> {
    constructor(resource: DatabaseDefinition & Resource, headers: CosmosHeaders, statusCode: number, database: Database, diagnostics: CosmosDiagnostics);
    readonly database: Database;
}

// @public
export class Databases {
    constructor(client: CosmosClient, clientContext: ClientContext);
    // (undocumented)
    readonly client: CosmosClient;
    create(body: DatabaseRequest, options?: RequestOptions): Promise<DatabaseResponse>;
    createIfNotExists(body: DatabaseRequest, options?: RequestOptions): Promise<DatabaseResponse>;
    query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<DatabaseDefinition & Resource>;
}

// @public
export enum DataType {
    LineString = "LineString",
    MultiPolygon = "MultiPolygon",
    Number = "Number",
    Point = "Point",
    Polygon = "Polygon",
    String = "String"
}

// @public (undocumented)
export const DEFAULT_PARTITION_KEY_PATH: "/_partitionKey";

// @public (undocumented)
export type DeleteOperation = OperationBase & {
    operationType: typeof BulkOperationType.Delete;
    id: string;
};

// @public (undocumented)
export interface DeleteOperationInput {
    // (undocumented)
    id: string;
    // (undocumented)
    operationType: typeof BulkOperationType.Delete;
    // (undocumented)
    partitionKey?: string | number | null | Record<string, unknown> | undefined;
}

// @public (undocumented)
export interface ErrorBody {
    // (undocumented)
    additionalErrorInfo?: PartitionedQueryExecutionInfo;
    // (undocumented)
    code: string;
    // (undocumented)
    message: string;
}

// @public (undocumented)
export class ErrorResponse extends Error {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    activityId?: string;
    // (undocumented)
    body?: ErrorBody;
    // (undocumented)
    code?: number;
    // (undocumented)
    diagnostics: CosmosDiagnostics;
    // (undocumented)
    headers?: CosmosHeaders;
    // (undocumented)
    retryAfterInMilliseconds?: number;
    // (undocumented)
    retryAfterInMs?: number;
    // (undocumented)
    substatus?: number;
}

// @public (undocumented)
export type ExistingKeyOperation = {
    op: keyof typeof PatchOperationType;
    value: any;
    path: string;
};

// @public (undocumented)
export function extractPartitionKey(document: unknown, partitionKeyDefinition: PartitionKeyDefinition): PartitionKey[];

// @public
export interface FailedRequestAttemptDiagnostic {
    // (undocumented)
    attemptNumber: number;
    // (undocumented)
    endTimeUTCInMs: number;
    // (undocumented)
    id: string;
    // (undocumented)
    startTimeUTCInMs: number;
    // (undocumented)
    statusCode: string;
}

// @public
export interface FeedOptions extends SharedOptions {
    accessCondition?: {
        type: string;
        condition: string;
    };
    bufferItems?: boolean;
    // @deprecated
    continuation?: string;
    continuationToken?: string;
    continuationTokenLimitInKB?: number;
    enableScanInQuery?: boolean;
    forceQueryPlan?: boolean;
    maxDegreeOfParallelism?: number;
    maxItemCount?: number;
    partitionKey?: any;
    populateIndexMetrics?: boolean;
    populateQueryMetrics?: boolean;
    useIncrementalFeed?: boolean;
}

// @public (undocumented)
export class FeedResponse<TResource> {
    constructor(resources: TResource[], headers: CosmosHeaders, hasMoreResults: boolean);
    // (undocumented)
    get activityId(): string;
    // (undocumented)
    get continuation(): string;
    // (undocumented)
    get continuationToken(): string;
    // (undocumented)
    readonly hasMoreResults: boolean;
    // (undocumented)
    get indexMetrics(): string;
    // (undocumented)
    get queryMetrics(): string;
    // (undocumented)
    get requestCharge(): number;
    // (undocumented)
    readonly resources: TResource[];
}

// @public (undocumented)
export enum GeospatialType {
    Geography = "Geography",
    Geometry = "Geometry"
}

// @public
export class GlobalEndpointManager {
    constructor(options: CosmosClientOptions, readDatabaseAccount: (opts: RequestOptions) => Promise<ResourceResponse<DatabaseAccount>>);
    // (undocumented)
    canUseMultipleWriteLocations(resourceType?: ResourceType, operationType?: OperationType): boolean;
    enableEndpointDiscovery: boolean;
    getReadEndpoint(): Promise<string>;
    // (undocumented)
    getReadEndpoints(): Promise<ReadonlyArray<string>>;
    getWriteEndpoint(): Promise<string>;
    // (undocumented)
    getWriteEndpoints(): Promise<ReadonlyArray<string>>;
    // (undocumented)
    markCurrentLocationUnavailableForRead(endpoint: string): Promise<void>;
    // (undocumented)
    markCurrentLocationUnavailableForWrite(endpoint: string): Promise<void>;
    refreshEndpointList(): Promise<void>;
    // (undocumented)
    resolveServiceEndpoint(resourceType: ResourceType, operationType: OperationType, requestContext?: RequestContext): Promise<string>;
}

// @public (undocumented)
export interface GroupByAliasToAggregateType {
    // (undocumented)
    [key: string]: AggregateType;
}

// @public (undocumented)
export type GroupByExpressions = string[];

// @public (undocumented)
export enum HTTPMethod {
    // (undocumented)
    delete = "DELETE",
    // (undocumented)
    get = "GET",
    // (undocumented)
    patch = "PATCH",
    // (undocumented)
    post = "POST",
    // (undocumented)
    put = "PUT"
}

// @public (undocumented)
export interface Index {
    // (undocumented)
    dataType: keyof typeof DataType;
    // (undocumented)
    kind: keyof typeof IndexKind;
    // (undocumented)
    precision?: number;
}

// @public (undocumented)
export interface IndexedPath {
    // (undocumented)
    indexes?: Index[];
    // (undocumented)
    path: string;
}

// @public
export enum IndexingMode {
    consistent = "consistent",
    lazy = "lazy",
    none = "none"
}

// @public (undocumented)
export interface IndexingPolicy {
    // (undocumented)
    automatic?: boolean;
    excludedPaths?: IndexedPath[];
    includedPaths?: IndexedPath[];
    indexingMode?: keyof typeof IndexingMode;
    // (undocumented)
    spatialIndexes?: SpatialIndex[];
}

// @public
export enum IndexKind {
    Range = "Range",
    Spatial = "Spatial"
}

// @public
export class Item {
    constructor(container: Container, id: string, partitionKey: PartitionKey, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete<T extends ItemDefinition = any>(options?: RequestOptions): Promise<ItemResponse<T>>;
    // (undocumented)
    readonly id: string;
    patch<T extends ItemDefinition = any>(body: PatchRequestBody, options?: RequestOptions): Promise<ItemResponse<T>>;
    read<T extends ItemDefinition = any>(options?: RequestOptions): Promise<ItemResponse<T>>;
    replace(body: ItemDefinition, options?: RequestOptions): Promise<ItemResponse<ItemDefinition>>;
    replace<T extends ItemDefinition>(body: T, options?: RequestOptions): Promise<ItemResponse<T>>;
    get url(): string;
}

// @public
export interface ItemDefinition {
    // (undocumented)
    [key: string]: any;
    id?: string;
    ttl?: number;
}

// @public (undocumented)
export class ItemResponse<T extends ItemDefinition> extends ResourceResponse<T & Resource> {
    constructor(resource: T & Resource, headers: CosmosHeaders, statusCode: number, subsstatusCode: number, item: Item, diagnostics: CosmosDiagnostics);
    readonly item: Item;
}

// @public
export class Items {
    constructor(container: Container, clientContext: ClientContext);
    batch(operations: OperationInput[], partitionKey?: string, options?: RequestOptions): Promise<Response_2<OperationResponse[]>>;
    bulk(operations: OperationInput[], bulkOptions?: BulkOptions, options?: RequestOptions): Promise<OperationResponse[]>;
    changeFeed(partitionKey: string | number | boolean, changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;
    changeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;
    changeFeed<T>(partitionKey: string | number | boolean, changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;
    changeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;
    // (undocumented)
    readonly container: Container;
    create<T extends ItemDefinition = any>(body: T, options?: RequestOptions): Promise<ItemResponse<T>>;
    query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<ItemDefinition>;
    readAll<T extends ItemDefinition>(options?: FeedOptions): QueryIterator<T>;
    // @deprecated
    readChangeFeed(partitionKey: string | number | boolean, changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;
    // @deprecated
    readChangeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;
    // @deprecated
    readChangeFeed<T>(partitionKey: string | number | boolean, changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;
    // @deprecated
    readChangeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;
    upsert(body: unknown, options?: RequestOptions): Promise<ItemResponse<ItemDefinition>>;
    upsert<T extends ItemDefinition>(body: T, options?: RequestOptions): Promise<ItemResponse<T>>;
}

// @public (undocumented)
export interface JSONArray extends ArrayLike<JSONValue> {
}

// @public (undocumented)
export interface JSONObject {
    // (undocumented)
    [key: string]: JSONValue;
}

// @public (undocumented)
export type JSONValue = boolean | number | string | null | JSONArray | JSONObject;

// @public
interface Location_2 {
    // (undocumented)
    databaseAccountEndpoint: string;
    // (undocumented)
    lastUnavailabilityTimestampInMs?: number;
    // (undocumented)
    name: string;
    // (undocumented)
    unavailable?: boolean;
}
export { Location_2 as Location }

// @public
export interface MetadataLookUpDiagnostic {
    // (undocumented)
    activityId: string;
    // (undocumented)
    endTimeUTCInMs: number;
    // (undocumented)
    id: string;
    // (undocumented)
    metaDataType: MetadataLookUpType;
    // (undocumented)
    startTimeUTCInMs: number;
}

// @public
export type MetadataLookUpDiagnostics = {
    metadataLookups: MetadataLookUpDiagnostic[];
};

// @public
export enum MetadataLookUpType {
    // (undocumented)
    DatabaseAccountLookUp = "DATABASE_ACCOUNT_LOOK_UP",
    // (undocumented)
    PartitionKeyRangeLookUp = "PARTITION_KEY_RANGE_LOOK_UP",
    // (undocumented)
    ServerAddressLookUp = "SERVER_ADDRESS_LOOK_UP"
}

// @public
export type Next<T> = (context: RequestContext) => Promise<Response_2<T>>;

// @public
export class Offer {
    constructor(client: CosmosClient, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly client: CosmosClient;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<OfferResponse>;
    replace(body: OfferDefinition, options?: RequestOptions): Promise<OfferResponse>;
    get url(): string;
}

// @public (undocumented)
export interface OfferDefinition {
    // (undocumented)
    content?: {
        offerThroughput: number;
        offerIsRUPerMinuteThroughputEnabled: boolean;
        offerMinimumThroughputParameters?: {
            maxThroughputEverProvisioned: number;
            maxConsumedStorageEverInKB: number;
        };
        offerAutopilotSettings?: {
            tier: number;
            maximumTierThroughput: number;
            autoUpgrade: boolean;
            maxThroughput: number;
        };
    };
    // (undocumented)
    id?: string;
    // (undocumented)
    offerResourceId?: string;
    // (undocumented)
    offerType?: string;
    // (undocumented)
    offerVersion?: string;
    // (undocumented)
    resource?: string;
}

// @public (undocumented)
export class OfferResponse extends ResourceResponse<OfferDefinition & Resource> {
    constructor(resource: OfferDefinition & Resource, headers: CosmosHeaders, statusCode: number, diagnostics: CosmosDiagnostics, offer?: Offer);
    readonly offer: Offer;
}

// @public
export class Offers {
    constructor(client: CosmosClient, clientContext: ClientContext);
    // (undocumented)
    readonly client: CosmosClient;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<OfferDefinition & Resource>;
}

// @public (undocumented)
export type Operation = CreateOperation | UpsertOperation | ReadOperation | DeleteOperation | ReplaceOperation | BulkPatchOperation;

// @public (undocumented)
export interface OperationBase {
    // (undocumented)
    ifMatch?: string;
    // (undocumented)
    ifNoneMatch?: string;
    // (undocumented)
    partitionKey?: string;
}

// @public (undocumented)
export type OperationInput = CreateOperationInput | UpsertOperationInput | ReadOperationInput | DeleteOperationInput | ReplaceOperationInput | PatchOperationInput;

// @public (undocumented)
export interface OperationResponse {
    // (undocumented)
    eTag?: string;
    // (undocumented)
    requestCharge: number;
    // (undocumented)
    resourceBody?: JSONObject;
    // (undocumented)
    statusCode: number;
}

// @public (undocumented)
export enum OperationType {
    // (undocumented)
    Batch = "batch",
    // (undocumented)
    Create = "create",
    // (undocumented)
    Delete = "delete",
    // (undocumented)
    Execute = "execute",
    // (undocumented)
    Patch = "patch",
    // (undocumented)
    Query = "query",
    // (undocumented)
    Read = "read",
    // (undocumented)
    Replace = "replace",
    // (undocumented)
    Upsert = "upsert"
}

// @public (undocumented)
export type OperationWithItem = OperationBase & {
    resourceBody: JSONObject;
};

// @public (undocumented)
export interface PartitionedQueryExecutionInfo {
    // (undocumented)
    partitionedQueryExecutionInfoVersion: number;
    // (undocumented)
    queryInfo: QueryInfo;
    // (undocumented)
    queryRanges: QueryRange[];
}

// @public (undocumented)
export type PartitionKey = PartitionKeyDefinition | string | number | unknown;

// @public (undocumented)
export interface PartitionKeyDefinition {
    paths: string[];
    // (undocumented)
    systemKey?: boolean;
    version?: number;
}

// @public (undocumented)
export interface PartitionKeyRange {
    // (undocumented)
    id: string;
    // (undocumented)
    maxExclusive: string;
    // (undocumented)
    minInclusive: string;
    // (undocumented)
    parents: string[];
    // (undocumented)
    ridPrefix: number;
    // (undocumented)
    status: string;
    // (undocumented)
    throughputFraction: number;
}

// @public (undocumented)
export interface PartitionKeyRangePropertiesNames {
    // (undocumented)
    Id: "id";
    // (undocumented)
    MaxExclusive: "maxExclusive";
    // (undocumented)
    MinInclusive: "minInclusive";
}

// @public (undocumented)
export type PatchOperation = ExistingKeyOperation | RemoveOperation;

// @public (undocumented)
export interface PatchOperationInput {
    // (undocumented)
    id: string;
    // (undocumented)
    ifMatch?: string;
    // (undocumented)
    ifNoneMatch?: string;
    // (undocumented)
    operationType: typeof BulkOperationType.Patch;
    // (undocumented)
    partitionKey?: string | number | null | Record<string, unknown> | undefined;
    // (undocumented)
    resourceBody: PatchRequestBody;
}

// @public (undocumented)
export const PatchOperationType: {
    readonly add: "add";
    readonly replace: "replace";
    readonly remove: "remove";
    readonly set: "set";
    readonly incr: "incr";
};

// @public (undocumented)
export type PatchRequestBody = {
    operations: PatchOperation[];
    condition?: string;
} | PatchOperation[];

// @public
export class Permission {
    constructor(user: User, id: string, clientContext: ClientContext);
    delete(options?: RequestOptions): Promise<PermissionResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<PermissionResponse>;
    replace(body: PermissionDefinition, options?: RequestOptions): Promise<PermissionResponse>;
    get url(): string;
    // (undocumented)
    readonly user: User;
}

// @public (undocumented)
export interface PermissionBody {
    _token: string;
}

// @public (undocumented)
export interface PermissionDefinition {
    id: string;
    permissionMode: PermissionMode;
    resource: string;
    // (undocumented)
    resourcePartitionKey?: string | any[];
}

// @public
export enum PermissionMode {
    All = "all",
    None = "none",
    Read = "read"
}

// @public (undocumented)
export class PermissionResponse extends ResourceResponse<PermissionDefinition & PermissionBody & Resource> {
    constructor(resource: PermissionDefinition & PermissionBody & Resource, headers: CosmosHeaders, statusCode: number, permission: Permission, diagnostics: CosmosDiagnostics);
    readonly permission: Permission;
}

// @public
class Permissions_2 {
    constructor(user: User, clientContext: ClientContext);
    create(body: PermissionDefinition, options?: RequestOptions): Promise<PermissionResponse>;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<PermissionDefinition & Resource>;
    upsert(body: PermissionDefinition, options?: RequestOptions): Promise<PermissionResponse>;
    // (undocumented)
    readonly user: User;
}
export { Permissions_2 as Permissions }

// @public
type Plugin_2<T> = (context: RequestContext, next: Next<T>) => Promise<Response_2<T>>;
export { Plugin_2 as Plugin }

// @public
export interface PluginConfig {
    on: keyof typeof PluginOn;
    plugin: Plugin_2<any>;
}

// @public
export enum PluginOn {
    operation = "operation",
    request = "request"
}

// @public (undocumented)
export interface QueryInfo {
    // (undocumented)
    aggregates?: AggregateType[];
    // (undocumented)
    distinctType: string;
    // (undocumented)
    groupByAliasToAggregateType: GroupByAliasToAggregateType;
    // (undocumented)
    groupByExpressions?: GroupByExpressions;
    // (undocumented)
    hasSelectValue: boolean;
    // (undocumented)
    limit?: number;
    // (undocumented)
    offset?: number;
    // (undocumented)
    orderBy?: any[];
    // (undocumented)
    orderByExpressions?: any[];
    // (undocumented)
    rewrittenQuery?: any;
    // (undocumented)
    top?: any;
}

// @public
export class QueryIterator<T> {
    // Warning: (ae-forgotten-export) The symbol "FetchFunctionCallback" needs to be exported by the entry point index.d.ts
    constructor(clientContext: ClientContext, query: SqlQuerySpec | string, options: FeedOptions, fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[], resourceLink?: string, resourceType?: ResourceType);
    fetchAll(): Promise<FeedResponse<T>>;
    fetchNext(): Promise<FeedResponse<T>>;
    getAsyncIterator(): AsyncIterable<FeedResponse<T>>;
    hasMoreResults(): boolean;
    reset(): void;
}

// @public (undocumented)
export class QueryMetrics {
    constructor(retrievedDocumentCount: number, retrievedDocumentSize: number, outputDocumentCount: number, outputDocumentSize: number, indexHitDocumentCount: number, totalQueryExecutionTime: TimeSpan, queryPreparationTimes: QueryPreparationTimes, indexLookupTime: TimeSpan, documentLoadTime: TimeSpan, vmExecutionTime: TimeSpan, runtimeExecutionTimes: RuntimeExecutionTimes, documentWriteTime: TimeSpan, clientSideMetrics: ClientSideMetrics);
    add(queryMetricsArray: QueryMetrics[]): QueryMetrics;
    // (undocumented)
    readonly clientSideMetrics: ClientSideMetrics;
    static createFromArray(queryMetricsArray: QueryMetrics[]): QueryMetrics;
    static createFromDelimitedString(delimitedString: string, clientSideMetrics?: ClientSideMetrics): QueryMetrics;
    // (undocumented)
    readonly documentLoadTime: TimeSpan;
    // (undocumented)
    readonly documentWriteTime: TimeSpan;
    // (undocumented)
    readonly indexHitDocumentCount: number;
    get indexHitRatio(): number;
    // (undocumented)
    readonly indexLookupTime: TimeSpan;
    // (undocumented)
    readonly outputDocumentCount: number;
    // (undocumented)
    readonly outputDocumentSize: number;
    // (undocumented)
    readonly queryPreparationTimes: QueryPreparationTimes;
    // (undocumented)
    readonly retrievedDocumentCount: number;
    // (undocumented)
    readonly retrievedDocumentSize: number;
    // (undocumented)
    readonly runtimeExecutionTimes: RuntimeExecutionTimes;
    toDelimitedString(): string;
    // (undocumented)
    readonly totalQueryExecutionTime: TimeSpan;
    // (undocumented)
    readonly vmExecutionTime: TimeSpan;
    // (undocumented)
    static readonly zero: QueryMetrics;
}

// @public (undocumented)
export const QueryMetricsConstants: {
    RetrievedDocumentCount: string;
    RetrievedDocumentSize: string;
    OutputDocumentCount: string;
    OutputDocumentSize: string;
    IndexHitRatio: string;
    IndexHitDocumentCount: string;
    TotalQueryExecutionTimeInMs: string;
    QueryCompileTimeInMs: string;
    LogicalPlanBuildTimeInMs: string;
    PhysicalPlanBuildTimeInMs: string;
    QueryOptimizationTimeInMs: string;
    IndexLookupTimeInMs: string;
    DocumentLoadTimeInMs: string;
    VMExecutionTimeInMs: string;
    DocumentWriteTimeInMs: string;
    QueryEngineTimes: string;
    SystemFunctionExecuteTimeInMs: string;
    UserDefinedFunctionExecutionTimeInMs: string;
    RetrievedDocumentCountText: string;
    RetrievedDocumentSizeText: string;
    OutputDocumentCountText: string;
    OutputDocumentSizeText: string;
    IndexUtilizationText: string;
    TotalQueryExecutionTimeText: string;
    QueryPreparationTimesText: string;
    QueryCompileTimeText: string;
    LogicalPlanBuildTimeText: string;
    PhysicalPlanBuildTimeText: string;
    QueryOptimizationTimeText: string;
    QueryEngineTimesText: string;
    IndexLookupTimeText: string;
    DocumentLoadTimeText: string;
    WriteOutputTimeText: string;
    RuntimeExecutionTimesText: string;
    TotalExecutionTimeText: string;
    SystemFunctionExecuteTimeText: string;
    UserDefinedFunctionExecutionTimeText: string;
    ClientSideQueryMetricsText: string;
    RetriesText: string;
    RequestChargeText: string;
    FetchExecutionRangesText: string;
    SchedulingMetricsText: string;
};

// @public (undocumented)
export class QueryPreparationTimes {
    constructor(queryCompilationTime: TimeSpan, logicalPlanBuildTime: TimeSpan, physicalPlanBuildTime: TimeSpan, queryOptimizationTime: TimeSpan);
    add(...queryPreparationTimesArray: QueryPreparationTimes[]): QueryPreparationTimes;
    static createFromArray(queryPreparationTimesArray: QueryPreparationTimes[]): QueryPreparationTimes;
    static createFromDelimitedString(delimitedString: string): QueryPreparationTimes;
    // (undocumented)
    readonly logicalPlanBuildTime: TimeSpan;
    // (undocumented)
    readonly physicalPlanBuildTime: TimeSpan;
    // (undocumented)
    readonly queryCompilationTime: TimeSpan;
    // (undocumented)
    readonly queryOptimizationTime: TimeSpan;
    toDelimitedString(): string;
    // (undocumented)
    static readonly zero: QueryPreparationTimes;
}

// @public (undocumented)
export interface QueryRange {
    // (undocumented)
    isMaxInclusive: boolean;
    // (undocumented)
    isMinInclusive: boolean;
    // (undocumented)
    max: string;
    // (undocumented)
    min: string;
}

// @public (undocumented)
export type ReadOperation = OperationBase & {
    operationType: typeof BulkOperationType.Read;
    id: string;
};

// @public (undocumented)
export interface ReadOperationInput {
    // (undocumented)
    id: string;
    // (undocumented)
    operationType: typeof BulkOperationType.Read;
    // (undocumented)
    partitionKey?: string | number | boolean | null | Record<string, unknown> | undefined;
}

// @public (undocumented)
export type RemoveOperation = {
    op: "remove";
    path: string;
};

// @public (undocumented)
export type ReplaceOperation = OperationWithItem & {
    operationType: typeof BulkOperationType.Replace;
    id: string;
};

// @public (undocumented)
export interface ReplaceOperationInput {
    // (undocumented)
    id: string;
    // (undocumented)
    ifMatch?: string;
    // (undocumented)
    ifNoneMatch?: string;
    // (undocumented)
    operationType: typeof BulkOperationType.Replace;
    // (undocumented)
    partitionKey?: string | number | null | Record<string, unknown> | undefined;
    // (undocumented)
    resourceBody: JSONObject;
}

// @public (undocumented)
export interface RequestContext {
    // (undocumented)
    body?: any;
    // (undocumented)
    client?: ClientContext;
    // (undocumented)
    connectionPolicy: ConnectionPolicy;
    // (undocumented)
    diagnosticContext: CosmosDiagnosticContext;
    // (undocumented)
    endpoint?: string;
    // (undocumented)
    globalEndpointManager: GlobalEndpointManager;
    // (undocumented)
    headers?: CosmosHeaders_2;
    // (undocumented)
    method: HTTPMethod;
    // (undocumented)
    operationType?: OperationType;
    // (undocumented)
    options: FeedOptions | RequestOptions;
    // (undocumented)
    partitionKey?: PartitionKey;
    // (undocumented)
    partitionKeyRangeId?: string;
    // (undocumented)
    path?: string;
    // (undocumented)
    pipeline?: Pipeline;
    // (undocumented)
    plugins: PluginConfig[];
    // (undocumented)
    requestAgent: Agent;
    // (undocumented)
    resourceId?: string;
    // (undocumented)
    resourceType?: ResourceType;
    // (undocumented)
    retryCount?: number;
}

// @public (undocumented)
interface RequestInfo_2 {
    // (undocumented)
    headers: CosmosHeaders;
    // (undocumented)
    path: string;
    // (undocumented)
    resourceId: string;
    // (undocumented)
    resourceType: ResourceType;
    // (undocumented)
    verb: HTTPMethod;
}
export { RequestInfo_2 as RequestInfo }

// @public
export interface RequestOptions extends SharedOptions {
    accessCondition?: {
        type: string;
        condition: string;
    };
    consistencyLevel?: string;
    disableAutomaticIdGeneration?: boolean;
    disableRUPerMinuteUsage?: boolean;
    enableScriptLogging?: boolean;
    indexingDirective?: string;
    offerThroughput?: number;
    offerType?: string;
    populateQuotaInfo?: boolean;
    postTriggerInclude?: string | string[];
    preTriggerInclude?: string | string[];
    resourceTokenExpirySeconds?: number;
    urlConnection?: string;
}

// @public (undocumented)
export interface Resource {
    _etag: string;
    id: string;
    _rid: string;
    _self: string;
    _ts: number;
}

// @public (undocumented)
export class ResourceResponse<TResource> {
    constructor(resource: TResource | undefined, headers: CosmosHeaders_2, statusCode: StatusCode, diagnostics?: CosmosDiagnostics, substatus?: SubStatusCode);
    // (undocumented)
    get activityId(): string;
    // (undocumented)
    readonly diagnostics?: CosmosDiagnostics;
    // (undocumented)
    get etag(): string;
    // (undocumented)
    readonly headers: CosmosHeaders_2;
    // (undocumented)
    get requestCharge(): number;
    // (undocumented)
    readonly resource: TResource | undefined;
    // (undocumented)
    readonly statusCode: StatusCode;
    // (undocumented)
    readonly substatus?: SubStatusCode;
}

// @public (undocumented)
export enum ResourceType {
    // (undocumented)
    conflicts = "conflicts",
    // (undocumented)
    container = "colls",
    // (undocumented)
    database = "dbs",
    // (undocumented)
    item = "docs",
    // (undocumented)
    none = "",
    // (undocumented)
    offer = "offers",
    // (undocumented)
    partitionkey = "partitionKey",
    // (undocumented)
    permission = "permissions",
    // (undocumented)
    pkranges = "pkranges",
    // (undocumented)
    sproc = "sprocs",
    // (undocumented)
    trigger = "triggers",
    // (undocumented)
    udf = "udfs",
    // (undocumented)
    user = "users"
}

// @public (undocumented)
interface Response_2<T> {
    // (undocumented)
    code?: number;
    // (undocumented)
    diagnostics?: CosmosDiagnostics;
    // (undocumented)
    headers: CosmosHeaders;
    // (undocumented)
    result?: T;
    // (undocumented)
    substatus?: number;
}
export { Response_2 as Response }

export { RestError }

// @public
export type RetryDiagnostics = {
    failedAttempts: FailedRequestAttemptDiagnostic[];
};

// @public
export interface RetryOptions {
    fixedRetryIntervalInMilliseconds: number;
    maxRetryAttemptCount: number;
    maxWaitTimeInSeconds: number;
}

// @public (undocumented)
export class RuntimeExecutionTimes {
    constructor(queryEngineExecutionTime: TimeSpan, systemFunctionExecutionTime: TimeSpan, userDefinedFunctionExecutionTime: TimeSpan);
    add(...runtimeExecutionTimesArray: RuntimeExecutionTimes[]): RuntimeExecutionTimes;
    static createFromArray(runtimeExecutionTimesArray: RuntimeExecutionTimes[]): RuntimeExecutionTimes;
    static createFromDelimitedString(delimitedString: string): RuntimeExecutionTimes;
    // (undocumented)
    readonly queryEngineExecutionTime: TimeSpan;
    // (undocumented)
    readonly systemFunctionExecutionTime: TimeSpan;
    toDelimitedString(): string;
    // (undocumented)
    readonly userDefinedFunctionExecutionTime: TimeSpan;
    // (undocumented)
    static readonly zero: RuntimeExecutionTimes;
}

// @public (undocumented)
export enum SasTokenPermissionKind {
    // (undocumented)
    ContainerCreateItems = 1,
    // (undocumented)
    ContainerCreateStoreProcedure = 16,
    // (undocumented)
    ContainerCreateTriggers = 256,
    // (undocumented)
    ContainerCreateUserDefinedFunctions = 2048,
    // (undocumented)
    ContainerDeleteConflicts = 16384,
    // (undocumented)
    ContainerDeleteItems = 128,
    // (undocumented)
    ContainerDeleteStoreProcedure = 64,
    // (undocumented)
    ContainerDeleteTriggers = 1024,
    // (undocumented)
    ContainerDeleteUserDefinedFunctions = 8192,
    // (undocumented)
    ContainerExecuteQueries = 1,
    // (undocumented)
    ContainerExecuteStoredProcedure = 128,
    // (undocumented)
    ContainerFullAccess = 4294967295,
    // (undocumented)
    ContainerReadAny = 64,
    // (undocumented)
    ContainerReadConflicts = 32,
    // (undocumented)
    ContainerReadFeeds = 2,
    // (undocumented)
    ContainerReadStoreProcedure = 4,
    // (undocumented)
    ContainerReadTriggers = 16,
    // (undocumented)
    ContainerReadUserDefinedFunctions = 8,
    // (undocumented)
    ContainerReplaceItems = 2,
    // (undocumented)
    ContainerReplaceStoreProcedure = 32,
    // (undocumented)
    ContainerReplaceTriggers = 512,
    // (undocumented)
    ContainerReplaceUserDefinedFunctions = 4096,
    // (undocumented)
    ContainerUpsertItems = 4,
    // (undocumented)
    ItemDelete = 262144,
    // (undocumented)
    ItemFullAccess = 65,
    // (undocumented)
    ItemRead = 64,
    // (undocumented)
    ItemReadAny = 65536,
    // (undocumented)
    ItemReplace = 65536,
    // (undocumented)
    ItemUpsert = 131072,
    // (undocumented)
    StoreProcedureDelete = 2097152,
    // (undocumented)
    StoreProcedureExecute = 4194304,
    // (undocumented)
    StoreProcedureRead = 128,
    // (undocumented)
    StoreProcedureReplace = 1048576,
    // (undocumented)
    TriggerDelete = 67108864,
    // (undocumented)
    TriggerRead = 512,
    // (undocumented)
    TriggerReplace = 33554432,
    // (undocumented)
    UserDefinedFuntionDelete = 16777216,
    // (undocumented)
    UserDefinedFuntionRead = 256,
    // (undocumented)
    UserDefinedFuntionReplace = 8388608
}

// @public (undocumented)
export class SasTokenProperties {
    // (undocumented)
    containerName: string;
    // (undocumented)
    controlPlaneReaderScope: number;
    // (undocumented)
    controlPlaneWriterScope: number;
    // (undocumented)
    cosmosContainerChildResourceKind: CosmosContainerChildResourceKind;
    // (undocumented)
    cosmosKeyType: CosmosKeyType;
    // (undocumented)
    databaseName: string;
    // (undocumented)
    dataPlaneReaderScope: number;
    // (undocumented)
    dataPlaneWriterScope: number;
    // (undocumented)
    expiryTime: Date;
    // Warning: (ae-forgotten-export) The symbol "CosmosKeyType" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    keyType: CosmosKeyType | number;
    // (undocumented)
    partitionKeyValueRanges: string[];
    // Warning: (ae-forgotten-export) The symbol "CosmosContainerChildResourceKind" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    resourceKind: CosmosContainerChildResourceKind;
    // (undocumented)
    resourceName: string;
    // (undocumented)
    resourcePath: string;
    // (undocumented)
    startTime: Date;
    // (undocumented)
    user: string;
    // (undocumented)
    userTag: string;
}

// @public (undocumented)
export class Scripts {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    storedProcedure(id: string): StoredProcedure;
    get storedProcedures(): StoredProcedures;
    trigger(id: string): Trigger;
    get triggers(): Triggers;
    userDefinedFunction(id: string): UserDefinedFunction;
    get userDefinedFunctions(): UserDefinedFunctions;
}

// @public
export function setAuthorizationTokenHeaderUsingMasterKey(verb: HTTPMethod, resourceId: string, resourceType: ResourceType, headers: CosmosHeaders, masterKey: string): Promise<void>;

// @public
export interface SharedOptions {
    abortSignal?: AbortSignal_2;
    initialHeaders?: CosmosHeaders;
    maxIntegratedCacheStalenessInMs?: number;
    sessionToken?: string;
}

// @public (undocumented)
export interface SpatialIndex {
    // (undocumented)
    boundingBox: {
        xmin: number;
        ymin: number;
        xmax: number;
        ymax: number;
    };
    // (undocumented)
    path: string;
    // (undocumented)
    types: SpatialType[];
}

// @public (undocumented)
export enum SpatialType {
    // (undocumented)
    LineString = "LineString",
    // (undocumented)
    MultiPolygon = "MultiPolygon",
    // (undocumented)
    Point = "Point",
    // (undocumented)
    Polygon = "Polygon"
}

// @public
export interface SqlParameter {
    name: string;
    value: JSONValue;
}

// @public
export interface SqlQuerySpec {
    parameters?: SqlParameter[];
    query: string;
}

// @public (undocumented)
export type StatusCode = number;

// @public (undocumented)
export const StatusCodes: StatusCodesType;

// @public (undocumented)
export interface StatusCodesType {
    // (undocumented)
    Accepted: 202;
    // (undocumented)
    BadRequest: 400;
    // (undocumented)
    Conflict: 409;
    // (undocumented)
    Created: 201;
    // (undocumented)
    ENOTFOUND: "ENOTFOUND";
    // (undocumented)
    Forbidden: 403;
    // (undocumented)
    Gone: 410;
    // (undocumented)
    InternalServerError: 500;
    // (undocumented)
    MethodNotAllowed: 405;
    // (undocumented)
    NoContent: 204;
    // (undocumented)
    NotFound: 404;
    // (undocumented)
    NotModified: 304;
    // (undocumented)
    Ok: 200;
    // (undocumented)
    OperationCancelled: 1201;
    // (undocumented)
    OperationPaused: 1200;
    // (undocumented)
    PreconditionFailed: 412;
    // (undocumented)
    RequestEntityTooLarge: 413;
    // (undocumented)
    RequestTimeout: 408;
    // (undocumented)
    RetryWith: 449;
    // (undocumented)
    ServiceUnavailable: 503;
    // (undocumented)
    TooManyRequests: 429;
    // (undocumented)
    Unauthorized: 401;
}

// @public
export class StoredProcedure {
    constructor(container: Container, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete(options?: RequestOptions): Promise<StoredProcedureResponse>;
    execute<T = any>(partitionKey: PartitionKey, params?: any[], options?: RequestOptions): Promise<ResourceResponse<T>>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<StoredProcedureResponse>;
    replace(body: StoredProcedureDefinition, options?: RequestOptions): Promise<StoredProcedureResponse>;
    get url(): string;
}

// @public (undocumented)
export interface StoredProcedureDefinition {
    body?: string | ((...inputs: any[]) => void);
    id?: string;
}

// @public (undocumented)
export class StoredProcedureResponse extends ResourceResponse<StoredProcedureDefinition & Resource> {
    constructor(resource: StoredProcedureDefinition & Resource, headers: CosmosHeaders, statusCode: number, storedProcedure: StoredProcedure, diagnostics: CosmosDiagnostics);
    get sproc(): StoredProcedure;
    readonly storedProcedure: StoredProcedure;
}

// @public
export class StoredProcedures {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    create(body: StoredProcedureDefinition, options?: RequestOptions): Promise<StoredProcedureResponse>;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<StoredProcedureDefinition & Resource>;
}

// @public (undocumented)
export type SubStatusCode = number;

// @public (undocumented)
export class TimeoutError extends Error {
    constructor(message?: string);
    // (undocumented)
    readonly code: string;
}

// @public
export class TimeSpan {
    constructor(days: number, hours: number, minutes: number, seconds: number, milliseconds: number);
    add(ts: TimeSpan): TimeSpan;
    // (undocumented)
    static additionDoesOverflow(a: number, b: number): boolean;
    // (undocumented)
    static compare(t1: TimeSpan, t2: TimeSpan): 1 | 0 | -1;
    compareTo(value: TimeSpan): 1 | -1 | 0;
    // (undocumented)
    days(): number;
    duration(): TimeSpan;
    equals(value: TimeSpan): boolean;
    // (undocumented)
    static fromDays(value: number): TimeSpan;
    // (undocumented)
    static fromHours(value: number): TimeSpan;
    // (undocumented)
    static fromMilliseconds(value: number): TimeSpan;
    // (undocumented)
    static fromMinutes(value: number): TimeSpan;
    // (undocumented)
    static fromSeconds(value: number): TimeSpan;
    // (undocumented)
    static fromTicks(value: number): TimeSpan;
    // (undocumented)
    hours(): number;
    // (undocumented)
    static interval(value: number, scale: number): TimeSpan;
    // (undocumented)
    static isTimeSpan(timespan: TimeSpan): number;
    // (undocumented)
    static readonly maxValue: TimeSpan;
    // (undocumented)
    milliseconds(): number;
    // (undocumented)
    static readonly minValue: TimeSpan;
    negate(): TimeSpan;
    // (undocumented)
    seconds(): number;
    subtract(ts: TimeSpan): TimeSpan;
    // (undocumented)
    static subtractionDoesUnderflow(a: number, b: number): boolean;
    // (undocumented)
    ticks(): number;
    // (undocumented)
    protected _ticks: number;
    // (undocumented)
    totalDays(): number;
    // (undocumented)
    totalHours(): number;
    // (undocumented)
    totalMilliseconds(): number;
    // (undocumented)
    totalMinutes(): number;
    // (undocumented)
    totalSeconds(): number;
    // (undocumented)
    static readonly zero: TimeSpan;
}

// @public (undocumented)
export type TokenProvider = (requestInfo: RequestInfo_2) => Promise<string>;

// @public
export class Trigger {
    constructor(container: Container, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete(options?: RequestOptions): Promise<TriggerResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<TriggerResponse>;
    replace(body: TriggerDefinition, options?: RequestOptions): Promise<TriggerResponse>;
    get url(): string;
}

// @public (undocumented)
export interface TriggerDefinition {
    body: (() => void) | string;
    id?: string;
    triggerOperation: TriggerOperation;
    triggerType: TriggerType;
}

// @public
export enum TriggerOperation {
    All = "all",
    Create = "create",
    Delete = "delete",
    Replace = "replace",
    Update = "update"
}

// @public (undocumented)
export class TriggerResponse extends ResourceResponse<TriggerDefinition & Resource> {
    constructor(resource: TriggerDefinition & Resource, headers: CosmosHeaders, statusCode: number, trigger: Trigger, diagnostics: CosmosDiagnostics);
    readonly trigger: Trigger;
}

// @public
export class Triggers {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    create(body: TriggerDefinition, options?: RequestOptions): Promise<TriggerResponse>;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<TriggerDefinition & Resource>;
}

// @public
export enum TriggerType {
    Post = "post",
    Pre = "pre"
}

// @public
export interface UniqueKey {
    // (undocumented)
    paths: string[];
}

// @public
export interface UniqueKeyPolicy {
    // (undocumented)
    uniqueKeys: UniqueKey[];
}

// @public (undocumented)
export type UpsertOperation = OperationWithItem & {
    operationType: typeof BulkOperationType.Upsert;
};

// @public (undocumented)
export interface UpsertOperationInput {
    // (undocumented)
    ifMatch?: string;
    // (undocumented)
    ifNoneMatch?: string;
    // (undocumented)
    operationType: typeof BulkOperationType.Upsert;
    // (undocumented)
    partitionKey?: string | number | null | Record<string, unknown> | undefined;
    // (undocumented)
    resourceBody: JSONObject;
}

// @public
export class User {
    constructor(database: Database, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly database: Database;
    delete(options?: RequestOptions): Promise<UserResponse>;
    // (undocumented)
    readonly id: string;
    permission(id: string): Permission;
    readonly permissions: Permissions_2;
    read(options?: RequestOptions): Promise<UserResponse>;
    replace(body: UserDefinition, options?: RequestOptions): Promise<UserResponse>;
    get url(): string;
}

// @public
export class UserDefinedFunction {
    constructor(container: Container, id: string, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    delete(options?: RequestOptions): Promise<UserDefinedFunctionResponse>;
    // (undocumented)
    readonly id: string;
    read(options?: RequestOptions): Promise<UserDefinedFunctionResponse>;
    replace(body: UserDefinedFunctionDefinition, options?: RequestOptions): Promise<UserDefinedFunctionResponse>;
    get url(): string;
}

// @public (undocumented)
export interface UserDefinedFunctionDefinition {
    body?: string | (() => void);
    id?: string;
}

// @public (undocumented)
export class UserDefinedFunctionResponse extends ResourceResponse<UserDefinedFunctionDefinition & Resource> {
    constructor(resource: UserDefinedFunctionDefinition & Resource, headers: CosmosHeaders, statusCode: number, udf: UserDefinedFunction, diagnostics: CosmosDiagnostics);
    get udf(): UserDefinedFunction;
    readonly userDefinedFunction: UserDefinedFunction;
}

// @public
export class UserDefinedFunctions {
    constructor(container: Container, clientContext: ClientContext);
    // (undocumented)
    readonly container: Container;
    create(body: UserDefinedFunctionDefinition, options?: RequestOptions): Promise<UserDefinedFunctionResponse>;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<UserDefinedFunctionDefinition & Resource>;
}

// @public
export enum UserDefinedFunctionType {
    Javascript = "Javascript"
}

// @public (undocumented)
export interface UserDefinition {
    id?: string;
}

// @public (undocumented)
export class UserResponse extends ResourceResponse<UserDefinition & Resource> {
    constructor(resource: UserDefinition & Resource, headers: CosmosHeaders, statusCode: number, user: User, diagnostics: CosmosDiagnostics);
    readonly user: User;
}

// @public
export class Users {
    constructor(database: Database, clientContext: ClientContext);
    create(body: UserDefinition, options?: RequestOptions): Promise<UserResponse>;
    // (undocumented)
    readonly database: Database;
    query(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;
    query<T>(query: SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;
    readAll(options?: FeedOptions): QueryIterator<UserDefinition & Resource>;
    upsert(body: UserDefinition, options?: RequestOptions): Promise<UserResponse>;
}

// Warnings were encountered during analysis:
//
// src/ClientContext.ts:90:5 - (ae-forgotten-export) The symbol "CosmosDiagnosticContext" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
