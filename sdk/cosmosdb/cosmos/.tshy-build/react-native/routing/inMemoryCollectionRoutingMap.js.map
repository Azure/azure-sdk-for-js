{"version":3,"file":"inMemoryCollectionRoutingMap.js","sourceRoot":"","sources":["../../../src/routing/inMemoryCollectionRoutingMap.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { PartitionKeyRange } from \"../client/index.js\";\nimport { Constants } from \"../common/index.js\";\nimport { QueryRange } from \"./QueryRange.js\";\n\n/** @hidden */\nexport class InMemoryCollectionRoutingMap {\n  private orderedPartitionKeyRanges: PartitionKeyRange[];\n  private orderedRanges: QueryRange[];\n  // TODO: chrande made this public, even though it is implementation detail for a test\n  public orderedPartitionInfo: unknown;\n\n  /**\n   * Represents a InMemoryCollectionRoutingMap Object,\n   * Stores partition key ranges in an efficient way with some additional information and provides\n   * convenience methods for working with set of ranges.\n   */\n  constructor(orderedPartitionKeyRanges: PartitionKeyRange[], orderedPartitionInfo: unknown) {\n    this.orderedPartitionKeyRanges = orderedPartitionKeyRanges;\n    this.orderedRanges = orderedPartitionKeyRanges.map((pkr) => {\n      return new QueryRange(\n        pkr[Constants.PartitionKeyRange.MinInclusive],\n        pkr[Constants.PartitionKeyRange.MaxExclusive],\n        true,\n        false,\n      );\n    });\n    this.orderedPartitionInfo = orderedPartitionInfo;\n  }\n  public getOrderedParitionKeyRanges(): PartitionKeyRange[] {\n    return this.orderedPartitionKeyRanges;\n  }\n\n  public getOverlappingRanges(providedQueryRanges: QueryRange | QueryRange[]): PartitionKeyRange[] {\n    // TODO This code has all kinds of smells. Multiple iterations and sorts just to grab overlapping ranges\n    // stfaul attempted to bring it down to one for-loop and failed\n    const pqr: QueryRange[] = Array.isArray(providedQueryRanges)\n      ? providedQueryRanges\n      : [providedQueryRanges];\n    const minToPartitionRange: any = {}; // TODO: any\n\n    // this for loop doesn't invoke any async callback\n    for (const queryRange of pqr) {\n      if (queryRange.isEmpty()) {\n        continue;\n      }\n\n      if (queryRange.isFullRange()) {\n        return this.orderedPartitionKeyRanges;\n      }\n\n      const minIndex = this.orderedRanges.findIndex((range) => {\n        if (queryRange.min > range.min && queryRange.min < range.max) {\n          return true;\n        }\n        if (queryRange.min === range.min) {\n          return true;\n        }\n        if (queryRange.min === range.max) {\n          return true;\n        }\n      });\n\n      if (minIndex < 0) {\n        throw new Error(\n          \"error in collection routing map, queried value is less than the start range.\",\n        );\n      }\n\n      // Start at the end and work backwards\n      let maxIndex: number;\n      for (let i = this.orderedRanges.length - 1; i >= 0; i--) {\n        const range = this.orderedRanges[i];\n        if (queryRange.max > range.min && queryRange.max < range.max) {\n          maxIndex = i;\n          break;\n        }\n        if (queryRange.max === range.min) {\n          maxIndex = i;\n          break;\n        }\n        if (queryRange.max === range.max) {\n          maxIndex = i;\n          break;\n        }\n      }\n\n      if (maxIndex > this.orderedRanges.length) {\n        throw new Error(\n          \"error in collection routing map, queried value is greater than the end range.\",\n        );\n      }\n\n      for (let j = minIndex; j < maxIndex + 1; j++) {\n        if (queryRange.overlaps(this.orderedRanges[j])) {\n          minToPartitionRange[\n            this.orderedPartitionKeyRanges[j][Constants.PartitionKeyRange.MinInclusive]\n          ] = this.orderedPartitionKeyRanges[j];\n        }\n      }\n    }\n\n    const overlappingPartitionKeyRanges = Object.keys(minToPartitionRange).map(\n      (k) => minToPartitionRange[k],\n    );\n\n    return overlappingPartitionKeyRanges.sort((a, b) => {\n      return a[Constants.PartitionKeyRange.MinInclusive].localeCompare(\n        b[Constants.PartitionKeyRange.MinInclusive],\n      );\n    });\n  }\n}\n"]}