{"version":3,"file":"globalEndpointManager.js","sourceRoot":"","sources":["../../src/globalEndpointManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { OperationType, ResourceType, isReadRequest } from \"./common/index.js\";\nimport type { CosmosClientOptions } from \"./CosmosClientOptions.js\";\nimport type { Location, DatabaseAccount } from \"./documents/index.js\";\nimport type { RequestOptions } from \"./index.js\";\nimport { Constants } from \"./common/constants.js\";\nimport type { ResourceResponse } from \"./request/index.js\";\nimport { MetadataLookUpType } from \"./CosmosDiagnostics.js\";\nimport type { DiagnosticNodeInternal } from \"./diagnostics/DiagnosticNodeInternal.js\";\nimport { withMetadataDiagnostics } from \"./utils/diagnostics.js\";\n\n/**\n * @hidden\n * This internal class implements the logic for endpoint management for geo-replicated database accounts.\n */\nexport class GlobalEndpointManager {\n  /**\n   * The endpoint used to create the client instance.\n   */\n  private defaultEndpoint: string;\n  /**\n   * Flag to enable/disable automatic redirecting of requests based on read/write operations.\n   */\n  public enableEndpointDiscovery: boolean;\n  private isRefreshing: boolean;\n  private options: CosmosClientOptions;\n  /**\n   * List of azure regions to be used as preferred locations for read requests.\n   */\n  private preferredLocations: string[];\n  private writeableLocations: Location[] = [];\n  private readableLocations: Location[] = [];\n  private unavailableReadableLocations: Location[] = [];\n  private unavailableWriteableLocations: Location[] = [];\n\n  public preferredLocationsCount: number;\n  /**\n   * @param options - The document client instance.\n   * @internal\n   */\n  constructor(\n    options: CosmosClientOptions,\n    private readDatabaseAccount: (\n      diagnosticNode: DiagnosticNodeInternal,\n      opts: RequestOptions,\n    ) => Promise<ResourceResponse<DatabaseAccount>>,\n  ) {\n    this.options = options;\n    this.defaultEndpoint = options.endpoint;\n    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;\n    this.isRefreshing = false;\n    this.preferredLocations = this.options.connectionPolicy.preferredLocations;\n    this.preferredLocationsCount = this.preferredLocations ? this.preferredLocations.length : 0;\n  }\n\n  /**\n   * Gets the current read endpoint from the endpoint cache.\n   */\n  public async getReadEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Read);\n  }\n\n  /**\n   * Gets the current write endpoint from the endpoint cache.\n   */\n  public async getWriteEndpoint(diagnosticNode: DiagnosticNodeInternal): Promise<string> {\n    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Replace);\n  }\n\n  public async getReadEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.readableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async getWriteEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.writeableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async markCurrentLocationUnavailableForRead(\n    diagnosticNode: DiagnosticNodeInternal,\n    endpoint: string,\n  ): Promise<void> {\n    await this.refreshEndpointList(diagnosticNode);\n    const location = this.readableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);\n    if (location) {\n      location.unavailable = true;\n      location.lastUnavailabilityTimestampInMs = Date.now();\n      this.unavailableReadableLocations.push(location);\n    }\n  }\n\n  public async markCurrentLocationUnavailableForWrite(\n    diagnosticNode: DiagnosticNodeInternal,\n    endpoint: string,\n  ): Promise<void> {\n    await this.refreshEndpointList(diagnosticNode);\n    const location = this.writeableLocations.find(\n      (loc) => loc.databaseAccountEndpoint === endpoint,\n    );\n    if (location) {\n      location.unavailable = true;\n      location.lastUnavailabilityTimestampInMs = Date.now();\n      this.unavailableWriteableLocations.push(location);\n    }\n  }\n\n  public canUseMultipleWriteLocations(\n    resourceType?: ResourceType,\n    operationType?: OperationType,\n  ): boolean {\n    let canUse = this.options.connectionPolicy.useMultipleWriteLocations;\n\n    if (resourceType) {\n      canUse =\n        canUse &&\n        (resourceType === ResourceType.item ||\n          (resourceType === ResourceType.sproc && operationType === OperationType.Execute));\n    }\n\n    return canUse;\n  }\n\n  public async resolveServiceEndpoint(\n    diagnosticNode: DiagnosticNodeInternal,\n    resourceType: ResourceType,\n    operationType: OperationType,\n    startServiceEndpointIndex: number = 0, // Represents the starting index for selecting servers.\n  ): Promise<string> {\n    // If endpoint discovery is disabled, always use the user provided endpoint\n\n    if (!this.options.connectionPolicy.enableEndpointDiscovery) {\n      diagnosticNode.addData({ readFromCache: true }, \"default_endpoint\");\n      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);\n      return this.defaultEndpoint;\n    }\n\n    // If getting the database account, always use the user provided endpoint\n    if (resourceType === ResourceType.none) {\n      diagnosticNode.addData({ readFromCache: true }, \"none_resource\");\n      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);\n      return this.defaultEndpoint;\n    }\n\n    if (this.readableLocations.length === 0 || this.writeableLocations.length === 0) {\n      const resourceResponse = await withMetadataDiagnostics(\n        async (metadataNode: DiagnosticNodeInternal) => {\n          return this.readDatabaseAccount(metadataNode, {\n            urlConnection: this.defaultEndpoint,\n          });\n        },\n        diagnosticNode,\n        MetadataLookUpType.DatabaseAccountLookUp,\n      );\n\n      this.writeableLocations = resourceResponse.resource.writableLocations;\n      this.readableLocations = resourceResponse.resource.readableLocations;\n    }\n\n    const locations = isReadRequest(operationType)\n      ? this.readableLocations\n      : this.writeableLocations;\n\n    let location;\n    // If we have preferred locations, try each one in order and use the first available one\n    if (\n      this.preferredLocations &&\n      this.preferredLocations.length > 0 &&\n      startServiceEndpointIndex < this.preferredLocations.length\n    ) {\n      for (let i = startServiceEndpointIndex; i < this.preferredLocations.length; i++) {\n        const preferredLocation = this.preferredLocations[i];\n        location = locations.find(\n          (loc) =>\n            loc.unavailable !== true &&\n            normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation),\n        );\n        if (location) {\n          break;\n        }\n      }\n    }\n\n    // If no preferred locations or one did not match, just grab the first one that is available\n    if (!location) {\n      const startIndexValid =\n        startServiceEndpointIndex >= 0 && startServiceEndpointIndex < locations.length;\n      const locationsToSearch = startIndexValid\n        ? locations.slice(startServiceEndpointIndex)\n        : locations;\n      location = locationsToSearch.find((loc) => {\n        return loc.unavailable !== true;\n      });\n    }\n\n    location = location ? location : { name: \"\", databaseAccountEndpoint: this.defaultEndpoint };\n    diagnosticNode.recordEndpointResolution(location.databaseAccountEndpoint);\n    return location.databaseAccountEndpoint;\n  }\n\n  /**\n   * Refreshes the endpoint list by clearning stale unavailability and then\n   *  retrieving the writable and readable locations from the geo-replicated database account\n   *  and then updating the locations cache.\n   *  We skip the refreshing if enableEndpointDiscovery is set to False\n   */\n  public async refreshEndpointList(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (!this.isRefreshing && this.enableEndpointDiscovery) {\n      this.isRefreshing = true;\n      const databaseAccount = await this.getDatabaseAccountFromAnyEndpoint(diagnosticNode);\n      if (databaseAccount) {\n        this.refreshStaleUnavailableLocations();\n        this.refreshEndpoints(databaseAccount);\n      }\n      this.isRefreshing = false;\n    }\n  }\n\n  private refreshEndpoints(databaseAccount: DatabaseAccount): void {\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.writeableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.writeableLocations.push(location);\n      }\n    }\n    for (const location of databaseAccount.readableLocations) {\n      const existingLocation = this.readableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.readableLocations.push(location);\n      }\n    }\n  }\n\n  private refreshStaleUnavailableLocations(): void {\n    const now = Date.now();\n    this.updateLocation(now, this.unavailableReadableLocations, this.readableLocations);\n    this.unavailableReadableLocations = this.cleanUnavailableLocationList(\n      now,\n      this.unavailableReadableLocations,\n    );\n\n    this.updateLocation(now, this.unavailableWriteableLocations, this.writeableLocations);\n    this.unavailableWriteableLocations = this.cleanUnavailableLocationList(\n      now,\n      this.unavailableWriteableLocations,\n    );\n  }\n\n  /**\n   * update the locationUnavailability to undefined if the location is available again\n   * @param now - current time\n   * @param unavailableLocations - list of unavailable locations\n   * @param allLocations - list of all locations\n   */\n  private updateLocation(\n    now: number,\n    unavailableLocations: Location[],\n    allLocations: Location[],\n  ): void {\n    for (const location of unavailableLocations) {\n      const unavaialableLocation = allLocations.find((loc) => loc.name === location.name);\n      if (\n        unavaialableLocation &&\n        now - unavaialableLocation.lastUnavailabilityTimestampInMs >\n          Constants.LocationUnavailableExpirationTimeInMs\n      ) {\n        unavaialableLocation.unavailable = false;\n      }\n    }\n  }\n\n  private cleanUnavailableLocationList(now: number, unavailableLocations: Location[]): Location[] {\n    return unavailableLocations.filter((loc) => {\n      if (\n        loc &&\n        now - loc.lastUnavailabilityTimestampInMs >= Constants.LocationUnavailableExpirationTimeInMs\n      ) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Gets the database account first by using the default endpoint, and if that doesn't returns\n   * use the endpoints for the preferred locations in the order they are specified to get\n   * the database account.\n   */\n  private async getDatabaseAccountFromAnyEndpoint(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<DatabaseAccount> {\n    try {\n      const options = { urlConnection: this.defaultEndpoint };\n      const { resource: databaseAccount } = await this.readDatabaseAccount(diagnosticNode, options);\n      return databaseAccount;\n      // If for any reason(non - globaldb related), we are not able to get the database\n      // account from the above call to readDatabaseAccount,\n      // we would try to get this information from any of the preferred locations that the user\n      // might have specified (by creating a locational endpoint)\n      // and keeping eating the exception until we get the database account and return None at the end,\n      // if we are not able to get that info from any endpoints\n    } catch (err: any) {\n      // TODO: Tracing\n    }\n\n    if (this.preferredLocations) {\n      for (const location of this.preferredLocations) {\n        try {\n          const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(\n            this.defaultEndpoint,\n            location,\n          );\n          const options = { urlConnection: locationalEndpoint };\n          const { resource: databaseAccount } = await this.readDatabaseAccount(\n            diagnosticNode,\n            options,\n          );\n          if (databaseAccount) {\n            return databaseAccount;\n          }\n        } catch (err: any) {\n          // TODO: Tracing\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the locational endpoint using the location name passed to it using the default endpoint.\n   *\n   * @param defaultEndpoint - The default endpoint to use for the endpoint.\n   * @param locationName    - The location name for the azure region like \"East US\".\n   */\n  private static getLocationalEndpoint(defaultEndpoint: string, locationName: string): string {\n    // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\n    // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)\n    // and we agreed to document that\n    const endpointUrl = new URL(defaultEndpoint);\n\n    // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\n    if (endpointUrl.hostname) {\n      const hostnameParts = endpointUrl.hostname.toString().toLowerCase().split(\".\");\n      if (hostnameParts) {\n        // globalDatabaseAccountName will return 'contoso'\n        const globalDatabaseAccountName = hostnameParts[0];\n\n        // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\n        const locationalDatabaseAccountName =\n          globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\");\n\n        // Replace 'contoso' with 'contoso-EastUS' and\n        // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\n        const locationalEndpoint = defaultEndpoint\n          .toLowerCase()\n          .replace(globalDatabaseAccountName, locationalDatabaseAccountName);\n        return locationalEndpoint;\n      }\n    }\n\n    return null;\n  }\n}\n\nfunction normalizeEndpoint(endpoint: string): string {\n  return endpoint.split(\" \").join(\"\").toLowerCase();\n}\n"]}