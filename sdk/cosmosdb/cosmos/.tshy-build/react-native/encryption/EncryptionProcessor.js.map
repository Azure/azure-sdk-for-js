{"version":3,"file":"EncryptionProcessor.js","sourceRoot":"","sources":["../../../src/encryption/EncryptionProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { EncryptionSettings } from \"./EncryptionSettings.js\";\nimport type { EncryptionSettingForProperty } from \"./EncryptionSettingForProperty.js\";\nimport type { AeadAes256CbcHmacSha256Algorithm } from \"./AeadAes256CbcHmacSha256Algorithm/index.js\";\nimport type { ContainerDefinition, Database, ItemDefinition } from \"../client/index.js\";\nimport type { PartitionKeyInternal } from \"../documents/index.js\";\nimport type { TypeMarker } from \"./enums/TypeMarker.js\";\nimport type { ClientContext } from \"../ClientContext.js\";\nimport type { ClientEncryptionKeyRequest } from \"./ClientEncryptionKey/index.js\";\nimport type { ClientEncryptionKeyProperties } from \"./ClientEncryptionKey/index.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport {\n  Constants,\n  ResourceType,\n  StatusCodes,\n  createDeserializer,\n  createSerializer,\n  extractPath,\n} from \"../common/index.js\";\nimport type { RequestOptions } from \"../request/index.js\";\nimport { ErrorResponse } from \"../request/index.js\";\nimport { withDiagnostics } from \"../utils/diagnostics.js\";\nimport type { EncryptionManager } from \"./EncryptionManager.js\";\nimport type { JSONValue } from \"../queryExecutionContext/index.js\";\n\nexport class EncryptionProcessor {\n  constructor(\n    private readonly containerId: string,\n    public containerRid: string,\n    private readonly database: Database,\n    private readonly clientContext: ClientContext,\n    private encryptionManager: EncryptionManager,\n  ) {}\n\n  async encrypt<T extends ItemDefinition>(\n    body: T,\n  ): Promise<{ body: T; propertiesEncryptedCount: number }> {\n    if (!body) {\n      throw new ErrorResponse(\"Input body is null or undefined.\");\n    }\n    let propertiesEncryptedCount = 0;\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return { body, propertiesEncryptedCount };\n    for (const pathToEncrypt of encryptionSettings.pathsToEncrypt) {\n      const propertyName = pathToEncrypt.slice(1);\n      if (!Object.prototype.hasOwnProperty.call(body, propertyName)) {\n        continue;\n      }\n\n      const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(pathToEncrypt);\n      if (!settingForProperty) {\n        throw new ErrorResponse(\"Invalid Encryption Setting for the Property: \" + propertyName);\n      }\n      body[propertyName as keyof T] = await this.encryptToken(\n        body[propertyName],\n        settingForProperty,\n        propertyName === \"id\",\n      );\n      propertiesEncryptedCount++;\n    }\n    return { body, propertiesEncryptedCount };\n  }\n\n  async isPathEncrypted(path: string): Promise<boolean> {\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) return false;\n    return true;\n  }\n\n  async encryptProperty(path: string, value: JSONValue): Promise<any> {\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return value;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) {\n      return value;\n    }\n\n    value = await this.encryptToken(value, settingForProperty, path === \"/id\");\n    return value;\n  }\n\n  async getEncryptedPartitionKeyValue(\n    partitionKeyList: PartitionKeyInternal,\n  ): Promise<{ partitionKeyList: PartitionKeyInternal; encryptedCount: number }> {\n    const encryptionSettings = await this.getEncryptionSetting();\n    let encryptedCount = 0;\n    if (!encryptionSettings) return { partitionKeyList, encryptedCount };\n    const partitionKeyPaths = encryptionSettings.partitionKeyPaths;\n    for (let i = 0; i < partitionKeyPaths.length; i++) {\n      const partitionKeyPath = extractPath(partitionKeyPaths[i]);\n      if (encryptionSettings.pathsToEncrypt.includes(partitionKeyPath)) {\n        const settingForProperty =\n          encryptionSettings.getEncryptionSettingForProperty(partitionKeyPath);\n        partitionKeyList[i] = await this.encryptToken(\n          partitionKeyList[i],\n          settingForProperty,\n          partitionKeyPath === \"/id\",\n        );\n        encryptedCount++;\n      }\n    }\n    return { partitionKeyList, encryptedCount };\n  }\n\n  async getEncryptedUrl(id: string): Promise<string> {\n    const parts = id.split(\"/\");\n    const lastPart = parts[parts.length - 1];\n    const encryptedLastPart = await this.getEncryptedId(lastPart);\n    parts[parts.length - 1] = encryptedLastPart;\n    return parts.join(\"/\");\n  }\n\n  async getEncryptedId(id: string): Promise<string> {\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return id;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(\"/id\");\n\n    if (!settingForProperty) return id;\n    id = await this.encryptToken(id, settingForProperty, true);\n    return id;\n  }\n\n  async encryptQueryParameter(\n    path: string,\n    value: JSONValue,\n    isValueId: boolean,\n    type?: TypeMarker,\n  ): Promise<JSONValue> {\n    if (value === null) {\n      return value;\n    }\n    path = extractPath(path);\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return value;\n    const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(path);\n    if (!settingForProperty) {\n      return value;\n    }\n    return this.encryptToken(value, settingForProperty, isValueId, type);\n  }\n\n  private async encryptToken(\n    valueToEncrypt: any,\n    propertySetting: EncryptionSettingForProperty,\n    isValueId: boolean,\n    type?: TypeMarker,\n  ): Promise<any> {\n    if (typeof valueToEncrypt === \"object\" && valueToEncrypt !== null) {\n      for (const key in valueToEncrypt) {\n        if (Object.prototype.hasOwnProperty.call(valueToEncrypt, key)) {\n          valueToEncrypt[key] = await this.encryptToken(\n            valueToEncrypt[key],\n            propertySetting,\n            isValueId,\n            type,\n          );\n        }\n      }\n    } else if (Array.isArray(type)) {\n      for (let i = 0; i < valueToEncrypt.length; i++) {\n        valueToEncrypt[i] = await this.encryptToken(\n          valueToEncrypt[i],\n          propertySetting,\n          isValueId,\n          type,\n        );\n      }\n    } else {\n      valueToEncrypt = await this.serializeAndEncryptValue(\n        valueToEncrypt,\n        propertySetting,\n        isValueId,\n        type,\n      );\n    }\n    return valueToEncrypt;\n  }\n\n  private async serializeAndEncryptValue(\n    valueToEncrypt: any,\n    propertySetting: EncryptionSettingForProperty,\n    isValueId: boolean,\n    type?: TypeMarker,\n  ): Promise<string> {\n    if (valueToEncrypt === null) {\n      return valueToEncrypt;\n    }\n    const [typeMarker, serializer] = createSerializer(valueToEncrypt, type);\n    const plainText = serializer.serialize(valueToEncrypt);\n    const encryptionAlgorithm = await this.buildEncryptionAlgorithm(propertySetting);\n    const cipherText = encryptionAlgorithm.encrypt(plainText);\n    if (isValueId) {\n      if (typeof valueToEncrypt !== \"string\") {\n        throw new ErrorResponse(\"The id should be of string type.\");\n      }\n    }\n\n    const cipherTextWithTypeMarker = Buffer.alloc(cipherText.length + 1);\n    cipherTextWithTypeMarker[0] = typeMarker;\n    cipherText.forEach((value, index) => {\n      cipherTextWithTypeMarker[index + 1] = value;\n    });\n    let encryptedValue = Buffer.from(cipherTextWithTypeMarker).toString(\"base64\");\n    if (isValueId) {\n      encryptedValue = encryptedValue.replace(/\\//g, \"_\").replace(/\\+/g, \"-\");\n    }\n    return encryptedValue;\n  }\n\n  async decrypt<T extends ItemDefinition>(\n    body: T,\n  ): Promise<{ body: T; propertiesDecryptedCount: number }> {\n    let propertiesDecryptedCount = 0;\n    if (body == null) {\n      return { body, propertiesDecryptedCount };\n    }\n    const encryptionSettings = await this.getEncryptionSetting();\n    if (!encryptionSettings) return { body, propertiesDecryptedCount };\n    for (const pathToEncrypt of encryptionSettings.pathsToEncrypt) {\n      const propertyName = pathToEncrypt.slice(1);\n      if (!Object.prototype.hasOwnProperty.call(body, propertyName)) {\n        continue;\n      }\n      const settingForProperty = encryptionSettings.getEncryptionSettingForProperty(pathToEncrypt);\n      if (settingForProperty == null) {\n        throw new ErrorResponse(\"Invalid Encryption Setting for the Path: \" + pathToEncrypt);\n      }\n\n      body[propertyName as keyof T] = await this.decryptToken(\n        body[propertyName],\n        settingForProperty,\n        propertyName === \"id\",\n      );\n      propertiesDecryptedCount++;\n    }\n    return { body, propertiesDecryptedCount };\n  }\n\n  private async decryptToken(\n    valueToDecrypt: any,\n    propertySetting: EncryptionSettingForProperty,\n    isValueId: boolean,\n  ): Promise<any> {\n    if (typeof valueToDecrypt === \"object\") {\n      for (const key in valueToDecrypt) {\n        if (Object.prototype.hasOwnProperty.call(valueToDecrypt, key)) {\n          valueToDecrypt[key] = await this.decryptToken(\n            valueToDecrypt[key],\n            propertySetting,\n            isValueId,\n          );\n        }\n      }\n    } else if (Array.isArray(valueToDecrypt)) {\n      for (let i = 0; i < valueToDecrypt.length; i++) {\n        valueToDecrypt[i] = await this.decryptToken(valueToDecrypt[i], propertySetting, isValueId);\n      }\n    } else {\n      valueToDecrypt = await this.deserializeAndDecryptValue(\n        valueToDecrypt,\n        propertySetting,\n        isValueId,\n      );\n    }\n    return valueToDecrypt;\n  }\n\n  private async deserializeAndDecryptValue(\n    valueToDecrypt: string,\n    propertySetting: EncryptionSettingForProperty,\n    isValueId: boolean,\n  ): Promise<any> {\n    if (isValueId) {\n      valueToDecrypt = valueToDecrypt.replace(/_/g, \"/\").replace(/-/g, \"+\");\n    }\n    const cipherTextWithTypeMarker = Buffer.from(valueToDecrypt, \"base64\");\n    if (cipherTextWithTypeMarker === null) {\n      return null;\n    }\n\n    let cipherText = Buffer.alloc(cipherTextWithTypeMarker.length - 1);\n    cipherText = Buffer.from(cipherTextWithTypeMarker.slice(1));\n\n    const encryptionAlgorithm = await this.buildEncryptionAlgorithm(propertySetting);\n    const plainText = encryptionAlgorithm.decrypt(cipherText);\n    if (plainText === null) {\n      throw new ErrorResponse(\"returned null plain text\");\n    }\n\n    const serializer = createDeserializer(cipherTextWithTypeMarker[0] as TypeMarker);\n    return serializer.deserialize(plainText);\n  }\n\n  async getEncryptionSetting(forceRefresh?: boolean): Promise<EncryptionSettings> {\n    const key = this.database._rid + \"/\" + this.containerRid;\n    const encryptionSetting = this.encryptionManager.encryptionSettingsCache.get(key);\n    if (forceRefresh || !encryptionSetting) {\n      return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n        const path = `/dbs/${this.database.id}/colls/${this.containerId}`;\n        const id = `dbs/${this.database.id}/colls/${this.containerId}`;\n        const response = await this.clientContext.read<ContainerDefinition>({\n          path,\n          resourceType: ResourceType.container,\n          resourceId: id,\n          diagnosticNode,\n        });\n        if (!response || !response.result) {\n          throw new ErrorResponse(\"Failed to fetch container definition\");\n        }\n        const containerRid = response.result._rid;\n        const clientEncryptionPolicy = response.result.clientEncryptionPolicy;\n        const partitionKeyPaths = response.result.partitionKey.paths;\n        const updatedEncryptionSetting =\n          await this.encryptionManager.encryptionSettingsCache.create(\n            key,\n            containerRid,\n            partitionKeyPaths,\n            clientEncryptionPolicy,\n          );\n        return updatedEncryptionSetting;\n      }, this.clientContext);\n    }\n    return encryptionSetting;\n  }\n\n  private async buildEncryptionAlgorithm(\n    propertySetting: EncryptionSettingForProperty,\n  ): Promise<AeadAes256CbcHmacSha256Algorithm> {\n    const key = `${this.database._rid}/${propertySetting.encryptionKeyId}`;\n    let clientEncryptionKeyProperties =\n      this.encryptionManager.clientEncryptionKeyPropertiesCache.get(key);\n    if (!clientEncryptionKeyProperties) {\n      clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(\n        propertySetting.encryptionKeyId,\n      );\n    }\n    try {\n      // the buildEncryptionAlgorithm will build ProtectedDEK which calls unwrapKey  using the masterKey configured in\n      // KeyEncryptionKey(created before creating Protected DEK)\n      // we get wrapped key and key wrap metadata info from clientEncryptionKeyProperties.\n      return await propertySetting.buildEncryptionAlgorithm(\n        clientEncryptionKeyProperties,\n        this.encryptionManager,\n      );\n    } catch (err) {\n      if (err.statusCode !== StatusCodes.Forbidden) throw err;\n      // if access to key is revoked, and in case there's stale value in cache\n      clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(\n        propertySetting.encryptionKeyId,\n      );\n\n      try {\n        // This will succeed after if client has rewrapped CEK and gateway cache has updated value.\n        return await propertySetting.buildEncryptionAlgorithm(\n          clientEncryptionKeyProperties,\n          this.encryptionManager,\n          true,\n        );\n      } catch (retryErr) {\n        if (retryErr.statusCode !== StatusCodes.Forbidden) throw retryErr;\n\n        // in case there's stale value in gateway cache. get fresh value from backend\n        clientEncryptionKeyProperties = await this.fetchClientEncryptionKey(\n          propertySetting.encryptionKeyId,\n          clientEncryptionKeyProperties.etag,\n        );\n        return propertySetting.buildEncryptionAlgorithm(\n          clientEncryptionKeyProperties,\n          this.encryptionManager,\n        );\n      }\n    }\n  }\n\n  private async fetchClientEncryptionKey(\n    cekId: string,\n    cekEtag?: string,\n  ): Promise<ClientEncryptionKeyProperties> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = `/dbs/${this.database.id}/clientencryptionkeys/${cekId}`;\n      const id = `dbs/${this.database.id}/clientencryptionkeys/${cekId}`;\n      const options: RequestOptions = {};\n      if (cekEtag) {\n        options.accessCondition = {\n          type: Constants.HttpHeaders.IfNoneMatch,\n          condition: cekEtag,\n        };\n      }\n      options.databaseRid = this.database._rid;\n      const response = await this.clientContext.read<ClientEncryptionKeyRequest>({\n        path: path,\n        resourceType: ResourceType.clientencryptionkey,\n        resourceId: id,\n        options: options,\n        diagnosticNode,\n      });\n      if (!response) {\n        throw new ErrorResponse(`Failed to fetch client encryption key ${cekId}`);\n      }\n      if (response.code === StatusCodes.NotModified) {\n        throw new ErrorResponse(\n          `The Client Encryption Key with key id: ${cekId} on database: ${this.database.id} needs to be rewrapped with a valid Key Encryption Key using rewrapClientEncryptionKey. The Key Encryption Key used to wrap the Client Encryption Key has been revoked`,\n        );\n      }\n      const clientEncryptionKeyProperties: ClientEncryptionKeyProperties = {\n        id: response.result.id,\n        encryptionAlgorithm: response.result.encryptionAlgorithm,\n        wrappedDataEncryptionKey: new Uint8Array(\n          Buffer.from(response.result.wrappedDataEncryptionKey, \"base64\"),\n        ),\n        encryptionKeyWrapMetadata: response.result.keyWrapMetadata,\n        etag: response.result._etag,\n      };\n      const key = this.database._rid + \"/\" + cekId;\n      this.encryptionManager.clientEncryptionKeyPropertiesCache.set(\n        key,\n        clientEncryptionKeyProperties,\n      );\n      return clientEncryptionKeyProperties;\n    }, this.clientContext);\n  }\n}\n"]}