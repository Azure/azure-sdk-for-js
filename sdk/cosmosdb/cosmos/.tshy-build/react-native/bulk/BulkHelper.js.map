{"version":3,"file":"BulkHelper.js","sourceRoot":"","sources":["../../../src/bulk/BulkHelper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { RequestOptions } from \"../request/RequestOptions.js\";\nimport { readPartitionKeyDefinition } from \"../client/ClientUtils.js\";\nimport type { Container } from \"../client/index.js\";\nimport type { ClientContext } from \"../ClientContext.js\";\nimport { Constants, ResourceType } from \"../common/constants.js\";\nimport { sleep, copyObject, getPathFromLink } from \"../common/helper.js\";\nimport { StatusCodes } from \"../common/statusCodes.js\";\nimport {\n  DiagnosticNodeInternal,\n  DiagnosticNodeType,\n} from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport type { PartitionKeyDefinition } from \"../documents/PartitionKeyDefinition.js\";\nimport { convertToInternalPartitionKey } from \"../documents/PartitionKeyInternal.js\";\nimport { ErrorResponse } from \"../index.js\";\nimport { BulkExecutionRetryPolicy } from \"../retry/bulkExecutionRetryPolicy.js\";\nimport { ResourceThrottleRetryPolicy } from \"../retry/resourceThrottleRetryPolicy.js\";\nimport type { RetryPolicy } from \"../retry/RetryPolicy.js\";\nimport type { PartitionKeyRangeCache } from \"../routing/partitionKeyRangeCache.js\";\nimport type { BulkOperationResult, OperationInput, Operation } from \"../utils/batch.js\";\nimport { encryptOperationInput, isKeyInRange } from \"../utils/batch.js\";\nimport { addDiagnosticChild } from \"../utils/diagnostics.js\";\nimport { hashPartitionKey } from \"../utils/hashing/hash.js\";\nimport { HelperPerPartition } from \"./HelperPerPartition.js\";\nimport type { ItemOperation } from \"./index.js\";\nimport { ItemOperationContext, BulkResponse } from \"./index.js\";\n\n/**\n * BulkHelper for bulk operations in a container.\n * It maintains one @see {@link HelperPerPartition} for each Partition Key Range, which allows independent execution of requests. Queue based limiters @see {@link LimiterQueue}\n * rate limit requestsbat the helper / Partition Key Range level, this means that we can send parallel and independent requests to different Partition Key Ranges, but for the same Range, requests\n * will be limited. Two callback implementations define how a particular request should be executed, and how operations should be retried. When the helper dispatches a batch\n * the batch will create a request and call the execute callback (executeRequest), if conditions are met, it might call the retry callback (reBatchOperation).\n * @hidden\n */\n\nexport class BulkHelper {\n  private readonly container: Container;\n  private readonly clientContext: ClientContext;\n  private readonly partitionKeyRangeCache: PartitionKeyRangeCache;\n  private readonly helpersByPartitionKeyRangeId: Map<string, HelperPerPartition>;\n  private options: RequestOptions;\n  private partitionKeyDefinition: PartitionKeyDefinition;\n  private partitionKeyDefinitionPromise: Promise<PartitionKeyDefinition>;\n  private isCancelled: boolean;\n  private processedOperationCountRef: { count: number } = { count: 0 };\n  private operationPromisesList: Promise<BulkOperationResult>[] = [];\n  private congestionControlTimer: NodeJS.Timeout;\n  private readonly congestionControlDelayInMs: number = 1000;\n  private staleRidError: ErrorResponse | undefined;\n  private readonly operationsPerSleep: number = 100; // Number of operations to add per sleep\n  private readonly intervalForPartialBatchInMs: number = 1000; // Sleep interval before adding partial batch to dispatch queue\n\n  /**\n   * @internal\n   */\n  constructor(\n    container: Container,\n    clientContext: ClientContext,\n    partitionKeyRangeCache: PartitionKeyRangeCache,\n    options: RequestOptions,\n  ) {\n    this.container = container;\n    this.clientContext = clientContext;\n    this.partitionKeyRangeCache = partitionKeyRangeCache;\n    this.helpersByPartitionKeyRangeId = new Map();\n    this.options = options;\n    this.executeRequest = this.executeRequest.bind(this);\n    this.reBatchOperation = this.reBatchOperation.bind(this);\n    this.refreshPartitionKeyRangeCache = this.refreshPartitionKeyRangeCache.bind(this);\n    this.isCancelled = false;\n    this.runCongestionControlTimer();\n  }\n\n  /**\n   * adds operation(s) to the helper\n   * @param operationInput - bulk operation or list of bulk operations\n   */\n  async execute(operationInput: OperationInput[]): Promise<BulkOperationResult[]> {\n    const addOperationPromises: Promise<void>[] = [];\n    const minimalPause = 0; // minimal pause (0 ms) inserted periodically during processing.\n    try {\n      for (let i = 0; i < operationInput.length; i++) {\n        // After every 100 operations,sleep of 0 ms is added to allow the event loop to process any pending\n        // callbacks/tasks such as fetching partition key definition and dispatching batches from queue. This helps\n        // to prevent blocking and improves overall responsiveness.\n        if (i % this.operationsPerSleep === 0) {\n          await sleep(minimalPause);\n        }\n        addOperationPromises.push(this.addOperation(operationInput[i], i));\n      }\n      await Promise.allSettled(addOperationPromises);\n\n      // After processing all operations via addOperation, it's possible that the current batch in each helper is not completely full.\n      // In such cases, addPartialBatchToQueue is called to ensure that all the operations are added to the dispatch queue.\n      // while loop below waits until the count of processed operations equals the number of input operations. This is necessary because\n      // some operations might fail and then again get added to current batch for retry.\n      while (this.processedOperationCountRef.count < operationInput.length) {\n        this.helpersByPartitionKeyRangeId.forEach((helper) => {\n          helper.addPartialBatchToQueue();\n        });\n        // Pause for 1000 ms to give pending operations chance to accumulate into a batch to avoid sending multiple small batches.\n        await sleep(this.intervalForPartialBatchInMs);\n      }\n    } finally {\n      if (this.congestionControlTimer) {\n        clearInterval(this.congestionControlTimer);\n      }\n    }\n    const settledResults = await Promise.allSettled(this.operationPromisesList);\n    if (this.isCancelled && this.staleRidError) {\n      throw this.staleRidError;\n    }\n\n    const bulkOperationResults = settledResults.map((result) =>\n      result.status === \"fulfilled\" ? result.value : result.reason,\n    );\n\n    // Formatting result: if an error is present, removing the stack trace details.\n    const formattedResults = bulkOperationResults.map((result) => {\n      if (result && result.error) {\n        const { stack, ...otherProps } = result.error;\n        const trimmedError = { message: result.error.message, ...otherProps };\n        return {\n          ...result,\n          error: trimmedError,\n        };\n      }\n      return result;\n    });\n    return formattedResults;\n  }\n\n  private async addOperation(operation: OperationInput, idx: number): Promise<void> {\n    if (this.isCancelled) {\n      return;\n    }\n    if (!operation) {\n      this.operationPromisesList[idx] = Promise.resolve({\n        operationInput: operation,\n        error: Object.assign(new ErrorResponse(\"Operation cannot be null or undefined.\"), {\n          code: StatusCodes.InternalServerError,\n        }),\n      });\n      return;\n    }\n\n    // Checks for id and partition key in input body\n    if (\n      operation.operationType === \"Create\" ||\n      operation.operationType === \"Upsert\" ||\n      operation.operationType === \"Replace\"\n    ) {\n      if (!operation.resourceBody.id) {\n        this.operationPromisesList[idx] = Promise.resolve({\n          operationInput: operation,\n          error: Object.assign(\n            new ErrorResponse(\n              `Operation resource body must have an 'id' for ${operation.operationType} operations.`,\n            ),\n            { code: StatusCodes.InternalServerError },\n          ),\n        });\n        this.processedOperationCountRef.count++;\n        return;\n      }\n    }\n    if (operation.partitionKey === undefined) {\n      this.operationPromisesList[idx] = Promise.resolve({\n        operationInput: operation,\n        error: Object.assign(\n          new ErrorResponse(`PartitionKey is required for ${operation.operationType} operations.`),\n          { code: StatusCodes.InternalServerError },\n        ),\n      });\n      this.processedOperationCountRef.count++;\n      return;\n    }\n\n    let operationError: Error | undefined;\n    let diagnosticNode: DiagnosticNodeInternal;\n    let unencryptedOperation: OperationInput;\n    let partitionKeyRangeId: string;\n    try {\n      diagnosticNode = new DiagnosticNodeInternal(\n        this.clientContext.diagnosticLevel,\n        DiagnosticNodeType.CLIENT_REQUEST_NODE,\n        null,\n      );\n      // Ensure partition key definition is available.\n      if (!this.partitionKeyDefinition) {\n        if (!this.partitionKeyDefinitionPromise) {\n          this.partitionKeyDefinitionPromise = (async () => {\n            try {\n              const partitionKeyDefinition = await readPartitionKeyDefinition(\n                diagnosticNode,\n                this.container,\n              );\n              this.partitionKeyDefinition = partitionKeyDefinition;\n              return partitionKeyDefinition;\n            } finally {\n              this.partitionKeyDefinitionPromise = null;\n            }\n          })();\n        }\n        await this.partitionKeyDefinitionPromise;\n      }\n      unencryptedOperation = copyObject(operation);\n      // If encryption is enabled, encrypt the operation input.\n      if (this.clientContext.enableEncryption) {\n        operation = copyObject(operation);\n        await this.container.checkAndInitializeEncryption();\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n        const { operation: encryptedOp, totalPropertiesEncryptedCount } =\n          await encryptOperationInput(this.container.encryptionProcessor, operation, 0);\n        operation = encryptedOp;\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsEncryptOperation,\n          totalPropertiesEncryptedCount,\n        );\n      }\n      // Resolve the partition key range id.\n      partitionKeyRangeId = await this.resolvePartitionKeyRangeId(operation, diagnosticNode);\n    } catch (error) {\n      operationError = error;\n    }\n\n    // Get helper & context.\n    const helperForPartition = this.getHelperForPKRange(partitionKeyRangeId);\n    const retryPolicy = this.getRetryPolicy();\n    const context = new ItemOperationContext(partitionKeyRangeId, retryPolicy, diagnosticNode);\n    const itemOperation: ItemOperation = {\n      unencryptedOperationInput: unencryptedOperation,\n      operationInput: operation,\n      operationContext: context,\n    };\n\n    // Assign the promise (ensuring position matches input order)\n    this.operationPromisesList[idx] = context.operationPromise;\n\n    if (operationError) {\n      const response: BulkOperationResult = {\n        operationInput: unencryptedOperation,\n        error: Object.assign(new ErrorResponse(operationError.message), {\n          code: StatusCodes.InternalServerError,\n          diagnostics: diagnosticNode?.toDiagnostic(this.clientContext.getClientConfig()),\n        }),\n      };\n      context.fail(response);\n      this.processedOperationCountRef.count++;\n      return;\n    }\n    // Add the operation to the helper.\n    return helperForPartition.add(itemOperation);\n  }\n\n  private async resolvePartitionKeyRangeId(\n    operation: OperationInput,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<string> {\n    const partitionKeyRanges = (\n      await this.partitionKeyRangeCache.onCollectionRoutingMap(this.container.url, diagnosticNode)\n    ).getOrderedParitionKeyRanges();\n\n    const partitionKey = convertToInternalPartitionKey(operation.partitionKey);\n\n    const hashedKey = hashPartitionKey(partitionKey, this.partitionKeyDefinition);\n\n    const matchingRange = partitionKeyRanges.find((range) =>\n      isKeyInRange(range.minInclusive, range.maxExclusive, hashedKey),\n    );\n\n    if (!matchingRange) {\n      throw new Error(\"No matching partition key range found for the operation.\");\n    }\n    return matchingRange.id;\n  }\n\n  private getRetryPolicy(): RetryPolicy {\n    const nextRetryPolicy = new ResourceThrottleRetryPolicy(this.clientContext.getRetryOptions());\n    return new BulkExecutionRetryPolicy(nextRetryPolicy);\n  }\n\n  private async executeRequest(\n    operations: ItemOperation[],\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<BulkResponse> {\n    if (this.isCancelled) {\n      throw new ErrorResponse(\"Bulk execution cancelled due to a previous error.\");\n    }\n    if (!operations.length) return;\n    const pkRangeId = operations[0].operationContext.pkRangeId;\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const requestBody: Operation[] = [];\n    for (const itemOperation of operations) {\n      requestBody.push(this.prepareOperation(itemOperation.operationInput));\n    }\n    if (!this.options.containerRid) {\n      this.options.containerRid = this.container._rid;\n    }\n    try {\n      const response = await addDiagnosticChild(\n        async (childNode: DiagnosticNodeInternal) =>\n          this.clientContext.bulk({\n            body: requestBody,\n            partitionKeyRangeId: pkRangeId,\n            path: path,\n            resourceId: this.container.url,\n            options: this.options,\n            diagnosticNode: childNode,\n          }),\n        diagnosticNode,\n        DiagnosticNodeType.BATCH_REQUEST,\n      );\n      if (!response) {\n        throw new ErrorResponse(\"Failed to fetch bulk response.\");\n      }\n      return BulkResponse.fromResponseMessage(response, operations);\n    } catch (error) {\n      if (this.clientContext.enableEncryption) {\n        try {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        } catch (err) {\n          await this.cancelExecution(err);\n          return BulkResponse.createEmptyResponse(operations, 0, 0, {});\n        }\n      }\n      return BulkResponse.fromResponseMessage(error, operations);\n    }\n  }\n\n  private prepareOperation(operationInput: OperationInput): Operation {\n    operationInput.partitionKey = convertToInternalPartitionKey(operationInput.partitionKey);\n    return {\n      ...operationInput,\n      partitionKey: JSON.stringify(operationInput.partitionKey),\n    } as Operation;\n  }\n\n  private async reBatchOperation(\n    operation: ItemOperation,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<void> {\n    const partitionKeyRangeId = await this.resolvePartitionKeyRangeId(\n      operation.operationInput,\n      diagnosticNode,\n    );\n    operation.operationContext.updatePKRangeId(partitionKeyRangeId);\n    const helper = this.getHelperForPKRange(partitionKeyRangeId);\n    await helper.add(operation);\n  }\n\n  private async cancelExecution(error: ErrorResponse): Promise<void> {\n    this.isCancelled = true;\n    this.staleRidError = error;\n    for (const helper of this.helpersByPartitionKeyRangeId.values()) {\n      await helper.dispose();\n    }\n    this.helpersByPartitionKeyRangeId.clear();\n  }\n\n  private getHelperForPKRange(pkRangeId: string): HelperPerPartition {\n    if (this.helpersByPartitionKeyRangeId.has(pkRangeId)) {\n      return this.helpersByPartitionKeyRangeId.get(pkRangeId);\n    }\n\n    const newHelper = new HelperPerPartition(\n      this.executeRequest,\n      this.reBatchOperation,\n      this.refreshPartitionKeyRangeCache,\n      this.clientContext.diagnosticLevel,\n      this.clientContext.enableEncryption,\n      this.clientContext.getClientConfig(),\n      this.container.encryptionProcessor,\n      this.processedOperationCountRef,\n    );\n    this.helpersByPartitionKeyRangeId.set(pkRangeId, newHelper);\n    return newHelper;\n  }\n\n  private runCongestionControlTimer(): void {\n    this.congestionControlTimer = setInterval(() => {\n      this.helpersByPartitionKeyRangeId.forEach((helper) => {\n        helper.runCongestionAlgorithm();\n      });\n    }, this.congestionControlDelayInMs);\n  }\n\n  private async refreshPartitionKeyRangeCache(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<void> {\n    await this.partitionKeyRangeCache.onCollectionRoutingMap(\n      this.container.url,\n      diagnosticNode,\n      true,\n    );\n  }\n}\n"]}