{"version":3,"file":"FeedOptions.js","sourceRoot":"","sources":["../../../src/request/FeedOptions.ts"],"names":[],"mappings":"","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { PartitionKey } from \"../documents/index.js\";\nimport type { SharedOptions } from \"./SharedOptions.js\";\n\n/**\n * The feed options and query methods.\n */\nexport interface FeedOptions extends SharedOptions {\n  /** Opaque token for continuing the enumeration. Default: undefined\n   * @deprecated Use continuationToken instead.\n   */\n  continuation?: string;\n  /** Opaque token for continuing the enumeration. Default: undefined */\n  continuationToken?: string;\n  /**\n   * Limits the size of the continuation token in the response. Default: undefined\n   *\n   * Continuation Tokens contain optional data that can be removed from the serialization before writing it out to a header.\n   * By default we are capping this to 1kb to avoid long headers (Node.js has a global header size limit).\n   * A user may set this field to allow for longer headers, which can help the backend optimize query execution.\"\n   */\n  continuationTokenLimitInKB?: number;\n  /**\n   * Allow scan on the queries which couldn't be served as indexing was opted out on the requested paths. Default: false\n   *\n   * In general, it is best to avoid using this setting. Scans are relatively expensive and take a long time to serve.\n   */\n  enableScanInQuery?: boolean;\n  /**\n   * The maximum number of concurrent operations that run client side during parallel query execution in the\n   * Azure Cosmos DB database service. Negative values make the system automatically decides the number of\n   * concurrent operations to run. Default: 0 (no parallelism)\n   */\n  maxDegreeOfParallelism?: number;\n  /**\n   * Max number of items to be returned in the enumeration operation. Default: undefined (server will defined payload)\n   *\n   * Expirimenting with this value can usually result in the biggest performance changes to the query.\n   *\n   * The smaller the item count, the faster the first result will be delivered (for non-aggregates). For larger amounts,\n   * it will take longer to serve the request, but you'll usually get better throughput for large queries (i.e. if you need 1000 items\n   * before you can do any other actions, set `maxItemCount` to 1000. If you can start doing work after the first 100, set `maxItemCount` to 100.)\n   */\n  maxItemCount?: number;\n  /**\n   * Note: consider using changeFeed instead.\n   *\n   * Indicates a change feed request. Must be set to \"Incremental feed\", or omitted otherwise. Default: false\n   */\n  useIncrementalFeed?: boolean;\n  /**\n   * @internal\n   * Indicates a change feed request in latestVersion mode.\n   * Note: Not to be used directly. Use `ChangeFeedMode` instead to set the mode.\n   */\n  useLatestVersionFeed?: boolean;\n  /**\n   * @internal\n   * Indicates a change feed request in allVersionsAndDelete mode. Default false.\n   * Note: Not to be used directly. Use `ChangeFeedMode` instead to set the mode.\n   */\n  useAllVersionsAndDeletesFeed?: boolean;\n  /** Conditions Associated with the request. */\n  accessCondition?: {\n    /** Conditional HTTP method header type (IfMatch or IfNoneMatch). */\n    type: string;\n    /** Conditional HTTP method header value (the _etag field from the last version you read). */\n    condition: string;\n  };\n  /**\n   * Enable returning query metrics in response headers. Default: false\n   *\n   * Used for debugging slow or expensive queries. Also increases response size and if you're using a low max header size in Node.js,\n   * you can run into issues faster.\n   */\n  populateQueryMetrics?: boolean;\n  /**\n   * Enable buffering additional items during queries. Default: false\n   *\n   * This will buffer an additional page at a time (multiplied by maxDegreeOfParallelism) from the server in the background.\n   * This improves latency by fetching pages before they are needed by the client. If you're draining all of the results from the\n   * server, like `.fetchAll`, you should usually enable this. If you're only fetching one page at a time via continuation token,\n   * you should avoid this. If you're draining more than one page, but not the entire result set, it may help improve latency, but\n   * it will increase the total amount of RU/s use to serve the entire query (as some pages will be fetched more than once).\n   */\n  bufferItems?: boolean;\n  /**\n   * This setting forces the query to use a query plan. Default: false\n   *\n   * Note: this will disable continuation token support, even for single partition queries.\n   *\n   * For queries like aggregates and most cross partition queries, this happens anyway.\n   * However, since the library doesn't know what type of query it is until we get back the first response,\n   * some optimization can't happen until later.\n   *\n   * If this setting is enabled, it will force query plan for the query, which will save some network requests\n   * and ensure parallelism can happen. Useful for when you know you're doing cross-partition or aggregate queries.\n   */\n  forceQueryPlan?: boolean;\n  /** Limits the query to a specific partition key. Default: undefined\n   *\n   *  Scoping a query to a single partition can be accomplished two ways:\n   *\n   * `container.items.query('SELECT * from c', { partitionKey: \"foo\" }).toArray()`\n   * `container.items.query('SELECT * from c WHERE c.yourPartitionKey = \"foo\"').toArray()`\n   *\n   * The former is useful when the query body is out of your control\n   * but you still want to restrict it to a single partition. Example: an end user specified query.\n   */\n  partitionKey?: PartitionKey;\n  /**\n   * Enable returning index metrics in response headers. Default: false\n   */\n  populateIndexMetrics?: boolean;\n  /**\n   * Specifies a custom maximum buffer size for storing final results for nonStreamingOrderBy queries.\n   * This value is ignored if the query includes top/offset+limit clauses.\n   */\n  vectorSearchBufferSize?: number;\n  /**\n   * Disable the nonStreamingOrderBy query feature in supported query features.\n   * Default: false. Set to true to avoid error from an old gateway that doesn't support this feature.\n   */\n  disableNonStreamingOrderByQuery?: boolean;\n  /**\n   * Valid only for non streaming order by query.\n   * Default: false; When set to true, it allows queries to bypass the default behavior that blocks nonStreaming queries without top or limit clauses.\n   */\n  allowUnboundedNonStreamingQueries?: boolean;\n  /**\n   * Controls query execution behavior.\n   * Default: false. If set to false, the query will retry until results are ready and `maxItemCount` is reached, which can take time for large partitions with relatively small data.\n   * If set to true, scans partitions up to `maxDegreeOfParallelism`, adds results to the buffer, and returns what is available. If results are not ready, it returns an empty response.\n   */\n  enableQueryControl?: boolean;\n  /**\n   * Default: false. If set to true, it disables the hybrid search query plan optimization.\n   * This optimization is enabled by default and is used to improve the performance of hybrid search queries.\n   */\n  disableHybridSearchQueryPlanOptimization?: boolean;\n  /**\n   * @internal\n   * rid of the container.\n   */\n  containerRid?: string;\n}\n"]}