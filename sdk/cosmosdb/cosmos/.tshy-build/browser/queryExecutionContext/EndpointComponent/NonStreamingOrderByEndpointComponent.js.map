{"version":3,"file":"NonStreamingOrderByEndpointComponent.js","sourceRoot":"","sources":["../../../../src/queryExecutionContext/EndpointComponent/NonStreamingOrderByEndpointComponent.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal.js\";\nimport type { Response } from \"../../request/index.js\";\nimport type { ExecutionContext } from \"../ExecutionContext.js\";\nimport { OrderByComparator } from \"../orderByComparator.js\";\nimport type { NonStreamingOrderByResult } from \"../nonStreamingOrderByResult.js\";\nimport { FixedSizePriorityQueue } from \"../../utils/fixedSizePriorityQueue.js\";\nimport type { CosmosHeaders } from \"../headerUtils.js\";\nimport { getInitialHeader } from \"../headerUtils.js\";\n\n/**\n * @hidden\n * Represents an endpoint in handling an non-streaming order by query.\n */\nexport class NonStreamingOrderByEndpointComponent implements ExecutionContext {\n  /**\n   * A priority queue to store the final sorted results.\n   */\n  private nonStreamingOrderByPQ: FixedSizePriorityQueue<NonStreamingOrderByResult>;\n  /**\n   * Flag to determine if all results are fetched from backend and results can be returned from priority queue.\n   */\n  private isCompleted: boolean = false;\n  /**\n   * Represents an endpoint in handling an non-streaming order by query. For each processed orderby\n   * result it returns 'payload' item of the result\n   *\n   * @param executionContext - Underlying Execution Context\n   * @hidden\n   */\n  constructor(\n    private executionContext: ExecutionContext,\n    private sortOrders: any[],\n    private priorityQueueBufferSize: number,\n    private offset: number = 0,\n    private emitRawOrderByPayload: boolean = false,\n  ) {\n    const comparator = new OrderByComparator(this.sortOrders);\n    this.nonStreamingOrderByPQ = new FixedSizePriorityQueue<NonStreamingOrderByResult>(\n      (a: NonStreamingOrderByResult, b: NonStreamingOrderByResult) => {\n        return comparator.compareItems(b, a);\n      },\n      this.priorityQueueBufferSize,\n    );\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs.\n   * @returns true if there is other elements to process in the NonStreamingOrderByEndpointComponent.\n   */\n  public hasMoreResults(): boolean {\n    return this.priorityQueueBufferSize > 0 && this.executionContext.hasMoreResults();\n  }\n\n  /**\n   * Fetches the next batch of the result from the target container.\n   * @param diagnosticNode - The diagnostic information for the request.\n   */\n  public async fetchMore(diagnosticNode?: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.isCompleted) {\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n    let resHeaders = getInitialHeader();\n    // if size is 0, just return undefined to signal to more results. Valid if query is TOP 0 or LIMIT 0\n    if (this.priorityQueueBufferSize <= 0) {\n      return {\n        result: undefined,\n        headers: resHeaders,\n      };\n    }\n    // If there are more results in backend, keep filling pq.\n    if (this.executionContext.hasMoreResults()) {\n      const response = await this.executionContext.fetchMore(diagnosticNode);\n      resHeaders = response.headers;\n      if (response === undefined || response.result === undefined) {\n        this.isCompleted = true;\n        if (!this.nonStreamingOrderByPQ.isEmpty()) {\n          return this.buildFinalResultArray(resHeaders);\n        }\n        return { result: undefined, headers: resHeaders };\n      }\n\n      for (const item of response.result) {\n        if (item !== undefined) {\n          this.nonStreamingOrderByPQ.enqueue(item);\n        }\n      }\n    }\n\n    // If the backend has more results to fetch, return [] to signal that there are more results to fetch.\n    if (this.executionContext.hasMoreResults()) {\n      return {\n        result: [],\n        headers: resHeaders,\n      };\n    }\n\n    // If all results are fetched from backend, prepare final results\n    if (!this.executionContext.hasMoreResults() && !this.isCompleted) {\n      this.isCompleted = true;\n      return this.buildFinalResultArray(resHeaders);\n    }\n\n    // If pq is empty, return undefined to signal that there are no more results.\n    return {\n      result: undefined,\n      headers: resHeaders,\n    };\n  }\n\n  private async buildFinalResultArray(resHeaders: CosmosHeaders): Promise<Response<any>> {\n    // Set isCompleted to true.\n    this.isCompleted = true;\n    // Reverse the priority queue to get the results in the correct order\n    this.nonStreamingOrderByPQ = this.nonStreamingOrderByPQ.reverse();\n    // For offset limit case we set the size of priority queue to offset + limit\n    // and we drain offset number of items from the priority queue\n    while (\n      this.offset < this.priorityQueueBufferSize &&\n      this.offset > 0 &&\n      !this.nonStreamingOrderByPQ.isEmpty()\n    ) {\n      this.nonStreamingOrderByPQ.dequeue();\n      this.offset--;\n    }\n\n    // If pq is not empty, return the result from pq.\n    if (!this.nonStreamingOrderByPQ.isEmpty()) {\n      const buffer: any[] = [];\n      if (this.emitRawOrderByPayload) {\n        while (!this.nonStreamingOrderByPQ.isEmpty()) {\n          buffer.push(this.nonStreamingOrderByPQ.dequeue());\n        }\n      } else {\n        while (!this.nonStreamingOrderByPQ.isEmpty()) {\n          buffer.push(this.nonStreamingOrderByPQ.dequeue()?.payload);\n        }\n      }\n      return {\n        result: buffer,\n        headers: resHeaders,\n      };\n    }\n  }\n}\n"]}