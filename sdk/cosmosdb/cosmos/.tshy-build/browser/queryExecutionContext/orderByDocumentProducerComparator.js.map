{"version":3,"file":"orderByDocumentProducerComparator.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/orderByDocumentProducerComparator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DocumentProducer } from \"./documentProducer.js\";\n\n// TODO: this smells funny\n/** @hidden */\nconst TYPEORDCOMPARATOR: {\n  [type: string]: { ord: number; compFunc?: (a: any, b: any) => number };\n} = Object.freeze({\n  NoValue: {\n    ord: 0,\n  },\n  undefined: {\n    ord: 1,\n  },\n  boolean: {\n    ord: 2,\n    compFunc: (a: boolean, b: boolean) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n  number: {\n    ord: 4,\n    compFunc: (a: number, b: number) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n  string: {\n    ord: 5,\n    compFunc: (a: string, b: string) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n});\n\n/** @hidden */\nexport class OrderByDocumentProducerComparator {\n  constructor(public sortOrder: string[]) {} // TODO: This should be an enum\n\n  private targetPartitionKeyRangeDocProdComparator(\n    docProd1: DocumentProducer,\n    docProd2: DocumentProducer,\n  ): 0 | 1 | -1 {\n    const a = docProd1.getTargetParitionKeyRange()[\"minInclusive\"];\n    const b = docProd2.getTargetParitionKeyRange()[\"minInclusive\"];\n    return a === b ? 0 : a > b ? 1 : -1;\n  }\n\n  public compare(docProd1: DocumentProducer, docProd2: DocumentProducer): number {\n    // Need to check for split, since we don't want to dereference \"item\" of undefined / exception\n    if (docProd1.gotSplit()) {\n      return -1;\n    }\n    if (docProd2.gotSplit()) {\n      return 1;\n    }\n\n    const orderByItemsRes1 = this.getOrderByItems(docProd1.peekBufferedItems()[0]);\n    const orderByItemsRes2 = this.getOrderByItems(docProd2.peekBufferedItems()[0]);\n\n    // validate order by items and types\n    // TODO: once V1 order by on different types is fixed this need to change\n    this.validateOrderByItems(orderByItemsRes1, orderByItemsRes2);\n\n    // no async call in the for loop\n    for (let i = 0; i < orderByItemsRes1.length; i++) {\n      // compares the orderby items one by one\n      const compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);\n      if (compRes !== 0) {\n        if (this.sortOrder[i] === \"Ascending\") {\n          return compRes;\n        } else if (this.sortOrder[i] === \"Descending\") {\n          return -compRes;\n        }\n      }\n    }\n\n    return this.targetPartitionKeyRangeDocProdComparator(docProd1, docProd2);\n  }\n\n  // TODO: This smells funny\n  public compareValue(item1: unknown, type1: string, item2: unknown, type2: string): number {\n    if (type1 === \"object\" || type2 === \"object\") {\n      throw new Error(\"Tried to compare an object type\");\n    }\n    const type1Ord = TYPEORDCOMPARATOR[type1].ord;\n    const type2Ord = TYPEORDCOMPARATOR[type2].ord;\n    const typeCmp = type1Ord - type2Ord;\n\n    if (typeCmp !== 0) {\n      // if the types are different, use type ordinal\n      return typeCmp;\n    }\n\n    // both are of the same type\n    if (\n      type1Ord === TYPEORDCOMPARATOR[\"undefined\"].ord ||\n      type1Ord === TYPEORDCOMPARATOR[\"NoValue\"].ord\n    ) {\n      // if both types are undefined or Null they are equal\n      return 0;\n    }\n\n    const compFunc = TYPEORDCOMPARATOR[type1].compFunc;\n    if (typeof compFunc === \"undefined\") {\n      throw new Error(\"Cannot find the comparison function\");\n    }\n    // same type and type is defined compare the items\n    return compFunc(item1, item2);\n  }\n\n  private compareOrderByItem(orderByItem1: any, orderByItem2: any): number {\n    const type1 = this.getType(orderByItem1);\n    const type2 = this.getType(orderByItem2);\n    return this.compareValue(orderByItem1[\"item\"], type1, orderByItem2[\"item\"], type2);\n  }\n\n  private validateOrderByItems(res1: string[], res2: string[]): void {\n    if (res1.length !== res2.length) {\n      throw new Error(`Expected ${res1.length}, but got ${res2.length}.`);\n    }\n    if (res1.length !== this.sortOrder.length) {\n      throw new Error(\"orderByItems cannot have a different size than sort orders.\");\n    }\n\n    for (let i = 0; i < this.sortOrder.length; i++) {\n      const type1 = this.getType(res1[i]);\n      const type2 = this.getType(res2[i]);\n      if (type1 !== type2) {\n        throw new Error(\n          `Expected ${type1}, but got ${type2}. Cannot execute cross partition order-by queries on mixed types. Consider filtering your query using IS_STRING or IS_NUMBER to get around this exception.`,\n        );\n      }\n    }\n  }\n\n  private getType(\n    orderByItem: any,\n  ):\n    | \"string\"\n    | \"number\"\n    | \"bigint\"\n    | \"boolean\"\n    | \"symbol\"\n    | \"undefined\"\n    | \"object\"\n    | \"function\"\n    | \"NoValue\" {\n    // TODO: any item?\n    if (orderByItem === undefined || orderByItem.item === undefined) {\n      return \"NoValue\";\n    }\n    const type = typeof orderByItem.item;\n    if (TYPEORDCOMPARATOR[type] === undefined) {\n      throw new Error(`unrecognizable type ${type}`);\n    }\n    return type;\n  }\n\n  private getOrderByItems(res: any): any {\n    // TODO: any res?\n    return res[\"orderByItems\"];\n  }\n}\n"]}