{"version":3,"file":"EncryptionKeyStoreProvider.js","sourceRoot":"","sources":["../../../src/encryption/EncryptionKeyStoreProvider.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAC;AAG/C;;GAEG;AACH,MAAM,OAAO,0BAA0B;IAQrC,YACU,wBAA+C,EAC/C,eAAuB;QADvB,6BAAwB,GAAxB,wBAAwB,CAAuB;QAC/C,oBAAe,GAAf,eAAe,CAAQ;QAT1B,+BAA0B,GAAW,UAAU,CAAC;QAWrD,IAAI,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;QACzD,IAAI,CAAC,YAAY,GAAG,wBAAwB,CAAC,yBAAyB,CAAC;QACvE,IAAI,CAAC,2BAA2B,GAAG,EAAE,CAAC;QACtC,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,qBAAqB,EAAE,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,OAAO,CAClB,eAAuB,EACvB,SAAiC,EACjC,GAAW;QAEX,MAAM,aAAa,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC;QAC1C,MAAM,oBAAoB,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,OAAO,CACtE,eAAe,EACf,SAAS,EACT,aAAa,CACd,CAAC;QACF,OAAO,MAAM,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;IAC3C,CAAC;IAEM,KAAK,CAAC,SAAS,CACpB,eAAuB,EACvB,SAAiC,EACjC,UAAkB;QAElB,IAAI,IAAI,CAAC,eAAe,KAAK,CAAC,EAAE,CAAC;YAC/B,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,SAAS,CACvD,eAAe,EACf,SAAS,EACT,UAAU,CACX,CAAC;YACF,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAC1B,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,2BAA2B,CAAC,eAAe,CAAC,EAAE,CAAC;YACvD,MAAM,oBAAoB,GAAG,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC;YACxD,MAAM,kBAAkB,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,SAAS,CACtE,eAAe,EACf,SAAS,EACT,oBAAoB,CACrB,CAAC;YACF,MAAM,wBAAwB,GAAG,MAAM,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YACjE,IAAI,CAAC,2BAA2B,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE,EAAE,wBAAwB,CAAC,CAAC;QAC7F,CAAC;QACD,OAAO,IAAI,CAAC,2BAA2B,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9D,CAAC;IAEO,KAAK,CAAC,qBAAqB;QACjC,IAAI,CAAC,cAAc,GAAG,WAAW,CAAC,GAAG,EAAE;YACrC,MAAM,GAAG,GAAG,IAAI,IAAI,EAAE,CAAC;YACvB,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,2BAA2B,EAAE,CAAC;gBACnD,IACE,GAAG,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,2BAA2B,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE;oBAClE,IAAI,CAAC,eAAe,EACpB,CAAC;oBACD,OAAO,IAAI,CAAC,2BAA2B,CAAC,GAAG,CAAC,CAAC;gBAC/C,CAAC;YACH,CAAC;QACH,CAAC,EAAE,SAAS,CAAC,kCAAkC,CAAC,CAAC;IACnD,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { Constants } from \"../common/index.js\";\nimport type { EncryptionKeyResolver } from \"./EncryptionKeyResolver/index.js\";\nimport type { KeyEncryptionAlgorithm } from \"./enums/index.js\";\n/**\n * Class to store encryption keys in unwrapped form and provide an interface for wrapping and unwrapping the keys.\n */\nexport class EncryptionKeyStoreProvider {\n  public RsaOaepEncryptionAlgorithm: string = \"RSA-OAEP\";\n  // interval for clear cache to run\n  cacheRefresher: NodeJS.Timeout;\n\n  // cache to store the unwrapped encryption key. Key is the path of the encryption key\n  public unwrappedEncryptionKeyCache: { [key: string]: [Date, Buffer] };\n  public providerName: string;\n  constructor(\n    private keyEncryptionKeyResolver: EncryptionKeyResolver,\n    private cacheTimeToLive: number,\n  ) {\n    this.keyEncryptionKeyResolver = keyEncryptionKeyResolver;\n    this.providerName = keyEncryptionKeyResolver.encryptionKeyResolverName;\n    this.unwrappedEncryptionKeyCache = {};\n    this.cacheTimeToLive = cacheTimeToLive;\n    this.clearCacheOnTtlExpiry();\n  }\n\n  public async wrapKey(\n    encryptionKeyId: string,\n    algorithm: KeyEncryptionAlgorithm,\n    key: Buffer,\n  ): Promise<Buffer> {\n    const uInt8ArrayKey = new Uint8Array(key);\n    const wrappedEncryptionKey = await this.keyEncryptionKeyResolver.wrapKey(\n      encryptionKeyId,\n      algorithm,\n      uInt8ArrayKey,\n    );\n    return Buffer.from(wrappedEncryptionKey);\n  }\n\n  public async unwrapKey(\n    encryptionKeyId: string,\n    algorithm: KeyEncryptionAlgorithm,\n    wrappedKey: Buffer,\n  ): Promise<Buffer> {\n    if (this.cacheTimeToLive === 0) {\n      const res = await this.keyEncryptionKeyResolver.unwrapKey(\n        encryptionKeyId,\n        algorithm,\n        wrappedKey,\n      );\n      return Buffer.from(res);\n    }\n    if (!this.unwrappedEncryptionKeyCache[encryptionKeyId]) {\n      const wrappedKeyUint8Array = new Uint8Array(wrappedKey);\n      const plainEncryptionKey = await this.keyEncryptionKeyResolver.unwrapKey(\n        encryptionKeyId,\n        algorithm,\n        wrappedKeyUint8Array,\n      );\n      const plainEncryptionKeyBuffer = Buffer.from(plainEncryptionKey);\n      this.unwrappedEncryptionKeyCache[encryptionKeyId] = [new Date(), plainEncryptionKeyBuffer];\n    }\n    return this.unwrappedEncryptionKeyCache[encryptionKeyId][1];\n  }\n\n  private async clearCacheOnTtlExpiry(): Promise<void> {\n    this.cacheRefresher = setInterval(() => {\n      const now = new Date();\n      for (const key in this.unwrappedEncryptionKeyCache) {\n        if (\n          now.getTime() - this.unwrappedEncryptionKeyCache[key][0].getTime() >\n          this.cacheTimeToLive\n        ) {\n          delete this.unwrappedEncryptionKeyCache[key];\n        }\n      }\n    }, Constants.EncryptionCacheRefreshIntervalInMs);\n  }\n}\n"]}