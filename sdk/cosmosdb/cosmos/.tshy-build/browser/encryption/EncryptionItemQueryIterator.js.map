{"version":3,"file":"EncryptionItemQueryIterator.js","sourceRoot":"","sources":["../../../src/encryption/EncryptionItemQueryIterator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { Container } from \"../client/index.js\";\nimport type { ClientContext } from \"../ClientContext.js\";\nimport { Constants, ResourceType } from \"../common/constants.js\";\nimport {\n  DiagnosticNodeInternal,\n  DiagnosticNodeType,\n} from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport type { SqlQuerySpec, FetchFunctionCallback } from \"../queryExecutionContext/index.js\";\nimport { QueryIterator } from \"../queryIterator.js\";\nimport type { FeedOptions, FeedResponse } from \"../request/index.js\";\nimport { withDiagnostics } from \"../utils/diagnostics.js\";\n\n/**\n * @internal\n * Provides the iterator for handling encrypted items in the Azure Cosmos DB database service.\n * extends @see {@link QueryIterator}\n */\nexport class EncryptionItemQueryIterator<Item> extends QueryIterator<Item> {\n  private container: Container;\n  private encryptionClientContext: ClientContext;\n  private encryptionOptions: FeedOptions;\n\n  constructor(\n    clientContext: ClientContext,\n    query: SqlQuerySpec | string,\n    options: FeedOptions,\n    fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n    container: Container,\n  ) {\n    super(clientContext, query, options, fetchFunctions, container.url, ResourceType.item);\n    this.container = container;\n    this.encryptionClientContext = clientContext;\n    this.encryptionOptions = options;\n  }\n\n  /**\n   * Gets an async iterator that will yield results until completion.\n   */\n  public override async *getAsyncIterator(): AsyncIterable<FeedResponse<Item>> {\n    let response: FeedResponse<Item>;\n    const diagnosticNode = new DiagnosticNodeInternal(\n      this.encryptionClientContext.diagnosticLevel,\n      DiagnosticNodeType.CLIENT_REQUEST_NODE,\n      null,\n    );\n    try {\n      response = yield* QueryIterator.prototype.getAsyncIteratorInternal.call(this, diagnosticNode);\n    } catch (error) {\n      await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n    }\n    if (response?.resources?.length > 0) {\n      let count = 0;\n      diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n      for (let resource of response.resources) {\n        const { body, propertiesDecryptedCount } =\n          await this.container.encryptionProcessor.decrypt(resource);\n        resource = body;\n        count += propertiesDecryptedCount;\n      }\n      diagnosticNode.endEncryptionDiagnostics(\n        Constants.Encryption.DiagnosticsDecryptOperation,\n        count,\n      );\n    }\n    yield response;\n  }\n\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   */\n  public override async fetchAll(): Promise<FeedResponse<Item>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      let response: FeedResponse<Item>;\n      try {\n        response = await QueryIterator.prototype.fetchAllInternal.call(this, diagnosticNode);\n      } catch (error) {\n        await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n      }\n      if (response?.resources?.length > 0) {\n        let count = 0;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        for (let resource of response.resources) {\n          const { body, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(resource);\n          resource = body;\n          count += propertiesDecryptedCount;\n        }\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsDecryptOperation,\n          count,\n        );\n      }\n      return response;\n    }, this.encryptionClientContext);\n  }\n\n  /**\n   * Retrieve the next batch from the feed.\n   */\n  public override async fetchNext(): Promise<FeedResponse<Item>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      let response: FeedResponse<Item>;\n      try {\n        response = await QueryIterator.prototype.fetchNextInternal.call(this, diagnosticNode);\n      } catch (error) {\n        await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n      }\n      if (response?.resources?.length > 0) {\n        let count = 0;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n        for (let resource of response.resources) {\n          const { body, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(resource);\n          resource = body;\n          count += propertiesDecryptedCount;\n        }\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsDecryptOperation,\n          count,\n        );\n      }\n      return response;\n    }, this.encryptionClientContext);\n  }\n  /**\n   * @internal\n   */\n  public override async init(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    // Ensure encryption is initialized and set rid in options\n    await this.container.checkAndInitializeEncryption();\n    this.encryptionOptions.containerRid = this.container._rid;\n    await QueryIterator.prototype.init.call(this, diagnosticNode);\n  }\n}\n"]}