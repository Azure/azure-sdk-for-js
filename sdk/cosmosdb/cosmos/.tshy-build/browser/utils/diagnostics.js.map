{"version":3,"file":"diagnostics.js","sourceRoot":"","sources":["../../../src/utils/diagnostics.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { MetadataLookUpType } from \"../CosmosDiagnostics.js\";\nimport { CosmosDiagnostics } from \"../CosmosDiagnostics.js\";\nimport type { DiagnosticDataValue } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport {\n  DiagnosticNodeInternal,\n  DiagnosticNodeType,\n} from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport type { ClientContext } from \"../ClientContext.js\";\nimport { getCurrentTimestampInMs } from \"./time.js\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel.js\";\nimport { randomUUID } from \"@azure/core-util\";\n\n/**\n * @hidden\n * Utility function to create an Empty CosmosDiagnostic object.\n */\nexport function getEmptyCosmosDiagnostics(): CosmosDiagnostics {\n  return new CosmosDiagnostics(\n    {\n      requestDurationInMs: 0,\n      requestStartTimeUTCInMs: getCurrentTimestampInMs(),\n      totalRequestPayloadLengthInBytes: 0,\n      totalResponsePayloadLengthInBytes: 0,\n      locationEndpointsContacted: [],\n      retryDiagnostics: {\n        failedAttempts: [],\n      },\n      metadataDiagnostics: {\n        metadataLookups: [],\n      },\n      gatewayStatistics: [],\n    },\n    {\n      id: randomUUID(),\n      nodeType: DiagnosticNodeType.CLIENT_REQUEST_NODE,\n      children: [],\n      data: {},\n      startTimeUTCInMs: getCurrentTimestampInMs(),\n      durationInMs: 0,\n    },\n  );\n}\n\n/**\n * @hidden\n */\nexport type ExtractPromise<T> = T extends Promise<infer U> ? U : never;\n\n/**\n * A supporting utility wrapper function, to be used inside a diagnostic session started\n * by `withDiagnostics` function.\n * Created a Diagnostic node and add it as a child to existing diagnostic session.\n * @hidden\n */\nexport async function addDiagnosticChild<\n  Callback extends (node: DiagnosticNodeInternal) => Promise<any>,\n>(\n  callback: Callback,\n  node: DiagnosticNodeInternal,\n  type: DiagnosticNodeType,\n  data: Partial<DiagnosticDataValue> = {},\n): Promise<ExtractPromise<ReturnType<Callback>>> {\n  const childNode = node.initializeChildNode(type, CosmosDbDiagnosticLevel.debug, data);\n  try {\n    const response = await callback(childNode);\n    childNode.updateTimestamp();\n    return response;\n  } catch (e: any) {\n    childNode.addData({\n      failure: true,\n    });\n    childNode.updateTimestamp();\n    throw e;\n  }\n}\n\n/**\n * A supporting utility wrapper function, to be used inside a diagnostic session started\n * by `withDiagnostics` function.\n * Treats requests originating in  provided `callback` as metadata calls.\n * To realize this, starts a temporary diagnostic session, after execution of callback is\n * finished. Merges this temporary diagnostic session to the original diagnostic session\n * represented by the input parameter `node`.\n * @hidden\n */\nexport async function withMetadataDiagnostics<\n  Callback extends (node: DiagnosticNodeInternal) => Promise<any>,\n>(\n  callback: Callback,\n  node: DiagnosticNodeInternal,\n  type: MetadataLookUpType,\n): Promise<ExtractPromise<ReturnType<Callback>>> {\n  const diagnosticNodeForMetadataCall = new DiagnosticNodeInternal(\n    node.diagnosticLevel,\n    DiagnosticNodeType.METADATA_REQUEST_NODE,\n    null,\n  );\n  try {\n    const response: any = await callback(diagnosticNodeForMetadataCall);\n    node.addChildNode(diagnosticNodeForMetadataCall, CosmosDbDiagnosticLevel.debug, type);\n    return response;\n  } catch (e) {\n    node.addChildNode(diagnosticNodeForMetadataCall, CosmosDbDiagnosticLevel.debug, type);\n    throw e;\n  }\n}\n\n/**\n * Utility wrapper function to managed lifecycle of a Diagnostic session.\n * Meant to be used at the root of the client operation. i.e. item.read(),\n * queryIterator.fetchAll().\n *\n * This utility starts a new diagnostic session. So using it any where else\n * other than start of operation, will result is different diagnostic sessions.\n *\n * Workings :\n * 1. Takes a callback function as input.\n * 2. Creates a new instance of DiagnosticNodeInternal, which can be though as starting\n * a new diagnostic session.\n * 3. Executes the callback function.\n * 4. If execution was successful. Converts DiagnosticNodeInternal to CosmosDiagnostics\n * and injects it to the response object and returns this object.\n * 5. If execution threw an exception. Sill converts DiagnosticNodeInternal to CosmosDiagnostics\n * and injects it to the Error object, and rethrows the Error object.\n *\n * @hidden\n */\nexport async function withDiagnostics<\n  Callback extends (node: DiagnosticNodeInternal) => Promise<any>,\n>(\n  callback: Callback,\n  clientContext: ClientContext,\n  type: DiagnosticNodeType = DiagnosticNodeType.CLIENT_REQUEST_NODE,\n): Promise<ExtractPromise<ReturnType<Callback>>> {\n  const diagnosticNode = new DiagnosticNodeInternal(clientContext.diagnosticLevel, type, null);\n  try {\n    const response: any = await callback(diagnosticNode);\n    diagnosticNode.updateTimestamp();\n    const diagnostics = diagnosticNode.toDiagnostic(clientContext.getClientConfig());\n    if (typeof response === \"object\" && response !== null) {\n      (response as any).diagnostics = diagnostics;\n    }\n    clientContext.recordDiagnostics(diagnostics);\n    return response;\n  } catch (e: any) {\n    diagnosticNode.updateTimestamp();\n    diagnosticNode.addData({\n      failure: true,\n    });\n    const diagnostics = diagnosticNode.toDiagnostic(clientContext.getClientConfig());\n    e.diagnostics = diagnostics;\n    clientContext.recordDiagnostics(diagnostics);\n    throw e;\n  }\n}\n"]}