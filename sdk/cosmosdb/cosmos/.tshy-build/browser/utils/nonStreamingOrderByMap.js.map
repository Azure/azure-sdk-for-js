{"version":3,"file":"nonStreamingOrderByMap.js","sourceRoot":"","sources":["../../../src/utils/nonStreamingOrderByMap.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC;;GAEG;AACH,MAAM,OAAO,sBAAsB;IAIjC,YAAY,SAAyD;QACnE,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,GAAG,GAAG,IAAI,GAAG,EAAa,CAAC;IAClC,CAAC;IAEM,GAAG,CAAC,GAAW,EAAE,KAAQ;QAC9B,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;YACvB,gDAAgD;YAChD,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;QAC3B,CAAC;aAAM,CAAC;YACN,oIAAoI;YACpI,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACnC,IAAI,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE,CAAC;gBACzC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YAC3B,CAAC;QACH,CAAC;IACH,CAAC;IAEM,GAAG,CAAC,GAAW;QACpB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;YAAE,OAAO,SAAS,CAAC;QAEzC,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC3B,CAAC;IACD;;OAEG;IACI,oBAAoB;QACzB,MAAM,GAAG,GAAQ,EAAE,CAAC;QACpB,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE,CAAC;YACpC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAChB,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IAEO,cAAc,CAAC,IAAmB,EAAE,IAAmB;QAC7D,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACvC,IAAI,GAAG,GAAG,CAAC;YAAE,OAAO,IAAI,CAAC;QAEzB,OAAO,KAAK,CAAC;IACf,CAAC;IAEM,IAAI;QACT,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;IACvB,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/**\n * Stores the most favourable distinct result from a set of nonStreamingOrderBy results.\n */\nexport class NonStreamingOrderByMap<T> {\n  private map: Map<string, T>;\n  private compareFn: (a: T | undefined, b: T | undefined) => number;\n\n  constructor(compareFn: (a: T | undefined, b: T | undefined) => number) {\n    this.compareFn = compareFn;\n    this.map = new Map<string, T>();\n  }\n\n  public set(key: string, value: T): void {\n    if (!this.map.has(key)) {\n      // If the key is not present in the map, add it.\n      this.map.set(key, value);\n    } else {\n      // If the key is present in the map, compare the similarity score of the new value with the old value. Keep the more favourable one.\n      const oldValue = this.map.get(key);\n      if (this.replaceResults(oldValue, value)) {\n        this.map.set(key, value);\n      }\n    }\n  }\n\n  public get(key: string): T | undefined {\n    if (!this.map.has(key)) return undefined;\n\n    return this.map.get(key);\n  }\n  /**\n   * Returns all the values in the map and resets the map.\n   */\n  public getAllValuesAndReset(): T[] {\n    const res: T[] = [];\n    for (const [key, value] of this.map) {\n      res.push(value);\n      this.map.delete(key);\n    }\n    return res;\n  }\n\n  private replaceResults(res1: T | undefined, res2: T | undefined): boolean {\n    const res = this.compareFn(res1, res2);\n    if (res < 0) return true;\n\n    return false;\n  }\n\n  public size(): number {\n    return this.map.size;\n  }\n}\n"]}