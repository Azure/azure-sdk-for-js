{"version":3,"file":"number.js","sourceRoot":"","sources":["../../../../../src/utils/hashing/encoding/number.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,iBAAiB,EAAE,qBAAqB,EAAE,MAAM,gBAAgB,CAAC;AAC1E,OAAO,EAAE,UAAU,EAAE,MAAM,aAAa,CAAC;AAEzC,MAAM,UAAU,kCAAkC,CAAC,IAAY;IAC7D,IAAI,OAAO,GAAG,0BAA0B,CAAC,IAAI,CAAC,CAAC;IAC/C,0DAA0D;IAC1D,IAAI,YAAY,GAAG,qBAAqB,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IAE5D,MAAM,UAAU,GAAG,CAAC,OAAO,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IAC1D,YAAY,GAAG,iBAAiB,CAAC;QAC/B,YAAY;QACZ,qBAAqB,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;KAChE,CAAC,CAAC;IAEH,OAAO,GAAG,CAAC,OAAO,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC;IAEhE,IAAI,WAAW,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IAC5B,IAAI,cAAc,GAAG,IAAI,CAAC;IAE1B,GAAG,CAAC;QACF,IAAI,CAAC,cAAc,EAAE,CAAC;YACpB,MAAM,MAAM,GAAG,WAAW,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;YACzD,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC;gBACpB,YAAY,GAAG,iBAAiB,CAAC,CAAC,YAAY,EAAE,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAClF,CAAC;QACH,CAAC;aAAM,CAAC;YACN,cAAc,GAAG,KAAK,CAAC;QACzB,CAAC;QAED,MAAM,OAAO,GAAG,CAAC,OAAO,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;QACvD,WAAW,GAAG,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;QACrC,OAAO,GAAG,CAAC,OAAO,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC;IAClE,CAAC,QAAQ,OAAO,KAAK,MAAM,CAAC,CAAC,CAAC,EAAE;IAEhC,MAAM,SAAS,GAAG,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;IAC7C,MAAM,MAAM,GAAG,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;IACvD,IAAI,MAAM,KAAK,IAAI,EAAE,CAAC;QACpB,YAAY,GAAG,iBAAiB,CAAC,CAAC,YAAY,EAAE,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAClF,CAAC;IAED,OAAO,YAAY,CAAC;AACtB,CAAC;AAED,SAAS,0BAA0B,CAAC,KAAa;IAC/C,MAAM,YAAY,GAAG,gBAAgB,CAAC,KAAK,CAAC,CAAC;IAC7C,MAAM,IAAI,GAAG,MAAM,CAAC,oBAAoB,CAAC,CAAC;IAC1C,OAAO,IAAI,GAAG,YAAY,CAAC,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,YAAY,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AAC/E,CAAC;AAED,SAAS,gBAAgB,CAAC,KAAa;IACrC,MAAM,MAAM,GAAG,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC;IAClC,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC;IAClC,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IAC1B,gDAAgD;IAChD,OAAO,MAAM,CAAC,IAAI,GAAG,OAAO,CAAC,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AACxD,CAAC;AAED,SAAS,OAAO,CAAC,GAAe;IAC9B,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC;SACnB,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;SAC3C,IAAI,CAAC,EAAE,CAAC,CAAC;AACd,CAAC;AAED,MAAM,UAAU,uBAAuB,CAAC,MAAc;IACpD,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC,CAAC,CAAC;IACjC,MAAM,GAAG,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC3B,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,IAAI,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;IAC5D,CAAC;IACD,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { concatUint8Arrays, hexStringToUint8Array } from \"../../uint8.js\";\nimport { BytePrefix } from \"./prefix.js\";\n\nexport function writeNumberForBinaryEncodingBigInt(hash: number): Uint8Array {\n  let payload = encodeNumberAsUInt64BigInt(hash);\n  // Convert the BytePrefix.Number hex string to Uint8Array.\n  let outputStream = hexStringToUint8Array(BytePrefix.Number);\n\n  const firstChunk = (payload >> BigInt(56)) & BigInt(0xff);\n  outputStream = concatUint8Arrays([\n    outputStream,\n    hexStringToUint8Array(firstChunk.toString(16).padStart(2, \"0\")),\n  ]);\n\n  payload = (payload << BigInt(8)) & BigInt(\"0xffffffffffffffff\");\n\n  let byteToWrite = BigInt(0);\n  let firstIteration = true;\n\n  do {\n    if (!firstIteration) {\n      const padded = byteToWrite.toString(16).padStart(2, \"0\");\n      if (padded !== \"00\") {\n        outputStream = concatUint8Arrays([outputStream, hexStringToUint8Array(padded)]);\n      }\n    } else {\n      firstIteration = false;\n    }\n\n    const shifted = (payload >> BigInt(56)) & BigInt(0xff);\n    byteToWrite = shifted | BigInt(0x01);\n    payload = (payload << BigInt(7)) & BigInt(\"0xffffffffffffffff\");\n  } while (payload !== BigInt(0));\n\n  const lastChunk = byteToWrite & BigInt(0xfe);\n  const padded = lastChunk.toString(16).padStart(2, \"0\");\n  if (padded !== \"00\") {\n    outputStream = concatUint8Arrays([outputStream, hexStringToUint8Array(padded)]);\n  }\n\n  return outputStream;\n}\n\nfunction encodeNumberAsUInt64BigInt(value: number): bigint {\n  const rawValueBits = getRawBitsBigInt(value);\n  const mask = BigInt(\"0x8000000000000000\");\n  return mask > rawValueBits ? rawValueBits ^ mask : ~rawValueBits + BigInt(1);\n}\n\nfunction getRawBitsBigInt(value: number): bigint {\n  const buffer = new ArrayBuffer(8);\n  const view = new DataView(buffer);\n  view.setFloat64(0, value);\n  // Convert the underlying bytes to a hex string.\n  return BigInt(\"0x\" + buf2hex(new Uint8Array(buffer)));\n}\n\nfunction buf2hex(arr: Uint8Array): string {\n  return Array.from(arr)\n    .map((x) => x.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n\nexport function doubleToByteArrayBigInt(double: number): Uint8Array {\n  const output = new Uint8Array(8);\n  const lng = getRawBitsBigInt(double);\n  for (let i = 0; i < 8; i++) {\n    output[i] = Number((lng >> BigInt(i * 8)) & BigInt(0xff));\n  }\n  return output;\n}\n"]}