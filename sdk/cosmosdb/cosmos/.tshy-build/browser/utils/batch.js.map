{"version":3,"file":"batch.js","sourceRoot":"","sources":["../../../src/utils/batch.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAGlC,OAAO,EAAE,oBAAoB,EAAE,qBAAqB,EAAE,MAAM,2BAA2B,CAAC;AAcxF,OAAO,EAAE,uBAAuB,EAAE,6BAA6B,EAAE,MAAM,uBAAuB,CAAC;AAE/F,OAAO,EAAE,kBAAkB,EAAE,MAAM,iBAAiB,CAAC;AACrD,OAAO,EAAE,YAAY,EAAE,MAAM,uBAAuB,CAAC;AACrD,OAAO,EAAE,SAAS,EAAE,MAAM,wBAAwB,CAAC;AACnD,OAAO,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAC;AAgE9C,MAAM,UAAU,YAAY,CAAC,GAAW,EAAE,GAAW,EAAE,GAAW;IAChE,MAAM,mBAAmB,GAAG,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IACxD,MAAM,WAAW,GAAG,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IAC/C,OAAO,mBAAmB,IAAI,WAAW,CAAC;AAC5C,CAAC;AAQD,MAAM,CAAC,MAAM,iBAAiB,GAAG;IAC/B,MAAM,EAAE,QAAQ;IAChB,MAAM,EAAE,QAAQ;IAChB,IAAI,EAAE,MAAM;IACZ,MAAM,EAAE,QAAQ;IAChB,OAAO,EAAE,SAAS;IAClB,KAAK,EAAE,OAAO;CACN,CAAC;AAwFX,MAAM,UAAU,WAAW,CACzB,SAAoB;IAEpB,OAAO,CACL,SAAS,CAAC,aAAa,KAAK,OAAO;QAClC,SAA+B,CAAC,YAAY,KAAK,SAAS,CAC5D,CAAC;AACJ,CAAC;AACD;;;;;;;;;;;;;;GAcG;AACH,MAAM,UAAU,iBAAiB,CAC/B,cAA8B,EAC9B,UAAkC,EAClC,UAA0B,EAAE;IAK5B,mBAAmB,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;IAE7C,IAAI,YAA0C,CAAC;IAC/C,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,cAAc,EAAE,cAAc,CAAC,EAAE,CAAC;QACzE,IAAI,cAAc,CAAC,YAAY,KAAK,SAAS,EAAE,CAAC;YAC9C,YAAY,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,uBAAuB,CAAC,CAAC;QACrE,CAAC;aAAM,CAAC;YACN,YAAY,GAAG,6BAA6B,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;QAC5E,CAAC;IACH,CAAC;SAAM,CAAC;QACN,QAAQ,cAAc,CAAC,aAAa,EAAE,CAAC;YACrC,KAAK,iBAAiB,CAAC,MAAM,CAAC;YAC9B,KAAK,iBAAiB,CAAC,OAAO,CAAC;YAC/B,KAAK,iBAAiB,CAAC,MAAM;gBAC3B,YAAY,GAAG,kBAAkB,CAC/B,oBAAoB,CAAC,cAAc,CAAC,YAAY,EAAE,UAAU,CAAC,EAC7D,2CAA2C,CAC5C,CAAC;gBACF,MAAM;YACR,KAAK,iBAAiB,CAAC,IAAI,CAAC;YAC5B,KAAK,iBAAiB,CAAC,MAAM,CAAC;YAC9B,KAAK,iBAAiB,CAAC,KAAK;gBAC1B,YAAY,GAAG,qBAAqB,CAAC,UAAU,CAAC,CAAC;gBACjD,MAAM;QACV,CAAC;IACH,CAAC;IACD,OAAO;QACL,SAAS,EAAE,gCAAK,cAAc,KAAE,YAAY,EAAE,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAe;QACzF,YAAY;KACb,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,SAAS,mBAAmB,CAAC,cAA8B,EAAE,OAAuB;IAClF,IACE,cAAc,CAAC,aAAa,KAAK,iBAAiB,CAAC,MAAM;QACzD,cAAc,CAAC,aAAa,KAAK,iBAAiB,CAAC,MAAM,EACzD,CAAC;QACD,IACE,CAAC,cAAc,CAAC,YAAY,CAAC,EAAE,KAAK,SAAS,IAAI,cAAc,CAAC,YAAY,CAAC,EAAE,KAAK,EAAE,CAAC;YACvF,CAAC,OAAO,CAAC,4BAA4B,EACrC,CAAC;YACD,cAAc,CAAC,YAAY,CAAC,EAAE,GAAG,UAAU,EAAE,CAAC;QAChD,CAAC;IACH,CAAC;AACH,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,UAAU,yBAAyB,CAAC,aAAoB;IAC5D,IAAI,CAAA,aAAa,aAAb,aAAa,uBAAb,aAAa,CAAE,UAAU,MAAK,SAAS,IAAI,aAAa,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC;QAAE,OAAO,EAAE,CAAC;IAC9F,IAAI,gBAAgB,GAAG,0BAA0B,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/E,IAAI,YAAY,mCACX,aAAa,KAChB,UAAU,EAAE,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EACzC,OAAO,EAAE,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GACpC,CAAC;IACF,MAAM,gBAAgB,GAAY,EAAE,CAAC;IACrC,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAEpC,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,aAAa,CAAC,UAAU,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC;QACrE,MAAM,SAAS,GAAG,aAAa,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;QAClD,MAAM,aAAa,GAAG,0BAA0B,CAAC,SAAS,CAAC,CAAC;QAC5D,IAAI,gBAAgB,GAAG,aAAa,GAAG,SAAS,CAAC,oCAAoC,EAAE,CAAC;YACtF,YAAY,mCACP,aAAa,KAChB,UAAU,EAAE,EAAE,EACd,OAAO,EAAE,EAAE,GACZ,CAAC;YACF,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YACpC,gBAAgB,GAAG,CAAC,CAAC;QACvB,CAAC;QACD,YAAY,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACxC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QACxD,gBAAgB,IAAI,aAAa,CAAC;IACpC,CAAC;IACD,OAAO,gBAAgB,CAAC;AAC1B,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,0BAA0B,CAAC,GAAY;IACrD,OAAO,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,GAAU,CAAC,CAAC,CAAC,MAAM,CAAC;AACnE,CAAC;AAED,MAAM,UAAU,sBAAsB,CACpC,SAAyB,EACzB,UAA0B,EAAE;IAE5B,IACE,SAAS,CAAC,aAAa,KAAK,iBAAiB,CAAC,MAAM;QACpD,SAAS,CAAC,aAAa,KAAK,iBAAiB,CAAC,MAAM,EACpD,CAAC;QACD,IACE,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,KAAK,SAAS,IAAI,SAAS,CAAC,YAAY,CAAC,EAAE,KAAK,EAAE,CAAC;YAC7E,CAAC,OAAO,CAAC,4BAA4B,EACrC,CAAC;YACD,SAAS,CAAC,YAAY,CAAC,EAAE,GAAG,UAAU,EAAE,CAAC;QAC3C,CAAC;IACH,CAAC;IACD,OAAO,SAAsB,CAAC;AAChC,CAAC;AAED,MAAM,UAAU,mBAAmB,CAAC,UAAsB;IACxD,OAAO,UAAU,IAAI,GAAG,IAAI,UAAU,IAAI,GAAG,CAAC;AAChD,CAAC;AAWD,MAAM,OAAO,oBAAoB;IAK/B;QACE,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,CAAI,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAChD,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC;YACzB,IAAI,CAAC,QAAQ,GAAG,MAAM,CAAC;QACzB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAEM,SAAS,CAAC,KAAQ;QACvB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;IACxB,CAAC;IAEM,YAAY,CAAC,KAAY;QAC9B,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACvB,CAAC;CACF;AAED,MAAM,CAAC,KAAK,UAAU,qBAAqB,CACzC,mBAAwC,EACxC,SAAyB,EACzB,6BAAqC;IAErC,IAAI,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,cAAc,CAAC,EAAE,CAAC;QACpE,MAAM,oBAAoB,GAAG,6BAA6B,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;QACnF,MAAM,EAAE,gBAAgB,EAAE,cAAc,EAAE,GACxC,MAAM,mBAAmB,CAAC,6BAA6B,CAAC,oBAAoB,CAAC,CAAC;QAChF,SAAS,CAAC,YAAY,GAAG,gBAAgB,CAAC;QAC1C,6BAA6B,IAAI,cAAc,CAAC;IAClD,CAAC;IACD,QAAQ,SAAS,CAAC,aAAa,EAAE,CAAC;QAChC,KAAK,iBAAiB,CAAC,MAAM,CAAC;QAC9B,KAAK,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC;YAC9B,MAAM,EAAE,IAAI,EAAE,wBAAwB,EAAE,GAAG,MAAM,mBAAmB,CAAC,OAAO,CAC1E,SAAS,CAAC,YAAY,CACvB,CAAC;YACF,SAAS,CAAC,YAAY,GAAG,IAAI,CAAC;YAC9B,6BAA6B,IAAI,wBAAwB,CAAC;YAC1D,MAAM;QACR,CAAC;QACD,KAAK,iBAAiB,CAAC,IAAI,CAAC;QAC5B,KAAK,iBAAiB,CAAC,MAAM;YAC3B,IAAI,MAAM,mBAAmB,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE,CAAC;gBACrD,SAAS,CAAC,EAAE,GAAG,MAAM,mBAAmB,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;gBACtE,6BAA6B,EAAE,CAAC;YAClC,CAAC;YACD,MAAM;QACR,KAAK,iBAAiB,CAAC,OAAO,CAAC,CAAC,CAAC;YAC/B,IAAI,MAAM,mBAAmB,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE,CAAC;gBACrD,SAAS,CAAC,EAAE,GAAG,MAAM,mBAAmB,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;gBACtE,6BAA6B,EAAE,CAAC;YAClC,CAAC;YACD,MAAM,EAAE,IAAI,EAAE,wBAAwB,EAAE,GAAG,MAAM,mBAAmB,CAAC,OAAO,CAC1E,SAAS,CAAC,YAAY,CACvB,CAAC;YACF,SAAS,CAAC,YAAY,GAAG,IAAI,CAAC;YAC9B,6BAA6B,IAAI,wBAAwB,CAAC;YAC1D,MAAM;QACR,CAAC;QACD,KAAK,iBAAiB,CAAC,KAAK,CAAC,CAAC,CAAC;YAC7B,IAAI,MAAM,mBAAmB,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE,CAAC;gBACrD,SAAS,CAAC,EAAE,GAAG,MAAM,mBAAmB,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;gBACtE,6BAA6B,EAAE,CAAC;YAClC,CAAC;YACD,MAAM,IAAI,GAAG,SAAS,CAAC,YAAY,CAAC;YACpC,MAAM,gBAAgB,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC;YACtE,KAAK,MAAM,cAAc,IAAI,gBAAgB,EAAE,CAAC;gBAC9C,IAAI,OAAO,IAAI,cAAc,EAAE,CAAC;oBAC9B,IAAI,MAAM,mBAAmB,CAAC,eAAe,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;wBACnE,cAAc,CAAC,KAAK,GAAG,MAAM,mBAAmB,CAAC,eAAe,CAC9D,cAAc,CAAC,IAAI,EACnB,cAAc,CAAC,KAAK,CACrB,CAAC;wBACF,6BAA6B,EAAE,CAAC;oBAClC,CAAC;gBACH,CAAC;YACH,CAAC;YACD,MAAM;QACR,CAAC;IACH,CAAC;IACD,OAAO,EAAE,SAAS,EAAE,6BAA6B,EAAE,CAAC;AACtD,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { JSONObject } from \"../queryExecutionContext/index.js\";\nimport { extractPartitionKeys, undefinedPartitionKey } from \"../extractPartitionKey.js\";\nimport type {\n  CosmosDiagnostics,\n  CosmosHeaders,\n  DiagnosticNodeInternal,\n  ErrorResponse,\n  RequestOptions,\n  StatusCode,\n} from \"../index.js\";\nimport type {\n  PartitionKey,\n  PartitionKeyDefinition,\n  PrimitivePartitionKeyValue,\n} from \"../documents/index.js\";\nimport { NonePartitionKeyLiteral, convertToInternalPartitionKey } from \"../documents/index.js\";\nimport type { PatchRequestBody } from \"./patch.js\";\nimport { assertNotUndefined } from \"./typeChecks.js\";\nimport { bodyFromData } from \"../request/request.js\";\nimport { Constants } from \"../common/constants.js\";\nimport { randomUUID } from \"@azure/core-util\";\nimport type { ItemOperation } from \"../bulk/ItemOperation.js\";\nimport type { BulkResponse } from \"../bulk/index.js\";\nimport type { EncryptionProcessor } from \"../encryption/EncryptionProcessor.js\";\n\nexport type Operation =\n  | CreateOperation\n  | UpsertOperation\n  | ReadOperation\n  | DeleteOperation\n  | ReplaceOperation\n  | BulkPatchOperation;\n\nexport interface Batch {\n  min: string;\n  max: string;\n  rangeId: string;\n  indexes: number[];\n  operations: Operation[];\n}\n\nexport type BulkOperationResponse = OperationResponse[] & { diagnostics: CosmosDiagnostics };\n\n/**\n * represents response for an operation in bulk with executeBulkOperations API\n */\nexport interface BulkOperationResult {\n  /** the original operation input passed */\n  operationInput: OperationInput;\n  /** response from the backend for the item operation  */\n  response?: ExtendedOperationResponse;\n  /** any exceptions are captured here */\n  error?: ErrorResponse;\n}\n\n/**\n * response for a successful operation in bulk with executeBulkOperations API\n */\nexport interface ExtendedOperationResponse extends OperationResponse {\n  /** activity id related to the operation */\n  activityId?: string;\n  /** session Token assigned to the result */\n  sessionToken?: string;\n  /** headers associated with the operation */\n  headers?: CosmosHeaders;\n  /** diagnostic details associated with operation */\n  diagnostics: CosmosDiagnostics;\n}\n\nexport interface OperationResponse {\n  statusCode: number;\n  requestCharge: number;\n  eTag?: string;\n  resourceBody?: JSONObject;\n}\n\n/**\n * Options object used to modify bulk execution.\n * continueOnError (Default value: false) - Continues bulk execution when an operation fails ** NOTE THIS WILL DEFAULT TO TRUE IN the 4.0 RELEASE\n */\nexport interface BulkOptions {\n  continueOnError?: boolean;\n}\n\nexport function isKeyInRange(min: string, max: string, key: string): boolean {\n  const isAfterMinInclusive = key.localeCompare(min) >= 0;\n  const isBeforeMax = key.localeCompare(max) < 0;\n  return isAfterMinInclusive && isBeforeMax;\n}\n\nexport interface OperationBase {\n  partitionKey?: string;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n}\n\nexport const BulkOperationType = {\n  Create: \"Create\",\n  Upsert: \"Upsert\",\n  Read: \"Read\",\n  Delete: \"Delete\",\n  Replace: \"Replace\",\n  Patch: \"Patch\",\n} as const;\n\nexport type OperationInput =\n  | CreateOperationInput\n  | UpsertOperationInput\n  | ReadOperationInput\n  | DeleteOperationInput\n  | ReplaceOperationInput\n  | PatchOperationInput;\n\nexport interface CreateOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Create;\n  resourceBody: JSONObject;\n}\n\nexport interface UpsertOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Upsert;\n  resourceBody: JSONObject;\n}\n\nexport interface ReadOperationInput {\n  partitionKey?: PartitionKey;\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n}\n\nexport interface DeleteOperationInput {\n  partitionKey?: PartitionKey;\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n}\n\nexport interface ReplaceOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Replace;\n  resourceBody: JSONObject;\n  id: string;\n}\n\nexport interface PatchOperationInput {\n  partitionKey?: PartitionKey;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Patch;\n  resourceBody: PatchRequestBody;\n  id: string;\n}\n\nexport type OperationWithItem = OperationBase & {\n  resourceBody: JSONObject;\n};\n\nexport type CreateOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Create;\n};\n\nexport type UpsertOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Upsert;\n};\n\nexport type ReadOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n};\n\nexport type DeleteOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n};\n\nexport type ReplaceOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Replace;\n  id: string;\n};\n\nexport type BulkPatchOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Patch;\n  id: string;\n};\n\nexport function hasResource(\n  operation: Operation,\n): operation is CreateOperation | UpsertOperation | ReplaceOperation {\n  return (\n    operation.operationType !== \"Patch\" &&\n    (operation as OperationWithItem).resourceBody !== undefined\n  );\n}\n/**\n * Maps OperationInput to Operation by\n * - generating Ids if needed.\n * - choosing partitionKey which can be used to choose which batch this\n * operation should be part of. The order is -\n *   1. If the operationInput itself has partitionKey field set it is used.\n *   2. Other wise for create/replace/upsert it is extracted from resource body.\n *   3. For read/delete/patch type operations undefined partitionKey is used.\n * - Here one nuance is that, the partitionKey field inside Operation needs to\n *  be serialized as a JSON string.\n * @param operationInput - OperationInput\n * @param definition - PartitionKeyDefinition\n * @param options - RequestOptions\n * @returns\n */\nexport function prepareOperations(\n  operationInput: OperationInput,\n  definition: PartitionKeyDefinition,\n  options: RequestOptions = {},\n): {\n  operation: Operation;\n  partitionKey: PrimitivePartitionKeyValue[];\n} {\n  populateIdsIfNeeded(operationInput, options);\n\n  let partitionKey: PrimitivePartitionKeyValue[];\n  if (Object.prototype.hasOwnProperty.call(operationInput, \"partitionKey\")) {\n    if (operationInput.partitionKey === undefined) {\n      partitionKey = definition.paths.map(() => NonePartitionKeyLiteral);\n    } else {\n      partitionKey = convertToInternalPartitionKey(operationInput.partitionKey);\n    }\n  } else {\n    switch (operationInput.operationType) {\n      case BulkOperationType.Create:\n      case BulkOperationType.Replace:\n      case BulkOperationType.Upsert:\n        partitionKey = assertNotUndefined(\n          extractPartitionKeys(operationInput.resourceBody, definition),\n          \"Unexpected undefined Partition Key Found.\",\n        );\n        break;\n      case BulkOperationType.Read:\n      case BulkOperationType.Delete:\n      case BulkOperationType.Patch:\n        partitionKey = undefinedPartitionKey(definition);\n        break;\n    }\n  }\n  return {\n    operation: { ...operationInput, partitionKey: JSON.stringify(partitionKey) } as Operation,\n    partitionKey,\n  };\n}\n\n/**\n * For operations requiring Id genrate random uuids.\n * @param operationInput - OperationInput to be checked.\n * @param options - RequestOptions\n */\nfunction populateIdsIfNeeded(operationInput: OperationInput, options: RequestOptions) {\n  if (\n    operationInput.operationType === BulkOperationType.Create ||\n    operationInput.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operationInput.resourceBody.id === undefined || operationInput.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operationInput.resourceBody.id = randomUUID();\n    }\n  }\n}\n\n/**\n * Splits a batch into array of batches based on cumulative size of its operations by making sure\n * cumulative size of an individual batch is not larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}.\n * If a single operation itself is larger than {@link Constants.DefaultMaxBulkRequestBodySizeInBytes}, that\n * operation would be moved into a batch containing only that operation.\n * @param originalBatch - A batch of operations needed to be checked.\n * @returns\n * @hidden\n */\nexport function splitBatchBasedOnBodySize(originalBatch: Batch): Batch[] {\n  if (originalBatch?.operations === undefined || originalBatch.operations.length < 1) return [];\n  let currentBatchSize = calculateObjectSizeInBytes(originalBatch.operations[0]);\n  let currentBatch: Batch = {\n    ...originalBatch,\n    operations: [originalBatch.operations[0]],\n    indexes: [originalBatch.indexes[0]],\n  };\n  const processedBatches: Batch[] = [];\n  processedBatches.push(currentBatch);\n\n  for (let index = 1; index < originalBatch.operations.length; index++) {\n    const operation = originalBatch.operations[index];\n    const currentOpSize = calculateObjectSizeInBytes(operation);\n    if (currentBatchSize + currentOpSize > Constants.DefaultMaxBulkRequestBodySizeInBytes) {\n      currentBatch = {\n        ...originalBatch,\n        operations: [],\n        indexes: [],\n      };\n      processedBatches.push(currentBatch);\n      currentBatchSize = 0;\n    }\n    currentBatch.operations.push(operation);\n    currentBatch.indexes.push(originalBatch.indexes[index]);\n    currentBatchSize += currentOpSize;\n  }\n  return processedBatches;\n}\n\n/**\n * Calculates size of an JSON object in bytes with utf-8 encoding.\n * @hidden\n */\nexport function calculateObjectSizeInBytes(obj: unknown): number {\n  return new TextEncoder().encode(bodyFromData(obj as any)).length;\n}\n\nexport function decorateBatchOperation(\n  operation: OperationInput,\n  options: RequestOptions = {},\n): Operation {\n  if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operation.resourceBody.id = randomUUID();\n    }\n  }\n  return operation as Operation;\n}\n\nexport function isSuccessStatusCode(statusCode: StatusCode): boolean {\n  return statusCode >= 200 && statusCode <= 299;\n}\n\nexport type ExecuteCallback = (\n  operations: ItemOperation[],\n  diagnosticNode: DiagnosticNodeInternal,\n) => Promise<BulkResponse>;\nexport type RetryCallback = (\n  operation: ItemOperation,\n  diagnosticNode: DiagnosticNodeInternal,\n) => Promise<void>;\n\nexport class TaskCompletionSource<T> {\n  private readonly promise: Promise<T>;\n  private resolveFn!: (value: T) => void;\n  private rejectFn!: (reason?: any) => void;\n\n  constructor() {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this.resolveFn = resolve;\n      this.rejectFn = reject;\n    });\n  }\n\n  public get task(): Promise<T> {\n    return this.promise;\n  }\n\n  public setResult(value: T): void {\n    this.resolveFn(value);\n  }\n\n  public setException(error: Error): void {\n    this.rejectFn(error);\n  }\n}\n\nexport async function encryptOperationInput(\n  encryptionProcessor: EncryptionProcessor,\n  operation: OperationInput,\n  totalPropertiesEncryptedCount: number,\n): Promise<{ operation: OperationInput; totalPropertiesEncryptedCount: number }> {\n  if (Object.prototype.hasOwnProperty.call(operation, \"partitionKey\")) {\n    const partitionKeyInternal = convertToInternalPartitionKey(operation.partitionKey);\n    const { partitionKeyList, encryptedCount } =\n      await encryptionProcessor.getEncryptedPartitionKeyValue(partitionKeyInternal);\n    operation.partitionKey = partitionKeyList;\n    totalPropertiesEncryptedCount += encryptedCount;\n  }\n  switch (operation.operationType) {\n    case BulkOperationType.Create:\n    case BulkOperationType.Upsert: {\n      const { body, propertiesEncryptedCount } = await encryptionProcessor.encrypt(\n        operation.resourceBody,\n      );\n      operation.resourceBody = body;\n      totalPropertiesEncryptedCount += propertiesEncryptedCount;\n      break;\n    }\n    case BulkOperationType.Read:\n    case BulkOperationType.Delete:\n      if (await encryptionProcessor.isPathEncrypted(\"/id\")) {\n        operation.id = await encryptionProcessor.getEncryptedId(operation.id);\n        totalPropertiesEncryptedCount++;\n      }\n      break;\n    case BulkOperationType.Replace: {\n      if (await encryptionProcessor.isPathEncrypted(\"/id\")) {\n        operation.id = await encryptionProcessor.getEncryptedId(operation.id);\n        totalPropertiesEncryptedCount++;\n      }\n      const { body, propertiesEncryptedCount } = await encryptionProcessor.encrypt(\n        operation.resourceBody,\n      );\n      operation.resourceBody = body;\n      totalPropertiesEncryptedCount += propertiesEncryptedCount;\n      break;\n    }\n    case BulkOperationType.Patch: {\n      if (await encryptionProcessor.isPathEncrypted(\"/id\")) {\n        operation.id = await encryptionProcessor.getEncryptedId(operation.id);\n        totalPropertiesEncryptedCount++;\n      }\n      const body = operation.resourceBody;\n      const patchRequestBody = Array.isArray(body) ? body : body.operations;\n      for (const patchOperation of patchRequestBody) {\n        if (\"value\" in patchOperation) {\n          if (await encryptionProcessor.isPathEncrypted(patchOperation.path)) {\n            patchOperation.value = await encryptionProcessor.encryptProperty(\n              patchOperation.path,\n              patchOperation.value,\n            );\n            totalPropertiesEncryptedCount++;\n          }\n        }\n      }\n      break;\n    }\n  }\n  return { operation, totalPropertiesEncryptedCount };\n}\n"]}