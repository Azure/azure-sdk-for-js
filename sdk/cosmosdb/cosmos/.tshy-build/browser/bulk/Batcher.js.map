{"version":3,"file":"Batcher.js","sourceRoot":"","sources":["../../../src/bulk/Batcher.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,SAAS,EAAE,MAAM,wBAAwB,CAAC;AACnD,OAAO,EAAE,WAAW,EAAE,MAAM,0BAA0B,CAAC;AAEvD,OAAO,EACL,sBAAsB,EACtB,kBAAkB,GACnB,MAAM,0CAA0C,CAAC;AAGlD,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAC;AAE5C,OAAO,EAAE,0BAA0B,EAAE,MAAM,mBAAmB,CAAC;AAC/D,OAAO,EAAE,uBAAuB,EAAE,MAAM,kBAAkB,CAAC;AAK3D;;;;GAIG;AAEH,MAAM,OAAO,OAAO;IAalB,YACE,OAAqB,EACrB,QAAyB,EACzB,OAAsB,EACtB,eAAwC,EACxC,iBAA0B,EAC1B,YAAoC,EACpC,mBAAwC,EACxC,0BAA6C;QAE7C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;QAC9B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;QAC3C,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;QAC/C,IAAI,CAAC,uBAAuB,GAAG,YAAY,CAAC;QAC5C,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;QACrB,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;QAC5B,IAAI,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;IAC/D,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,SAAwB;QACpC,IAAI,IAAI,CAAC,cAAc,EAAE,CAAC;YACxB,OAAO,KAAK,CAAC;QACf,CAAC;QACD,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,MAAM,IAAI,aAAa,CAAC,0BAA0B,CAAC,CAAC;QACtD,CAAC;QACD,IAAI,CAAC,SAAS,CAAC,gBAAgB,EAAE,CAAC;YAChC,MAAM,IAAI,aAAa,CAAC,kCAAkC,CAAC,CAAC;QAC9D,CAAC;QACD,IAAI,IAAI,CAAC,mBAAmB,CAAC,MAAM,KAAK,SAAS,CAAC,sBAAsB,EAAE,CAAC;YACzE,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,oBAAoB,GAAG,0BAA0B,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;QAClF,IACE,IAAI,CAAC,mBAAmB,CAAC,MAAM,GAAG,CAAC;YACnC,IAAI,CAAC,WAAW,GAAG,oBAAoB,GAAG,SAAS,CAAC,oCAAoC,EACxF,CAAC;YACD,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAAC,WAAW,IAAI,oBAAoB,CAAC;QACzC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QACzC,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,OAAO;QACZ,OAAO,IAAI,CAAC,mBAAmB,CAAC,MAAM,KAAK,CAAC,CAAC;IAC/C,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,QAAQ,CAAC,eAAgC;;QACpD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;QAC3B,MAAM,SAAS,GAAG,uBAAuB,EAAE,CAAC;QAC5C,MAAM,cAAc,GAAG,IAAI,sBAAsB,CAC/C,IAAI,CAAC,eAAe,EACpB,kBAAkB,CAAC,aAAa,EAChC,IAAI,CACL,CAAC;QACF,IAAI,CAAC;YACH,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,mBAAmB,EAAE,cAAc,CAAC,CAAC;YAE/E,MAAM,YAAY,GAAG,CAAC,CAAC;YACvB,MAAM,UAAU,GAAG,CAAC,CAAC;YACrB,MAAM,WAAW,GAAG,CAAA,MAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,OAAO,0CAAE,IAAI,CACzC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,WAAW,CAAC,eAAe,CAC5E;gBACC,CAAC,CAAC,YAAY;gBACd,CAAC,CAAC,UAAU,CAAC;YACf,MAAM,YAAY,GAAG,CAAA,MAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,OAAO,0CAAE,IAAI,CAC1C,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,WAAW,CAAC,IAAI,CACjE;gBACC,CAAC,CAAC,IAAI;gBACN,CAAC,CAAC,KAAK,CAAC;YACV,IAAI,YAAY,EAAE,CAAC;gBACjB,MAAM,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;YACrE,CAAC;YACD,eAAe,CAAC,GAAG,CACjB,IAAI,CAAC,mBAAmB,CAAC,MAAM,EAC/B,uBAAuB,EAAE,GAAG,SAAS,EACrC,WAAW,CACZ,CAAC;YACF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACpD,MAAM,SAAS,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBACzC,MAAM,mBAAmB,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;gBAChD,IAAI,mBAAmB,YAAY,aAAa,EAAE,CAAC;oBACjD,MAAM,WAAW,GAAG,MAAM,SAAS,CAAC,gBAAgB,CAAC,WAAW,CAAC,WAAW,CAC1E,mBAAmB,EACnB,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAC1C,CAAC;oBACF,IAAI,WAAW,EAAE,CAAC;wBAChB,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAC,CAAC;wBACzE,SAAS;oBACX,CAAC;gBACH,CAAC;gBACD,IAAI,CAAC;oBACH,IAAI,IAAI,CAAC,iBAAiB,IAAI,mBAAmB,CAAC,YAAY,EAAE,CAAC;wBAC/D,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAC,0BAA0B,CAClE,SAAS,CAAC,UAAU,CAAC,2BAA2B,CACjD,CAAC;wBACF,MAAM,EAAE,IAAI,EAAE,aAAa,EAAE,wBAAwB,EAAE,GACrD,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAC;wBAC3E,mBAAmB,CAAC,YAAY,GAAG,aAAa,CAAC;wBACjD,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAC,wBAAwB,CAChE,SAAS,CAAC,UAAU,CAAC,2BAA2B,EAChD,wBAAwB,CACzB,CAAC;oBACJ,CAAC;gBACH,CAAC;gBAAC,OAAO,KAAK,EAAE,CAAC;oBACf,sGAAsG;oBACtG,IAAI,SAAS,CAAC,cAAc,CAAC,aAAa,KAAK,MAAM,EAAE,CAAC;wBACtD,MAAM,eAAe,GAAG,IAAI,aAAa,CACvC,QAAQ,SAAS,CAAC,cAAc,CAAC,aAAa,+DAA+D,KAAK,CAAC,OAAO,EAAE,CAC7H,CAAC;wBACF,eAAe,CAAC,IAAI,GAAG,WAAW,CAAC,kBAAkB,CAAC;wBACtD,MAAM,eAAe,CAAC;oBACxB,CAAC;gBACH,CAAC;gBACD,SAAS,CAAC,gBAAgB,CAAC,kBAAkB,CAAC,cAAc,CAAC,CAAC;gBAC9D,mBAAmB,CAAC,WAAW,GAAG,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAC,YAAY,CACtF,IAAI,CAAC,uBAAuB,CAC7B,CAAC;gBACF,MAAM,gBAAgB,GAAwB;oBAC5C,cAAc,EAAE,SAAS,CAAC,yBAAyB;iBACpD,CAAC;gBACF,IAAI,mBAAmB,YAAY,aAAa,EAAE,CAAC;oBACjD,gBAAgB,CAAC,KAAK,GAAG,mBAAmB,CAAC;gBAC/C,CAAC;qBAAM,CAAC;oBACN,gBAAgB,CAAC,QAAQ,GAAG,mBAAmB,CAAC;gBAClD,CAAC;gBACD,SAAS,CAAC,gBAAgB,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC;gBACtD,IAAI,CAAC,0BAA0B,CAAC,KAAK,EAAE,CAAC;YAC1C,CAAC;QACH,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,6CAA6C;YAC7C,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBACjD,MAAM,QAAQ,GAAwB;oBACpC,cAAc,EAAE,SAAS,CAAC,cAAc;oBACxC,KAAK,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,aAAa,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;wBACrD,IAAI,EAAE,WAAW,CAAC,mBAAmB;wBACrC,WAAW,EAAE,SAAS,CAAC,gBAAgB,CAAC,cAAc,CAAC,YAAY,CACjE,IAAI,CAAC,uBAAuB,CAC7B;qBACF,CAAC;iBACH,CAAC;gBACF,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBAC1C,IAAI,CAAC,0BAA0B,CAAC,KAAK,EAAE,CAAC;YAC1C,CAAC;QACH,CAAC;gBAAS,CAAC;YACT,uBAAuB;YACvB,IAAI,CAAC,mBAAmB,GAAG,EAAE,CAAC;QAChC,CAAC;IACH,CAAC;IAEM,aAAa;QAClB,OAAO,IAAI,CAAC,mBAAmB,CAAC;IAClC,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { Constants } from \"../common/constants.js\";\nimport { StatusCodes } from \"../common/statusCodes.js\";\nimport type { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel.js\";\nimport {\n  DiagnosticNodeInternal,\n  DiagnosticNodeType,\n} from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport type { EncryptionProcessor } from \"../encryption/EncryptionProcessor.js\";\nimport type { ClientConfigDiagnostic } from \"../index.js\";\nimport { ErrorResponse } from \"../index.js\";\nimport type { ExecuteCallback, RetryCallback, BulkOperationResult } from \"../utils/batch.js\";\nimport { calculateObjectSizeInBytes } from \"../utils/batch.js\";\nimport { getCurrentTimestampInMs } from \"../utils/time.js\";\nimport type { PartitionMetric } from \"./PartitionMetric.js\";\nimport type { ItemOperation } from \"./index.js\";\nimport type { LimiterQueue } from \"./Limiter.js\";\n\n/**\n * Maintains a batch of operations and dispatches it as a unit of work.\n * Execution of the request is done by the @see {@link ExecuteCallback} and retry is done by the @see {@link RetryCallback}.\n * @hidden\n */\n\nexport class Batcher {\n  private batchOperationsList: ItemOperation[];\n  private currentSize: number;\n  private toBeDispatched: boolean;\n  private readonly executor: ExecuteCallback;\n  private readonly retrier: RetryCallback;\n  private readonly diagnosticLevel: CosmosDbDiagnosticLevel;\n  private readonly encryptionEnabled: boolean;\n  private readonly encryptionProcessor: EncryptionProcessor;\n  private readonly clientConfigDiagnostics: ClientConfigDiagnostic;\n  private readonly limiter: LimiterQueue;\n  private processedOperationCountRef: { count: number };\n\n  constructor(\n    limiter: LimiterQueue,\n    executor: ExecuteCallback,\n    retrier: RetryCallback,\n    diagnosticLevel: CosmosDbDiagnosticLevel,\n    encryptionEnabled: boolean,\n    clientConfig: ClientConfigDiagnostic,\n    encryptionProcessor: EncryptionProcessor,\n    processedOperationCountRef: { count: number },\n  ) {\n    this.limiter = limiter;\n    this.batchOperationsList = [];\n    this.executor = executor;\n    this.retrier = retrier;\n    this.diagnosticLevel = diagnosticLevel;\n    this.encryptionEnabled = encryptionEnabled;\n    this.encryptionProcessor = encryptionProcessor;\n    this.clientConfigDiagnostics = clientConfig;\n    this.currentSize = 0;\n    this.toBeDispatched = false;\n    this.processedOperationCountRef = processedOperationCountRef;\n  }\n\n  /**\n   * Attempts to add an operation to the current batch.\n   * Returns false if the batch is full or already dispatched.\n   */\n  public tryAdd(operation: ItemOperation): boolean {\n    if (this.toBeDispatched) {\n      return false;\n    }\n    if (!operation) {\n      throw new ErrorResponse(\"Operation is not defined\");\n    }\n    if (!operation.operationContext) {\n      throw new ErrorResponse(\"Operation context is not defined\");\n    }\n    if (this.batchOperationsList.length === Constants.MaxBulkOperationsCount) {\n      return false;\n    }\n    const currentOperationSize = calculateObjectSizeInBytes(operation.operationInput);\n    if (\n      this.batchOperationsList.length > 0 &&\n      this.currentSize + currentOperationSize > Constants.DefaultMaxBulkRequestBodySizeInBytes\n    ) {\n      return false;\n    }\n\n    this.currentSize += currentOperationSize;\n    this.batchOperationsList.push(operation);\n    return true;\n  }\n\n  public isEmpty(): boolean {\n    return this.batchOperationsList.length === 0;\n  }\n\n  /**\n   * Dispatches the current batch of operations.\n   * Handles retries for failed operations and updates the ordered response.\n   */\n  public async dispatch(partitionMetric: PartitionMetric): Promise<void> {\n    this.toBeDispatched = true;\n    const startTime = getCurrentTimestampInMs();\n    const diagnosticNode = new DiagnosticNodeInternal(\n      this.diagnosticLevel,\n      DiagnosticNodeType.BATCH_REQUEST,\n      null,\n    );\n    try {\n      const response = await this.executor(this.batchOperationsList, diagnosticNode);\n\n      const hasThrottles = 1;\n      const noThrottle = 0;\n      const numThrottle = response?.results?.some(\n        (result) => \"code\" in result && result.code === StatusCodes.TooManyRequests,\n      )\n        ? hasThrottles\n        : noThrottle;\n      const splitOrMerge = response?.results?.some(\n        (result) => \"code\" in result && result.code === StatusCodes.Gone,\n      )\n        ? true\n        : false;\n      if (splitOrMerge) {\n        await this.limiter.pauseAndClear(StatusCodes.Gone, diagnosticNode);\n      }\n      partitionMetric.add(\n        this.batchOperationsList.length,\n        getCurrentTimestampInMs() - startTime,\n        numThrottle,\n      );\n      for (let i = 0; i < response.operations.length; i++) {\n        const operation = response.operations[i];\n        const bulkOperationResult = response.results[i];\n        if (bulkOperationResult instanceof ErrorResponse) {\n          const shouldRetry = await operation.operationContext.retryPolicy.shouldRetry(\n            bulkOperationResult,\n            operation.operationContext.diagnosticNode,\n          );\n          if (shouldRetry) {\n            await this.retrier(operation, operation.operationContext.diagnosticNode);\n            continue;\n          }\n        }\n        try {\n          if (this.encryptionEnabled && bulkOperationResult.resourceBody) {\n            operation.operationContext.diagnosticNode.beginEncryptionDiagnostics(\n              Constants.Encryption.DiagnosticsDecryptOperation,\n            );\n            const { body: decryptedBody, propertiesDecryptedCount } =\n              await this.encryptionProcessor.decrypt(bulkOperationResult.resourceBody);\n            bulkOperationResult.resourceBody = decryptedBody;\n            operation.operationContext.diagnosticNode.endEncryptionDiagnostics(\n              Constants.Encryption.DiagnosticsDecryptOperation,\n              propertiesDecryptedCount,\n            );\n          }\n        } catch (error) {\n          // if decryption fails after successful write operation, fail the operation with internal server error\n          if (operation.operationInput.operationType !== \"Read\") {\n            const decryptionError = new ErrorResponse(\n              `Item ${operation.operationInput.operationType} operation was successful but response decryption failed: + ${error.message}`,\n            );\n            decryptionError.code = StatusCodes.ServiceUnavailable;\n            throw decryptionError;\n          }\n        }\n        operation.operationContext.addDiagnosticChild(diagnosticNode);\n        bulkOperationResult.diagnostics = operation.operationContext.diagnosticNode.toDiagnostic(\n          this.clientConfigDiagnostics,\n        );\n        const bulkItemResponse: BulkOperationResult = {\n          operationInput: operation.unencryptedOperationInput,\n        };\n        if (bulkOperationResult instanceof ErrorResponse) {\n          bulkItemResponse.error = bulkOperationResult;\n        } else {\n          bulkItemResponse.response = bulkOperationResult;\n        }\n        operation.operationContext.complete(bulkItemResponse);\n        this.processedOperationCountRef.count++;\n      }\n    } catch (error) {\n      // Mark all operations in the batch as failed\n      for (const operation of this.batchOperationsList) {\n        const response: BulkOperationResult = {\n          operationInput: operation.operationInput,\n          error: Object.assign(new ErrorResponse(error.message), {\n            code: StatusCodes.InternalServerError,\n            diagnostics: operation.operationContext.diagnosticNode.toDiagnostic(\n              this.clientConfigDiagnostics,\n            ),\n          }),\n        };\n        operation.operationContext.fail(response);\n        this.processedOperationCountRef.count++;\n      }\n    } finally {\n      // Clean up batch state\n      this.batchOperationsList = [];\n    }\n  }\n\n  public getOperations(): ItemOperation[] {\n    return this.batchOperationsList;\n  }\n}\n"]}