{"version":3,"file":"changeFeedUtils.js","sourceRoot":"","sources":["../../../../src/client/ChangeFeed/changeFeedUtils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ChangeFeedIteratorOptions } from \"./ChangeFeedIteratorOptions.js\";\nimport { ErrorResponse } from \"../../request/index.js\";\nimport type { PartitionKeyRange } from \"../Container/index.js\";\nimport type { InternalChangeFeedIteratorOptions } from \"./InternalChangeFeedOptions.js\";\nimport { isPrimitivePartitionKeyValue } from \"../../utils/typeChecks.js\";\nimport type { ChangeFeedStartFrom } from \"./ChangeFeedStartFrom.js\";\nimport { ChangeFeedStartFromBeginning } from \"./ChangeFeedStartFromBeginning.js\";\nimport { Constants } from \"../../common/index.js\";\nimport { ChangeFeedStartFromTime } from \"./ChangeFeedStartFromTime.js\";\nimport { QueryRange } from \"../../routing/index.js\";\nimport { FeedRangeInternal } from \"./FeedRange.js\";\nimport { hashV2PartitionKey } from \"../../utils/hashing/v2.js\";\nimport { PartitionKeyInternal } from \"../../documents/PartitionKeyInternal.js\";\nimport { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal.js\";\nimport { EncryptionProcessor } from \"../../encryption/index.js\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode.js\";\nimport { ChangeFeedIteratorResponse } from \"./ChangeFeedIteratorResponse.js\";\n\n/**\n * @hidden\n * Validates the change feed options passed by the user\n */\nexport function validateChangeFeedIteratorOptions(options: ChangeFeedIteratorOptions): void {\n  if (!isChangeFeedIteratorOptions(options)) {\n    throw new ErrorResponse(\"Invalid Changefeed Iterator Options.\");\n  }\n  if (options?.maxItemCount && typeof options?.maxItemCount !== \"number\") {\n    throw new ErrorResponse(\"maxItemCount must be number\");\n  }\n  if (options?.maxItemCount !== undefined && options?.maxItemCount < 1) {\n    throw new ErrorResponse(\"maxItemCount must be a positive number\");\n  }\n}\n\nfunction isChangeFeedIteratorOptions(options: unknown): options is ChangeFeedIteratorOptions {\n  if (typeof options !== \"object\") {\n    return false;\n  }\n  if (Object.keys(options).length === 0 && JSON.stringify(options) === \"{}\") {\n    return true;\n  }\n  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));\n}\n\n/**\n * @hidden\n * Checks if pkRange entirely covers the given overLapping range or there is only partial overlap.\n *\n * If no complete overlap, exact range which overlaps is retured which is used to set minEpk and maxEpk headers while quering change feed.\n */\nexport async function extractOverlappingRanges(\n  epkRange: QueryRange,\n  overLappingRange: PartitionKeyRange,\n): Promise<[string, string]> {\n  if (\n    overLappingRange.minInclusive >= epkRange.min &&\n    overLappingRange.maxExclusive <= epkRange.max\n  ) {\n    return [undefined, undefined];\n  } else if (\n    overLappingRange.minInclusive <= epkRange.min &&\n    overLappingRange.maxExclusive >= epkRange.max\n  ) {\n    return [epkRange.min, epkRange.max];\n  }\n  // Right Side of overlapping range is covered\n  else if (\n    overLappingRange.minInclusive <= epkRange.min &&\n    overLappingRange.maxExclusive <= epkRange.max &&\n    overLappingRange.maxExclusive >= epkRange.min\n  ) {\n    return [epkRange.min, overLappingRange.maxExclusive];\n  }\n  // Left Side of overlapping range is covered\n  else {\n    return [overLappingRange.minInclusive, epkRange.max];\n  }\n}\n\n/**\n * @hidden\n * Checks if the object is a valid EpkRange\n */\nexport function isEpkRange(obj: unknown): boolean {\n  return (\n    obj instanceof FeedRangeInternal &&\n    typeof obj.minInclusive === \"string\" &&\n    typeof obj.maxExclusive === \"string\" &&\n    obj.minInclusive >=\n      Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey &&\n    obj.maxExclusive <=\n      Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey &&\n    obj.maxExclusive > obj.minInclusive\n  );\n}\n\n/**\n * @hidden\n */\nexport function buildInternalChangeFeedOptions(\n  options: ChangeFeedIteratorOptions,\n  continuationToken?: string,\n  startTime?: Date,\n  startFromNow?: boolean,\n): InternalChangeFeedIteratorOptions {\n  const internalCfOptions = {} as InternalChangeFeedIteratorOptions;\n  internalCfOptions.maxItemCount = options?.maxItemCount;\n  internalCfOptions.sessionToken = options?.sessionToken;\n  internalCfOptions.continuationToken = continuationToken;\n  internalCfOptions.changeFeedMode = options?.changeFeedMode;\n  // Default option of changefeed is to start from now.\n  if (startFromNow) {\n    internalCfOptions.startFromNow = true;\n  } else {\n    internalCfOptions.startTime = startTime;\n  }\n  return internalCfOptions;\n}\n/**\n * @hidden\n */\nexport function fetchStartTime(changeFeedStartFrom: ChangeFeedStartFrom): Date | undefined {\n  if (changeFeedStartFrom instanceof ChangeFeedStartFromBeginning) {\n    return undefined;\n  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromTime) {\n    return changeFeedStartFrom.getStartTime();\n  }\n}\n\n/**\n * @hidden\n */\nexport function isNullOrEmpty(text: string | null | undefined): boolean {\n  return text === null || text === undefined || text.trim() === \"\";\n}\n\n/**\n * @hidden\n */\nexport async function getEPKRangeForPrefixPartitionKey(\n  internalPartitionKey: PartitionKeyInternal,\n): Promise<QueryRange> {\n  const minEPK = getEffectivePartitionKeyForMultiHashPartitioning(internalPartitionKey);\n  const maxEPK =\n    minEPK + Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey;\n  return new QueryRange(minEPK, maxEPK, true, false);\n}\n\n/**\n * @hidden\n */\nexport function getEffectivePartitionKeyForMultiHashPartitioning(\n  partitionKeyInternal: PartitionKeyInternal,\n): string {\n  const hashArray = partitionKeyInternal.map((item) => hashV2PartitionKey([item]));\n  return hashArray.join(\"\");\n}\n\n/**\n * @hidden\n */\nexport async function decryptChangeFeedResponse(\n  result: ChangeFeedIteratorResponse<any>,\n  diagnosticNode: DiagnosticNodeInternal,\n  changeFeedMode: ChangeFeedMode,\n  encryptionProcessor: EncryptionProcessor,\n): Promise<void> {\n  let count = 0;\n  diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation);\n  for (let item of result.result) {\n    if (changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes) {\n      if (\"current\" in item && item.current !== null) {\n        const { body, propertiesDecryptedCount } = await encryptionProcessor.decrypt(item.current);\n        item.current = body;\n        count += propertiesDecryptedCount;\n      }\n      if (\"previous\" in item && item.previous !== null) {\n        const { body, propertiesDecryptedCount } = await encryptionProcessor.decrypt(item.previous);\n        item.previous = body;\n        count += propertiesDecryptedCount;\n      }\n    } else {\n      const { body, propertiesDecryptedCount } = await encryptionProcessor.decrypt(item);\n      item = body;\n      count += propertiesDecryptedCount;\n    }\n  }\n  diagnosticNode.endEncryptionDiagnostics(Constants.Encryption.DiagnosticsDecryptOperation, count);\n}\n"]}