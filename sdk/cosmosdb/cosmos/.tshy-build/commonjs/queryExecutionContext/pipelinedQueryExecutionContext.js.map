{"version":3,"file":"pipelinedQueryExecutionContext.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/pipelinedQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { ClientContext } from \"../ClientContext.js\";\nimport type { Response, FeedOptions } from \"../request/index.js\";\nimport type { PartitionedQueryExecutionInfo, QueryInfo } from \"../request/ErrorResponse.js\";\nimport { ErrorResponse } from \"../request/ErrorResponse.js\";\nimport type { CosmosHeaders } from \"./CosmosHeaders.js\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent.js\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent.js\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent.js\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent.js\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent.js\";\nimport type { ExecutionContext } from \"./ExecutionContext.js\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils.js\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext.js\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext.js\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent.js\";\nimport type { SqlQuerySpec } from \"./SqlQuerySpec.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport { NonStreamingOrderByDistinctEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByDistinctEndpointComponent.js\";\nimport { NonStreamingOrderByEndpointComponent } from \"./EndpointComponent/NonStreamingOrderByEndpointComponent.js\";\n\n/** @hidden */\nexport class PipelinedQueryExecutionContext implements ExecutionContext {\n  private fetchBuffer: any[];\n  private fetchMoreRespHeaders: CosmosHeaders;\n  private endpoint: ExecutionContext;\n  private pageSize: number;\n  private vectorSearchBufferSize: number = 0;\n  private static DEFAULT_PAGE_SIZE = 10;\n  private static DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE = 50000;\n  private nonStreamingOrderBy = false;\n\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: string | SqlQuerySpec,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo,\n    correlatedActivityId: string,\n    private emitRawOrderByPayload: boolean = false,\n  ) {\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n    // Pick between Nonstreaming and streaming endpoints\n    this.nonStreamingOrderBy = partitionedQueryExecutionInfo.queryInfo.hasNonStreamingOrderBy;\n\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    // TODO: Currently we don't get any field from backend to determine streaming queries\n    if (this.nonStreamingOrderBy) {\n      if (!options.allowUnboundedNonStreamingQueries) {\n        this.checkQueryConstraints(partitionedQueryExecutionInfo.queryInfo);\n      }\n\n      this.vectorSearchBufferSize = this.calculateVectorSearchBufferSize(\n        partitionedQueryExecutionInfo.queryInfo,\n        options,\n      );\n      const maxBufferSize = options[\"vectorSearchBufferSize\"]\n        ? options[\"vectorSearchBufferSize\"]\n        : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n\n      if (this.vectorSearchBufferSize > maxBufferSize) {\n        throw new ErrorResponse(\n          `Executing a vector search query with TOP or OFFSET + LIMIT value ${this.vectorSearchBufferSize} larger than the vectorSearchBufferSize ${maxBufferSize} ` +\n            `is not allowed`,\n        );\n      }\n\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      const context: ExecutionContext = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        this.query,\n        this.options,\n        this.partitionedQueryExecutionInfo,\n        correlatedActivityId,\n      );\n\n      if (distinctType === \"None\") {\n        this.endpoint = new NonStreamingOrderByEndpointComponent(\n          context,\n          sortOrders,\n          this.vectorSearchBufferSize,\n          partitionedQueryExecutionInfo.queryInfo.offset,\n          this.emitRawOrderByPayload,\n        );\n      } else {\n        this.endpoint = new NonStreamingOrderByDistinctEndpointComponent(\n          context,\n          partitionedQueryExecutionInfo.queryInfo,\n          this.vectorSearchBufferSize,\n          this.emitRawOrderByPayload,\n        );\n      }\n    } else {\n      if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n        // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n        //      \"payload\" property.\n        this.endpoint = new OrderByEndpointComponent(\n          new OrderByQueryExecutionContext(\n            this.clientContext,\n            this.collectionLink,\n            this.query,\n            this.options,\n            this.partitionedQueryExecutionInfo,\n            correlatedActivityId,\n          ),\n          this.emitRawOrderByPayload,\n        );\n      } else {\n        this.endpoint = new ParallelQueryExecutionContext(\n          this.clientContext,\n          this.collectionLink,\n          this.query,\n          this.options,\n          this.partitionedQueryExecutionInfo,\n          correlatedActivityId,\n        );\n      }\n      if (\n        Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length >\n          0 ||\n        partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 ||\n        partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0\n      ) {\n        if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n          this.endpoint = new GroupByValueEndpointComponent(\n            this.endpoint,\n            partitionedQueryExecutionInfo.queryInfo,\n          );\n        } else {\n          this.endpoint = new GroupByEndpointComponent(\n            this.endpoint,\n            partitionedQueryExecutionInfo.queryInfo,\n          );\n        }\n      }\n\n      // If distinct then add that to the pipeline\n      const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n      if (distinctType === \"Ordered\") {\n        this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n      }\n      if (distinctType === \"Unordered\") {\n        this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n      }\n\n      // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n      const top = partitionedQueryExecutionInfo.queryInfo.top;\n      if (typeof top === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n      }\n\n      // If offset+limit then add that to the pipeline\n      const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n      const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n      if (typeof limit === \"number\" && typeof offset === \"number\") {\n        this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n      }\n    }\n    this.fetchBuffer = [];\n  }\n\n  public hasMoreResults(): boolean {\n    return this.fetchBuffer.length !== 0 || this.endpoint.hasMoreResults();\n  }\n\n  public async fetchMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    this.fetchMoreRespHeaders = getInitialHeader();\n    return this._fetchMoreImplementation(diagnosticNode);\n  }\n\n  private async _fetchMoreImplementation(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<Response<any>> {\n    try {\n      if (this.fetchBuffer.length >= this.pageSize) {\n        const temp = this.fetchBuffer.slice(0, this.pageSize);\n        this.fetchBuffer = this.fetchBuffer.slice(this.pageSize);\n        return { result: temp, headers: this.fetchMoreRespHeaders };\n      } else {\n        const response = await this.endpoint.fetchMore(diagnosticNode);\n        mergeHeaders(this.fetchMoreRespHeaders, response.headers);\n        if (response === undefined || response.result === undefined) {\n          if (this.fetchBuffer.length > 0) {\n            const temp = this.fetchBuffer;\n            this.fetchBuffer = [];\n            return { result: temp, headers: this.fetchMoreRespHeaders };\n          } else {\n            return { result: undefined, headers: this.fetchMoreRespHeaders };\n          }\n        }\n        this.fetchBuffer.push(...response.result);\n\n        if (this.options.enableQueryControl) {\n          if (this.fetchBuffer.length >= this.pageSize) {\n            const temp = this.fetchBuffer.slice(0, this.pageSize);\n            this.fetchBuffer = this.fetchBuffer.slice(this.pageSize);\n            return { result: temp, headers: this.fetchMoreRespHeaders };\n          } else {\n            const temp = this.fetchBuffer;\n            this.fetchBuffer = [];\n            return { result: temp, headers: this.fetchMoreRespHeaders };\n          }\n        }\n        // Recursively fetch more results to ensure the pageSize number of results are returned\n        // to maintain compatibility with the previous implementation\n        return this._fetchMoreImplementation(diagnosticNode);\n      }\n    } catch (err: any) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n\n  private calculateVectorSearchBufferSize(queryInfo: QueryInfo, options: FeedOptions): number {\n    if (queryInfo.top === 0 || queryInfo.limit === 0) return 0;\n    return queryInfo.top\n      ? queryInfo.top\n      : queryInfo.limit\n        ? queryInfo.offset + queryInfo.limit\n        : options[\"vectorSearchBufferSize\"] && options[\"vectorSearchBufferSize\"] > 0\n          ? options[\"vectorSearchBufferSize\"]\n          : PipelinedQueryExecutionContext.DEFAULT_MAX_VECTOR_SEARCH_BUFFER_SIZE;\n  }\n\n  private checkQueryConstraints(queryInfo: QueryInfo): void {\n    const hasTop = queryInfo.top || queryInfo.top === 0;\n    const hasLimit = queryInfo.limit || queryInfo.limit === 0;\n    if (!hasTop && !hasLimit) {\n      throw new ErrorResponse(\n        \"Executing a non-streaming search query without TOP or LIMIT can consume a large number of RUs \" +\n          \"very fast and have long runtimes. Please ensure you are using one of the above two filters \" +\n          \"with your vector search query.\",\n      );\n    }\n    return;\n  }\n}\n"]}