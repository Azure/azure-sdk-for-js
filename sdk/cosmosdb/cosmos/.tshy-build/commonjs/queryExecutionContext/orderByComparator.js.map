{"version":3,"file":"orderByComparator.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/orderByComparator.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAIlC;;;;GAIG;AACH,MAAM,iBAAiB,GAEnB,MAAM,CAAC,MAAM,CAAC;IAChB,OAAO,EAAE;QACP,GAAG,EAAE,CAAC;KACP;IACD,SAAS,EAAE;QACT,GAAG,EAAE,CAAC;KACP;IACD,OAAO,EAAE;QACP,GAAG,EAAE,CAAC;QACN,QAAQ,EAAE,CAAC,CAAU,EAAE,CAAU,EAAE,EAAE;YACnC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtC,CAAC;KACF;IACD,MAAM,EAAE;QACN,GAAG,EAAE,CAAC;QACN,QAAQ,EAAE,CAAC,CAAS,EAAE,CAAS,EAAE,EAAE;YACjC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtC,CAAC;KACF;IACD,MAAM,EAAE;QACN,GAAG,EAAE,CAAC;QACN,QAAQ,EAAE,CAAC,CAAS,EAAE,CAAS,EAAE,EAAE;YACjC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtC,CAAC;KACF;CACF,CAAC,CAAC;AAEH,cAAc;AACd,MAAa,iBAAiB;IAC5B,YAAmB,SAAmB;QAAnB,cAAS,GAAT,SAAS,CAAU;IAAG,CAAC;IAEnC,YAAY,CAAC,KAAgC,EAAE,KAAgC;QACpF,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QACrD,MAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QAErD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,gBAAgB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACjD,wCAAwC;YACxC,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC;YAClF,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;gBAClB,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,YAAY,EAAE,CAAC;oBACvC,OAAO,OAAO,CAAC;gBACjB,CAAC;qBAAM,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,WAAW,EAAE,CAAC;oBAC7C,OAAO,CAAC,OAAO,CAAC;gBAClB,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAEO,eAAe,CAAC,GAAQ;QAC9B,OAAO,GAAG,CAAC,cAAc,CAAC,CAAC;IAC7B,CAAC;IAEO,kBAAkB,CAAC,YAAiB,EAAE,YAAiB;QAC7D,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QACzC,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QACzC,OAAO,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,YAAY,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,CAAC;IACrF,CAAC;IAEO,OAAO,CACb,WAAgB;QAWhB,kBAAkB;QAClB,IAAI,WAAW,KAAK,SAAS,IAAI,WAAW,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;YAChE,OAAO,SAAS,CAAC;QACnB,CAAC;QACD,MAAM,IAAI,GAAG,OAAO,WAAW,CAAC,IAAI,CAAC;QACrC,IAAI,iBAAiB,CAAC,IAAI,CAAC,KAAK,SAAS,EAAE,CAAC;YAC1C,MAAM,IAAI,KAAK,CAAC,uBAAuB,IAAI,EAAE,CAAC,CAAC;QACjD,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,YAAY,CAAC,KAAc,EAAE,KAAa,EAAE,KAAc,EAAE,KAAa;QAC/E,+DAA+D;QAC/D,0FAA0F;QAE1F,IAAI,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,QAAQ,EAAE,CAAC;YAC7C,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;QACrD,CAAC;QACD,MAAM,QAAQ,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC;QAC9C,MAAM,QAAQ,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC;QAE9C,8EAA8E;QAC9E,MAAM,OAAO,GAAG,QAAQ,GAAG,QAAQ,CAAC;QAEpC,2GAA2G;QAC3G,IAAI,OAAO,KAAK,CAAC,EAAE,CAAC;YAClB,OAAO,OAAO,CAAC;QACjB,CAAC;QAED,4BAA4B;QAC5B,IACE,QAAQ,KAAK,iBAAiB,CAAC,WAAW,CAAC,CAAC,GAAG;YAC/C,QAAQ,KAAK,iBAAiB,CAAC,SAAS,CAAC,CAAC,GAAG,EAC7C,CAAC;YACD,qDAAqD;YACrD,OAAO,CAAC,CAAC;QACX,CAAC;QAED,MAAM,QAAQ,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC;QACnD,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,CAAC;YACpC,MAAM,IAAI,KAAK,CAAC,qCAAqC,CAAC,CAAC;QACzD,CAAC;QACD,kDAAkD;QAClD,OAAO,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAChC,CAAC;CACF;AAvFD,8CAuFC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { NonStreamingOrderByResult } from \"./nonStreamingOrderByResult.js\";\n\n/**\n *  @hidden\n * ord is used to compare different types. Eg. in ascending order, for cross type comparison, boolean will come first, then number and, then string.\n * compFunc is used to compare the same type comparison.\n */\nconst TYPEORDCOMPARATOR: {\n  [type: string]: { ord: number; compFunc?: (a: any, b: any) => number };\n} = Object.freeze({\n  NoValue: {\n    ord: 0,\n  },\n  undefined: {\n    ord: 1,\n  },\n  boolean: {\n    ord: 2,\n    compFunc: (a: boolean, b: boolean) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n  number: {\n    ord: 4,\n    compFunc: (a: number, b: number) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n  string: {\n    ord: 5,\n    compFunc: (a: string, b: string) => {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n  },\n});\n\n/** @hidden */\nexport class OrderByComparator {\n  constructor(public sortOrder: string[]) {}\n\n  public compareItems(item1: NonStreamingOrderByResult, item2: NonStreamingOrderByResult): number {\n    const orderByItemsRes1 = this.getOrderByItems(item1);\n    const orderByItemsRes2 = this.getOrderByItems(item2);\n\n    for (let i = 0; i < orderByItemsRes1.length; i++) {\n      // compares the orderby items one by one\n      const compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);\n      if (compRes !== 0) {\n        if (this.sortOrder[i] === \"Descending\") {\n          return compRes;\n        } else if (this.sortOrder[i] === \"Ascending\") {\n          return -compRes;\n        }\n      }\n    }\n  }\n\n  private getOrderByItems(res: any): any {\n    return res[\"orderByItems\"];\n  }\n\n  private compareOrderByItem(orderByItem1: any, orderByItem2: any): number {\n    const type1 = this.getType(orderByItem1);\n    const type2 = this.getType(orderByItem2);\n    return this.compareValue(orderByItem1[\"item\"], type1, orderByItem2[\"item\"], type2);\n  }\n\n  private getType(\n    orderByItem: any,\n  ):\n    | \"string\"\n    | \"number\"\n    | \"bigint\"\n    | \"boolean\"\n    | \"symbol\"\n    | \"undefined\"\n    | \"object\"\n    | \"function\"\n    | \"NoValue\" {\n    // TODO: any item?\n    if (orderByItem === undefined || orderByItem.item === undefined) {\n      return \"NoValue\";\n    }\n    const type = typeof orderByItem.item;\n    if (TYPEORDCOMPARATOR[type] === undefined) {\n      throw new Error(`unrecognizable type ${type}`);\n    }\n    return type;\n  }\n\n  private compareValue(item1: unknown, type1: string, item2: unknown, type2: string): number {\n    // TODO: https://github.com/Azure/azure-sdk-for-js/issues/30122\n    // currently we do not support same type and cross type comparision for object and arrays.\n\n    if (type1 === \"object\" || type2 === \"object\") {\n      throw new Error(\"Tried to compare an object type\");\n    }\n    const type1Ord = TYPEORDCOMPARATOR[type1].ord;\n    const type2Ord = TYPEORDCOMPARATOR[type2].ord;\n\n    // Validate if the two item are of same type or not based on the type ordinal.\n    const typeCmp = type1Ord - type2Ord;\n\n    // if not same type, compare based on the type ordinal. Lower ordinal takes precedence over higher ordinal.\n    if (typeCmp !== 0) {\n      return typeCmp;\n    }\n\n    // both are of the same type\n    if (\n      type1Ord === TYPEORDCOMPARATOR[\"undefined\"].ord ||\n      type1Ord === TYPEORDCOMPARATOR[\"NoValue\"].ord\n    ) {\n      // if both types are undefined or Null they are equal\n      return 0;\n    }\n\n    const compFunc = TYPEORDCOMPARATOR[type1].compFunc;\n    if (typeof compFunc === \"undefined\") {\n      throw new Error(\"Cannot find the comparison function\");\n    }\n    // same type and type is defined compare the items\n    return compFunc(item1, item2);\n  }\n}\n"]}