{"version":3,"file":"defaultQueryExecutionContext.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/defaultQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { AzureLogger } from \"@azure/logger\";\nimport { createClientLogger } from \"@azure/logger\";\nimport { Constants } from \"../common/index.js\";\nimport { ClientSideMetrics, QueryMetrics } from \"../queryMetrics/index.js\";\nimport type { FeedOptions, Response } from \"../request/index.js\";\nimport { getInitialHeader } from \"./headerUtils.js\";\nimport type { ExecutionContext } from \"./index.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport { DiagnosticNodeType } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport { addDiagnosticChild } from \"../utils/diagnostics.js\";\nimport { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel.js\";\n\nconst logger: AzureLogger = createClientLogger(\"ClientContext\");\n/** @hidden */\nexport type FetchFunctionCallback = (\n  diagnosticNode: DiagnosticNodeInternal,\n  options: FeedOptions,\n  correlatedActivityId: string,\n) => Promise<Response<any>>;\n\n/** @hidden */\nenum STATES {\n  start = \"start\",\n  inProgress = \"inProgress\",\n  ended = \"ended\",\n}\n\n/** @hidden */\nexport class DefaultQueryExecutionContext implements ExecutionContext {\n  private static readonly STATES = STATES;\n  private resources: any[]; // TODO: any resources\n  private currentIndex: number;\n  private currentPartitionIndex: number;\n  private fetchFunctions: FetchFunctionCallback[];\n  private options: FeedOptions; // TODO: any options\n  public continuationToken: string; // TODO: any continuation\n  public get continuation(): string {\n    return this.continuationToken;\n  }\n  private state: STATES;\n  private nextFetchFunction: Promise<Response<any>>;\n  private correlatedActivityId: string;\n  /**\n   * Provides the basic Query Execution Context.\n   * This wraps the internal logic query execution using provided fetch functions\n   *\n   * @param clientContext  - Is used to read the partitionKeyRanges for split proofing\n   * @param query          - A SQL query.\n   * @param options        - Represents the feed options.\n   * @param fetchFunctions - A function to retrieve each page of data.\n   *                          An array of functions may be used to query more than one partition.\n   * @hidden\n   */\n  constructor(\n    options: FeedOptions,\n    fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n    correlatedActivityId: string,\n  ) {\n    this.resources = [];\n    this.currentIndex = 0;\n    this.currentPartitionIndex = 0;\n    this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];\n    this.options = options || {};\n    this.continuationToken = this.options.continuationToken || this.options.continuation || null;\n    this.state = DefaultQueryExecutionContext.STATES.start;\n    this.correlatedActivityId = correlatedActivityId;\n  }\n\n  /**\n   * Execute a provided callback on the next element in the execution context.\n   */\n  public async nextItem(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    ++this.currentIndex;\n    const response = await this.current(diagnosticNode);\n    return response;\n  }\n\n  /**\n   * Retrieve the current element on the execution context.\n   */\n  public async current(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    if (this.currentIndex < this.resources.length) {\n      return {\n        result: this.resources[this.currentIndex],\n        headers: getInitialHeader(),\n      };\n    }\n\n    if (this._canFetchMore()) {\n      const { result: resources, headers } = await this.fetchMore(diagnosticNode);\n      this.resources = resources;\n      if (this.resources.length === 0) {\n        if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          return { result: undefined, headers };\n        } else {\n          return this.current(diagnosticNode);\n        }\n      }\n      return { result: this.resources[this.currentIndex], headers };\n    } else {\n      this.state = DefaultQueryExecutionContext.STATES.ended;\n      return {\n        result: undefined,\n        headers: getInitialHeader(),\n      };\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on\n   * the value of the continuation token or the elements remaining on the current batch in the execution context.\n   *\n   * @returns true if there is other elements to process in the DefaultQueryExecutionContext.\n   */\n  public hasMoreResults(): boolean {\n    return (\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      this.continuationToken !== undefined ||\n      this.currentIndex < this.resources.length - 1 ||\n      this.currentPartitionIndex < this.fetchFunctions.length\n    );\n  }\n\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   */\n  public async fetchMore(diagnosticNode: DiagnosticNodeInternal): Promise<Response<any>> {\n    return addDiagnosticChild(\n      async (childDiagnosticNode: DiagnosticNodeInternal) => {\n        if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n          return {\n            headers: getInitialHeader(),\n            result: undefined,\n          };\n        }\n\n        // Keep to the original continuation and to restore the value after fetchFunction call\n        const originalContinuation = this.options.continuationToken || this.options.continuation;\n        this.options.continuationToken = this.continuationToken;\n\n        // Return undefined if there is no more results\n        if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n          return {\n            headers: getInitialHeader(),\n            result: undefined,\n          };\n        }\n\n        let resources;\n        let responseHeaders;\n        try {\n          let p: Promise<Response<any>>;\n          if (this.nextFetchFunction !== undefined) {\n            logger.verbose(\"using prefetch\");\n            p = this.nextFetchFunction;\n            this.nextFetchFunction = undefined;\n          } else {\n            logger.verbose(\"using fresh fetch\");\n            p = this.fetchFunctions[this.currentPartitionIndex](\n              childDiagnosticNode,\n              this.options,\n              this.correlatedActivityId,\n            );\n          }\n          const response = await p;\n          resources = response.result;\n          childDiagnosticNode.recordQueryResult(resources, CosmosDbDiagnosticLevel.debugUnsafe);\n          responseHeaders = response.headers;\n          this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];\n          if (!this.continuationToken) {\n            ++this.currentPartitionIndex;\n          }\n\n          if (this.options && this.options.bufferItems === true) {\n            const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];\n            this.nextFetchFunction = fetchFunction\n              ? fetchFunction(\n                  childDiagnosticNode,\n                  {\n                    ...this.options,\n                    continuationToken: this.continuationToken,\n                  },\n                  this.correlatedActivityId,\n                )\n              : undefined;\n          }\n        } catch (err: any) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          // return callback(err, undefined, responseHeaders);\n          // TODO: Error and data being returned is an antipattern, this might broken\n          throw err;\n        }\n\n        this.state = DefaultQueryExecutionContext.STATES.inProgress;\n        this.currentIndex = 0;\n        this.options.continuationToken = originalContinuation;\n        this.options.continuation = originalContinuation;\n\n        // deserializing query metrics so that we aren't working with delimited strings in the rest of the code base\n        if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {\n          const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];\n          let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString);\n\n          // Add the request charge to the query metrics so that we can have per partition request charge.\n          if (Constants.HttpHeaders.RequestCharge in responseHeaders) {\n            const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;\n            queryMetrics = new QueryMetrics(\n              queryMetrics.retrievedDocumentCount,\n              queryMetrics.retrievedDocumentSize,\n              queryMetrics.outputDocumentCount,\n              queryMetrics.outputDocumentSize,\n              queryMetrics.indexHitDocumentCount,\n              queryMetrics.totalQueryExecutionTime,\n              queryMetrics.queryPreparationTimes,\n              queryMetrics.indexLookupTime,\n              queryMetrics.documentLoadTime,\n              queryMetrics.vmExecutionTime,\n              queryMetrics.runtimeExecutionTimes,\n              queryMetrics.documentWriteTime,\n              new ClientSideMetrics(requestCharge),\n            );\n          }\n\n          // Wraping query metrics in a object where the key is '0' just so single partition\n          // and partition queries have the same response schema\n          responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};\n          responseHeaders[Constants.HttpHeaders.QueryMetrics][\"0\"] = queryMetrics;\n        }\n\n        return { result: resources, headers: responseHeaders };\n      },\n      diagnosticNode,\n      DiagnosticNodeType.DEFAULT_QUERY_NODE,\n      {\n        queryMethodIdentifier: \"fetchMore\",\n      },\n    );\n  }\n\n  private _canFetchMore(): boolean {\n    const res =\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      (this.continuationToken && this.state === DefaultQueryExecutionContext.STATES.inProgress) ||\n      (this.currentPartitionIndex < this.fetchFunctions.length &&\n        this.state === DefaultQueryExecutionContext.STATES.inProgress);\n    return res;\n  }\n}\n"]}