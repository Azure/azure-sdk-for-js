{"version":3,"file":"Limiter.js","sourceRoot":"","sources":["../../../src/bulk/Limiter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { StatusCodes } from \"../common/statusCodes.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport type { RetryCallback } from \"../utils/batch.js\";\nimport type { Batcher } from \"./Batcher.js\";\nimport type { PartitionMetric } from \"./PartitionMetric.js\";\nimport type { ItemOperation } from \"./ItemOperation.js\";\n\nexport type Task<T = any> = () => Promise<T>;\n\ninterface QueueItem {\n  batcher: Batcher;\n  resolve: (value: any) => void;\n  reject: (reason?: any) => void;\n}\n\nclass ListNode<T> {\n  public value: T;\n  public next: ListNode<T> | null = null;\n  public prev: ListNode<T> | null = null;\n  constructor(value: T) {\n    this.value = value;\n  }\n}\n\nclass DoublyLinkedList<T> {\n  public head: ListNode<T> | null = null;\n  public tail: ListNode<T> | null = null;\n  public length = 0;\n\n  public push(value: T): void {\n    const node = new ListNode(value);\n    if (!this.head) {\n      this.head = this.tail = node;\n    } else {\n      this.tail!.next = node;\n      node.prev = this.tail;\n      this.tail = node;\n    }\n    this.length++;\n  }\n\n  public shift(): T | null {\n    if (!this.head) return null;\n    const value = this.head.value;\n    this.head = this.head.next;\n    if (this.head) {\n      this.head.prev = null;\n    } else {\n      this.tail = null;\n    }\n    this.length--;\n    return value;\n  }\n\n  public clear(): void {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  public isEmpty(): boolean {\n    return this.length === 0;\n  }\n}\n\n/**\n * Returns a function that will schedule the given callback using the best available method.\n */\nfunction scheduleCallback(fn: () => void): void {\n  if (typeof process !== \"undefined\" && typeof process.nextTick === \"function\") {\n    process.nextTick(fn);\n  } else if (typeof setImmediate === \"function\") {\n    setImmediate(fn);\n  } else {\n    // eslint-disable-next-line promise/catch-or-return\n    Promise.resolve().then(fn);\n  }\n}\n\n/**\n * HighPerformanceQueue processes tasks concurrently.\n * If pauseAndClear() is called, it permanently halts processing,\n * clears queued tasks (resolving them with a custom value), and\n * any subsequent push() calls will immediately resolve with that value.\n */\nexport class LimiterQueue {\n  // maximum number of tasks allowed to run concurrently\n  public concurrency: number;\n  // number of tasks currently executing\n  private running = 0;\n  // doubly linked list to store batchers and resolve/reject functions for dispatch tasks\n  private tasks: DoublyLinkedList<QueueItem> = new DoublyLinkedList();\n  // boolean flag that indicates whether the queue has been permanently paused\n  private terminated = false;\n  // value to resolve with when the queue is terminated\n  private terminatedValue: any;\n  // indicates if the processing cycle has been scheduled via the asynchronous scheduler\n  private scheduled = false;\n  // indicates whether the queue is currently in the process of dequeueing and executing tasks\n  private processing = false;\n  // retry callback to retry all the queued operations in case of split/merge error\n  private retrier: RetryCallback;\n  // partiton metric for collecting metrics for the requests\n  private partitionMetric: PartitionMetric;\n  // callback used to refresh the partition key range cache in case of split/merge error\n  private readonly refreshPartitionKeyRangeCache: (diagnosticNode: any) => Promise<void>;\n\n  /**\n   * Creates a new HighPerformanceQueue.\n   */\n  constructor(\n    concurrency: number,\n    partitionMetric: PartitionMetric,\n    retrier: RetryCallback,\n    refreshPartitionKeyRangeCache: (diagnosticNode: any) => Promise<void>,\n  ) {\n    this.concurrency = concurrency;\n    this.partitionMetric = partitionMetric;\n    this.retrier = retrier;\n    this.refreshPartitionKeyRangeCache = refreshPartitionKeyRangeCache;\n  }\n\n  /**\n   * Enqueue a task and return a Promise that resolves or rejects when the task completes.\n   * If the queue has been terminated via pauseAndClear, the promise resolves immediately with the terminated value.\n   */\n  public push(batcher: Batcher): Promise<any> {\n    if (this.terminated) {\n      return Promise.resolve(this.terminatedValue);\n    }\n    return new Promise<any>((resolve, reject) => {\n      this.tasks.push({ batcher, resolve, reject });\n      this.scheduleProcess();\n    });\n  }\n\n  /**\n   * Permanently pauses processing and clears the queue.\n   * All queued tasks and subsequent push() calls will immediately resolve with the provided custom value.\n   */\n  public async pauseAndClear<T = any>(\n    customValue: T,\n    diagnosticNode?: DiagnosticNodeInternal,\n  ): Promise<void> {\n    this.terminated = true;\n    this.terminatedValue = customValue;\n    const operationsList: ItemOperation[] = [];\n    while (!this.tasks.isEmpty()) {\n      const queueItem = this.tasks.shift();\n      if (!queueItem) break;\n      if (customValue === StatusCodes.Gone) {\n        const operations = queueItem.batcher.getOperations();\n        operationsList.push(...operations);\n      }\n      queueItem.resolve(customValue);\n    }\n    if (customValue === StatusCodes.Gone) {\n      await this.refreshPartitionKeyRangeCache(diagnosticNode);\n      for (const operation of operationsList) {\n        await this.retrier(operation, operation.operationContext.diagnosticNode);\n      }\n    }\n  }\n\n  /**\n   * Schedules the processing loop using the best available asynchronous scheduler.\n   */\n  private scheduleProcess(): void {\n    if (this.scheduled || this.processing || this.terminated) return;\n    this.scheduled = true;\n    scheduleCallback(() => {\n      this.scheduled = false;\n      this.process();\n    });\n  }\n\n  /**\n   * Processes tasks up to the concurrency limit.\n   */\n  private process(): void {\n    if (this.terminated) return;\n    this.processing = true;\n\n    try {\n      while (!this.terminated && this.running < this.concurrency && !this.tasks.isEmpty()) {\n        const queueItem = this.tasks.shift();\n        if (!queueItem) break;\n\n        this.running++;\n\n        // Handle synchronous exceptions\n        let dispatchPromise: Promise<any>;\n        try {\n          dispatchPromise = queueItem.batcher.dispatch(this.partitionMetric);\n        } catch (err) {\n          // Handle synchronous errors\n          queueItem.reject(err);\n          this.running--;\n          continue;\n        }\n\n        void dispatchPromise\n          // eslint-disable-next-line promise/always-return\n          .then((result) => {\n            queueItem.resolve(result);\n          })\n          .catch((err) => {\n            queueItem.reject(err);\n          })\n          .finally(() => {\n            this.running--;\n            if (!this.terminated && this.running < this.concurrency && !this.tasks.isEmpty()) {\n              this.scheduleProcess();\n            }\n          });\n      }\n    } catch (err) {\n      console.error(\"Unexpected error in task queue processing:\", err);\n    } finally {\n      this.processing = false;\n    }\n  }\n\n  /**\n   * Dynamically updates the concurrency limit.\n   */\n  public setConcurrency(newConcurrency: number): void {\n    if (newConcurrency < 1) {\n      throw new Error(\"Concurrency must be at least 1\");\n    }\n    this.concurrency = newConcurrency;\n    if (!this.terminated && this.running < this.concurrency) {\n      // Use the scheduleCallback helper for consistency\n      this.scheduleProcess();\n    }\n  }\n}\n"]}