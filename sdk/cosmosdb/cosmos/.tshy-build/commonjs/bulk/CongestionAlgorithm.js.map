{"version":3,"file":"CongestionAlgorithm.js","sourceRoot":"","sources":["../../../src/bulk/CongestionAlgorithm.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAElC,yDAAmD;AAInD;;;;;;;;;;GAUG;AAEH,MAAa,mBAAmB;IAa9B,YACE,YAA0B,EAC1B,eAAgC,EAChC,kBAAmC;QATrC,2DAA2D;QACnD,2BAAsB,GAAW,IAAI,CAAC;QACtC,6BAAwB,GAAW,CAAC,CAAC;QACrC,6BAAwB,GAAW,CAAC,CAAC;QAQ3C,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC7C,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;IACtC,CAAC;IAED,GAAG;QACD,MAAM,eAAe,GACnB,IAAI,CAAC,eAAe,CAAC,aAAa,GAAG,IAAI,CAAC,kBAAkB,CAAC,aAAa,CAAC;QAE7E,IAAI,eAAe,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;YACnD,MAAM,YAAY,GAChB,IAAI,CAAC,eAAe,CAAC,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CAAC;YACrF,MAAM,gBAAgB,GACpB,IAAI,CAAC,eAAe,CAAC,uBAAuB;gBAC5C,IAAI,CAAC,kBAAkB,CAAC,uBAAuB,CAAC;YAElD,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,gBAAgB,EAAE,eAAe,EAAE,YAAY,CAAC,CAAC;YAC7E,4EAA4E;YAC5E,IAAI,YAAY,GAAG,CAAC,EAAE,CAAC;gBACrB,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,CAAC;YACD,4GAA4G;YAC5G,IAAI,gBAAgB,GAAG,CAAC,IAAI,YAAY,KAAK,CAAC,EAAE,CAAC;gBAC/C,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,CAAC;QACH,CAAC;IACH,CAAC;IAEO,mBAAmB;QACzB,2DAA2D;QAC3D,MAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAC5B,IAAI,CAAC,wBAAwB,EAC7B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC,CAChD,CAAC;QACF,IAAI,CAAC,0BAA0B,IAAI,aAAa,CAAC;QACjD,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC;QAClE,oFAAoF;QACpF,IAAI,CAAC,sBAAsB,IAAI,IAAI,CAAC;IACtC,CAAC;IAEO,mBAAmB;QACzB,IACE,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,wBAAwB;YAC/D,wBAAS,CAAC,0BAA0B,EACpC,CAAC;YACD,IAAI,CAAC,0BAA0B,IAAI,IAAI,CAAC,wBAAwB,CAAC;YACjE,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC;QACpE,CAAC;IACH,CAAC;CACF;AApED,kDAoEC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { Constants } from \"../common/constants.js\";\nimport type { PartitionMetric } from \"./PartitionMetric.js\";\nimport type { LimiterQueue } from \"./Limiter.js\";\n\n/**\n * This class implements a congestion control algorithm which dynamically adjusts the degree\n * of concurrency based on the throttling and number of processed items.\n * For example, if it sees any throttling in requests from the last time the algorithm ran, it will decrease the\n * degree of concurrency (either by a factor of 5 or half the current degree of concurrency, whichever is smaller)\n * and increase the wait time to run the algorithm again by 1 second.\n * If it sees no throttling and the number of items processed increased, it will increase the degree of concurrency\n * (by a factor of 1) which cannot exceed the max degree of concurrency (Min(20, concurrency set by user)).\n * It uses the @see {@link PartitionMetric} to capture the metrics.\n * @hidden\n */\n\nexport class CongestionAlgorithm {\n  // The semaphore to control the degree of concurrency.\n  private limiterQueue: LimiterQueue;\n  // captures metrics upto previous requests for a partition.\n  private oldPartitionMetric: PartitionMetric;\n  // captures metrics upto current request for a partition.\n  private partitionMetric: PartitionMetric;\n  // time to wait before adjusting the degree of concurrency.\n  private congestionWaitTimeInMs: number = 1000;\n  private congestionIncreaseFactor: number = 1;\n  private congestionDecreaseFactor: number = 5;\n  private currentDegreeOfConcurrency: number;\n\n  constructor(\n    limiterQueue: LimiterQueue,\n    partitionMetric: PartitionMetric,\n    oldPartitionMetric: PartitionMetric,\n  ) {\n    this.limiterQueue = limiterQueue;\n    this.oldPartitionMetric = oldPartitionMetric;\n    this.partitionMetric = partitionMetric;\n    this.currentDegreeOfConcurrency = 1;\n  }\n\n  run(): void {\n    const elapsedTimeInMs =\n      this.partitionMetric.timeTakenInMs - this.oldPartitionMetric.timeTakenInMs;\n\n    if (elapsedTimeInMs >= this.congestionWaitTimeInMs) {\n      const diffThrottle =\n        this.partitionMetric.numberOfThrottles - this.oldPartitionMetric.numberOfThrottles;\n      const changeItemsCount =\n        this.partitionMetric.numberOfItemsOperatedOn -\n        this.oldPartitionMetric.numberOfItemsOperatedOn;\n\n      this.oldPartitionMetric.add(changeItemsCount, elapsedTimeInMs, diffThrottle);\n      // if the number of throttles increased, decrease the degree of concurrency.\n      if (diffThrottle > 0) {\n        this.decreaseConcurrency();\n      }\n      // if there's no throttling and the number of items processed increased, increase the degree of concurrency.\n      if (changeItemsCount > 0 && diffThrottle === 0) {\n        this.increaseConcurrency();\n      }\n    }\n  }\n\n  private decreaseConcurrency(): void {\n    // decrease should not lead the degree of concurrency as 0.\n    const decreaseCount = Math.min(\n      this.congestionDecreaseFactor,\n      Math.floor(this.currentDegreeOfConcurrency / 2),\n    );\n    this.currentDegreeOfConcurrency -= decreaseCount;\n    this.limiterQueue.setConcurrency(this.currentDegreeOfConcurrency);\n    // In case of throttling increase the wait time to adjust the degree of concurrency.\n    this.congestionWaitTimeInMs += 1000;\n  }\n\n  private increaseConcurrency(): void {\n    if (\n      this.currentDegreeOfConcurrency + this.congestionIncreaseFactor <=\n      Constants.BulkMaxDegreeOfConcurrency\n    ) {\n      this.currentDegreeOfConcurrency += this.congestionIncreaseFactor;\n      this.limiterQueue.setConcurrency(this.currentDegreeOfConcurrency);\n    }\n  }\n}\n"]}