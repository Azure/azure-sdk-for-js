{"version":3,"file":"HelperPerPartition.js","sourceRoot":"","sources":["../../../src/bulk/HelperPerPartition.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport semaphore from \"semaphore\";\nimport { StatusCodes } from \"../common/statusCodes.js\";\nimport type { CosmosDbDiagnosticLevel } from \"../diagnostics/CosmosDbDiagnosticLevel.js\";\nimport type { EncryptionProcessor } from \"../encryption/EncryptionProcessor.js\";\nimport type { ClientConfigDiagnostic, DiagnosticNodeInternal } from \"../index.js\";\nimport type { ExecuteCallback, RetryCallback, BulkOperationResult } from \"../utils/batch.js\";\nimport { Batcher } from \"./Batcher.js\";\nimport { CongestionAlgorithm } from \"./CongestionAlgorithm.js\";\nimport { PartitionMetric } from \"./PartitionMetric.js\";\nimport type { ItemOperation } from \"./index.js\";\nimport { LimiterQueue } from \"./Limiter.js\";\n\n/**\n * Handles operations batching and queuing for dispatch. Fills batches efficiently. There is always one batch at a time being filled. When the batch is full, it is added to the\n * dispatch queue and a new batch is created.\n * @hidden\n */\n\nexport class HelperPerPartition {\n  private readonly executor: ExecuteCallback;\n  private readonly retrier: RetryCallback;\n  private currentBatcher: Batcher;\n  private readonly lock: semaphore.Semaphore;\n  private readonly partitionMetric: PartitionMetric;\n  private readonly oldPartitionMetric: PartitionMetric;\n  private readonly diagnosticLevel: CosmosDbDiagnosticLevel;\n  private readonly encryptionEnabled: boolean;\n  private readonly encryptionProcessor: EncryptionProcessor;\n  private readonly clientConfigDiagnostics: ClientConfigDiagnostic;\n  private readonly congestionControlAlgorithm: CongestionAlgorithm;\n  private readonly dispatchLimiterQueue: LimiterQueue;\n  private initialConcurrency: number = 1;\n  private processedOperationCountRef: { count: number };\n\n  constructor(\n    executor: ExecuteCallback,\n    retrier: RetryCallback,\n    refreshpartitionKeyRangeCache: (diagnosticNode: DiagnosticNodeInternal) => Promise<void>,\n    diagnosticLevel: CosmosDbDiagnosticLevel,\n    encryptionEnabled: boolean,\n    clientConfig: ClientConfigDiagnostic,\n    encryptionProcessor: EncryptionProcessor,\n    processedOperationCountRef: { count: number },\n  ) {\n    this.executor = executor;\n    this.retrier = retrier;\n    this.diagnosticLevel = diagnosticLevel;\n    this.encryptionEnabled = encryptionEnabled;\n    this.encryptionProcessor = encryptionProcessor;\n    this.clientConfigDiagnostics = clientConfig;\n    this.oldPartitionMetric = new PartitionMetric();\n    this.partitionMetric = new PartitionMetric();\n    this.processedOperationCountRef = processedOperationCountRef;\n    this.lock = semaphore(1);\n    this.dispatchLimiterQueue = new LimiterQueue(\n      this.initialConcurrency,\n      this.partitionMetric,\n      this.retrier,\n      refreshpartitionKeyRangeCache,\n    );\n    this.congestionControlAlgorithm = new CongestionAlgorithm(\n      this.dispatchLimiterQueue,\n      this.partitionMetric,\n      this.oldPartitionMetric,\n    );\n    this.currentBatcher = this.createBatcher();\n  }\n\n  /**\n   * Enqueues an operation into the current batch.\n   * If the operation does not fit because the batch is full, the full batch is enqueued in the dispatch queue\n   * and a new batch is created. The promise resolves when the operation has been successfully added.\n   */\n  async add(operation: ItemOperation): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.lock.take(() => {\n        try {\n          // If the current batch is full, move it to the dispatch queue until the operation fits.\n          while (!this.currentBatcher.tryAdd(operation)) {\n            const fullBatch = this.getBatchToQueueAndCreate();\n            if (fullBatch) {\n              this.dispatchLimiterQueue.push(fullBatch);\n            }\n          }\n          // At this point the operation was added.\n          resolve();\n        } catch (err) {\n          const response: BulkOperationResult = {\n            operationInput: operation.unencryptedOperationInput,\n            error: Object.assign(new Error(err.message), {\n              code: StatusCodes.InternalServerError,\n              diagnostics: operation.operationContext.diagnosticNode.toDiagnostic(\n                this.clientConfigDiagnostics,\n              ),\n            }),\n          };\n          operation.operationContext.fail(response);\n          this.processedOperationCountRef.count++;\n          reject(err);\n        } finally {\n          this.lock.leave();\n        }\n      });\n    });\n  }\n\n  /**\n   * @returns the batch to be dispatched and creates a new one\n   */\n  private getBatchToQueueAndCreate(): Batcher {\n    if (this.currentBatcher.isEmpty()) return null;\n    const previousBatcher = this.currentBatcher;\n    this.currentBatcher = this.createBatcher();\n    return previousBatcher;\n  }\n\n  /**\n   * In case there are leftover operations that did not fill a full batch,\n   * dispatchUnfilledBatch will add those operations as a batch in the dispatch queue.\n   */\n  addPartialBatchToQueue(): void {\n    this.lock.take(() => {\n      try {\n        if (!this.currentBatcher.isEmpty()) {\n          const batch = this.currentBatcher;\n          this.currentBatcher = this.createBatcher();\n          this.dispatchLimiterQueue.push(batch);\n        }\n      } finally {\n        this.lock.leave();\n      }\n    });\n  }\n\n  private createBatcher(): Batcher {\n    return new Batcher(\n      this.dispatchLimiterQueue,\n      this.executor,\n      this.retrier,\n      this.diagnosticLevel,\n      this.encryptionEnabled,\n      this.clientConfigDiagnostics,\n      this.encryptionProcessor,\n      this.processedOperationCountRef,\n    );\n  }\n  /**\n   * Runs congestion algo for a partition.\n   * Controlled by a single timer for all the partitions.\n   */\n  public runCongestionAlgorithm(): void {\n    this.congestionControlAlgorithm.run();\n  }\n\n  /**\n   * Empties the dispatch queue and clears the current batch.\n   * This is used in case of stale container Rid detected for encryption operations\n   */\n  public async dispose(): Promise<void> {\n    await this.dispatchLimiterQueue.pauseAndClear(null);\n    this.currentBatcher = undefined;\n  }\n}\n"]}