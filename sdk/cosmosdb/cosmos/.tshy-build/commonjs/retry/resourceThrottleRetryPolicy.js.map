{"version":3,"file":"resourceThrottleRetryPolicy.js","sourceRoot":"","sources":["../../../src/retry/resourceThrottleRetryPolicy.ts"],"names":[],"mappings":";;;AAAA,uCAAuC;AACvC,kCAAkC;AAClC,yDAAmD;AAKnD;;;GAGG;AACH,MAAa,2BAA2B;IAoBtC,YAAY,OAAqB;;QAnBjC,mCAAmC;QAC5B,6BAAwB,GAAW,CAAC,CAAC;QAC5C,2FAA2F;QACpF,4BAAuB,GAAW,CAAC,CAAC;QAC3C,mFAAmF;QAC5E,mBAAc,GAAW,CAAC,CAAC;QAehC,IAAI,CAAC,QAAQ,GAAG,MAAA,OAAO,CAAC,oBAAoB,mCAAI,wBAAS,CAAC,oCAAoC,CAAC;QAC/F,IAAI,CAAC,sBAAsB;YACzB,MAAA,OAAO,CAAC,gCAAgC,mCAAI,wBAAS,CAAC,sCAAsC,CAAC;QAC/F,MAAM,gBAAgB,GACpB,MAAA,OAAO,CAAC,oBAAoB,mCAAI,wBAAS,CAAC,oCAAoC,CAAC;QACjF,IAAI,CAAC,WAAW,GAAG,gBAAgB,GAAG,IAAI,CAAC;QAC3C,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;QAClC,IAAI,CAAC,uBAAuB,GAAG,CAAC,CAAC;IACnC,CAAC;IACD;;;OAGG;IACI,KAAK,CAAC,WAAW,CACtB,GAAkB,EAClB,cAAsC;QAEtC,gCAAgC;QAChC,IAAI,GAAG,EAAE,CAAC;YACR,IAAI,IAAI,CAAC,wBAAwB,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClD,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBAChC,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;gBAExB,IAAI,IAAI,CAAC,sBAAsB,EAAE,CAAC;oBAChC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,sBAAsB,CAAC;gBACpD,CAAC;qBAAM,IAAI,GAAG,CAAC,cAAc,EAAE,CAAC;oBAC9B,IAAI,CAAC,cAAc,GAAG,GAAG,CAAC,cAAc,CAAC;gBAC3C,CAAC;gBAED,IAAI,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;oBACpD,IAAI,CAAC,uBAAuB,IAAI,IAAI,CAAC,cAAc,CAAC;oBACpD,cAAc,CAAC,OAAO,CAAC,EAAE,qBAAqB,EAAE,kBAAkB,EAAE,CAAC,CAAC;oBACtE,OAAO,IAAI,CAAC;gBACd,CAAC;YACH,CAAC;QACH,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;CACF;AA3DD,kEA2DC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common/constants.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport type { ErrorResponse } from \"../request/index.js\";\nimport type { RetryOptions } from \"./retryOptions.js\";\n\n/**\n * This class implements the resource throttle retry policy for requests.\n * @hidden\n */\nexport class ResourceThrottleRetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount: number = 0;\n  /** Cummulative wait time in milliseconds for a request while the retries are happening. */\n  public cummulativeWaitTimeinMs: number = 0;\n  /** Retry interval in milliseconds to wait before the next request will be sent. */\n  public retryAfterInMs: number = 0;\n\n  /** Max wait time in milliseconds to wait for a request while the retries are happening. */\n  private timeoutInMs: number;\n  /**\n   * @param maxTries - Max number of retries to be performed for a request.\n   * @param fixedRetryIntervalInMs - Fixed retry interval in milliseconds to wait between each\n   * retry ignoring the retryAfter returned as part of the response.\n   * @param timeoutInSeconds - Max wait time in seconds to wait for a request while the\n   * retries are happening.\n   */\n\n  private maxTries: number;\n  private fixedRetryIntervalInMs: number;\n  constructor(options: RetryOptions) {\n    this.maxTries = options.maxRetryAttemptCount ?? Constants.ThrottledRequestMaxRetryAttemptCount;\n    this.fixedRetryIntervalInMs =\n      options.fixedRetryIntervalInMilliseconds ?? Constants.ThrottledRequestFixedRetryIntervalInMs;\n    const timeoutInSeconds =\n      options.maxWaitTimeInSeconds ?? Constants.ThrottledRequestMaxWaitTimeInSeconds;\n    this.timeoutInMs = timeoutInSeconds * 1000;\n    this.currentRetryAttemptCount = 0;\n    this.cummulativeWaitTimeinMs = 0;\n  }\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   */\n  public async shouldRetry(\n    err: ErrorResponse,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<boolean> {\n    // TODO: any custom error object\n    if (err) {\n      if (this.currentRetryAttemptCount < this.maxTries) {\n        this.currentRetryAttemptCount++;\n        this.retryAfterInMs = 0;\n\n        if (this.fixedRetryIntervalInMs) {\n          this.retryAfterInMs = this.fixedRetryIntervalInMs;\n        } else if (err.retryAfterInMs) {\n          this.retryAfterInMs = err.retryAfterInMs;\n        }\n\n        if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {\n          this.cummulativeWaitTimeinMs += this.retryAfterInMs;\n          diagnosticNode.addData({ successfulRetryPolicy: \"resourceThrottle\" });\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n"]}