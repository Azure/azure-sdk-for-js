{"version":3,"file":"timeoutFailoverRetryPolicy.js","sourceRoot":"","sources":["../../../src/retry/timeoutFailoverRetryPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { RetryPolicy } from \"./RetryPolicy.js\";\nimport { StatusCodes } from \"../common/statusCodes.js\";\nimport type { GlobalEndpointManager } from \"../globalEndpointManager.js\";\nimport { HTTPMethod, isReadRequest } from \"../common/index.js\";\nimport type { OperationType, ResourceType } from \"../common/constants.js\";\nimport { Constants } from \"../common/constants.js\";\nimport type { RetryContext } from \"./RetryContext.js\";\nimport type { CosmosHeaders } from \"../queryExecutionContext/CosmosHeaders.js\";\nimport { TimeoutErrorCode } from \"../request/TimeoutError.js\";\nimport type { ErrorResponse } from \"../request/index.js\";\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\n\n/**\n * This class TimeoutFailoverRetryPolicy handles retries for read operations\n * (including data plane,metadata, and query plan) in case of request timeouts\n * (TimeoutError) or service unavailability (503 status code) by performing failover\n * and retrying on other regions.\n * @hidden\n */\nexport class TimeoutFailoverRetryPolicy implements RetryPolicy {\n  private maxRetryAttemptCount = 120;\n  private maxServiceUnavailableRetryCount = 1;\n  public retryAfterInMs = 0;\n  public failoverRetryCount = 0;\n  public request: any;\n  public locationEndpoint: any;\n\n  constructor(\n    private globalEndpointManager: GlobalEndpointManager,\n    private headers: CosmosHeaders,\n    private methodType: HTTPMethod,\n    private resourceType: ResourceType,\n    private operationType: OperationType,\n    private enableEndPointDiscovery: boolean,\n  ) {}\n\n  /**\n   * Checks if a timeout request is valid for the timeout failover retry policy.\n   * A valid request should be a data plane, metadata, or query plan request.\n   * @returns\n   */\n  private isValidRequestForTimeoutError(): boolean {\n    const isQuery = Constants.HttpHeaders.IsQuery in this.headers;\n    const isQueryPlan = Constants.HttpHeaders.IsQueryPlan in this.headers;\n    if (this.methodType === HTTPMethod.get || isQuery || isQueryPlan) {\n      return true;\n    }\n    return false;\n  }\n\n  public async shouldRetry(\n    err: ErrorResponse,\n    diagnosticNode: DiagnosticNodeInternal,\n    retryContext?: RetryContext,\n    locationEndpoint?: string,\n  ): Promise<boolean> {\n    if (!err) {\n      return false;\n    }\n    if (!retryContext || !locationEndpoint) {\n      return false;\n    }\n    // Check if the error is a timeout error (TimeoutErrorCode) and if it is not a valid HTTP network timeout request\n    if (err.code === TimeoutErrorCode && !this.isValidRequestForTimeoutError()) {\n      return false;\n    }\n    if (!this.enableEndPointDiscovery) {\n      return false;\n    }\n    if (\n      err.code === StatusCodes.ServiceUnavailable &&\n      this.failoverRetryCount >= this.maxServiceUnavailableRetryCount\n    ) {\n      return false;\n    }\n    if (this.failoverRetryCount >= this.maxRetryAttemptCount) {\n      return false;\n    }\n    const canUseMultipleWriteLocations = this.globalEndpointManager.canUseMultipleWriteLocations(\n      this.resourceType,\n      this.operationType,\n    );\n    const readRequest = isReadRequest(this.operationType);\n\n    if (!canUseMultipleWriteLocations && !readRequest) {\n      // Write requests on single master cannot be retried, no other regions available\n      return false;\n    }\n    this.failoverRetryCount++;\n    // Setting the retryLocationIndex to the next available location for retry.\n    // The retryLocationIndex is determined based on the failoverRetryCount, starting from zero.\n    retryContext.retryLocationServerIndex = await this.findEndpointIndex(this.failoverRetryCount);\n    diagnosticNode.addData({ successfulRetryPolicy: \"timeout-failover\" });\n    return true;\n  }\n\n  /**\n   * Determines index of endpoint to be used for retry based upon failoverRetryCount and avalable locations\n   * @param failoverRetryCount - count of failovers\n   * @returns\n   */\n  private async findEndpointIndex(failoverRetryCount: number): Promise<number> {\n    // count of preferred locations specified by user\n    const preferredLocationsCount = this.globalEndpointManager.preferredLocationsCount;\n    const readRequest = isReadRequest(this.operationType);\n    let endpointIndex = 0;\n    // If preferredLocationsCount is not zero, it indicates that the user has specified preferred locations.\n    if (preferredLocationsCount !== 0) {\n      // The endpointIndex is set based on the preferred location and the failover retry count.\n      endpointIndex = failoverRetryCount % preferredLocationsCount;\n    } else {\n      // In the absence of preferred locations, the endpoint selection is based on the failover count and the number of available locations.\n      if (readRequest) {\n        const getReadEndpoints = await this.globalEndpointManager.getReadEndpoints();\n        if (getReadEndpoints && getReadEndpoints.length > 0) {\n          endpointIndex = failoverRetryCount % getReadEndpoints.length;\n        }\n      } else {\n        const getWriteEndpoints = await this.globalEndpointManager.getWriteEndpoints();\n        if (getWriteEndpoints && getWriteEndpoints.length > 0) {\n          endpointIndex = failoverRetryCount % getWriteEndpoints.length;\n        }\n      }\n    }\n    return endpointIndex;\n  }\n}\n"]}