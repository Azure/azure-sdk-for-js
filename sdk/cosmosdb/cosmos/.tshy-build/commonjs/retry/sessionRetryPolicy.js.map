{"version":3,"file":"sessionRetryPolicy.js","sourceRoot":"","sources":["../../../src/retry/sessionRetryPolicy.ts"],"names":[],"mappings":";;;AAIA,iDAAmD;AAOnD;;;GAGG;AACH,MAAa,kBAAkB;IAM7B;;OAEG;IACH,YACU,qBAA4C,EAC5C,YAA0B,EAC1B,aAA4B,EAC5B,gBAAkC;QAHlC,0BAAqB,GAArB,qBAAqB,CAAuB;QAC5C,iBAAY,GAAZ,YAAY,CAAc;QAC1B,kBAAa,GAAb,aAAa,CAAe;QAC5B,qBAAgB,GAAhB,gBAAgB,CAAkB;QAZ5C,mCAAmC;QAC5B,6BAAwB,GAAG,CAAC,CAAC;QACpC,sCAAsC;QAC/B,mBAAc,GAAG,CAAC,CAAC;IAUvB,CAAC;IAEJ;;;;;OAKG;IACI,KAAK,CAAC,WAAW,CACtB,GAAkB,EAClB,cAAsC,EACtC,YAA2B;QAE3B,IAAI,CAAC,GAAG,EAAE,CAAC;YACT,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,uBAAuB,EAAE,CAAC;YACnD,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IACE,IAAI,CAAC,qBAAqB,CAAC,4BAA4B,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,aAAa,CAAC,EAC9F,CAAC;YACD,iGAAiG;YACjG,MAAM,SAAS,GAAG,IAAA,wBAAa,EAAC,IAAI,CAAC,aAAa,CAAC;gBACjD,CAAC,CAAC,MAAM,IAAI,CAAC,qBAAqB,CAAC,gBAAgB,EAAE;gBACrD,CAAC,CAAC,MAAM,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,EAAE,CAAC;YACzD,IAAI,IAAI,CAAC,wBAAwB,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC;gBACrD,OAAO,KAAK,CAAC;YACf,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBAChC,YAAY,CAAC,UAAU,EAAE,CAAC;gBAC1B,YAAY,CAAC,gCAAgC,GAAG,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;gBAClF,YAAY,CAAC,6BAA6B;oBACxC,IAAI,CAAC,wBAAwB,KAAK,SAAS,CAAC,MAAM,CAAC;gBACrD,cAAc,CAAC,OAAO,CAAC,EAAE,qBAAqB,EAAE,SAAS,EAAE,CAAC,CAAC;gBAC7D,OAAO,IAAI,CAAC;YACd,CAAC;QACH,CAAC;aAAM,CAAC;YACN,IAAI,IAAI,CAAC,wBAAwB,GAAG,CAAC,EAAE,CAAC;gBACtC,OAAO,KAAK,CAAC;YACf,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,wBAAwB,EAAE,CAAC;gBAChC,YAAY,CAAC,UAAU,EAAE,CAAC;gBAC1B,YAAY,CAAC,gCAAgC,GAAG,KAAK,CAAC,CAAC,kDAAkD;gBACzG,YAAY,CAAC,6BAA6B,GAAG,IAAI,CAAC;gBAClD,cAAc,CAAC,OAAO,CAAC,EAAE,qBAAqB,EAAE,SAAS,EAAE,CAAC,CAAC;gBAC7D,OAAO,IAAI,CAAC;YACd,CAAC;QACH,CAAC;IACH,CAAC;CACF;AAtED,gDAsEC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DiagnosticNodeInternal } from \"../diagnostics/DiagnosticNodeInternal.js\";\nimport type { OperationType, ResourceType } from \"../common/index.js\";\nimport { isReadRequest } from \"../common/index.js\";\nimport type { ConnectionPolicy } from \"../documents/index.js\";\nimport type { GlobalEndpointManager } from \"../globalEndpointManager.js\";\nimport type { ErrorResponse } from \"../request/index.js\";\nimport type { RetryContext } from \"./RetryContext.js\";\nimport type { RetryPolicy } from \"./RetryPolicy.js\";\n\n/**\n * This class implements the retry policy for session consistent reads.\n * @hidden\n */\nexport class SessionRetryPolicy implements RetryPolicy {\n  /** Current retry attempt count. */\n  public currentRetryAttemptCount = 0;\n  /** Retry interval in milliseconds. */\n  public retryAfterInMs = 0;\n\n  /**\n   * @param globalEndpointManager - The GlobalEndpointManager instance.\n   */\n  constructor(\n    private globalEndpointManager: GlobalEndpointManager,\n    private resourceType: ResourceType,\n    private operationType: OperationType,\n    private connectionPolicy: ConnectionPolicy,\n  ) {}\n\n  /**\n   * Determines whether the request should be retried or not.\n   * @param err - Error returned by the request.\n   * @param callback - The callback function which takes bool argument which specifies whether the request\n   * will be retried or not.\n   */\n  public async shouldRetry(\n    err: ErrorResponse,\n    diagnosticNode: DiagnosticNodeInternal,\n    retryContext?: RetryContext,\n  ): Promise<boolean> {\n    if (!err) {\n      return false;\n    }\n\n    if (!retryContext) {\n      return false;\n    }\n\n    if (!this.connectionPolicy.enableEndpointDiscovery) {\n      return false;\n    }\n\n    if (\n      this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)\n    ) {\n      // If we can write to multiple locations, we should against every write endpoint until we succeed\n      const endpoints = isReadRequest(this.operationType)\n        ? await this.globalEndpointManager.getReadEndpoints()\n        : await this.globalEndpointManager.getWriteEndpoints();\n      if (this.currentRetryAttemptCount > endpoints.length) {\n        return false;\n      } else {\n        this.currentRetryAttemptCount++;\n        retryContext.retryCount++;\n        retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;\n        retryContext.clearSessionTokenNotAvailable =\n          this.currentRetryAttemptCount === endpoints.length;\n        diagnosticNode.addData({ successfulRetryPolicy: \"session\" });\n        return true;\n      }\n    } else {\n      if (this.currentRetryAttemptCount > 1) {\n        return false;\n      } else {\n        this.currentRetryAttemptCount++;\n        retryContext.retryCount++;\n        retryContext.retryRequestOnPreferredLocations = false; // Forces all operations to primary write endpoint\n        retryContext.clearSessionTokenNotAvailable = true;\n        diagnosticNode.addData({ successfulRetryPolicy: \"session\" });\n        return true;\n      }\n    }\n  }\n}\n"]}