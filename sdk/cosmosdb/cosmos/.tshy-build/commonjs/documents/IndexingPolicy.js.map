{"version":3,"file":"IndexingPolicy.js","sourceRoot":"","sources":["../../../src/documents/IndexingPolicy.ts"],"names":[],"mappings":";;;AAqBA,4CAA4C;AAC5C,IAAY,WAKX;AALD,WAAY,WAAW;IACrB,wCAAyB,CAAA;IACzB,4CAA6B,CAAA;IAC7B,8BAAe,CAAA;IACf,kCAAmB,CAAA;AACrB,CAAC,EALW,WAAW,2BAAX,WAAW,QAKtB;AAiED;;GAEG;AACH,IAAY,eAaX;AAbD,WAAY,eAAe;IACzB;;OAEG;IACH,gCAAa,CAAA;IACb;;OAEG;IACH,sCAAmB,CAAA;IACnB;;OAEG;IACH,kDAA+B,CAAA;AACjC,CAAC,EAbW,eAAe,+BAAf,eAAe,QAa1B","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport type { DataType, IndexingMode, IndexKind } from \"./index.js\";\n\nexport interface IndexingPolicy {\n  /** The indexing mode (consistent or lazy) {@link IndexingMode}. */\n  indexingMode?: keyof typeof IndexingMode;\n  automatic?: boolean;\n  /** An array of {@link IncludedPath} represents the paths to be included for indexing. */\n  includedPaths?: IndexedPath[];\n  /** An array of {@link IncludedPath} represents the paths to be excluded for indexing. */\n  excludedPaths?: IndexedPath[];\n  spatialIndexes?: SpatialIndex[];\n  /** An array of {@link VectorIndex} represents the vector index paths to be included for indexing. */\n  vectorIndexes?: VectorIndex[];\n  /** An array of {@link CompositeIndexes} representing composite indexes to be included. */\n  compositeIndexes?: CompositePath[][];\n  /** An array of {@link FullTextIndex} representing full text indexes to be included. */\n  fullTextIndexes?: FullTextIndex[];\n}\n\n/* The target data type of a spatial path */\nexport enum SpatialType {\n  LineString = \"LineString\",\n  MultiPolygon = \"MultiPolygon\",\n  Point = \"Point\",\n  Polygon = \"Polygon\",\n}\n\nexport interface SpatialIndex {\n  /* Path in JSON document to index */\n  path: string;\n  types: SpatialType[];\n  /* Bounding box for geometry spatial path */\n  boundingBox: {\n    /* X-coordinate of the lower-left corner of the bounding box. */\n    xmin: number;\n    /* Y-coordinate of the lower-left corner of the bounding box. */\n    ymin: number;\n    /* X-coordinate of the upper-right corner of the bounding box. */\n    xmax: number;\n    /* Y-coordinate of the upper-right corner of the bounding box. */\n    ymax: number;\n  };\n}\n\nexport interface IndexedPath {\n  path: string;\n  indexes?: Index[];\n}\n\nexport interface Index {\n  kind: keyof typeof IndexKind;\n  dataType: keyof typeof DataType;\n  precision?: number;\n}\n/**\n * Represents a vector index in the Azure Cosmos DB service.\n * A vector index is used to index vector fields in the documents.\n */\n\nexport interface VectorIndex {\n  /**\n   * The path to the vector field in the document.\n   * for example, path: \"/path/to/vector\".\n   */\n  path: string;\n  /**\n   * The index type of the vector.\n   * Currently, flat, diskANN, and quantizedFlat are supported.\n   */\n  type: VectorIndexType;\n  /**\n   * The number of bytes used in product quantization of the vectors.\n   * This is an optional parameter and applies to index types DiskANN and quantizedFlat.\n   * The allowed range for this parameter is between 1 and min(Dimensions, 512).\n   */\n  quantizationByteSize?: number;\n  /**\n   * The list of string containing the shard keys used for partitioning the vector indexes.\n   * This is an optional parameter and applies to index types DiskANN and quantizedFlat.\n   */\n  vectorIndexShardKey?: string[];\n  /**\n   * The size of the candidate list of approximate neighbors stored while building\n   * the diskANN index as part of the optimization processes.\n   * This is an optional parameter and applies to index type DiskANN only.\n   * The allowed range is between 25 and 500.\n   */\n  indexingSearchListSize?: number;\n}\n\n/**\n * Represents the index type of the vector.\n */\nexport enum VectorIndexType {\n  /**\n   * Represents flat index type.\n   */\n  Flat = \"flat\",\n  /**\n   * Represents diskANN index type.\n   */\n  DiskANN = \"diskANN\",\n  /**\n   * Represents quantizedFlat index type.\n   */\n  QuantizedFlat = \"quantizedFlat\",\n}\n\n/**\n * Represents a composite path in the indexing policy.\n */\nexport interface CompositePath {\n  /** The path in the JSON document to include in the composite index. */\n  path: string;\n  /** The order of the composite index, either \"ascending\" or \"descending\". */\n  order: \"ascending\" | \"descending\";\n}\n\n/**\n * Represents a full text index in the indexing policy.\n */\nexport interface FullTextIndex {\n  /** The path in the JSON document to index. */\n  path: string;\n}\n"]}