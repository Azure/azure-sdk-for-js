{"version":3,"file":"CollectionRoutingMapFactory.js","sourceRoot":"","sources":["../../../src/routing/CollectionRoutingMapFactory.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { Constants } from \"../common/constants.js\";\nimport { InMemoryCollectionRoutingMap } from \"./inMemoryCollectionRoutingMap.js\";\n\n/**\n * @hidden\n */\nfunction compareRanges(a: any, b: any): 0 | 1 | -1 {\n  const aVal = a[0][Constants.PartitionKeyRange.MinInclusive];\n  const bVal = b[0][Constants.PartitionKeyRange.MinInclusive];\n  if (aVal > bVal) {\n    return 1;\n  }\n  if (aVal < bVal) {\n    return -1;\n  }\n  return 0;\n}\n\n/** @hidden */\nexport function createCompleteRoutingMap(\n  partitionKeyRangeInfoTuppleList: any[],\n): InMemoryCollectionRoutingMap {\n  const rangeById: any = {}; // TODO: any\n  const rangeByInfo: any = {}; // TODO: any\n\n  let sortedRanges = [];\n\n  // the for loop doesn't invoke any async callback\n  for (const r of partitionKeyRangeInfoTuppleList) {\n    rangeById[r[0][Constants.PartitionKeyRange.Id]] = r;\n    rangeByInfo[r[1]] = r[0];\n    sortedRanges.push(r);\n  }\n\n  sortedRanges = sortedRanges.sort(compareRanges);\n  const partitionKeyOrderedRange = sortedRanges.map((r) => r[0]);\n  const orderedPartitionInfo = sortedRanges.map((r) => r[1]);\n\n  if (!isCompleteSetOfRange(partitionKeyOrderedRange)) {\n    return undefined;\n  }\n  return new InMemoryCollectionRoutingMap(partitionKeyOrderedRange, orderedPartitionInfo);\n}\n\n/**\n * @hidden\n */\nfunction isCompleteSetOfRange(partitionKeyOrderedRange: any): boolean {\n  // TODO: any\n  let isComplete = false;\n  if (partitionKeyOrderedRange.length > 0) {\n    const firstRange = partitionKeyOrderedRange[0];\n    const lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];\n    isComplete =\n      firstRange[Constants.PartitionKeyRange.MinInclusive] ===\n      Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey;\n    isComplete =\n      isComplete &&\n      lastRange[Constants.PartitionKeyRange.MaxExclusive] ===\n        Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey;\n\n    for (let i = 1; i < partitionKeyOrderedRange.length; i++) {\n      const previousRange = partitionKeyOrderedRange[i - 1];\n      const currentRange = partitionKeyOrderedRange[i];\n      isComplete =\n        isComplete &&\n        previousRange[Constants.PartitionKeyRange.MaxExclusive] ===\n          currentRange[Constants.PartitionKeyRange.MinInclusive];\n\n      if (!isComplete) {\n        if (\n          previousRange[Constants.PartitionKeyRange.MaxExclusive] >\n          currentRange[Constants.PartitionKeyRange.MinInclusive]\n        ) {\n          throw Error(\"Ranges overlap\");\n        }\n        break;\n      }\n    }\n  }\n  return isComplete;\n}\n"]}