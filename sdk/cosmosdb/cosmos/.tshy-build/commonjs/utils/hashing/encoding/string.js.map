{"version":3,"file":"string.js","sourceRoot":"","sources":["../../../../../src/utils/hashing/encoding/string.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;AAKlC,oEA4BC;AA/BD,2CAAyC;AACzC,6CAA0E;AAE1E,SAAgB,4BAA4B,CAAC,OAAe;IAC1D,uDAAuD;IACvD,MAAM,YAAY,GAAG,IAAA,gCAAqB,EAAC,sBAAU,CAAC,MAAM,CAAC,CAAC;IAC9D,MAAM,0BAA0B,GAAG,GAAG,CAAC;IACvC,8DAA8D;IAC9D,MAAM,SAAS,GAAG,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAEpD,MAAM,aAAa,GAAG,OAAO,CAAC,MAAM,IAAI,0BAA0B,CAAC;IAEnE,IAAI,WAAW,GAAG,YAAY,CAAC;IAC/B,KACE,IAAI,KAAK,GAAG,CAAC,EACb,KAAK,GAAG,CAAC,aAAa,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,0BAA0B,GAAG,CAAC,CAAC,EAC3E,KAAK,EAAE,EACP,CAAC;QACD,IAAI,QAAQ,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC;QAChC,IAAI,QAAQ,GAAG,IAAI,EAAE,CAAC;YACpB,QAAQ,EAAE,CAAC;QACb,CAAC;QACD,kDAAkD;QAClD,MAAM,MAAM,GAAG,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QACtD,WAAW,GAAG,IAAA,4BAAiB,EAAC,CAAC,WAAW,EAAE,IAAA,gCAAqB,EAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAChF,CAAC;IAED,IAAI,aAAa,EAAE,CAAC;QAClB,WAAW,GAAG,IAAA,4BAAiB,EAAC,CAAC,WAAW,EAAE,IAAA,gCAAqB,EAAC,sBAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAC9F,CAAC;IACD,OAAO,WAAW,CAAC;AACrB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { BytePrefix } from \"./prefix.js\";\nimport { hexStringToUint8Array, concatUint8Arrays } from \"../../uint8.js\";\n\nexport function writeStringForBinaryEncoding(payload: string): Uint8Array {\n  // Convert the BytePrefix.String hex into a Uint8Array.\n  const outputStream = hexStringToUint8Array(BytePrefix.String);\n  const MAX_STRING_BYTES_TO_APPEND = 100;\n  // Use TextEncoder to get a UTF-8 byte array from the payload.\n  const byteArray = new TextEncoder().encode(payload);\n\n  const isShortString = payload.length <= MAX_STRING_BYTES_TO_APPEND;\n\n  let finalStream = outputStream;\n  for (\n    let index = 0;\n    index < (isShortString ? byteArray.length : MAX_STRING_BYTES_TO_APPEND + 1);\n    index++\n  ) {\n    let charByte = byteArray[index];\n    if (charByte < 0xff) {\n      charByte++;\n    }\n    // Convert the byte value to a 2-digit hex string.\n    const hexRep = charByte.toString(16).padStart(2, \"0\");\n    finalStream = concatUint8Arrays([finalStream, hexStringToUint8Array(hexRep)]);\n  }\n\n  if (isShortString) {\n    finalStream = concatUint8Arrays([finalStream, hexStringToUint8Array(BytePrefix.Undefined)]);\n  }\n  return finalStream;\n}\n"]}