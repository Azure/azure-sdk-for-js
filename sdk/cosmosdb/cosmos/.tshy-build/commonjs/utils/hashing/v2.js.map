{"version":3,"file":"v2.js","sourceRoot":"","sources":["../../../../src/utils/hashing/v2.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { PrimitivePartitionKeyValue } from \"../../documents/index.js\";\nimport { doubleToByteArrayBigInt } from \"./encoding/number.js\";\nimport { BytePrefix } from \"./encoding/prefix.js\";\nimport MurmurHash from \"./murmurHash.js\";\nimport { concatUint8Arrays, hexStringToUint8Array, uint8ArrayToHex } from \"../uint8.js\";\n\nexport function hashV2PartitionKey(partitionKey: PrimitivePartitionKeyValue[]): string {\n  // Create a single Uint8Array from the concatenated prefixes for each partition key value.\n  const toHash: Uint8Array = concatUint8Arrays(partitionKey.map(prefixKeyByType));\n\n  // Compute the 128-bit hash. This returns a hex string.\n  const hash = MurmurHash.x64.hash128(toHash);\n\n  // Convert the hex string hash to a Uint8Array and reverse it.\n  const reverseBuff: Uint8Array = reverse(hexStringToUint8Array(hash));\n\n  // Mask the first byte as required.\n  reverseBuff[0] &= 0x3f;\n\n  // Convert the reversed buffer back to a hex string, uppercase it, and return.\n  return uint8ArrayToHex(reverseBuff).toUpperCase();\n}\n\nfunction prefixKeyByType(key: PrimitivePartitionKeyValue): Uint8Array {\n  let bytes: Uint8Array;\n  switch (typeof key) {\n    case \"string\": {\n      // For strings, concatenate:\n      // - The hex prefix for String\n      // - The UTF-8 bytes for the key (using Uint8Array.from should work for string iterables; alternatively use an encoder)\n      // - The hex prefix for Infinity\n      bytes = concatUint8Arrays([\n        hexStringToUint8Array(BytePrefix.String),\n        new TextEncoder().encode(key),\n        hexStringToUint8Array(BytePrefix.Infinity),\n      ]);\n      return bytes;\n    }\n    case \"number\": {\n      const numberBytes = doubleToByteArrayBigInt(key);\n      bytes = concatUint8Arrays([hexStringToUint8Array(BytePrefix.Number), numberBytes]);\n      return bytes;\n    }\n    case \"boolean\": {\n      const prefix = key ? BytePrefix.True : BytePrefix.False;\n      return hexStringToUint8Array(prefix);\n    }\n    case \"object\": {\n      if (key === null) {\n        return hexStringToUint8Array(BytePrefix.Null);\n      }\n      return hexStringToUint8Array(BytePrefix.Undefined);\n    }\n    case \"undefined\": {\n      return hexStringToUint8Array(BytePrefix.Undefined);\n    }\n    default:\n      throw new Error(`Unexpected type: ${typeof key}`);\n  }\n}\n\nexport function reverse(buff: Uint8Array): Uint8Array {\n  // Replace Uint8Array.allocUnsafe(buff.length) with new Uint8Array(buff.length)\n  const uint8array = new Uint8Array(buff.length);\n  for (let i = 0, j = buff.length - 1; i <= j; ++i, --j) {\n    uint8array[i] = buff[j];\n    uint8array[j] = buff[i];\n  }\n  return uint8array;\n}\n"]}