{"version":3,"file":"queryIterator.js","sourceRoot":"","sources":["../../src/queryIterator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\n/// <reference lib=\"esnext.asynciterable\" />\nimport type { ClientContext } from \"./ClientContext.js\";\nimport {\n  DiagnosticNodeInternal,\n  DiagnosticNodeType,\n} from \"./diagnostics/DiagnosticNodeInternal.js\";\nimport { getPathFromLink, ResourceType, StatusCodes } from \"./common/index.js\";\nimport type {\n  CosmosHeaders,\n  ExecutionContext,\n  FetchFunctionCallback,\n  SqlQuerySpec,\n} from \"./queryExecutionContext/index.js\";\nimport {\n  DefaultQueryExecutionContext,\n  getInitialHeader,\n  mergeHeaders,\n  PipelinedQueryExecutionContext,\n} from \"./queryExecutionContext/index.js\";\nimport type { Response } from \"./request/index.js\";\nimport type {\n  ErrorResponse,\n  PartitionedQueryExecutionInfo,\n  QueryRange,\n} from \"./request/ErrorResponse.js\";\nimport type { FeedOptions } from \"./request/FeedOptions.js\";\nimport { FeedResponse } from \"./request/FeedResponse.js\";\nimport {\n  getEmptyCosmosDiagnostics,\n  withDiagnostics,\n  withMetadataDiagnostics,\n} from \"./utils/diagnostics.js\";\nimport { MetadataLookUpType } from \"./CosmosDiagnostics.js\";\nimport { randomUUID } from \"@azure/core-util\";\nimport { HybridQueryExecutionContext } from \"./queryExecutionContext/hybridQueryExecutionContext.js\";\nimport { PartitionKeyRangeCache } from \"./routing/index.js\";\n\n/**\n * Represents a QueryIterator Object, an implementation of feed or query response that enables\n * traversal and iterating over the response\n * in the Azure Cosmos DB database service.\n */\nexport class QueryIterator<T> {\n  private fetchAllTempResources: T[]; // TODO\n  private fetchAllLastResHeaders: CosmosHeaders;\n  private queryExecutionContext: ExecutionContext;\n  private queryPlanPromise: Promise<Response<PartitionedQueryExecutionInfo>>;\n  private isInitialized: boolean;\n  private correlatedActivityId: string;\n  private partitionKeyRangeCache: PartitionKeyRangeCache;\n  /**\n   * @hidden\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private query: SqlQuerySpec | string,\n    private options: FeedOptions,\n    private fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[],\n    private resourceLink?: string,\n    private resourceType?: ResourceType,\n  ) {\n    this.query = query;\n    this.fetchFunctions = fetchFunctions;\n    this.options = options || {};\n    this.resourceLink = resourceLink;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.reset();\n    this.isInitialized = false;\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(this.clientContext);\n  }\n\n  /**\n   * Gets an async iterator that will yield results until completion.\n   *\n   * NOTE: AsyncIterators are a very new feature and you might need to\n   * use polyfils/etc. in order to use them in your code.\n   *\n   * If you're using TypeScript, you can use the following polyfill as long\n   * as you target ES6 or higher and are running on Node 6 or higher.\n   *\n   * ```ts snippet:ignore\n   * if (!Symbol || !Symbol.asyncIterator) {\n   *   (Symbol as any).asyncIterator = Symbol.for(\"Symbol.asyncIterator\");\n   * }\n   * ```\n   *\n   * @example Iterate over all databases\n   * ```ts snippet:QueryIteratorIterateDatabases\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * for await (const { resources: db } of client.databases.readAll().getAsyncIterator()) {\n   *   console.log(`Got ${db} from AsyncIterator`);\n   * }\n   * ```\n   */\n  public async *getAsyncIterator(): AsyncIterable<FeedResponse<T>> {\n    const diagnosticNode = new DiagnosticNodeInternal(\n      this.clientContext.diagnosticLevel,\n      DiagnosticNodeType.CLIENT_REQUEST_NODE,\n      null,\n    );\n    yield* this.getAsyncIteratorInternal(diagnosticNode);\n  }\n  /**\n   * @internal\n   */\n  public async *getAsyncIteratorInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): AsyncIterable<FeedResponse<T>> {\n    this.reset();\n    this.queryPlanPromise = this.fetchQueryPlan(diagnosticNode);\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response: Response<any>;\n      try {\n        response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n      } catch (error: any) {\n        if (this.needsQueryPlan(error)) {\n          await this.createExecutionContext(diagnosticNode);\n          try {\n            response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n          } catch (queryError: any) {\n            this.handleSplitError(queryError);\n          }\n        } else {\n          throw error;\n        }\n      }\n\n      const feedResponse = new FeedResponse<T>(\n        response.result,\n        response.headers,\n        this.queryExecutionContext.hasMoreResults(),\n        diagnosticNode.toDiagnostic(this.clientContext.getClientConfig()),\n      );\n      diagnosticNode = new DiagnosticNodeInternal(\n        this.clientContext.diagnosticLevel,\n        DiagnosticNodeType.CLIENT_REQUEST_NODE,\n        null,\n      );\n      if (response.result !== undefined) {\n        yield feedResponse;\n      }\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to process based on the value of the continuation token or the\n   * elements remaining on the current batch in the QueryIterator.\n   * @returns true if there is other elements to process in the QueryIterator.\n   */\n  public hasMoreResults(): boolean {\n    return this.queryExecutionContext.hasMoreResults();\n  }\n\n  /**\n   * Fetch all pages for the query and return a single FeedResponse.\n   * @example\n   * ```ts snippet:ReadmeSampleQueryDatabase\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { resources } = await container.items\n   *   .query(\"SELECT * from c WHERE c.isCapitol = true\")\n   *   .fetchAll();\n   * ```\n   */\n\n  public async fetchAll(): Promise<FeedResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.fetchAllInternal(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async fetchAllInternal(diagnosticNode: DiagnosticNodeInternal): Promise<FeedResponse<T>> {\n    this.reset();\n    let response: FeedResponse<T>;\n    try {\n      response = await this.toArrayImplementation(diagnosticNode);\n    } catch (error: any) {\n      this.handleSplitError(error);\n    }\n    return response;\n  }\n\n  /**\n   * Retrieve the next batch from the feed.\n   *\n   * This may or may not fetch more pages from the backend depending on your settings\n   * and the type of query. Aggregate queries will generally fetch all backend pages\n   * before returning the first batch of responses.\n   *\n   * @example\n   * ```ts snippet:ReadmeSampleNonStreamableCrossPartitionQuery\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const querySpec = {\n   *   query: \"SELECT c.status, COUNT(c.id) AS count FROM c GROUP BY c.status\",\n   * };\n   * const queryOptions = {\n   *   maxItemCount: 10, // maximum number of items to return per page\n   *   enableCrossPartitionQuery: true,\n   * };\n   * const queryIterator = container.items.query(querySpec, queryOptions);\n   * while (queryIterator.hasMoreResults()) {\n   *   const { resources: result } = await queryIterator.fetchNext();\n   *   // process results\n   * }\n   * ```\n   */\n  public async fetchNext(): Promise<FeedResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.fetchNextInternal(diagnosticNode);\n    }, this.clientContext);\n  }\n  /**\n   * @internal\n   */\n  public async fetchNextInternal(diagnosticNode: DiagnosticNodeInternal): Promise<FeedResponse<T>> {\n    this.queryPlanPromise = withMetadataDiagnostics(\n      async (metadataNode: DiagnosticNodeInternal) => {\n        return this.fetchQueryPlan(metadataNode);\n      },\n      diagnosticNode,\n      MetadataLookUpType.QueryPlanLookUp,\n    );\n    if (!this.isInitialized) {\n      await this.init(diagnosticNode);\n    }\n    let response: Response<any>;\n    try {\n      response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n    } catch (error: any) {\n      if (this.needsQueryPlan(error)) {\n        await this.createExecutionContext(diagnosticNode);\n        try {\n          response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n        } catch (queryError: any) {\n          this.handleSplitError(queryError);\n        }\n      } else {\n        throw error;\n      }\n    }\n    return new FeedResponse<T>(\n      response.result,\n      response.headers,\n      this.queryExecutionContext.hasMoreResults(),\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  /**\n   * Reset the QueryIterator to the beginning and clear all the resources inside it\n   * @example\n   * ```ts snippet:QueryIteratorReset\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const querySpec = {\n   *   query: \"SELECT c.status, COUNT(c.id) AS count FROM c GROUP BY c.status\",\n   * };\n   * const queryIterator = container.items.query(querySpec);\n   * while (queryIterator.hasMoreResults()) {\n   *   const { resources: result } = await queryIterator.fetchNext();\n   *   // process results\n   * }\n   * queryIterator.reset();\n   * ```\n   *\n   */\n  public reset(): void {\n    this.correlatedActivityId = randomUUID();\n    this.queryPlanPromise = undefined;\n    this.fetchAllLastResHeaders = getInitialHeader();\n    this.fetchAllTempResources = [];\n    this.queryExecutionContext = new DefaultQueryExecutionContext(\n      this.options,\n      this.fetchFunctions,\n      this.correlatedActivityId,\n    );\n  }\n\n  private async toArrayImplementation(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<FeedResponse<T>> {\n    this.queryPlanPromise = withMetadataDiagnostics(\n      async (metadataNode: DiagnosticNodeInternal) => {\n        return this.fetchQueryPlan(metadataNode);\n      },\n      diagnosticNode,\n      MetadataLookUpType.QueryPlanLookUp,\n    );\n    // this.queryPlanPromise = this.fetchQueryPlan(diagnosticNode);\n    if (!this.isInitialized) {\n      await this.init(diagnosticNode);\n    }\n    while (this.queryExecutionContext.hasMoreResults()) {\n      let response: Response<any>;\n      try {\n        response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n      } catch (error: any) {\n        if (this.needsQueryPlan(error)) {\n          await this.createExecutionContext(diagnosticNode);\n          response = await this.queryExecutionContext.fetchMore(diagnosticNode);\n        } else {\n          throw error;\n        }\n      }\n      const { result, headers } = response;\n      // concatenate the results and fetch more\n      mergeHeaders(this.fetchAllLastResHeaders, headers);\n      if (result) {\n        this.fetchAllTempResources.push(...result);\n      }\n    }\n    return new FeedResponse(\n      this.fetchAllTempResources,\n      this.fetchAllLastResHeaders,\n      this.queryExecutionContext.hasMoreResults(),\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  private async createExecutionContext(diagnosticNode?: DiagnosticNodeInternal): Promise<void> {\n    const queryPlanResponse = await this.queryPlanPromise;\n\n    // We always coerce queryPlanPromise to resolved. So if it errored, we need to manually inspect the resolved value\n    if (queryPlanResponse instanceof Error) {\n      throw queryPlanResponse;\n    }\n\n    const queryPlan: PartitionedQueryExecutionInfo = queryPlanResponse.result;\n    if (queryPlan.hybridSearchQueryInfo && queryPlan.hybridSearchQueryInfo !== null) {\n      await this.createHybridQueryExecutionContext(queryPlan, diagnosticNode);\n    } else {\n      await this.createPipelinedExecutionContext(queryPlan);\n    }\n  }\n\n  private async createHybridQueryExecutionContext(\n    queryPlan: PartitionedQueryExecutionInfo,\n    diagnosticNode?: DiagnosticNodeInternal,\n  ): Promise<void> {\n    const allPartitionKeyRanges = (\n      await this.partitionKeyRangeCache.onCollectionRoutingMap(this.resourceLink, diagnosticNode)\n    ).getOrderedParitionKeyRanges();\n\n    // convert allPartitionKeyRanges to QueryRanges\n    const queryRanges: QueryRange[] = allPartitionKeyRanges.map((partitionKeyRange) => {\n      return {\n        min: partitionKeyRange.minInclusive,\n        max: partitionKeyRange.maxExclusive,\n        isMinInclusive: true,\n        isMaxInclusive: false,\n      };\n    });\n\n    this.queryExecutionContext = new HybridQueryExecutionContext(\n      this.clientContext,\n      this.resourceLink,\n      this.options,\n      queryPlan,\n      this.correlatedActivityId,\n      queryRanges,\n    );\n  }\n\n  private async createPipelinedExecutionContext(\n    queryPlan: PartitionedQueryExecutionInfo,\n  ): Promise<void> {\n    const queryInfo = queryPlan.queryInfo;\n    if (queryInfo.aggregates.length > 0 && queryInfo.hasSelectValue === false) {\n      throw new Error(\"Aggregate queries must use the VALUE keyword\");\n    }\n    this.queryExecutionContext = new PipelinedQueryExecutionContext(\n      this.clientContext,\n      this.resourceLink,\n      this.query,\n      this.options,\n      queryPlan,\n      this.correlatedActivityId,\n    );\n  }\n\n  private async fetchQueryPlan(diagnosticNode: DiagnosticNodeInternal): Promise<any> {\n    if (!this.queryPlanPromise && this.resourceType === ResourceType.item) {\n      return this.clientContext\n        .getQueryPlan(\n          getPathFromLink(this.resourceLink) + \"/docs\",\n          ResourceType.item,\n          this.resourceLink,\n          this.query,\n          this.options,\n          diagnosticNode,\n          this.correlatedActivityId,\n        )\n        .catch((error: any) => error); // Without this catch, node reports an unhandled rejection. So we stash the promise as resolved even if it errored.\n    }\n    return this.queryPlanPromise;\n  }\n\n  private needsQueryPlan(error: ErrorResponse): error is ErrorResponse {\n    if (\n      error.body?.additionalErrorInfo ||\n      error.message.includes(\"Cross partition query only supports\")\n    ) {\n      return error.code === StatusCodes.BadRequest && this.resourceType === ResourceType.item;\n    } else {\n      throw error;\n    }\n  }\n\n  private initPromise: Promise<void>;\n  /**\n   * @internal\n   */\n  public async init(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (this.isInitialized === true) {\n      return;\n    }\n    if (this.initPromise === undefined) {\n      this.initPromise = this._init(diagnosticNode);\n    }\n    return this.initPromise;\n  }\n  private async _init(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (this.options.forceQueryPlan === true && this.resourceType === ResourceType.item) {\n      await this.createExecutionContext(diagnosticNode);\n    }\n    this.isInitialized = true;\n  }\n\n  private handleSplitError(err: any): void {\n    if (err.code === 410) {\n      const error = new Error(\n        \"Encountered partition split and could not recover. This request is retryable\",\n      ) as any;\n      error.code = 503;\n      error.originalError = err;\n      throw error;\n    } else {\n      throw err;\n    }\n  }\n}\n"]}