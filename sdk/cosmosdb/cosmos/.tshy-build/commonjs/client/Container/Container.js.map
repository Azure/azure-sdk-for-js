{"version":3,"file":"Container.js","sourceRoot":"","sources":["../../../../src/client/Container/Container.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { ClientContext } from \"../../ClientContext.js\";\nimport {\n  Constants,\n  createDocumentCollectionUri,\n  getIdFromLink,\n  getPathFromLink,\n  HTTPMethod,\n  isResourceValid,\n  ResourceType,\n  StatusCodes,\n  SubStatusCodes,\n} from \"../../common/index.js\";\nimport type { PartitionKey, PartitionKeyDefinition } from \"../../documents/index.js\";\nimport { convertToInternalPartitionKey } from \"../../documents/index.js\";\nimport type { SqlQuerySpec } from \"../../queryExecutionContext/index.js\";\nimport type { QueryIterator } from \"../../queryIterator.js\";\nimport type { FeedOptions, RequestOptions, Response } from \"../../request/index.js\";\nimport { ResourceResponse } from \"../../request/index.js\";\nimport type { PartitionedQueryExecutionInfo } from \"../../request/ErrorResponse.js\";\nimport { ErrorResponse } from \"../../request/ErrorResponse.js\";\nimport { Conflict, Conflicts } from \"../Conflict/index.js\";\nimport type { Database } from \"../Database/index.js\";\nimport { Item, Items } from \"../Item/index.js\";\nimport { Scripts } from \"../Script/Scripts.js\";\nimport type { ContainerDefinition } from \"./ContainerDefinition.js\";\nimport { ContainerResponse } from \"./ContainerResponse.js\";\nimport type { PartitionKeyRange } from \"./PartitionKeyRange.js\";\nimport type { OfferDefinition } from \"../Offer/index.js\";\nimport { Offer } from \"../Offer/index.js\";\nimport { OfferResponse } from \"../Offer/OfferResponse.js\";\nimport type { Resource } from \"../Resource.js\";\nimport type { FeedRange } from \"../ChangeFeed/index.js\";\nimport { FeedRangeInternal } from \"../ChangeFeed/index.js\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal.js\";\nimport {\n  getEmptyCosmosDiagnostics,\n  withDiagnostics,\n  withMetadataDiagnostics,\n} from \"../../utils/diagnostics.js\";\nimport { MetadataLookUpType } from \"../../CosmosDiagnostics.js\";\nimport type { EncryptionSettingForProperty } from \"../../encryption/index.js\";\nimport { EncryptionProcessor } from \"../../encryption/index.js\";\nimport type { EncryptionManager } from \"../../encryption/EncryptionManager.js\";\n\n/**\n * Operations for reading, replacing, or deleting a specific, existing container by id.\n *\n * @see {@link Containers} for creating new containers, and reading/querying all containers; use `.containers`.\n *\n * Note: all these operations make calls against a fixed budget.\n * You should design your system such that these calls scale sublinearly with your application.\n * For instance, do not call `container(id).read()` before every single `item.read()` call, to ensure the container exists;\n * do this once on application start up.\n */\nexport class Container {\n  private $items: Items;\n  /**\n   * Operations for creating new items, and reading/querying all items\n   *\n   * For reading, replacing, or deleting an existing item, use `.item(id)`.\n   *\n   * @example Create a new item\n   * ```ts snippet:ContainerItems\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { resource: createdItem } = await container.items.create({\n   *   id: \"<item id>\",\n   *   properties: {},\n   * });\n   * ```\n   */\n  public get items(): Items {\n    if (!this.$items) {\n      this.$items = new Items(this, this.clientContext);\n    }\n    return this.$items;\n  }\n\n  private $scripts: Scripts;\n  /**\n   * All operations for Stored Procedures, Triggers, and User Defined Functions\n   */\n  public get scripts(): Scripts {\n    if (!this.$scripts) {\n      this.$scripts = new Scripts(this, this.clientContext);\n    }\n    return this.$scripts;\n  }\n\n  private $conflicts: Conflicts;\n  /**\n   * Operations for reading and querying conflicts for the given container.\n   *\n   * For reading or deleting a specific conflict, use `.conflict(id)`.\n   */\n  public get conflicts(): Conflicts {\n    if (!this.$conflicts) {\n      this.$conflicts = new Conflicts(this, this.clientContext);\n    }\n    return this.$conflicts;\n  }\n\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  public get url(): string {\n    return createDocumentCollectionUri(this.database.id, this.id);\n  }\n  /**\n   * @internal\n   */\n  public encryptionProcessor: EncryptionProcessor;\n\n  /**\n   * @internal\n   */\n  public _rid: string;\n\n  private isEncryptionInitialized: boolean = false;\n  private encryptionInitializationPromise: Promise<void>;\n\n  /**\n   * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.\n   * @param database - The parent {@link Database}.\n   * @param id - The id of the given container.\n   * @hidden\n   */\n  constructor(\n    public readonly database: Database,\n    public readonly id: string,\n    private readonly clientContext: ClientContext,\n    private encryptionManager?: EncryptionManager,\n    _rid?: string,\n  ) {\n    this._rid = _rid;\n    if (this.clientContext.enableEncryption) {\n      this.encryptionProcessor = new EncryptionProcessor(\n        this.id,\n        this._rid,\n        this.database,\n        this.clientContext,\n        this.encryptionManager,\n      );\n    }\n  }\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Item} by id.\n   *\n   * Use `.items` for creating new items, or querying/reading all items.\n   *\n   * @param id - The id of the {@link Item}.\n   * @param partitionKeyValue - The value of the {@link Item} partition key\n   * @example Replace an item\n   * ```ts snippet:ContainerItem\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { body: replacedItem } = await container\n   *   .item(\"<item id>\", \"<partition key value>\")\n   *   .replace({ id: \"<item id>\", title: \"Updated post\", authorID: 5 });\n   * ```\n   */\n  public item(id: string, partitionKeyValue?: PartitionKey): Item {\n    return new Item(this, id, this.clientContext, partitionKeyValue);\n  }\n\n  /**\n   * Used to read, replace, or delete a specific, existing {@link Conflict} by id.\n   *\n   * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.\n   * @param id - The id of the {@link Conflict}.\n   * @example\n   * ```ts snippet:ConflictRead\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   * const container = database.container(\"Test Container\");\n   *\n   * const { resource: conflict } = await container.conflict(\"<conflict-id>\").read();\n   * ```\n   */\n  public conflict(id: string, partitionKey?: PartitionKey): Conflict {\n    return new Conflict(this, id, this.clientContext, partitionKey);\n  }\n\n  /**\n   * Read the container's definition\n   * @example\n   * ```ts snippet:ContainerRead\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { resource: database } = await client.database(\"<db id>\").container(\"<container id>\").read();\n   * ```\n   */\n  public async read(options?: RequestOptions): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.readInternal(diagnosticNode, options);\n    }, this.clientContext);\n  }\n\n  /**\n   * @hidden\n   */\n  public async readInternal(\n    diagnosticNode: DiagnosticNodeInternal,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n    const response = await this.clientContext.read<ContainerDefinition>({\n      path,\n      resourceType: ResourceType.container,\n      resourceId: id,\n      options,\n      diagnosticNode,\n    });\n    this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;\n    return new ContainerResponse(\n      response.result,\n      response.headers,\n      response.code,\n      this,\n      getEmptyCosmosDiagnostics(),\n    );\n  }\n\n  /**\n   * Replace the container's definition\n   * @example\n   * ```ts snippet:ContainerReplace\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const containerDefinition = {\n   *   id: \"Test Container\",\n   *   partitionKey: {\n   *     paths: [\"/key1\"],\n   *   },\n   *   throughput: 1000,\n   * };\n   * const { container } = await database.containers.createIfNotExists(containerDefinition);\n   *\n   * containerDefinition.throughput = 400;\n   * const { container: replacedContainer } = await container.replace(containerDefinition);\n   * ```\n   */\n  public async replace(\n    body: ContainerDefinition,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const err = {};\n      if (!isResourceValid(body, err)) {\n        throw err;\n      }\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n\n      const response = await this.clientContext.replace<ContainerDefinition>({\n        body,\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode,\n      });\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Delete the container\n   * @example\n   * ```ts snippet:DatabaseDeleteContainer\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * await client.database(\"<db id>\").container(\"<container id>\").delete();\n   * ```\n   */\n  public async delete(options?: RequestOptions): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n\n      const response = await this.clientContext.delete<ContainerDefinition>({\n        path,\n        resourceType: ResourceType.container,\n        resourceId: id,\n        options,\n        diagnosticNode,\n      });\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @deprecated This method has been renamed to readPartitionKeyDefinition.\n   */\n  public async getPartitionKeyDefinition(): Promise<ResourceResponse<PartitionKeyDefinition>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      return this.readPartitionKeyDefinition(diagnosticNode);\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.\n   * @hidden\n   */\n  public async readPartitionKeyDefinition(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<ResourceResponse<PartitionKeyDefinition>> {\n    // $ISSUE-felixfan-2016-03-17: Make name based path and link based path use the same key\n    // $ISSUE-felixfan-2016-03-17: Refresh partitionKeyDefinitionCache when necessary\n    if (this.url in this.clientContext.partitionKeyDefinitionCache) {\n      diagnosticNode.addData({ readFromCache: true });\n      return new ResourceResponse<PartitionKeyDefinition>(\n        this.clientContext.partitionKeyDefinitionCache[this.url],\n        {},\n        0,\n        getEmptyCosmosDiagnostics(),\n      );\n    }\n\n    const { headers, statusCode, diagnostics } = await withMetadataDiagnostics(\n      async (node: DiagnosticNodeInternal) => {\n        return this.readInternal(node);\n      },\n      diagnosticNode,\n      MetadataLookUpType.ContainerLookUp,\n    );\n\n    return new ResourceResponse<PartitionKeyDefinition>(\n      this.clientContext.partitionKeyDefinitionCache[this.url],\n      headers,\n      statusCode,\n      diagnostics,\n    );\n  }\n\n  /**\n   * Gets offer on container. If none exists, returns an OfferResponse with undefined.\n   * @example\n   * ```ts snippet:ContainerReadOffer\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { resource: offer } = await client\n   *   .database(\"<db id>\")\n   *   .container(\"<container id>\")\n   *   .readOffer();\n   * ```\n   */\n  public async readOffer(options: RequestOptions = {}): Promise<OfferResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const { resource: container } = await this.read();\n      const path = \"/offers\";\n      const url = container._self;\n\n      const response = await this.clientContext.queryFeed<OfferDefinition & Resource[]>({\n        path,\n        resourceId: \"\",\n        resourceType: ResourceType.offer,\n        query: `SELECT * from root where root.resource = \"${url}\"`,\n        resultFn: (result) => result.Offers,\n        options,\n        diagnosticNode,\n      });\n      const offer = response.result[0]\n        ? new Offer(this.database.client, response.result[0].id, this.clientContext)\n        : undefined;\n      return new OfferResponse(\n        response.result[0],\n        response.headers,\n        response.code,\n        getEmptyCosmosDiagnostics(),\n        offer,\n      );\n    }, this.clientContext);\n  }\n\n  public async getQueryPlan(\n    query: string | SqlQuerySpec,\n  ): Promise<Response<PartitionedQueryExecutionInfo>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const path = getPathFromLink(this.url);\n\n      return this.clientContext.getQueryPlan(\n        path + \"/docs\",\n        ResourceType.item,\n        getIdFromLink(this.url),\n        query,\n        {},\n        diagnosticNode,\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Gets the partition key ranges for the container.\n   * @param feedOptions - Options for the request.\n   * @returns An iterator of partition key ranges.\n   * @example\n   * ```ts snippet:ContainerReadPartitionKeyRanges\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { resources: ranges } = await container.readPartitionKeyRanges().fetchAll();\n   * ```\n   */\n  public readPartitionKeyRanges(feedOptions?: FeedOptions): QueryIterator<PartitionKeyRange> {\n    feedOptions = feedOptions || {};\n    return this.clientContext.queryPartitionKeyRanges(this.url, undefined, feedOptions);\n  }\n  /**\n   *\n   * @returns all the feed ranges for which changefeed could be fetched.\n   * @example\n   * ```ts snippet:ContainerGetFeedRanges\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { resources: ranges } = await container.getFeedRanges();\n   * ```\n   */\n  public async getFeedRanges(): Promise<ReadonlyArray<FeedRange>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const { resources } = await this.readPartitionKeyRanges().fetchAllInternal(diagnosticNode);\n\n      const feedRanges: FeedRange[] = [];\n      for (const resource of resources) {\n        const feedRange = new FeedRangeInternal(resource.minInclusive, resource.maxExclusive);\n        Object.freeze(feedRange);\n        feedRanges.push(feedRange);\n      }\n      return feedRanges;\n    }, this.clientContext);\n  }\n\n  /**\n   * Delete all documents belong to the container for the provided partition key value\n   * @param partitionKey - The partition key value of the items to be deleted\n   * @example\n   * ```ts snippet:ContainerDeleteAllItemsForPartitionKey\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({\n   *   id: \"Test Container\",\n   *   partitionKey: {\n   *     paths: [\"/state\"],\n   *   },\n   * });\n   *\n   * const cities = [\n   *   { id: \"1\", name: \"Olympia\", state: \"WA\", isCapitol: true },\n   *   { id: \"2\", name: \"Redmond\", state: \"WA\", isCapitol: false },\n   *   { id: \"3\", name: \"Olympia\", state: \"IL\", isCapitol: false },\n   * ];\n   * for (const city of cities) {\n   *   await container.items.create(city);\n   * }\n   *\n   * await container.deleteAllItemsForPartitionKey(\"WA\");\n   * ```\n   */\n  public async deleteAllItemsForPartitionKey(\n    partitionKey: PartitionKey,\n    options?: RequestOptions,\n  ): Promise<ContainerResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      let path = getPathFromLink(this.url);\n      const id = getIdFromLink(this.url);\n      path = path + \"/operations/partitionkeydelete\";\n      if (this.clientContext.enableEncryption) {\n        await this.checkAndInitializeEncryption();\n        options = options || {};\n        options.containerRid = this._rid;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n        const partitionKeyInternal = convertToInternalPartitionKey(partitionKey);\n        const { partitionKeyList, encryptedCount } =\n          await this.encryptionProcessor.getEncryptedPartitionKeyValue(partitionKeyInternal);\n        partitionKey = partitionKeyList;\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsEncryptOperation,\n          encryptedCount,\n        );\n      }\n      let response: Response<any>;\n      try {\n        response = await this.clientContext.delete<ContainerDefinition>({\n          path,\n          resourceType: ResourceType.container,\n          resourceId: id,\n          options,\n          partitionKey: partitionKey,\n          method: HTTPMethod.post,\n          diagnosticNode,\n        });\n      } catch (error) {\n        if (this.clientContext.enableEncryption) {\n          await this.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n\n      return new ContainerResponse(\n        response.result,\n        response.headers,\n        response.code,\n        this,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n  /**\n   * Warms up encryption related caches for the container.\n   * @example\n   * ```ts snippet:ContainerIntializeEncryption\n   * import { ClientSecretCredential } from \"@azure/identity\";\n   * import {\n   *   AzureKeyVaultEncryptionKeyResolver,\n   *   CosmosClient,\n   *   EncryptionType,\n   *   EncryptionAlgorithm,\n   *   ClientEncryptionIncludedPath,\n   *   ClientEncryptionPolicy,\n   * } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const credentials = new ClientSecretCredential(\"<tenant-id>\", \"<client-id>\", \"<app-secret>\");\n   * const keyResolver = new AzureKeyVaultEncryptionKeyResolver(credentials);\n   * const client = new CosmosClient({\n   *   endpoint,\n   *   key,\n   *   clientEncryptionOptions: {\n   *     keyEncryptionKeyResolver: keyResolver,\n   *   },\n   * });\n   * const { database } = await client.databases.createIfNotExists({ id: \"<db id>\" });\n   *\n   * const paths = [\"/path1\", \"/path2\", \"/path3\"].map(\n   *   (path) =>\n   *     ({\n   *       path: path,\n   *       clientEncryptionKeyId: \"< cek - id >\",\n   *       encryptionType: EncryptionType.DETERMINISTIC,\n   *       encryptionAlgorithm: EncryptionAlgorithm.AEAD_AES_256_CBC_HMAC_SHA256,\n   *     }) as ClientEncryptionIncludedPath,\n   * );\n   * const clientEncryptionPolicy: ClientEncryptionPolicy = {\n   *   includedPaths: paths,\n   *   policyFormatVersion: 2,\n   * };\n   * const containerDefinition = {\n   *   id: \"Test Container\",\n   *   partitionKey: {\n   *     paths: [\"/id\"],\n   *   },\n   *   clientEncryptionPolicy: clientEncryptionPolicy,\n   * };\n   * const { container } = await database.containers.createIfNotExists(containerDefinition);\n   *\n   * await container.initializeEncryption();\n   * ```\n   */\n  public async initializeEncryption(): Promise<void> {\n    if (!this.clientContext.enableEncryption) {\n      throw new ErrorResponse(\"Encryption is not enabled for the client.\");\n    } else {\n      await withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n        const readResponse = await this.readInternal(diagnosticNode);\n        if (!readResponse || !readResponse.resource) {\n          throw new ErrorResponse(\n            \"Failed to initialize encryption: The container's resource definition could not be retrieved.\",\n          );\n        }\n        this._rid = readResponse.resource._rid;\n        this.encryptionProcessor.containerRid = this._rid;\n        const clientEncryptionPolicy = readResponse.resource.clientEncryptionPolicy;\n        if (!clientEncryptionPolicy) return;\n        const partitionKeyPaths = readResponse.resource.partitionKey.paths;\n        const databaseResponse = await this.database.readInternal(diagnosticNode);\n        if (!databaseResponse || !databaseResponse.resource) {\n          throw new ErrorResponse(\n            \"Failed to initialize encryption: The database's resource definition could not be retrieved.\",\n          );\n        }\n        this.database._rid = databaseResponse.resource._rid;\n        const encryptionSettingKey = this.database._rid + \"/\" + this._rid;\n\n        await this.encryptionManager.encryptionSettingsCache.create(\n          encryptionSettingKey,\n          this._rid,\n          partitionKeyPaths,\n          clientEncryptionPolicy,\n        );\n        const clientEncryptionKeyIds = [\n          ...new Set(\n            clientEncryptionPolicy.includedPaths.map((item) => item.clientEncryptionKeyId),\n          ),\n        ];\n        // fetch and set clientEncryptionKeys in the cache\n        for (const clientEncryptionKeyId of clientEncryptionKeyIds) {\n          const res = await this.database.readClientEncryptionKey(clientEncryptionKeyId);\n          if (!res || !res.clientEncryptionKeyProperties) {\n            throw new ErrorResponse(\n              `Failed to initialize encryption: The client encryption key ${clientEncryptionKeyId} could not be retrieved.`,\n            );\n          }\n          const encryptionKeyProperties = res.clientEncryptionKeyProperties;\n          const key = this.database._rid + \"/\" + clientEncryptionKeyId;\n\n          this.encryptionManager.clientEncryptionKeyPropertiesCache.set(\n            key,\n            encryptionKeyProperties,\n          );\n        }\n        this.isEncryptionInitialized = true;\n      }, this.clientContext);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async checkAndInitializeEncryption(): Promise<void> {\n    if (!this.isEncryptionInitialized) {\n      if (!this.encryptionInitializationPromise) {\n        this.encryptionInitializationPromise = this.initializeEncryption();\n      }\n      await this.encryptionInitializationPromise;\n    }\n  }\n\n  /**\n   * @internal\n   * This function handles the scenario where a container is deleted(say from different Client) and recreated with same Id but with different client encryption policy.\n   * The idea is to have the container Rid cached and sent out as part of RequestOptions with Container Rid set in \"x-ms-cosmos-intended-collection-rid\" header.\n   * So, when the container being referenced here gets recreated we would end up with a stale encryption settings and container Rid and this would result in BadRequest (and a substatus 1024).\n   * This would allow us to refresh the encryption settings and Container Rid, on the premise that the container recreated could possibly be configured with a new encryption policy.\n   */\n  async throwIfRequestNeedsARetryPostPolicyRefresh(errorResponse: ErrorResponse): Promise<void> {\n    const key = this.database._rid + \"/\" + this._rid;\n    const encryptionSetting = this.encryptionManager.encryptionSettingsCache.get(key);\n    if (!errorResponse?.code || !errorResponse?.headers?.[Constants.HttpHeaders.SubStatus]) {\n      return;\n    }\n    const subStatusCode = errorResponse.headers[Constants.HttpHeaders.SubStatus];\n    const isPartitionKeyMismatch = Number(subStatusCode) === SubStatusCodes.PartitionKeyMismatch;\n    const isIncorrectContainerRidSubstatus =\n      Number(subStatusCode) === SubStatusCodes.IncorrectContainerRidSubstatus;\n    if (\n      errorResponse.code === StatusCodes.BadRequest &&\n      (isPartitionKeyMismatch || isIncorrectContainerRidSubstatus)\n    ) {\n      // This code verifies if the partitionKeyPaths are encrypted.\n      // If the paths are not encrypted, it indicates that the application passed an incorrect partition key in the request.\n      // This ensures the issue is not caused by a mismatched encrypted value due to a policy error,\n      // avoiding unnecessary force-refreshing of encryption settings.\n      if (isPartitionKeyMismatch && encryptionSetting.partitionKeyPaths.length) {\n        let encryptionSettingsForProperty: EncryptionSettingForProperty = null;\n        for (const path of encryptionSetting.partitionKeyPaths) {\n          const partitionKeyPath = path.split(\"/\")[1];\n          encryptionSettingsForProperty =\n            encryptionSetting.getEncryptionSettingForProperty(partitionKeyPath);\n          if (encryptionSettingsForProperty) {\n            break;\n          }\n        }\n        // wrong partition key passed as partition key is not encrypted.\n        if (encryptionSettingsForProperty == null) {\n          return;\n        }\n      }\n\n      const currentContainerRid = encryptionSetting.containerRid;\n      const forceRefresh = true;\n      // fetch rid of newly created container\n      const updatedContainerRid = (\n        await this.encryptionProcessor.getEncryptionSetting(forceRefresh)\n      ).containerRid;\n      // if the container was not recreated, so policy has not changed, just return the original response\n      if (currentContainerRid === updatedContainerRid) {\n        return;\n      }\n      await this.initializeEncryption();\n      throw new ErrorResponse(\n        \"Operation has failed due to a possible mismatch in Client Encryption Policy configured on the container. Retrying may fix the issue. Please refer to https://aka.ms/CosmosClientEncryption for more details.\" +\n          errorResponse.message,\n      );\n    }\n  }\n}\n"]}