{"version":3,"file":"Items.js","sourceRoot":"","sources":["../../../../src/client/Item/Items.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { ChangeFeedIterator } from \"../../ChangeFeedIterator.js\";\nimport type { ChangeFeedOptions } from \"../../ChangeFeedOptions.js\";\nimport type { ClientContext } from \"../../ClientContext.js\";\nimport {\n  Constants,\n  copyObject,\n  getIdFromLink,\n  getPathFromLink,\n  isItemResourceValid,\n  ResourceType,\n  StatusCodes,\n  SubStatusCodes,\n} from \"../../common/index.js\";\nimport { extractPartitionKeys, setPartitionKeyIfUndefined } from \"../../extractPartitionKey.js\";\nimport type { FetchFunctionCallback, SqlQuerySpec } from \"../../queryExecutionContext/index.js\";\nimport { QueryIterator } from \"../../queryIterator.js\";\nimport type { FeedOptions, RequestOptions, Response } from \"../../request/index.js\";\nimport type { Container, PartitionKeyRange } from \"../Container/index.js\";\nimport { Item } from \"./Item.js\";\nimport type { ItemDefinition } from \"./ItemDefinition.js\";\nimport { ItemResponse } from \"./ItemResponse.js\";\nimport type {\n  Batch,\n  OperationResponse,\n  OperationInput,\n  BulkOptions,\n  BulkOperationResponse,\n  Operation,\n  BulkOperationResult,\n} from \"../../utils/batch.js\";\nimport {\n  isKeyInRange,\n  prepareOperations,\n  decorateBatchOperation,\n  splitBatchBasedOnBodySize,\n  encryptOperationInput,\n} from \"../../utils/batch.js\";\nimport { assertNotUndefined, isPrimitivePartitionKeyValue } from \"../../utils/typeChecks.js\";\nimport { hashPartitionKey } from \"../../utils/hashing/hash.js\";\nimport { PartitionKeyRangeCache, QueryRange } from \"../../routing/index.js\";\nimport type { PartitionKey, PartitionKeyDefinition } from \"../../documents/index.js\";\nimport { convertToInternalPartitionKey } from \"../../documents/index.js\";\nimport type {\n  ChangeFeedPullModelIterator,\n  ChangeFeedIteratorOptions,\n} from \"../../client/ChangeFeed/index.js\";\nimport { validateChangeFeedIteratorOptions } from \"../../client/ChangeFeed/changeFeedUtils.js\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal.js\";\nimport { DiagnosticNodeType } from \"../../diagnostics/DiagnosticNodeInternal.js\";\nimport {\n  getEmptyCosmosDiagnostics,\n  withDiagnostics,\n  addDiagnosticChild,\n} from \"../../utils/diagnostics.js\";\nimport { randomUUID } from \"@azure/core-util\";\nimport { readPartitionKeyDefinition } from \"../ClientUtils.js\";\nimport { ChangeFeedIteratorBuilder } from \"../ChangeFeed/ChangeFeedIteratorBuilder.js\";\nimport type { EncryptionQueryBuilder } from \"../../encryption/index.js\";\nimport type { EncryptionSqlParameter } from \"../../encryption/EncryptionQueryBuilder.js\";\nimport type { Resource } from \"../Resource.js\";\nimport { TypeMarker } from \"../../encryption/enums/TypeMarker.js\";\nimport { EncryptionItemQueryIterator } from \"../../encryption/EncryptionItemQueryIterator.js\";\nimport { ErrorResponse } from \"../../request/index.js\";\nimport { BulkHelper } from \"../../bulk/BulkHelper.js\";\n\n/**\n * @hidden\n */\nfunction isChangeFeedOptions(options: unknown): options is ChangeFeedOptions {\n  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));\n}\n\n/**\n * Operations for creating new items, and reading/querying all items\n *\n * @see {@link Item} for reading, replacing, or deleting an existing container; use `.item(id)`.\n */\nexport class Items {\n  private partitionKeyRangeCache: PartitionKeyRangeCache;\n  /**\n   * Create an instance of {@link Items} linked to the parent {@link Container}.\n   * @param container - The parent container.\n   * @hidden\n   */\n  constructor(\n    public readonly container: Container,\n    private readonly clientContext: ClientContext,\n  ) {\n    this.partitionKeyRangeCache = new PartitionKeyRangeCache(this.clientContext);\n  }\n\n  /**\n   * Queries all items.\n   * @param query - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to configure a query.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```ts snippet:ItemsQueryItems\n   * import { CosmosClient, SqlQuerySpec } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const querySpec: SqlQuerySpec = {\n   *   query: `SELECT * FROM Families f WHERE f.lastName = @lastName`,\n   *   parameters: [{ name: \"@lastName\", value: \"Hendricks\" }],\n   * };\n   * const { resources: items } = await container.items.query(querySpec).fetchAll();\n   * ```\n   */\n\n  //\n  public query(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<any>;\n  /**\n   * Queries all items.\n   * @param query - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to configure a query.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```ts snippet:ItemsQueryItems\n   * import { CosmosClient, SqlQuerySpec } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const querySpec: SqlQuerySpec = {\n   *   query: `SELECT * FROM Families f WHERE f.lastName = @lastName`,\n   *   parameters: [{ name: \"@lastName\", value: \"Hendricks\" }],\n   * };\n   * const { resources: items } = await container.items.query(querySpec).fetchAll();\n   * ```\n   */\n  public query<T>(query: string | SqlQuerySpec, options?: FeedOptions): QueryIterator<T>;\n  public query<T>(query: string | SqlQuerySpec, options: FeedOptions = {}): QueryIterator<T> {\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n\n    const fetchFunction: FetchFunctionCallback = async (\n      diagnosticNode: DiagnosticNodeInternal,\n      innerOptions: FeedOptions,\n      correlatedActivityId: string,\n    ) => {\n      const response = await this.clientContext.queryFeed({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        resultFn: (result) => (result ? result.Documents : []),\n        query,\n        options: innerOptions,\n        partitionKey: options.partitionKey,\n        diagnosticNode,\n        correlatedActivityId: correlatedActivityId,\n      });\n      return response;\n    };\n    let iterator: QueryIterator<T>;\n    if (this.clientContext.enableEncryption) {\n      iterator = new EncryptionItemQueryIterator(\n        this.clientContext,\n        query,\n        options,\n        fetchFunction,\n        this.container,\n      );\n    } else {\n      iterator = new QueryIterator<T>(\n        this.clientContext,\n        query,\n        options,\n        fetchFunction,\n        this.container.url,\n        ResourceType.item,\n      );\n    }\n    return iterator;\n  }\n  /**\n   * Queries all items in an encrypted container.\n   * @param queryBuilder - Query configuration for the operation. See {@link SqlQuerySpec} for more info on how to build a query on encrypted properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```ts snippet:ItemsQueryEncryptedItems\n   * import { CosmosClient, EncryptionQueryBuilder } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const queryBuilder = new EncryptionQueryBuilder(\n   *   `SELECT firstname FROM Families f WHERE f.lastName = @lastName`,\n   * );\n   * queryBuilder.addParameter(\"@lastName\", \"Hendricks\", \"/lastname\");\n   * const queryIterator = await container.items.getEncryptionQueryIterator(queryBuilder);\n   * const { resources: items } = await queryIterator.fetchAll();\n   * ```\n   */\n  public async getEncryptionQueryIterator(\n    queryBuilder: EncryptionQueryBuilder,\n    options: FeedOptions = {},\n  ): Promise<QueryIterator<ItemDefinition>> {\n    const encryptionSqlQuerySpec = queryBuilder.toEncryptionSqlQuerySpec();\n    const sqlQuerySpec = await this.buildSqlQuerySpec(encryptionSqlQuerySpec);\n    const iterator = this.query<ItemDefinition>(sqlQuerySpec, options);\n    return iterator;\n  }\n\n  private async buildSqlQuerySpec(encryptionSqlQuerySpec: SqlQuerySpec): Promise<SqlQuerySpec> {\n    let encryptionParameters = encryptionSqlQuerySpec.parameters as EncryptionSqlParameter[];\n    const sqlQuerySpec: SqlQuerySpec = {\n      query: encryptionSqlQuerySpec.query,\n      parameters: [],\n    };\n    // returns copy to avoid encryption of original parameters passed\n    encryptionParameters = copyObject(encryptionParameters);\n    for (const parameter of encryptionParameters) {\n      let value: any;\n      if (parameter.type !== undefined || parameter.type !== TypeMarker.Null) {\n        value = await this.container.encryptionProcessor.encryptQueryParameter(\n          parameter.path,\n          parameter.value,\n          parameter.path === \"/id\",\n          parameter.type,\n        );\n      }\n      sqlQuerySpec.parameters.push({ name: parameter.name, value: value });\n    }\n    return sqlQuerySpec;\n  }\n\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   *\n   * @deprecated Use `getChangeFeedIterator` instead.\n   *\n   * @example Read from the beginning of the change feed.\n   * ```ts snippet:ignore\n   * const iterator = items.readChangeFeed({ startFromBeginning: true });\n   * const firstPage = await iterator.fetchNext();\n   * const firstPageResults = firstPage.result\n   * const secondPage = await iterator.fetchNext();\n   * ```\n   */\n  public readChangeFeed(\n    partitionKey: PartitionKey,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   *\n   */\n  public readChangeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public readChangeFeed<T>(\n    partitionKey: PartitionKey,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<T>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public readChangeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;\n  public readChangeFeed<T>(\n    partitionKeyOrChangeFeedOptions?: PartitionKey | ChangeFeedOptions,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<T> {\n    if (isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions);\n    } else {\n      return this.changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions);\n    }\n  }\n\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   * @example Read from the beginning of the change feed.\n   * ```ts snippet:ignore\n   * const iterator = items.readChangeFeed({ startFromBeginning: true });\n   * const firstPage = await iterator.fetchNext();\n   * const firstPageResults = firstPage.result\n   * const secondPage = await iterator.fetchNext();\n   * ```\n   */\n  public changeFeed(\n    partitionKey: PartitionKey,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public changeFeed(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<any>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public changeFeed<T>(\n    partitionKey: PartitionKey,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<T>;\n  /**\n   * Create a `ChangeFeedIterator` to iterate over pages of changes\n   * @deprecated Use `getChangeFeedIterator` instead.\n   */\n  public changeFeed<T>(changeFeedOptions?: ChangeFeedOptions): ChangeFeedIterator<T>;\n  public changeFeed<T>(\n    partitionKeyOrChangeFeedOptions?: PartitionKey | ChangeFeedOptions,\n    changeFeedOptions?: ChangeFeedOptions,\n  ): ChangeFeedIterator<T> {\n    let partitionKey: PartitionKey;\n    if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {\n      partitionKey = undefined;\n      changeFeedOptions = partitionKeyOrChangeFeedOptions;\n    } else if (\n      partitionKeyOrChangeFeedOptions !== undefined &&\n      !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)\n    ) {\n      partitionKey = partitionKeyOrChangeFeedOptions;\n    }\n\n    if (!changeFeedOptions) {\n      changeFeedOptions = {};\n    }\n\n    const path = getPathFromLink(this.container.url, ResourceType.item);\n    const id = getIdFromLink(this.container.url);\n    return new ChangeFeedIterator<T>(this.clientContext, id, path, partitionKey, changeFeedOptions);\n  }\n\n  /**\n   * Returns an iterator to iterate over pages of changes. The iterator returned can be used to fetch changes for a single partition key, feed range or an entire container.\n   *\n   * @example\n   * ```ts snippet:ReadmeSampleChangeFeedPullModelIteratorPartitionKey\n   * import {\n   *   CosmosClient,\n   *   PartitionKeyDefinitionVersion,\n   *   PartitionKeyKind,\n   *   ChangeFeedStartFrom,\n   * } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const containerDefinition = {\n   *   id: \"Test Database\",\n   *   partitionKey: {\n   *     paths: [\"/name\", \"/address/zip\"],\n   *     version: PartitionKeyDefinitionVersion.V2,\n   *     kind: PartitionKeyKind.MultiHash,\n   *   },\n   * };\n   * const { container } = await database.containers.createIfNotExists(containerDefinition);\n   *\n   * const partitionKey = \"some-partition-Key-value\";\n   * const options = {\n   *   changeFeedStartFrom: ChangeFeedStartFrom.Beginning(partitionKey),\n   * };\n   *\n   * const iterator = container.items.getChangeFeedIterator(options);\n   *\n   * while (iterator.hasMoreResults) {\n   *   const response = await iterator.readNext();\n   *   // process this response\n   * }\n   * ```\n   */\n  public getChangeFeedIterator<T>(\n    changeFeedIteratorOptions?: ChangeFeedIteratorOptions,\n  ): ChangeFeedPullModelIterator<T> {\n    const cfOptions = changeFeedIteratorOptions !== undefined ? changeFeedIteratorOptions : {};\n    validateChangeFeedIteratorOptions(cfOptions);\n    const iterator = new ChangeFeedIteratorBuilder<T>(\n      cfOptions,\n      this.clientContext,\n      this.container,\n      this.partitionKeyRangeCache,\n    );\n    return iterator;\n  }\n\n  /**\n   * Read all items.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```ts snippet:ItemsReadAll\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { resources: containerList } = await container.items.readAll().fetchAll();\n   * ```\n   */\n  public readAll(options?: FeedOptions): QueryIterator<ItemDefinition>;\n  /**\n   * Read all items.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Read all items to array.\n   * ```ts snippet:ItemsReadAll\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { resources: containerList } = await container.items.readAll().fetchAll();\n   * ```\n   */\n  public readAll<T extends ItemDefinition>(options?: FeedOptions): QueryIterator<T>;\n  public readAll<T extends ItemDefinition>(options?: FeedOptions): QueryIterator<T> {\n    return this.query<T>(\"SELECT * from c\", options);\n  }\n\n  /**\n   * Create an item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - Represents the body of the item. Can contain any number of user defined properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Create an item.\n   * ```ts snippet:ContainerItems\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { resource: createdItem } = await container.items.create({\n   *   id: \"<item id>\",\n   *   properties: {},\n   * });\n   * ```\n   */\n  public async create<T extends ItemDefinition = any>(\n    body: T,\n    options: RequestOptions = {},\n  ): Promise<ItemResponse<T>> {\n    // Generate random document id if the id is missing in the payload and\n    // options.disableAutomaticIdGeneration != true\n\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n        body.id = randomUUID();\n      }\n      const partitionKeyDefinition = await readPartitionKeyDefinition(\n        diagnosticNode,\n        this.container,\n      );\n      let partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n      let response: Response<T & Resource>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          const { body: encryptedBody, propertiesEncryptedCount } =\n            await this.container.encryptionProcessor.encrypt(body);\n          body = encryptedBody;\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            propertiesEncryptedCount,\n          );\n\n          partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n        }\n        const err = {};\n        if (!isItemResourceValid(body, err)) {\n          throw err;\n        }\n        const path = getPathFromLink(this.container.url, ResourceType.item);\n        const id = getIdFromLink(this.container.url);\n        response = await this.clientContext.create<T>({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          diagnosticNode,\n          options,\n          partitionKey,\n        });\n      } catch (error: any) {\n        if (this.clientContext.enableEncryption) {\n          // Todo: internally retry post policy refresh\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n\n      if (this.clientContext.enableEncryption) {\n        // try block for decrypting response. This is done so that we can throw special error message in case of decryption failure\n        try {\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n          );\n          const { body: decryptedResult, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(response.result);\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n            propertiesDecryptedCount,\n          );\n          response.result = decryptedResult;\n          partitionKey = extractPartitionKeys(response.result, partitionKeyDefinition);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Item creation was successful but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      const ref = new Item(\n        this.container,\n        (response.result as any).id,\n        this.clientContext,\n        partitionKey,\n      );\n      return new ItemResponse(\n        response.result,\n        response.headers,\n        response.code,\n        response.substatus,\n        ref,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Upsert an item.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - Represents the body of the item. Can contain any number of user defined properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   */\n  public async upsert(\n    body: unknown,\n    options?: RequestOptions,\n  ): Promise<ItemResponse<ItemDefinition>>;\n  /**\n   * Upsert an item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - Represents the body of the item. Can contain any number of user defined properties.\n   * @param options - Used for modifying the request (for instance, specifying the partition key).\n   * @example Upsert an item.\n   * ```ts snippet:ItemsUpsert\n   * import { CosmosClient } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const { resource: createdItem1 } = await container.items.create({\n   *   id: \"<item id 1>\",\n   *   properties: {},\n   * });\n   *\n   * const { resource: upsertItem1 } = await container.items.upsert({\n   *   id: \"<item id 1>\",\n   *   updated_properties: {},\n   * });\n   *\n   * const { resource: upsertItem2 } = await container.items.upsert({\n   *   id: \"<item id 2>\",\n   *   properties: {},\n   * });\n   * ```\n   */\n  public async upsert<T extends ItemDefinition>(\n    body: T,\n    options?: RequestOptions,\n  ): Promise<ItemResponse<T>>;\n  public async upsert<T extends ItemDefinition>(\n    body: T,\n    options: RequestOptions = {},\n  ): Promise<ItemResponse<T>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      // Generate random document id if the id is missing in the payload and\n      // options.disableAutomaticIdGeneration != true\n      if ((body.id === undefined || body.id === \"\") && !options.disableAutomaticIdGeneration) {\n        body.id = randomUUID();\n      }\n\n      const partitionKeyDefinition = await readPartitionKeyDefinition(\n        diagnosticNode,\n        this.container,\n      );\n      let partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n      let response: Response<T & Resource>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          // returns copy to avoid encryption of original body passed\n          body = copyObject(body);\n          options = options || {};\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          const { body: encryptedBody, propertiesEncryptedCount } =\n            await this.container.encryptionProcessor.encrypt(body);\n          body = encryptedBody;\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            propertiesEncryptedCount,\n          );\n          partitionKey = extractPartitionKeys(body, partitionKeyDefinition);\n        }\n\n        const err = {};\n        if (!isItemResourceValid(body, err)) {\n          throw err;\n        }\n\n        const path = getPathFromLink(this.container.url, ResourceType.item);\n        const id = getIdFromLink(this.container.url);\n        response = await this.clientContext.upsert<T>({\n          body,\n          path,\n          resourceType: ResourceType.item,\n          resourceId: id,\n          options,\n          partitionKey,\n          diagnosticNode,\n        });\n      } catch (error: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(error);\n        }\n        throw error;\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          // try block for decrypting response. This is done so that we can throw special error message in case of decryption failure\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n          );\n          const { body: decryptedResult, propertiesDecryptedCount } =\n            await this.container.encryptionProcessor.decrypt(response.result);\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n            propertiesDecryptedCount,\n          );\n          response.result = decryptedResult;\n          partitionKey = extractPartitionKeys(response.result, partitionKeyDefinition);\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Item upsert was successful but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n\n      const ref = new Item(\n        this.container,\n        (response.result as any).id,\n        this.clientContext,\n        partitionKey,\n      );\n      return new ItemResponse(\n        response.result,\n        response.headers,\n        response.code,\n        response.substatus,\n        ref,\n        getEmptyCosmosDiagnostics(),\n      );\n    }, this.clientContext);\n  }\n\n  /**\n   * Execute bulk operations on items.\n   * @param operations - List of operations\n   * @param options - used for modifying the request\n   * @returns list of operation results corresponding to the operations\n   *\n   * @example\n   * ```ts snippet:ItemsExecuteBulkOperations\n   * import { CosmosClient, OperationInput } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * const operations: OperationInput[] = [\n   *   {\n   *     operationType: \"Create\",\n   *     resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" },\n   *   },\n   *   {\n   *     operationType: \"Upsert\",\n   *     partitionKey: \"A\",\n   *     resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" },\n   *   },\n   * ];\n   *\n   * await container.items.executeBulkOperations(operations);\n   * ```\n   */\n  public async executeBulkOperations(\n    operations: OperationInput[],\n    options: RequestOptions = {},\n  ): Promise<BulkOperationResult[]> {\n    const bulkHelper = new BulkHelper(\n      this.container,\n      this.clientContext,\n      this.partitionKeyRangeCache,\n      options,\n    );\n    return bulkHelper.execute(operations);\n  }\n\n  /**\n   * Execute bulk operations on items.\n   *\n   * Bulk takes an array of Operations which are typed based on what the operation does.\n   * The choices are: Create, Upsert, Read, Replace, and Delete\n   *\n   * Usage example:\n   * ```ts snippet:ItemsBulk\n   * import { CosmosClient, OperationInput } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * // partitionKey is optional at the top level if present in the resourceBody\n   * const operations: OperationInput[] = [\n   *   {\n   *     operationType: \"Create\",\n   *     resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" },\n   *   },\n   *   {\n   *     operationType: \"Upsert\",\n   *     partitionKey: \"A\",\n   *     resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" },\n   *   },\n   * ];\n   *\n   * await container.items.bulk(operations);\n   * ```\n   *\n   * @param operations - List of operations. Limit 100\n   * @param bulkOptions - Optional options object to modify bulk behavior. Pass \\{ continueOnError: false \\} to stop executing operations when one fails. (Defaults to true)\n   * @param options - Used for modifying the request.\n   */\n  public async bulk(\n    operations: OperationInput[],\n    bulkOptions?: BulkOptions,\n    options?: RequestOptions,\n  ): Promise<BulkOperationResponse> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      const partitionKeyRanges = (\n        await this.partitionKeyRangeCache.onCollectionRoutingMap(this.container.url, diagnosticNode)\n      ).getOrderedParitionKeyRanges();\n\n      const partitionKeyDefinition = await readPartitionKeyDefinition(\n        diagnosticNode,\n        this.container,\n      );\n\n      if (this.clientContext.enableEncryption) {\n        // returns copy to avoid encryption of original operations body passed\n        operations = copyObject(operations);\n        options = options || {};\n        await this.container.checkAndInitializeEncryption();\n        options.containerRid = this.container._rid;\n        diagnosticNode.beginEncryptionDiagnostics(Constants.Encryption.DiagnosticsEncryptOperation);\n        const { operations: encryptedOperations, totalPropertiesEncryptedCount } =\n          await this.bulkBatchEncryptionHelper(operations);\n        operations = encryptedOperations;\n        diagnosticNode.endEncryptionDiagnostics(\n          Constants.Encryption.DiagnosticsEncryptOperation,\n          totalPropertiesEncryptedCount,\n        );\n      }\n\n      const batches: Batch[] = partitionKeyRanges.map((keyRange: PartitionKeyRange) => {\n        return {\n          min: keyRange.minInclusive,\n          max: keyRange.maxExclusive,\n          rangeId: keyRange.id,\n          indexes: [] as number[],\n          operations: [] as Operation[],\n        };\n      });\n\n      this.groupOperationsBasedOnPartitionKey(operations, partitionKeyDefinition, options, batches);\n\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n\n      const orderedResponses: OperationResponse[] = [];\n      // split batches based on cumulative size of operations\n      const batchMap = batches\n        .filter((batch: Batch) => batch.operations.length)\n        .flatMap((batch: Batch) => splitBatchBasedOnBodySize(batch));\n\n      await Promise.all(\n        this.executeBatchOperations(\n          batchMap,\n          path,\n          bulkOptions,\n          options,\n          diagnosticNode,\n          orderedResponses,\n          partitionKeyDefinition,\n        ),\n      );\n      const response: any = orderedResponses;\n      response.diagnostics = diagnosticNode.toDiagnostic(this.clientContext.getClientConfig());\n      return response;\n    }, this.clientContext);\n  }\n\n  private executeBatchOperations(\n    batchMap: Batch[],\n    path: string,\n    bulkOptions: BulkOptions,\n    options: RequestOptions,\n    diagnosticNode: DiagnosticNodeInternal,\n    orderedResponses: OperationResponse[],\n    partitionKeyDefinition: PartitionKeyDefinition,\n  ): Promise<void>[] {\n    return batchMap.map(async (batch: Batch) => {\n      if (batch.operations.length > 100) {\n        throw new Error(\"Cannot run bulk request with more than 100 operations per partition\");\n      }\n      let response: Response<OperationResponse[]>;\n      try {\n        response = await addDiagnosticChild(\n          async (childNode: DiagnosticNodeInternal) =>\n            this.clientContext.bulk({\n              body: batch.operations,\n              partitionKeyRangeId: batch.rangeId,\n              path,\n              resourceId: this.container.url,\n              bulkOptions,\n              options,\n              diagnosticNode: childNode,\n            }),\n          diagnosticNode,\n          DiagnosticNodeType.BATCH_REQUEST,\n        );\n        response.result.forEach((operationResponse: OperationResponse, index: number) => {\n          orderedResponses[batch.indexes[index]] = operationResponse;\n        });\n      } catch (err: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(err);\n        }\n        // In the case of 410 errors, we need to recompute the partition key ranges\n        // and redo the batch request, however, 410 errors occur for unsupported\n        // partition key types as well since we don't support them, so for now we throw\n        if (err.code === StatusCodes.Gone) {\n          const isPartitionSplit =\n            err.substatus === SubStatusCodes.PartitionKeyRangeGone ||\n            err.substatus === SubStatusCodes.CompletingSplit;\n\n          if (isPartitionSplit) {\n            const queryRange = new QueryRange(batch.min, batch.max, true, false);\n            const overlappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n              this.container.url,\n              queryRange,\n              diagnosticNode,\n              true,\n            );\n            if (overlappingRanges.length < 1) {\n              throw new Error(\"Partition split/merge detected but no overlapping ranges found.\");\n            }\n            // Handles both merge (overlappingRanges.length === 1) and split (overlappingRanges.length > 1) cases.\n            if (overlappingRanges.length >= 1) {\n              // const splitBatches: Batch[] = [];\n              const newBatches: Batch[] = this.createNewBatches(\n                overlappingRanges,\n                batch,\n                partitionKeyDefinition,\n              );\n\n              await Promise.all(\n                this.executeBatchOperations(\n                  newBatches,\n                  path,\n                  bulkOptions,\n                  options,\n                  diagnosticNode,\n                  orderedResponses,\n                  partitionKeyDefinition,\n                ),\n              );\n            }\n          } else {\n            throw new Error(\n              \"Partition key error. An operation has an unsupported partitionKey type\" +\n                err.message,\n            );\n          }\n        } else {\n          throw new Error(`Bulk request errored with: ${err.message}`);\n        }\n      }\n      if (response) {\n        try {\n          if (this.clientContext.enableEncryption) {\n            diagnosticNode.beginEncryptionDiagnostics(\n              Constants.Encryption.DiagnosticsDecryptOperation,\n            );\n            let count = 0;\n            for (const result of response.result) {\n              if (result.resourceBody) {\n                const { body, propertiesDecryptedCount } =\n                  await this.container.encryptionProcessor.decrypt(result.resourceBody);\n                result.resourceBody = body;\n                count += propertiesDecryptedCount;\n              }\n            }\n            diagnosticNode.endEncryptionDiagnostics(\n              Constants.Encryption.DiagnosticsDecryptOperation,\n              count,\n            );\n          }\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Batch response was received but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n        response.result.forEach((operationResponse: OperationResponse, index: number) => {\n          orderedResponses[batch.indexes[index]] = operationResponse;\n        });\n      }\n    });\n  }\n\n  /**\n   * Function to create new batches based of partition key Ranges.\n   *\n   * @param overlappingRanges - Overlapping partition key ranges.\n   * @param batch - Batch to be split.\n   * @param partitionKeyDefinition - PartitionKey definition of container.\n   * @returns Array of new batches.\n   */\n  private createNewBatches(\n    overlappingRanges: PartitionKeyRange[],\n    batch: Batch,\n    partitionKeyDefinition: PartitionKeyDefinition,\n  ): Batch[] {\n    const newBatches: Batch[] = overlappingRanges.map((keyRange: PartitionKeyRange) => {\n      return {\n        min: keyRange.minInclusive,\n        max: keyRange.maxExclusive,\n        rangeId: keyRange.id,\n        indexes: [] as number[],\n        operations: [] as Operation[],\n      };\n    });\n    let indexValue = 0;\n    batch.operations.forEach((operation) => {\n      const partitionKey = JSON.parse(operation.partitionKey);\n      const hashed = hashPartitionKey(\n        assertNotUndefined(\n          partitionKey,\n          \"undefined value for PartitionKey is not expected during grouping of bulk operations.\",\n        ),\n        partitionKeyDefinition,\n      );\n      const batchForKey = assertNotUndefined(\n        newBatches.find((newBatch: Batch) => {\n          return isKeyInRange(newBatch.min, newBatch.max, hashed);\n        }),\n        \"No suitable Batch found.\",\n      );\n      batchForKey.operations.push(operation);\n      batchForKey.indexes.push(batch.indexes[indexValue]);\n      indexValue++;\n    });\n    return newBatches;\n  }\n\n  /**\n   * Function to create batches based of partition key Ranges.\n   * @param operations - operations to group\n   * @param partitionDefinition - PartitionKey definition of container.\n   * @param options - Request options for bulk request.\n   * @param batches - Groups to be filled with operations.\n   */\n  private groupOperationsBasedOnPartitionKey(\n    operations: OperationInput[],\n    partitionDefinition: PartitionKeyDefinition,\n    options: RequestOptions | undefined,\n    batches: Batch[],\n  ) {\n    operations.forEach((operationInput, index: number) => {\n      const { operation, partitionKey } = prepareOperations(\n        operationInput,\n        partitionDefinition,\n        options,\n      );\n      const hashed = hashPartitionKey(\n        assertNotUndefined(\n          partitionKey,\n          \"undefined value for PartitionKey is not expected during grouping of bulk operations.\",\n        ),\n        partitionDefinition,\n      );\n      const batchForKey = assertNotUndefined(\n        batches.find((batch: Batch) => {\n          return isKeyInRange(batch.min, batch.max, hashed);\n        }),\n        \"No suitable Batch found.\",\n      );\n      batchForKey.operations.push(operation);\n      batchForKey.indexes.push(index);\n    });\n  }\n\n  /**\n   * Execute transactional batch operations on items.\n   *\n   * Batch takes an array of Operations which are typed based on what the operation does. Batch is transactional and will rollback all operations if one fails.\n   * The choices are: Create, Upsert, Read, Replace, and Delete\n   *\n   * Usage example:\n   * ```ts snippet:ItemsBatch\n   * import { CosmosClient, OperationInput } from \"@azure/cosmos\";\n   *\n   * const endpoint = \"https://your-account.documents.azure.com\";\n   * const key = \"<database account masterkey>\";\n   * const client = new CosmosClient({ endpoint, key });\n   *\n   * const { database } = await client.databases.createIfNotExists({ id: \"Test Database\" });\n   *\n   * const { container } = await database.containers.createIfNotExists({ id: \"Test Container\" });\n   *\n   * // The partitionKey is a required second argument. If it’s undefined, it defaults to the expected partition key format.\n   * const operations: OperationInput[] = [\n   *   {\n   *     operationType: \"Create\",\n   *     resourceBody: { id: \"doc1\", name: \"sample\", key: \"A\" },\n   *   },\n   *   {\n   *     operationType: \"Upsert\",\n   *     resourceBody: { id: \"doc2\", name: \"other\", key: \"A\" },\n   *   },\n   * ];\n   *\n   * await container.items.batch(operations, \"A\");\n   * ```\n   *\n   * @param operations - List of operations. Limit 100\n   * @param options - Used for modifying the request\n   */\n  public async batch(\n    operations: OperationInput[],\n    partitionKey?: PartitionKey,\n    options?: RequestOptions,\n  ): Promise<Response<OperationResponse[]>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      operations.map((operation) => decorateBatchOperation(operation, options));\n      partitionKey = await setPartitionKeyIfUndefined(diagnosticNode, this.container, partitionKey);\n      const path = getPathFromLink(this.container.url, ResourceType.item);\n\n      if (operations.length > 100) {\n        throw new Error(\"Cannot run batch request with more than 100 operations per partition\");\n      }\n      let response: Response<OperationResponse[]>;\n      try {\n        if (this.clientContext.enableEncryption) {\n          // returns copy to avoid encryption of original operations body passed\n          operations = copyObject(operations);\n          options = options || {};\n          await this.container.checkAndInitializeEncryption();\n          options.containerRid = this.container._rid;\n          let count = 0;\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n          );\n          if (partitionKey) {\n            const partitionKeyInternal = convertToInternalPartitionKey(partitionKey);\n            const { partitionKeyList, encryptedCount } =\n              await this.container.encryptionProcessor.getEncryptedPartitionKeyValue(\n                partitionKeyInternal,\n              );\n            partitionKey = partitionKeyList;\n            count += encryptedCount;\n          }\n          const { operations: encryptedOperations, totalPropertiesEncryptedCount } =\n            await this.bulkBatchEncryptionHelper(operations);\n          operations = encryptedOperations;\n          count += totalPropertiesEncryptedCount;\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsEncryptOperation,\n            count,\n          );\n        }\n\n        response = await this.clientContext.batch({\n          body: operations,\n          partitionKey,\n          path,\n          resourceId: this.container.url,\n          options,\n          diagnosticNode,\n        });\n      } catch (err: any) {\n        if (this.clientContext.enableEncryption) {\n          await this.container.throwIfRequestNeedsARetryPostPolicyRefresh(err);\n        }\n        throw new Error(`Batch request error: ${err.message}`);\n      }\n      if (this.clientContext.enableEncryption) {\n        try {\n          diagnosticNode.beginEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n          );\n          let count = 0;\n          for (const result of response.result) {\n            if (result.resourceBody) {\n              const { body, propertiesDecryptedCount } =\n                await this.container.encryptionProcessor.decrypt(result.resourceBody);\n              result.resourceBody = body;\n              count += propertiesDecryptedCount;\n            }\n          }\n          diagnosticNode.endEncryptionDiagnostics(\n            Constants.Encryption.DiagnosticsDecryptOperation,\n            count,\n          );\n        } catch (error) {\n          const decryptionError = new ErrorResponse(\n            `Batch response was received but response decryption failed: + ${error.message}`,\n          );\n          decryptionError.code = StatusCodes.ServiceUnavailable;\n          throw decryptionError;\n        }\n      }\n      return response;\n    }, this.clientContext);\n  }\n\n  private async bulkBatchEncryptionHelper(\n    operations: OperationInput[],\n  ): Promise<{ operations: OperationInput[]; totalPropertiesEncryptedCount: number }> {\n    let totalPropertiesEncryptedCount = 0;\n    const encryptedOperations: OperationInput[] = [];\n    for (const operation of operations) {\n      const { operation: encryptedOp, totalPropertiesEncryptedCount: updatedCount } =\n        await encryptOperationInput(\n          this.container.encryptionProcessor,\n          operation,\n          totalPropertiesEncryptedCount,\n        );\n      totalPropertiesEncryptedCount = updatedCount;\n      encryptedOperations.push(encryptedOp);\n    }\n    return { operations: encryptedOperations, totalPropertiesEncryptedCount };\n  }\n}\n"]}