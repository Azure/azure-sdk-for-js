{"version":3,"file":"ChangeFeedForEpkRange.js","sourceRoot":"","sources":["../../../../src/client/ChangeFeed/ChangeFeedForEpkRange.ts"],"names":[],"mappings":";;;;AAAA,uCAAuC;AACvC,kCAAkC;AAClC,6DAAuD;AACvD,mFAA6E;AAE7E,qDAAoD;AACpD,2DAAqD;AAGrD,oDAA6F;AAE7F,qDAAuD;AACvD,mFAA6E;AAE7E,6DAA2F;AAG3F,+DAAwF;AACxF,2DAAqD;AACrD;;;;;GAKG;AACH,MAAa,qBAAqB;IAOhC;;OAEG;IACH,YACU,aAA4B,EAC5B,SAAoB,EACpB,sBAA8C,EAC9C,UAAkB,EAClB,YAAoB,EACpB,GAAW,EACX,iBAAoD,EACpD,QAAoB;QAPpB,kBAAa,GAAb,aAAa,CAAe;QAC5B,cAAS,GAAT,SAAS,CAAW;QACpB,2BAAsB,GAAtB,sBAAsB,CAAwB;QAC9C,eAAU,GAAV,UAAU,CAAQ;QAClB,iBAAY,GAAZ,YAAY,CAAQ;QACpB,QAAG,GAAH,GAAG,CAAQ;QACX,sBAAiB,GAAjB,iBAAiB,CAAmC;QACpD,aAAQ,GAAR,QAAQ,CAAY;QAoLtB,8BAAyB,GAAG,GAAW,EAAE;YAC/C,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,0DAA0B,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;QAC/F,CAAC,CAAC;QApLA,IAAI,CAAC,KAAK,GAAG,IAAI,kCAAc,EAAmB,CAAC;QACnD,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC,iBAAiB;YAC1D,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,iBAAiB,CAAC;YACjD,CAAC,CAAC,SAAS,CAAC;QACd,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;QAC5B,wKAAwK;QACxK,IAAI,iBAAiB,CAAC,YAAY,EAAE,CAAC;YACnC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAC3B,CAAC;aAAM,IAAI,iBAAiB,CAAC,SAAS,EAAE,CAAC;YACvC,IAAI,CAAC,SAAS,GAAG,iBAAiB,CAAC,SAAS,CAAC,WAAW,EAAE,CAAC;QAC7D,CAAC;IACH,CAAC;IAEO,KAAK,CAAC,cAAc,CAAC,cAAsC;QACjE,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,cAAc,CAAC,CAAC;QACvE,IAAI,CAAC,GAAG,GAAG,QAAQ,CAAC,IAAI,CAAC;IAC3B,CAAC;IAEO,qCAAqC;QAC3C,IAAI,IAAI,CAAC,iBAAiB,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,EAAE,CAAC;YAC5C,OAAO,KAAK,CAAC;QACf,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEO,KAAK,CAAC,mBAAmB,CAAC,cAAsC;QACtE,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC3B,yDAAyD;YACzD,MAAM,IAAI,CAAC,gCAAgC,CAAC,cAAc,CAAC,CAAC;QAC9D,CAAC;aAAM,CAAC;YACN,mEAAmE;YACnE,MAAM,IAAI,CAAC,0BAA0B,CAAC,cAAc,CAAC,CAAC;QACxD,CAAC;QACD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC7B,CAAC;IAED;;OAEG;IACK,KAAK,CAAC,0BAA0B,CAAC,cAAsC;QAC7E,IAAI,CAAC;YACH,MAAM,iBAAiB,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,oBAAoB,CAC9E,IAAI,CAAC,GAAG,EACR,IAAI,CAAC,QAAQ,EACb,cAAc,CACf,CAAC;YACF,KAAK,MAAM,gBAAgB,IAAI,iBAAiB,EAAE,CAAC;gBACjD,MAAM,CAAC,YAAY,EAAE,YAAY,CAAC,GAAG,MAAM,IAAA,6CAAwB,EACjE,IAAI,CAAC,QAAQ,EACb,gBAAgB,CACjB,CAAC;gBACF,MAAM,SAAS,GAAoB,IAAI,oCAAe,CACpD,gBAAgB,CAAC,YAAY,EAC7B,gBAAgB,CAAC,YAAY,EAC7B,EAAE,EACF,YAAY,EACZ,YAAY,CACb,CAAC;gBACF,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;YAChC,CAAC;QACH,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,MAAM,IAAI,wBAAa,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QACvC,CAAC;IACH,CAAC;IACD;;OAEG;IACK,KAAK,CAAC,gCAAgC,CAC5C,cAAsC;QAEtC,MAAM,SAAS,GAAG,IAAI,CAAC,iBAAiB,CAAC;QACzC,IAAI,CAAC,IAAI,CAAC,qCAAqC,EAAE,EAAE,CAAC;YAClD,MAAM,IAAI,wBAAa,CAAC,oEAAoE,CAAC,CAAC;QAChG,CAAC;aAAM,CAAC;YACN,KAAK,MAAM,MAAM,IAAI,SAAS,CAAC,YAAY,EAAE,CAAC;gBAC5C,MAAM,UAAU,GAAG,IAAI,qBAAU,CAAC,MAAM,CAAC,YAAY,EAAE,MAAM,CAAC,YAAY,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;gBACzF,IAAI,CAAC;oBACH,MAAM,iBAAiB,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,oBAAoB,CAC9E,IAAI,CAAC,GAAG,EACR,UAAU,EACV,cAAc,CACf,CAAC;oBACF,KAAK,MAAM,gBAAgB,IAAI,iBAAiB,EAAE,CAAC;wBACjD,8FAA8F;wBAC9F,8EAA8E;wBAC9E,8GAA8G;wBAC9G,8DAA8D;wBAC9D,MAAM,CAAC,YAAY,EAAE,YAAY,CAAC,GAAG,MAAM,IAAA,6CAAwB,EACjE,UAAU,EACV,gBAAgB,CACjB,CAAC;wBACF,MAAM,SAAS,GAAoB,IAAI,oCAAe,CACpD,gBAAgB,CAAC,YAAY,EAC7B,gBAAgB,CAAC,YAAY,EAC7B,MAAM,CAAC,iBAAiB,EACxB,YAAY,EACZ,YAAY,CACb,CAAC;wBACF,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;oBAChC,CAAC;gBACH,CAAC;gBAAC,OAAO,GAAG,EAAE,CAAC;oBACb,MAAM,IAAI,wBAAa,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;gBACvC,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED;;OAEG;IACH,IAAI,cAAc;QAChB,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACW,gBAAgB;;YAC5B,GAAG,CAAC;gBACF,MAAM,MAAM,GAAG,sBAAM,IAAI,CAAC,QAAQ,EAAE,CAAA,CAAC;gBACrC,4BAAM,MAAM,CAAA,CAAC;YACf,CAAC,QAAQ,IAAI,CAAC,cAAc,EAAE;QAChC,CAAC;KAAA;IAED;;;;;;OAMG;IACI,KAAK,CAAC,QAAQ;QACnB,OAAO,IAAA,gCAAe,EAAC,KAAK,EAAE,cAAsC,EAAE,EAAE;YACtE,gEAAgE;YAChE,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC;gBACzB,MAAM,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;gBAC1C,MAAM,IAAI,CAAC,mBAAmB,CAAC,cAAc,CAAC,CAAC;YACjD,CAAC;YAED,4GAA4G;YAC5G,IAAI,yBAAyB,GAAoB,SAAS,CAAC;YAC3D,IAAI,MAAuD,CAAC;YAC5D,GAAG,CAAC;gBACF,MAAM,CAAC,kBAAkB,EAAE,QAAQ,CAAC,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;gBAC5E,MAAM,GAAG,QAAQ,CAAC;gBAElB,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;oBACzB,CAAC;wBACC,IAAI,yBAAyB,KAAK,SAAS,EAAE,CAAC;4BAC5C,yBAAyB,GAAG,kBAAkB,CAAC;wBACjD,CAAC;wBACD,8EAA8E;wBAC9E,8EAA8E;wBAC9E,IAAI,CAAC,KAAK,CAAC,wBAAwB,EAAE,CAAC;wBACtC,2DAA2D;wBAC3D,IAAI,MAAM,CAAC,UAAU,KAAK,sBAAW,CAAC,EAAE,EAAE,CAAC;4BACzC,MAAM,CAAC,OAAO,CAAC,oBAAS,CAAC,WAAW,CAAC,iBAAiB,CAAC;gCACrD,IAAI,CAAC,yBAAyB,EAAE,CAAC;4BAEnC,IAAI,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;gCACxC,MAAM,IAAA,8CAAyB,EAC7B,MAAM,EACN,cAAc,EACd,IAAI,CAAC,iBAAiB,CAAC,cAAc,EACrC,IAAI,CAAC,SAAS,CAAC,mBAAmB,CACnC,CAAC;4BACJ,CAAC;4BACD,OAAO,MAAM,CAAC;wBAChB,CAAC;oBACH,CAAC;gBACH,CAAC;YACH,CAAC,QAAQ,CAAC,IAAI,CAAC,oBAAoB,CAAC,yBAAyB,CAAC,EAAE;YAChE,+CAA+C;YAC/C,MAAM,CAAC,OAAO,CAAC,oBAAS,CAAC,WAAW,CAAC,iBAAiB,CAAC,GAAG,IAAI,CAAC,yBAAyB,EAAE,CAAC;YAC3F,OAAO,MAAM,CAAC;QAChB,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;IACzB,CAAC;IAMD;;OAEG;IACK,KAAK,CAAC,SAAS,CACrB,cAAsC;QAEtC,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QACpC,IAAI,SAAS,EAAE,CAAC;YACd,8DAA8D;YAC9D,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;YAErE,+EAA+E;YAC/E,qFAAqF;YACrF,MAAM,WAAW,GAAY,MAAM,IAAI,CAAC,oBAAoB,CAC1D,SAAS,EACT,MAAM,EACN,cAAc,CACf,CAAC;YAEF,IAAI,WAAW,EAAE,CAAC;gBAChB,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;gBACrB,OAAO,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;YACxC,CAAC;iBAAM,CAAC;gBACN,4DAA4D;gBAC5D,MAAM,6BAA6B,GAAG,MAAM,CAAC,OAAO,CAAC,oBAAS,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;gBACjF,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;gBACvC,YAAY,CAAC,iBAAiB,GAAG,6BAA6B,CAAC;gBAC/D,OAAO,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC;YAChC,CAAC;QACH,CAAC;aAAM,CAAC;YACN,OAAO,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;QAChC,CAAC;IACH,CAAC;IAEO,oBAAoB,CAAC,yBAAsD;QACjF,IAAI,yBAAyB,KAAK,SAAS,EAAE,CAAC;YAC5C,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,0BAA0B,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QACrD,OAAO,CACL,yBAAyB,CAAC,YAAY,MAAK,0BAA0B,aAA1B,0BAA0B,uBAA1B,0BAA0B,CAAE,YAAY,CAAA;YACnF,yBAAyB,CAAC,YAAY,MAAK,0BAA0B,aAA1B,0BAA0B,uBAA1B,0BAA0B,CAAE,YAAY,CAAA;YACnF,yBAAyB,CAAC,YAAY,MAAK,0BAA0B,aAA1B,0BAA0B,uBAA1B,0BAA0B,CAAE,YAAY,CAAA;YACnF,yBAAyB,CAAC,YAAY,MAAK,0BAA0B,aAA1B,0BAA0B,uBAA1B,0BAA0B,CAAE,YAAY,CAAA,CACpF,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAC,oBAAoB,CAChC,SAA0B,EAC1B,QAAyD,EACzD,cAAsC;QAEtC,IAAI,QAAQ,CAAC,UAAU,KAAK,sBAAW,CAAC,EAAE,IAAI,QAAQ,CAAC,UAAU,KAAK,sBAAW,CAAC,WAAW,EAAE,CAAC;YAC9F,OAAO,KAAK,CAAC;QACf,CAAC;QAED,MAAM,cAAc,GAClB,QAAQ,CAAC,UAAU,KAAK,sBAAW,CAAC,IAAI;YACxC,CAAC,QAAQ,CAAC,aAAa,KAAK,yBAAc,CAAC,qBAAqB;gBAC9D,QAAQ,CAAC,aAAa,KAAK,yBAAc,CAAC,eAAe,CAAC,CAAC;QAE/D,IAAI,cAAc,EAAE,CAAC;YACnB,MAAM,UAAU,GAAG,IAAI,qBAAU,CAC/B,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,EACxE,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,EACxE,IAAI,EACJ,KAAK,CACN,CAAC;YACF,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,oBAAoB,CAC3E,IAAI,CAAC,GAAG,EACR,UAAU,EACV,cAAc,EACd,IAAI,CACL,CAAC;YACF,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC9B,MAAM,IAAI,wBAAa,CAAC,iEAAiE,CAAC,CAAC;YAC7F,CAAC;YACD,6CAA6C;YAC7C,8CAA8C;YAC9C,6FAA6F;YAC7F,IAAI,cAAc,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;gBAC/B,MAAM,IAAI,CAAC,kBAAkB,CAC3B,KAAK,EACL,cAAc,EACd,UAAU,EACV,SAAS,CAAC,iBAAiB,CAC5B,CAAC;YACJ,CAAC;YACD,OAAO,IAAI,CAAC;QACd,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC;IACD;;OAEG;IACK,KAAK,CAAC,kBAAkB,CAC9B,SAAkB,EAClB,cAAmB,EACnB,YAAwB,EACxB,iBAAyB;QAEzB,IAAI,IAAI,GAAG,CAAC,CAAC;QACb,IAAI,SAAS,EAAE,CAAC;YACd,8FAA8F;YAC9F,iGAAiG;YACjG,+DAA+D;YAC/D,MAAM,CAAC,YAAY,EAAE,YAAY,CAAC,GAAG,MAAM,IAAA,6CAAwB,EACjE,YAAY,EACZ,cAAc,CAAC,CAAC,CAAC,CAClB,CAAC;YACF,MAAM,YAAY,GAAG,IAAI,oCAAe,CACtC,cAAc,CAAC,CAAC,CAAC,CAAC,YAAY,EAC9B,cAAc,CAAC,CAAC,CAAC,CAAC,YAAY,EAC9B,iBAAiB,EACjB,YAAY,EACZ,YAAY,CACb,CAAC;YAEF,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAC;YAC5C,IAAI,GAAG,CAAC,CAAC;QACX,CAAC;QACD,kCAAkC;QAClC,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,cAAc,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAClD,MAAM,CAAC,YAAY,EAAE,YAAY,CAAC,GAAG,MAAM,IAAA,6CAAwB,EACjE,YAAY,EACZ,cAAc,CAAC,CAAC,CAAC,CAClB,CAAC;YACF,MAAM,YAAY,GAAG,IAAI,oCAAe,CACtC,cAAc,CAAC,CAAC,CAAC,CAAC,YAAY,EAC9B,cAAc,CAAC,CAAC,CAAC,CAAC,YAAY,EAC9B,iBAAiB,EACjB,YAAY,EACZ,YAAY,CACb,CAAC;YACF,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAC,mBAAmB,CAC/B,SAA0B,EAC1B,cAAsC;QAEtC,MAAM,GAAG,GAAG,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC;QACrF,MAAM,GAAG,GAAG,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,YAAY,CAAC;QACrF,MAAM,UAAU,GAAG,IAAI,qBAAU,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;QACzD,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,sBAAsB,CAAC,oBAAoB,CAC3E,IAAI,CAAC,GAAG,EACR,UAAU,EACV,cAAc,EACd,KAAK,CACN,CAAC;QACF,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC9B,MAAM,IAAI,wBAAa,CAAC,8BAA8B,CAAC,CAAC;QAC1D,CAAC;QACD,MAAM,kBAAkB,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC;QAC7C,MAAM,uBAAuB,GAC3B,SAAS,CAAC,YAAY,KAAK,kBAAkB,CAAC,YAAY;YAC1D,SAAS,CAAC,YAAY,KAAK,kBAAkB,CAAC,YAAY;YAC1D,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;QAC5B,mEAAmE;QACnE,IAAI,uBAAuB,EAAE,CAAC;YAC5B,MAAM,IAAI,CAAC,kBAAkB,CAAC,IAAI,EAAE,cAAc,EAAE,UAAU,EAAE,SAAS,CAAC,iBAAiB,CAAC,CAAC;QAC/F,CAAC;QACD,OAAO,kBAAkB,CAAC,EAAE,CAAC;IAC/B,CAAC;IAEO,KAAK,CAAC,eAAe,CAC3B,SAA0B,EAC1B,cAAsC;QAEtC,MAAM,WAAW,GAAgB;YAC/B,cAAc,EAAE,EAAE;YAClB,oBAAoB,EAAE,IAAI;YAC1B,4BAA4B,EAAE,KAAK;SACpC,CAAC;QAEF,IAAI,OAAO,IAAI,CAAC,iBAAiB,CAAC,YAAY,KAAK,QAAQ,EAAE,CAAC;YAC5D,WAAW,CAAC,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC;QACjE,CAAC;QAED,IAAI,IAAI,CAAC,iBAAiB,CAAC,YAAY,EAAE,CAAC;YACxC,WAAW,CAAC,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC;QACjE,CAAC;QAED,IAAI,SAAS,CAAC,iBAAiB,EAAE,CAAC;YAChC,WAAW,CAAC,eAAe,GAAG;gBAC5B,IAAI,EAAE,oBAAS,CAAC,WAAW,CAAC,WAAW;gBACvC,SAAS,EAAE,SAAS,CAAC,iBAAiB;aACvC,CAAC;QACJ,CAAC;aAAM,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YAC7B,WAAW,CAAC,cAAc,CAAC,oBAAS,CAAC,WAAW,CAAC,WAAW,CAAC;gBAC3D,oBAAS,CAAC,uCAAuC,CAAC;QACtD,CAAC;QAED,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnB,WAAW,CAAC,cAAc,CAAC,oBAAS,CAAC,WAAW,CAAC,eAAe,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QACrF,CAAC;QAED,IACE,IAAI,CAAC,iBAAiB,CAAC,cAAc;YACrC,IAAI,CAAC,iBAAiB,CAAC,cAAc,KAAK,kCAAc,CAAC,qBAAqB,EAC9E,CAAC;YACD,WAAW,CAAC,4BAA4B,GAAG,IAAI,CAAC;YAChD,WAAW,CAAC,oBAAoB,GAAG,KAAK,CAAC;QAC3C,CAAC;QAED,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;QAC1E,IAAI,IAAI,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;YACxC,MAAM,IAAI,CAAC,SAAS,CAAC,4BAA4B,EAAE,CAAC;YACpD,WAAW,CAAC,YAAY,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;QACjD,CAAC;QACD,IAAI,CAAC;YACH,2HAA2H;YAC3H,MAAM,cAAc,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAClD,MAAM,QAAQ,GAAkC,MAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAI;gBACrF,IAAI,EAAE,IAAI,CAAC,YAAY;gBACvB,YAAY,EAAE,uBAAY,CAAC,IAAI;gBAC/B,UAAU,EAAE,IAAI,CAAC,UAAU;gBAC3B,QAAQ,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC;gBACtD,KAAK,EAAE,SAAS;gBAChB,OAAO,EAAE,WAAW;gBACpB,cAAc;gBACd,YAAY,EAAE,SAAS;gBACvB,mBAAmB,EAAE,OAAO;gBAC5B,QAAQ,EAAE,cAAc,CAAC,YAAY;gBACrC,MAAM,EAAE,cAAc,CAAC,YAAY;aACpC,CAAkB,CAAC;YAEpB,OAAO,IAAI,0DAA0B,CACnC,QAAQ,CAAC,MAAM,EACf,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAC5C,QAAQ,CAAC,IAAI,EACb,QAAQ,CAAC,OAAO,EAChB,IAAA,0CAAyB,GAAE,CAC5B,CAAC;QACJ,CAAC;QAAC,OAAO,GAAG,EAAE,CAAC;YACb,+FAA+F;YAC/F,IAAI,GAAG,CAAC,IAAI,KAAK,sBAAW,CAAC,IAAI,EAAE,CAAC;gBAClC,OAAO,IAAI,0DAA0B,CACnC,EAAE,EACF,CAAC,EACD,GAAG,CAAC,IAAI,EACR,GAAG,CAAC,OAAO,EACX,IAAA,0CAAyB,GAAE,EAC3B,GAAG,CAAC,SAAS,CACd,CAAC;YACJ,CAAC;YACD,wDAAwD;YACxD,MAAM,aAAa,GAAG,IAAI,wBAAa,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;YACrD,aAAa,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC;YAC9B,aAAa,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAAC;YACpC,MAAM,aAAa,CAAC;QACtB,CAAC;IACH,CAAC;IACO,mBAAmB;QACzB,wFAAwF;QACxF,mGAAmG;QACnG,MAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QACpC,IAAI,SAAS,EAAE,CAAC;YACd,OAAO,SAAS,CAAC;QACnB,CAAC;aAAM,CAAC;YACN,MAAM,IAAI,wBAAa,CAAC,sBAAsB,CAAC,CAAC;QAClD,CAAC;IACH,CAAC;CACF;AA5dD,sDA4dC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { ChangeFeedRange } from \"./ChangeFeedRange.js\";\nimport { ChangeFeedIteratorResponse } from \"./ChangeFeedIteratorResponse.js\";\nimport type { PartitionKeyRangeCache } from \"../../routing/index.js\";\nimport { QueryRange } from \"../../routing/index.js\";\nimport { FeedRangeQueue } from \"./FeedRangeQueue.js\";\nimport type { ClientContext } from \"../../ClientContext.js\";\nimport type { Container, Resource } from \"../../client/index.js\";\nimport { Constants, SubStatusCodes, StatusCodes, ResourceType } from \"../../common/index.js\";\nimport type { Response, FeedOptions } from \"../../request/index.js\";\nimport { ErrorResponse } from \"../../request/index.js\";\nimport { CompositeContinuationToken } from \"./CompositeContinuationToken.js\";\nimport type { ChangeFeedPullModelIterator } from \"./ChangeFeedPullModelIterator.js\";\nimport { decryptChangeFeedResponse, extractOverlappingRanges } from \"./changeFeedUtils.js\";\nimport type { InternalChangeFeedIteratorOptions } from \"./InternalChangeFeedOptions.js\";\nimport type { DiagnosticNodeInternal } from \"../../diagnostics/DiagnosticNodeInternal.js\";\nimport { getEmptyCosmosDiagnostics, withDiagnostics } from \"../../utils/diagnostics.js\";\nimport { ChangeFeedMode } from \"./ChangeFeedMode.js\";\n/**\n * @hidden\n * Provides iterator for change feed for entire container or an epk range.\n *\n * Use `Items.getChangeFeedIterator()` to get an instance of the iterator.\n */\nexport class ChangeFeedForEpkRange<T> implements ChangeFeedPullModelIterator<T> {\n  private continuationToken?: CompositeContinuationToken;\n  private queue: FeedRangeQueue<ChangeFeedRange>;\n  private startTime: string;\n  private isInstantiated: boolean;\n  private rId: string;\n  private startFromNow: boolean;\n  /**\n   * @internal\n   */\n  constructor(\n    private clientContext: ClientContext,\n    private container: Container,\n    private partitionKeyRangeCache: PartitionKeyRangeCache,\n    private resourceId: string,\n    private resourceLink: string,\n    private url: string,\n    private changeFeedOptions: InternalChangeFeedIteratorOptions,\n    private epkRange: QueryRange,\n  ) {\n    this.queue = new FeedRangeQueue<ChangeFeedRange>();\n    this.continuationToken = changeFeedOptions.continuationToken\n      ? JSON.parse(changeFeedOptions.continuationToken)\n      : undefined;\n    this.isInstantiated = false;\n    // startTime is used to store and specify time from which change feed should start reading new changes. StartFromNow flag is used to indicate fetching changes from now.\n    if (changeFeedOptions.startFromNow) {\n      this.startFromNow = true;\n    } else if (changeFeedOptions.startTime) {\n      this.startTime = changeFeedOptions.startTime.toUTCString();\n    }\n  }\n\n  private async setIteratorRid(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    const { resource } = await this.container.readInternal(diagnosticNode);\n    this.rId = resource._rid;\n  }\n\n  private continuationTokenRidMatchContainerRid(): boolean {\n    if (this.continuationToken.rid !== this.rId) {\n      return false;\n    }\n    return true;\n  }\n\n  private async fillChangeFeedQueue(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    if (this.continuationToken) {\n      // fill the queue with feed ranges in continuation token.\n      await this.fetchContinuationTokenFeedRanges(diagnosticNode);\n    } else {\n      // fill the queue with feed ranges overlapping the given epk range.\n      await this.fetchOverLappingFeedRanges(diagnosticNode);\n    }\n    this.isInstantiated = true;\n  }\n\n  /**\n   * Fill the queue with the feed ranges overlapping with the given epk range.\n   */\n  private async fetchOverLappingFeedRanges(diagnosticNode: DiagnosticNodeInternal): Promise<void> {\n    try {\n      const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n        this.url,\n        this.epkRange,\n        diagnosticNode,\n      );\n      for (const overLappingRange of overLappingRanges) {\n        const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n          this.epkRange,\n          overLappingRange,\n        );\n        const feedRange: ChangeFeedRange = new ChangeFeedRange(\n          overLappingRange.minInclusive,\n          overLappingRange.maxExclusive,\n          \"\",\n          epkMinHeader,\n          epkMaxHeader,\n        );\n        this.queue.enqueue(feedRange);\n      }\n    } catch (err) {\n      throw new ErrorResponse(err.message);\n    }\n  }\n  /**\n   * Fill the queue with feed ranges from continuation token\n   */\n  private async fetchContinuationTokenFeedRanges(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<void> {\n    const contToken = this.continuationToken;\n    if (!this.continuationTokenRidMatchContainerRid()) {\n      throw new ErrorResponse(\"The continuation token is not for the current container definition\");\n    } else {\n      for (const cToken of contToken.Continuation) {\n        const queryRange = new QueryRange(cToken.minInclusive, cToken.maxExclusive, true, false);\n        try {\n          const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n            this.url,\n            queryRange,\n            diagnosticNode,\n          );\n          for (const overLappingRange of overLappingRanges) {\n            // check if the epk range present in continuation token entirely covers the overlapping range.\n            // If yes, minInclusive and maxExclusive of the overlapping range will be set.\n            // If no, i.e. there is only partial overlap, epkMinHeader and epkMaxHeader are set as min and max of overlap.\n            // This will be used when we make a call to fetch change feed.\n            const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n              queryRange,\n              overLappingRange,\n            );\n            const feedRange: ChangeFeedRange = new ChangeFeedRange(\n              overLappingRange.minInclusive,\n              overLappingRange.maxExclusive,\n              cToken.continuationToken,\n              epkMinHeader,\n              epkMaxHeader,\n            );\n            this.queue.enqueue(feedRange);\n          }\n        } catch (err) {\n          throw new ErrorResponse(err.message);\n        }\n      }\n    }\n  }\n\n  /**\n   * Change feed is an infinite feed. hasMoreResults is always true.\n   */\n  get hasMoreResults(): boolean {\n    return true;\n  }\n\n  /**\n   * Gets an async iterator which will yield change feed results.\n   */\n  public async *getAsyncIterator(): AsyncIterable<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    do {\n      const result = await this.readNext();\n      yield result;\n    } while (this.hasMoreResults);\n  }\n\n  /**\n   * Gets an async iterator which will yield pages of results from Azure Cosmos DB.\n   *\n   * Keeps iterating over the feedranges and checks if any feed range has new result. Keeps note of the last feed range which returned non 304 result.\n   *\n   * When same feed range is reached and no new changes are found, a 304 (not Modified) is returned to the end user. Then starts process all over again.\n   */\n  public async readNext(): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    return withDiagnostics(async (diagnosticNode: DiagnosticNodeInternal) => {\n      // validate if the internal queue is filled up with feed ranges.\n      if (!this.isInstantiated) {\n        await this.setIteratorRid(diagnosticNode);\n        await this.fillChangeFeedQueue(diagnosticNode);\n      }\n\n      // stores the last feedRange for which statusCode is not 304 i.e. there were new changes in that feed range.\n      let firstNotModifiedFeedRange: ChangeFeedRange = undefined;\n      let result: ChangeFeedIteratorResponse<Array<T & Resource>>;\n      do {\n        const [processedFeedRange, response] = await this.fetchNext(diagnosticNode);\n        result = response;\n\n        if (result !== undefined) {\n          {\n            if (firstNotModifiedFeedRange === undefined) {\n              firstNotModifiedFeedRange = processedFeedRange;\n            }\n            // move current feed range to end of queue to fetch result of next feed range.\n            // This is done to fetch changes in breadth first manner and avoid starvation.\n            this.queue.moveFirstElementToTheEnd();\n            // check if there are new results for the given feed range.\n            if (result.statusCode === StatusCodes.Ok) {\n              result.headers[Constants.HttpHeaders.ContinuationToken] =\n                this.generateContinuationToken();\n\n              if (this.clientContext.enableEncryption) {\n                await decryptChangeFeedResponse(\n                  result,\n                  diagnosticNode,\n                  this.changeFeedOptions.changeFeedMode,\n                  this.container.encryptionProcessor,\n                );\n              }\n              return result;\n            }\n          }\n        }\n      } while (!this.checkedAllFeedRanges(firstNotModifiedFeedRange));\n      // set the continuation token after processing.\n      result.headers[Constants.HttpHeaders.ContinuationToken] = this.generateContinuationToken();\n      return result;\n    }, this.clientContext);\n  }\n\n  private generateContinuationToken = (): string => {\n    return JSON.stringify(new CompositeContinuationToken(this.rId, this.queue.returnSnapshot()));\n  };\n\n  /**\n   * Read feed and retrieves the next page of results in Azure Cosmos DB.\n   */\n  private async fetchNext(\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<[ChangeFeedRange | undefined, ChangeFeedIteratorResponse<Array<T & Resource>>]> {\n    const feedRange = this.queue.peek();\n    if (feedRange) {\n      // fetch results for feed range at the beginning of the queue.\n      const result = await this.getFeedResponse(feedRange, diagnosticNode);\n\n      // check if results need to be fetched again depending on status code returned.\n      // Eg. in case of paritionSplit, results need to be fetched for the child partitions.\n      const shouldRetry: boolean = await this.shouldRetryOnFailure(\n        feedRange,\n        result,\n        diagnosticNode,\n      );\n\n      if (shouldRetry) {\n        this.queue.dequeue();\n        return this.fetchNext(diagnosticNode);\n      } else {\n        // update the continuation value for the current feed range.\n        const continuationValueForFeedRange = result.headers[Constants.HttpHeaders.ETag];\n        const newFeedRange = this.queue.peek();\n        newFeedRange.continuationToken = continuationValueForFeedRange;\n        return [newFeedRange, result];\n      }\n    } else {\n      return [undefined, undefined];\n    }\n  }\n\n  private checkedAllFeedRanges(firstNotModifiedFeedRange: ChangeFeedRange | undefined): boolean {\n    if (firstNotModifiedFeedRange === undefined) {\n      return false;\n    }\n    const feedRangeQueueFirstElement = this.queue.peek();\n    return (\n      firstNotModifiedFeedRange.minInclusive === feedRangeQueueFirstElement?.minInclusive &&\n      firstNotModifiedFeedRange.maxExclusive === feedRangeQueueFirstElement?.maxExclusive &&\n      firstNotModifiedFeedRange.epkMinHeader === feedRangeQueueFirstElement?.epkMinHeader &&\n      firstNotModifiedFeedRange.epkMaxHeader === feedRangeQueueFirstElement?.epkMaxHeader\n    );\n  }\n\n  /**\n   * Checks whether the current EpkRange is split into multiple ranges or not.\n   *\n   * If yes, it force refreshes the partitionKeyRange cache and enqueue children epk ranges.\n   */\n  private async shouldRetryOnFailure(\n    feedRange: ChangeFeedRange,\n    response: ChangeFeedIteratorResponse<Array<T & Resource>>,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<boolean> {\n    if (response.statusCode === StatusCodes.Ok || response.statusCode === StatusCodes.NotModified) {\n      return false;\n    }\n\n    const partitionSplit =\n      response.statusCode === StatusCodes.Gone &&\n      (response.subStatusCode === SubStatusCodes.PartitionKeyRangeGone ||\n        response.subStatusCode === SubStatusCodes.CompletingSplit);\n\n    if (partitionSplit) {\n      const queryRange = new QueryRange(\n        feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive,\n        feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive,\n        true,\n        false,\n      );\n      const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n        this.url,\n        queryRange,\n        diagnosticNode,\n        true,\n      );\n      if (resolvedRanges.length < 1) {\n        throw new ErrorResponse(\"Partition split/merge detected but no overlapping ranges found.\");\n      }\n      // This covers both cases of merge and split.\n      // resolvedRanges.length > 1 in case of split.\n      // resolvedRanges.length === 1 in case of merge. EpkRange headers will be added in this case.\n      if (resolvedRanges.length >= 1) {\n        await this.handleSplitOrMerge(\n          false,\n          resolvedRanges,\n          queryRange,\n          feedRange.continuationToken,\n        );\n      }\n      return true;\n    }\n    return false;\n  }\n  /*\n   * Enqueues all the children feed ranges for the given feed range.\n   */\n  private async handleSplitOrMerge(\n    shiftLeft: boolean,\n    resolvedRanges: any,\n    oldFeedRange: QueryRange,\n    continuationToken: string,\n  ): Promise<void> {\n    let flag = 0;\n    if (shiftLeft) {\n      // This section is only applicable when handleSplitOrMerge is called by getPartitionRangeId().\n      // used only when existing partition key range cache is used to check for any overlapping ranges.\n      // Modifies the first element with the first overlapping range.\n      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n        oldFeedRange,\n        resolvedRanges[0],\n      );\n      const newFeedRange = new ChangeFeedRange(\n        resolvedRanges[0].minInclusive,\n        resolvedRanges[0].maxExclusive,\n        continuationToken,\n        epkMinHeader,\n        epkMaxHeader,\n      );\n\n      this.queue.modifyFirstElement(newFeedRange);\n      flag = 1;\n    }\n    // Enqueue the overlapping ranges.\n    for (let i = flag; i < resolvedRanges.length; i++) {\n      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(\n        oldFeedRange,\n        resolvedRanges[i],\n      );\n      const newFeedRange = new ChangeFeedRange(\n        resolvedRanges[i].minInclusive,\n        resolvedRanges[i].maxExclusive,\n        continuationToken,\n        epkMinHeader,\n        epkMaxHeader,\n      );\n      this.queue.enqueue(newFeedRange);\n    }\n  }\n\n  /**\n   * Fetch the partitionKeyRangeId for the given feed range.\n   *\n   * This partitionKeyRangeId is passed to queryFeed to fetch the results.\n   */\n  private async getPartitionRangeId(\n    feedRange: ChangeFeedRange,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<string> {\n    const min = feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive;\n    const max = feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive;\n    const queryRange = new QueryRange(min, max, true, false);\n    const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(\n      this.url,\n      queryRange,\n      diagnosticNode,\n      false,\n    );\n    if (resolvedRanges.length < 1) {\n      throw new ErrorResponse(\"No overlapping ranges found.\");\n    }\n    const firstResolvedRange = resolvedRanges[0];\n    const isPartitionRangeChanged =\n      feedRange.minInclusive !== firstResolvedRange.minInclusive ||\n      feedRange.maxExclusive !== firstResolvedRange.maxExclusive ||\n      resolvedRanges.length > 1;\n    // If the partition range is changed, we need to handle split/merge\n    if (isPartitionRangeChanged) {\n      await this.handleSplitOrMerge(true, resolvedRanges, queryRange, feedRange.continuationToken);\n    }\n    return firstResolvedRange.id;\n  }\n\n  private async getFeedResponse(\n    feedRange: ChangeFeedRange,\n    diagnosticNode: DiagnosticNodeInternal,\n  ): Promise<ChangeFeedIteratorResponse<Array<T & Resource>>> {\n    const feedOptions: FeedOptions = {\n      initialHeaders: {},\n      useLatestVersionFeed: true,\n      useAllVersionsAndDeletesFeed: false,\n    };\n\n    if (typeof this.changeFeedOptions.maxItemCount === \"number\") {\n      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;\n    }\n\n    if (this.changeFeedOptions.sessionToken) {\n      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;\n    }\n\n    if (feedRange.continuationToken) {\n      feedOptions.accessCondition = {\n        type: Constants.HttpHeaders.IfNoneMatch,\n        condition: feedRange.continuationToken,\n      };\n    } else if (this.startFromNow) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfNoneMatch] =\n        Constants.ChangeFeedIfNoneMatchStartFromNowHeader;\n    }\n\n    if (this.startTime) {\n      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.startTime;\n    }\n\n    if (\n      this.changeFeedOptions.changeFeedMode &&\n      this.changeFeedOptions.changeFeedMode === ChangeFeedMode.AllVersionsAndDeletes\n    ) {\n      feedOptions.useAllVersionsAndDeletesFeed = true;\n      feedOptions.useLatestVersionFeed = false;\n    }\n\n    const rangeId = await this.getPartitionRangeId(feedRange, diagnosticNode);\n    if (this.clientContext.enableEncryption) {\n      await this.container.checkAndInitializeEncryption();\n      feedOptions.containerRid = this.container._rid;\n    }\n    try {\n      // startEpk and endEpk are only valid in case we want to fetch result for a part of partition and not the entire partition.\n      const finalFeedRange = this.fetchFinalFeedRange();\n      const response: Response<Array<T & Resource>> = await (this.clientContext.queryFeed<T>({\n        path: this.resourceLink,\n        resourceType: ResourceType.item,\n        resourceId: this.resourceId,\n        resultFn: (result) => (result ? result.Documents : []),\n        query: undefined,\n        options: feedOptions,\n        diagnosticNode,\n        partitionKey: undefined,\n        partitionKeyRangeId: rangeId,\n        startEpk: finalFeedRange.epkMinHeader,\n        endEpk: finalFeedRange.epkMaxHeader,\n      }) as Promise<any>);\n\n      return new ChangeFeedIteratorResponse(\n        response.result,\n        response.result ? response.result.length : 0,\n        response.code,\n        response.headers,\n        getEmptyCosmosDiagnostics(),\n      );\n    } catch (err) {\n      // If partition split/merge is encountered, handle it gracefully and continue fetching results.\n      if (err.code === StatusCodes.Gone) {\n        return new ChangeFeedIteratorResponse(\n          [],\n          0,\n          err.code,\n          err.headers,\n          getEmptyCosmosDiagnostics(),\n          err.substatus,\n        );\n      }\n      // If any other errors are encountered, throw the error.\n      const errorResponse = new ErrorResponse(err.message);\n      errorResponse.code = err.code;\n      errorResponse.headers = err.headers;\n      throw errorResponse;\n    }\n  }\n  private fetchFinalFeedRange(): ChangeFeedRange {\n    // this is used to fetch the final feed range before making a call to fetch the results.\n    // In case of merge, the final updated feed range is present in the queue and needs to be returned.\n    const feedRange = this.queue.peek();\n    if (feedRange) {\n      return feedRange;\n    } else {\n      throw new ErrorResponse(\"No feed range found.\");\n    }\n  }\n}\n"]}