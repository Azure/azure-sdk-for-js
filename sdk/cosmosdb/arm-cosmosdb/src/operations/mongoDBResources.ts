/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { MongoDBResources } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { CosmosDBManagementClient } from "../cosmosDBManagementClient";
import { PollerLike, PollOperationState, LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
import {
  MongoDBDatabaseGetResults,
  MongoDBResourcesListMongoDBDatabasesOptionalParams,
  MongoDBResourcesListMongoDBDatabasesResponse,
  MongoDBCollectionGetResults,
  MongoDBResourcesListMongoDBCollectionsOptionalParams,
  MongoDBResourcesListMongoDBCollectionsResponse,
  MongoRoleDefinitionGetResults,
  MongoDBResourcesListMongoRoleDefinitionsOptionalParams,
  MongoDBResourcesListMongoRoleDefinitionsResponse,
  MongoUserDefinitionGetResults,
  MongoDBResourcesListMongoUserDefinitionsOptionalParams,
  MongoDBResourcesListMongoUserDefinitionsResponse,
  MongoDBResourcesGetMongoDBDatabaseOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseResponse,
  MongoDBDatabaseCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams,
  MongoDBResourcesCreateUpdateMongoDBDatabaseResponse,
  MongoDBResourcesDeleteMongoDBDatabaseOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseThroughputOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseThroughputResponse,
  ThroughputSettingsUpdateParameters,
  MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams,
  MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse,
  MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams,
  MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse,
  MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams,
  MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse,
  RetrieveThroughputParameters,
  MongoDBResourcesMongoDBDatabaseRetrieveThroughputDistributionOptionalParams,
  MongoDBResourcesMongoDBDatabaseRetrieveThroughputDistributionResponse,
  RedistributeThroughputParameters,
  MongoDBResourcesMongoDBDatabaseRedistributeThroughputOptionalParams,
  MongoDBResourcesMongoDBDatabaseRedistributeThroughputResponse,
  MongoDBResourcesMongoDBContainerRetrieveThroughputDistributionOptionalParams,
  MongoDBResourcesMongoDBContainerRetrieveThroughputDistributionResponse,
  MongoDBResourcesMongoDBContainerRedistributeThroughputOptionalParams,
  MongoDBResourcesMongoDBContainerRedistributeThroughputResponse,
  MongoDBResourcesGetMongoDBCollectionOptionalParams,
  MongoDBResourcesGetMongoDBCollectionResponse,
  MongoDBCollectionCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams,
  MongoDBResourcesCreateUpdateMongoDBCollectionResponse,
  MongoDBResourcesDeleteMongoDBCollectionOptionalParams,
  MergeParameters,
  MongoDBResourcesListMongoDBCollectionPartitionMergeOptionalParams,
  MongoDBResourcesListMongoDBCollectionPartitionMergeResponse,
  MongoDBResourcesGetMongoDBCollectionThroughputOptionalParams,
  MongoDBResourcesGetMongoDBCollectionThroughputResponse,
  MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams,
  MongoDBResourcesUpdateMongoDBCollectionThroughputResponse,
  MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams,
  MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse,
  MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams,
  MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse,
  MongoDBResourcesGetMongoRoleDefinitionOptionalParams,
  MongoDBResourcesGetMongoRoleDefinitionResponse,
  MongoRoleDefinitionCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoRoleDefinitionOptionalParams,
  MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse,
  MongoDBResourcesDeleteMongoRoleDefinitionOptionalParams,
  MongoDBResourcesGetMongoUserDefinitionOptionalParams,
  MongoDBResourcesGetMongoUserDefinitionResponse,
  MongoUserDefinitionCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoUserDefinitionOptionalParams,
  MongoDBResourcesCreateUpdateMongoUserDefinitionResponse,
  MongoDBResourcesDeleteMongoUserDefinitionOptionalParams,
  ContinuousBackupRestoreLocation,
  MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams,
  MongoDBResourcesRetrieveContinuousBackupInformationResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing MongoDBResources operations. */
export class MongoDBResourcesImpl implements MongoDBResources {
  private readonly client: CosmosDBManagementClient;

  /**
   * Initialize a new instance of the class MongoDBResources class.
   * @param client Reference to the service client
   */
  constructor(client: CosmosDBManagementClient) {
    this.client = client;
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listMongoDBDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams
  ): PagedAsyncIterableIterator<MongoDBDatabaseGetResults> {
    const iter = this.listMongoDBDatabasesPagingAll(
      resourceGroupName,
      accountName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoDBDatabasesPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings
        );
      }
    };
  }

  private async *listMongoDBDatabasesPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
    _settings?: PageSettings
  ): AsyncIterableIterator<MongoDBDatabaseGetResults[]> {
    let result: MongoDBResourcesListMongoDBDatabasesResponse;
    result = await this._listMongoDBDatabases(
      resourceGroupName,
      accountName,
      options
    );
    yield result.value || [];
  }

  private async *listMongoDBDatabasesPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams
  ): AsyncIterableIterator<MongoDBDatabaseGetResults> {
    for await (const page of this.listMongoDBDatabasesPagingPage(
      resourceGroupName,
      accountName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  public listMongoDBCollections(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams
  ): PagedAsyncIterableIterator<MongoDBCollectionGetResults> {
    const iter = this.listMongoDBCollectionsPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoDBCollectionsPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          options,
          settings
        );
      }
    };
  }

  private async *listMongoDBCollectionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
    _settings?: PageSettings
  ): AsyncIterableIterator<MongoDBCollectionGetResults[]> {
    let result: MongoDBResourcesListMongoDBCollectionsResponse;
    result = await this._listMongoDBCollections(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    yield result.value || [];
  }

  private async *listMongoDBCollectionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams
  ): AsyncIterableIterator<MongoDBCollectionGetResults> {
    for await (const page of this.listMongoDBCollectionsPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listMongoRoleDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoRoleDefinitionsOptionalParams
  ): PagedAsyncIterableIterator<MongoRoleDefinitionGetResults> {
    const iter = this.listMongoRoleDefinitionsPagingAll(
      resourceGroupName,
      accountName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoRoleDefinitionsPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings
        );
      }
    };
  }

  private async *listMongoRoleDefinitionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoRoleDefinitionsOptionalParams,
    _settings?: PageSettings
  ): AsyncIterableIterator<MongoRoleDefinitionGetResults[]> {
    let result: MongoDBResourcesListMongoRoleDefinitionsResponse;
    result = await this._listMongoRoleDefinitions(
      resourceGroupName,
      accountName,
      options
    );
    yield result.value || [];
  }

  private async *listMongoRoleDefinitionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoRoleDefinitionsOptionalParams
  ): AsyncIterableIterator<MongoRoleDefinitionGetResults> {
    for await (const page of this.listMongoRoleDefinitionsPagingPage(
      resourceGroupName,
      accountName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves the list of all Azure Cosmos DB Mongo User Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listMongoUserDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoUserDefinitionsOptionalParams
  ): PagedAsyncIterableIterator<MongoUserDefinitionGetResults> {
    const iter = this.listMongoUserDefinitionsPagingAll(
      resourceGroupName,
      accountName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoUserDefinitionsPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings
        );
      }
    };
  }

  private async *listMongoUserDefinitionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoUserDefinitionsOptionalParams,
    _settings?: PageSettings
  ): AsyncIterableIterator<MongoUserDefinitionGetResults[]> {
    let result: MongoDBResourcesListMongoUserDefinitionsResponse;
    result = await this._listMongoUserDefinitions(
      resourceGroupName,
      accountName,
      options
    );
    yield result.value || [];
  }

  private async *listMongoUserDefinitionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoUserDefinitionsOptionalParams
  ): AsyncIterableIterator<MongoUserDefinitionGetResults> {
    for await (const page of this.listMongoUserDefinitionsPagingPage(
      resourceGroupName,
      accountName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listMongoDBDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams
  ): Promise<MongoDBResourcesListMongoDBDatabasesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listMongoDBDatabasesOperationSpec
    );
  }

  /**
   * Gets the MongoDB databases under an existing Azure Cosmos DB database account with the provided
   * name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesGetMongoDBDatabaseOptionalParams
  ): Promise<MongoDBResourcesGetMongoDBDatabaseResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getMongoDBDatabaseOperationSpec
    );
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
   *                                              database.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateMongoDBDatabaseParameters: MongoDBDatabaseCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse>,
      MongoDBResourcesCreateUpdateMongoDBDatabaseResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        createUpdateMongoDBDatabaseParameters,
        options
      },
      createUpdateMongoDBDatabaseOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
   *                                              database.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateMongoDBDatabaseParameters: MongoDBDatabaseCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams
  ): Promise<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse> {
    const poller = await this.beginCreateUpdateMongoDBDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      createUpdateMongoDBDatabaseParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesDeleteMongoDBDatabaseOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      deleteMongoDBDatabaseOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesDeleteMongoDBDatabaseOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteMongoDBDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the MongoDB database under an existing Azure Cosmos DB database account
   * with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getMongoDBDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesGetMongoDBDatabaseThroughputOptionalParams
  ): Promise<MongoDBResourcesGetMongoDBDatabaseThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getMongoDBDatabaseThroughputOperationSpec
    );
  }

  /**
   * Update RUs per second of the an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB database.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse
      >,
      MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        updateThroughputParameters,
        options
      },
      updateMongoDBDatabaseThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update RUs per second of the an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB database.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBDatabaseThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams
  ): Promise<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse> {
    const poller = await this.beginUpdateMongoDBDatabaseThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      updateThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse
      >,
      MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      migrateMongoDBDatabaseToAutoscaleOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams
  ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse> {
    const poller = await this.beginMigrateMongoDBDatabaseToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse
      >,
      MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      migrateMongoDBDatabaseToManualThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams
  ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse> {
    const poller = await this.beginMigrateMongoDBDatabaseToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieve throughput distribution for an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param retrieveThroughputParameters The parameters to provide for retrieving throughput distribution
   *                                     for the current MongoDB database.
   * @param options The options parameters.
   */
  async beginMongoDBDatabaseRetrieveThroughputDistribution(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    retrieveThroughputParameters: RetrieveThroughputParameters,
    options?: MongoDBResourcesMongoDBDatabaseRetrieveThroughputDistributionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMongoDBDatabaseRetrieveThroughputDistributionResponse
      >,
      MongoDBResourcesMongoDBDatabaseRetrieveThroughputDistributionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMongoDBDatabaseRetrieveThroughputDistributionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        retrieveThroughputParameters,
        options
      },
      mongoDBDatabaseRetrieveThroughputDistributionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieve throughput distribution for an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param retrieveThroughputParameters The parameters to provide for retrieving throughput distribution
   *                                     for the current MongoDB database.
   * @param options The options parameters.
   */
  async beginMongoDBDatabaseRetrieveThroughputDistributionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    retrieveThroughputParameters: RetrieveThroughputParameters,
    options?: MongoDBResourcesMongoDBDatabaseRetrieveThroughputDistributionOptionalParams
  ): Promise<
    MongoDBResourcesMongoDBDatabaseRetrieveThroughputDistributionResponse
  > {
    const poller = await this.beginMongoDBDatabaseRetrieveThroughputDistribution(
      resourceGroupName,
      accountName,
      databaseName,
      retrieveThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Redistribute throughput for an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param redistributeThroughputParameters The parameters to provide for redistributing throughput for
   *                                         the current MongoDB database.
   * @param options The options parameters.
   */
  async beginMongoDBDatabaseRedistributeThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    redistributeThroughputParameters: RedistributeThroughputParameters,
    options?: MongoDBResourcesMongoDBDatabaseRedistributeThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMongoDBDatabaseRedistributeThroughputResponse
      >,
      MongoDBResourcesMongoDBDatabaseRedistributeThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMongoDBDatabaseRedistributeThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        redistributeThroughputParameters,
        options
      },
      mongoDBDatabaseRedistributeThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Redistribute throughput for an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param redistributeThroughputParameters The parameters to provide for redistributing throughput for
   *                                         the current MongoDB database.
   * @param options The options parameters.
   */
  async beginMongoDBDatabaseRedistributeThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    redistributeThroughputParameters: RedistributeThroughputParameters,
    options?: MongoDBResourcesMongoDBDatabaseRedistributeThroughputOptionalParams
  ): Promise<MongoDBResourcesMongoDBDatabaseRedistributeThroughputResponse> {
    const poller = await this.beginMongoDBDatabaseRedistributeThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      redistributeThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieve throughput distribution for an Azure Cosmos DB MongoDB container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param retrieveThroughputParameters The parameters to provide for retrieving throughput distribution
   *                                     for the current MongoDB container.
   * @param options The options parameters.
   */
  async beginMongoDBContainerRetrieveThroughputDistribution(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    retrieveThroughputParameters: RetrieveThroughputParameters,
    options?: MongoDBResourcesMongoDBContainerRetrieveThroughputDistributionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMongoDBContainerRetrieveThroughputDistributionResponse
      >,
      MongoDBResourcesMongoDBContainerRetrieveThroughputDistributionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMongoDBContainerRetrieveThroughputDistributionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        retrieveThroughputParameters,
        options
      },
      mongoDBContainerRetrieveThroughputDistributionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieve throughput distribution for an Azure Cosmos DB MongoDB container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param retrieveThroughputParameters The parameters to provide for retrieving throughput distribution
   *                                     for the current MongoDB container.
   * @param options The options parameters.
   */
  async beginMongoDBContainerRetrieveThroughputDistributionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    retrieveThroughputParameters: RetrieveThroughputParameters,
    options?: MongoDBResourcesMongoDBContainerRetrieveThroughputDistributionOptionalParams
  ): Promise<
    MongoDBResourcesMongoDBContainerRetrieveThroughputDistributionResponse
  > {
    const poller = await this.beginMongoDBContainerRetrieveThroughputDistribution(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      retrieveThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Redistribute throughput for an Azure Cosmos DB MongoDB container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param redistributeThroughputParameters The parameters to provide for redistributing throughput for
   *                                         the current MongoDB container.
   * @param options The options parameters.
   */
  async beginMongoDBContainerRedistributeThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    redistributeThroughputParameters: RedistributeThroughputParameters,
    options?: MongoDBResourcesMongoDBContainerRedistributeThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMongoDBContainerRedistributeThroughputResponse
      >,
      MongoDBResourcesMongoDBContainerRedistributeThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMongoDBContainerRedistributeThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        redistributeThroughputParameters,
        options
      },
      mongoDBContainerRedistributeThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Redistribute throughput for an Azure Cosmos DB MongoDB container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param redistributeThroughputParameters The parameters to provide for redistributing throughput for
   *                                         the current MongoDB container.
   * @param options The options parameters.
   */
  async beginMongoDBContainerRedistributeThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    redistributeThroughputParameters: RedistributeThroughputParameters,
    options?: MongoDBResourcesMongoDBContainerRedistributeThroughputOptionalParams
  ): Promise<MongoDBResourcesMongoDBContainerRedistributeThroughputResponse> {
    const poller = await this.beginMongoDBContainerRedistributeThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      redistributeThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  private _listMongoDBCollections(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams
  ): Promise<MongoDBResourcesListMongoDBCollectionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      listMongoDBCollectionsOperationSpec
    );
  }

  /**
   * Gets the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  getMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesGetMongoDBCollectionOptionalParams
  ): Promise<MongoDBResourcesGetMongoDBCollectionResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, collectionName, options },
      getMongoDBCollectionOperationSpec
    );
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
   *                                                Collection.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    createUpdateMongoDBCollectionParameters: MongoDBCollectionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<MongoDBResourcesCreateUpdateMongoDBCollectionResponse>,
      MongoDBResourcesCreateUpdateMongoDBCollectionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesCreateUpdateMongoDBCollectionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        createUpdateMongoDBCollectionParameters,
        options
      },
      createUpdateMongoDBCollectionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
   *                                                Collection.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBCollectionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    createUpdateMongoDBCollectionParameters: MongoDBCollectionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams
  ): Promise<MongoDBResourcesCreateUpdateMongoDBCollectionResponse> {
    const poller = await this.beginCreateUpdateMongoDBCollection(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      createUpdateMongoDBCollectionParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesDeleteMongoDBCollectionOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, collectionName, options },
      deleteMongoDBCollectionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBCollectionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesDeleteMongoDBCollectionOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteMongoDBCollection(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Merges the partitions of a MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param mergeParameters The parameters for the merge operation.
   * @param options The options parameters.
   */
  async beginListMongoDBCollectionPartitionMerge(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    mergeParameters: MergeParameters,
    options?: MongoDBResourcesListMongoDBCollectionPartitionMergeOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesListMongoDBCollectionPartitionMergeResponse
      >,
      MongoDBResourcesListMongoDBCollectionPartitionMergeResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesListMongoDBCollectionPartitionMergeResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        mergeParameters,
        options
      },
      listMongoDBCollectionPartitionMergeOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Merges the partitions of a MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param mergeParameters The parameters for the merge operation.
   * @param options The options parameters.
   */
  async beginListMongoDBCollectionPartitionMergeAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    mergeParameters: MergeParameters,
    options?: MongoDBResourcesListMongoDBCollectionPartitionMergeOptionalParams
  ): Promise<MongoDBResourcesListMongoDBCollectionPartitionMergeResponse> {
    const poller = await this.beginListMongoDBCollectionPartitionMerge(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      mergeParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the MongoDB collection under an existing Azure Cosmos DB database account
   * with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  getMongoDBCollectionThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesGetMongoDBCollectionThroughputOptionalParams
  ): Promise<MongoDBResourcesGetMongoDBCollectionThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, collectionName, options },
      getMongoDBCollectionThroughputOperationSpec
    );
  }

  /**
   * Update the RUs per second of an Azure Cosmos DB MongoDB collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB collection.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBCollectionThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesUpdateMongoDBCollectionThroughputResponse
      >,
      MongoDBResourcesUpdateMongoDBCollectionThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        updateThroughputParameters,
        options
      },
      updateMongoDBCollectionThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update the RUs per second of an Azure Cosmos DB MongoDB collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB collection.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBCollectionThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams
  ): Promise<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse> {
    const poller = await this.beginUpdateMongoDBCollectionThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      updateThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse
      >,
      MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, collectionName, options },
      migrateMongoDBCollectionToAutoscaleOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams
  ): Promise<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse> {
    const poller = await this.beginMigrateMongoDBCollectionToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse
      >,
      MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, collectionName, options },
      migrateMongoDBCollectionToManualThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams
  ): Promise<
    MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse
  > {
    const poller = await this.beginMigrateMongoDBCollectionToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB Mongo Role Definition with the given Id.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  getMongoRoleDefinition(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesGetMongoRoleDefinitionOptionalParams
  ): Promise<MongoDBResourcesGetMongoRoleDefinitionResponse> {
    return this.client.sendOperationRequest(
      { mongoRoleDefinitionId, resourceGroupName, accountName, options },
      getMongoRoleDefinitionOperationSpec
    );
  }

  /**
   * Creates or updates an Azure Cosmos DB Mongo Role Definition.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateMongoRoleDefinitionParameters The properties required to create or update a Role
   *                                                  Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoRoleDefinition(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateMongoRoleDefinitionParameters: MongoRoleDefinitionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoRoleDefinitionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse
      >,
      MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        mongoRoleDefinitionId,
        resourceGroupName,
        accountName,
        createUpdateMongoRoleDefinitionParameters,
        options
      },
      createUpdateMongoRoleDefinitionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates or updates an Azure Cosmos DB Mongo Role Definition.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateMongoRoleDefinitionParameters The properties required to create or update a Role
   *                                                  Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoRoleDefinitionAndWait(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateMongoRoleDefinitionParameters: MongoRoleDefinitionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoRoleDefinitionOptionalParams
  ): Promise<MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse> {
    const poller = await this.beginCreateUpdateMongoRoleDefinition(
      mongoRoleDefinitionId,
      resourceGroupName,
      accountName,
      createUpdateMongoRoleDefinitionParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB Mongo Role Definition.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteMongoRoleDefinition(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesDeleteMongoRoleDefinitionOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { mongoRoleDefinitionId, resourceGroupName, accountName, options },
      deleteMongoRoleDefinitionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB Mongo Role Definition.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteMongoRoleDefinitionAndWait(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesDeleteMongoRoleDefinitionOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteMongoRoleDefinition(
      mongoRoleDefinitionId,
      resourceGroupName,
      accountName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listMongoRoleDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoRoleDefinitionsOptionalParams
  ): Promise<MongoDBResourcesListMongoRoleDefinitionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listMongoRoleDefinitionsOperationSpec
    );
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB Mongo User Definition with the given Id.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  getMongoUserDefinition(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesGetMongoUserDefinitionOptionalParams
  ): Promise<MongoDBResourcesGetMongoUserDefinitionResponse> {
    return this.client.sendOperationRequest(
      { mongoUserDefinitionId, resourceGroupName, accountName, options },
      getMongoUserDefinitionOperationSpec
    );
  }

  /**
   * Creates or updates an Azure Cosmos DB Mongo User Definition.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateMongoUserDefinitionParameters The properties required to create or update a User
   *                                                  Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoUserDefinition(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateMongoUserDefinitionParameters: MongoUserDefinitionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoUserDefinitionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesCreateUpdateMongoUserDefinitionResponse
      >,
      MongoDBResourcesCreateUpdateMongoUserDefinitionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesCreateUpdateMongoUserDefinitionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        mongoUserDefinitionId,
        resourceGroupName,
        accountName,
        createUpdateMongoUserDefinitionParameters,
        options
      },
      createUpdateMongoUserDefinitionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates or updates an Azure Cosmos DB Mongo User Definition.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateMongoUserDefinitionParameters The properties required to create or update a User
   *                                                  Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoUserDefinitionAndWait(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateMongoUserDefinitionParameters: MongoUserDefinitionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoUserDefinitionOptionalParams
  ): Promise<MongoDBResourcesCreateUpdateMongoUserDefinitionResponse> {
    const poller = await this.beginCreateUpdateMongoUserDefinition(
      mongoUserDefinitionId,
      resourceGroupName,
      accountName,
      createUpdateMongoUserDefinitionParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB Mongo User Definition.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteMongoUserDefinition(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesDeleteMongoUserDefinitionOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { mongoUserDefinitionId, resourceGroupName, accountName, options },
      deleteMongoUserDefinitionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB Mongo User Definition.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteMongoUserDefinitionAndWait(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesDeleteMongoUserDefinitionOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteMongoUserDefinition(
      mongoUserDefinitionId,
      resourceGroupName,
      accountName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the list of all Azure Cosmos DB Mongo User Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listMongoUserDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoUserDefinitionsOptionalParams
  ): Promise<MongoDBResourcesListMongoUserDefinitionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listMongoUserDefinitionsOperationSpec
    );
  }

  /**
   * Retrieves continuous backup information for a Mongodb collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformation(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    location: ContinuousBackupRestoreLocation,
    options?: MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesRetrieveContinuousBackupInformationResponse
      >,
      MongoDBResourcesRetrieveContinuousBackupInformationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesRetrieveContinuousBackupInformationResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        location,
        options
      },
      retrieveContinuousBackupInformationOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieves continuous backup information for a Mongodb collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformationAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    location: ContinuousBackupRestoreLocation,
    options?: MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams
  ): Promise<MongoDBResourcesRetrieveContinuousBackupInformationResponse> {
    const poller = await this.beginRetrieveContinuousBackupInformation(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      location,
      options
    );
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listMongoDBDatabasesOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    },
    201: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    },
    202: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    },
    204: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    }
  },
  requestBody: Parameters.createUpdateMongoDBDatabaseParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  serializer
};
const getMongoDBDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const updateMongoDBDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const migrateMongoDBDatabaseToAutoscaleOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const migrateMongoDBDatabaseToManualThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const mongoDBDatabaseRetrieveThroughputDistributionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/retrieveThroughputDistribution",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.retrieveThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const mongoDBDatabaseRedistributeThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/redistributeThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.redistributeThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const mongoDBContainerRetrieveThroughputDistributionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/retrieveThroughputDistribution",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.retrieveThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const mongoDBContainerRedistributeThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/redistributeThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.redistributeThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const listMongoDBCollectionsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    },
    201: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    },
    202: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    },
    204: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    }
  },
  requestBody: Parameters.createUpdateMongoDBCollectionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  serializer
};
const listMongoDBCollectionPartitionMergeOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/partitionMerge",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionStorageInfoCollection
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionStorageInfoCollection
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionStorageInfoCollection
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionStorageInfoCollection
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.mergeParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const getMongoDBCollectionThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const updateMongoDBCollectionThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const migrateMongoDBCollectionToAutoscaleOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToAutoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const migrateMongoDBCollectionToManualThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToManualThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getMongoRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoRoleDefinitionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateMongoRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults
    },
    201: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults
    },
    202: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults
    },
    204: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.createUpdateMongoRoleDefinitionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoRoleDefinitionId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteMongoRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoRoleDefinitionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listMongoRoleDefinitionsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoRoleDefinitionListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getMongoUserDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoUserDefinitionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateMongoUserDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults
    },
    201: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults
    },
    202: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults
    },
    204: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.createUpdateMongoUserDefinitionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoUserDefinitionId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteMongoUserDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoUserDefinitionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listMongoUserDefinitionsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoUserDefinitionListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const retrieveContinuousBackupInformationOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/retrieveContinuousBackupInformation",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.BackupInformation
    },
    201: {
      bodyMapper: Mappers.BackupInformation
    },
    202: {
      bodyMapper: Mappers.BackupInformation
    },
    204: {
      bodyMapper: Mappers.BackupInformation
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.location,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
