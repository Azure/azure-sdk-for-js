/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { MongoDBResources } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { CosmosDBManagementClient } from "../cosmosDBManagementClient";
import {
  SimplePollerLike,
  OperationState,
  createHttpPoller,
} from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
import {
  MongoDBDatabaseGetResults,
  MongoDBResourcesListMongoDBDatabasesOptionalParams,
  MongoDBResourcesListMongoDBDatabasesResponse,
  MongoDBCollectionGetResults,
  MongoDBResourcesListMongoDBCollectionsOptionalParams,
  MongoDBResourcesListMongoDBCollectionsResponse,
  MongoRoleDefinitionGetResults,
  MongoDBResourcesListMongoRoleDefinitionsOptionalParams,
  MongoDBResourcesListMongoRoleDefinitionsResponse,
  MongoUserDefinitionGetResults,
  MongoDBResourcesListMongoUserDefinitionsOptionalParams,
  MongoDBResourcesListMongoUserDefinitionsResponse,
  MongoDBResourcesGetMongoDBDatabaseOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseResponse,
  MongoDBDatabaseCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams,
  MongoDBResourcesCreateUpdateMongoDBDatabaseResponse,
  MongoDBResourcesDeleteMongoDBDatabaseOptionalParams,
  MongoDBResourcesDeleteMongoDBDatabaseResponse,
  MongoDBResourcesGetMongoDBDatabaseThroughputOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseThroughputResponse,
  ThroughputSettingsUpdateParameters,
  MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams,
  MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse,
  MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams,
  MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse,
  MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams,
  MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse,
  MongoDBResourcesGetMongoDBCollectionOptionalParams,
  MongoDBResourcesGetMongoDBCollectionResponse,
  MongoDBCollectionCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams,
  MongoDBResourcesCreateUpdateMongoDBCollectionResponse,
  MongoDBResourcesDeleteMongoDBCollectionOptionalParams,
  MongoDBResourcesDeleteMongoDBCollectionResponse,
  MongoDBResourcesGetMongoDBCollectionThroughputOptionalParams,
  MongoDBResourcesGetMongoDBCollectionThroughputResponse,
  MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams,
  MongoDBResourcesUpdateMongoDBCollectionThroughputResponse,
  MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams,
  MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse,
  MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams,
  MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse,
  MongoDBResourcesGetMongoRoleDefinitionOptionalParams,
  MongoDBResourcesGetMongoRoleDefinitionResponse,
  MongoRoleDefinitionCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoRoleDefinitionOptionalParams,
  MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse,
  MongoDBResourcesDeleteMongoRoleDefinitionOptionalParams,
  MongoDBResourcesGetMongoUserDefinitionOptionalParams,
  MongoDBResourcesGetMongoUserDefinitionResponse,
  MongoUserDefinitionCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoUserDefinitionOptionalParams,
  MongoDBResourcesCreateUpdateMongoUserDefinitionResponse,
  MongoDBResourcesDeleteMongoUserDefinitionOptionalParams,
  ContinuousBackupRestoreLocation,
  MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams,
  MongoDBResourcesRetrieveContinuousBackupInformationResponse,
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing MongoDBResources operations. */
export class MongoDBResourcesImpl implements MongoDBResources {
  private readonly client: CosmosDBManagementClient;

  /**
   * Initialize a new instance of the class MongoDBResources class.
   * @param client Reference to the service client
   */
  constructor(client: CosmosDBManagementClient) {
    this.client = client;
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listMongoDBDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
  ): PagedAsyncIterableIterator<MongoDBDatabaseGetResults> {
    const iter = this.listMongoDBDatabasesPagingAll(
      resourceGroupName,
      accountName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoDBDatabasesPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings,
        );
      },
    };
  }

  private async *listMongoDBDatabasesPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<MongoDBDatabaseGetResults[]> {
    let result: MongoDBResourcesListMongoDBDatabasesResponse;
    result = await this._listMongoDBDatabases(
      resourceGroupName,
      accountName,
      options,
    );
    yield result.value || [];
  }

  private async *listMongoDBDatabasesPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
  ): AsyncIterableIterator<MongoDBDatabaseGetResults> {
    for await (const page of this.listMongoDBDatabasesPagingPage(
      resourceGroupName,
      accountName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  public listMongoDBCollections(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
  ): PagedAsyncIterableIterator<MongoDBCollectionGetResults> {
    const iter = this.listMongoDBCollectionsPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoDBCollectionsPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          options,
          settings,
        );
      },
    };
  }

  private async *listMongoDBCollectionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<MongoDBCollectionGetResults[]> {
    let result: MongoDBResourcesListMongoDBCollectionsResponse;
    result = await this._listMongoDBCollections(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    yield result.value || [];
  }

  private async *listMongoDBCollectionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
  ): AsyncIterableIterator<MongoDBCollectionGetResults> {
    for await (const page of this.listMongoDBCollectionsPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listMongoRoleDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoRoleDefinitionsOptionalParams,
  ): PagedAsyncIterableIterator<MongoRoleDefinitionGetResults> {
    const iter = this.listMongoRoleDefinitionsPagingAll(
      resourceGroupName,
      accountName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoRoleDefinitionsPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings,
        );
      },
    };
  }

  private async *listMongoRoleDefinitionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoRoleDefinitionsOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<MongoRoleDefinitionGetResults[]> {
    let result: MongoDBResourcesListMongoRoleDefinitionsResponse;
    result = await this._listMongoRoleDefinitions(
      resourceGroupName,
      accountName,
      options,
    );
    yield result.value || [];
  }

  private async *listMongoRoleDefinitionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoRoleDefinitionsOptionalParams,
  ): AsyncIterableIterator<MongoRoleDefinitionGetResults> {
    for await (const page of this.listMongoRoleDefinitionsPagingPage(
      resourceGroupName,
      accountName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves the list of all Azure Cosmos DB Mongo User Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listMongoUserDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoUserDefinitionsOptionalParams,
  ): PagedAsyncIterableIterator<MongoUserDefinitionGetResults> {
    const iter = this.listMongoUserDefinitionsPagingAll(
      resourceGroupName,
      accountName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMongoUserDefinitionsPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings,
        );
      },
    };
  }

  private async *listMongoUserDefinitionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoUserDefinitionsOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<MongoUserDefinitionGetResults[]> {
    let result: MongoDBResourcesListMongoUserDefinitionsResponse;
    result = await this._listMongoUserDefinitions(
      resourceGroupName,
      accountName,
      options,
    );
    yield result.value || [];
  }

  private async *listMongoUserDefinitionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoUserDefinitionsOptionalParams,
  ): AsyncIterableIterator<MongoUserDefinitionGetResults> {
    for await (const page of this.listMongoUserDefinitionsPagingPage(
      resourceGroupName,
      accountName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listMongoDBDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams,
  ): Promise<MongoDBResourcesListMongoDBDatabasesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listMongoDBDatabasesOperationSpec,
    );
  }

  /**
   * Gets the MongoDB databases under an existing Azure Cosmos DB database account with the provided
   * name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesGetMongoDBDatabaseOptionalParams,
  ): Promise<MongoDBResourcesGetMongoDBDatabaseResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getMongoDBDatabaseOperationSpec,
    );
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
   *                                              database.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateMongoDBDatabaseParameters: MongoDBDatabaseCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse>,
      MongoDBResourcesCreateUpdateMongoDBDatabaseResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        createUpdateMongoDBDatabaseParameters,
        options,
      },
      spec: createUpdateMongoDBDatabaseOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesCreateUpdateMongoDBDatabaseResponse,
      OperationState<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
   *                                              database.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateMongoDBDatabaseParameters: MongoDBDatabaseCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams,
  ): Promise<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse> {
    const poller = await this.beginCreateUpdateMongoDBDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      createUpdateMongoDBDatabaseParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesDeleteMongoDBDatabaseOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesDeleteMongoDBDatabaseResponse>,
      MongoDBResourcesDeleteMongoDBDatabaseResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesDeleteMongoDBDatabaseResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: deleteMongoDBDatabaseOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesDeleteMongoDBDatabaseResponse,
      OperationState<MongoDBResourcesDeleteMongoDBDatabaseResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesDeleteMongoDBDatabaseOptionalParams,
  ): Promise<MongoDBResourcesDeleteMongoDBDatabaseResponse> {
    const poller = await this.beginDeleteMongoDBDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the MongoDB database under an existing Azure Cosmos DB database account
   * with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getMongoDBDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesGetMongoDBDatabaseThroughputOptionalParams,
  ): Promise<MongoDBResourcesGetMongoDBDatabaseThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getMongoDBDatabaseThroughputOperationSpec,
    );
  }

  /**
   * Update RUs per second of the an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB database.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse>,
      MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        updateThroughputParameters,
        options,
      },
      spec: updateMongoDBDatabaseThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse,
      OperationState<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update RUs per second of the an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB database.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBDatabaseThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams,
  ): Promise<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse> {
    const poller = await this.beginUpdateMongoDBDatabaseThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      updateThroughputParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse>,
      MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: migrateMongoDBDatabaseToAutoscaleOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse,
      OperationState<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams,
  ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse> {
    const poller = await this.beginMigrateMongoDBDatabaseToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse>,
      MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: migrateMongoDBDatabaseToManualThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse,
      OperationState<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams,
  ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse> {
    const poller = await this.beginMigrateMongoDBDatabaseToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  private _listMongoDBCollections(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams,
  ): Promise<MongoDBResourcesListMongoDBCollectionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      listMongoDBCollectionsOperationSpec,
    );
  }

  /**
   * Gets the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  getMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesGetMongoDBCollectionOptionalParams,
  ): Promise<MongoDBResourcesGetMongoDBCollectionResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, collectionName, options },
      getMongoDBCollectionOperationSpec,
    );
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
   *                                                Collection.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    createUpdateMongoDBCollectionParameters: MongoDBCollectionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesCreateUpdateMongoDBCollectionResponse>,
      MongoDBResourcesCreateUpdateMongoDBCollectionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesCreateUpdateMongoDBCollectionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        createUpdateMongoDBCollectionParameters,
        options,
      },
      spec: createUpdateMongoDBCollectionOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesCreateUpdateMongoDBCollectionResponse,
      OperationState<MongoDBResourcesCreateUpdateMongoDBCollectionResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
   *                                                Collection.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBCollectionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    createUpdateMongoDBCollectionParameters: MongoDBCollectionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams,
  ): Promise<MongoDBResourcesCreateUpdateMongoDBCollectionResponse> {
    const poller = await this.beginCreateUpdateMongoDBCollection(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      createUpdateMongoDBCollectionParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesDeleteMongoDBCollectionOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesDeleteMongoDBCollectionResponse>,
      MongoDBResourcesDeleteMongoDBCollectionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesDeleteMongoDBCollectionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        options,
      },
      spec: deleteMongoDBCollectionOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesDeleteMongoDBCollectionResponse,
      OperationState<MongoDBResourcesDeleteMongoDBCollectionResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBCollectionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesDeleteMongoDBCollectionOptionalParams,
  ): Promise<MongoDBResourcesDeleteMongoDBCollectionResponse> {
    const poller = await this.beginDeleteMongoDBCollection(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the MongoDB collection under an existing Azure Cosmos DB database account
   * with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  getMongoDBCollectionThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesGetMongoDBCollectionThroughputOptionalParams,
  ): Promise<MongoDBResourcesGetMongoDBCollectionThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, collectionName, options },
      getMongoDBCollectionThroughputOperationSpec,
    );
  }

  /**
   * Update the RUs per second of an Azure Cosmos DB MongoDB collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB collection.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBCollectionThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse>,
      MongoDBResourcesUpdateMongoDBCollectionThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        updateThroughputParameters,
        options,
      },
      spec: updateMongoDBCollectionThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesUpdateMongoDBCollectionThroughputResponse,
      OperationState<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update the RUs per second of an Azure Cosmos DB MongoDB collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB collection.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBCollectionThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams,
  ): Promise<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse> {
    const poller = await this.beginUpdateMongoDBCollectionThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      updateThroughputParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse>,
      MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        options,
      },
      spec: migrateMongoDBCollectionToAutoscaleOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse,
      OperationState<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams,
  ): Promise<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse> {
    const poller = await this.beginMigrateMongoDBCollectionToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse>,
      MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        options,
      },
      spec: migrateMongoDBCollectionToManualThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse,
      OperationState<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams,
  ): Promise<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse> {
    const poller = await this.beginMigrateMongoDBCollectionToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB Mongo Role Definition with the given Id.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  getMongoRoleDefinition(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesGetMongoRoleDefinitionOptionalParams,
  ): Promise<MongoDBResourcesGetMongoRoleDefinitionResponse> {
    return this.client.sendOperationRequest(
      { mongoRoleDefinitionId, resourceGroupName, accountName, options },
      getMongoRoleDefinitionOperationSpec,
    );
  }

  /**
   * Creates or updates an Azure Cosmos DB Mongo Role Definition.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateMongoRoleDefinitionParameters The properties required to create or update a Role
   *                                                  Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoRoleDefinition(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateMongoRoleDefinitionParameters: MongoRoleDefinitionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoRoleDefinitionOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse>,
      MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        mongoRoleDefinitionId,
        resourceGroupName,
        accountName,
        createUpdateMongoRoleDefinitionParameters,
        options,
      },
      spec: createUpdateMongoRoleDefinitionOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse,
      OperationState<MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates or updates an Azure Cosmos DB Mongo Role Definition.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateMongoRoleDefinitionParameters The properties required to create or update a Role
   *                                                  Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoRoleDefinitionAndWait(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateMongoRoleDefinitionParameters: MongoRoleDefinitionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoRoleDefinitionOptionalParams,
  ): Promise<MongoDBResourcesCreateUpdateMongoRoleDefinitionResponse> {
    const poller = await this.beginCreateUpdateMongoRoleDefinition(
      mongoRoleDefinitionId,
      resourceGroupName,
      accountName,
      createUpdateMongoRoleDefinitionParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB Mongo Role Definition.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteMongoRoleDefinition(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesDeleteMongoRoleDefinitionOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { mongoRoleDefinitionId, resourceGroupName, accountName, options },
      spec: deleteMongoRoleDefinitionOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB Mongo Role Definition.
   * @param mongoRoleDefinitionId The ID for the Role Definition {dbName.roleName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteMongoRoleDefinitionAndWait(
    mongoRoleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesDeleteMongoRoleDefinitionOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteMongoRoleDefinition(
      mongoRoleDefinitionId,
      resourceGroupName,
      accountName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the list of all Azure Cosmos DB Mongo Role Definitions.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listMongoRoleDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoRoleDefinitionsOptionalParams,
  ): Promise<MongoDBResourcesListMongoRoleDefinitionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listMongoRoleDefinitionsOperationSpec,
    );
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB Mongo User Definition with the given Id.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  getMongoUserDefinition(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesGetMongoUserDefinitionOptionalParams,
  ): Promise<MongoDBResourcesGetMongoUserDefinitionResponse> {
    return this.client.sendOperationRequest(
      { mongoUserDefinitionId, resourceGroupName, accountName, options },
      getMongoUserDefinitionOperationSpec,
    );
  }

  /**
   * Creates or updates an Azure Cosmos DB Mongo User Definition.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateMongoUserDefinitionParameters The properties required to create or update a User
   *                                                  Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoUserDefinition(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateMongoUserDefinitionParameters: MongoUserDefinitionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoUserDefinitionOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesCreateUpdateMongoUserDefinitionResponse>,
      MongoDBResourcesCreateUpdateMongoUserDefinitionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesCreateUpdateMongoUserDefinitionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        mongoUserDefinitionId,
        resourceGroupName,
        accountName,
        createUpdateMongoUserDefinitionParameters,
        options,
      },
      spec: createUpdateMongoUserDefinitionOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesCreateUpdateMongoUserDefinitionResponse,
      OperationState<MongoDBResourcesCreateUpdateMongoUserDefinitionResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates or updates an Azure Cosmos DB Mongo User Definition.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateMongoUserDefinitionParameters The properties required to create or update a User
   *                                                  Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoUserDefinitionAndWait(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateMongoUserDefinitionParameters: MongoUserDefinitionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoUserDefinitionOptionalParams,
  ): Promise<MongoDBResourcesCreateUpdateMongoUserDefinitionResponse> {
    const poller = await this.beginCreateUpdateMongoUserDefinition(
      mongoUserDefinitionId,
      resourceGroupName,
      accountName,
      createUpdateMongoUserDefinitionParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB Mongo User Definition.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteMongoUserDefinition(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesDeleteMongoUserDefinitionOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { mongoUserDefinitionId, resourceGroupName, accountName, options },
      spec: deleteMongoUserDefinitionOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB Mongo User Definition.
   * @param mongoUserDefinitionId The ID for the User Definition {dbName.userName}.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteMongoUserDefinitionAndWait(
    mongoUserDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesDeleteMongoUserDefinitionOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteMongoUserDefinition(
      mongoUserDefinitionId,
      resourceGroupName,
      accountName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the list of all Azure Cosmos DB Mongo User Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listMongoUserDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoUserDefinitionsOptionalParams,
  ): Promise<MongoDBResourcesListMongoUserDefinitionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listMongoUserDefinitionsOperationSpec,
    );
  }

  /**
   * Retrieves continuous backup information for a Mongodb collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformation(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    location: ContinuousBackupRestoreLocation,
    options?: MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<MongoDBResourcesRetrieveContinuousBackupInformationResponse>,
      MongoDBResourcesRetrieveContinuousBackupInformationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<MongoDBResourcesRetrieveContinuousBackupInformationResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        location,
        options,
      },
      spec: retrieveContinuousBackupInformationOperationSpec,
    });
    const poller = await createHttpPoller<
      MongoDBResourcesRetrieveContinuousBackupInformationResponse,
      OperationState<MongoDBResourcesRetrieveContinuousBackupInformationResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieves continuous backup information for a Mongodb collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformationAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    location: ContinuousBackupRestoreLocation,
    options?: MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams,
  ): Promise<MongoDBResourcesRetrieveContinuousBackupInformationResponse> {
    const poller = await this.beginRetrieveContinuousBackupInformation(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      location,
      options,
    );
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listMongoDBDatabasesOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
    201: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
    202: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
    204: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults,
    },
  },
  requestBody: Parameters.createUpdateMongoDBDatabaseParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.MongoDBResourcesDeleteMongoDBDatabaseHeaders,
    },
    201: {
      headersMapper: Mappers.MongoDBResourcesDeleteMongoDBDatabaseHeaders,
    },
    202: {
      headersMapper: Mappers.MongoDBResourcesDeleteMongoDBDatabaseHeaders,
    },
    204: {
      headersMapper: Mappers.MongoDBResourcesDeleteMongoDBDatabaseHeaders,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  serializer,
};
const getMongoDBDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const updateMongoDBDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const migrateMongoDBDatabaseToAutoscaleOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.ErrorResponse,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const migrateMongoDBDatabaseToManualThroughputOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.ErrorResponse,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const listMongoDBCollectionsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
    201: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
    202: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
    204: {
      bodyMapper: Mappers.MongoDBCollectionGetResults,
    },
  },
  requestBody: Parameters.createUpdateMongoDBCollectionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.MongoDBResourcesDeleteMongoDBCollectionHeaders,
    },
    201: {
      headersMapper: Mappers.MongoDBResourcesDeleteMongoDBCollectionHeaders,
    },
    202: {
      headersMapper: Mappers.MongoDBResourcesDeleteMongoDBCollectionHeaders,
    },
    204: {
      headersMapper: Mappers.MongoDBResourcesDeleteMongoDBCollectionHeaders,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName,
  ],
  serializer,
};
const getMongoDBCollectionThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const updateMongoDBCollectionThroughputOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
    httpMethod: "PUT",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
    },
    requestBody: Parameters.updateThroughputParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.collectionName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
  };
const migrateMongoDBCollectionToAutoscaleOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToAutoscale",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.ErrorResponse,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.collectionName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const migrateMongoDBCollectionToManualThroughputOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.ErrorResponse,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.collectionName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const getMongoRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoRoleDefinitionId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateMongoRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults,
    },
    201: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults,
    },
    202: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults,
    },
    204: {
      bodyMapper: Mappers.MongoRoleDefinitionGetResults,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.createUpdateMongoRoleDefinitionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoRoleDefinitionId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteMongoRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions/{mongoRoleDefinitionId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoRoleDefinitionId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listMongoRoleDefinitionsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbRoleDefinitions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoRoleDefinitionListResult,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getMongoUserDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoUserDefinitionId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateMongoUserDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults,
    },
    201: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults,
    },
    202: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults,
    },
    204: {
      bodyMapper: Mappers.MongoUserDefinitionGetResults,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  requestBody: Parameters.createUpdateMongoUserDefinitionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoUserDefinitionId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteMongoUserDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions/{mongoUserDefinitionId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.mongoUserDefinitionId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listMongoUserDefinitionsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbUserDefinitions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoUserDefinitionListResult,
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const retrieveContinuousBackupInformationOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.BackupInformation,
      },
      201: {
        bodyMapper: Mappers.BackupInformation,
      },
      202: {
        bodyMapper: Mappers.BackupInformation,
      },
      204: {
        bodyMapper: Mappers.BackupInformation,
      },
      default: {
        bodyMapper: Mappers.ErrorResponse,
      },
    },
    requestBody: Parameters.location,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.collectionName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
  };
