/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { MongoDBResources } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { CosmosDBManagementClient } from "../cosmosDBManagementClient";
import { PollerLike, PollOperationState, LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
import {
  MongoDBDatabaseGetResults,
  MongoDBResourcesListMongoDBDatabasesOptionalParams,
  MongoDBCollectionGetResults,
  MongoDBResourcesListMongoDBCollectionsOptionalParams,
  MongoDBResourcesListMongoDBDatabasesResponse,
  MongoDBResourcesGetMongoDBDatabaseOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseResponse,
  MongoDBDatabaseCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams,
  MongoDBResourcesCreateUpdateMongoDBDatabaseResponse,
  MongoDBResourcesDeleteMongoDBDatabaseOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseThroughputOptionalParams,
  MongoDBResourcesGetMongoDBDatabaseThroughputResponse,
  ThroughputSettingsUpdateParameters,
  MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams,
  MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse,
  MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams,
  MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse,
  MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams,
  MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse,
  MongoDBResourcesListMongoDBCollectionsResponse,
  MongoDBResourcesGetMongoDBCollectionOptionalParams,
  MongoDBResourcesGetMongoDBCollectionResponse,
  MongoDBCollectionCreateUpdateParameters,
  MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams,
  MongoDBResourcesCreateUpdateMongoDBCollectionResponse,
  MongoDBResourcesDeleteMongoDBCollectionOptionalParams,
  MongoDBResourcesGetMongoDBCollectionThroughputOptionalParams,
  MongoDBResourcesGetMongoDBCollectionThroughputResponse,
  MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams,
  MongoDBResourcesUpdateMongoDBCollectionThroughputResponse,
  MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams,
  MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse,
  MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams,
  MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse,
  ContinuousBackupRestoreLocation,
  MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams,
  MongoDBResourcesRetrieveContinuousBackupInformationResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing MongoDBResources operations. */
export class MongoDBResourcesImpl implements MongoDBResources {
  private readonly client: CosmosDBManagementClient;

  /**
   * Initialize a new instance of the class MongoDBResources class.
   * @param client Reference to the service client
   */
  constructor(client: CosmosDBManagementClient) {
    this.client = client;
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listMongoDBDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams
  ): PagedAsyncIterableIterator<MongoDBDatabaseGetResults> {
    const iter = this.listMongoDBDatabasesPagingAll(
      resourceGroupName,
      accountName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listMongoDBDatabasesPagingPage(
          resourceGroupName,
          accountName,
          options
        );
      }
    };
  }

  private async *listMongoDBDatabasesPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams
  ): AsyncIterableIterator<MongoDBDatabaseGetResults[]> {
    let result = await this._listMongoDBDatabases(
      resourceGroupName,
      accountName,
      options
    );
    yield result.value || [];
  }

  private async *listMongoDBDatabasesPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams
  ): AsyncIterableIterator<MongoDBDatabaseGetResults> {
    for await (const page of this.listMongoDBDatabasesPagingPage(
      resourceGroupName,
      accountName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  public listMongoDBCollections(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams
  ): PagedAsyncIterableIterator<MongoDBCollectionGetResults> {
    const iter = this.listMongoDBCollectionsPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listMongoDBCollectionsPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          options
        );
      }
    };
  }

  private async *listMongoDBCollectionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams
  ): AsyncIterableIterator<MongoDBCollectionGetResults[]> {
    let result = await this._listMongoDBCollections(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    yield result.value || [];
  }

  private async *listMongoDBCollectionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams
  ): AsyncIterableIterator<MongoDBCollectionGetResults> {
    for await (const page of this.listMongoDBCollectionsPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listMongoDBDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: MongoDBResourcesListMongoDBDatabasesOptionalParams
  ): Promise<MongoDBResourcesListMongoDBDatabasesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listMongoDBDatabasesOperationSpec
    );
  }

  /**
   * Gets the MongoDB databases under an existing Azure Cosmos DB database account with the provided
   * name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesGetMongoDBDatabaseOptionalParams
  ): Promise<MongoDBResourcesGetMongoDBDatabaseResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getMongoDBDatabaseOperationSpec
    );
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
   *                                              database.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateMongoDBDatabaseParameters: MongoDBDatabaseCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse>,
      MongoDBResourcesCreateUpdateMongoDBDatabaseResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        createUpdateMongoDBDatabaseParameters,
        options
      },
      createUpdateMongoDBDatabaseOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateMongoDBDatabaseParameters The parameters to provide for the current MongoDB
   *                                              database.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateMongoDBDatabaseParameters: MongoDBDatabaseCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBDatabaseOptionalParams
  ): Promise<MongoDBResourcesCreateUpdateMongoDBDatabaseResponse> {
    const poller = await this.beginCreateUpdateMongoDBDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      createUpdateMongoDBDatabaseParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesDeleteMongoDBDatabaseOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      deleteMongoDBDatabaseOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesDeleteMongoDBDatabaseOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteMongoDBDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the MongoDB database under an existing Azure Cosmos DB database account
   * with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getMongoDBDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesGetMongoDBDatabaseThroughputOptionalParams
  ): Promise<MongoDBResourcesGetMongoDBDatabaseThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getMongoDBDatabaseThroughputOperationSpec
    );
  }

  /**
   * Update RUs per second of the an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB database.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse
      >,
      MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        updateThroughputParameters,
        options
      },
      updateMongoDBDatabaseThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update RUs per second of the an Azure Cosmos DB MongoDB database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB database.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBDatabaseThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBDatabaseThroughputOptionalParams
  ): Promise<MongoDBResourcesUpdateMongoDBDatabaseThroughputResponse> {
    const poller = await this.beginUpdateMongoDBDatabaseThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      updateThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse
      >,
      MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      migrateMongoDBDatabaseToAutoscaleOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleOptionalParams
  ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToAutoscaleResponse> {
    const poller = await this.beginMigrateMongoDBDatabaseToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse
      >,
      MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      migrateMongoDBDatabaseToManualThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBDatabaseToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputOptionalParams
  ): Promise<MongoDBResourcesMigrateMongoDBDatabaseToManualThroughputResponse> {
    const poller = await this.beginMigrateMongoDBDatabaseToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  private _listMongoDBCollections(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: MongoDBResourcesListMongoDBCollectionsOptionalParams
  ): Promise<MongoDBResourcesListMongoDBCollectionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      listMongoDBCollectionsOperationSpec
    );
  }

  /**
   * Gets the MongoDB collection under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  getMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesGetMongoDBCollectionOptionalParams
  ): Promise<MongoDBResourcesGetMongoDBCollectionResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, collectionName, options },
      getMongoDBCollectionOperationSpec
    );
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
   *                                                Collection.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    createUpdateMongoDBCollectionParameters: MongoDBCollectionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<MongoDBResourcesCreateUpdateMongoDBCollectionResponse>,
      MongoDBResourcesCreateUpdateMongoDBCollectionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesCreateUpdateMongoDBCollectionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        createUpdateMongoDBCollectionParameters,
        options
      },
      createUpdateMongoDBCollectionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param createUpdateMongoDBCollectionParameters The parameters to provide for the current MongoDB
   *                                                Collection.
   * @param options The options parameters.
   */
  async beginCreateUpdateMongoDBCollectionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    createUpdateMongoDBCollectionParameters: MongoDBCollectionCreateUpdateParameters,
    options?: MongoDBResourcesCreateUpdateMongoDBCollectionOptionalParams
  ): Promise<MongoDBResourcesCreateUpdateMongoDBCollectionResponse> {
    const poller = await this.beginCreateUpdateMongoDBCollection(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      createUpdateMongoDBCollectionParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBCollection(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesDeleteMongoDBCollectionOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, collectionName, options },
      deleteMongoDBCollectionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginDeleteMongoDBCollectionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesDeleteMongoDBCollectionOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteMongoDBCollection(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the MongoDB collection under an existing Azure Cosmos DB database account
   * with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  getMongoDBCollectionThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesGetMongoDBCollectionThroughputOptionalParams
  ): Promise<MongoDBResourcesGetMongoDBCollectionThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, collectionName, options },
      getMongoDBCollectionThroughputOperationSpec
    );
  }

  /**
   * Update the RUs per second of an Azure Cosmos DB MongoDB collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB collection.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBCollectionThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesUpdateMongoDBCollectionThroughputResponse
      >,
      MongoDBResourcesUpdateMongoDBCollectionThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        updateThroughputParameters,
        options
      },
      updateMongoDBCollectionThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update the RUs per second of an Azure Cosmos DB MongoDB collection
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param updateThroughputParameters The RUs per second of the parameters to provide for the current
   *                                   MongoDB collection.
   * @param options The options parameters.
   */
  async beginUpdateMongoDBCollectionThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: MongoDBResourcesUpdateMongoDBCollectionThroughputOptionalParams
  ): Promise<MongoDBResourcesUpdateMongoDBCollectionThroughputResponse> {
    const poller = await this.beginUpdateMongoDBCollectionThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      updateThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse
      >,
      MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, collectionName, options },
      migrateMongoDBCollectionToAutoscaleOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToAutoscaleOptionalParams
  ): Promise<MongoDBResourcesMigrateMongoDBCollectionToAutoscaleResponse> {
    const poller = await this.beginMigrateMongoDBCollectionToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse
      >,
      MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, collectionName, options },
      migrateMongoDBCollectionToManualThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB MongoDB collection from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param options The options parameters.
   */
  async beginMigrateMongoDBCollectionToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    options?: MongoDBResourcesMigrateMongoDBCollectionToManualThroughputOptionalParams
  ): Promise<
    MongoDBResourcesMigrateMongoDBCollectionToManualThroughputResponse
  > {
    const poller = await this.beginMigrateMongoDBCollectionToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves continuous backup information for a Mongodb collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformation(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    location: ContinuousBackupRestoreLocation,
    options?: MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        MongoDBResourcesRetrieveContinuousBackupInformationResponse
      >,
      MongoDBResourcesRetrieveContinuousBackupInformationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<MongoDBResourcesRetrieveContinuousBackupInformationResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        collectionName,
        location,
        options
      },
      retrieveContinuousBackupInformationOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieves continuous backup information for a Mongodb collection.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param collectionName Cosmos DB collection name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformationAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    collectionName: string,
    location: ContinuousBackupRestoreLocation,
    options?: MongoDBResourcesRetrieveContinuousBackupInformationOptionalParams
  ): Promise<MongoDBResourcesRetrieveContinuousBackupInformationResponse> {
    const poller = await this.beginRetrieveContinuousBackupInformation(
      resourceGroupName,
      accountName,
      databaseName,
      collectionName,
      location,
      options
    );
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listMongoDBDatabasesOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    },
    201: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    },
    202: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    },
    204: {
      bodyMapper: Mappers.MongoDBDatabaseGetResults
    }
  },
  requestBody: Parameters.createUpdateMongoDBDatabaseParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteMongoDBDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  serializer
};
const getMongoDBDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const updateMongoDBDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const migrateMongoDBDatabaseToAutoscaleOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const migrateMongoDBDatabaseToManualThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listMongoDBCollectionsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    },
    201: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    },
    202: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    },
    204: {
      bodyMapper: Mappers.MongoDBCollectionGetResults
    }
  },
  requestBody: Parameters.createUpdateMongoDBCollectionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteMongoDBCollectionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  serializer
};
const getMongoDBCollectionThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const updateMongoDBCollectionThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const migrateMongoDBCollectionToAutoscaleOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToAutoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const migrateMongoDBCollectionToManualThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/throughputSettings/default/migrateToManualThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const retrieveContinuousBackupInformationOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/mongodbDatabases/{databaseName}/collections/{collectionName}/retrieveContinuousBackupInformation",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.BackupInformation
    },
    201: {
      bodyMapper: Mappers.BackupInformation
    },
    202: {
      bodyMapper: Mappers.BackupInformation
    },
    204: {
      bodyMapper: Mappers.BackupInformation
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.location,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.collectionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
