/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { SqlResources } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { CosmosDBManagementClient } from "../cosmosDBManagementClient";
import {
  SimplePollerLike,
  OperationState,
  createHttpPoller,
} from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
import {
  SqlDatabaseGetResults,
  SqlResourcesListSqlDatabasesOptionalParams,
  SqlResourcesListSqlDatabasesResponse,
  SqlContainerGetResults,
  SqlResourcesListSqlContainersOptionalParams,
  SqlResourcesListSqlContainersResponse,
  ClientEncryptionKeyGetResults,
  SqlResourcesListClientEncryptionKeysOptionalParams,
  SqlResourcesListClientEncryptionKeysResponse,
  SqlStoredProcedureGetResults,
  SqlResourcesListSqlStoredProceduresOptionalParams,
  SqlResourcesListSqlStoredProceduresResponse,
  SqlUserDefinedFunctionGetResults,
  SqlResourcesListSqlUserDefinedFunctionsOptionalParams,
  SqlResourcesListSqlUserDefinedFunctionsResponse,
  SqlTriggerGetResults,
  SqlResourcesListSqlTriggersOptionalParams,
  SqlResourcesListSqlTriggersResponse,
  SqlRoleDefinitionGetResults,
  SqlResourcesListSqlRoleDefinitionsOptionalParams,
  SqlResourcesListSqlRoleDefinitionsResponse,
  SqlRoleAssignmentGetResults,
  SqlResourcesListSqlRoleAssignmentsOptionalParams,
  SqlResourcesListSqlRoleAssignmentsResponse,
  SqlResourcesGetSqlDatabaseOptionalParams,
  SqlResourcesGetSqlDatabaseResponse,
  SqlDatabaseCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlDatabaseOptionalParams,
  SqlResourcesCreateUpdateSqlDatabaseResponse,
  SqlResourcesDeleteSqlDatabaseOptionalParams,
  SqlResourcesDeleteSqlDatabaseResponse,
  SqlResourcesGetSqlDatabaseThroughputOptionalParams,
  SqlResourcesGetSqlDatabaseThroughputResponse,
  ThroughputSettingsUpdateParameters,
  SqlResourcesUpdateSqlDatabaseThroughputOptionalParams,
  SqlResourcesUpdateSqlDatabaseThroughputResponse,
  SqlResourcesMigrateSqlDatabaseToAutoscaleOptionalParams,
  SqlResourcesMigrateSqlDatabaseToAutoscaleResponse,
  SqlResourcesMigrateSqlDatabaseToManualThroughputOptionalParams,
  SqlResourcesMigrateSqlDatabaseToManualThroughputResponse,
  SqlResourcesGetSqlContainerOptionalParams,
  SqlResourcesGetSqlContainerResponse,
  SqlContainerCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlContainerOptionalParams,
  SqlResourcesCreateUpdateSqlContainerResponse,
  SqlResourcesDeleteSqlContainerOptionalParams,
  SqlResourcesDeleteSqlContainerResponse,
  SqlResourcesGetSqlContainerThroughputOptionalParams,
  SqlResourcesGetSqlContainerThroughputResponse,
  SqlResourcesUpdateSqlContainerThroughputOptionalParams,
  SqlResourcesUpdateSqlContainerThroughputResponse,
  SqlResourcesMigrateSqlContainerToAutoscaleOptionalParams,
  SqlResourcesMigrateSqlContainerToAutoscaleResponse,
  SqlResourcesMigrateSqlContainerToManualThroughputOptionalParams,
  SqlResourcesMigrateSqlContainerToManualThroughputResponse,
  SqlResourcesGetClientEncryptionKeyOptionalParams,
  SqlResourcesGetClientEncryptionKeyResponse,
  ClientEncryptionKeyCreateUpdateParameters,
  SqlResourcesCreateUpdateClientEncryptionKeyOptionalParams,
  SqlResourcesCreateUpdateClientEncryptionKeyResponse,
  SqlResourcesGetSqlStoredProcedureOptionalParams,
  SqlResourcesGetSqlStoredProcedureResponse,
  SqlStoredProcedureCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlStoredProcedureOptionalParams,
  SqlResourcesCreateUpdateSqlStoredProcedureResponse,
  SqlResourcesDeleteSqlStoredProcedureOptionalParams,
  SqlResourcesDeleteSqlStoredProcedureResponse,
  SqlResourcesGetSqlUserDefinedFunctionOptionalParams,
  SqlResourcesGetSqlUserDefinedFunctionResponse,
  SqlUserDefinedFunctionCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlUserDefinedFunctionOptionalParams,
  SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse,
  SqlResourcesDeleteSqlUserDefinedFunctionOptionalParams,
  SqlResourcesDeleteSqlUserDefinedFunctionResponse,
  SqlResourcesGetSqlTriggerOptionalParams,
  SqlResourcesGetSqlTriggerResponse,
  SqlTriggerCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlTriggerOptionalParams,
  SqlResourcesCreateUpdateSqlTriggerResponse,
  SqlResourcesDeleteSqlTriggerOptionalParams,
  SqlResourcesDeleteSqlTriggerResponse,
  SqlResourcesGetSqlRoleDefinitionOptionalParams,
  SqlResourcesGetSqlRoleDefinitionResponse,
  SqlRoleDefinitionCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlRoleDefinitionOptionalParams,
  SqlResourcesCreateUpdateSqlRoleDefinitionResponse,
  SqlResourcesDeleteSqlRoleDefinitionOptionalParams,
  SqlResourcesGetSqlRoleAssignmentOptionalParams,
  SqlResourcesGetSqlRoleAssignmentResponse,
  SqlRoleAssignmentCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlRoleAssignmentOptionalParams,
  SqlResourcesCreateUpdateSqlRoleAssignmentResponse,
  SqlResourcesDeleteSqlRoleAssignmentOptionalParams,
  ContinuousBackupRestoreLocation,
  SqlResourcesRetrieveContinuousBackupInformationOptionalParams,
  SqlResourcesRetrieveContinuousBackupInformationResponse,
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing SqlResources operations. */
export class SqlResourcesImpl implements SqlResources {
  private readonly client: CosmosDBManagementClient;

  /**
   * Initialize a new instance of the class SqlResources class.
   * @param client Reference to the service client
   */
  constructor(client: CosmosDBManagementClient) {
    this.client = client;
  }

  /**
   * Lists the SQL databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listSqlDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlDatabasesOptionalParams,
  ): PagedAsyncIterableIterator<SqlDatabaseGetResults> {
    const iter = this.listSqlDatabasesPagingAll(
      resourceGroupName,
      accountName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listSqlDatabasesPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings,
        );
      },
    };
  }

  private async *listSqlDatabasesPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlDatabasesOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<SqlDatabaseGetResults[]> {
    let result: SqlResourcesListSqlDatabasesResponse;
    result = await this._listSqlDatabases(
      resourceGroupName,
      accountName,
      options,
    );
    yield result.value || [];
  }

  private async *listSqlDatabasesPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlDatabasesOptionalParams,
  ): AsyncIterableIterator<SqlDatabaseGetResults> {
    for await (const page of this.listSqlDatabasesPagingPage(
      resourceGroupName,
      accountName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL container under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  public listSqlContainers(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListSqlContainersOptionalParams,
  ): PagedAsyncIterableIterator<SqlContainerGetResults> {
    const iter = this.listSqlContainersPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listSqlContainersPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          options,
          settings,
        );
      },
    };
  }

  private async *listSqlContainersPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListSqlContainersOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<SqlContainerGetResults[]> {
    let result: SqlResourcesListSqlContainersResponse;
    result = await this._listSqlContainers(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    yield result.value || [];
  }

  private async *listSqlContainersPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListSqlContainersOptionalParams,
  ): AsyncIterableIterator<SqlContainerGetResults> {
    for await (const page of this.listSqlContainersPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  public listClientEncryptionKeys(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListClientEncryptionKeysOptionalParams,
  ): PagedAsyncIterableIterator<ClientEncryptionKeyGetResults> {
    const iter = this.listClientEncryptionKeysPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listClientEncryptionKeysPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          options,
          settings,
        );
      },
    };
  }

  private async *listClientEncryptionKeysPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListClientEncryptionKeysOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<ClientEncryptionKeyGetResults[]> {
    let result: SqlResourcesListClientEncryptionKeysResponse;
    result = await this._listClientEncryptionKeys(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    yield result.value || [];
  }

  private async *listClientEncryptionKeysPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListClientEncryptionKeysOptionalParams,
  ): AsyncIterableIterator<ClientEncryptionKeyGetResults> {
    for await (const page of this.listClientEncryptionKeysPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  public listSqlStoredProcedures(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlStoredProceduresOptionalParams,
  ): PagedAsyncIterableIterator<SqlStoredProcedureGetResults> {
    const iter = this.listSqlStoredProceduresPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listSqlStoredProceduresPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          containerName,
          options,
          settings,
        );
      },
    };
  }

  private async *listSqlStoredProceduresPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlStoredProceduresOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<SqlStoredProcedureGetResults[]> {
    let result: SqlResourcesListSqlStoredProceduresResponse;
    result = await this._listSqlStoredProcedures(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    yield result.value || [];
  }

  private async *listSqlStoredProceduresPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlStoredProceduresOptionalParams,
  ): AsyncIterableIterator<SqlStoredProcedureGetResults> {
    for await (const page of this.listSqlStoredProceduresPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  public listSqlUserDefinedFunctions(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlUserDefinedFunctionsOptionalParams,
  ): PagedAsyncIterableIterator<SqlUserDefinedFunctionGetResults> {
    const iter = this.listSqlUserDefinedFunctionsPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listSqlUserDefinedFunctionsPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          containerName,
          options,
          settings,
        );
      },
    };
  }

  private async *listSqlUserDefinedFunctionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlUserDefinedFunctionsOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<SqlUserDefinedFunctionGetResults[]> {
    let result: SqlResourcesListSqlUserDefinedFunctionsResponse;
    result = await this._listSqlUserDefinedFunctions(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    yield result.value || [];
  }

  private async *listSqlUserDefinedFunctionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlUserDefinedFunctionsOptionalParams,
  ): AsyncIterableIterator<SqlUserDefinedFunctionGetResults> {
    for await (const page of this.listSqlUserDefinedFunctionsPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL trigger under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  public listSqlTriggers(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlTriggersOptionalParams,
  ): PagedAsyncIterableIterator<SqlTriggerGetResults> {
    const iter = this.listSqlTriggersPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listSqlTriggersPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          containerName,
          options,
          settings,
        );
      },
    };
  }

  private async *listSqlTriggersPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlTriggersOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<SqlTriggerGetResults[]> {
    let result: SqlResourcesListSqlTriggersResponse;
    result = await this._listSqlTriggers(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    yield result.value || [];
  }

  private async *listSqlTriggersPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlTriggersOptionalParams,
  ): AsyncIterableIterator<SqlTriggerGetResults> {
    for await (const page of this.listSqlTriggersPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves the list of all Azure Cosmos DB SQL Role Definitions.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listSqlRoleDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleDefinitionsOptionalParams,
  ): PagedAsyncIterableIterator<SqlRoleDefinitionGetResults> {
    const iter = this.listSqlRoleDefinitionsPagingAll(
      resourceGroupName,
      accountName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listSqlRoleDefinitionsPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings,
        );
      },
    };
  }

  private async *listSqlRoleDefinitionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleDefinitionsOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<SqlRoleDefinitionGetResults[]> {
    let result: SqlResourcesListSqlRoleDefinitionsResponse;
    result = await this._listSqlRoleDefinitions(
      resourceGroupName,
      accountName,
      options,
    );
    yield result.value || [];
  }

  private async *listSqlRoleDefinitionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleDefinitionsOptionalParams,
  ): AsyncIterableIterator<SqlRoleDefinitionGetResults> {
    for await (const page of this.listSqlRoleDefinitionsPagingPage(
      resourceGroupName,
      accountName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves the list of all Azure Cosmos DB SQL Role Assignments.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listSqlRoleAssignments(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleAssignmentsOptionalParams,
  ): PagedAsyncIterableIterator<SqlRoleAssignmentGetResults> {
    const iter = this.listSqlRoleAssignmentsPagingAll(
      resourceGroupName,
      accountName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listSqlRoleAssignmentsPagingPage(
          resourceGroupName,
          accountName,
          options,
          settings,
        );
      },
    };
  }

  private async *listSqlRoleAssignmentsPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleAssignmentsOptionalParams,
    _settings?: PageSettings,
  ): AsyncIterableIterator<SqlRoleAssignmentGetResults[]> {
    let result: SqlResourcesListSqlRoleAssignmentsResponse;
    result = await this._listSqlRoleAssignments(
      resourceGroupName,
      accountName,
      options,
    );
    yield result.value || [];
  }

  private async *listSqlRoleAssignmentsPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleAssignmentsOptionalParams,
  ): AsyncIterableIterator<SqlRoleAssignmentGetResults> {
    for await (const page of this.listSqlRoleAssignmentsPagingPage(
      resourceGroupName,
      accountName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listSqlDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlDatabasesOptionalParams,
  ): Promise<SqlResourcesListSqlDatabasesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listSqlDatabasesOperationSpec,
    );
  }

  /**
   * Gets the SQL database under an existing Azure Cosmos DB database account with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getSqlDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesGetSqlDatabaseOptionalParams,
  ): Promise<SqlResourcesGetSqlDatabaseResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getSqlDatabaseOperationSpec,
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateSqlDatabaseParameters The parameters to provide for the current SQL database.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateSqlDatabaseParameters: SqlDatabaseCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlDatabaseOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesCreateUpdateSqlDatabaseResponse>,
      SqlResourcesCreateUpdateSqlDatabaseResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesCreateUpdateSqlDatabaseResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        createUpdateSqlDatabaseParameters,
        options,
      },
      spec: createUpdateSqlDatabaseOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesCreateUpdateSqlDatabaseResponse,
      OperationState<SqlResourcesCreateUpdateSqlDatabaseResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateSqlDatabaseParameters The parameters to provide for the current SQL database.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateSqlDatabaseParameters: SqlDatabaseCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlDatabaseOptionalParams,
  ): Promise<SqlResourcesCreateUpdateSqlDatabaseResponse> {
    const poller = await this.beginCreateUpdateSqlDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      createUpdateSqlDatabaseParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteSqlDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesDeleteSqlDatabaseOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesDeleteSqlDatabaseResponse>,
      SqlResourcesDeleteSqlDatabaseResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesDeleteSqlDatabaseResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: deleteSqlDatabaseOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesDeleteSqlDatabaseResponse,
      OperationState<SqlResourcesDeleteSqlDatabaseResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteSqlDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesDeleteSqlDatabaseOptionalParams,
  ): Promise<SqlResourcesDeleteSqlDatabaseResponse> {
    const poller = await this.beginDeleteSqlDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the SQL database under an existing Azure Cosmos DB database account with
   * the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getSqlDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesGetSqlDatabaseThroughputOptionalParams,
  ): Promise<SqlResourcesGetSqlDatabaseThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getSqlDatabaseThroughputOperationSpec,
    );
  }

  /**
   * Update RUs per second of an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
   *                                   SQL database.
   * @param options The options parameters.
   */
  async beginUpdateSqlDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: SqlResourcesUpdateSqlDatabaseThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesUpdateSqlDatabaseThroughputResponse>,
      SqlResourcesUpdateSqlDatabaseThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesUpdateSqlDatabaseThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        updateThroughputParameters,
        options,
      },
      spec: updateSqlDatabaseThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesUpdateSqlDatabaseThroughputResponse,
      OperationState<SqlResourcesUpdateSqlDatabaseThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update RUs per second of an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
   *                                   SQL database.
   * @param options The options parameters.
   */
  async beginUpdateSqlDatabaseThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: SqlResourcesUpdateSqlDatabaseThroughputOptionalParams,
  ): Promise<SqlResourcesUpdateSqlDatabaseThroughputResponse> {
    const poller = await this.beginUpdateSqlDatabaseThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      updateThroughputParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateSqlDatabaseToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesMigrateSqlDatabaseToAutoscaleOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesMigrateSqlDatabaseToAutoscaleResponse>,
      SqlResourcesMigrateSqlDatabaseToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesMigrateSqlDatabaseToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: migrateSqlDatabaseToAutoscaleOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesMigrateSqlDatabaseToAutoscaleResponse,
      OperationState<SqlResourcesMigrateSqlDatabaseToAutoscaleResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateSqlDatabaseToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesMigrateSqlDatabaseToAutoscaleOptionalParams,
  ): Promise<SqlResourcesMigrateSqlDatabaseToAutoscaleResponse> {
    const poller = await this.beginMigrateSqlDatabaseToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateSqlDatabaseToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesMigrateSqlDatabaseToManualThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesMigrateSqlDatabaseToManualThroughputResponse>,
      SqlResourcesMigrateSqlDatabaseToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesMigrateSqlDatabaseToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { resourceGroupName, accountName, databaseName, options },
      spec: migrateSqlDatabaseToManualThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesMigrateSqlDatabaseToManualThroughputResponse,
      OperationState<SqlResourcesMigrateSqlDatabaseToManualThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateSqlDatabaseToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesMigrateSqlDatabaseToManualThroughputOptionalParams,
  ): Promise<SqlResourcesMigrateSqlDatabaseToManualThroughputResponse> {
    const poller = await this.beginMigrateSqlDatabaseToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the SQL container under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  private _listSqlContainers(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListSqlContainersOptionalParams,
  ): Promise<SqlResourcesListSqlContainersResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      listSqlContainersOperationSpec,
    );
  }

  /**
   * Gets the SQL container under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  getSqlContainer(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesGetSqlContainerOptionalParams,
  ): Promise<SqlResourcesGetSqlContainerResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      getSqlContainerOperationSpec,
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param createUpdateSqlContainerParameters The parameters to provide for the current SQL container.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlContainer(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    createUpdateSqlContainerParameters: SqlContainerCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlContainerOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesCreateUpdateSqlContainerResponse>,
      SqlResourcesCreateUpdateSqlContainerResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesCreateUpdateSqlContainerResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        createUpdateSqlContainerParameters,
        options,
      },
      spec: createUpdateSqlContainerOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesCreateUpdateSqlContainerResponse,
      OperationState<SqlResourcesCreateUpdateSqlContainerResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param createUpdateSqlContainerParameters The parameters to provide for the current SQL container.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlContainerAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    createUpdateSqlContainerParameters: SqlContainerCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlContainerOptionalParams,
  ): Promise<SqlResourcesCreateUpdateSqlContainerResponse> {
    const poller = await this.beginCreateUpdateSqlContainer(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      createUpdateSqlContainerParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL container.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginDeleteSqlContainer(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesDeleteSqlContainerOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesDeleteSqlContainerResponse>,
      SqlResourcesDeleteSqlContainerResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesDeleteSqlContainerResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        options,
      },
      spec: deleteSqlContainerOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesDeleteSqlContainerResponse,
      OperationState<SqlResourcesDeleteSqlContainerResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL container.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginDeleteSqlContainerAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesDeleteSqlContainerOptionalParams,
  ): Promise<SqlResourcesDeleteSqlContainerResponse> {
    const poller = await this.beginDeleteSqlContainer(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the SQL container under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  getSqlContainerThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesGetSqlContainerThroughputOptionalParams,
  ): Promise<SqlResourcesGetSqlContainerThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      getSqlContainerThroughputOperationSpec,
    );
  }

  /**
   * Update RUs per second of an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
   *                                   SQL container.
   * @param options The options parameters.
   */
  async beginUpdateSqlContainerThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: SqlResourcesUpdateSqlContainerThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesUpdateSqlContainerThroughputResponse>,
      SqlResourcesUpdateSqlContainerThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesUpdateSqlContainerThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        updateThroughputParameters,
        options,
      },
      spec: updateSqlContainerThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesUpdateSqlContainerThroughputResponse,
      OperationState<SqlResourcesUpdateSqlContainerThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update RUs per second of an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
   *                                   SQL container.
   * @param options The options parameters.
   */
  async beginUpdateSqlContainerThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: SqlResourcesUpdateSqlContainerThroughputOptionalParams,
  ): Promise<SqlResourcesUpdateSqlContainerThroughputResponse> {
    const poller = await this.beginUpdateSqlContainerThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      updateThroughputParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginMigrateSqlContainerToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesMigrateSqlContainerToAutoscaleOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesMigrateSqlContainerToAutoscaleResponse>,
      SqlResourcesMigrateSqlContainerToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesMigrateSqlContainerToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        options,
      },
      spec: migrateSqlContainerToAutoscaleOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesMigrateSqlContainerToAutoscaleResponse,
      OperationState<SqlResourcesMigrateSqlContainerToAutoscaleResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginMigrateSqlContainerToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesMigrateSqlContainerToAutoscaleOptionalParams,
  ): Promise<SqlResourcesMigrateSqlContainerToAutoscaleResponse> {
    const poller = await this.beginMigrateSqlContainerToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginMigrateSqlContainerToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesMigrateSqlContainerToManualThroughputOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesMigrateSqlContainerToManualThroughputResponse>,
      SqlResourcesMigrateSqlContainerToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesMigrateSqlContainerToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        options,
      },
      spec: migrateSqlContainerToManualThroughputOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesMigrateSqlContainerToManualThroughputResponse,
      OperationState<SqlResourcesMigrateSqlContainerToManualThroughputResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginMigrateSqlContainerToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesMigrateSqlContainerToManualThroughputOptionalParams,
  ): Promise<SqlResourcesMigrateSqlContainerToManualThroughputResponse> {
    const poller = await this.beginMigrateSqlContainerToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  private _listClientEncryptionKeys(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListClientEncryptionKeysOptionalParams,
  ): Promise<SqlResourcesListClientEncryptionKeysResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      listClientEncryptionKeysOperationSpec,
    );
  }

  /**
   * Gets the ClientEncryptionKey under an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
   * @param options The options parameters.
   */
  getClientEncryptionKey(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    clientEncryptionKeyName: string,
    options?: SqlResourcesGetClientEncryptionKeyOptionalParams,
  ): Promise<SqlResourcesGetClientEncryptionKeyResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        accountName,
        databaseName,
        clientEncryptionKeyName,
        options,
      },
      getClientEncryptionKeyOperationSpec,
    );
  }

  /**
   * Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the Azure
   * Powershell (instead of directly).
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
   * @param createUpdateClientEncryptionKeyParameters The parameters to provide for the client encryption
   *                                                  key.
   * @param options The options parameters.
   */
  async beginCreateUpdateClientEncryptionKey(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    clientEncryptionKeyName: string,
    createUpdateClientEncryptionKeyParameters: ClientEncryptionKeyCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateClientEncryptionKeyOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesCreateUpdateClientEncryptionKeyResponse>,
      SqlResourcesCreateUpdateClientEncryptionKeyResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesCreateUpdateClientEncryptionKeyResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        clientEncryptionKeyName,
        createUpdateClientEncryptionKeyParameters,
        options,
      },
      spec: createUpdateClientEncryptionKeyOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesCreateUpdateClientEncryptionKeyResponse,
      OperationState<SqlResourcesCreateUpdateClientEncryptionKeyResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the Azure
   * Powershell (instead of directly).
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
   * @param createUpdateClientEncryptionKeyParameters The parameters to provide for the client encryption
   *                                                  key.
   * @param options The options parameters.
   */
  async beginCreateUpdateClientEncryptionKeyAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    clientEncryptionKeyName: string,
    createUpdateClientEncryptionKeyParameters: ClientEncryptionKeyCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateClientEncryptionKeyOptionalParams,
  ): Promise<SqlResourcesCreateUpdateClientEncryptionKeyResponse> {
    const poller = await this.beginCreateUpdateClientEncryptionKey(
      resourceGroupName,
      accountName,
      databaseName,
      clientEncryptionKeyName,
      createUpdateClientEncryptionKeyParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  private _listSqlStoredProcedures(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlStoredProceduresOptionalParams,
  ): Promise<SqlResourcesListSqlStoredProceduresResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      listSqlStoredProceduresOperationSpec,
    );
  }

  /**
   * Gets the SQL storedProcedure under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param options The options parameters.
   */
  getSqlStoredProcedure(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    options?: SqlResourcesGetSqlStoredProcedureOptionalParams,
  ): Promise<SqlResourcesGetSqlStoredProcedureResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName,
        options,
      },
      getSqlStoredProcedureOperationSpec,
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL storedProcedure
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param createUpdateSqlStoredProcedureParameters The parameters to provide for the current SQL
   *                                                 storedProcedure.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlStoredProcedure(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    createUpdateSqlStoredProcedureParameters: SqlStoredProcedureCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlStoredProcedureOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesCreateUpdateSqlStoredProcedureResponse>,
      SqlResourcesCreateUpdateSqlStoredProcedureResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesCreateUpdateSqlStoredProcedureResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName,
        createUpdateSqlStoredProcedureParameters,
        options,
      },
      spec: createUpdateSqlStoredProcedureOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesCreateUpdateSqlStoredProcedureResponse,
      OperationState<SqlResourcesCreateUpdateSqlStoredProcedureResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL storedProcedure
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param createUpdateSqlStoredProcedureParameters The parameters to provide for the current SQL
   *                                                 storedProcedure.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlStoredProcedureAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    createUpdateSqlStoredProcedureParameters: SqlStoredProcedureCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlStoredProcedureOptionalParams,
  ): Promise<SqlResourcesCreateUpdateSqlStoredProcedureResponse> {
    const poller = await this.beginCreateUpdateSqlStoredProcedure(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      storedProcedureName,
      createUpdateSqlStoredProcedureParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL storedProcedure.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param options The options parameters.
   */
  async beginDeleteSqlStoredProcedure(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    options?: SqlResourcesDeleteSqlStoredProcedureOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesDeleteSqlStoredProcedureResponse>,
      SqlResourcesDeleteSqlStoredProcedureResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesDeleteSqlStoredProcedureResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName,
        options,
      },
      spec: deleteSqlStoredProcedureOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesDeleteSqlStoredProcedureResponse,
      OperationState<SqlResourcesDeleteSqlStoredProcedureResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL storedProcedure.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param options The options parameters.
   */
  async beginDeleteSqlStoredProcedureAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    options?: SqlResourcesDeleteSqlStoredProcedureOptionalParams,
  ): Promise<SqlResourcesDeleteSqlStoredProcedureResponse> {
    const poller = await this.beginDeleteSqlStoredProcedure(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      storedProcedureName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  private _listSqlUserDefinedFunctions(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlUserDefinedFunctionsOptionalParams,
  ): Promise<SqlResourcesListSqlUserDefinedFunctionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      listSqlUserDefinedFunctionsOperationSpec,
    );
  }

  /**
   * Gets the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param options The options parameters.
   */
  getSqlUserDefinedFunction(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    options?: SqlResourcesGetSqlUserDefinedFunctionOptionalParams,
  ): Promise<SqlResourcesGetSqlUserDefinedFunctionResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName,
        options,
      },
      getSqlUserDefinedFunctionOperationSpec,
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL userDefinedFunction
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param createUpdateSqlUserDefinedFunctionParameters The parameters to provide for the current SQL
   *                                                     userDefinedFunction.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlUserDefinedFunction(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    createUpdateSqlUserDefinedFunctionParameters: SqlUserDefinedFunctionCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlUserDefinedFunctionOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse>,
      SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName,
        createUpdateSqlUserDefinedFunctionParameters,
        options,
      },
      spec: createUpdateSqlUserDefinedFunctionOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse,
      OperationState<SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL userDefinedFunction
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param createUpdateSqlUserDefinedFunctionParameters The parameters to provide for the current SQL
   *                                                     userDefinedFunction.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlUserDefinedFunctionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    createUpdateSqlUserDefinedFunctionParameters: SqlUserDefinedFunctionCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlUserDefinedFunctionOptionalParams,
  ): Promise<SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse> {
    const poller = await this.beginCreateUpdateSqlUserDefinedFunction(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      userDefinedFunctionName,
      createUpdateSqlUserDefinedFunctionParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL userDefinedFunction.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param options The options parameters.
   */
  async beginDeleteSqlUserDefinedFunction(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    options?: SqlResourcesDeleteSqlUserDefinedFunctionOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesDeleteSqlUserDefinedFunctionResponse>,
      SqlResourcesDeleteSqlUserDefinedFunctionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesDeleteSqlUserDefinedFunctionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName,
        options,
      },
      spec: deleteSqlUserDefinedFunctionOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesDeleteSqlUserDefinedFunctionResponse,
      OperationState<SqlResourcesDeleteSqlUserDefinedFunctionResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL userDefinedFunction.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param options The options parameters.
   */
  async beginDeleteSqlUserDefinedFunctionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    options?: SqlResourcesDeleteSqlUserDefinedFunctionOptionalParams,
  ): Promise<SqlResourcesDeleteSqlUserDefinedFunctionResponse> {
    const poller = await this.beginDeleteSqlUserDefinedFunction(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      userDefinedFunctionName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the SQL trigger under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  private _listSqlTriggers(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlTriggersOptionalParams,
  ): Promise<SqlResourcesListSqlTriggersResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      listSqlTriggersOperationSpec,
    );
  }

  /**
   * Gets the SQL trigger under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param options The options parameters.
   */
  getSqlTrigger(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    options?: SqlResourcesGetSqlTriggerOptionalParams,
  ): Promise<SqlResourcesGetSqlTriggerResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName,
        options,
      },
      getSqlTriggerOperationSpec,
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL trigger
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param createUpdateSqlTriggerParameters The parameters to provide for the current SQL trigger.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlTrigger(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    createUpdateSqlTriggerParameters: SqlTriggerCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlTriggerOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesCreateUpdateSqlTriggerResponse>,
      SqlResourcesCreateUpdateSqlTriggerResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesCreateUpdateSqlTriggerResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName,
        createUpdateSqlTriggerParameters,
        options,
      },
      spec: createUpdateSqlTriggerOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesCreateUpdateSqlTriggerResponse,
      OperationState<SqlResourcesCreateUpdateSqlTriggerResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL trigger
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param createUpdateSqlTriggerParameters The parameters to provide for the current SQL trigger.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlTriggerAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    createUpdateSqlTriggerParameters: SqlTriggerCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlTriggerOptionalParams,
  ): Promise<SqlResourcesCreateUpdateSqlTriggerResponse> {
    const poller = await this.beginCreateUpdateSqlTrigger(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      triggerName,
      createUpdateSqlTriggerParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL trigger.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param options The options parameters.
   */
  async beginDeleteSqlTrigger(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    options?: SqlResourcesDeleteSqlTriggerOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesDeleteSqlTriggerResponse>,
      SqlResourcesDeleteSqlTriggerResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesDeleteSqlTriggerResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName,
        options,
      },
      spec: deleteSqlTriggerOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesDeleteSqlTriggerResponse,
      OperationState<SqlResourcesDeleteSqlTriggerResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL trigger.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param options The options parameters.
   */
  async beginDeleteSqlTriggerAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    options?: SqlResourcesDeleteSqlTriggerOptionalParams,
  ): Promise<SqlResourcesDeleteSqlTriggerResponse> {
    const poller = await this.beginDeleteSqlTrigger(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      triggerName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB SQL Role Definition with the given Id.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  getSqlRoleDefinition(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesGetSqlRoleDefinitionOptionalParams,
  ): Promise<SqlResourcesGetSqlRoleDefinitionResponse> {
    return this.client.sendOperationRequest(
      { roleDefinitionId, resourceGroupName, accountName, options },
      getSqlRoleDefinitionOperationSpec,
    );
  }

  /**
   * Creates or updates an Azure Cosmos DB SQL Role Definition.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateSqlRoleDefinitionParameters The properties required to create or update a Role
   *                                                Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlRoleDefinition(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateSqlRoleDefinitionParameters: SqlRoleDefinitionCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlRoleDefinitionOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesCreateUpdateSqlRoleDefinitionResponse>,
      SqlResourcesCreateUpdateSqlRoleDefinitionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesCreateUpdateSqlRoleDefinitionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        roleDefinitionId,
        resourceGroupName,
        accountName,
        createUpdateSqlRoleDefinitionParameters,
        options,
      },
      spec: createUpdateSqlRoleDefinitionOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesCreateUpdateSqlRoleDefinitionResponse,
      OperationState<SqlResourcesCreateUpdateSqlRoleDefinitionResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates or updates an Azure Cosmos DB SQL Role Definition.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateSqlRoleDefinitionParameters The properties required to create or update a Role
   *                                                Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlRoleDefinitionAndWait(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateSqlRoleDefinitionParameters: SqlRoleDefinitionCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlRoleDefinitionOptionalParams,
  ): Promise<SqlResourcesCreateUpdateSqlRoleDefinitionResponse> {
    const poller = await this.beginCreateUpdateSqlRoleDefinition(
      roleDefinitionId,
      resourceGroupName,
      accountName,
      createUpdateSqlRoleDefinitionParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL Role Definition.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteSqlRoleDefinition(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesDeleteSqlRoleDefinitionOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { roleDefinitionId, resourceGroupName, accountName, options },
      spec: deleteSqlRoleDefinitionOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL Role Definition.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteSqlRoleDefinitionAndWait(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesDeleteSqlRoleDefinitionOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteSqlRoleDefinition(
      roleDefinitionId,
      resourceGroupName,
      accountName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the list of all Azure Cosmos DB SQL Role Definitions.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listSqlRoleDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleDefinitionsOptionalParams,
  ): Promise<SqlResourcesListSqlRoleDefinitionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listSqlRoleDefinitionsOperationSpec,
    );
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB SQL Role Assignment with the given Id.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  getSqlRoleAssignment(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesGetSqlRoleAssignmentOptionalParams,
  ): Promise<SqlResourcesGetSqlRoleAssignmentResponse> {
    return this.client.sendOperationRequest(
      { roleAssignmentId, resourceGroupName, accountName, options },
      getSqlRoleAssignmentOperationSpec,
    );
  }

  /**
   * Creates or updates an Azure Cosmos DB SQL Role Assignment.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateSqlRoleAssignmentParameters The properties required to create or update a Role
   *                                                Assignment.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlRoleAssignment(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateSqlRoleAssignmentParameters: SqlRoleAssignmentCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlRoleAssignmentOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesCreateUpdateSqlRoleAssignmentResponse>,
      SqlResourcesCreateUpdateSqlRoleAssignmentResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesCreateUpdateSqlRoleAssignmentResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        roleAssignmentId,
        resourceGroupName,
        accountName,
        createUpdateSqlRoleAssignmentParameters,
        options,
      },
      spec: createUpdateSqlRoleAssignmentOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesCreateUpdateSqlRoleAssignmentResponse,
      OperationState<SqlResourcesCreateUpdateSqlRoleAssignmentResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates or updates an Azure Cosmos DB SQL Role Assignment.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateSqlRoleAssignmentParameters The properties required to create or update a Role
   *                                                Assignment.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlRoleAssignmentAndWait(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateSqlRoleAssignmentParameters: SqlRoleAssignmentCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlRoleAssignmentOptionalParams,
  ): Promise<SqlResourcesCreateUpdateSqlRoleAssignmentResponse> {
    const poller = await this.beginCreateUpdateSqlRoleAssignment(
      roleAssignmentId,
      resourceGroupName,
      accountName,
      createUpdateSqlRoleAssignmentParameters,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL Role Assignment.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteSqlRoleAssignment(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesDeleteSqlRoleAssignmentOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: { roleAssignmentId, resourceGroupName, accountName, options },
      spec: deleteSqlRoleAssignmentOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL Role Assignment.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteSqlRoleAssignmentAndWait(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesDeleteSqlRoleAssignmentOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDeleteSqlRoleAssignment(
      roleAssignmentId,
      resourceGroupName,
      accountName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the list of all Azure Cosmos DB SQL Role Assignments.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listSqlRoleAssignments(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleAssignmentsOptionalParams,
  ): Promise<SqlResourcesListSqlRoleAssignmentsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listSqlRoleAssignmentsOperationSpec,
    );
  }

  /**
   * Retrieves continuous backup information for a container resource.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformation(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    location: ContinuousBackupRestoreLocation,
    options?: SqlResourcesRetrieveContinuousBackupInformationOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<SqlResourcesRetrieveContinuousBackupInformationResponse>,
      SqlResourcesRetrieveContinuousBackupInformationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<SqlResourcesRetrieveContinuousBackupInformationResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        location,
        options,
      },
      spec: retrieveContinuousBackupInformationOperationSpec,
    });
    const poller = await createHttpPoller<
      SqlResourcesRetrieveContinuousBackupInformationResponse,
      OperationState<SqlResourcesRetrieveContinuousBackupInformationResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieves continuous backup information for a container resource.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformationAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    location: ContinuousBackupRestoreLocation,
    options?: SqlResourcesRetrieveContinuousBackupInformationOptionalParams,
  ): Promise<SqlResourcesRetrieveContinuousBackupInformationResponse> {
    const poller = await this.beginRetrieveContinuousBackupInformation(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      location,
      options,
    );
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listSqlDatabasesOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlDatabaseListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSqlDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlDatabaseGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateSqlDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlDatabaseGetResults,
    },
    201: {
      bodyMapper: Mappers.SqlDatabaseGetResults,
    },
    202: {
      bodyMapper: Mappers.SqlDatabaseGetResults,
    },
    204: {
      bodyMapper: Mappers.SqlDatabaseGetResults,
    },
  },
  requestBody: Parameters.createUpdateSqlDatabaseParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteSqlDatabaseOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.SqlResourcesDeleteSqlDatabaseHeaders,
    },
    201: {
      headersMapper: Mappers.SqlResourcesDeleteSqlDatabaseHeaders,
    },
    202: {
      headersMapper: Mappers.SqlResourcesDeleteSqlDatabaseHeaders,
    },
    204: {
      headersMapper: Mappers.SqlResourcesDeleteSqlDatabaseHeaders,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  serializer,
};
const getSqlDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const updateSqlDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const migrateSqlDatabaseToAutoscaleOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const migrateSqlDatabaseToManualThroughputOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const listSqlContainersOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlContainerListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSqlContainerOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlContainerGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateSqlContainerOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlContainerGetResults,
    },
    201: {
      bodyMapper: Mappers.SqlContainerGetResults,
    },
    202: {
      bodyMapper: Mappers.SqlContainerGetResults,
    },
    204: {
      bodyMapper: Mappers.SqlContainerGetResults,
    },
  },
  requestBody: Parameters.createUpdateSqlContainerParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteSqlContainerOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.SqlResourcesDeleteSqlContainerHeaders,
    },
    201: {
      headersMapper: Mappers.SqlResourcesDeleteSqlContainerHeaders,
    },
    202: {
      headersMapper: Mappers.SqlResourcesDeleteSqlContainerHeaders,
    },
    204: {
      headersMapper: Mappers.SqlResourcesDeleteSqlContainerHeaders,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  serializer,
};
const getSqlContainerThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const updateSqlContainerThroughputOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const migrateSqlContainerToAutoscaleOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/migrateToAutoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const migrateSqlContainerToManualThroughputOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/migrateToManualThroughput",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      201: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      202: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      204: {
        bodyMapper: Mappers.ThroughputSettingsGetResults,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.containerName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const listClientEncryptionKeysOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClientEncryptionKeysListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getClientEncryptionKeyOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys/{clientEncryptionKeyName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.clientEncryptionKeyName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateClientEncryptionKeyOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys/{clientEncryptionKeyName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults,
    },
    201: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults,
    },
    202: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults,
    },
    204: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults,
    },
  },
  requestBody: Parameters.createUpdateClientEncryptionKeyParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.clientEncryptionKeyName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const listSqlStoredProceduresOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlStoredProcedureListResult,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSqlStoredProcedureOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.storedProcedureName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateSqlStoredProcedureOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults,
    },
    201: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults,
    },
    202: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults,
    },
    204: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults,
    },
  },
  requestBody: Parameters.createUpdateSqlStoredProcedureParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.storedProcedureName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteSqlStoredProcedureOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.SqlResourcesDeleteSqlStoredProcedureHeaders,
    },
    201: {
      headersMapper: Mappers.SqlResourcesDeleteSqlStoredProcedureHeaders,
    },
    202: {
      headersMapper: Mappers.SqlResourcesDeleteSqlStoredProcedureHeaders,
    },
    204: {
      headersMapper: Mappers.SqlResourcesDeleteSqlStoredProcedureHeaders,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.storedProcedureName,
  ],
  serializer,
};
const listSqlUserDefinedFunctionsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlUserDefinedFunctionListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSqlUserDefinedFunctionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlUserDefinedFunctionGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.userDefinedFunctionName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateSqlUserDefinedFunctionOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
    httpMethod: "PUT",
    responses: {
      200: {
        bodyMapper: Mappers.SqlUserDefinedFunctionGetResults,
      },
      201: {
        bodyMapper: Mappers.SqlUserDefinedFunctionGetResults,
      },
      202: {
        bodyMapper: Mappers.SqlUserDefinedFunctionGetResults,
      },
      204: {
        bodyMapper: Mappers.SqlUserDefinedFunctionGetResults,
      },
    },
    requestBody: Parameters.createUpdateSqlUserDefinedFunctionParameters,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.containerName,
      Parameters.userDefinedFunctionName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
  };
const deleteSqlUserDefinedFunctionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.SqlResourcesDeleteSqlUserDefinedFunctionHeaders,
    },
    201: {
      headersMapper: Mappers.SqlResourcesDeleteSqlUserDefinedFunctionHeaders,
    },
    202: {
      headersMapper: Mappers.SqlResourcesDeleteSqlUserDefinedFunctionHeaders,
    },
    204: {
      headersMapper: Mappers.SqlResourcesDeleteSqlUserDefinedFunctionHeaders,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.userDefinedFunctionName,
  ],
  serializer,
};
const listSqlTriggersOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlTriggerListResult,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSqlTriggerOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlTriggerGetResults,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.triggerName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateSqlTriggerOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlTriggerGetResults,
    },
    201: {
      bodyMapper: Mappers.SqlTriggerGetResults,
    },
    202: {
      bodyMapper: Mappers.SqlTriggerGetResults,
    },
    204: {
      bodyMapper: Mappers.SqlTriggerGetResults,
    },
  },
  requestBody: Parameters.createUpdateSqlTriggerParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.triggerName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteSqlTriggerOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
  httpMethod: "DELETE",
  responses: {
    200: {
      headersMapper: Mappers.SqlResourcesDeleteSqlTriggerHeaders,
    },
    201: {
      headersMapper: Mappers.SqlResourcesDeleteSqlTriggerHeaders,
    },
    202: {
      headersMapper: Mappers.SqlResourcesDeleteSqlTriggerHeaders,
    },
    204: {
      headersMapper: Mappers.SqlResourcesDeleteSqlTriggerHeaders,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.triggerName,
  ],
  serializer,
};
const getSqlRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleDefinitionId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateSqlRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults,
    },
    201: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults,
    },
    202: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults,
    },
    204: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.createUpdateSqlRoleDefinitionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleDefinitionId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteSqlRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleDefinitionId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listSqlRoleDefinitionsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleDefinitionListResult,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const getSqlRoleAssignmentOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleAssignmentId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createUpdateSqlRoleAssignmentOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults,
    },
    201: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults,
    },
    202: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults,
    },
    204: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  requestBody: Parameters.createUpdateSqlRoleAssignmentParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleAssignmentId,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteSqlRoleAssignmentOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleAssignmentId,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listSqlRoleAssignmentsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleAssignmentListResult,
    },
    default: {
      bodyMapper: Mappers.CloudError,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const retrieveContinuousBackupInformationOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/retrieveContinuousBackupInformation",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.BackupInformation,
      },
      201: {
        bodyMapper: Mappers.BackupInformation,
      },
      202: {
        bodyMapper: Mappers.BackupInformation,
      },
      204: {
        bodyMapper: Mappers.BackupInformation,
      },
      default: {
        bodyMapper: Mappers.CloudError,
      },
    },
    requestBody: Parameters.location,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.subscriptionId,
      Parameters.resourceGroupName,
      Parameters.accountName,
      Parameters.databaseName,
      Parameters.containerName,
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer,
  };
