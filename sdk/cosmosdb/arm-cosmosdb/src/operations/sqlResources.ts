/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { SqlResources } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { CosmosDBManagementClient } from "../cosmosDBManagementClient";
import { PollerLike, PollOperationState, LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
import {
  SqlDatabaseGetResults,
  SqlResourcesListSqlDatabasesOptionalParams,
  ClientEncryptionKeyGetResults,
  SqlResourcesListClientEncryptionKeysOptionalParams,
  SqlContainerGetResults,
  SqlResourcesListSqlContainersOptionalParams,
  SqlStoredProcedureGetResults,
  SqlResourcesListSqlStoredProceduresOptionalParams,
  SqlUserDefinedFunctionGetResults,
  SqlResourcesListSqlUserDefinedFunctionsOptionalParams,
  SqlTriggerGetResults,
  SqlResourcesListSqlTriggersOptionalParams,
  SqlRoleDefinitionGetResults,
  SqlResourcesListSqlRoleDefinitionsOptionalParams,
  SqlRoleAssignmentGetResults,
  SqlResourcesListSqlRoleAssignmentsOptionalParams,
  SqlResourcesListSqlDatabasesResponse,
  SqlResourcesGetSqlDatabaseOptionalParams,
  SqlResourcesGetSqlDatabaseResponse,
  SqlDatabaseCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlDatabaseOptionalParams,
  SqlResourcesCreateUpdateSqlDatabaseResponse,
  SqlResourcesDeleteSqlDatabaseOptionalParams,
  SqlResourcesGetSqlDatabaseThroughputOptionalParams,
  SqlResourcesGetSqlDatabaseThroughputResponse,
  ThroughputSettingsUpdateParameters,
  SqlResourcesUpdateSqlDatabaseThroughputOptionalParams,
  SqlResourcesUpdateSqlDatabaseThroughputResponse,
  SqlResourcesMigrateSqlDatabaseToAutoscaleOptionalParams,
  SqlResourcesMigrateSqlDatabaseToAutoscaleResponse,
  SqlResourcesMigrateSqlDatabaseToManualThroughputOptionalParams,
  SqlResourcesMigrateSqlDatabaseToManualThroughputResponse,
  SqlResourcesListClientEncryptionKeysResponse,
  SqlResourcesGetClientEncryptionKeyOptionalParams,
  SqlResourcesGetClientEncryptionKeyResponse,
  ClientEncryptionKeyCreateUpdateParameters,
  SqlResourcesCreateUpdateClientEncryptionKeyOptionalParams,
  SqlResourcesCreateUpdateClientEncryptionKeyResponse,
  SqlResourcesListSqlContainersResponse,
  SqlResourcesGetSqlContainerOptionalParams,
  SqlResourcesGetSqlContainerResponse,
  SqlContainerCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlContainerOptionalParams,
  SqlResourcesCreateUpdateSqlContainerResponse,
  SqlResourcesDeleteSqlContainerOptionalParams,
  MergeParameters,
  SqlResourcesListSqlContainerPartitionMergeOptionalParams,
  SqlResourcesListSqlContainerPartitionMergeResponse,
  SqlResourcesGetSqlContainerThroughputOptionalParams,
  SqlResourcesGetSqlContainerThroughputResponse,
  SqlResourcesUpdateSqlContainerThroughputOptionalParams,
  SqlResourcesUpdateSqlContainerThroughputResponse,
  SqlResourcesMigrateSqlContainerToAutoscaleOptionalParams,
  SqlResourcesMigrateSqlContainerToAutoscaleResponse,
  SqlResourcesMigrateSqlContainerToManualThroughputOptionalParams,
  SqlResourcesMigrateSqlContainerToManualThroughputResponse,
  RetrieveThroughputParameters,
  SqlResourcesSqlDatabaseRetrieveThroughputDistributionOptionalParams,
  SqlResourcesSqlDatabaseRetrieveThroughputDistributionResponse,
  RedistributeThroughputParameters,
  SqlResourcesSqlDatabaseRedistributeThroughputOptionalParams,
  SqlResourcesSqlDatabaseRedistributeThroughputResponse,
  SqlResourcesSqlContainerRetrieveThroughputDistributionOptionalParams,
  SqlResourcesSqlContainerRetrieveThroughputDistributionResponse,
  SqlResourcesSqlContainerRedistributeThroughputOptionalParams,
  SqlResourcesSqlContainerRedistributeThroughputResponse,
  SqlResourcesListSqlStoredProceduresResponse,
  SqlResourcesGetSqlStoredProcedureOptionalParams,
  SqlResourcesGetSqlStoredProcedureResponse,
  SqlStoredProcedureCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlStoredProcedureOptionalParams,
  SqlResourcesCreateUpdateSqlStoredProcedureResponse,
  SqlResourcesDeleteSqlStoredProcedureOptionalParams,
  SqlResourcesListSqlUserDefinedFunctionsResponse,
  SqlResourcesGetSqlUserDefinedFunctionOptionalParams,
  SqlResourcesGetSqlUserDefinedFunctionResponse,
  SqlUserDefinedFunctionCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlUserDefinedFunctionOptionalParams,
  SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse,
  SqlResourcesDeleteSqlUserDefinedFunctionOptionalParams,
  SqlResourcesListSqlTriggersResponse,
  SqlResourcesGetSqlTriggerOptionalParams,
  SqlResourcesGetSqlTriggerResponse,
  SqlTriggerCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlTriggerOptionalParams,
  SqlResourcesCreateUpdateSqlTriggerResponse,
  SqlResourcesDeleteSqlTriggerOptionalParams,
  SqlResourcesGetSqlRoleDefinitionOptionalParams,
  SqlResourcesGetSqlRoleDefinitionResponse,
  SqlRoleDefinitionCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlRoleDefinitionOptionalParams,
  SqlResourcesCreateUpdateSqlRoleDefinitionResponse,
  SqlResourcesDeleteSqlRoleDefinitionOptionalParams,
  SqlResourcesListSqlRoleDefinitionsResponse,
  SqlResourcesGetSqlRoleAssignmentOptionalParams,
  SqlResourcesGetSqlRoleAssignmentResponse,
  SqlRoleAssignmentCreateUpdateParameters,
  SqlResourcesCreateUpdateSqlRoleAssignmentOptionalParams,
  SqlResourcesCreateUpdateSqlRoleAssignmentResponse,
  SqlResourcesDeleteSqlRoleAssignmentOptionalParams,
  SqlResourcesListSqlRoleAssignmentsResponse,
  ContinuousBackupRestoreLocation,
  SqlResourcesRetrieveContinuousBackupInformationOptionalParams,
  SqlResourcesRetrieveContinuousBackupInformationResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing SqlResources operations. */
export class SqlResourcesImpl implements SqlResources {
  private readonly client: CosmosDBManagementClient;

  /**
   * Initialize a new instance of the class SqlResources class.
   * @param client Reference to the service client
   */
  constructor(client: CosmosDBManagementClient) {
    this.client = client;
  }

  /**
   * Lists the SQL databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listSqlDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlDatabasesOptionalParams
  ): PagedAsyncIterableIterator<SqlDatabaseGetResults> {
    const iter = this.listSqlDatabasesPagingAll(
      resourceGroupName,
      accountName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listSqlDatabasesPagingPage(
          resourceGroupName,
          accountName,
          options
        );
      }
    };
  }

  private async *listSqlDatabasesPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlDatabasesOptionalParams
  ): AsyncIterableIterator<SqlDatabaseGetResults[]> {
    let result = await this._listSqlDatabases(
      resourceGroupName,
      accountName,
      options
    );
    yield result.value || [];
  }

  private async *listSqlDatabasesPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlDatabasesOptionalParams
  ): AsyncIterableIterator<SqlDatabaseGetResults> {
    for await (const page of this.listSqlDatabasesPagingPage(
      resourceGroupName,
      accountName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  public listClientEncryptionKeys(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListClientEncryptionKeysOptionalParams
  ): PagedAsyncIterableIterator<ClientEncryptionKeyGetResults> {
    const iter = this.listClientEncryptionKeysPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listClientEncryptionKeysPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          options
        );
      }
    };
  }

  private async *listClientEncryptionKeysPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListClientEncryptionKeysOptionalParams
  ): AsyncIterableIterator<ClientEncryptionKeyGetResults[]> {
    let result = await this._listClientEncryptionKeys(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    yield result.value || [];
  }

  private async *listClientEncryptionKeysPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListClientEncryptionKeysOptionalParams
  ): AsyncIterableIterator<ClientEncryptionKeyGetResults> {
    for await (const page of this.listClientEncryptionKeysPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL container under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  public listSqlContainers(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListSqlContainersOptionalParams
  ): PagedAsyncIterableIterator<SqlContainerGetResults> {
    const iter = this.listSqlContainersPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listSqlContainersPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          options
        );
      }
    };
  }

  private async *listSqlContainersPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListSqlContainersOptionalParams
  ): AsyncIterableIterator<SqlContainerGetResults[]> {
    let result = await this._listSqlContainers(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    yield result.value || [];
  }

  private async *listSqlContainersPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListSqlContainersOptionalParams
  ): AsyncIterableIterator<SqlContainerGetResults> {
    for await (const page of this.listSqlContainersPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  public listSqlStoredProcedures(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlStoredProceduresOptionalParams
  ): PagedAsyncIterableIterator<SqlStoredProcedureGetResults> {
    const iter = this.listSqlStoredProceduresPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listSqlStoredProceduresPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          containerName,
          options
        );
      }
    };
  }

  private async *listSqlStoredProceduresPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlStoredProceduresOptionalParams
  ): AsyncIterableIterator<SqlStoredProcedureGetResults[]> {
    let result = await this._listSqlStoredProcedures(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    yield result.value || [];
  }

  private async *listSqlStoredProceduresPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlStoredProceduresOptionalParams
  ): AsyncIterableIterator<SqlStoredProcedureGetResults> {
    for await (const page of this.listSqlStoredProceduresPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  public listSqlUserDefinedFunctions(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlUserDefinedFunctionsOptionalParams
  ): PagedAsyncIterableIterator<SqlUserDefinedFunctionGetResults> {
    const iter = this.listSqlUserDefinedFunctionsPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listSqlUserDefinedFunctionsPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          containerName,
          options
        );
      }
    };
  }

  private async *listSqlUserDefinedFunctionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlUserDefinedFunctionsOptionalParams
  ): AsyncIterableIterator<SqlUserDefinedFunctionGetResults[]> {
    let result = await this._listSqlUserDefinedFunctions(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    yield result.value || [];
  }

  private async *listSqlUserDefinedFunctionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlUserDefinedFunctionsOptionalParams
  ): AsyncIterableIterator<SqlUserDefinedFunctionGetResults> {
    for await (const page of this.listSqlUserDefinedFunctionsPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL trigger under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  public listSqlTriggers(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlTriggersOptionalParams
  ): PagedAsyncIterableIterator<SqlTriggerGetResults> {
    const iter = this.listSqlTriggersPagingAll(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listSqlTriggersPagingPage(
          resourceGroupName,
          accountName,
          databaseName,
          containerName,
          options
        );
      }
    };
  }

  private async *listSqlTriggersPagingPage(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlTriggersOptionalParams
  ): AsyncIterableIterator<SqlTriggerGetResults[]> {
    let result = await this._listSqlTriggers(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    yield result.value || [];
  }

  private async *listSqlTriggersPagingAll(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlTriggersOptionalParams
  ): AsyncIterableIterator<SqlTriggerGetResults> {
    for await (const page of this.listSqlTriggersPagingPage(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves the list of all Azure Cosmos DB SQL Role Definitions.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listSqlRoleDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleDefinitionsOptionalParams
  ): PagedAsyncIterableIterator<SqlRoleDefinitionGetResults> {
    const iter = this.listSqlRoleDefinitionsPagingAll(
      resourceGroupName,
      accountName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listSqlRoleDefinitionsPagingPage(
          resourceGroupName,
          accountName,
          options
        );
      }
    };
  }

  private async *listSqlRoleDefinitionsPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleDefinitionsOptionalParams
  ): AsyncIterableIterator<SqlRoleDefinitionGetResults[]> {
    let result = await this._listSqlRoleDefinitions(
      resourceGroupName,
      accountName,
      options
    );
    yield result.value || [];
  }

  private async *listSqlRoleDefinitionsPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleDefinitionsOptionalParams
  ): AsyncIterableIterator<SqlRoleDefinitionGetResults> {
    for await (const page of this.listSqlRoleDefinitionsPagingPage(
      resourceGroupName,
      accountName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves the list of all Azure Cosmos DB SQL Role Assignments.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  public listSqlRoleAssignments(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleAssignmentsOptionalParams
  ): PagedAsyncIterableIterator<SqlRoleAssignmentGetResults> {
    const iter = this.listSqlRoleAssignmentsPagingAll(
      resourceGroupName,
      accountName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listSqlRoleAssignmentsPagingPage(
          resourceGroupName,
          accountName,
          options
        );
      }
    };
  }

  private async *listSqlRoleAssignmentsPagingPage(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleAssignmentsOptionalParams
  ): AsyncIterableIterator<SqlRoleAssignmentGetResults[]> {
    let result = await this._listSqlRoleAssignments(
      resourceGroupName,
      accountName,
      options
    );
    yield result.value || [];
  }

  private async *listSqlRoleAssignmentsPagingAll(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleAssignmentsOptionalParams
  ): AsyncIterableIterator<SqlRoleAssignmentGetResults> {
    for await (const page of this.listSqlRoleAssignmentsPagingPage(
      resourceGroupName,
      accountName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Lists the SQL databases under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listSqlDatabases(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlDatabasesOptionalParams
  ): Promise<SqlResourcesListSqlDatabasesResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listSqlDatabasesOperationSpec
    );
  }

  /**
   * Gets the SQL database under an existing Azure Cosmos DB database account with the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getSqlDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesGetSqlDatabaseOptionalParams
  ): Promise<SqlResourcesGetSqlDatabaseResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getSqlDatabaseOperationSpec
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateSqlDatabaseParameters The parameters to provide for the current SQL database.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateSqlDatabaseParameters: SqlDatabaseCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlDatabaseOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesCreateUpdateSqlDatabaseResponse>,
      SqlResourcesCreateUpdateSqlDatabaseResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesCreateUpdateSqlDatabaseResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        createUpdateSqlDatabaseParameters,
        options
      },
      createUpdateSqlDatabaseOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param createUpdateSqlDatabaseParameters The parameters to provide for the current SQL database.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    createUpdateSqlDatabaseParameters: SqlDatabaseCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlDatabaseOptionalParams
  ): Promise<SqlResourcesCreateUpdateSqlDatabaseResponse> {
    const poller = await this.beginCreateUpdateSqlDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      createUpdateSqlDatabaseParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteSqlDatabase(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesDeleteSqlDatabaseOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      deleteSqlDatabaseOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginDeleteSqlDatabaseAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesDeleteSqlDatabaseOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteSqlDatabase(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the SQL database under an existing Azure Cosmos DB database account with
   * the provided name.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  getSqlDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesGetSqlDatabaseThroughputOptionalParams
  ): Promise<SqlResourcesGetSqlDatabaseThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      getSqlDatabaseThroughputOperationSpec
    );
  }

  /**
   * Update RUs per second of an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
   *                                   SQL database.
   * @param options The options parameters.
   */
  async beginUpdateSqlDatabaseThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: SqlResourcesUpdateSqlDatabaseThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesUpdateSqlDatabaseThroughputResponse>,
      SqlResourcesUpdateSqlDatabaseThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesUpdateSqlDatabaseThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        updateThroughputParameters,
        options
      },
      updateSqlDatabaseThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update RUs per second of an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
   *                                   SQL database.
   * @param options The options parameters.
   */
  async beginUpdateSqlDatabaseThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: SqlResourcesUpdateSqlDatabaseThroughputOptionalParams
  ): Promise<SqlResourcesUpdateSqlDatabaseThroughputResponse> {
    const poller = await this.beginUpdateSqlDatabaseThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      updateThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateSqlDatabaseToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesMigrateSqlDatabaseToAutoscaleOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesMigrateSqlDatabaseToAutoscaleResponse>,
      SqlResourcesMigrateSqlDatabaseToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesMigrateSqlDatabaseToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      migrateSqlDatabaseToAutoscaleOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB SQL database from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateSqlDatabaseToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesMigrateSqlDatabaseToAutoscaleOptionalParams
  ): Promise<SqlResourcesMigrateSqlDatabaseToAutoscaleResponse> {
    const poller = await this.beginMigrateSqlDatabaseToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateSqlDatabaseToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesMigrateSqlDatabaseToManualThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        SqlResourcesMigrateSqlDatabaseToManualThroughputResponse
      >,
      SqlResourcesMigrateSqlDatabaseToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesMigrateSqlDatabaseToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, options },
      migrateSqlDatabaseToManualThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB SQL database from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  async beginMigrateSqlDatabaseToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesMigrateSqlDatabaseToManualThroughputOptionalParams
  ): Promise<SqlResourcesMigrateSqlDatabaseToManualThroughputResponse> {
    const poller = await this.beginMigrateSqlDatabaseToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the ClientEncryptionKeys under an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  private _listClientEncryptionKeys(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListClientEncryptionKeysOptionalParams
  ): Promise<SqlResourcesListClientEncryptionKeysResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      listClientEncryptionKeysOperationSpec
    );
  }

  /**
   * Gets the ClientEncryptionKey under an existing Azure Cosmos DB SQL database.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
   * @param options The options parameters.
   */
  getClientEncryptionKey(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    clientEncryptionKeyName: string,
    options?: SqlResourcesGetClientEncryptionKeyOptionalParams
  ): Promise<SqlResourcesGetClientEncryptionKeyResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        accountName,
        databaseName,
        clientEncryptionKeyName,
        options
      },
      getClientEncryptionKeyOperationSpec
    );
  }

  /**
   * Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the Azure
   * Powershell (instead of directly).
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
   * @param createUpdateClientEncryptionKeyParameters The parameters to provide for the client encryption
   *                                                  key.
   * @param options The options parameters.
   */
  async beginCreateUpdateClientEncryptionKey(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    clientEncryptionKeyName: string,
    createUpdateClientEncryptionKeyParameters: ClientEncryptionKeyCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateClientEncryptionKeyOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesCreateUpdateClientEncryptionKeyResponse>,
      SqlResourcesCreateUpdateClientEncryptionKeyResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesCreateUpdateClientEncryptionKeyResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        clientEncryptionKeyName,
        createUpdateClientEncryptionKeyParameters,
        options
      },
      createUpdateClientEncryptionKeyOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update a ClientEncryptionKey. This API is meant to be invoked via tools such as the Azure
   * Powershell (instead of directly).
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param clientEncryptionKeyName Cosmos DB ClientEncryptionKey name.
   * @param createUpdateClientEncryptionKeyParameters The parameters to provide for the client encryption
   *                                                  key.
   * @param options The options parameters.
   */
  async beginCreateUpdateClientEncryptionKeyAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    clientEncryptionKeyName: string,
    createUpdateClientEncryptionKeyParameters: ClientEncryptionKeyCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateClientEncryptionKeyOptionalParams
  ): Promise<SqlResourcesCreateUpdateClientEncryptionKeyResponse> {
    const poller = await this.beginCreateUpdateClientEncryptionKey(
      resourceGroupName,
      accountName,
      databaseName,
      clientEncryptionKeyName,
      createUpdateClientEncryptionKeyParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the SQL container under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param options The options parameters.
   */
  private _listSqlContainers(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    options?: SqlResourcesListSqlContainersOptionalParams
  ): Promise<SqlResourcesListSqlContainersResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, options },
      listSqlContainersOperationSpec
    );
  }

  /**
   * Gets the SQL container under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  getSqlContainer(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesGetSqlContainerOptionalParams
  ): Promise<SqlResourcesGetSqlContainerResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      getSqlContainerOperationSpec
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param createUpdateSqlContainerParameters The parameters to provide for the current SQL container.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlContainer(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    createUpdateSqlContainerParameters: SqlContainerCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlContainerOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesCreateUpdateSqlContainerResponse>,
      SqlResourcesCreateUpdateSqlContainerResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesCreateUpdateSqlContainerResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        createUpdateSqlContainerParameters,
        options
      },
      createUpdateSqlContainerOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param createUpdateSqlContainerParameters The parameters to provide for the current SQL container.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlContainerAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    createUpdateSqlContainerParameters: SqlContainerCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlContainerOptionalParams
  ): Promise<SqlResourcesCreateUpdateSqlContainerResponse> {
    const poller = await this.beginCreateUpdateSqlContainer(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      createUpdateSqlContainerParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL container.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginDeleteSqlContainer(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesDeleteSqlContainerOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, containerName, options },
      deleteSqlContainerOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL container.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginDeleteSqlContainerAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesDeleteSqlContainerOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteSqlContainer(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Merges the partitions of a SQL Container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param mergeParameters The parameters for the merge operation.
   * @param options The options parameters.
   */
  async beginListSqlContainerPartitionMerge(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    mergeParameters: MergeParameters,
    options?: SqlResourcesListSqlContainerPartitionMergeOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesListSqlContainerPartitionMergeResponse>,
      SqlResourcesListSqlContainerPartitionMergeResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesListSqlContainerPartitionMergeResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        mergeParameters,
        options
      },
      listSqlContainerPartitionMergeOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Merges the partitions of a SQL Container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param mergeParameters The parameters for the merge operation.
   * @param options The options parameters.
   */
  async beginListSqlContainerPartitionMergeAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    mergeParameters: MergeParameters,
    options?: SqlResourcesListSqlContainerPartitionMergeOptionalParams
  ): Promise<SqlResourcesListSqlContainerPartitionMergeResponse> {
    const poller = await this.beginListSqlContainerPartitionMerge(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      mergeParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the RUs per second of the SQL container under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  getSqlContainerThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesGetSqlContainerThroughputOptionalParams
  ): Promise<SqlResourcesGetSqlContainerThroughputResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      getSqlContainerThroughputOperationSpec
    );
  }

  /**
   * Update RUs per second of an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
   *                                   SQL container.
   * @param options The options parameters.
   */
  async beginUpdateSqlContainerThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: SqlResourcesUpdateSqlContainerThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesUpdateSqlContainerThroughputResponse>,
      SqlResourcesUpdateSqlContainerThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesUpdateSqlContainerThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        updateThroughputParameters,
        options
      },
      updateSqlContainerThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Update RUs per second of an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param updateThroughputParameters The parameters to provide for the RUs per second of the current
   *                                   SQL container.
   * @param options The options parameters.
   */
  async beginUpdateSqlContainerThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    updateThroughputParameters: ThroughputSettingsUpdateParameters,
    options?: SqlResourcesUpdateSqlContainerThroughputOptionalParams
  ): Promise<SqlResourcesUpdateSqlContainerThroughputResponse> {
    const poller = await this.beginUpdateSqlContainerThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      updateThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginMigrateSqlContainerToAutoscale(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesMigrateSqlContainerToAutoscaleOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesMigrateSqlContainerToAutoscaleResponse>,
      SqlResourcesMigrateSqlContainerToAutoscaleResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesMigrateSqlContainerToAutoscaleResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, containerName, options },
      migrateSqlContainerToAutoscaleOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB SQL container from manual throughput to autoscale
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginMigrateSqlContainerToAutoscaleAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesMigrateSqlContainerToAutoscaleOptionalParams
  ): Promise<SqlResourcesMigrateSqlContainerToAutoscaleResponse> {
    const poller = await this.beginMigrateSqlContainerToAutoscale(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginMigrateSqlContainerToManualThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesMigrateSqlContainerToManualThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        SqlResourcesMigrateSqlContainerToManualThroughputResponse
      >,
      SqlResourcesMigrateSqlContainerToManualThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesMigrateSqlContainerToManualThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { resourceGroupName, accountName, databaseName, containerName, options },
      migrateSqlContainerToManualThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Migrate an Azure Cosmos DB SQL container from autoscale to manual throughput
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  async beginMigrateSqlContainerToManualThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesMigrateSqlContainerToManualThroughputOptionalParams
  ): Promise<SqlResourcesMigrateSqlContainerToManualThroughputResponse> {
    const poller = await this.beginMigrateSqlContainerToManualThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieve throughput distribution for an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param retrieveThroughputParameters The parameters to provide for retrieving throughput distribution
   *                                     for the current SQL database.
   * @param options The options parameters.
   */
  async beginSqlDatabaseRetrieveThroughputDistribution(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    retrieveThroughputParameters: RetrieveThroughputParameters,
    options?: SqlResourcesSqlDatabaseRetrieveThroughputDistributionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        SqlResourcesSqlDatabaseRetrieveThroughputDistributionResponse
      >,
      SqlResourcesSqlDatabaseRetrieveThroughputDistributionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesSqlDatabaseRetrieveThroughputDistributionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        retrieveThroughputParameters,
        options
      },
      sqlDatabaseRetrieveThroughputDistributionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieve throughput distribution for an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param retrieveThroughputParameters The parameters to provide for retrieving throughput distribution
   *                                     for the current SQL database.
   * @param options The options parameters.
   */
  async beginSqlDatabaseRetrieveThroughputDistributionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    retrieveThroughputParameters: RetrieveThroughputParameters,
    options?: SqlResourcesSqlDatabaseRetrieveThroughputDistributionOptionalParams
  ): Promise<SqlResourcesSqlDatabaseRetrieveThroughputDistributionResponse> {
    const poller = await this.beginSqlDatabaseRetrieveThroughputDistribution(
      resourceGroupName,
      accountName,
      databaseName,
      retrieveThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Redistribute throughput for an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param redistributeThroughputParameters The parameters to provide for redistributing throughput for
   *                                         the current SQL database.
   * @param options The options parameters.
   */
  async beginSqlDatabaseRedistributeThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    redistributeThroughputParameters: RedistributeThroughputParameters,
    options?: SqlResourcesSqlDatabaseRedistributeThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesSqlDatabaseRedistributeThroughputResponse>,
      SqlResourcesSqlDatabaseRedistributeThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesSqlDatabaseRedistributeThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        redistributeThroughputParameters,
        options
      },
      sqlDatabaseRedistributeThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Redistribute throughput for an Azure Cosmos DB SQL database
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param redistributeThroughputParameters The parameters to provide for redistributing throughput for
   *                                         the current SQL database.
   * @param options The options parameters.
   */
  async beginSqlDatabaseRedistributeThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    redistributeThroughputParameters: RedistributeThroughputParameters,
    options?: SqlResourcesSqlDatabaseRedistributeThroughputOptionalParams
  ): Promise<SqlResourcesSqlDatabaseRedistributeThroughputResponse> {
    const poller = await this.beginSqlDatabaseRedistributeThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      redistributeThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieve throughput distribution for an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param retrieveThroughputParameters The parameters to provide for retrieving throughput distribution
   *                                     for the current SQL container.
   * @param options The options parameters.
   */
  async beginSqlContainerRetrieveThroughputDistribution(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    retrieveThroughputParameters: RetrieveThroughputParameters,
    options?: SqlResourcesSqlContainerRetrieveThroughputDistributionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        SqlResourcesSqlContainerRetrieveThroughputDistributionResponse
      >,
      SqlResourcesSqlContainerRetrieveThroughputDistributionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesSqlContainerRetrieveThroughputDistributionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        retrieveThroughputParameters,
        options
      },
      sqlContainerRetrieveThroughputDistributionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieve throughput distribution for an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param retrieveThroughputParameters The parameters to provide for retrieving throughput distribution
   *                                     for the current SQL container.
   * @param options The options parameters.
   */
  async beginSqlContainerRetrieveThroughputDistributionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    retrieveThroughputParameters: RetrieveThroughputParameters,
    options?: SqlResourcesSqlContainerRetrieveThroughputDistributionOptionalParams
  ): Promise<SqlResourcesSqlContainerRetrieveThroughputDistributionResponse> {
    const poller = await this.beginSqlContainerRetrieveThroughputDistribution(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      retrieveThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Redistribute throughput for an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param redistributeThroughputParameters The parameters to provide for redistributing throughput for
   *                                         the current SQL container.
   * @param options The options parameters.
   */
  async beginSqlContainerRedistributeThroughput(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    redistributeThroughputParameters: RedistributeThroughputParameters,
    options?: SqlResourcesSqlContainerRedistributeThroughputOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        SqlResourcesSqlContainerRedistributeThroughputResponse
      >,
      SqlResourcesSqlContainerRedistributeThroughputResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesSqlContainerRedistributeThroughputResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        redistributeThroughputParameters,
        options
      },
      sqlContainerRedistributeThroughputOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Redistribute throughput for an Azure Cosmos DB SQL container
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param redistributeThroughputParameters The parameters to provide for redistributing throughput for
   *                                         the current SQL container.
   * @param options The options parameters.
   */
  async beginSqlContainerRedistributeThroughputAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    redistributeThroughputParameters: RedistributeThroughputParameters,
    options?: SqlResourcesSqlContainerRedistributeThroughputOptionalParams
  ): Promise<SqlResourcesSqlContainerRedistributeThroughputResponse> {
    const poller = await this.beginSqlContainerRedistributeThroughput(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      redistributeThroughputParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the SQL storedProcedure under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  private _listSqlStoredProcedures(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlStoredProceduresOptionalParams
  ): Promise<SqlResourcesListSqlStoredProceduresResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      listSqlStoredProceduresOperationSpec
    );
  }

  /**
   * Gets the SQL storedProcedure under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param options The options parameters.
   */
  getSqlStoredProcedure(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    options?: SqlResourcesGetSqlStoredProcedureOptionalParams
  ): Promise<SqlResourcesGetSqlStoredProcedureResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName,
        options
      },
      getSqlStoredProcedureOperationSpec
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL storedProcedure
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param createUpdateSqlStoredProcedureParameters The parameters to provide for the current SQL
   *                                                 storedProcedure.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlStoredProcedure(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    createUpdateSqlStoredProcedureParameters: SqlStoredProcedureCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlStoredProcedureOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesCreateUpdateSqlStoredProcedureResponse>,
      SqlResourcesCreateUpdateSqlStoredProcedureResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesCreateUpdateSqlStoredProcedureResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName,
        createUpdateSqlStoredProcedureParameters,
        options
      },
      createUpdateSqlStoredProcedureOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL storedProcedure
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param createUpdateSqlStoredProcedureParameters The parameters to provide for the current SQL
   *                                                 storedProcedure.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlStoredProcedureAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    createUpdateSqlStoredProcedureParameters: SqlStoredProcedureCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlStoredProcedureOptionalParams
  ): Promise<SqlResourcesCreateUpdateSqlStoredProcedureResponse> {
    const poller = await this.beginCreateUpdateSqlStoredProcedure(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      storedProcedureName,
      createUpdateSqlStoredProcedureParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL storedProcedure.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param options The options parameters.
   */
  async beginDeleteSqlStoredProcedure(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    options?: SqlResourcesDeleteSqlStoredProcedureOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        storedProcedureName,
        options
      },
      deleteSqlStoredProcedureOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL storedProcedure.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param storedProcedureName Cosmos DB storedProcedure name.
   * @param options The options parameters.
   */
  async beginDeleteSqlStoredProcedureAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    storedProcedureName: string,
    options?: SqlResourcesDeleteSqlStoredProcedureOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteSqlStoredProcedure(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      storedProcedureName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  private _listSqlUserDefinedFunctions(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlUserDefinedFunctionsOptionalParams
  ): Promise<SqlResourcesListSqlUserDefinedFunctionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      listSqlUserDefinedFunctionsOperationSpec
    );
  }

  /**
   * Gets the SQL userDefinedFunction under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param options The options parameters.
   */
  getSqlUserDefinedFunction(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    options?: SqlResourcesGetSqlUserDefinedFunctionOptionalParams
  ): Promise<SqlResourcesGetSqlUserDefinedFunctionResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName,
        options
      },
      getSqlUserDefinedFunctionOperationSpec
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL userDefinedFunction
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param createUpdateSqlUserDefinedFunctionParameters The parameters to provide for the current SQL
   *                                                     userDefinedFunction.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlUserDefinedFunction(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    createUpdateSqlUserDefinedFunctionParameters: SqlUserDefinedFunctionCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlUserDefinedFunctionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse
      >,
      SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName,
        createUpdateSqlUserDefinedFunctionParameters,
        options
      },
      createUpdateSqlUserDefinedFunctionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL userDefinedFunction
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param createUpdateSqlUserDefinedFunctionParameters The parameters to provide for the current SQL
   *                                                     userDefinedFunction.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlUserDefinedFunctionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    createUpdateSqlUserDefinedFunctionParameters: SqlUserDefinedFunctionCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlUserDefinedFunctionOptionalParams
  ): Promise<SqlResourcesCreateUpdateSqlUserDefinedFunctionResponse> {
    const poller = await this.beginCreateUpdateSqlUserDefinedFunction(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      userDefinedFunctionName,
      createUpdateSqlUserDefinedFunctionParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL userDefinedFunction.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param options The options parameters.
   */
  async beginDeleteSqlUserDefinedFunction(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    options?: SqlResourcesDeleteSqlUserDefinedFunctionOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        userDefinedFunctionName,
        options
      },
      deleteSqlUserDefinedFunctionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL userDefinedFunction.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param userDefinedFunctionName Cosmos DB userDefinedFunction name.
   * @param options The options parameters.
   */
  async beginDeleteSqlUserDefinedFunctionAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    userDefinedFunctionName: string,
    options?: SqlResourcesDeleteSqlUserDefinedFunctionOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteSqlUserDefinedFunction(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      userDefinedFunctionName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Lists the SQL trigger under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param options The options parameters.
   */
  private _listSqlTriggers(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    options?: SqlResourcesListSqlTriggersOptionalParams
  ): Promise<SqlResourcesListSqlTriggersResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, databaseName, containerName, options },
      listSqlTriggersOperationSpec
    );
  }

  /**
   * Gets the SQL trigger under an existing Azure Cosmos DB database account.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param options The options parameters.
   */
  getSqlTrigger(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    options?: SqlResourcesGetSqlTriggerOptionalParams
  ): Promise<SqlResourcesGetSqlTriggerResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName,
        options
      },
      getSqlTriggerOperationSpec
    );
  }

  /**
   * Create or update an Azure Cosmos DB SQL trigger
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param createUpdateSqlTriggerParameters The parameters to provide for the current SQL trigger.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlTrigger(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    createUpdateSqlTriggerParameters: SqlTriggerCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlTriggerOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesCreateUpdateSqlTriggerResponse>,
      SqlResourcesCreateUpdateSqlTriggerResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesCreateUpdateSqlTriggerResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName,
        createUpdateSqlTriggerParameters,
        options
      },
      createUpdateSqlTriggerOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Create or update an Azure Cosmos DB SQL trigger
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param createUpdateSqlTriggerParameters The parameters to provide for the current SQL trigger.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlTriggerAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    createUpdateSqlTriggerParameters: SqlTriggerCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlTriggerOptionalParams
  ): Promise<SqlResourcesCreateUpdateSqlTriggerResponse> {
    const poller = await this.beginCreateUpdateSqlTrigger(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      triggerName,
      createUpdateSqlTriggerParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL trigger.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param options The options parameters.
   */
  async beginDeleteSqlTrigger(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    options?: SqlResourcesDeleteSqlTriggerOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        triggerName,
        options
      },
      deleteSqlTriggerOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL trigger.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param triggerName Cosmos DB trigger name.
   * @param options The options parameters.
   */
  async beginDeleteSqlTriggerAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    triggerName: string,
    options?: SqlResourcesDeleteSqlTriggerOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteSqlTrigger(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      triggerName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB SQL Role Definition with the given Id.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  getSqlRoleDefinition(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesGetSqlRoleDefinitionOptionalParams
  ): Promise<SqlResourcesGetSqlRoleDefinitionResponse> {
    return this.client.sendOperationRequest(
      { roleDefinitionId, resourceGroupName, accountName, options },
      getSqlRoleDefinitionOperationSpec
    );
  }

  /**
   * Creates or updates an Azure Cosmos DB SQL Role Definition.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateSqlRoleDefinitionParameters The properties required to create or update a Role
   *                                                Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlRoleDefinition(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateSqlRoleDefinitionParameters: SqlRoleDefinitionCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlRoleDefinitionOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesCreateUpdateSqlRoleDefinitionResponse>,
      SqlResourcesCreateUpdateSqlRoleDefinitionResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesCreateUpdateSqlRoleDefinitionResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        roleDefinitionId,
        resourceGroupName,
        accountName,
        createUpdateSqlRoleDefinitionParameters,
        options
      },
      createUpdateSqlRoleDefinitionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates or updates an Azure Cosmos DB SQL Role Definition.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateSqlRoleDefinitionParameters The properties required to create or update a Role
   *                                                Definition.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlRoleDefinitionAndWait(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateSqlRoleDefinitionParameters: SqlRoleDefinitionCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlRoleDefinitionOptionalParams
  ): Promise<SqlResourcesCreateUpdateSqlRoleDefinitionResponse> {
    const poller = await this.beginCreateUpdateSqlRoleDefinition(
      roleDefinitionId,
      resourceGroupName,
      accountName,
      createUpdateSqlRoleDefinitionParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL Role Definition.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteSqlRoleDefinition(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesDeleteSqlRoleDefinitionOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { roleDefinitionId, resourceGroupName, accountName, options },
      deleteSqlRoleDefinitionOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL Role Definition.
   * @param roleDefinitionId The GUID for the Role Definition.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteSqlRoleDefinitionAndWait(
    roleDefinitionId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesDeleteSqlRoleDefinitionOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteSqlRoleDefinition(
      roleDefinitionId,
      resourceGroupName,
      accountName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the list of all Azure Cosmos DB SQL Role Definitions.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listSqlRoleDefinitions(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleDefinitionsOptionalParams
  ): Promise<SqlResourcesListSqlRoleDefinitionsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listSqlRoleDefinitionsOperationSpec
    );
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB SQL Role Assignment with the given Id.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  getSqlRoleAssignment(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesGetSqlRoleAssignmentOptionalParams
  ): Promise<SqlResourcesGetSqlRoleAssignmentResponse> {
    return this.client.sendOperationRequest(
      { roleAssignmentId, resourceGroupName, accountName, options },
      getSqlRoleAssignmentOperationSpec
    );
  }

  /**
   * Creates or updates an Azure Cosmos DB SQL Role Assignment.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateSqlRoleAssignmentParameters The properties required to create or update a Role
   *                                                Assignment.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlRoleAssignment(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateSqlRoleAssignmentParameters: SqlRoleAssignmentCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlRoleAssignmentOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<SqlResourcesCreateUpdateSqlRoleAssignmentResponse>,
      SqlResourcesCreateUpdateSqlRoleAssignmentResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesCreateUpdateSqlRoleAssignmentResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        roleAssignmentId,
        resourceGroupName,
        accountName,
        createUpdateSqlRoleAssignmentParameters,
        options
      },
      createUpdateSqlRoleAssignmentOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Creates or updates an Azure Cosmos DB SQL Role Assignment.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param createUpdateSqlRoleAssignmentParameters The properties required to create or update a Role
   *                                                Assignment.
   * @param options The options parameters.
   */
  async beginCreateUpdateSqlRoleAssignmentAndWait(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    createUpdateSqlRoleAssignmentParameters: SqlRoleAssignmentCreateUpdateParameters,
    options?: SqlResourcesCreateUpdateSqlRoleAssignmentOptionalParams
  ): Promise<SqlResourcesCreateUpdateSqlRoleAssignmentResponse> {
    const poller = await this.beginCreateUpdateSqlRoleAssignment(
      roleAssignmentId,
      resourceGroupName,
      accountName,
      createUpdateSqlRoleAssignmentParameters,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL Role Assignment.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteSqlRoleAssignment(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesDeleteSqlRoleAssignmentOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      { roleAssignmentId, resourceGroupName, accountName, options },
      deleteSqlRoleAssignmentOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL Role Assignment.
   * @param roleAssignmentId The GUID for the Role Assignment.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  async beginDeleteSqlRoleAssignmentAndWait(
    roleAssignmentId: string,
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesDeleteSqlRoleAssignmentOptionalParams
  ): Promise<void> {
    const poller = await this.beginDeleteSqlRoleAssignment(
      roleAssignmentId,
      resourceGroupName,
      accountName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Retrieves the list of all Azure Cosmos DB SQL Role Assignments.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param options The options parameters.
   */
  private _listSqlRoleAssignments(
    resourceGroupName: string,
    accountName: string,
    options?: SqlResourcesListSqlRoleAssignmentsOptionalParams
  ): Promise<SqlResourcesListSqlRoleAssignmentsResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, accountName, options },
      listSqlRoleAssignmentsOperationSpec
    );
  }

  /**
   * Retrieves continuous backup information for a container resource.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformation(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    location: ContinuousBackupRestoreLocation,
    options?: SqlResourcesRetrieveContinuousBackupInformationOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        SqlResourcesRetrieveContinuousBackupInformationResponse
      >,
      SqlResourcesRetrieveContinuousBackupInformationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<SqlResourcesRetrieveContinuousBackupInformationResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        resourceGroupName,
        accountName,
        databaseName,
        containerName,
        location,
        options
      },
      retrieveContinuousBackupInformationOperationSpec
    );
    const poller = new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "location"
    });
    await poller.poll();
    return poller;
  }

  /**
   * Retrieves continuous backup information for a container resource.
   * @param resourceGroupName The name of the resource group. The name is case insensitive.
   * @param accountName Cosmos DB database account name.
   * @param databaseName Cosmos DB database name.
   * @param containerName Cosmos DB container name.
   * @param location The name of the continuous backup restore location.
   * @param options The options parameters.
   */
  async beginRetrieveContinuousBackupInformationAndWait(
    resourceGroupName: string,
    accountName: string,
    databaseName: string,
    containerName: string,
    location: ContinuousBackupRestoreLocation,
    options?: SqlResourcesRetrieveContinuousBackupInformationOptionalParams
  ): Promise<SqlResourcesRetrieveContinuousBackupInformationResponse> {
    const poller = await this.beginRetrieveContinuousBackupInformation(
      resourceGroupName,
      accountName,
      databaseName,
      containerName,
      location,
      options
    );
    return poller.pollUntilDone();
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listSqlDatabasesOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlDatabaseListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getSqlDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlDatabaseGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateSqlDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlDatabaseGetResults
    },
    201: {
      bodyMapper: Mappers.SqlDatabaseGetResults
    },
    202: {
      bodyMapper: Mappers.SqlDatabaseGetResults
    },
    204: {
      bodyMapper: Mappers.SqlDatabaseGetResults
    }
  },
  requestBody: Parameters.createUpdateSqlDatabaseParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteSqlDatabaseOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  serializer
};
const getSqlDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const updateSqlDatabaseThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const migrateSqlDatabaseToAutoscaleOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/migrateToAutoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const migrateSqlDatabaseToManualThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/migrateToManualThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listClientEncryptionKeysOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClientEncryptionKeysListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getClientEncryptionKeyOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys/{clientEncryptionKeyName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.clientEncryptionKeyName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateClientEncryptionKeyOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/clientEncryptionKeys/{clientEncryptionKeyName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults
    },
    201: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults
    },
    202: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults
    },
    204: {
      bodyMapper: Mappers.ClientEncryptionKeyGetResults
    }
  },
  requestBody: Parameters.createUpdateClientEncryptionKeyParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.clientEncryptionKeyName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const listSqlContainersOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlContainerListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getSqlContainerOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlContainerGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateSqlContainerOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlContainerGetResults
    },
    201: {
      bodyMapper: Mappers.SqlContainerGetResults
    },
    202: {
      bodyMapper: Mappers.SqlContainerGetResults
    },
    204: {
      bodyMapper: Mappers.SqlContainerGetResults
    }
  },
  requestBody: Parameters.createUpdateSqlContainerParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteSqlContainerOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  serializer
};
const listSqlContainerPartitionMergeOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/partitionMerge",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionStorageInfoCollection
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionStorageInfoCollection
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionStorageInfoCollection
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionStorageInfoCollection
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.mergeParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const getSqlContainerThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const updateSqlContainerThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    }
  },
  requestBody: Parameters.updateThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const migrateSqlContainerToAutoscaleOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/migrateToAutoscale",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const migrateSqlContainerToManualThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/migrateToManualThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    201: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    202: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    204: {
      bodyMapper: Mappers.ThroughputSettingsGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const sqlDatabaseRetrieveThroughputDistributionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/retrieveThroughputDistribution",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.retrieveThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const sqlDatabaseRedistributeThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/throughputSettings/default/redistributeThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.redistributeThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const sqlContainerRetrieveThroughputDistributionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/retrieveThroughputDistribution",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.retrieveThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const sqlContainerRedistributeThroughputOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/throughputSettings/default/redistributeThroughput",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    201: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    202: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    204: {
      bodyMapper: Mappers.PhysicalPartitionThroughputInfoResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.redistributeThroughputParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const listSqlStoredProceduresOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlStoredProcedureListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getSqlStoredProcedureOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.storedProcedureName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateSqlStoredProcedureOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults
    },
    201: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults
    },
    202: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults
    },
    204: {
      bodyMapper: Mappers.SqlStoredProcedureGetResults
    }
  },
  requestBody: Parameters.createUpdateSqlStoredProcedureParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.storedProcedureName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteSqlStoredProcedureOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/storedProcedures/{storedProcedureName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.storedProcedureName
  ],
  serializer
};
const listSqlUserDefinedFunctionsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlUserDefinedFunctionListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getSqlUserDefinedFunctionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.userDefinedFunctionName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateSqlUserDefinedFunctionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
    },
    201: {
      bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
    },
    202: {
      bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
    },
    204: {
      bodyMapper: Mappers.SqlUserDefinedFunctionGetResults
    }
  },
  requestBody: Parameters.createUpdateSqlUserDefinedFunctionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.userDefinedFunctionName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteSqlUserDefinedFunctionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/userDefinedFunctions/{userDefinedFunctionName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.userDefinedFunctionName
  ],
  serializer
};
const listSqlTriggersOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlTriggerListResult
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getSqlTriggerOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlTriggerGetResults
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.triggerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateSqlTriggerOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlTriggerGetResults
    },
    201: {
      bodyMapper: Mappers.SqlTriggerGetResults
    },
    202: {
      bodyMapper: Mappers.SqlTriggerGetResults
    },
    204: {
      bodyMapper: Mappers.SqlTriggerGetResults
    }
  },
  requestBody: Parameters.createUpdateSqlTriggerParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.triggerName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteSqlTriggerOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/triggers/{triggerName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName,
    Parameters.triggerName
  ],
  serializer
};
const getSqlRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleDefinitionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateSqlRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults
    },
    201: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults
    },
    202: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults
    },
    204: {
      bodyMapper: Mappers.SqlRoleDefinitionGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.createUpdateSqlRoleDefinitionParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleDefinitionId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteSqlRoleDefinitionOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions/{roleDefinitionId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleDefinitionId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listSqlRoleDefinitionsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleDefinitions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleDefinitionListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getSqlRoleAssignmentOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleAssignmentId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createUpdateSqlRoleAssignmentOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults
    },
    201: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults
    },
    202: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults
    },
    204: {
      bodyMapper: Mappers.SqlRoleAssignmentGetResults
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.createUpdateSqlRoleAssignmentParameters,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleAssignmentId
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteSqlRoleAssignmentOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments/{roleAssignmentId}",
  httpMethod: "DELETE",
  responses: {
    200: {},
    201: {},
    202: {},
    204: {},
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.roleAssignmentId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listSqlRoleAssignmentsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlRoleAssignments",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.SqlRoleAssignmentListResult
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const retrieveContinuousBackupInformationOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/sqlDatabases/{databaseName}/containers/{containerName}/retrieveContinuousBackupInformation",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.BackupInformation
    },
    201: {
      bodyMapper: Mappers.BackupInformation
    },
    202: {
      bodyMapper: Mappers.BackupInformation
    },
    204: {
      bodyMapper: Mappers.BackupInformation
    },
    default: {
      bodyMapper: Mappers.CloudError
    }
  },
  requestBody: Parameters.location,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.subscriptionId,
    Parameters.resourceGroupName,
    Parameters.accountName,
    Parameters.databaseName,
    Parameters.containerName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
