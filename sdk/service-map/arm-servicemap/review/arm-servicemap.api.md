## API Report File for "@azure/arm-servicemap"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';

// @public
export type Acceptor = Relationship & {
    source?: PortReference;
    destination?: ProcessReference;
    startTime?: Date;
    endTime?: Date;
};

// @public
export type Accuracy = "actual" | "estimated";

// @public
export interface AgentConfiguration {
    agentId: string;
    clockGranularity?: number;
    dependencyAgentId?: string;
    dependencyAgentRevision?: string;
    dependencyAgentVersion?: string;
    rebootStatus?: MachineRebootStatus;
}

// @public
export interface AzureCloudServiceConfiguration {
    deployment?: string;
    instanceId?: string;
    name?: string;
    roleName?: string;
    roleType?: AzureCloudServiceRoleType;
}

// @public
export type AzureCloudServiceRoleType = "unknown" | "worker" | "web";

// @public
export type AzureHostingConfiguration = HostingConfiguration & {
    kind: "provider:azure";
    vmId?: string;
    location?: string;
    name?: string;
    size?: string;
    updateDomain?: string;
    faultDomain?: string;
    subscriptionId?: string;
    resourceGroup?: string;
    resourceId?: string;
    image?: ImageConfiguration;
    cloudService?: AzureCloudServiceConfiguration;
    vmScaleSet?: AzureVmScaleSetConfiguration;
    serviceFabricCluster?: AzureServiceFabricClusterConfiguration;
};

// @public
export type AzureProcessHostingConfiguration = ProcessHostingConfiguration & {
    kind: "provider:azure";
    cloudService?: AzureCloudServiceConfiguration;
};

// @public
export interface AzureServiceFabricClusterConfiguration {
    clusterId?: string;
    name?: string;
}

// @public
export interface AzureVmScaleSetConfiguration {
    deployment?: string;
    instanceId?: string;
    name?: string;
    resourceId?: string;
}

// @public
export type Bitness = "32bit" | "64bit";

// @public
export type ClientGroup = CoreResource & {
    clientsOf?: ResourceReferenceUnion;
};

// @public
export type ClientGroupMember = Resource & {
    ipAddress?: string;
    port?: PortReference;
    processes?: ProcessReference[];
};

// @public
export interface ClientGroupMembersCollection {
    nextLink?: string;
    value?: ClientGroupMember[];
}

// @public
export interface ClientGroupMembersCount {
    accuracy: Accuracy;
    count: number;
    endTime: Date;
    groupId: string;
    startTime: Date;
}

// @public
export type ClientGroupReference = ResourceReference & {
    kind: "ref:clientgroup";
};

// @public
export interface ClientGroups {
    get(resourceGroupName: string, workspaceName: string, clientGroupName: string, options?: ClientGroupsGetOptionalParams): Promise<ClientGroupsGetResponse>;
    getMembersCount(resourceGroupName: string, workspaceName: string, clientGroupName: string, options?: ClientGroupsGetMembersCountOptionalParams): Promise<ClientGroupsGetMembersCountResponse>;
    listMembers(resourceGroupName: string, workspaceName: string, clientGroupName: string, options?: ClientGroupsListMembersOptionalParams): PagedAsyncIterableIterator<ClientGroupMember>;
}

// @public
export interface ClientGroupsGetMembersCountOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type ClientGroupsGetMembersCountResponse = ClientGroupMembersCount;

// @public
export interface ClientGroupsGetOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type ClientGroupsGetResponse = ClientGroup;

// @public
export interface ClientGroupsListMembersNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
    top?: number;
}

// @public
export type ClientGroupsListMembersNextResponse = ClientGroupMembersCollection;

// @public
export interface ClientGroupsListMembersOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
    top?: number;
}

// @public
export type ClientGroupsListMembersResponse = ClientGroupMembersCollection;

// @public
export type Connection = Relationship & {
    source?: ResourceReferenceUnion;
    destination?: ResourceReferenceUnion;
    startTime?: Date;
    endTime?: Date;
    serverPort?: PortReference;
    failureState?: ConnectionFailureState;
};

// @public
export interface ConnectionCollection {
    nextLink?: string;
    value?: Connection[];
}

// @public
export type ConnectionFailureState = "ok" | "failed" | "mixed";

// @public
export type ConnectionProperties = RelationshipProperties & {
    serverPort?: PortReference;
    failureState?: ConnectionFailureState;
};

// @public
export type CoreResource = Resource & {
    etag?: string;
    kind: CoreResourceKind;
};

// @public
export type CoreResourceKind = string;

// @public (undocumented)
export type CoreResourceUnion = CoreResource | Machine | Process | Port | MachineGroup | ClientGroup;

// @public
export interface ErrorModel {
    code: string;
    message?: string;
}

// @public
export interface ErrorResponse {
    error: ErrorModel;
}

// @public
export interface HostingConfiguration {
    kind: "provider:azure";
    provider?: "azure";
}

// @public (undocumented)
export type HostingConfigurationUnion = HostingConfiguration | AzureHostingConfiguration;

// @public
export interface HypervisorConfiguration {
    hypervisorType?: HypervisorType;
    nativeHostMachineId?: string;
}

// @public
export type HypervisorType = "unknown" | "hyperv";

// @public
export interface ImageConfiguration {
    offering?: string;
    publisher?: string;
    sku?: string;
    version?: string;
}

// @public
export interface Ipv4NetworkInterface {
    ipAddress: string;
    subnetMask?: string;
}

// @public
export interface Ipv6NetworkInterface {
    ipAddress: string;
}

// @public
export enum KnownCoreResourceKind {
    // (undocumented)
    ClientGroup = "clientGroup",
    // (undocumented)
    Machine = "machine",
    // (undocumented)
    MachineGroup = "machineGroup",
    // (undocumented)
    Port = "port",
    // (undocumented)
    Process = "process"
}

// @public
export enum KnownMachineGroupType {
    // (undocumented)
    AzureCs = "azure-cs",
    // (undocumented)
    AzureSf = "azure-sf",
    // (undocumented)
    AzureVmss = "azure-vmss",
    // (undocumented)
    Unknown = "unknown",
    // (undocumented)
    UserStatic = "user-static"
}

// @public
export enum KnownMapRequestKind {
    // (undocumented)
    MapMachineGroupDependency = "map:machine-group-dependency",
    // (undocumented)
    MapMachineListDependency = "map:machine-list-dependency",
    // (undocumented)
    MapSingleMachineDependency = "map:single-machine-dependency"
}

// @public
export enum KnownProcessRole {
    // (undocumented)
    AppServer = "appServer",
    // (undocumented)
    DatabaseServer = "databaseServer",
    // (undocumented)
    LdapServer = "ldapServer",
    // (undocumented)
    SmbServer = "smbServer",
    // (undocumented)
    WebServer = "webServer"
}

// @public
export enum KnownRelationshipKind {
    // (undocumented)
    RelAcceptor = "rel:acceptor",
    // (undocumented)
    RelConnection = "rel:connection"
}

// @public
export enum KnownResourceReferenceKind {
    // (undocumented)
    RefClientgroup = "ref:clientgroup",
    // (undocumented)
    RefMachine = "ref:machine",
    // (undocumented)
    RefMachinewithhints = "ref:machinewithhints",
    // (undocumented)
    RefOnmachine = "ref:onmachine",
    // (undocumented)
    RefPort = "ref:port",
    // (undocumented)
    RefProcess = "ref:process"
}

// @public
export interface Liveness {
    endTime: Date;
    live: boolean;
    startTime: Date;
}

// @public
export type Machine = CoreResource & {
    timestamp?: Date;
    monitoringState?: MonitoringState;
    virtualizationState?: VirtualizationState;
    displayName?: string;
    computerName?: string;
    fullyQualifiedDomainName?: string;
    bootTime?: Date;
    timezone?: Timezone;
    agent?: AgentConfiguration;
    resources?: MachineResourcesConfiguration;
    networking?: NetworkConfiguration;
    operatingSystem?: OperatingSystemConfiguration;
    virtualMachine?: VirtualMachineConfiguration;
    hypervisor?: HypervisorConfiguration;
    hosting?: HostingConfigurationUnion;
};

// @public
export interface MachineCollection {
    nextLink?: string;
    value?: Machine[];
}

// @public
export interface MachineCountsByOperatingSystem {
    linux: number;
    windows: number;
}

// @public
export type MachineGroup = CoreResource & {
    groupType?: MachineGroupType;
    displayName?: string;
    count?: number;
    machines?: MachineReferenceWithHints[];
};

// @public
export interface MachineGroupCollection {
    nextLink?: string;
    value?: MachineGroup[];
}

// @public
export type MachineGroupMapRequest = MultipleMachinesMapRequest & {
    kind: "map:machine-group-dependency";
    machineGroupId: string;
};

// @public
export interface MachineGroups {
    create(resourceGroupName: string, workspaceName: string, machineGroup: MachineGroup, options?: MachineGroupsCreateOptionalParams): Promise<MachineGroupsCreateResponse>;
    delete(resourceGroupName: string, workspaceName: string, machineGroupName: string, options?: MachineGroupsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, workspaceName: string, machineGroupName: string, options?: MachineGroupsGetOptionalParams): Promise<MachineGroupsGetResponse>;
    listByWorkspace(resourceGroupName: string, workspaceName: string, options?: MachineGroupsListByWorkspaceOptionalParams): PagedAsyncIterableIterator<MachineGroup>;
    update(resourceGroupName: string, workspaceName: string, machineGroupName: string, machineGroup: MachineGroup, options?: MachineGroupsUpdateOptionalParams): Promise<MachineGroupsUpdateResponse>;
}

// @public
export interface MachineGroupsCreateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MachineGroupsCreateResponse = MachineGroup;

// @public
export interface MachineGroupsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface MachineGroupsGetOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachineGroupsGetResponse = MachineGroup;

// @public
export interface MachineGroupsListByWorkspaceNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachineGroupsListByWorkspaceNextResponse = MachineGroupCollection;

// @public
export interface MachineGroupsListByWorkspaceOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachineGroupsListByWorkspaceResponse = MachineGroupCollection;

// @public
export interface MachineGroupsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MachineGroupsUpdateResponse = MachineGroup;

// @public
export type MachineGroupType = string;

// @public
export type MachineListMapRequest = MultipleMachinesMapRequest & {
    kind: "map:machine-list-dependency";
    machineIds: string[];
};

// @public
export type MachineRebootStatus = "unknown" | "rebooted" | "notRebooted";

// @public
export type MachineReference = ResourceReference & {
    kind: "ref:machine";
};

// @public
export type MachineReferenceWithHints = ResourceReference & {
    kind: "ref:machinewithhints";
    readonly displayNameHint?: string;
    readonly osFamilyHint?: OperatingSystemFamily;
};

// @public
export interface MachineResourcesConfiguration {
    cpus?: number;
    cpuSpeed?: number;
    cpuSpeedAccuracy?: Accuracy;
    physicalMemory?: number;
}

// @public
export interface Machines {
    get(resourceGroupName: string, workspaceName: string, machineName: string, options?: MachinesGetOptionalParams): Promise<MachinesGetResponse>;
    getLiveness(resourceGroupName: string, workspaceName: string, machineName: string, options?: MachinesGetLivenessOptionalParams): Promise<MachinesGetLivenessResponse>;
    listByWorkspace(resourceGroupName: string, workspaceName: string, options?: MachinesListByWorkspaceOptionalParams): PagedAsyncIterableIterator<Machine>;
    listConnections(resourceGroupName: string, workspaceName: string, machineName: string, options?: MachinesListConnectionsOptionalParams): PagedAsyncIterableIterator<Connection>;
    listMachineGroupMembership(resourceGroupName: string, workspaceName: string, machineName: string, options?: MachinesListMachineGroupMembershipOptionalParams): PagedAsyncIterableIterator<MachineGroup>;
    listPorts(resourceGroupName: string, workspaceName: string, machineName: string, options?: MachinesListPortsOptionalParams): PagedAsyncIterableIterator<Port>;
    listProcesses(resourceGroupName: string, workspaceName: string, machineName: string, options?: MachinesListProcessesOptionalParams): PagedAsyncIterableIterator<Process>;
}

// @public
export interface MachinesGetLivenessOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachinesGetLivenessResponse = Liveness;

// @public
export interface MachinesGetOptionalParams extends coreClient.OperationOptions {
    timestamp?: Date;
}

// @public
export type MachinesGetResponse = Machine;

// @public
export interface MachinesListByWorkspaceNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    live?: boolean;
    startTime?: Date;
    timestamp?: Date;
    top?: number;
}

// @public
export type MachinesListByWorkspaceNextResponse = MachineCollection;

// @public
export interface MachinesListByWorkspaceOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    live?: boolean;
    startTime?: Date;
    timestamp?: Date;
    top?: number;
}

// @public
export type MachinesListByWorkspaceResponse = MachineCollection;

// @public
export interface MachinesListConnectionsNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachinesListConnectionsNextResponse = ConnectionCollection;

// @public
export interface MachinesListConnectionsOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachinesListConnectionsResponse = ConnectionCollection;

// @public
export interface MachinesListMachineGroupMembershipNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachinesListMachineGroupMembershipNextResponse = MachineGroupCollection;

// @public
export interface MachinesListMachineGroupMembershipOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachinesListMachineGroupMembershipResponse = MachineGroupCollection;

// @public
export interface MachinesListPortsNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachinesListPortsNextResponse = PortCollection;

// @public
export interface MachinesListPortsOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type MachinesListPortsResponse = PortCollection;

// @public
export interface MachinesListProcessesNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    live?: boolean;
    startTime?: Date;
    timestamp?: Date;
}

// @public
export type MachinesListProcessesNextResponse = ProcessCollection;

// @public
export interface MachinesListProcessesOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    live?: boolean;
    startTime?: Date;
    timestamp?: Date;
}

// @public
export type MachinesListProcessesResponse = ProcessCollection;

// @public
export type MachinesSummary = Summary & {
    startTime?: Date;
    endTime?: Date;
    total?: number;
    live?: number;
    os?: MachineCountsByOperatingSystem;
};

// @public
export type MachinesSummaryProperties = SummaryProperties & {
    total: number;
    live: number;
    os: MachineCountsByOperatingSystem;
};

// @public
interface Map_2 {
    edges: MapEdges;
    nodes: MapNodes;
}
export { Map_2 as Map }

// @public
export interface MapEdges {
    acceptors?: Acceptor[];
    connections?: Connection[];
}

// @public
export interface MapNodes {
    clientGroups?: ClientGroup[];
    machines?: Machine[];
    ports?: Port[];
    processes?: Process[];
}

// @public
export interface MapRequest {
    endTime?: Date;
    kind: "map:single-machine-dependency" | "MultipleMachinesMapRequest" | "map:machine-list-dependency" | "map:machine-group-dependency";
    startTime?: Date;
}

// @public
export type MapRequestKind = string;

// @public (undocumented)
export type MapRequestUnion = MapRequest | SingleMachineDependencyMapRequest | MultipleMachinesMapRequestUnion;

// @public
export interface MapResponse {
    endTime: Date;
    map: Map_2;
    startTime: Date;
}

// @public
export interface Maps {
    generate(resourceGroupName: string, workspaceName: string, request: MapRequestUnion, options?: MapsGenerateOptionalParams): Promise<MapsGenerateResponse>;
}

// @public
export interface MapsGenerateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MapsGenerateResponse = MapResponse;

// @public
export type MonitoringState = "monitored" | "discovered";

// @public
export type MultipleMachinesMapRequest = MapRequest & {
    kind: "MultipleMachinesMapRequest" | "map:machine-list-dependency" | "map:machine-group-dependency";
    filterProcesses?: boolean;
};

// @public (undocumented)
export type MultipleMachinesMapRequestUnion = MultipleMachinesMapRequest | MachineListMapRequest | MachineGroupMapRequest;

// @public
export interface NetworkConfiguration {
    defaultIpv4Gateways?: string[];
    dnsNames?: string[];
    ipv4Interfaces?: Ipv4NetworkInterface[];
    ipv6Interfaces?: Ipv6NetworkInterface[];
    macAddresses?: string[];
}

// @public
export interface OperatingSystemConfiguration {
    bitness: Bitness;
    family: OperatingSystemFamily;
    fullName: string;
}

// @public
export type OperatingSystemFamily = "unknown" | "windows" | "linux" | "solaris" | "aix";

// @public
export type Port = CoreResource & {
    monitoringState?: MonitoringState;
    machine?: ResourceReferenceUnion;
    displayName?: string;
    ipAddress?: string;
    portNumber?: number;
};

// @public
export interface PortCollection {
    nextLink?: string;
    value?: Port[];
}

// @public
export type PortReference = ResourceReference & {
    kind: "ref:port";
    readonly machine?: MachineReference;
    readonly ipAddress?: string;
    portNumber?: number;
};

// @public
export interface Ports {
    get(resourceGroupName: string, workspaceName: string, machineName: string, portName: string, options?: PortsGetOptionalParams): Promise<PortsGetResponse>;
    getLiveness(resourceGroupName: string, workspaceName: string, machineName: string, portName: string, options?: PortsGetLivenessOptionalParams): Promise<PortsGetLivenessResponse>;
    listAcceptingProcesses(resourceGroupName: string, workspaceName: string, machineName: string, portName: string, options?: PortsListAcceptingProcessesOptionalParams): PagedAsyncIterableIterator<Process>;
    listConnections(resourceGroupName: string, workspaceName: string, machineName: string, portName: string, options?: PortsListConnectionsOptionalParams): PagedAsyncIterableIterator<Connection>;
}

// @public
export interface PortsGetLivenessOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type PortsGetLivenessResponse = Liveness;

// @public
export interface PortsGetOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type PortsGetResponse = Port;

// @public
export interface PortsListAcceptingProcessesNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type PortsListAcceptingProcessesNextResponse = ProcessCollection;

// @public
export interface PortsListAcceptingProcessesOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type PortsListAcceptingProcessesResponse = ProcessCollection;

// @public
export interface PortsListConnectionsNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type PortsListConnectionsNextResponse = ConnectionCollection;

// @public
export interface PortsListConnectionsOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type PortsListConnectionsResponse = ConnectionCollection;

// @public
export type Process = CoreResource & {
    timestamp?: Date;
    monitoringState?: MonitoringState;
    machine?: ResourceReferenceUnion;
    executableName?: string;
    displayName?: string;
    startTime?: Date;
    role?: ProcessRole;
    group?: string;
    details?: ProcessDetails;
    user?: ProcessUser;
    clientOf?: ResourceReferenceUnion;
    acceptorOf?: ResourceReferenceUnion;
    hosting?: ProcessHostingConfigurationUnion;
};

// @public
export interface ProcessCollection {
    nextLink?: string;
    value?: Process[];
}

// @public
export interface ProcessDetails {
    commandLine?: string;
    companyName?: string;
    description?: string;
    executablePath?: string;
    fileVersion?: string;
    firstPid?: number;
    internalName?: string;
    persistentKey?: string;
    poolId?: number;
    productName?: string;
    productVersion?: string;
    services?: ProcessHostedService[];
    workingDirectory?: string;
    zoneName?: string;
}

// @public
export interface Processes {
    get(resourceGroupName: string, workspaceName: string, machineName: string, processName: string, options?: ProcessesGetOptionalParams): Promise<ProcessesGetResponse>;
    getLiveness(resourceGroupName: string, workspaceName: string, machineName: string, processName: string, options?: ProcessesGetLivenessOptionalParams): Promise<ProcessesGetLivenessResponse>;
    listAcceptingPorts(resourceGroupName: string, workspaceName: string, machineName: string, processName: string, options?: ProcessesListAcceptingPortsOptionalParams): PagedAsyncIterableIterator<Port>;
    listConnections(resourceGroupName: string, workspaceName: string, machineName: string, processName: string, options?: ProcessesListConnectionsOptionalParams): PagedAsyncIterableIterator<Connection>;
}

// @public
export interface ProcessesGetLivenessOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type ProcessesGetLivenessResponse = Liveness;

// @public
export interface ProcessesGetOptionalParams extends coreClient.OperationOptions {
    timestamp?: Date;
}

// @public
export type ProcessesGetResponse = Process;

// @public
export interface ProcessesListAcceptingPortsNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type ProcessesListAcceptingPortsNextResponse = PortCollection;

// @public
export interface ProcessesListAcceptingPortsOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type ProcessesListAcceptingPortsResponse = PortCollection;

// @public
export interface ProcessesListConnectionsNextOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type ProcessesListConnectionsNextResponse = ConnectionCollection;

// @public
export interface ProcessesListConnectionsOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type ProcessesListConnectionsResponse = ConnectionCollection;

// @public
export interface ProcessHostedService {
    displayName?: string;
    name?: string;
}

// @public
export interface ProcessHostingConfiguration {
    kind: "provider:azure";
    provider?: "azure";
}

// @public (undocumented)
export type ProcessHostingConfigurationUnion = ProcessHostingConfiguration | AzureProcessHostingConfiguration;

// @public
export type ProcessReference = ResourceReference & {
    kind: "ref:process";
    readonly machine?: MachineReference;
};

// @public
export type ProcessRole = string;

// @public
export interface ProcessUser {
    userDomain?: string;
    userName?: string;
}

// @public
export type Relationship = Resource & {
    kind: RelationshipKind;
};

// @public
export type RelationshipKind = string;

// @public
export interface RelationshipProperties {
    destination: ResourceReferenceUnion;
    endTime?: Date;
    source: ResourceReferenceUnion;
    startTime?: Date;
}

// @public (undocumented)
export type RelationshipUnion = Relationship | Connection | Acceptor;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface ResourceReference {
    id: string;
    kind: "ref:machine" | "ref:port" | "ref:machinewithhints" | "ref:process" | "ref:clientgroup";
    readonly name?: string;
    readonly type?: string;
}

// @public
export type ResourceReferenceKind = string;

// @public (undocumented)
export type ResourceReferenceUnion = ResourceReference | MachineReference | PortReference | MachineReferenceWithHints | ProcessReference | ClientGroupReference;

// @public (undocumented)
export class ServiceMap extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: ServiceMapOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    clientGroups: ClientGroups;
    // (undocumented)
    machineGroups: MachineGroups;
    // (undocumented)
    machines: Machines;
    // (undocumented)
    maps: Maps;
    // (undocumented)
    ports: Ports;
    // (undocumented)
    processes: Processes;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    summaries: Summaries;
}

// @public
export interface ServiceMapOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export type SingleMachineDependencyMapRequest = MapRequest & {
    kind: "map:single-machine-dependency";
    machineId: string;
};

// @public
export interface Summaries {
    getMachines(resourceGroupName: string, workspaceName: string, options?: SummariesGetMachinesOptionalParams): Promise<SummariesGetMachinesResponse>;
}

// @public
export interface SummariesGetMachinesOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
}

// @public
export type SummariesGetMachinesResponse = MachinesSummary;

// @public
export type Summary = Resource & {};

// @public
export interface SummaryProperties {
    endTime: Date;
    startTime: Date;
}

// @public
export interface Timezone {
    fullName?: string;
}

// @public
export type VirtualizationState = "unknown" | "physical" | "virtual" | "hypervisor";

// @public
export interface VirtualMachineConfiguration {
    nativeHostMachineId?: string;
    nativeMachineId?: string;
    virtualMachineName?: string;
    virtualMachineType?: VirtualMachineType;
}

// @public
export type VirtualMachineType = "unknown" | "hyperv" | "ldom" | "lpar" | "vmware" | "virtualPc" | "xen";

// (No @packageDocumentation comment for this package)

```
