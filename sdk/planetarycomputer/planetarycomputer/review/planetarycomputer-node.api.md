## API Report File for "@azure-rest/planetarycomputer"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import type { ClientOptions } from '@azure-rest/core-client';
import type { ErrorModel } from '@azure-rest/core-client';
import type { OperationOptions } from '@azure-rest/core-client';
import type { OperationState } from '@azure/core-lro';
import type { PathUncheckedResponse } from '@azure-rest/core-client';
import type { Pipeline } from '@azure/core-rest-pipeline';
import type { PollerLike } from '@azure/core-lro';
import type { TokenCredential } from '@azure/core-auth';

// @public
export interface AssetMetadata {
    description: string;
    key: string;
    roles: string[];
    title: string;
    type: string;
}

// @public
export type BandMetadataElement = string | Record<string, string>;

// @public
export interface BandStatistics {
    count: number;
    histogram: number[][];
    majority: number;
    maskedPixels: number;
    maximum: number;
    mean: number;
    median: number;
    minimum: number;
    minority: number;
    percentile2: number;
    percentile98: number;
    std: number;
    sum: number;
    unique: number;
    validPercent: number;
    validPixels: number;
}

// @public
export type ColorMapNames = string;

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface DataCreateStaticImageOptionalParams extends OperationOptions {
}

// @public
export interface DataCropGeoJsonOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    coordinateReferenceSystem?: string;
    expression?: string;
    height?: number;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
    width?: number;
}

// @public
export interface DataCropGeoJsonWithDimensionsOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    coordinateReferenceSystem?: string;
    expression?: string;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
}

// @public
export interface DataGetAssetStatisticsOptionalParams extends OperationOptions {
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    categorical?: boolean;
    categoriesPixels?: string[];
    expression?: string;
    histogramBins?: string;
    histogramRange?: string;
    maxSize?: number;
    noData?: number;
    percentiles?: number[];
    resampling?: Resampling;
    unscale?: boolean;
}

// @public
export interface DataGetBoundsOptionalParams extends OperationOptions {
}

// @public
export interface DataGetClassMapLegendOptionalParams extends OperationOptions {
    trimEnd?: number;
    trimStart?: number;
}

// @public
export interface DataGetGeoJsonStatisticsOptionalParams extends OperationOptions {
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    categorical?: boolean;
    categoriesPixels?: string[];
    coordinateReferenceSystem?: string;
    expression?: string;
    histogramBins?: string;
    histogramRange?: string;
    maxSize?: number;
    noData?: number;
    percentiles?: number[];
    resampling?: Resampling;
    unscale?: boolean;
}

// @public
export interface DataGetInfoGeoJsonOptionalParams extends OperationOptions {
    assets?: string[];
}

// @public
export interface DataGetIntervalLegendOptionalParams extends OperationOptions {
    trimEnd?: number;
    trimStart?: number;
}

// @public
export interface DataGetItemAssetDetailsOptionalParams extends OperationOptions {
    assets?: string[];
}

// @public
export interface DataGetLegendOptionalParams extends OperationOptions {
    height?: number;
    trimEnd?: number;
    trimStart?: number;
    width?: number;
}

// @public
export interface DataGetMosaicsAssetsForPointOptionalParams extends OperationOptions {
    coordinateReferenceSystem?: string;
    exitWhenFull?: boolean;
    itemsLimit?: number;
    scanLimit?: number;
    skipCovered?: boolean;
    timeLimit?: number;
}

// @public
export interface DataGetMosaicsAssetsForTileOptionalParams extends OperationOptions {
    exitWhenFull?: boolean;
    itemsLimit?: number;
    scanLimit?: number;
    skipCovered?: boolean;
    timeLimit?: number;
}

// @public
export interface DataGetMosaicsSearchInfoOptionalParams extends OperationOptions {
}

// @public
export interface DataGetMosaicsTileJsonOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    collection?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    exitWhenFull?: boolean;
    expression?: string;
    itemsLimit?: number;
    maxZoom?: number;
    minZoom?: number;
    noData?: number;
    pixelSelection?: PixelSelection;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    scanLimit?: number;
    skipCovered?: boolean;
    tileFormat?: TilerImageFormat;
    tileScale?: number;
    timeLimit?: number;
    unscale?: boolean;
}

// @public
export interface DataGetMosaicsTileOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    collection?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    exitWhenFull?: boolean;
    expression?: string;
    itemsLimit?: number;
    noData?: number;
    pixelSelection?: PixelSelection;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    scanLimit?: number;
    skipCovered?: boolean;
    timeLimit?: number;
    unscale?: boolean;
}

// @public
export interface DataGetMosaicsWmtsCapabilitiesOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    expression?: string;
    maxZoom?: number;
    minZoom?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    tileFormat?: TilerImageFormat;
    tileScale?: number;
    unscale?: boolean;
}

// @public
export interface DataGetPartOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    coordinateReferenceSystem?: string;
    dstCrs?: string;
    expression?: string;
    height?: number;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
    width?: number;
}

// @public
export interface DataGetPartWithDimensionsOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    coordinateReferenceSystem?: string;
    dstCrs?: string;
    expression?: string;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
}

// @public
export interface DataGetPointOptionalParams extends OperationOptions {
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    coordinateReferenceSystem?: string;
    expression?: string;
    noData?: number;
    resampling?: Resampling;
    unscale?: boolean;
}

// @public
export interface DataGetPreviewOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    dstCrs?: string;
    expression?: string;
    format?: TilerImageFormat;
    height?: number;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
    width?: number;
}

// @public
export interface DataGetPreviewWithFormatOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    dstCrs?: string;
    expression?: string;
    height?: number;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
    width?: number;
}

// @public
export interface DataGetStaticImageOptionalParams extends OperationOptions {
}

// @public
export interface DataGetTileJsonOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    expression?: string;
    maxZoom?: number;
    minZoom?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    tileFormat?: TilerImageFormat;
    tileScale?: number;
    unscale?: boolean;
}

// @public
export interface DataGetTileMatrixDefinitionsOptionalParams extends OperationOptions {
}

// @public
export interface DataGetTileOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    expression?: string;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    subdatasetBands?: string[];
    subdatasetName?: string;
    unscale?: boolean;
}

// @public
export interface DataGetWmtsCapabilitiesOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    expression?: string;
    maxZoom?: number;
    minZoom?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    tileFormat?: TilerImageFormat;
    tileScale?: number;
    unscale?: boolean;
}

// @public
export interface DataListAvailableAssetsOptionalParams extends OperationOptions {
}

// @public
export interface DataListStatisticsOptionalParams extends OperationOptions {
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    categorical?: boolean;
    categoriesPixels?: string[];
    expression?: string;
    histogramBins?: string;
    histogramRange?: string;
    maxSize?: number;
    noData?: number;
    percentiles?: number[];
    resampling?: Resampling;
    unscale?: boolean;
}

// @public
export interface DataListTileMatricesOptionalParams extends OperationOptions {
}

// @public
export interface DataOperations {
    createStaticImage: (collectionId: string, body: ImageParameters, options?: DataCreateStaticImageOptionalParams) => Promise<ImageResponse>;
    cropGeoJson: (collectionId: string, itemId: string, format: string, body: Feature, options?: DataCropGeoJsonOptionalParams) => Promise<Uint8Array>;
    cropGeoJsonWithDimensions: (collectionId: string, itemId: string, width: number, height: number, format: string, body: Feature, options?: DataCropGeoJsonWithDimensionsOptionalParams) => Promise<Uint8Array>;
    getAssetStatistics: (collectionId: string, itemId: string, options?: DataGetAssetStatisticsOptionalParams) => Promise<Record<string, Record<string, BandStatistics>>>;
    getBounds: (collectionId: string, itemId: string, options?: DataGetBoundsOptionalParams) => Promise<StacItemBounds>;
    getClassMapLegend: (classmapName: string, options?: DataGetClassMapLegendOptionalParams) => Promise<Record<string, any>>;
    getGeoJsonStatistics: (collectionId: string, itemId: string, body: Feature, options?: DataGetGeoJsonStatisticsOptionalParams) => Promise<StacItemStatisticsGeoJson>;
    getInfoGeoJson: (collectionId: string, itemId: string, options?: DataGetInfoGeoJsonOptionalParams) => Promise<TilerInfoGeoJsonFeature>;
    getIntervalLegend: (classmapName: string, options?: DataGetIntervalLegendOptionalParams) => Promise<IntervalLegendsElement[][]>;
    getItemAssetDetails: (collectionId: string, itemId: string, options?: DataGetItemAssetDetailsOptionalParams) => Promise<Record<string, TilerInfo>>;
    getLegend: (colorMapName: string, options?: DataGetLegendOptionalParams) => Promise<Uint8Array>;
    getMosaicsAssetsForPoint: (searchId: string, longitude: number, latitude: number, options?: DataGetMosaicsAssetsForPointOptionalParams) => Promise<StacItemPointAsset[]>;
    getMosaicsAssetsForTile: (searchId: string, tileMatrixSetId: string, collectionId: string, z: number, x: number, y: number, options?: DataGetMosaicsAssetsForTileOptionalParams) => Promise<any[]>;
    getMosaicsSearchInfo: (searchId: string, options?: DataGetMosaicsSearchInfoOptionalParams) => Promise<TilerStacSearchRegistration>;
    getMosaicsTile: (searchId: string, tileMatrixSetId: string, z: number, x: number, y: number, scale: number, format: string, options?: DataGetMosaicsTileOptionalParams) => Promise<Uint8Array>;
    getMosaicsTileJson: (searchId: string, tileMatrixSetId: string, options?: DataGetMosaicsTileJsonOptionalParams) => Promise<TileJsonMetadata>;
    getMosaicsWmtsCapabilities: (searchId: string, tileMatrixSetId: string, options?: DataGetMosaicsWmtsCapabilitiesOptionalParams) => Promise<Uint8Array>;
    getPart: (collectionId: string, itemId: string, minx: number, miny: number, maxx: number, maxy: number, format: string, options?: DataGetPartOptionalParams) => Promise<Uint8Array>;
    getPartWithDimensions: (collectionId: string, itemId: string, minx: number, miny: number, maxx: number, maxy: number, width: number, height: number, format: string, options?: DataGetPartWithDimensionsOptionalParams) => Promise<Uint8Array>;
    getPoint: (collectionId: string, itemId: string, longitude: number, latitude: number, options?: DataGetPointOptionalParams) => Promise<TilerCoreModelsResponsesPoint>;
    getPreview: (collectionId: string, itemId: string, options?: DataGetPreviewOptionalParams) => Promise<Uint8Array>;
    getPreviewWithFormat: (collectionId: string, itemId: string, format: string, options?: DataGetPreviewWithFormatOptionalParams) => Promise<Uint8Array>;
    getStaticImage: (collectionId: string, id: string, options?: DataGetStaticImageOptionalParams) => Promise<Uint8Array>;
    getTile: (collectionId: string, itemId: string, tileMatrixSetId: string, z: number, x: number, y: number, scale: number, format: string, options?: DataGetTileOptionalParams) => Promise<Uint8Array>;
    getTileJson: (collectionId: string, itemId: string, tileMatrixSetId: string, options?: DataGetTileJsonOptionalParams) => Promise<TileJsonMetadata>;
    getTileMatrixDefinitions: (tileMatrixSetId: string, options?: DataGetTileMatrixDefinitionsOptionalParams) => Promise<TileMatrixSet>;
    getWmtsCapabilities: (collectionId: string, itemId: string, tileMatrixSetId: string, options?: DataGetWmtsCapabilitiesOptionalParams) => Promise<Uint8Array>;
    listAvailableAssets: (collectionId: string, itemId: string, options?: DataListAvailableAssetsOptionalParams) => Promise<string[]>;
    listStatistics: (collectionId: string, itemId: string, options?: DataListStatisticsOptionalParams) => Promise<TilerStacItemStatistics>;
    listTileMatrices: (options?: DataListTileMatricesOptionalParams) => Promise<string[]>;
    registerMosaicsSearch: (options?: DataRegisterMosaicsSearchOptionalParams) => Promise<TilerMosaicSearchRegistrationResponse>;
}

// @public
export interface DataRegisterMosaicsSearchOptionalParams extends OperationOptions {
    boundingBox?: number;
    collections?: string[];
    datetime?: string;
    filter?: Record<string, any>;
    filterLanguage?: FilterLanguage;
    ids?: string[];
    intersects?: GeometryUnion;
    metadata?: MosaicMetadata;
    query?: Record<string, any>;
    sortBy?: StacSortExtension[];
}

// @public
export interface DefaultLocation {
    coordinates: number[];
    zoom: number;
}

// @public
export interface ErrorInfo {
    error: ErrorModel;
}

// @public
export interface Feature {
    geometry: GeometryUnion;
    properties?: Record<string, any>;
    type: FeatureType;
}

// @public
export type FeatureType = string;

// @public
export type FileContents = string | NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array | Blob;

// @public
export type FilterLanguage = string;

// @public
export interface Geometry {
    boundingBox?: number[];
    type: GeometryType;
}

// @public
export type GeometryType = string;

// @public
export type GeometryUnion = Point | Polygon | MultiPolygon | MultiLineString | LineString | MultiPoint | Geometry;

// @public
export interface ImageParameters {
    columns: number;
    cql: Record<string, any>;
    geometry?: GeometryUnion;
    imageSize?: string;
    renderParameters: string;
    rows: number;
    showBranding?: boolean;
    zoom?: number;
}

// @public
export interface ImageResponse {
    url: string;
}

// @public
export interface IngestionCancelAllOperationsOptionalParams extends OperationOptions {
}

// @public
export interface IngestionCancelOperationOptionalParams extends OperationOptions {
}

// @public
export interface IngestionCreateOptionalParams extends OperationOptions {
}

// @public
export interface IngestionCreateRunOptionalParams extends OperationOptions {
}

// @public
export interface IngestionCreateSourceOptionalParams extends OperationOptions {
}

// @public
export interface IngestionDefinition {
    readonly creationTime: Date;
    displayName?: string;
    readonly id: string;
    importType: IngestionType;
    keepOriginalAssets?: boolean;
    skipExistingItems?: boolean;
    sourceCatalogUrl?: string;
    readonly status: IngestionStatus;
}

// @public
export interface IngestionDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface IngestionDeleteSourceOptionalParams extends OperationOptions {
}

// @public
export interface IngestionGetOperationOptionalParams extends OperationOptions {
}

// @public
export interface IngestionGetOptionalParams extends OperationOptions {
}

// @public
export interface IngestionGetRunOptionalParams extends OperationOptions {
}

// @public
export interface IngestionGetSourceOptionalParams extends OperationOptions {
}

// @public
export interface IngestionListManagedIdentitiesOptionalParams extends OperationOptions {
}

// @public
export interface IngestionListOperationsOptionalParams extends OperationOptions {
    collectionId?: string;
    skip?: number;
    status?: OperationStatus;
    top?: number;
}

// @public
export interface IngestionListOptionalParams extends OperationOptions {
    skip?: number;
    top?: number;
}

// @public
export interface IngestionListRunsOptionalParams extends OperationOptions {
    skip?: number;
    top?: number;
}

// @public
export interface IngestionListSourcesOptionalParams extends OperationOptions {
    skip?: number;
    top?: number;
}

// @public
export interface IngestionOperations {
    cancelAllOperations: (options?: IngestionCancelAllOperationsOptionalParams) => Promise<void>;
    cancelOperation: (operationId: string, options?: IngestionCancelOperationOptionalParams) => Promise<void>;
    create: (collectionId: string, body: IngestionDefinition, options?: IngestionCreateOptionalParams) => Promise<IngestionDefinition>;
    createRun: (collectionId: string, ingestionId: string, options?: IngestionCreateRunOptionalParams) => Promise<IngestionRun>;
    createSource: (body: IngestionSourceUnion, options?: IngestionCreateSourceOptionalParams) => Promise<IngestionSourceUnion>;
    delete: (collectionId: string, ingestionId: string, options?: IngestionDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    deleteSource: (id: string, options?: IngestionDeleteSourceOptionalParams) => Promise<void>;
    get: (collectionId: string, ingestionId: string, options?: IngestionGetOptionalParams) => Promise<IngestionDefinition>;
    getOperation: (operationId: string, options?: IngestionGetOperationOptionalParams) => Promise<Operation>;
    getRun: (collectionId: string, ingestionId: string, runId: string, options?: IngestionGetRunOptionalParams) => Promise<IngestionRun>;
    getSource: (id: string, options?: IngestionGetSourceOptionalParams) => Promise<IngestionSourceUnion>;
    list: (collectionId: string, options?: IngestionListOptionalParams) => PagedAsyncIterableIterator<IngestionDefinition>;
    listManagedIdentities: (options?: IngestionListManagedIdentitiesOptionalParams) => PagedAsyncIterableIterator<ManagedIdentityMetadata>;
    listOperations: (options?: IngestionListOperationsOptionalParams) => PagedAsyncIterableIterator<Operation>;
    listRuns: (collectionId: string, ingestionId: string, options?: IngestionListRunsOptionalParams) => PagedAsyncIterableIterator<IngestionRun>;
    listSources: (options?: IngestionListSourcesOptionalParams) => PagedAsyncIterableIterator<IngestionSourceSummary>;
    replaceSource: (id: string, body: IngestionSourceUnion, options?: IngestionReplaceSourceOptionalParams) => Promise<IngestionSourceUnion>;
    update: (collectionId: string, ingestionId: string, body: IngestionDefinition, options?: IngestionUpdateOptionalParams) => Promise<IngestionDefinition>;
}

// @public
export interface IngestionReplaceSourceOptionalParams extends OperationOptions {
}

// @public
export interface IngestionRun {
    creationTime: Date;
    id: string;
    keepOriginalAssets?: boolean;
    operation: IngestionRunOperation;
    parentRunId?: string;
    skipExistingItems?: boolean;
    sourceCatalogUrl?: string;
}

// @public
export interface IngestionRunOperation {
    creationTime: Date;
    finishTime?: Date;
    id: string;
    startTime?: Date;
    status: OperationStatus;
    statusHistory: OperationStatusHistoryItem[];
    totalFailedItems: number;
    totalItems: number;
    totalPendingItems: number;
    totalSuccessfulItems: number;
}

// @public
export interface IngestionSource {
    readonly created?: Date;
    id: string;
    kind: IngestionSourceType;
}

// @public
export interface IngestionSourceSummary {
    created?: Date;
    id: string;
    kind: IngestionSourceType;
}

// @public
export type IngestionSourceType = string;

// @public
export type IngestionSourceUnion = SharedAccessSignatureTokenIngestionSource | ManagedIdentityIngestionSource | IngestionSource;

// @public
export type IngestionStatus = string;

// @public
export type IngestionType = string;

// @public
export interface IngestionUpdateOptionalParams extends OperationOptions {
}

// @public
export type IntervalLegendsElement = number[] | Record<string, string>;

// @public
export enum KnownColorMapNames {
    Accent = "accent",
    AccentR = "accent_r",
    Afmhot = "afmhot",
    AfmhotR = "afmhot_r",
    Ai4GLulc = "ai4g-lulc",
    AlosFnf = "alos-fnf",
    AlosPalsarMask = "alos-palsar-mask",
    Autumn = "autumn",
    AutumnR = "autumn_r",
    Binary = "binary",
    BinaryR = "binary_r",
    Blues = "blues",
    BluesR = "blues_r",
    Bone = "bone",
    BoneR = "bone_r",
    Brbg = "brbg",
    BrbgR = "brbg_r",
    Brg = "brg",
    BrgR = "brg_r",
    Bugn = "bugn",
    BugnR = "bugn_r",
    Bupu = "bupu",
    BupuR = "bupu_r",
    Bwr = "bwr",
    BwrR = "bwr_r",
    CCap = "c-cap",
    Cfastie = "cfastie",
    ChesapeakeLc13 = "chesapeake-lc-13",
    ChesapeakeLc7 = "chesapeake-lc-7",
    ChesapeakeLu = "chesapeake-lu",
    ChlorisBiomass = "chloris-biomass",
    Cividis = "cividis",
    CividisR = "cividis_r",
    Cmrmap = "cmrmap",
    CmrmapR = "cmrmap_r",
    Cool = "cool",
    CoolR = "cool_r",
    Coolwarm = "coolwarm",
    CoolwarmR = "coolwarm_r",
    Copper = "copper",
    CopperR = "copper_r",
    Cubehelix = "cubehelix",
    CubehelixR = "cubehelix_r",
    Dark2 = "dark2",
    Dark2R = "dark2_r",
    DrcogLulc = "drcog-lulc",
    EsaCciLc = "esa-cci-lc",
    EsaWorldcover = "esa-worldcover",
    Flag = "flag",
    FlagR = "flag_r",
    GapLulc = "gap-lulc",
    GistEarth = "gist_earth",
    GistEarthR = "gist_earth_r",
    GistGray = "gist_gray",
    GistGrayR = "gist_gray_r",
    GistHeat = "gist_heat",
    GistHeatR = "gist_heat_r",
    GistNcar = "gist_ncar",
    GistNcarR = "gist_ncar_r",
    GistRainbow = "gist_rainbow",
    GistRainbowR = "gist_rainbow_r",
    GistStern = "gist_stern",
    GistSternR = "gist_stern_r",
    GistYarg = "gist_yarg",
    GistYargR = "gist_yarg_r",
    Gnbu = "gnbu",
    GnbuR = "gnbu_r",
    Gnuplot = "gnuplot",
    Gnuplot2 = "gnuplot2",
    Gnuplot2R = "gnuplot2_r",
    GnuplotR = "gnuplot_r",
    Gray = "gray",
    GrayR = "gray_r",
    Greens = "greens",
    GreensR = "greens_r",
    Greys = "greys",
    GreysR = "greys_r",
    Hot = "hot",
    HotR = "hot_r",
    Hsv = "hsv",
    HsvR = "hsv_r",
    Inferno = "inferno",
    InfernoR = "inferno_r",
    IoBii = "io-bii",
    IoLulc = "io-lulc",
    IoLulc9Class = "io-lulc-9-class",
    Jet = "jet",
    JetR = "jet_r",
    JrcChange = "jrc-change",
    JrcExtent = "jrc-extent",
    JrcOccurrence = "jrc-occurrence",
    JrcRecurrence = "jrc-recurrence",
    JrcSeasonality = "jrc-seasonality",
    JrcTransitions = "jrc-transitions",
    LidarClassification = "lidar-classification",
    LidarHag = "lidar-hag",
    LidarHagAlternative = "lidar-hag-alternative",
    LidarIntensity = "lidar-intensity",
    LidarReturns = "lidar-returns",
    Magma = "magma",
    MagmaR = "magma_r",
    Modis10A1 = "modis-10A1",
    Modis10A2 = "modis-10A2",
    Modis13A1Q1 = "modis-13A1|Q1",
    Modis14A1A2 = "modis-14A1|A2",
    Modis15A2HA3H = "modis-15A2H|A3H",
    Modis16A3GFET = "modis-16A3GF-ET",
    Modis16A3GFPET = "modis-16A3GF-PET",
    Modis17A2HA2HGF = "modis-17A2H|A2HGF",
    Modis17A3HGF = "modis-17A3HGF",
    Modis64A1 = "modis-64A1",
    MtbsSeverity = "mtbs-severity",
    NipySpectral = "nipy_spectral",
    NipySpectralR = "nipy_spectral_r",
    NrcanLulc = "nrcan-lulc",
    Ocean = "ocean",
    OceanR = "ocean_r",
    Oranges = "oranges",
    OrangesR = "oranges_r",
    Orrd = "orrd",
    OrrdR = "orrd_r",
    Paired = "paired",
    PairedR = "paired_r",
    Pastel1 = "pastel1",
    Pastel1R = "pastel1_r",
    Pastel2 = "pastel2",
    Pastel2R = "pastel2_r",
    Pink = "pink",
    PinkR = "pink_r",
    Piyg = "piyg",
    PiygR = "piyg_r",
    Plasma = "plasma",
    PlasmaR = "plasma_r",
    Prgn = "prgn",
    PrgnR = "prgn_r",
    Prism = "prism",
    PrismR = "prism_r",
    Pubu = "pubu",
    Pubugn = "pubugn",
    PubugnR = "pubugn_r",
    PubuR = "pubu_r",
    Puor = "puor",
    PuorR = "puor_r",
    Purd = "purd",
    PurdR = "purd_r",
    Purples = "purples",
    PurplesR = "purples_r",
    Qpe = "qpe",
    Rainbow = "rainbow",
    RainbowR = "rainbow_r",
    Rdbu = "rdbu",
    RdbuR = "rdbu_r",
    Rdgy = "rdgy",
    RdgyR = "rdgy_r",
    Rdpu = "rdpu",
    RdpuR = "rdpu_r",
    Rdylbu = "rdylbu",
    RdylbuR = "rdylbu_r",
    Rdylgn = "rdylgn",
    RdylgnR = "rdylgn_r",
    Reds = "reds",
    RedsR = "reds_r",
    Rplumbo = "rplumbo",
    Schwarzwald = "schwarzwald",
    Seismic = "seismic",
    SeismicR = "seismic_r",
    Set1 = "set1",
    Set1R = "set1_r",
    Set2 = "set2",
    Set2R = "set2_r",
    Set3 = "set3",
    Set3R = "set3_r",
    Spectral = "spectral",
    SpectralR = "spectral_r",
    Spring = "spring",
    SpringR = "spring_r",
    Summer = "summer",
    SummerR = "summer_r",
    Tab10 = "tab10",
    Tab10R = "tab10_r",
    Tab20 = "tab20",
    Tab20B = "tab20b",
    Tab20BR = "tab20b_r",
    Tab20C = "tab20c",
    Tab20CR = "tab20c_r",
    Tab20R = "tab20_r",
    Terrain = "terrain",
    TerrainR = "terrain_r",
    Twilight = "twilight",
    TwilightR = "twilight_r",
    TwilightShifted = "twilight_shifted",
    TwilightShiftedR = "twilight_shifted_r",
    UsdaCdl = "usda-cdl",
    UsdaCdlCorn = "usda-cdl-corn",
    UsdaCdlCotton = "usda-cdl-cotton",
    UsdaCdlSoybeans = "usda-cdl-soybeans",
    UsdaCdlWheat = "usda-cdl-wheat",
    UsgsLcmap = "usgs-lcmap",
    Viirs10A1 = "viirs-10a1",
    Viirs13A1 = "viirs-13a1",
    Viirs14A1 = "viirs-14a1",
    Viirs15A2H = "viirs-15a2H",
    Viridis = "viridis",
    ViridisR = "viridis_r",
    Winter = "winter",
    WinterR = "winter_r",
    Wistia = "wistia",
    WistiaR = "wistia_r",
    Ylgn = "ylgn",
    Ylgnbu = "ylgnbu",
    YlgnbuR = "ylgnbu_r",
    YlgnR = "ylgn_r",
    Ylorbr = "ylorbr",
    YlorbrR = "ylorbr_r",
    Ylorrd = "ylorrd",
    YlorrdR = "ylorrd_r"
}

// @public
export enum KnownFeatureType {
    Feature = "Feature"
}

// @public
export enum KnownFilterLanguage {
    Cql2Json = "cql2-json",
    Cql2Text = "cql2-text",
    CqlJson = "cql-json"
}

// @public
export enum KnownGeometryType {
    LineString = "LineString",
    MultiLineString = "MultiLineString",
    MultiPoint = "MultiPoint",
    MultiPolygon = "MultiPolygon",
    Point = "Point",
    Polygon = "Polygon"
}

// @public
export enum KnownIngestionSourceType {
    BlobManagedIdentity = "BlobManagedIdentity",
    SharedAccessSignatureToken = "SasToken"
}

// @public
export enum KnownIngestionStatus {
    Deleting = "Deleting",
    Ready = "Ready"
}

// @public
export enum KnownIngestionType {
    StaticCatalog = "StaticCatalog"
}

// @public
export enum KnownLegendConfigType {
    Classmap = "classmap",
    Continuous = "continuous",
    Interval = "interval",
    None = "none"
}

// @public
export enum KnownMosaicMetadataType {
    Mosaic = "mosaic",
    Search = "search"
}

// @public
export enum KnownNoDataType {
    Alpha = "Alpha",
    Internal = "Internal",
    Mask = "Mask",
    Nodata = "Nodata",
    None = "None"
}

// @public
export enum KnownOperationStatus {
    Canceled = "Canceled",
    Canceling = "Canceling",
    Failed = "Failed",
    Pending = "Pending",
    Running = "Running",
    Succeeded = "Succeeded"
}

// @public
export enum KnownPartitionTypeScheme {
    Month = "month",
    None = "none",
    Year = "year"
}

// @public
export enum KnownPixelSelection {
    First = "first",
    Highest = "highest",
    LastBandHigh = "lastbandhigh",
    LastBandLow = "lastbandlow",
    Lowest = "lowest",
    Mean = "mean",
    Median = "median",
    StandardDeviation = "stdev"
}

// @public
export enum KnownRenderOptionType {
    RasterTile = "raster-tile",
    VtLine = "vt-line",
    VtPolygon = "vt-polygon"
}

// @public
export enum KnownResampling {
    Average = "average",
    Bilinear = "bilinear",
    Cubic = "cubic",
    CubicSpline = "cubic_spline",
    Gauss = "gauss",
    Lanczos = "lanczos",
    Mode = "mode",
    Nearest = "nearest",
    Rms = "rms"
}

// @public
export enum KnownStacAssetUrlSigningMode {
    False = "false",
    True = "true"
}

// @public
export enum KnownStacLinkType {
    ApplicationGeoJson = "application/geo+json",
    ApplicationJson = "application/json",
    ApplicationXBinary = "application/x-binary",
    ApplicationXml = "application/xml",
    ApplicationXProtobuf = "application/x-protobuf",
    ImageJp2 = "image/jp2",
    ImageJpeg = "image/jpeg",
    ImageJpg = "image/jpg",
    ImagePng = "image/png",
    ImageTiffApplicationGeotiff = "image/tiff; application=geotiff",
    ImageWebp = "image/webp",
    TextHtml = "text/html",
    TextPlain = "text/plain"
}

// @public
export enum KnownStacModelType {
    Feature = "Feature",
    FeatureCollection = "FeatureCollection"
}

// @public
export enum KnownStacQueryableDefinitionDataType {
    Boolean = "boolean",
    Date = "date",
    Number = "number",
    String = "string",
    Timestamp = "timestamp"
}

// @public
export enum KnownStacSearchSortingDirection {
    Asc = "asc",
    Desc = "desc"
}

// @public
export enum KnownTerrainAlgorithm {
    Contours = "contours",
    Hillshade = "hillshade",
    NormalizedIndex = "normalizedIndex",
    Terrainrgb = "terrainrgb",
    Terrarium = "terrarium"
}

// @public
export enum KnownTileAddressingScheme {
    Tms = "tms",
    Xyz = "xyz"
}

// @public
export enum KnownTileMatrixCornerOfOrigin {
    BottomLeft = "bottomLeft",
    TopLeft = "topLeft"
}

// @public
export enum KnownTilerImageFormat {
    Jp2 = "jp2",
    Jpeg = "jpeg",
    Jpg = "jpg",
    Npy = "npy",
    Png = "png",
    Pngraw = "pngraw",
    Tif = "tif",
    Webp = "webp"
}

// @public
export enum KnownVersions {
    V20250430Preview = "2025-04-30-preview"
}

// @public
export type LegendConfigType = string;

// @public
export interface LineString extends Geometry {
    coordinates: number[];
    type: "LineString";
}

// @public
export interface ManagedIdentityConnection {
    containerUri: string;
    objectId: string;
}

// @public
export interface ManagedIdentityIngestionSource extends IngestionSource {
    connectionInfo: ManagedIdentityConnection;
    // (undocumented)
    kind: "BlobManagedIdentity";
}

// @public
export interface ManagedIdentityMetadata {
    objectId: string;
    resourceId: string;
}

// @public
export interface MosaicMetadata {
    assets?: string[];
    bounds?: string;
    defaults?: Record<string, string>;
    maxZoom?: number;
    minZoom?: number;
    name?: string;
    type?: MosaicMetadataType;
}

// @public
export type MosaicMetadataType = string;

// @public
export interface MultiLineString extends Geometry {
    coordinates: number[][];
    type: "MultiLineString";
}

// @public
export interface MultiPoint extends Geometry {
    coordinates: number[];
    type: "MultiPoint";
}

// @public
export interface MultiPolygon extends Geometry {
    coordinates: number[][][];
    type: "MultiPolygon";
}

// @public
export type NoDataType = string;

// @public
export interface Operation {
    additionalInformation?: Record<string, string>;
    collectionId?: string;
    creationTime: Date;
    error?: ErrorInfo;
    finishTime?: Date;
    id: string;
    startTime?: Date;
    status: OperationStatus;
    statusHistory: OperationStatusHistoryItem[];
    type: string;
}

// @public
export type OperationStatus = string;

// @public
export interface OperationStatusHistoryItem {
    errorCode?: string;
    errorMessage?: string;
    status: OperationStatus;
    timestamp: Date;
}

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PartitionType {
    scheme?: PartitionTypeScheme;
}

// @public
export type PartitionTypeScheme = string;

// @public
export type PixelSelection = string;

// @public (undocumented)
export class PlanetaryComputerProClient {
    constructor(endpointParam: string, credential: TokenCredential, options?: PlanetaryComputerProClientOptionalParams);
    readonly data: DataOperations;
    readonly ingestion: IngestionOperations;
    readonly pipeline: Pipeline;
    readonly sharedAccessSignature: SharedAccessSignatureOperations;
    readonly stac: StacOperations;
}

// @public
export interface PlanetaryComputerProClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface Point extends Geometry {
    coordinates: string;
    type: "Point";
}

// @public
export interface Polygon extends Geometry {
    coordinates: number[][][];
    type: "Polygon";
}

// @public
export interface RenderOption {
    conditions?: RenderOptionCondition[];
    description?: string;
    id: string;
    legend?: RenderOptionLegend;
    minZoom?: number;
    name: string;
    options?: string;
    type?: RenderOptionType;
    vectorOptions?: RenderOptionVectorOptions;
}

// @public
export interface RenderOptionCondition {
    property: string;
    value?: string;
}

// @public
export interface RenderOptionLegend {
    labels?: string[];
    scaleFactor?: number;
    trimEnd?: number;
    trimStart?: number;
    type?: LegendConfigType;
}

// @public
export type RenderOptionType = string;

// @public
export interface RenderOptionVectorOptions {
    fillColor?: string;
    filter?: string[];
    sourceLayer: string;
    strokeColor?: string;
    strokeWidth?: number;
    tilejsonKey: string;
}

// @public
export type Resampling = string;

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: PlanetaryComputerProClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export interface SearchOptionsFields {
    exclude?: string[];
    include?: string[];
}

// @public
export interface SharedAccessSignatureGetSignOptionalParams extends OperationOptions {
    durationInMinutes?: number;
}

// @public
export interface SharedAccessSignatureGetTokenOptionalParams extends OperationOptions {
    durationInMinutes?: number;
}

// @public
export interface SharedAccessSignatureOperations {
    getSign: (href: string, options?: SharedAccessSignatureGetSignOptionalParams) => Promise<SharedAccessSignatureSignedLink>;
    getToken: (collectionId: string, options?: SharedAccessSignatureGetTokenOptionalParams) => Promise<SharedAccessSignatureToken>;
    revokeToken: (options?: SharedAccessSignatureRevokeTokenOptionalParams) => Promise<void>;
}

// @public
export interface SharedAccessSignatureRevokeTokenOptionalParams extends OperationOptions {
    durationInMinutes?: number;
}

// @public
export interface SharedAccessSignatureSignedLink {
    expiresOn?: Date;
    href: string;
}

// @public
export interface SharedAccessSignatureToken {
    expiresOn: Date;
    token: string;
}

// @public
export interface SharedAccessSignatureTokenConnection {
    containerUri: string;
    readonly expiration?: Date;
    sharedAccessSignatureToken?: string;
}

// @public
export interface SharedAccessSignatureTokenIngestionSource extends IngestionSource {
    connectionInfo: SharedAccessSignatureTokenConnection;
    // (undocumented)
    kind: "SasToken";
}

// @public
export interface StacAddMosaicOptionalParams extends OperationOptions {
}

// @public
export interface StacAsset {
    additionalProperties?: Record<string, any>;
    constellation?: string;
    created?: Date;
    description?: string;
    gsd?: number;
    href: string;
    instruments?: string[];
    mission?: string;
    platform?: string;
    providers?: StacProvider[];
    roles?: string[];
    title?: string;
    type?: string;
    updated?: Date;
}

// @public
export interface StacAssetData {
    data: AssetMetadata;
    file: FileContents | {
        contents: FileContents;
        contentType?: string;
        filename?: string;
    };
}

// @public
export type StacAssetUrlSigningMode = string;

// @public
export interface StacCatalogCollections {
    collections: StacCollection[];
    links: StacLink[];
}

// @public
export interface StacCollection {
    additionalProperties?: Record<string, any>;
    assets?: Record<string, StacAsset>;
    createdOn?: string;
    description: string;
    extent: StacExtensionExtent;
    id: string;
    itemAssets?: Record<string, StacItemAsset>;
    keywords?: string[];
    license: string;
    links: StacLink[];
    providers?: StacProvider[];
    shortDescription?: string;
    stacExtensions?: string[];
    stacVersion?: string;
    summaries?: Record<string, any>;
    title?: string;
    type?: string;
    updatedOn?: string;
}

// @public
export interface StacCollectionTemporalExtent {
    interval: (Date | null)[][];
}

// @public
export interface StacConformanceClasses {
    conformsTo: string[];
}

// @public
export interface StacContextExtension {
    limit?: number;
    matched?: number;
    returned: number;
}

// @public
export interface StacCreateCollectionAssetOptionalParams extends OperationOptions {
}

// @public
export interface StacCreateCollectionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface StacCreateItemOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface StacCreateOrReplaceCollectionOptionalParams extends OperationOptions {
}

// @public
export interface StacCreateOrReplaceItemOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface StacCreateQueryablesOptionalParams extends OperationOptions {
}

// @public
export interface StacCreateRenderOptionOptionalParams extends OperationOptions {
}

// @public
export interface StacDeleteCollectionAssetOptionalParams extends OperationOptions {
}

// @public
export interface StacDeleteCollectionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface StacDeleteItemOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface StacDeleteMosaicOptionalParams extends OperationOptions {
}

// @public
export interface StacDeleteQueryableOptionalParams extends OperationOptions {
}

// @public
export interface StacDeleteRenderOptionOptionalParams extends OperationOptions {
}

// @public
export interface StacExtensionExtent {
    spatial: StacExtensionSpatialExtent;
    temporal: StacCollectionTemporalExtent;
}

// @public
export interface StacExtensionSpatialExtent {
    boundingBox?: number[][];
}

// @public
export interface StacGetCollectionConfigurationOptionalParams extends OperationOptions {
}

// @public
export interface StacGetCollectionOptionalParams extends OperationOptions {
    durationInMinutes?: number;
    sign?: StacAssetUrlSigningMode;
}

// @public
export interface StacGetCollectionQueryablesOptionalParams extends OperationOptions {
}

// @public
export interface StacGetCollectionThumbnailOptionalParams extends OperationOptions {
}

// @public
export interface StacGetConformanceClassOptionalParams extends OperationOptions {
}

// @public
export interface StacGetItemCollectionOptionalParams extends OperationOptions {
    boundingBox?: string[];
    datetime?: string;
    limit?: number;
}

// @public
export interface StacGetItemOptionalParams extends OperationOptions {
}

// @public
export interface StacGetLandingPageOptionalParams extends OperationOptions {
}

// @public
export interface StacGetMosaicOptionalParams extends OperationOptions {
}

// @public
export interface StacGetPartitionTypeOptionalParams extends OperationOptions {
}

// @public
export interface StacGetRenderOptionOptionalParams extends OperationOptions {
}

// @public
export interface StacGetTileSettingsOptionalParams extends OperationOptions {
}

// @public
export interface StacItem extends StacItemOrStacItemCollection {
    assets: Record<string, StacAsset>;
    boundingBox: number[];
    collection?: string;
    eTag?: string;
    geometry: GeometryUnion;
    id: string;
    properties: StacItemProperties;
    timestamp?: string;
    type: "Feature";
}

// @public
export interface StacItemAsset {
    additionalProperties?: Record<string, any>;
    constellation?: string;
    created?: Date;
    description?: string;
    gsd?: number;
    href?: string;
    instruments?: string[];
    mission?: string;
    platform?: string;
    providers?: StacProvider[];
    roles?: string[];
    title: string;
    type: string;
    updated?: Date;
}

// @public
export interface StacItemBounds {
    bounds: number[];
}

// @public
export interface StacItemCollection extends StacItemOrStacItemCollection {
    boundingBox?: number[];
    context?: StacContextExtension;
    features: StacItem[];
    type: "FeatureCollection";
}

// @public
export interface StacItemOrStacItemCollection {
    createdOn?: string;
    links?: StacLink[];
    shortDescription?: string;
    stacExtensions?: string[];
    stacVersion?: string;
    type: StacModelType;
    updatedOn?: string;
}

// @public
export type StacItemOrStacItemCollectionUnion = StacItemCollection | StacItem | StacItemOrStacItemCollection;

// @public
export interface StacItemPointAsset {
    assets: Record<string, StacAsset>;
    boundingBox: number[];
    collectionId: string;
    id: string;
}

// @public
export interface StacItemProperties {
    additionalProperties?: Record<string, any>;
    constellation?: string;
    created?: Date;
    datetime: string;
    description?: string;
    endDatetime?: Date;
    gsd?: number;
    instruments?: string[];
    mission?: string;
    platform?: string;
    providers?: StacProvider[];
    startDatetime?: Date;
    title?: string;
    updated?: Date;
}

// @public
export interface StacItemStatisticsGeoJson {
    geometry: GeometryUnion;
    properties?: StacItemStatisticsGeoJsonProperties;
    type: FeatureType;
}

// @public
export interface StacItemStatisticsGeoJsonProperties {
    additionalProperties?: Record<string, any>;
    statistics: Record<string, BandStatistics>;
}

// @public
export interface StacLandingPage {
    conformsTo: string[];
    createdOn?: string;
    description: string;
    id: string;
    links: StacLink[];
    shortDescription?: string;
    stacExtensions?: string[];
    stacVersion?: string;
    title?: string;
    type?: string;
    updatedOn?: string;
}

// @public
export interface StacLink {
    body?: Record<string, any>;
    headers?: Record<string, string>;
    href: string;
    hreflang?: string;
    length?: number;
    merge?: boolean;
    method?: string;
    rel?: string;
    title?: string;
    type?: StacLinkType;
}

// @public
export type StacLinkType = string;

// @public
export interface StacListCollectionsOptionalParams extends OperationOptions {
    durationInMinutes?: number;
    sign?: StacAssetUrlSigningMode;
}

// @public
export interface StacListMosaicsOptionalParams extends OperationOptions {
}

// @public
export interface StacListQueryablesOptionalParams extends OperationOptions {
}

// @public
export interface StacListRenderOptionsOptionalParams extends OperationOptions {
}

// @public
export type StacModelType = string;

// @public
export interface StacMosaic {
    cql: Record<string, any>[];
    description?: string;
    id: string;
    name: string;
}

// @public
export interface StacMosaicConfiguration {
    defaultCustomQuery?: Record<string, any>;
    defaultLocation?: DefaultLocation;
    mosaics: StacMosaic[];
    renderOptions: RenderOption[];
}

// @public
export interface StacOperations {
    addMosaic: (collectionId: string, body: StacMosaic, options?: StacAddMosaicOptionalParams) => Promise<StacMosaic>;
    createCollection: (body: StacCollection, options?: StacCreateCollectionOptionalParams) => PollerLike<OperationState<void>, void>;
    createCollectionAsset: (collectionId: string, body: StacAssetData, options?: StacCreateCollectionAssetOptionalParams) => Promise<StacCollection>;
    createItem: (collectionId: string, body: StacItemOrStacItemCollectionUnion, options?: StacCreateItemOptionalParams) => PollerLike<OperationState<void>, void>;
    createOrReplaceCollection: (collectionId: string, body: StacCollection, options?: StacCreateOrReplaceCollectionOptionalParams) => Promise<StacCollection>;
    createOrReplaceItem: (collectionId: string, itemId: string, body: StacItem, options?: StacCreateOrReplaceItemOptionalParams) => PollerLike<OperationState<void>, void>;
    createQueryables: (collectionId: string, body: StacQueryable[], options?: StacCreateQueryablesOptionalParams) => Promise<StacQueryable[]>;
    createRenderOption: (collectionId: string, body: RenderOption, options?: StacCreateRenderOptionOptionalParams) => Promise<RenderOption>;
    deleteCollection: (collectionId: string, options?: StacDeleteCollectionOptionalParams) => PollerLike<OperationState<void>, void>;
    deleteCollectionAsset: (collectionId: string, assetId: string, options?: StacDeleteCollectionAssetOptionalParams) => Promise<StacCollection>;
    deleteItem: (collectionId: string, itemId: string, options?: StacDeleteItemOptionalParams) => PollerLike<OperationState<void>, void>;
    deleteMosaic: (collectionId: string, mosaicId: string, options?: StacDeleteMosaicOptionalParams) => Promise<void>;
    deleteQueryable: (collectionId: string, queryableName: string, options?: StacDeleteQueryableOptionalParams) => Promise<void>;
    deleteRenderOption: (collectionId: string, renderOptionId: string, options?: StacDeleteRenderOptionOptionalParams) => Promise<void>;
    getCollection: (collectionId: string, options?: StacGetCollectionOptionalParams) => Promise<StacCollection>;
    getCollectionConfiguration: (collectionId: string, options?: StacGetCollectionConfigurationOptionalParams) => Promise<UserCollectionSettings>;
    getCollectionQueryables: (collectionId: string, options?: StacGetCollectionQueryablesOptionalParams) => Promise<Record<string, any>>;
    getCollectionThumbnail: (collectionId: string, options?: StacGetCollectionThumbnailOptionalParams) => Promise<Uint8Array>;
    getConformanceClass: (options?: StacGetConformanceClassOptionalParams) => Promise<StacConformanceClasses>;
    getItem: (collectionId: string, itemId: string, options?: StacGetItemOptionalParams) => Promise<StacItem>;
    getItemCollection: (collectionId: string, options?: StacGetItemCollectionOptionalParams) => Promise<StacItemCollection>;
    getLandingPage: (options?: StacGetLandingPageOptionalParams) => Promise<StacLandingPage>;
    getMosaic: (collectionId: string, mosaicId: string, options?: StacGetMosaicOptionalParams) => Promise<StacMosaic>;
    getPartitionType: (collectionId: string, options?: StacGetPartitionTypeOptionalParams) => Promise<PartitionType>;
    getRenderOption: (collectionId: string, renderOptionId: string, options?: StacGetRenderOptionOptionalParams) => Promise<RenderOption>;
    getTileSettings: (collectionId: string, options?: StacGetTileSettingsOptionalParams) => Promise<TileSettings>;
    listCollections: (options?: StacListCollectionsOptionalParams) => Promise<StacCatalogCollections>;
    listMosaics: (collectionId: string, options?: StacListMosaicsOptionalParams) => Promise<StacMosaic[]>;
    listQueryables: (options?: StacListQueryablesOptionalParams) => Promise<Record<string, any>>;
    listRenderOptions: (collectionId: string, options?: StacListRenderOptionsOptionalParams) => Promise<RenderOption[]>;
    replaceCollectionAsset: (collectionId: string, assetId: string, body: StacAssetData, options?: StacReplaceCollectionAssetOptionalParams) => Promise<StacCollection>;
    replaceMosaic: (collectionId: string, mosaicId: string, body: StacMosaic, options?: StacReplaceMosaicOptionalParams) => Promise<StacMosaic>;
    replacePartitionType: (collectionId: string, body: PartitionType, options?: StacReplacePartitionTypeOptionalParams) => Promise<void>;
    replaceQueryable: (collectionId: string, queryableName: string, body: StacQueryable, options?: StacReplaceQueryableOptionalParams) => Promise<StacQueryable>;
    replaceRenderOption: (collectionId: string, renderOptionId: string, body: RenderOption, options?: StacReplaceRenderOptionOptionalParams) => Promise<RenderOption>;
    replaceTileSettings: (collectionId: string, body: TileSettings, options?: StacReplaceTileSettingsOptionalParams) => Promise<TileSettings>;
    search: (body: StacSearchParameters, options?: StacSearchOptionalParams) => Promise<StacItemCollection>;
    updateItem: (collectionId: string, itemId: string, body: StacItem, options?: StacUpdateItemOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export interface StacProvider {
    description?: string;
    name: string;
    roles?: string[];
    url?: string;
}

// @public
export interface StacQueryable {
    createIndex?: boolean;
    dataType?: StacQueryableDefinitionDataType;
    definition: Record<string, any>;
    name: string;
}

// @public
export type StacQueryableDefinitionDataType = string;

// @public
export interface StacReplaceCollectionAssetOptionalParams extends OperationOptions {
}

// @public
export interface StacReplaceMosaicOptionalParams extends OperationOptions {
}

// @public
export interface StacReplacePartitionTypeOptionalParams extends OperationOptions {
}

// @public
export interface StacReplaceQueryableOptionalParams extends OperationOptions {
}

// @public
export interface StacReplaceRenderOptionOptionalParams extends OperationOptions {
}

// @public
export interface StacReplaceTileSettingsOptionalParams extends OperationOptions {
}

// @public
export interface StacSearchOptionalParams extends OperationOptions {
}

// @public
export interface StacSearchParameters {
    boundingBox?: number[];
    collections?: string[];
    conformanceClass?: Record<string, any>;
    datetime?: string;
    durationInMinutes?: number;
    fields?: SearchOptionsFields[];
    filter?: Record<string, any>;
    filterCoordinateReferenceSystem?: string;
    filterLang?: FilterLanguage;
    ids?: string[];
    intersects?: GeometryUnion;
    limit?: number;
    query?: Record<string, any>;
    sign?: StacAssetUrlSigningMode;
    sortBy?: StacSortExtension[];
    token?: string;
}

// @public
export type StacSearchSortingDirection = string;

// @public
export interface StacSortExtension {
    direction: StacSearchSortingDirection;
    field: string;
}

// @public
export interface StacUpdateItemOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export type TerrainAlgorithm = string;

// @public
export type TileAddressingScheme = string;

// @public
export interface TileJsonMetadata {
    attribution?: string;
    bounds?: number[];
    center?: number[];
    data?: string[];
    description?: string;
    grids?: string[];
    legend?: string;
    maxZoom?: number;
    minZoom?: number;
    name?: string;
    scheme?: TileAddressingScheme;
    template?: string;
    tileJson?: string;
    tiles: string[];
    version?: string;
}

// @public
export interface TileMatrix {
    cellSize: number;
    cornerOfOrigin?: TileMatrixCornerOfOrigin;
    description?: string;
    id: string;
    keywords?: string[];
    matrixHeight: number;
    matrixWidth: number;
    pointOfOrigin: number[];
    scaleDenominator: number;
    tileHeight: number;
    tileWidth: number;
    title?: string;
    variableMatrixWidths?: VariableMatrixWidth[];
}

// @public
export type TileMatrixCornerOfOrigin = string;

// @public
export interface TileMatrixSet {
    boundingBox?: TileMatrixSetBoundingBox;
    crs: string;
    description?: string;
    id?: string;
    keywords?: string[];
    orderedAxes?: string[];
    tileMatrices: TileMatrix[];
    title?: string;
    uri?: string;
    wellKnownScaleSet?: string;
}

// @public
export interface TileMatrixSetBoundingBox {
    crs?: string;
    lowerLeft: string[];
    orderedAxes?: string[];
    upperRight: string[];
}

// @public
export interface TilerCoreModelsResponsesPoint {
    bandNames: string[];
    coordinates: number[];
    values: number[];
}

// @public
export type TilerImageFormat = string;

// @public
export interface TilerInfo {
    bandDescriptions?: string[][];
    bandMetadata?: BandMetadataElement[][];
    bounds: number[];
    colorInterpretation?: string[];
    colormap?: Record<string, string[]>;
    coordinateReferenceSystem?: string;
    count?: number;
    driver?: string;
    dtype: string;
    height?: number;
    maxZoom?: number;
    minZoom?: number;
    noDataType?: NoDataType;
    offsets?: number[];
    overviews?: number[];
    scales?: number[];
    width?: number;
}

// @public
export interface TilerInfoGeoJsonFeature {
    boundingBox?: number;
    geometry: GeometryUnion;
    id?: string;
    properties: Record<string, TilerInfo>;
    type: FeatureType;
}

// @public
export interface TilerMosaicSearchRegistrationResponse {
    links?: StacLink[];
    searchId: string;
}

// @public
export interface TilerStacItemStatistics {
    additionalProperties?: Record<string, BandStatistics>;
}

// @public
export interface TilerStacSearchDefinition {
    hash: string;
    lastUsed: Date;
    metadata: MosaicMetadata;
    orderBy: string;
    search: Record<string, any>;
    useCount: number;
    where: string;
}

// @public
export interface TilerStacSearchRegistration {
    links?: StacLink[];
    search: TilerStacSearchDefinition;
}

// @public
export interface TileSettings {
    defaultLocation?: DefaultLocation;
    maxItemsPerTile: number;
    minZoom: number;
}

// @public
export interface UserCollectionSettings {
    mosaicConfiguration: StacMosaicConfiguration;
    tileSettings: TileSettings;
}

// @public
export interface VariableMatrixWidth {
    coalesce: number;
    maxTileRow: number;
    minTileRow: number;
}

// (No @packageDocumentation comment for this package)

```
