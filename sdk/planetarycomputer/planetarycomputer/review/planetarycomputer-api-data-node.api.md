## API Report File for "@azure-rest/planetarycomputer"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Client } from '@azure-rest/core-client';
import type { OperationOptions } from '@azure-rest/core-client';

// @public
export function createStaticImage(context: PlanetaryComputerProContext, collectionId: string, body: ImageParameters, options?: DataCreateStaticImageOptionalParams): Promise<ImageResponse>;

// @public
export function cropGeoJson(context: PlanetaryComputerProContext, collectionId: string, itemId: string, format: string, body: Feature, options?: DataCropGeoJsonOptionalParams): Promise<Uint8Array>;

// @public
export function cropGeoJsonWithDimensions(context: PlanetaryComputerProContext, collectionId: string, itemId: string, width: number, height: number, format: string, body: Feature, options?: DataCropGeoJsonWithDimensionsOptionalParams): Promise<Uint8Array>;

// @public
export interface DataCreateStaticImageOptionalParams extends OperationOptions {
}

// @public
export interface DataCropGeoJsonOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    coordinateReferenceSystem?: string;
    expression?: string;
    height?: number;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
    width?: number;
}

// @public
export interface DataCropGeoJsonWithDimensionsOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    coordinateReferenceSystem?: string;
    expression?: string;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
}

// @public
export interface DataGetAssetStatisticsOptionalParams extends OperationOptions {
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    categorical?: boolean;
    categoriesPixels?: string[];
    expression?: string;
    histogramBins?: string;
    histogramRange?: string;
    maxSize?: number;
    noData?: number;
    percentiles?: number[];
    resampling?: Resampling;
    unscale?: boolean;
}

// @public
export interface DataGetBoundsOptionalParams extends OperationOptions {
}

// @public
export interface DataGetClassMapLegendOptionalParams extends OperationOptions {
    trimEnd?: number;
    trimStart?: number;
}

// @public
export interface DataGetGeoJsonStatisticsOptionalParams extends OperationOptions {
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    categorical?: boolean;
    categoriesPixels?: string[];
    coordinateReferenceSystem?: string;
    expression?: string;
    histogramBins?: string;
    histogramRange?: string;
    maxSize?: number;
    noData?: number;
    percentiles?: number[];
    resampling?: Resampling;
    unscale?: boolean;
}

// @public
export interface DataGetInfoGeoJsonOptionalParams extends OperationOptions {
    assets?: string[];
}

// @public
export interface DataGetIntervalLegendOptionalParams extends OperationOptions {
    trimEnd?: number;
    trimStart?: number;
}

// @public
export interface DataGetItemAssetDetailsOptionalParams extends OperationOptions {
    assets?: string[];
}

// @public
export interface DataGetLegendOptionalParams extends OperationOptions {
    height?: number;
    trimEnd?: number;
    trimStart?: number;
    width?: number;
}

// @public
export interface DataGetMosaicsAssetsForPointOptionalParams extends OperationOptions {
    coordinateReferenceSystem?: string;
    exitWhenFull?: boolean;
    itemsLimit?: number;
    scanLimit?: number;
    skipCovered?: boolean;
    timeLimit?: number;
}

// @public
export interface DataGetMosaicsAssetsForTileOptionalParams extends OperationOptions {
    exitWhenFull?: boolean;
    itemsLimit?: number;
    scanLimit?: number;
    skipCovered?: boolean;
    timeLimit?: number;
}

// @public
export interface DataGetMosaicsSearchInfoOptionalParams extends OperationOptions {
}

// @public
export interface DataGetMosaicsTileJsonOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    collection?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    exitWhenFull?: boolean;
    expression?: string;
    itemsLimit?: number;
    maxZoom?: number;
    minZoom?: number;
    noData?: number;
    pixelSelection?: PixelSelection;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    scanLimit?: number;
    skipCovered?: boolean;
    tileFormat?: TilerImageFormat;
    tileScale?: number;
    timeLimit?: number;
    unscale?: boolean;
}

// @public
export interface DataGetMosaicsTileOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    collection?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    exitWhenFull?: boolean;
    expression?: string;
    itemsLimit?: number;
    noData?: number;
    pixelSelection?: PixelSelection;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    scanLimit?: number;
    skipCovered?: boolean;
    timeLimit?: number;
    unscale?: boolean;
}

// @public
export interface DataGetMosaicsWmtsCapabilitiesOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    expression?: string;
    maxZoom?: number;
    minZoom?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    tileFormat?: TilerImageFormat;
    tileScale?: number;
    unscale?: boolean;
}

// @public
export interface DataGetPartOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    coordinateReferenceSystem?: string;
    dstCrs?: string;
    expression?: string;
    height?: number;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
    width?: number;
}

// @public
export interface DataGetPartWithDimensionsOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    coordinateReferenceSystem?: string;
    dstCrs?: string;
    expression?: string;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
}

// @public
export interface DataGetPointOptionalParams extends OperationOptions {
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    coordinateReferenceSystem?: string;
    expression?: string;
    noData?: number;
    resampling?: Resampling;
    unscale?: boolean;
}

// @public
export interface DataGetPreviewOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    dstCrs?: string;
    expression?: string;
    format?: TilerImageFormat;
    height?: number;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
    width?: number;
}

// @public
export interface DataGetPreviewWithFormatOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    dstCrs?: string;
    expression?: string;
    height?: number;
    maxSize?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    unscale?: boolean;
    width?: number;
}

// @public
export interface DataGetStaticImageOptionalParams extends OperationOptions {
}

// @public
export interface DataGetTileJsonOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    expression?: string;
    maxZoom?: number;
    minZoom?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    tileFormat?: TilerImageFormat;
    tileScale?: number;
    unscale?: boolean;
}

// @public
export interface DataGetTileMatrixDefinitionsOptionalParams extends OperationOptions {
}

// @public
export interface DataGetTileOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    expression?: string;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    subdatasetBands?: string[];
    subdatasetName?: string;
    unscale?: boolean;
}

// @public
export interface DataGetWmtsCapabilitiesOptionalParams extends OperationOptions {
    algorithm?: TerrainAlgorithm;
    algorithmParams?: string;
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    buffer?: string;
    colorFormula?: string;
    colorMap?: string;
    colorMapName?: ColorMapNames;
    expression?: string;
    maxZoom?: number;
    minZoom?: number;
    noData?: number;
    resampling?: Resampling;
    rescale?: string[];
    returnMask?: boolean;
    tileFormat?: TilerImageFormat;
    tileScale?: number;
    unscale?: boolean;
}

// @public
export interface DataListAvailableAssetsOptionalParams extends OperationOptions {
}

// @public
export interface DataListStatisticsOptionalParams extends OperationOptions {
    assetAsBand?: boolean;
    assetBandIndices?: string;
    assets?: string[];
    categorical?: boolean;
    categoriesPixels?: string[];
    expression?: string;
    histogramBins?: string;
    histogramRange?: string;
    maxSize?: number;
    noData?: number;
    percentiles?: number[];
    resampling?: Resampling;
    unscale?: boolean;
}

// @public
export interface DataListTileMatricesOptionalParams extends OperationOptions {
}

// @public
export interface DataRegisterMosaicsSearchOptionalParams extends OperationOptions {
    boundingBox?: number;
    collections?: string[];
    datetime?: string;
    filter?: Record<string, any>;
    filterLanguage?: FilterLanguage;
    ids?: string[];
    intersects?: GeometryUnion;
    metadata?: MosaicMetadata;
    query?: Record<string, any>;
    sortBy?: StacSortExtension[];
}

// @public
export function getAssetStatistics(context: PlanetaryComputerProContext, collectionId: string, itemId: string, options?: DataGetAssetStatisticsOptionalParams): Promise<Record<string, Record<string, BandStatistics>>>;

// @public
export function getBounds(context: PlanetaryComputerProContext, collectionId: string, itemId: string, options?: DataGetBoundsOptionalParams): Promise<StacItemBounds>;

// @public
export function getClassMapLegend(context: PlanetaryComputerProContext, classmapName: string, options?: DataGetClassMapLegendOptionalParams): Promise<Record<string, any>>;

// @public
export function getGeoJsonStatistics(context: PlanetaryComputerProContext, collectionId: string, itemId: string, body: Feature, options?: DataGetGeoJsonStatisticsOptionalParams): Promise<StacItemStatisticsGeoJson>;

// @public
export function getInfoGeoJson(context: PlanetaryComputerProContext, collectionId: string, itemId: string, options?: DataGetInfoGeoJsonOptionalParams): Promise<TilerInfoGeoJsonFeature>;

// @public
export function getIntervalLegend(context: PlanetaryComputerProContext, classmapName: string, options?: DataGetIntervalLegendOptionalParams): Promise<IntervalLegendsElement[][]>;

// @public
export function getItemAssetDetails(context: PlanetaryComputerProContext, collectionId: string, itemId: string, options?: DataGetItemAssetDetailsOptionalParams): Promise<Record<string, TilerInfo>>;

// @public
export function getLegend(context: PlanetaryComputerProContext, colorMapName: string, options?: DataGetLegendOptionalParams): Promise<Uint8Array>;

// @public
export function getMosaicsAssetsForPoint(context: PlanetaryComputerProContext, searchId: string, longitude: number, latitude: number, options?: DataGetMosaicsAssetsForPointOptionalParams): Promise<StacItemPointAsset[]>;

// @public
export function getMosaicsAssetsForTile(context: PlanetaryComputerProContext, searchId: string, tileMatrixSetId: string, collectionId: string, z: number, x: number, y: number, options?: DataGetMosaicsAssetsForTileOptionalParams): Promise<any[]>;

// @public
export function getMosaicsSearchInfo(context: PlanetaryComputerProContext, searchId: string, options?: DataGetMosaicsSearchInfoOptionalParams): Promise<TilerStacSearchRegistration>;

// @public
export function getMosaicsTile(context: PlanetaryComputerProContext, searchId: string, tileMatrixSetId: string, z: number, x: number, y: number, scale: number, format: string, options?: DataGetMosaicsTileOptionalParams): Promise<Uint8Array>;

// @public
export function getMosaicsTileJson(context: PlanetaryComputerProContext, searchId: string, tileMatrixSetId: string, options?: DataGetMosaicsTileJsonOptionalParams): Promise<TileJsonMetadata>;

// @public
export function getMosaicsWmtsCapabilities(context: PlanetaryComputerProContext, searchId: string, tileMatrixSetId: string, options?: DataGetMosaicsWmtsCapabilitiesOptionalParams): Promise<Uint8Array>;

// @public
export function getPart(context: PlanetaryComputerProContext, collectionId: string, itemId: string, minx: number, miny: number, maxx: number, maxy: number, format: string, options?: DataGetPartOptionalParams): Promise<Uint8Array>;

// @public
export function getPartWithDimensions(context: PlanetaryComputerProContext, collectionId: string, itemId: string, minx: number, miny: number, maxx: number, maxy: number, width: number, height: number, format: string, options?: DataGetPartWithDimensionsOptionalParams): Promise<Uint8Array>;

// @public
export function getPoint(context: PlanetaryComputerProContext, collectionId: string, itemId: string, longitude: number, latitude: number, options?: DataGetPointOptionalParams): Promise<TilerCoreModelsResponsesPoint>;

// @public
export function getPreview(context: PlanetaryComputerProContext, collectionId: string, itemId: string, options?: DataGetPreviewOptionalParams): Promise<Uint8Array>;

// @public
export function getPreviewWithFormat(context: PlanetaryComputerProContext, collectionId: string, itemId: string, format: string, options?: DataGetPreviewWithFormatOptionalParams): Promise<Uint8Array>;

// @public
export function getStaticImage(context: PlanetaryComputerProContext, collectionId: string, id: string, options?: DataGetStaticImageOptionalParams): Promise<Uint8Array>;

// @public
export function getTile(context: PlanetaryComputerProContext, collectionId: string, itemId: string, tileMatrixSetId: string, z: number, x: number, y: number, scale: number, format: string, options?: DataGetTileOptionalParams): Promise<Uint8Array>;

// @public
export function getTileJson(context: PlanetaryComputerProContext, collectionId: string, itemId: string, tileMatrixSetId: string, options?: DataGetTileJsonOptionalParams): Promise<TileJsonMetadata>;

// @public
export function getTileMatrixDefinitions(context: PlanetaryComputerProContext, tileMatrixSetId: string, options?: DataGetTileMatrixDefinitionsOptionalParams): Promise<TileMatrixSet>;

// @public
export function getWmtsCapabilities(context: PlanetaryComputerProContext, collectionId: string, itemId: string, tileMatrixSetId: string, options?: DataGetWmtsCapabilitiesOptionalParams): Promise<Uint8Array>;

// @public
export function listAvailableAssets(context: PlanetaryComputerProContext, collectionId: string, itemId: string, options?: DataListAvailableAssetsOptionalParams): Promise<string[]>;

// @public
export function listStatistics(context: PlanetaryComputerProContext, collectionId: string, itemId: string, options?: DataListStatisticsOptionalParams): Promise<TilerStacItemStatistics>;

// @public
export function listTileMatrices(context: PlanetaryComputerProContext, options?: DataListTileMatricesOptionalParams): Promise<string[]>;

// @public
export function registerMosaicsSearch(context: PlanetaryComputerProContext, options?: DataRegisterMosaicsSearchOptionalParams): Promise<TilerMosaicSearchRegistrationResponse>;

// (No @packageDocumentation comment for this package)

```
