/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";
import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { setContinuationToken } from "./pagingHelper";
import { tracingClient } from "./tracing";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
import {
  AnomalyDetectorOptionalParams,
  ModelSnapshot,
  ListMultivariateModelNextOptionalParams,
  ListMultivariateModelOptionalParams,
  ListMultivariateModelResponse,
  DetectRequest,
  DetectEntireSeriesOptionalParams,
  DetectEntireSeriesResponse,
  DetectLastPointOptionalParams,
  DetectLastPointOperationResponse,
  DetectChangePointRequest,
  DetectChangePointOptionalParams,
  DetectChangePointOperationResponse,
  ModelInfo,
  TrainMultivariateModelOptionalParams,
  TrainMultivariateModelResponse,
  GetMultivariateModelOptionalParams,
  GetMultivariateModelResponse,
  DeleteMultivariateModelOptionalParams,
  DetectionRequest,
  DetectAnomalyOptionalParams,
  DetectAnomalyResponse,
  GetDetectionResultOptionalParams,
  GetDetectionResultResponse,
  ExportModelOptionalParams,
  ExportModelResponse,
  LastDetectionRequest,
  LastDetectAnomalyOptionalParams,
  LastDetectAnomalyResponse,
  ListMultivariateModelNextResponse
} from "./models";

/// <reference lib="esnext.asynciterable" />
export class AnomalyDetector extends coreClient.ServiceClient {
  endpoint: string;
  apiVersion: string;

  /**
   * Initializes a new instance of the AnomalyDetector class.
   * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
   *                 https://westus2.api.cognitive.microsoft.com).
   * @param options The parameter options
   */
  constructor(endpoint: string, options?: AnomalyDetectorOptionalParams) {
    if (endpoint === undefined) {
      throw new Error("'endpoint' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults: AnomalyDetectorOptionalParams = {
      requestContentType: "application/json; charset=utf-8"
    };

    const packageDetails = `azsdk-js-ai-anomaly-detector/3.0.0-beta.6`;
    const userAgentPrefix =
      options.userAgentOptions && options.userAgentOptions.userAgentPrefix
        ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
        : `${packageDetails}`;

    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      endpoint:
        options.endpoint ??
        options.baseUri ??
        "{Endpoint}/anomalydetector/{ApiVersion}"
    };
    super(optionsWithDefaults);
    // Parameter assignments
    this.endpoint = endpoint;

    // Assigning values to Constant parameters
    this.apiVersion = options.apiVersion || "v1.1-preview.1";
  }

  /**
   * List models of a subscription
   * @param options The options parameters.
   */
  public listMultivariateModel(
    options?: ListMultivariateModelOptionalParams
  ): PagedAsyncIterableIterator<ModelSnapshot> {
    const iter = this.listMultivariateModelPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listMultivariateModelPagingPage(options, settings);
      }
    };
  }

  private async *listMultivariateModelPagingPage(
    options?: ListMultivariateModelOptionalParams,
    settings?: PageSettings
  ): AsyncIterableIterator<ModelSnapshot[]> {
    let result: ListMultivariateModelResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listMultivariateModel(options);
      let page = result.models || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listMultivariateModelNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      let page = result.models || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listMultivariateModelPagingAll(
    options?: ListMultivariateModelOptionalParams
  ): AsyncIterableIterator<ModelSnapshot> {
    for await (const page of this.listMultivariateModelPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * This operation generates a model with an entire series, each point is detected with the same model.
   * With this method, points before and after a certain point are used to determine whether it is an
   * anomaly. The entire detection can give user an overall status of the time series.
   * @param body Time series points and period if needed. Advanced model parameters can also be set in
   *             the request.
   * @param options The options parameters.
   */
  async detectEntireSeries(
    body: DetectRequest,
    options?: DetectEntireSeriesOptionalParams
  ): Promise<DetectEntireSeriesResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.detectEntireSeries",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { body, options },
          detectEntireSeriesOperationSpec
        ) as Promise<DetectEntireSeriesResponse>;
      }
    );
  }

  /**
   * This operation generates a model using points before the latest one. With this method, only
   * historical points are used to determine whether the target point is an anomaly. The latest point
   * detecting operation matches the scenario of real-time monitoring of business metrics.
   * @param body Time series points and period if needed. Advanced model parameters can also be set in
   *             the request.
   * @param options The options parameters.
   */
  async detectLastPoint(
    body: DetectRequest,
    options?: DetectLastPointOptionalParams
  ): Promise<DetectLastPointOperationResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.detectLastPoint",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { body, options },
          detectLastPointOperationSpec
        ) as Promise<DetectLastPointOperationResponse>;
      }
    );
  }

  /**
   * Evaluate change point score of every series point
   * @param body Time series points and granularity is needed. Advanced model parameters can also be set
   *             in the request if needed.
   * @param options The options parameters.
   */
  async detectChangePoint(
    body: DetectChangePointRequest,
    options?: DetectChangePointOptionalParams
  ): Promise<DetectChangePointOperationResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.detectChangePoint",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { body, options },
          detectChangePointOperationSpec
        ) as Promise<DetectChangePointOperationResponse>;
      }
    );
  }

  /**
   * Create and train a multivariate anomaly detection model. The request must include a source parameter
   * to indicate an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri).
   * All time-series used in generate the model must be zipped into one single file. Each time-series
   * will be in a single CSV file in which the first column is timestamp and the second column is value.
   * @param body Training request
   * @param options The options parameters.
   */
  async trainMultivariateModel(
    body: ModelInfo,
    options?: TrainMultivariateModelOptionalParams
  ): Promise<TrainMultivariateModelResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.trainMultivariateModel",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { body, options },
          trainMultivariateModelOperationSpec
        ) as Promise<TrainMultivariateModelResponse>;
      }
    );
  }

  /**
   * List models of a subscription
   * @param options The options parameters.
   */
  private async _listMultivariateModel(
    options?: ListMultivariateModelOptionalParams
  ): Promise<ListMultivariateModelResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector._listMultivariateModel",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { options },
          listMultivariateModelOperationSpec
        ) as Promise<ListMultivariateModelResponse>;
      }
    );
  }

  /**
   * Get detailed information of multivariate model, including the training status and variables used in
   * the model.
   * @param modelId Model identifier.
   * @param options The options parameters.
   */
  async getMultivariateModel(
    modelId: string,
    options?: GetMultivariateModelOptionalParams
  ): Promise<GetMultivariateModelResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.getMultivariateModel",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { modelId, options },
          getMultivariateModelOperationSpec
        ) as Promise<GetMultivariateModelResponse>;
      }
    );
  }

  /**
   * Delete an existing multivariate model according to the modelId
   * @param modelId Model identifier.
   * @param options The options parameters.
   */
  async deleteMultivariateModel(
    modelId: string,
    options?: DeleteMultivariateModelOptionalParams
  ): Promise<void> {
    return tracingClient.withSpan(
      "AnomalyDetector.deleteMultivariateModel",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { modelId, options },
          deleteMultivariateModelOperationSpec
        ) as Promise<void>;
      }
    );
  }

  /**
   * Submit detection multivariate anomaly task with the trained model of modelId, the input schema
   * should be the same with the training request. Thus request will be complete asynchronously and will
   * return a resultId for querying the detection result.The request should be a source link to indicate
   * an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri). All
   * time-series used in generate the model must be zipped into one single file. Each time-series will be
   * as follows: the first column is timestamp and the second column is value.
   * @param modelId Model identifier.
   * @param body Detect anomaly request
   * @param options The options parameters.
   */
  async detectAnomaly(
    modelId: string,
    body: DetectionRequest,
    options?: DetectAnomalyOptionalParams
  ): Promise<DetectAnomalyResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.detectAnomaly",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { modelId, body, options },
          detectAnomalyOperationSpec
        ) as Promise<DetectAnomalyResponse>;
      }
    );
  }

  /**
   * Get multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync api
   * @param resultId Result identifier.
   * @param options The options parameters.
   */
  async getDetectionResult(
    resultId: string,
    options?: GetDetectionResultOptionalParams
  ): Promise<GetDetectionResultResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.getDetectionResult",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { resultId, options },
          getDetectionResultOperationSpec
        ) as Promise<GetDetectionResultResponse>;
      }
    );
  }

  /**
   * Export multivariate anomaly detection model based on modelId
   * @param modelId Model identifier.
   * @param options The options parameters.
   */
  async exportModel(
    modelId: string,
    options?: ExportModelOptionalParams
  ): Promise<ExportModelResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.exportModel",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { modelId, options },
          exportModelOperationSpec
        ) as Promise<ExportModelResponse>;
      }
    );
  }

  /**
   * Synchronized API for anomaly detection.
   * @param modelId Model identifier.
   * @param body Request for last detection.
   * @param options The options parameters.
   */
  async lastDetectAnomaly(
    modelId: string,
    body: LastDetectionRequest,
    options?: LastDetectAnomalyOptionalParams
  ): Promise<LastDetectAnomalyResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector.lastDetectAnomaly",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { modelId, body, options },
          lastDetectAnomalyOperationSpec
        ) as Promise<LastDetectAnomalyResponse>;
      }
    );
  }

  /**
   * ListMultivariateModelNext
   * @param nextLink The nextLink from the previous successful call to the ListMultivariateModel method.
   * @param options The options parameters.
   */
  private async _listMultivariateModelNext(
    nextLink: string,
    options?: ListMultivariateModelNextOptionalParams
  ): Promise<ListMultivariateModelNextResponse> {
    return tracingClient.withSpan(
      "AnomalyDetector._listMultivariateModelNext",
      options ?? {},
      async (options) => {
        return this.sendOperationRequest(
          { nextLink, options },
          listMultivariateModelNextOperationSpec
        ) as Promise<ListMultivariateModelNextResponse>;
      }
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const detectEntireSeriesOperationSpec: coreClient.OperationSpec = {
  path: "/timeseries/entire/detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.DetectEntireResponse
    },
    default: {
      bodyMapper: Mappers.AnomalyDetectorError,
      headersMapper: Mappers.AnomalyDetectorDetectEntireSeriesExceptionHeaders
    }
  },
  requestBody: Parameters.body,
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const detectLastPointOperationSpec: coreClient.OperationSpec = {
  path: "/timeseries/last/detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.DetectLastPointResponse
    },
    default: {
      bodyMapper: Mappers.AnomalyDetectorError,
      headersMapper: Mappers.AnomalyDetectorDetectLastPointExceptionHeaders
    }
  },
  requestBody: Parameters.body,
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const detectChangePointOperationSpec: coreClient.OperationSpec = {
  path: "/timeseries/changepoint/detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.DetectChangePointResponse
    },
    default: {
      bodyMapper: Mappers.AnomalyDetectorError,
      headersMapper: Mappers.AnomalyDetectorDetectChangePointExceptionHeaders
    }
  },
  requestBody: Parameters.body1,
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const trainMultivariateModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models",
  httpMethod: "POST",
  responses: {
    201: {
      headersMapper: Mappers.AnomalyDetectorTrainMultivariateModelHeaders
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorTrainMultivariateModelExceptionHeaders
    }
  },
  requestBody: Parameters.body2,
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listMultivariateModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ModelList
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorListMultivariateModelExceptionHeaders
    }
  },
  queryParameters: [Parameters.skip, Parameters.top],
  urlParameters: [Parameters.endpoint, Parameters.apiVersion],
  headerParameters: [Parameters.accept],
  serializer
};
const getMultivariateModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.Model
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.AnomalyDetectorGetMultivariateModelExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteMultivariateModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorDeleteMultivariateModelExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const detectAnomalyOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}/detect",
  httpMethod: "POST",
  responses: {
    201: {
      headersMapper: Mappers.AnomalyDetectorDetectAnomalyHeaders
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.AnomalyDetectorDetectAnomalyExceptionHeaders
    }
  },
  requestBody: Parameters.body3,
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getDetectionResultOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/results/{resultId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DetectionResult
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.AnomalyDetectorGetDetectionResultExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.resultId
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const exportModelOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}/export",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.AnomalyDetectorExportModelExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.accept1],
  serializer
};
const lastDetectAnomalyOperationSpec: coreClient.OperationSpec = {
  path: "/multivariate/models/{modelId}/last/detect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.LastDetectionResult
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper: Mappers.AnomalyDetectorLastDetectAnomalyExceptionHeaders
    }
  },
  requestBody: Parameters.body4,
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.modelId
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listMultivariateModelNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ModelList
    },
    default: {
      bodyMapper: Mappers.ErrorResponse,
      headersMapper:
        Mappers.AnomalyDetectorListMultivariateModelNextExceptionHeaders
    }
  },
  urlParameters: [
    Parameters.endpoint,
    Parameters.apiVersion,
    Parameters.nextLink
  ],
  headerParameters: [Parameters.accept],
  serializer
};
