{"version":3,"file":"jsonSchemaSerializer.js","sourceRoot":"","sources":["../../src/jsonSchemaSerializer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  DeserializeOptions,\n  JsonSchemaSerializerOptions,\n  MessageAdapter,\n  MessageContent,\n} from \"./models.js\";\nimport type { SchemaDescription, SchemaRegistry } from \"@azure/schema-registry\";\nimport { KnownSchemaFormats } from \"@azure/schema-registry\";\nimport { isMessageContent } from \"./utility.js\";\nimport { errorWithCause, wrapError } from \"./errors.js\";\nimport { LRUCache } from \"lru-cache\";\nimport LRUCacheOptions = LRUCache.Options;\nimport { logger } from \"./logger.js\";\n\nconst jsonMimeType = \"application/json\";\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\ninterface CacheEntry {\n  /** Schema ID */\n  id: string;\n  /** Schema string */\n  schema: string;\n}\ninterface SchemaObject {\n  id?: string;\n  $id?: string;\n  $schema?: string;\n}\nfunction getSchemaObject(schema: string): SchemaObject {\n  return wrapError(\n    () => JSON.parse(schema),\n    `Parsing Json schema failed:\\n\\n\\t${schema}\\n\\nSee 'cause' for more details.`,\n  );\n}\n\nconst cacheOptions: LRUCacheOptions<string, any, unknown> = {\n  max: 128,\n  /**\n   * This is needed in order to specify `sizeCalculation` but we do not intend\n   * to limit the size just yet.\n   */\n  maxSize: Number.MAX_VALUE,\n  sizeCalculation: (_value: any, key: string) => {\n    return key.length;\n  },\n};\n\n/**\n * Json serializer that obtains schemas from a schema registry and does not\n * pack schemas into its payloads.\n */\nexport class JsonSchemaSerializer<MessageT = MessageContent> {\n  /**\n   * Creates a new serializer.\n   *\n   * @param client - Schema Registry where schemas are registered and obtained.\n   *                 Usually this is a SchemaRegistryClient instance.\n   */\n  constructor(client: SchemaRegistry, options?: JsonSchemaSerializerOptions<MessageT>) {\n    this.registry = client;\n    this.schemaGroup = options?.groupName;\n    this.messageAdapter = options?.messageAdapter;\n  }\n\n  private readonly schemaGroup?: string;\n  private readonly registry: SchemaRegistry;\n  private readonly messageAdapter?: MessageAdapter<MessageT>;\n  private readonly cacheIdByDefinition = new LRUCache<string, string>(cacheOptions);\n  private readonly cacheById = new LRUCache<string, string>(cacheOptions);\n\n  /**\n   * serializes the value parameter according to the input schema and creates a message\n   * with the serialized data.\n   *\n   * @param value - The value to serialize.\n   * @param schema - The Json schema to use.\n   * @returns A new message with the serialized value. The structure of message is\n   * constrolled by the message factory option.\n   * @throws {@link Error}\n   * Thrown if the schema can not be parsed or the value does not match the schema.\n   */\n  async serialize(value: unknown, schema: string): Promise<MessageT> {\n    const entry = await this.getSchemaByDefinition(schema);\n    const data = wrapError(\n      () => encoder.encode(JSON.stringify(value)),\n      `Json serialization failed. See 'cause' for more details. Schema ID: ${entry.id}`,\n    );\n    const contentType = `${jsonMimeType}+${entry.id}`;\n    return this.messageAdapter\n      ? this.messageAdapter.produce({\n          contentType,\n          data,\n        })\n      : /**\n         * If no message consumer was provided, then a MessageContent will be\n         * returned. This should work because the MessageT type parameter defaults\n         * to MessageContent.\n         */\n        ({\n          data,\n          contentType,\n        } as MessageContent as unknown as MessageT);\n  }\n\n  /**\n   * Deserializes the payload of the message using the schema ID in the content type\n   * field if no schema was provided.\n   *\n   * @param message - The message with the payload to be deserialized.\n   * @returns The deserialized value.\n   * @throws {@link Error}\n   * Thrown if the deserialization failed, e.g. because reader and writer schemas are incompatible.\n   */\n  async deserialize<T>(message: MessageT, options?: DeserializeOptions): Promise<T> {\n    const { data, contentType } = convertMessage(message, this.messageAdapter);\n    const schemaId = getSchemaId(contentType);\n    const schema = await this.getSchemaById(schemaId);\n    const returnedMessage = wrapError(\n      () => JSON.parse(decoder.decode(data)),\n      `Json deserialization failed with schema ID (${schemaId}). See 'cause' for more details.`,\n    );\n    const validate = options?.validateCallback;\n    if (validate) {\n      wrapError(\n        () => validate(returnedMessage, schema),\n        `Json validation failed. See 'cause' for more details. Schema ID: ${schemaId}`,\n      );\n    }\n    return returnedMessage as T;\n  }\n\n  private async getSchemaById(schemaId: string): Promise<string> {\n    const cached = this.cacheById.get(schemaId);\n    if (cached) {\n      return cached;\n    }\n    const schemaResponse = await this.registry.getSchema(schemaId);\n    if (!schemaResponse) {\n      throw new Error(`Schema with ID '${schemaId}' not found.`);\n    }\n\n    if (!schemaResponse.properties.format.match(/^json$/i)) {\n      throw new Error(\n        `Schema with ID '${schemaResponse.properties.id}' has format '${schemaResponse.properties.format}', not 'json'.`,\n      );\n    }\n    return this.cache(schemaResponse.definition, schemaId).schema;\n  }\n\n  private async getSchemaByDefinition(definition: string): Promise<CacheEntry> {\n    const schemaId = this.cacheIdByDefinition.get(definition);\n    if (schemaId) {\n      return { id: schemaId, schema: definition };\n    }\n    if (!this.schemaGroup) {\n      throw new Error(\n        \"Schema group must have been specified in the constructor options when the client was created in order to serialize.\",\n      );\n    }\n    const schemaObj = getSchemaObject(definition);\n    const description: SchemaDescription = {\n      groupName: this.schemaGroup,\n      name: getSchemaName(schemaObj),\n      format: KnownSchemaFormats.Json,\n      definition,\n    };\n    let id: string;\n\n    try {\n      id = (await this.registry.getSchemaProperties(description)).id;\n    } catch (e) {\n      if ((e as any).statusCode === 404) {\n        throw errorWithCause(\n          `Schema '${description.name}' not found in registry group '${description.groupName}', or not found to have matching definition.`,\n          e as Error,\n        );\n      } else {\n        throw e;\n      }\n    }\n\n    return this.cache(definition, id);\n  }\n\n  private cache(schema: string, id: string): CacheEntry {\n    const entry = { schema, id };\n    this.cacheIdByDefinition.set(schema, id);\n    this.cacheById.set(id, schema);\n    logger.verbose(\n      `Cache entry added or updated. Total number of entries: ${this.cacheIdByDefinition.size}; Total schema length ${this.cacheIdByDefinition.calculatedSize}`,\n    );\n    return entry;\n  }\n}\n\nfunction getSchemaId(contentType: string): string {\n  const contentTypeParts = contentType.split(\"+\");\n  if (contentTypeParts.length !== 2) {\n    throw new Error(\"Content type was not in the expected format of MIME type + schema ID\");\n  }\n  if (contentTypeParts[0] !== jsonMimeType) {\n    throw new Error(\n      `Received content of type ${contentTypeParts[0]} but an json serializer may only be used on content that is of '${jsonMimeType}' type`,\n    );\n  }\n  return contentTypeParts[1];\n}\n\nfunction convertMessage<MessageT>(\n  message: MessageT,\n  adapter?: MessageAdapter<MessageT>,\n): MessageContent {\n  const messageConsumer = adapter?.consume;\n  if (messageConsumer) {\n    return messageConsumer(message);\n  } else if (isMessageContent(message)) {\n    return message;\n  } else {\n    throw new Error(\n      `Expected either a message adapter to be provided to the serializer or the input message to have data and contentType fields`,\n    );\n  }\n}\n\nfunction getSchemaName(schema: SchemaObject): string {\n  const id = schema.$id || schema.id;\n  if (!id) {\n    throw new Error(\"Schema must have an ID.\");\n  }\n  return id;\n}\n"]}