/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";
import * as Parameters from "./models/parameters";
import * as Models from "./models";
import * as Mappers from "./models/mappers";
import { SchemaRegistryClientContext } from "./schemaRegistryClientContext";
import {
  SchemaRegistryClientOptionalParams,
  SchemaRegistryClientGetSchemaByIdResponse,
  SchemaRegistryClientGetIdBySchemaContentResponse,
  SchemaRegistryClientRegisterSchemaResponse
} from "./models";

class SchemaRegistryClient extends SchemaRegistryClientContext {
  /**
   * Initializes a new instance of the SchemaRegistryClient class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host: string, options?: SchemaRegistryClientOptionalParams) {
    super($host, options);
  }

  /**
   * Get schema by ID.  Azure Schema Registry guarantees that ID is unique within a namespace.
   * @param schemaId schema ID referencing specific schema in registry namespace
   * @param options The options parameters.
   */
  getSchemaById(
    schemaId: string,
    options?: coreHttp.OperationOptions
  ): Promise<SchemaRegistryClientGetSchemaByIdResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.sendOperationRequest(
      { schemaId, options: operationOptions },
      getSchemaByIdOperationSpec
    ) as Promise<SchemaRegistryClientGetSchemaByIdResponse>;
  }

  /**
   * Get ID for schema with matching byte content and serialization format.
   * @param groupName schema group
   * @param schemaName schema name
   * @param serializationType serialization type for schema being registered
   * @param schemaContent schema content
   * @param options The options parameters.
   */
  getIdBySchemaContent(
    groupName: string,
    schemaName: string,
    serializationType: string,
    schemaContent: string,
    options?: coreHttp.OperationOptions
  ): Promise<SchemaRegistryClientGetIdBySchemaContentResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.sendOperationRequest(
      {
        groupName,
        schemaName,
        serializationType,
        schemaContent,
        options: operationOptions
      },
      getIdBySchemaContentOperationSpec
    ) as Promise<SchemaRegistryClientGetIdBySchemaContentResponse>;
  }

  /**
   * Register new schema. If schema of specified name does not exist in specified group, schema is
   * created at version 1. If schema of specified name exists already in specified group, schema is
   * created at latest version + 1.
   *
   * @param groupName schema group
   * @param schemaName schema name
   * @param serializationType serialization type for schema being registered
   * @param schemaContent schema content
   * @param options The options parameters.
   */
  registerSchema(
    groupName: string,
    schemaName: string,
    serializationType: string,
    schemaContent: string,
    options?: coreHttp.OperationOptions
  ): Promise<SchemaRegistryClientRegisterSchemaResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.sendOperationRequest(
      {
        groupName,
        schemaName,
        serializationType,
        schemaContent,
        options: operationOptions
      },
      registerSchemaOperationSpec
    ) as Promise<SchemaRegistryClientRegisterSchemaResponse>;
  }
}
// Operation Specifications

const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const getSchemaByIdOperationSpec: coreHttp.OperationSpec = {
  path: "/$schemagroups/getSchemaById/{schema-id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: { type: { name: "String" } },
      headersMapper: Mappers.SchemaRegistryClientGetSchemaByIdHeaders
    }
  },
  urlParameters: [Parameters.$host, Parameters.schemaId],
  serializer
};
const getIdBySchemaContentOperationSpec: coreHttp.OperationSpec = {
  path: "/$schemagroups/{group-name}/schemas/{schema-name}",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.SchemaId,
      headersMapper: Mappers.SchemaRegistryClientGetIdBySchemaContentHeaders
    }
  },
  requestBody: Parameters.schemaContent,
  urlParameters: [
    Parameters.$host,
    Parameters.groupName,
    Parameters.schemaName
  ],
  headerParameters: [Parameters.contentType, Parameters.serializationType],
  mediaType: "json",
  serializer
};
const registerSchemaOperationSpec: coreHttp.OperationSpec = {
  path: "/$schemagroups/{group-name}/schemas/{schema-name}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SchemaId,
      headersMapper: Mappers.SchemaRegistryClientRegisterSchemaHeaders
    }
  },
  requestBody: Parameters.schemaContent,
  urlParameters: [
    Parameters.$host,
    Parameters.groupName,
    Parameters.schemaName
  ],
  headerParameters: [Parameters.contentType, Parameters.serializationType],
  mediaType: "json",
  serializer
};

// Operation Specifications

export {
  SchemaRegistryClient,
  SchemaRegistryClientContext,
  Models as SchemaRegistryModels,
  Mappers as SchemaRegistryMappers
};
