/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { GeneratedSchemaRegistryClient } from "../generatedSchemaRegistryClient";
import {
  SchemaGetByIdResponse,
  SerializationType,
  SchemaQueryIdByContentResponse,
  SchemaRegisterResponse
} from "../models";

/**
 * Class representing a Schema.
 */
export class Schema {
  private readonly client: GeneratedSchemaRegistryClient;

  /**
   * Initialize a new instance of the class Schema class.
   * @param client Reference to the service client
   */
  constructor(client: GeneratedSchemaRegistryClient) {
    this.client = client;
  }

  /**
   * Gets a registered schema by its unique ID.  Azure Schema Registry guarantees that ID is unique
   * within a namespace.
   * @param schemaId References specific schema in registry namespace.
   * @param options The options parameters.
   */
  getById(
    schemaId: string,
    options?: coreHttp.OperationOptions
  ): Promise<SchemaGetByIdResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      { schemaId, options: operationOptions },
      getByIdOperationSpec
    ) as Promise<SchemaGetByIdResponse>;
  }

  /**
   * Gets the ID referencing an existing schema within the specified schema group, as matched by schema
   * content comparison.
   * @param groupName Schema group under which schema is registered.  Group's serialization type should
   *                  match the serialization type specified in the request.
   * @param schemaName Name of the registered schema.
   * @param xSchemaType Serialization type for the schema being registered.
   * @param schemaContent String representation of the registered schema.
   * @param options The options parameters.
   */
  queryIdByContent(
    groupName: string,
    schemaName: string,
    xSchemaType: SerializationType,
    schemaContent: string,
    options?: coreHttp.OperationOptions
  ): Promise<SchemaQueryIdByContentResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      {
        groupName,
        schemaName,
        xSchemaType,
        schemaContent,
        options: operationOptions
      },
      queryIdByContentOperationSpec
    ) as Promise<SchemaQueryIdByContentResponse>;
  }

  /**
   * Register new schema. If schema of specified name does not exist in specified group, schema is
   * created at version 1. If schema of specified name exists already in specified group, schema is
   * created at latest version + 1.
   *
   * @param groupName Schema group under which schema should be registered.  Group's serialization type
   *                  should match the serialization type specified in the request.
   * @param schemaName Name of schema being registered.
   * @param xSchemaType Serialization type for the schema being registered.
   * @param schemaContent String representation of the schema being registered.
   * @param options The options parameters.
   */
  register(
    groupName: string,
    schemaName: string,
    xSchemaType: SerializationType,
    schemaContent: string,
    options?: coreHttp.OperationOptions
  ): Promise<SchemaRegisterResponse> {
    const operationOptions: coreHttp.RequestOptionsBase = coreHttp.operationOptionsToRequestOptionsBase(
      options || {}
    );
    return this.client.sendOperationRequest(
      {
        groupName,
        schemaName,
        xSchemaType,
        schemaContent,
        options: operationOptions
      },
      registerOperationSpec
    ) as Promise<SchemaRegisterResponse>;
  }
}
// Operation Specifications

const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const getByIdOperationSpec: coreHttp.OperationSpec = {
  path: "/$schemagroups/getSchemaById/{schema-id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: { type: { name: "String" } },
      headersMapper: Mappers.SchemaGetByIdHeaders
    },
    default: {
      bodyMapper: { type: { name: "String" } }
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.schemaId],
  serializer
};
const queryIdByContentOperationSpec: coreHttp.OperationSpec = {
  path: "/$schemagroups/{group-name}/schemas/{schema-name}",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.SchemaId,
      headersMapper: Mappers.SchemaQueryIdByContentHeaders
    },
    default: {
      bodyMapper: { type: { name: "String" } }
    }
  },
  requestBody: Parameters.schemaContent,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.endpoint,
    Parameters.groupName,
    Parameters.schemaName
  ],
  headerParameters: [Parameters.contentType, Parameters.xSchemaType],
  mediaType: "json",
  serializer
};
const registerOperationSpec: coreHttp.OperationSpec = {
  path: "/$schemagroups/{group-name}/schemas/{schema-name}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SchemaId,
      headersMapper: Mappers.SchemaRegisterHeaders
    },
    default: {
      bodyMapper: { type: { name: "String" } }
    }
  },
  requestBody: Parameters.schemaContent,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.endpoint,
    Parameters.groupName,
    Parameters.schemaName
  ],
  headerParameters: [Parameters.contentType, Parameters.xSchemaType],
  mediaType: "json",
  serializer
};
