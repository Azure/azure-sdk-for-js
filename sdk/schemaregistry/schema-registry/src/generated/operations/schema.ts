/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { Schema } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { GeneratedSchemaRegistryClientContext } from "../generatedSchemaRegistryClientContext";
import {
  SchemaGetByIdOptionalParams,
  SchemaGetByIdResponse,
  SerializationType,
  SchemaQueryIdByContentOptionalParams,
  SchemaQueryIdByContentResponse,
  SchemaRegisterOptionalParams,
  SchemaRegisterResponse
} from "../models";

/** Class representing a Schema. */
export class SchemaImpl implements Schema {
  private readonly client: GeneratedSchemaRegistryClientContext;

  /**
   * Initialize a new instance of the class Schema class.
   * @param client Reference to the service client
   */
  constructor(client: GeneratedSchemaRegistryClientContext) {
    this.client = client;
  }

  /**
   * Gets a registered schema by its unique ID.  Azure Schema Registry guarantees that ID is unique
   * within a namespace.
   * @param schemaId References specific schema in registry namespace.
   * @param options The options parameters.
   */
  getById(
    schemaId: string,
    options?: SchemaGetByIdOptionalParams
  ): Promise<SchemaGetByIdResponse> {
    return this.client.sendOperationRequest(
      { schemaId, options },
      getByIdOperationSpec
    );
  }

  /**
   * Gets the ID referencing an existing schema within the specified schema group, as matched by schema
   * content comparison.
   * @param groupName Schema group under which schema is registered.  Group's serialization type should
   *                  match the serialization type specified in the request.
   * @param schemaName Name of the registered schema.
   * @param serializationType Serialization type for the schema being registered.
   * @param schemaContent String representation (UTF-8) of the registered schema.
   * @param options The options parameters.
   */
  queryIdByContent(
    groupName: string,
    schemaName: string,
    serializationType: SerializationType,
    schemaContent: string,
    options?: SchemaQueryIdByContentOptionalParams
  ): Promise<SchemaQueryIdByContentResponse> {
    return this.client.sendOperationRequest(
      { groupName, schemaName, serializationType, schemaContent, options },
      queryIdByContentOperationSpec
    );
  }

  /**
   * Register new schema. If schema of specified name does not exist in specified group, schema is
   * created at version 1. If schema of specified name exists already in specified group, schema is
   * created at latest version + 1.
   *
   * @param groupName Schema group under which schema should be registered.  Group's serialization type
   *                  should match the serialization type specified in the request.
   * @param schemaName Name of schema being registered.
   * @param serializationType Serialization type for the schema being registered.
   * @param schemaContent String representation (UTF-8) of the schema being registered.
   * @param options The options parameters.
   */
  register(
    groupName: string,
    schemaName: string,
    serializationType: SerializationType,
    schemaContent: string,
    options?: SchemaRegisterOptionalParams
  ): Promise<SchemaRegisterResponse> {
    return this.client.sendOperationRequest(
      { groupName, schemaName, serializationType, schemaContent, options },
      registerOperationSpec
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const getByIdOperationSpec: coreClient.OperationSpec = {
  path: "/$schemagroups/getSchemaById/{schema-id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: { type: { name: "String" } },
      headersMapper: Mappers.SchemaGetByIdHeaders
    },
    default: {
      bodyMapper: { type: { name: "String" } }
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.schemaId],
  headerParameters: [Parameters.accept],
  serializer
};
const queryIdByContentOperationSpec: coreClient.OperationSpec = {
  path: "/$schemagroups/{group-name}/schemas/{schema-name}",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.SchemaId,
      headersMapper: Mappers.SchemaQueryIdByContentHeaders
    },
    default: {
      bodyMapper: { type: { name: "String" } }
    }
  },
  requestBody: Parameters.schemaContent,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.endpoint,
    Parameters.groupName,
    Parameters.schemaName
  ],
  headerParameters: [
    Parameters.contentType,
    Parameters.accept1,
    Parameters.serializationType
  ],
  mediaType: "text",
  serializer
};
const registerOperationSpec: coreClient.OperationSpec = {
  path: "/$schemagroups/{group-name}/schemas/{schema-name}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.SchemaId,
      headersMapper: Mappers.SchemaRegisterHeaders
    },
    default: {
      bodyMapper: { type: { name: "String" } }
    }
  },
  requestBody: Parameters.schemaContent,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.endpoint,
    Parameters.groupName,
    Parameters.schemaName
  ],
  headerParameters: [
    Parameters.contentType,
    Parameters.accept1,
    Parameters.serializationType
  ],
  mediaType: "text",
  serializer
};
