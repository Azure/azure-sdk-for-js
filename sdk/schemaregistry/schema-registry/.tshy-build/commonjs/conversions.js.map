{"version":3,"file":"conversions.js","sourceRoot":"","sources":["../../src/conversions.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;AAiClC,0DAaC;AAOD,4CAIC;AAED,sDAWC;AA5DD,MAAM,SAAS,GAAG,YAAY,CAAC;AAC/B,MAAM,WAAW,GAAG,eAAe,CAAC;AACpC,MAAM,iBAAiB,GAAG,GAAG,SAAS,KAAK,WAAW,EAAE,CAAC;AACzD,MAAM,YAAY,GAAG,QAAQ,CAAC;AAe9B;;;;GAIG;AACI,KAAK,UAAU,uBAAuB,CAC3C,QAAmC,EACnC,YAAoB;IAEpB,OAAO;QACL,4EAA4E;QAC5E,0CAA0C;QAC1C,EAAE,EAAE,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAE;QAClC,MAAM,EAAE,YAAY;QACpB,SAAS,EAAE,QAAQ,CAAC,OAAO,CAAC,mBAAmB,CAAE;QACjD,IAAI,EAAE,QAAQ,CAAC,OAAO,CAAC,aAAa,CAAE;QACtC,OAAO,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,gBAAgB,CAAE,CAAC;KACrD,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,SAAgB,gBAAgB,CAAC,MAAc;IAC7C,OAAO,MAAM,CAAC,WAAW,EAAE,KAAK,YAAY,CAAC,WAAW,EAAE;QACxD,CAAC,CAAC,iBAAiB;QACnB,CAAC,CAAE,mCAAmC,MAAM,EAAU,CAAC;AAC3D,CAAC;AAEM,KAAK,UAAU,qBAAqB,CAAC,QAAiC;IAC3E,OAAO;QACL,UAAU,EAAE,OAAO,QAAQ,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC;QAC7F,UAAU,EAAE;YACV,EAAE,EAAE,QAAQ,CAAC,OAAO,CAAC,WAAW,CAAE;YAClC,MAAM,EAAE,sBAAsB,CAAC,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAE,CAAC;YACjE,SAAS,EAAE,QAAQ,CAAC,OAAO,CAAC,mBAAmB,CAAE;YACjD,IAAI,EAAE,QAAQ,CAAC,OAAO,CAAC,aAAa,CAAE;YACtC,OAAO,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,gBAAgB,CAAE,CAAC;SACrD;KACF,CAAC;AACJ,CAAC;AAED,SAAS,sBAAsB,CAAC,WAAmB;IACjD,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,GAAG,SAAS,QAAQ,WAAW,EAAE,CAAC,CAAC;QAAE,OAAO,YAAY,CAAC;IAC1F,MAAM,KAAK,GAAG,uBAAuB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;IACxD,MAAM,YAAY,GAAG,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAG,CAAC,CAAC,CAAC;IAChC,IAAI,YAAY,EAAE,CAAC;QACjB,OAAO,YAAY,CAAC;IACtB,CAAC;SAAM,CAAC;QACN,OAAO,WAAW,CAAC;IACrB,CAAC;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  GetSchemaById200Response,\n  GetSchemaByVersion200Response,\n  GetSchemaPropertiesByContent204Response,\n  RegisterSchema204Response,\n} from \"./responses.js\";\nimport type { SchemaProperties, Schema, SchemaContentTypeValues } from \"./models.js\";\n\nconst textPlain = \"text/plain\";\nconst charsetutf8 = \"charset=utf-8\";\nconst customContentType = `${textPlain}; ${charsetutf8}`;\nconst customFormat = \"Custom\";\n\n/**\n * Union of generated client's response that return schema ID\n */\ntype GeneratedSchemaIdResponse =\n  | RegisterSchema204Response\n  | GetSchemaPropertiesByContent204Response\n  | GetSchemaByVersion200Response;\n\n/**\n * Union of generated client's responses that return schema definition.\n */\ntype GeneratedSchemaResponse = GetSchemaById200Response | GetSchemaByVersion200Response;\n\n/**\n * Converts generated client's response to SchemaIdentityResponse.\n *\n * @internal\n */\nexport async function convertSchemaIdResponse(\n  response: GeneratedSchemaIdResponse,\n  schemaFormat: string,\n): Promise<SchemaProperties> {\n  return {\n    // `!`s here because server is required to return these on success, but that\n    // is not modeled by the generated client.\n    id: response.headers[\"schema-id\"]!,\n    format: schemaFormat,\n    groupName: response.headers[\"schema-group-name\"]!,\n    name: response.headers[\"schema-name\"]!,\n    version: Number(response.headers[\"schema-version\"]!),\n  };\n}\n\n/**\n * @internal\n * @param format - schema format\n * @returns corresponding content-type value\n */\nexport function buildContentType(format: string): SchemaContentTypeValues {\n  return format.toLowerCase() === customFormat.toLowerCase()\n    ? customContentType\n    : (`application/json; serialization=${format}` as any);\n}\n\nexport async function convertSchemaResponse(response: GeneratedSchemaResponse): Promise<Schema> {\n  return {\n    definition: typeof response.body === \"string\" ? response.body : JSON.stringify(response.body),\n    properties: {\n      id: response.headers[\"schema-id\"]!,\n      format: mapContentTypeToFormat(response.headers[\"content-type\"]!),\n      groupName: response.headers[\"schema-group-name\"]!,\n      name: response.headers[\"schema-name\"]!,\n      version: Number(response.headers[\"schema-version\"]!),\n    },\n  };\n}\n\nfunction mapContentTypeToFormat(contentType: string): string {\n  if (contentType.match(new RegExp(`${textPlain};\\\\s?${charsetutf8}`))) return customFormat;\n  const parts = /.*serialization=(.*)$/.exec(contentType);\n  const schemaFormat = parts?.[1];\n  if (schemaFormat) {\n    return schemaFormat;\n  } else {\n    return contentType;\n  }\n}\n"]}