## API Report File for "@azure/core-amqp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { AccessToken } from '@azure/core-auth';
import { AmqpError } from 'rhea-promise';
import { Message as AmqpMessage } from 'rhea-promise';
import { MessageHeader as AmqpMessageHeader } from 'rhea-promise';
import { MessageProperties as AmqpMessageProperties } from 'rhea-promise';
import AsyncLock from 'async-lock';
import { Connection } from 'rhea-promise';
import { Dictionary } from 'rhea-promise';
import { isAmqpError } from 'rhea-promise';
import { isTokenCredential } from '@azure/core-auth';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { ReqResLink } from 'rhea-promise';
import { Sender } from 'rhea-promise';
import { SenderOptions } from 'rhea-promise';
import { Session } from 'rhea-promise';
import { TokenCredential } from '@azure/core-auth';
import { WebSocketImpl } from 'rhea-promise';

export { AccessToken }

export { AmqpMessage }

export { AmqpMessageHeader }

export { AmqpMessageProperties }

export { AsyncLock }

// @public
export interface AsyncLockOptions {
    domainReentrant?: boolean;
    maxPending?: number;
    Promise?: any;
    timeout?: number;
}

// @public
export class CbsClient {
    constructor(connection: Connection, connectionLock: string);
    readonly cbsLock: string;
    close(): Promise<void>;
    connection: Connection;
    readonly connectionLock: string;
    readonly endpoint: string;
    init(): Promise<void>;
    negotiateClaim(audience: string, tokenObject: AccessToken, tokenType: TokenType): Promise<CbsResponse>;
    remove(): void;
    readonly replyTo: string;
}

// @public
export interface CbsResponse {
    // (undocumented)
    correlationId: string;
    // (undocumented)
    satusDescription: string;
    // (undocumented)
    statusCode: string;
}

// @public
export enum ConditionErrorNameMapper {
    "amqp:connection:forced" = "ConnectionForcedError",
    "amqp:connection:framing-error" = "FramingError",
    "amqp:connection:redirect" = "ConnectionRedirectError",
    "amqp:decode-error" = "DecodeError",
    "amqp:frame-size-too-small" = "FrameSizeTooSmallError",
    "amqp:illegal-state" = "IllegalStateError",
    "amqp:internal-error" = "InternalServerError",
    "amqp:invalid-field" = "InvalidFieldError",
    "amqp:link:detach-forced" = "DetachForcedError",
    "amqp:link:message-size-exceeded" = "MessageTooLargeError",
    "amqp:link:redirect" = "LinkRedirectError",
    "amqp:link:stolen" = "ReceiverDisconnectedError",
    "amqp:link:transfer-limit-exceeded" = "TransferLimitExceededError",
    "amqp:not-allowed" = "InvalidOperationError",
    "amqp:not-found" = "ServiceCommunicationError",
    "amqp:not-implemented" = "NotImplementedError",
    "amqp:precondition-failed" = "PreconditionFailedError",
    "amqp:resource-deleted" = "ResourceDeletedError",
    "amqp:resource-limit-exceeded" = "QuotaExceededError",
    "amqp:resource-locked" = "ResourceLockedError",
    "amqp:session:errant-link" = "ErrantLinkError",
    "amqp:session:handle-in-use" = "HandleInUseError",
    "amqp:session:unattached-handle" = "UnattachedHandleError",
    "amqp:session:window-violation" = "SessionWindowViolationError",
    "amqp:unauthorized-access" = "UnauthorizedError",
    "client.sender:not-enough-link-credit" = "SenderBusyError",
    "com.microsoft:address-already-in-use" = "AddressAlreadyInUseError",
    "com.microsoft:argument-error" = "ArgumentError",
    "com.microsoft:argument-out-of-range" = "ArgumentOutOfRangeError",
    "com.microsoft:auth-failed" = "UnauthorizedError",
    "com.microsoft:entity-already-exists" = "MessagingEntityAlreadyExistsError",
    "com.microsoft:entity-disabled" = "MessagingEntityDisabledError",
    "com.microsoft:message-lock-lost" = "MessageLockLostError",
    "com.microsoft:message-not-found" = "MessageNotFoundError",
    "com.microsoft:message-wait-timeout" = "MessageWaitTimeout",
    "com.microsoft:no-matching-subscription" = "NoMatchingSubscriptionError",
    "com.microsoft:operation-cancelled" = "OperationCancelledError",
    "com.microsoft:partition-not-owned" = "PartitionNotOwnedError",
    "com.microsoft:precondition-failed" = "PreconditionFailedError",
    "com.microsoft:publisher-revoked" = "PublisherRevokedError",
    "com.microsoft:relay-not-found" = "RelayNotFoundError",
    "com.microsoft:server-busy" = "ServerBusyError",
    "com.microsoft:session-cannot-be-locked" = "SessionCannotBeLockedError",
    "com.microsoft:session-lock-lost" = "SessionLockLostError",
    "com.microsoft:store-lock-lost" = "StoreLockLostError",
    "com.microsoft:timeout" = "ServiceUnavailableError",
    "system:error" = "SystemError"
}

// @public
export enum ConditionStatusMapper {
    // (undocumented)
    "amqp:link:message-size-exceeded" = 403,
    // (undocumented)
    "amqp:link:stolen" = 410,
    // (undocumented)
    "amqp:not-allowed" = 400,
    // (undocumented)
    "amqp:not-found" = 404,
    // (undocumented)
    "amqp:not-implemented" = 501,
    // (undocumented)
    "amqp:resource-limit-exceeded" = 403,
    // (undocumented)
    "amqp:unauthorized-access" = 401,
    // (undocumented)
    "com.microsoft:argument-error" = 400,
    // (undocumented)
    "com.microsoft:argument-out-of-range" = 400,
    // (undocumented)
    "com.microsoft:entity-already-exists" = 409,
    // (undocumented)
    "com.microsoft:entity-disabled" = 400,
    // (undocumented)
    "com.microsoft:message-lock-lost" = 410,
    // (undocumented)
    "com.microsoft:no-matching-subscription" = 500,
    // (undocumented)
    "com.microsoft:partition-not-owned" = 410,
    // (undocumented)
    "com.microsoft:publisher-revoked" = 401,
    // (undocumented)
    "com.microsoft:server-busy" = 503,
    // (undocumented)
    "com.microsoft:session-cannot-be-locked" = 410,
    // (undocumented)
    "com.microsoft:session-lock-lost" = 410,
    // (undocumented)
    "com.microsoft:store-lock-lost" = 410,
    // (undocumented)
    "com.microsoft:timeout" = 408
}

// @public
export interface ConnectionConfig {
    connectionString: string;
    endpoint: string;
    entityPath?: string;
    host: string;
    sharedAccessKey: string;
    sharedAccessKeyName: string;
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
    webSocketEndpointPath?: string;
}

// @public
export const ConnectionConfig: {
    create(connectionString: string, path?: string | undefined): ConnectionConfig;
    validate(config: ConnectionConfig, options?: ConnectionConfigOptions | undefined): void;
};

// @public
export interface ConnectionConfigOptions {
    isEntityPathRequired?: boolean;
}

// @public
export interface ConnectionContextBase {
    cbsSession: CbsClient;
    readonly config: ConnectionConfig;
    connection: Connection;
    connectionId: string;
    connectionLock: string;
    dataTransformer: DataTransformer;
    negotiateClaimLock: string;
    refreshConnection: () => void;
    readonly tokenCredential: SharedKeyCredential | TokenCredential;
    wasConnectionCloseCalled: boolean;
}

// @public (undocumented)
export const ConnectionContextBase: {
    create(parameters: CreateConnectionContextBaseParameters): ConnectionContextBase;
};

// @public
export interface ConnectionProperties {
    product: string;
    userAgent: string;
    version: string;
}

// @public (undocumented)
export const Constants: {
    readonly associatedLinkName: "associated-link-name";
    readonly partitionKey: "x-opt-partition-key";
    readonly sequenceNumber: "x-opt-sequence-number";
    readonly enqueueSequenceNumber: "x-opt-enqueue-sequence-number";
    readonly enqueuedTime: "x-opt-enqueued-time";
    readonly scheduledEnqueueTime: "x-opt-scheduled-enqueue-time";
    readonly offset: "x-opt-offset";
    readonly lockedUntil: "x-opt-locked-until";
    readonly partitionIdName: "x-opt-partition-id";
    readonly publisher: "x-opt-publisher-name";
    readonly viaPartitionKey: "x-opt-via-partition-key";
    readonly deadLetterSource: "x-opt-deadletter-source";
    readonly enqueuedTimeAnnotation: "amqp.annotation.x-opt-enqueued-time";
    readonly offsetAnnotation: "amqp.annotation.x-opt-offset";
    readonly sequenceNumberAnnotation: "amqp.annotation.x-opt-sequence-number";
    readonly guidSize: 16;
    readonly message: "message";
    readonly error: "error";
    readonly statusCode: "status-code";
    readonly statusDescription: "status-description";
    readonly errorCondition: "error-condition";
    readonly management: "$management";
    readonly partition: "partition";
    readonly partitionId: "partitionId";
    readonly readOperation: "READ";
    readonly TLS: "tls";
    readonly establishConnection: "establishConnection";
    readonly defaultConsumerGroup: "$default";
    readonly eventHub: "eventhub";
    readonly cbsEndpoint: "$cbs";
    readonly cbsReplyTo: "cbs";
    readonly operationPutToken: "put-token";
    readonly aadEventHubsAudience: "https://eventhubs.azure.net/";
    readonly aadEventHubsScope: "https://eventhubs.azure.net//.default";
    readonly aadServiceBusAudience: "https://servicebus.azure.net/";
    readonly aadServiceBusScope: "https://servicebus.azure.net//.default";
    readonly maxUserAgentLength: 512;
    readonly vendorString: "com.microsoft";
    readonly attachEpoch: "com.microsoft:epoch";
    readonly receiverIdentifierName: "com.microsoft:receiver-name";
    readonly enableReceiverRuntimeMetricName: "com.microsoft:enable-receiver-runtime-metric";
    readonly timespan: "com.microsoft:timespan";
    readonly uri: "com.microsoft:uri";
    readonly dateTimeOffset: "com.microsoft:datetime-offset";
    readonly sessionFilterName: "com.microsoft:session-filter";
    readonly receiverError: "receiver_error";
    readonly senderError: "sender_error";
    readonly sessionError: "session_error";
    readonly connectionError: "connection_error";
    readonly defaultOperationTimeoutInMs: 60000;
    readonly defaultConnectionIdleTimeoutInMs: 60000;
    readonly managementRequestKey: "managementRequest";
    readonly negotiateCbsKey: "negotiateCbs";
    readonly negotiateClaim: "negotiateClaim";
    readonly ensureContainerAndBlob: "ensureContainerAndBlob";
    readonly defaultPrefetchCount: 1000;
    readonly reconnectLimit: 100;
    readonly maxMessageIdLength: 128;
    readonly maxPartitionKeyLength: 128;
    readonly maxSessionIdLength: 128;
    readonly pathDelimiter: "/";
    readonly ruleNameMaximumLength: 50;
    readonly maximumSqlFilterStatementLength: 1024;
    readonly maximumSqlRuleActionStatementLength: 1024;
    readonly maxDeadLetterReasonLength: 4096;
    readonly maxDurationValue: 922337203685477;
    readonly minDurationValue: -922337203685477;
    readonly maxAbsoluteExpiryTime: number;
    readonly aadTokenValidityMarginInMs: 5000;
    readonly connectionReconnectDelay: 300;
    readonly defaultMaxRetries: 3;
    readonly defaultMaxRetriesForConnection: 150;
    readonly defaultDelayBetweenOperationRetriesInMs: 30000;
    readonly defaultMaxDelayForExponentialRetryInMs: 90000;
    readonly receiverSettleMode: "receiver-settle-mode";
    readonly dispositionStatus: "disposition-status";
    readonly fromSequenceNumber: "from-sequence-number";
    readonly messageCount: "message-count";
    readonly lockTokens: "lock-tokens";
    readonly messageIdMapKey: "message-id";
    readonly sequenceNumberMapKey: "sequence-number";
    readonly lockTokenMapKey: "lock-token";
    readonly sessionIdMapKey: "session-id";
    readonly sequenceNumbers: "sequence-numbers";
    readonly deadLetterReason: "deadletter-reason";
    readonly deadLetterDescription: "deadletter-description";
    readonly propertiesToModify: "properties-to-modify";
    readonly deadLetterName: "com.microsoft:dead-letter";
    readonly trackingId: "com.microsoft:tracking-id";
    readonly serverTimeout: "com.microsoft:server-timeout";
    readonly operations: {
        readonly putToken: "put-token";
        readonly read: "READ";
        readonly cancelScheduledMessage: "com.microsoft:cancel-scheduled-message";
        readonly scheduleMessage: "com.microsoft:schedule-message";
        readonly renewLock: "com.microsoft:renew-lock";
        readonly peekMessage: "com.microsoft:peek-message";
        readonly receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number";
        readonly updateDisposition: "com.microsoft:update-disposition";
        readonly renewSessionLock: "com.microsoft:renew-session-lock";
        readonly setSessionState: "com.microsoft:set-session-state";
        readonly getSessionState: "com.microsoft:get-session-state";
        readonly enumerateSessions: "com.microsoft:get-message-sessions";
        readonly addRule: "com.microsoft:add-rule";
        readonly removeRule: "com.microsoft:remove-rule";
        readonly enumerateRules: "com.microsoft:enumerate-rules";
    };
    readonly descriptorCodes: {
        readonly ruleDescriptionList: 1335734829060;
        readonly sqlFilterList: 83483426822;
        readonly correlationFilterList: 83483426825;
        readonly sqlRuleActionList: 1335734829062;
        readonly trueFilterList: 83483426823;
        readonly falseFilterList: 83483426824;
    };
};

// @public
export interface CreateConnectionContextBaseParameters {
    config: ConnectionConfig;
    connectionProperties: ConnectionProperties;
    dataTransformer?: DataTransformer;
    isEntityPathRequired?: boolean;
    operationTimeoutInMs?: number;
    tokenCredential?: SharedKeyCredential | TokenCredential;
}

// @public
export interface DataTransformer {
    decode: (body: any) => any;
    encode: (body: any) => any;
}

// @public
export class DefaultDataTransformer implements DataTransformer {
    decode(body: any): any;
    encode(body: any): any;
}

// @public
export const defaultLock: AsyncLock;

// @public
export function delay<T>(delayInMs: number, abortSignal?: AbortSignalLike, abortErrorMsg?: string, value?: T): Promise<T>;

export { Dictionary }

// @public
export enum ErrorNameConditionMapper {
    AddressAlreadyInUseError = "com.microsoft:address-already-in-use",
    ArgumentError = "com.microsoft:argument-error",
    ArgumentOutOfRangeError = "com.microsoft:argument-out-of-range",
    ConnectionForcedError = "amqp:connection:forced",
    ConnectionRedirectError = "amqp:connection:redirect",
    DecodeError = "amqp:decode-error",
    DetachForcedError = "amqp:link:detach-forced",
    ErrantLinkError = "amqp:session:errant-link",
    FrameSizeTooSmallError = "amqp:frame-size-too-small",
    FramingError = "amqp:connection:framing-error",
    HandleInUseError = "amqp:session:handle-in-use",
    IllegalStateError = "amqp:illegal-state",
    InternalServerError = "amqp:internal-error",
    InvalidFieldError = "amqp:invalid-field",
    InvalidOperationError = "amqp:not-allowed",
    LinkRedirectError = "amqp:link:redirect",
    MessageLockLostError = "com.microsoft:message-lock-lost",
    MessageNotFoundError = "com.microsoft:message-not-found",
    MessageTooLargeError = "amqp:link:message-size-exceeded",
    MessageWaitTimeout = "com.microsoft:message-wait-timeout",
    MessagingEntityAlreadyExistsError = "com.microsoft:entity-already-exists",
    MessagingEntityDisabledError = "com.microsoft:entity-disabled",
    NoMatchingSubscriptionError = "com.microsoft:no-matching-subscription",
    NotImplementedError = "amqp:not-implemented",
    OperationCancelledError = "com.microsoft:operation-cancelled",
    PartitionNotOwnedError = "com.microsoft:partition-not-owned",
    PreconditionFailedError = "amqp:precondition-failed",
    PublisherRevokedError = "com.microsoft:publisher-revoked",
    QuotaExceededError = "amqp:resource-limit-exceeded",
    ReceiverDisconnectedError = "amqp:link:stolen",
    RelayNotFoundError = "com.microsoft:relay-not-found",
    ResourceDeletedError = "amqp:resource-deleted",
    ResourceLockedError = "amqp:resource-locked",
    SenderBusyError = "client.sender:not-enough-link-credit",
    ServerBusyError = "com.microsoft:server-busy",
    ServiceCommunicationError = "amqp:not-found",
    ServiceUnavailableError = "com.microsoft:timeout",
    SessionCannotBeLockedError = "com.microsoft:session-cannot-be-locked",
    SessionLockLostError = "com.microsoft:session-lock-lost",
    SessionWindowViolationError = "amqp:session:window-violation",
    StoreLockLostError = "com.microsoft:store-lock-lost",
    SystemError = "system:error",
    TransferLimitExceededError = "amqp:link:transfer-limit-exceeded",
    UnattachedHandleError = "amqp:session:unattached-handle",
    UnauthorizedError = "amqp:unauthorized-access"
}

// @public
export interface EventHubConnectionConfig extends ConnectionConfig {
    entityPath: string;
    getManagementAddress(): string;
    getManagementAudience(): string;
    getReceiverAddress(partitionId: string | number, consumergroup?: string): string;
    getReceiverAudience(partitionId: string | number, consumergroup?: string): string;
    getSenderAddress(partitionId?: string | number): string;
    getSenderAudience(partitionId?: string | number): string;
}

// @public
export const EventHubConnectionConfig: {
    create(connectionString: string, path?: string | undefined): EventHubConnectionConfig;
    createFromConnectionConfig(config: ConnectionConfig): EventHubConnectionConfig;
    validate(config: EventHubConnectionConfig): void;
};

// @public
export interface EventHubConnectionStringModel {
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    Endpoint: string;
    // (undocumented)
    EntityPath?: string;
    // (undocumented)
    SharedAccessKey: string;
    // (undocumented)
    SharedAccessKeyName: string;
}

// @public (undocumented)
export function executePromisesSequentially(promiseFactories: Array<any>, kickstart?: any): Promise<any>;

// @public
export type Func<T, V> = (a: T) => V;

// @public
export function getNewAsyncLock(options?: AsyncLockOptions): AsyncLock;

// @public (undocumented)
export interface IotHubConnectionConfig {
    connectionString: string;
    deviceId?: string;
    entityPath: string;
    host: string;
    hostName: string;
    sharedAccessKey: string;
    sharedAccessKeyName: string;
}

// @public
export const IotHubConnectionConfig: {
    create(connectionString: string, path?: string | undefined): IotHubConnectionConfig;
    validate(config: IotHubConnectionConfig): void;
    convertToEventHubConnectionConfig(iotHubConfig: IotHubConnectionConfig): EventHubConnectionConfig;
};

// @public
export interface IotHubConnectionStringModel {
    // (undocumented)
    DeviceId?: string;
    // (undocumented)
    HostName: string;
    // (undocumented)
    SharedAccessKey: string;
    // (undocumented)
    SharedAccessKeyName: string;
}

// @public
export class IotSharedKeyCredential extends SharedKeyCredential {
    getToken(audience: string): AccessToken;
}

export { isAmqpError }

// @public
export function isIotHubConnectionString(connectionString: string): boolean;

// @public
export function isMessagingError(error: Error | MessagingError): error is MessagingError;

// @public
export const isNode: boolean;

// @public
export function isSystemError(err: any): err is NetworkSystemError;

export { isTokenCredential }

// @public
export const logger: import("@azure/logger").AzureLogger;

// @public
export type MessageErrorCodes = "AddressAlreadyInUseError" | "StoreLockLostError" | "NoMatchingSubscriptionError" | "PartitionNotOwnedError" | "PublisherRevokedError" | "MessagingEntityAlreadyExistsError" | "MessagingEntityDisabledError" | "MessageLockLostError" | "SessionLockLostError" | "SessionCannotBeLockedError" | "InternalServerError" | "ServiceCommunicationError" | "MessageNotFoundError" | "RelayNotFoundError" | "NotImplementedError" | "InvalidOperationError" | "QuotaExceededError" | "UnauthorizedError" | "ServiceUnavailableError" | "MessageWaitTimeout" | "ArgumentOutOfRangeError" | "PreconditionFailedError" | "DecodeError" | "InvalidFieldError" | "ResourceLockedError" | "ResourceDeletedError" | "IllegalStateError" | "FrameSizeTooSmallError" | "DetachForcedError" | "TransferLimitExceededError" | "MessageTooLargeError" | "LinkRedirectError" | "ReceiverDisconnectedError" | "SessionWindowViolationError" | "ErrantLinkError" | "HandleInUseError" | "UnattachedHandleError" | "ConnectionForcedError" | "FramingError" | "ConnectionRedirectError" | "ServerBusyError" | "ArgumentError" | "OperationCancelledError" | "SenderBusyError" | "SystemError";

// @public
export interface MessageHeader {
    deliveryCount?: number;
    durable?: boolean;
    firstAcquirer?: boolean;
    priority?: number;
    ttl?: number;
}

// @public
export const MessageHeader: {
    toAmqpMessageHeader(props: MessageHeader): AmqpMessageHeader;
    fromAmqpMessageHeader(props: AmqpMessageHeader): MessageHeader;
};

// @public
export interface MessageProperties {
    absoluteExpiryTime?: number;
    contentEncoding?: string;
    contentType?: string;
    correlationId?: string | number | Buffer;
    creationTime?: number;
    groupId?: string;
    groupSequence?: number;
    messageId?: string | number | Buffer;
    replyTo?: string;
    replyToGroupId?: string;
    subject?: string;
    to?: string;
    userId?: string;
}

// @public
export const MessageProperties: {
    toAmqpMessageProperties(props: MessageProperties): AmqpMessageProperties;
    fromAmqpMessageProperties(props: AmqpMessageProperties): MessageProperties;
};

// @public
export class MessagingError extends Error {
    constructor(message: string, originalError?: Error);
    address?: string;
    code?: MessageErrorCodes | string;
    errno?: number | string;
    info?: any;
    name: string;
    port?: number;
    retryable: boolean;
    syscall?: string;
}

// @public
export interface NetworkSystemError {
    // (undocumented)
    address?: string;
    // (undocumented)
    code: string;
    // (undocumented)
    errno: string | number;
    // (undocumented)
    info?: any;
    // (undocumented)
    message: string;
    // (undocumented)
    name: string;
    // (undocumented)
    port?: number;
    // (undocumented)
    stack: string;
    // (undocumented)
    syscall: string;
}

// @public
export function parseConnectionString<T>(connectionString: string): ParsedOutput<T>;

// @public
export type ParsedOutput<T> = {
    [P in keyof T]: T[P];
};

// @public
export function randomNumberFromInterval(min: number, max: number): number;

// @public
export class RequestResponseLink implements ReqResLink {
    constructor(session: Session, sender: Sender, receiver: Receiver);
    close(): Promise<void>;
    get connection(): Connection;
    static create(connection: Connection, senderOptions: SenderOptions, receiverOptions: ReceiverOptions): Promise<RequestResponseLink>;
    isOpen(): boolean;
    // (undocumented)
    receiver: Receiver;
    remove(): void;
    // (undocumented)
    sender: Sender;
    sendRequest(request: AmqpMessage, options?: SendRequestOptions): Promise<AmqpMessage>;
    // (undocumented)
    session: Session;
}

// @public
export function retry<T>(config: RetryConfig<T>): Promise<T>;

// @public
export const retryableErrors: string[];

// @public
export interface RetryConfig<T> {
    abortSignal?: AbortSignalLike;
    connectionHost?: string;
    connectionId: string;
    operation: () => Promise<T>;
    operationType: RetryOperationType;
    retryOptions?: RetryOptions;
}

// @public
export enum RetryMode {
    // (undocumented)
    Exponential = 0,
    // (undocumented)
    Fixed = 1
}

// @public
export enum RetryOperationType {
    // (undocumented)
    cbsAuth = "cbsAuth",
    // (undocumented)
    connection = "connection",
    // (undocumented)
    management = "management",
    // (undocumented)
    receiveMessage = "receiveMessage",
    // (undocumented)
    receiverLink = "receiverLink",
    // (undocumented)
    senderLink = "senderLink",
    // (undocumented)
    sendMessage = "sendMessage",
    // (undocumented)
    session = "session"
}

// @public
export interface RetryOptions {
    maxRetries?: number;
    maxRetryDelayInMs?: number;
    mode?: RetryMode;
    retryDelayInMs?: number;
    timeoutInMs?: number;
}

// @public
export interface SendRequestOptions {
    abortSignal?: AbortSignalLike;
    requestName?: string;
    timeoutInMs?: number;
}

// @public
export interface ServiceBusConnectionStringModel {
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    Endpoint: string;
    // (undocumented)
    EntityPath?: string;
    // (undocumented)
    SharedAccessKey: string;
    // (undocumented)
    SharedAccessKeyName: string;
}

// @public
export class SharedKeyCredential {
    constructor(keyName: string, key: string);
    protected _createToken(expiry: number, audience: string, hashInput?: string | Buffer): AccessToken;
    static fromConnectionString(connectionString: string): SharedKeyCredential;
    getToken(audience: string): AccessToken;
    key: string;
    keyName: string;
}

// @public
export interface StorageConnectionStringModel {
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    AccountKey: string;
    // (undocumented)
    AccountName: string;
    // (undocumented)
    DefaultEndpointsProtocol: string;
    // (undocumented)
    EndpointSuffix: string;
}

// @public
export enum SystemErrorConditionMapper {
    // (undocumented)
    EBUSY = "com.microsoft:server-busy",
    // (undocumented)
    ECONNREFUSED = "amqp:connection:forced",
    // (undocumented)
    ECONNRESET = "com.microsoft:timeout",
    // (undocumented)
    EHOSTDOWN = "com.microsoft:timeout",
    // (undocumented)
    ENETDOWN = "com.microsoft:timeout",
    // (undocumented)
    ENETRESET = "com.microsoft:timeout",
    // (undocumented)
    ENETUNREACH = "com.microsoft:timeout",
    // (undocumented)
    ENONET = "com.microsoft:timeout",
    // (undocumented)
    ENOTFOUND = "amqp:not-found",
    // (undocumented)
    ETIMEDOUT = "com.microsoft:timeout"
}

// @public
export class Timeout {
    // (undocumented)
    clear(): void;
    // (undocumented)
    set<T>(t: number, value?: T): Promise<T>;
    // (undocumented)
    static set<T>(t: number, value?: T): Promise<T>;
    // (undocumented)
    wrap<T>(promise: Promise<T>, t: number, value?: T): Promise<T>;
    // (undocumented)
    static wrap<T>(promise: Promise<T>, t: number, value?: T): Promise<T>;
}

export { TokenCredential }

// @public
export enum TokenType {
    CbsTokenTypeJwt = "jwt",
    CbsTokenTypeSas = "servicebus.windows.net:sastoken"
}

// @public
export function translate(err: AmqpError | Error): MessagingError | Error;

// @public
export interface WebSocketOptions {
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
}


// (No @packageDocumentation comment for this package)

```
