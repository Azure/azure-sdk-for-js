## API Report File for "@azure/core-amqp"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { AccessToken } from '@azure/core-auth';
import { AmqpError } from 'rhea-promise';
import AsyncLock from 'async-lock';
import { Connection } from 'rhea-promise';
import { Message } from 'rhea-promise';
import { MessageHeader } from 'rhea-promise';
import { MessageProperties } from 'rhea-promise';
import { NamedKeyCredential } from '@azure/core-auth';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { ReqResLink } from 'rhea-promise';
import { SASCredential } from '@azure/core-auth';
import { Sender } from 'rhea-promise';
import { SenderOptions } from 'rhea-promise';
import { Session } from 'rhea-promise';
import { WebSocketImpl } from 'rhea-promise';

// @public
export interface AcquireLockProperties {
    abortSignal: AbortSignalLike | undefined;
    timeoutInMs: number | undefined;
}

// @public
export interface AmqpAnnotatedMessage {
    applicationProperties?: {
        [key: string]: any;
    };
    body: any;
    bodyType?: "data" | "sequence" | "value";
    deliveryAnnotations?: {
        [key: string]: any;
    };
    footer?: {
        [key: string]: any;
    };
    header?: AmqpMessageHeader;
    messageAnnotations?: {
        [key: string]: any;
    };
    properties?: AmqpMessageProperties;
}

// @public
export const AmqpAnnotatedMessage: {
    fromRheaMessage(msg: Message): AmqpAnnotatedMessage;
    toRheaMessage(msg: AmqpAnnotatedMessage): Message;
};

// @public
export interface AmqpMessageHeader {
    deliveryCount?: number;
    durable?: boolean;
    firstAcquirer?: boolean;
    priority?: number;
    timeToLive?: number;
}

// @public
export const AmqpMessageHeader: {
    toRheaMessageHeader(props: AmqpMessageHeader): MessageHeader;
    fromRheaMessageHeader(props: MessageHeader): AmqpMessageHeader;
};

// @public
export interface AmqpMessageProperties {
    absoluteExpiryTime?: number;
    contentEncoding?: string;
    contentType?: string;
    correlationId?: string | number | Buffer;
    creationTime?: number;
    groupId?: string;
    groupSequence?: number;
    messageId?: string | number | Buffer;
    replyTo?: string;
    replyToGroupId?: string;
    subject?: string;
    to?: string;
}

// @public
export const AmqpMessageProperties: {
    toRheaMessageProperties(props: AmqpMessageProperties): MessageProperties;
    fromRheaMessageProperties(props: MessageProperties): AmqpMessageProperties;
};

export { AsyncLock }

// @public
export interface CancellableAsyncLock {
    acquire<T = void>(key: string, task: (...args: any[]) => Promise<T>, properties: AcquireLockProperties): Promise<T>;
}

// @public
export class CbsClient {
    constructor(connection: Connection, connectionLock: string);
    readonly cbsLock: string;
    close(): Promise<void>;
    connection: Connection;
    readonly connectionLock: string;
    readonly endpoint: string;
    init(options?: {
        abortSignal?: AbortSignalLike;
        timeoutInMs?: number;
    }): Promise<void>;
    isOpen(): boolean;
    negotiateClaim(audience: string, token: string, tokenType: TokenType, options?: {
        abortSignal?: AbortSignalLike;
        timeoutInMs?: number;
    }): Promise<CbsResponse>;
    remove(): void;
    readonly replyTo: string;
}

// @public
export interface CbsResponse {
    // (undocumented)
    correlationId: string;
    // (undocumented)
    statusCode: string;
    // (undocumented)
    statusDescription: string;
}

// @public
export enum ConditionErrorNameMapper {
    "amqp:connection:forced" = "ConnectionForcedError",
    "amqp:connection:framing-error" = "FramingError",
    "amqp:connection:redirect" = "ConnectionRedirectError",
    "amqp:decode-error" = "DecodeError",
    "amqp:frame-size-too-small" = "FrameSizeTooSmallError",
    "amqp:illegal-state" = "IllegalStateError",
    "amqp:internal-error" = "InternalServerError",
    "amqp:invalid-field" = "InvalidFieldError",
    "amqp:link:detach-forced" = "DetachForcedError",
    "amqp:link:message-size-exceeded" = "MessageTooLargeError",
    "amqp:link:redirect" = "LinkRedirectError",
    "amqp:link:stolen" = "ReceiverDisconnectedError",
    "amqp:link:transfer-limit-exceeded" = "TransferLimitExceededError",
    "amqp:not-allowed" = "InvalidOperationError",
    "amqp:not-found" = "ServiceCommunicationError",
    "amqp:not-implemented" = "NotImplementedError",
    "amqp:precondition-failed" = "PreconditionFailedError",
    "amqp:resource-deleted" = "ResourceDeletedError",
    "amqp:resource-limit-exceeded" = "QuotaExceededError",
    "amqp:resource-locked" = "ResourceLockedError",
    "amqp:session:errant-link" = "ErrantLinkError",
    "amqp:session:handle-in-use" = "HandleInUseError",
    "amqp:session:unattached-handle" = "UnattachedHandleError",
    "amqp:session:window-violation" = "SessionWindowViolationError",
    "amqp:unauthorized-access" = "UnauthorizedError",
    "client.sender:not-enough-link-credit" = "SenderBusyError",
    "com.microsoft:address-already-in-use" = "AddressAlreadyInUseError",
    "com.microsoft:argument-error" = "ArgumentError",
    "com.microsoft:argument-out-of-range" = "ArgumentOutOfRangeError",
    "com.microsoft:auth-failed" = "UnauthorizedError",
    "com.microsoft:entity-already-exists" = "MessagingEntityAlreadyExistsError",
    "com.microsoft:entity-disabled" = "MessagingEntityDisabledError",
    "com.microsoft:message-lock-lost" = "MessageLockLostError",
    "com.microsoft:message-not-found" = "MessageNotFoundError",
    "com.microsoft:message-wait-timeout" = "MessageWaitTimeout",
    "com.microsoft:no-matching-subscription" = "NoMatchingSubscriptionError",
    "com.microsoft:operation-cancelled" = "OperationCancelledError",
    "com.microsoft:partition-not-owned" = "PartitionNotOwnedError",
    "com.microsoft:precondition-failed" = "PreconditionFailedError",
    "com.microsoft:publisher-revoked" = "PublisherRevokedError",
    "com.microsoft:relay-not-found" = "RelayNotFoundError",
    "com.microsoft:server-busy" = "ServerBusyError",
    "com.microsoft:session-cannot-be-locked" = "SessionCannotBeLockedError",
    "com.microsoft:session-lock-lost" = "SessionLockLostError",
    "com.microsoft:store-lock-lost" = "StoreLockLostError",
    "com.microsoft:timeout" = "ServiceUnavailableError",
    "system:error" = "SystemError"
}

// @public
export interface ConnectionConfig {
    amqpHostname?: string;
    connectionString: string;
    endpoint: string;
    entityPath?: string;
    host: string;
    port?: number;
    sharedAccessKey: string;
    sharedAccessKeyName: string;
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
    webSocketEndpointPath?: string;
}

// @public
export const ConnectionConfig: {
    create(connectionString: string, path?: string | undefined): ConnectionConfig;
    validate(config: ConnectionConfig, options?: ConnectionConfigOptions | undefined): void;
};

// @public
export interface ConnectionConfigOptions {
    isEntityPathRequired?: boolean;
}

// @public
export interface ConnectionContextBase {
    cbsSession: CbsClient;
    readonly config: ConnectionConfig;
    connection: Connection;
    connectionId: string;
    connectionLock: string;
    negotiateClaimLock: string;
    refreshConnection: () => void;
    wasConnectionCloseCalled: boolean;
}

// @public (undocumented)
export const ConnectionContextBase: {
    create(parameters: CreateConnectionContextBaseParameters): ConnectionContextBase;
};

// @public
export interface ConnectionProperties {
    product: string;
    userAgent: string;
    version: string;
}

// @public (undocumented)
export const Constants: {
    readonly associatedLinkName: "associated-link-name";
    readonly partitionKey: "x-opt-partition-key";
    readonly sequenceNumber: "x-opt-sequence-number";
    readonly enqueueSequenceNumber: "x-opt-enqueue-sequence-number";
    readonly enqueuedTime: "x-opt-enqueued-time";
    readonly scheduledEnqueueTime: "x-opt-scheduled-enqueue-time";
    readonly offset: "x-opt-offset";
    readonly lockedUntil: "x-opt-locked-until";
    readonly partitionIdName: "x-opt-partition-id";
    readonly publisher: "x-opt-publisher-name";
    readonly viaPartitionKey: "x-opt-via-partition-key";
    readonly deadLetterSource: "x-opt-deadletter-source";
    readonly enqueuedTimeAnnotation: "amqp.annotation.x-opt-enqueued-time";
    readonly offsetAnnotation: "amqp.annotation.x-opt-offset";
    readonly sequenceNumberAnnotation: "amqp.annotation.x-opt-sequence-number";
    readonly guidSize: 16;
    readonly message: "message";
    readonly error: "error";
    readonly statusCode: "status-code";
    readonly statusDescription: "status-description";
    readonly errorCondition: "error-condition";
    readonly management: "$management";
    readonly partition: "partition";
    readonly partitionId: "partitionId";
    readonly readOperation: "READ";
    readonly TLS: "tls";
    readonly establishConnection: "establishConnection";
    readonly defaultConsumerGroup: "$default";
    readonly eventHub: "eventhub";
    readonly cbsEndpoint: "$cbs";
    readonly cbsReplyTo: "cbs";
    readonly operationPutToken: "put-token";
    readonly aadEventHubsAudience: "https://eventhubs.azure.net/";
    readonly aadEventHubsScope: "https://eventhubs.azure.net//.default";
    readonly aadServiceBusAudience: "https://servicebus.azure.net/";
    readonly aadServiceBusScope: "https://servicebus.azure.net//.default";
    readonly maxUserAgentLength: 512;
    readonly vendorString: "com.microsoft";
    readonly attachEpoch: "com.microsoft:epoch";
    readonly receiverIdentifierName: "com.microsoft:receiver-name";
    readonly enableReceiverRuntimeMetricName: "com.microsoft:enable-receiver-runtime-metric";
    readonly timespan: "com.microsoft:timespan";
    readonly uri: "com.microsoft:uri";
    readonly dateTimeOffset: "com.microsoft:datetime-offset";
    readonly sessionFilterName: "com.microsoft:session-filter";
    readonly receiverError: "receiver_error";
    readonly senderError: "sender_error";
    readonly sessionError: "session_error";
    readonly connectionError: "connection_error";
    readonly defaultOperationTimeoutInMs: 60000;
    readonly defaultConnectionIdleTimeoutInMs: 60000;
    readonly managementRequestKey: "managementRequest";
    readonly negotiateCbsKey: "negotiateCbs";
    readonly negotiateClaim: "negotiateClaim";
    readonly ensureContainerAndBlob: "ensureContainerAndBlob";
    readonly defaultPrefetchCount: 1000;
    readonly reconnectLimit: 100;
    readonly maxMessageIdLength: 128;
    readonly maxPartitionKeyLength: 128;
    readonly maxSessionIdLength: 128;
    readonly pathDelimiter: "/";
    readonly ruleNameMaximumLength: 50;
    readonly maximumSqlFilterStatementLength: 1024;
    readonly maximumSqlRuleActionStatementLength: 1024;
    readonly maxDeadLetterReasonLength: 4096;
    readonly maxDurationValue: 922337203685477;
    readonly minDurationValue: -922337203685477;
    readonly maxAbsoluteExpiryTime: number;
    readonly aadTokenValidityMarginInMs: 5000;
    readonly connectionReconnectDelay: 300;
    readonly defaultMaxRetries: 3;
    readonly defaultMaxRetriesForConnection: 150;
    readonly defaultDelayBetweenOperationRetriesInMs: 30000;
    readonly defaultMaxDelayForExponentialRetryInMs: 90000;
    readonly receiverSettleMode: "receiver-settle-mode";
    readonly dispositionStatus: "disposition-status";
    readonly fromSequenceNumber: "from-sequence-number";
    readonly messageCount: "message-count";
    readonly lockTokens: "lock-tokens";
    readonly messageIdMapKey: "message-id";
    readonly sequenceNumberMapKey: "sequence-number";
    readonly lockTokenMapKey: "lock-token";
    readonly sessionIdMapKey: "session-id";
    readonly sequenceNumbers: "sequence-numbers";
    readonly deadLetterReason: "deadletter-reason";
    readonly deadLetterDescription: "deadletter-description";
    readonly propertiesToModify: "properties-to-modify";
    readonly deadLetterName: "com.microsoft:dead-letter";
    readonly trackingId: "com.microsoft:tracking-id";
    readonly serverTimeout: "com.microsoft:server-timeout";
    readonly operations: {
        readonly putToken: "put-token";
        readonly read: "READ";
        readonly cancelScheduledMessage: "com.microsoft:cancel-scheduled-message";
        readonly scheduleMessage: "com.microsoft:schedule-message";
        readonly renewLock: "com.microsoft:renew-lock";
        readonly peekMessage: "com.microsoft:peek-message";
        readonly receiveBySequenceNumber: "com.microsoft:receive-by-sequence-number";
        readonly updateDisposition: "com.microsoft:update-disposition";
        readonly renewSessionLock: "com.microsoft:renew-session-lock";
        readonly setSessionState: "com.microsoft:set-session-state";
        readonly getSessionState: "com.microsoft:get-session-state";
        readonly enumerateSessions: "com.microsoft:get-message-sessions";
        readonly addRule: "com.microsoft:add-rule";
        readonly removeRule: "com.microsoft:remove-rule";
        readonly enumerateRules: "com.microsoft:enumerate-rules";
    };
    readonly descriptorCodes: {
        readonly ruleDescriptionList: 1335734829060;
        readonly sqlFilterList: 83483426822;
        readonly correlationFilterList: 83483426825;
        readonly sqlRuleActionList: 1335734829062;
        readonly trueFilterList: 83483426823;
        readonly falseFilterList: 83483426824;
    };
};

// @public
export interface CreateConnectionContextBaseParameters {
    config: ConnectionConfig;
    connectionProperties: ConnectionProperties;
    isEntityPathRequired?: boolean;
    operationTimeoutInMs?: number;
}

// @public
export function createSasTokenProvider(data: {
    sharedAccessKeyName: string;
    sharedAccessKey: string;
} | {
    sharedAccessSignature: string;
} | NamedKeyCredential | SASCredential): SasTokenProvider;

// @public
export const defaultCancellableLock: CancellableAsyncLock;

// @public
export const defaultLock: AsyncLock;

// @public
export function delay<T>(delayInMs: number, abortSignal?: AbortSignalLike, abortErrorMsg?: string, value?: T): Promise<T | void>;

// @public
export enum ErrorNameConditionMapper {
    AddressAlreadyInUseError = "com.microsoft:address-already-in-use",
    ArgumentError = "com.microsoft:argument-error",
    ArgumentOutOfRangeError = "com.microsoft:argument-out-of-range",
    ConnectionForcedError = "amqp:connection:forced",
    ConnectionRedirectError = "amqp:connection:redirect",
    DecodeError = "amqp:decode-error",
    DetachForcedError = "amqp:link:detach-forced",
    ErrantLinkError = "amqp:session:errant-link",
    FrameSizeTooSmallError = "amqp:frame-size-too-small",
    FramingError = "amqp:connection:framing-error",
    HandleInUseError = "amqp:session:handle-in-use",
    IllegalStateError = "amqp:illegal-state",
    InternalServerError = "amqp:internal-error",
    InvalidFieldError = "amqp:invalid-field",
    InvalidOperationError = "amqp:not-allowed",
    LinkRedirectError = "amqp:link:redirect",
    MessageLockLostError = "com.microsoft:message-lock-lost",
    MessageNotFoundError = "com.microsoft:message-not-found",
    MessageTooLargeError = "amqp:link:message-size-exceeded",
    MessageWaitTimeout = "com.microsoft:message-wait-timeout",
    MessagingEntityAlreadyExistsError = "com.microsoft:entity-already-exists",
    MessagingEntityDisabledError = "com.microsoft:entity-disabled",
    NoMatchingSubscriptionError = "com.microsoft:no-matching-subscription",
    NotImplementedError = "amqp:not-implemented",
    OperationCancelledError = "com.microsoft:operation-cancelled",
    PartitionNotOwnedError = "com.microsoft:partition-not-owned",
    PreconditionFailedError = "amqp:precondition-failed",
    PublisherRevokedError = "com.microsoft:publisher-revoked",
    QuotaExceededError = "amqp:resource-limit-exceeded",
    ReceiverDisconnectedError = "amqp:link:stolen",
    RelayNotFoundError = "com.microsoft:relay-not-found",
    ResourceDeletedError = "amqp:resource-deleted",
    ResourceLockedError = "amqp:resource-locked",
    SenderBusyError = "client.sender:not-enough-link-credit",
    ServerBusyError = "com.microsoft:server-busy",
    ServiceCommunicationError = "amqp:not-found",
    ServiceUnavailableError = "com.microsoft:timeout",
    SessionCannotBeLockedError = "com.microsoft:session-cannot-be-locked",
    SessionLockLostError = "com.microsoft:session-lock-lost",
    SessionWindowViolationError = "amqp:session:window-violation",
    StoreLockLostError = "com.microsoft:store-lock-lost",
    SystemError = "system:error",
    TransferLimitExceededError = "amqp:link:transfer-limit-exceeded",
    UnattachedHandleError = "amqp:session:unattached-handle",
    UnauthorizedError = "amqp:unauthorized-access"
}

// @public
export function isMessagingError(error: Error | MessagingError): error is MessagingError;

// @public
export function isSasTokenProvider(thing: unknown): thing is SasTokenProvider;

// @public
export function isSystemError(err: unknown): err is NetworkSystemError;

// @public
export const logger: import("@azure/logger").AzureLogger;

// @public
export class MessagingError extends Error {
    constructor(message: string, originalError?: Error);
    address?: string;
    code?: string;
    errno?: number | string;
    info?: any;
    name: string;
    port?: number;
    retryable: boolean;
    syscall?: string;
}

// @public
export interface NetworkSystemError {
    // (undocumented)
    address?: string;
    // (undocumented)
    code: string;
    // (undocumented)
    errno: string | number;
    // (undocumented)
    info?: any;
    // (undocumented)
    message: string;
    // (undocumented)
    name: string;
    // (undocumented)
    port?: number;
    // (undocumented)
    stack: string;
    // (undocumented)
    syscall: string;
}

// @public
export function parseConnectionString<T>(connectionString: string): ParsedOutput<T>;

// @public
export type ParsedOutput<T> = {
    [P in keyof T]: T[P];
};

// @public
export class RequestResponseLink implements ReqResLink {
    constructor(session: Session, sender: Sender, receiver: Receiver);
    close(): Promise<void>;
    get connection(): Connection;
    static create(connection: Connection, senderOptions: SenderOptions, receiverOptions: ReceiverOptions, createOptions?: {
        abortSignal?: AbortSignalLike;
    }): Promise<RequestResponseLink>;
    isOpen(): boolean;
    // (undocumented)
    receiver: Receiver;
    remove(): void;
    // (undocumented)
    sender: Sender;
    sendRequest(request: Message, options?: SendRequestOptions): Promise<Message>;
    // (undocumented)
    session: Session;
}

// @public
export function retry<T>(config: RetryConfig<T>): Promise<T>;

// @public
export const retryableErrors: string[];

// @public
export interface RetryConfig<T> {
    abortSignal?: AbortSignalLike;
    connectionHost?: string;
    connectionId: string;
    operation: () => Promise<T>;
    operationType: RetryOperationType;
    retryOptions?: RetryOptions;
}

// @public
export enum RetryMode {
    // (undocumented)
    Exponential = 0,
    // (undocumented)
    Fixed = 1
}

// @public
export enum RetryOperationType {
    // (undocumented)
    cbsAuth = "cbsAuth",
    // (undocumented)
    connection = "connection",
    // (undocumented)
    management = "management",
    // (undocumented)
    messageSettlement = "settlement",
    // (undocumented)
    receiveMessage = "receiveMessage",
    // (undocumented)
    receiverLink = "receiverLink",
    // (undocumented)
    senderLink = "senderLink",
    // (undocumented)
    sendMessage = "sendMessage",
    // (undocumented)
    session = "session"
}

// @public
export interface RetryOptions {
    maxRetries?: number;
    maxRetryDelayInMs?: number;
    mode?: RetryMode;
    retryDelayInMs?: number;
    timeoutInMs?: number;
}

// @public
export interface SasTokenProvider {
    getToken(audience: string): AccessToken;
    isSasTokenProvider: true;
}

// @public
export interface SendRequestOptions {
    abortSignal?: AbortSignalLike;
    requestName?: string;
    timeoutInMs?: number;
}

// @public
export const StandardAbortMessage = "The operation was aborted.";

// @public
export enum SystemErrorConditionMapper {
    // (undocumented)
    EBUSY = "com.microsoft:server-busy",
    // (undocumented)
    ECONNREFUSED = "amqp:connection:forced",
    // (undocumented)
    ECONNRESET = "com.microsoft:timeout",
    // (undocumented)
    EHOSTDOWN = "com.microsoft:timeout",
    // (undocumented)
    ENETDOWN = "com.microsoft:timeout",
    // (undocumented)
    ENETRESET = "com.microsoft:timeout",
    // (undocumented)
    ENETUNREACH = "com.microsoft:timeout",
    // (undocumented)
    ENONET = "com.microsoft:timeout",
    // (undocumented)
    ENOTFOUND = "amqp:not-found",
    // (undocumented)
    ETIMEDOUT = "com.microsoft:timeout"
}

// @public
export enum TokenType {
    CbsTokenTypeJwt = "jwt",
    CbsTokenTypeSas = "servicebus.windows.net:sastoken"
}

// @public
export function translate(err: AmqpError | Error): MessagingError | Error;

// @public
export interface WebSocketOptions {
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
}


// (No @packageDocumentation comment for this package)

```
