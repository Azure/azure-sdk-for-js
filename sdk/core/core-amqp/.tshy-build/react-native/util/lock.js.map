{"version":3,"file":"lock.js","sourceRoot":"","sources":["../../../src/util/lock.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { OperationTimeoutError } from \"rhea-promise\";\nimport { StandardAbortMessage } from \"./constants.js\";\nimport { logger } from \"../log.js\";\n\n/**\n * Describes the properties that must be provided while acquiring a lock.\n */\nexport interface AcquireLockProperties {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel lock acquisition.\n   * This only applies to the acquisition of a lock. Once the lock is acquired, the task is invoked and `acquire`\n   * can no longer be cancelled.\n   * This does not cancel running the task passed to `acquire()` if the lock has been acquired,\n   * but will prevent it from running if cancelled before the task is invoked.\n   */\n  abortSignal: AbortSignalLike | undefined;\n  /**\n   * The allowed amount of time in milliseconds to acquire a lock.\n   * If a lock isn't acquired within this time, the promise returned\n   * by `acquire()` will be rejected with an Error.\n   */\n  timeoutInMs: number | undefined;\n}\n\n/**\n * Describes the components related to a specific task.\n * @internal\n */\ninterface TaskDetails {\n  abortListener?: () => void;\n  abortSignal?: AbortSignalLike;\n  resolve: (value: unknown) => void;\n  reject: (reason: Error) => void;\n  task: (...args: any[]) => Promise<unknown>;\n  tid?: ReturnType<typeof setTimeout>;\n}\n\n/**\n * CancellableAsyncLock provides a mechanism for forcing tasks using the same\n * 'key' to be executed serially.\n *\n * Pending tasks can be manually cancelled via an abortSignal or automatically\n * cancelled by reach a provided timeout value.\n */\nexport interface CancellableAsyncLock {\n  /**\n   * Returns a promise that resolves to the value returned by the provided task function.\n   * Only 1 task can be invoked at a time for a given `key` value.\n   *\n   * An acquire call can be cancelled via an `abortSignal`.\n   * If cancelled, the promise will be rejected with an `AbortError`.\n   *\n   * `acquireTimeoutInMs` can also be provided to properties.\n   * If the timeout is reached before the provided `task` is invoked,\n   * then the promise will be rejected with an Error stating the task\n   * timed out waiting to acquire a lock.\n   *\n   * @param key - All `acquire` calls are grouped by the provided `key`.\n   * @param task - The function to invoke once the lock has been acquired.\n   * @param properties - Additional properties to control the behavior of `acquire`.\n   */\n  acquire<T = void>(\n    key: string,\n    task: (...args: any[]) => Promise<T>,\n    properties: AcquireLockProperties,\n  ): Promise<T>;\n}\n\n/**\n * This class is used to coordinate executing tasks that should not be run in parallel.\n * @internal\n */\nexport class CancellableAsyncLockImpl {\n  private _keyMap = new Map<string, TaskDetails[]>();\n  private _executionRunningSet = new Set<string>();\n  /**\n   * Returns a promise that resolves to the value returned by the provided task function.\n   * Only 1 task can be invoked at a time for a given `key` value.\n   *\n   * An acquire call can be cancelled via an `abortSignal`.\n   * If cancelled, the promise will be rejected with an `AbortError`.\n   *\n   * `acquireTimeoutInMs` can also be provided to properties.\n   * If the timeout is reached before the provided `task` is invoked,\n   * then the promise will be rejected with an Error stating the task\n   * timed out waiting to acquire a lock.\n   *\n   * @param key - All `acquire` calls are grouped by the provided `key`.\n   * @param task - The function to invoke once the lock has been acquired.\n   * @param properties - Additional properties to control the behavior of `acquire`.\n   */\n  acquire<T = void>(\n    key: string,\n    task: (...args: any[]) => Promise<T>,\n    properties: AcquireLockProperties,\n  ): Promise<T> {\n    const { abortSignal, timeoutInMs } = properties;\n    // Fast exit if the operation is already cancelled.\n    if (abortSignal?.aborted) {\n      return Promise.reject(new AbortError(StandardAbortMessage));\n    }\n\n    // Ensure we've got a task queue for the given key.\n    const taskQueue = this._keyMap.get(key) ?? [];\n    this._keyMap.set(key, taskQueue);\n\n    // This method will return a promise that will be fulfilled outside this function.\n    const { promise, rejecter, resolver } = getPromiseParts();\n\n    const taskDetails: TaskDetails = {\n      reject: rejecter,\n      resolve: resolver,\n      task,\n    };\n\n    // Handle timeouts by removing the task from the queue when hit.\n    if (typeof timeoutInMs === \"number\") {\n      const tid = setTimeout(() => {\n        this._removeTaskDetails(key, taskDetails);\n        rejecter(\n          new OperationTimeoutError(`The task timed out waiting to acquire a lock for ${key}`),\n        );\n      }, timeoutInMs);\n      taskDetails.tid = tid;\n    }\n\n    // Handle cancellation by removing the task from the queue when cancelled.\n    if (abortSignal) {\n      const abortListener = (): void => {\n        this._removeTaskDetails(key, taskDetails);\n        rejecter(new AbortError(StandardAbortMessage));\n      };\n      abortSignal.addEventListener(\"abort\", abortListener);\n      taskDetails.abortSignal = abortSignal;\n      taskDetails.abortListener = abortListener;\n    }\n\n    // Enqueue the task!\n    taskQueue.push(taskDetails);\n    logger.verbose(\n      `Called acquire() for lock \"${key}\". Lock \"${key}\" has ${taskQueue.length} pending tasks.`,\n    );\n\n    // Start a loop to iterate over the task queue.\n    // This will run asynchronously and won't allow\n    // more than 1 concurrent execution per key at a time.\n    this._execute(key);\n\n    return promise as Promise<T>;\n  }\n\n  /**\n   * Iterates over all the pending tasks for a given `key` serially.\n   *\n   * Note: If the pending tasks are already being iterated by an early\n   * _execute invocation, this returns immediately.\n   * @returns\n   */\n  private async _execute(key: string): Promise<void> {\n    // If the key already exists in the set, then exit because\n    // tasks are already being processed.\n    if (this._executionRunningSet.has(key)) {\n      return;\n    }\n\n    const taskQueue = this._keyMap.get(key);\n    // If the queue is empty, exit early!\n    if (!taskQueue || !taskQueue.length) {\n      return;\n    }\n\n    // Add the key to the set so we can tell the\n    // task queue is already being processed.\n    this._executionRunningSet.add(key);\n    while (taskQueue.length) {\n      // Remove tasks from the front of the queue.\n      // Order matters!\n      const taskDetails = taskQueue.shift();\n      if (!taskDetails) {\n        continue;\n      }\n\n      try {\n        logger.verbose(`Acquired lock for \"${key}\", invoking task.`);\n        cleanupTaskDetails(taskDetails);\n        const value = await taskDetails.task();\n        taskDetails.resolve(value);\n      } catch (err: any) {\n        taskDetails.reject(err);\n      }\n      logger.verbose(\n        `Task completed for lock \"${key}\". Lock \"${key}\" has ${taskQueue.length} pending tasks.`,\n      );\n    }\n\n    // Indicate that the task queue for the key is empty\n    // and we're done processing it.\n    this._executionRunningSet.delete(key);\n    // clean up the key map\n    this._keyMap.delete(key);\n  }\n\n  private _removeTaskDetails(key: string, taskDetails: TaskDetails): void {\n    const taskQueue = this._keyMap.get(key);\n    if (!taskQueue || !taskQueue.length) {\n      // The task is already gone from the queue, so our work here is done!\n      return;\n    }\n\n    const index = taskQueue.indexOf(taskDetails);\n    if (index !== -1) {\n      const [details] = taskQueue.splice(index, 1);\n      // Cleanup the task rejection code paths.\n      cleanupTaskDetails(details);\n    }\n  }\n}\n\n/**\n * @internal\n * Returns a promise and the promise's resolve and reject methods.\n */\nfunction getPromiseParts(): {\n  promise: Promise<unknown>;\n  resolver: (value: unknown) => void;\n  rejecter: (reason: Error) => void;\n} {\n  let resolver: (value: unknown) => void;\n  let rejecter: (reason: Error) => void;\n\n  const promise = new Promise<unknown>((resolve, reject) => {\n    resolver = resolve;\n    rejecter = reject;\n  });\n\n  return {\n    promise,\n    resolver: resolver!,\n    rejecter: rejecter!,\n  };\n}\n\n/**\n * @internal\n * Removes any abort listener or pending timeout from a task.\n */\nfunction cleanupTaskDetails(taskDetails: TaskDetails): void {\n  // Cleanup the task rejection code paths.\n  if (taskDetails.tid) clearTimeout(taskDetails.tid);\n  if (taskDetails.abortSignal && taskDetails.abortListener) {\n    taskDetails.abortSignal.removeEventListener(\"abort\", taskDetails.abortListener);\n  }\n}\n"]}