{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/util/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { CancellableAsyncLock } from \"./lock.js\";\nimport { CancellableAsyncLockImpl } from \"./lock.js\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport type { WebSocketImpl } from \"rhea-promise\";\nimport { delay as wrapperDelay } from \"@azure/core-util\";\n\n/**\n * @internal\n *\n * Describes the options that can be provided to create an async lock.\n */\nexport interface AsyncLockOptions {\n  /**\n   * The max timeout. Default is: 0 (never timeout).\n   */\n  timeout?: number;\n  /**\n   * Maximum pending tasks. Default is: 1000.\n   */\n  maxPending?: number;\n  /**\n   * Whether lock can reenter in the same domain.\n   * Default is: false.\n   */\n  domainReentrant?: boolean;\n  /**\n   * Your implementation of the promise. Default is: global promise.\n   */\n  Promise?: any;\n}\n\n/**\n * Options to configure the channelling of the AMQP connection over Web Sockets.\n */\nexport interface WebSocketOptions {\n  /**\n   * The WebSocket constructor used to create an AMQP connection over a WebSocket.\n   * This option should be provided in the below scenarios:\n   * - The TCP port 5671 which is that is used by the AMQP connection to Event Hubs is blocked in your environment.\n   * - Your application needs to be run behind a proxy server.\n   * - Your application needs to run in the browser and you want to provide your own choice of Websocket implementation\n   *   instead of the built-in WebSocket in the browser.\n   */\n  webSocket?: WebSocketImpl;\n  /**\n   * Options to be passed to the WebSocket constructor when the underlying `rhea` library instantiates\n   * the WebSocket.\n   */\n  webSocketConstructorOptions?: any;\n}\n\n/**\n * Defines an object with possible properties defined in T.\n */\nexport type ParsedOutput<T> = { [P in keyof T]: T[P] };\n\n/**\n * Parses the connection string and returns an object of type T.\n *\n * Connection strings have the following syntax:\n *\n * ConnectionString ::= `Part { \";\" Part } [ \";\" ] [ WhiteSpace ]`\n * Part             ::= [ PartLiteral [ \"=\" PartLiteral ] ]\n * PartLiteral      ::= [ WhiteSpace ] Literal [ WhiteSpace ]\n * Literal          ::= ? any sequence of characters except ; or = or WhiteSpace ?\n * WhiteSpace       ::= ? all whitespace characters including `\\r` and `\\n` ?\n *\n * @param connectionString - The connection string to be parsed.\n * @returns ParsedOutput<T>.\n */\nexport function parseConnectionString<T>(connectionString: string): ParsedOutput<T> {\n  const output: { [k: string]: string } = {};\n  const parts = connectionString.trim().split(\";\");\n\n  for (let part of parts) {\n    part = part.trim();\n\n    if (part === \"\") {\n      // parts can be empty\n      continue;\n    }\n\n    const splitIndex = part.indexOf(\"=\");\n    if (splitIndex === -1) {\n      throw new Error(\n        \"Connection string malformed: each part of the connection string must have an `=` assignment.\",\n      );\n    }\n\n    const key = part.substring(0, splitIndex).trim();\n    if (key === \"\") {\n      throw new Error(\"Connection string malformed: missing key for assignment\");\n    }\n\n    const value = part.substring(splitIndex + 1).trim();\n\n    output[key] = value;\n  }\n\n  return output as any;\n}\n\n/**\n * The cancellable async lock instance.\n */\nexport const defaultCancellableLock: CancellableAsyncLock = new CancellableAsyncLockImpl();\n\n/**\n * @internal\n *\n * Describes a Timeout class that can wait for the specified amount of time and then resolve/reject\n * the promise with the given value.\n */\nexport class Timeout {\n  private _timer?: ReturnType<typeof setTimeout>;\n\n  set<T>(t: number, value?: T): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      this.clear();\n      const callback: (args: any) => void = value ? () => reject(new Error(`${value}`)) : resolve;\n      this._timer = setTimeout(callback, t);\n    });\n  }\n\n  clear(): void {\n    if (this._timer) {\n      clearTimeout(this._timer);\n    }\n  }\n\n  wrap<T>(promise: Promise<T>, t: number, value?: T): Promise<T> {\n    const wrappedPromise = this._promiseFinally(promise, () => this.clear());\n    const timer = this.set(t, value);\n    return Promise.race([wrappedPromise, timer]);\n  }\n\n  private _promiseFinally<T>(promise: Promise<T>, fn: (...args: any[]) => void): Promise<T> {\n    const success = (result: T): T => {\n      fn();\n      return result;\n    };\n    const error = (e: Error): Promise<never> => {\n      fn();\n      return Promise.reject(e);\n    };\n    return Promise.resolve(promise).then(success, error);\n  }\n\n  static set<T>(t: number, value?: T): Promise<T> {\n    return new Timeout().set(t, value);\n  }\n\n  static wrap<T>(promise: Promise<T>, t: number, value?: T): Promise<T> {\n    return new Timeout().wrap(promise, t, value);\n  }\n}\n\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param abortSignal - The abortSignal associated with containing operation.\n * @param abortErrorMsg - The abort error message associated with containing operation.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n * @returns - Resolved promise\n */\nexport async function delay<T>(\n  delayInMs: number,\n  abortSignal?: AbortSignalLike,\n  abortErrorMsg?: string,\n  value?: T,\n): Promise<T | void> {\n  await wrapperDelay(delayInMs, {\n    abortSignal: abortSignal,\n    abortErrorMsg: abortErrorMsg,\n  });\n  if (value !== undefined) {\n    return value;\n  }\n}\n\n/**\n * Checks if an address is localhost.\n * @param address - The address to check.\n * @returns true if the address is localhost, false otherwise.\n */\nexport function isLoopbackAddress(address: string): boolean {\n  return /^(.*:\\/\\/)?(127\\.[\\d.]+|[0:]+1|localhost)/.test(address.toLowerCase());\n}\n\n/**\n * @internal\n *\n * Generates a random number between the given interval\n * @param min - Min number of the range (inclusive).\n * @param max - Max number of the range (inclusive).\n */\nexport function randomNumberFromInterval(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * @internal\n *\n * Type declaration for a Function type where T is the input to the function and V is the output\n * of the function.\n */\nexport type Func<T, V> = (a: T) => V;\n\n/**\n * @internal\n *\n * Executes an array of promises sequentially. Inspiration of this method is here:\n * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!\n *\n * @param promiseFactories - An array of promise factories(A function that return a promise)\n *\n * @param kickstart - Input to the first promise that is used to kickstart the promise chain.\n * If not provided then the promise chain starts with undefined.\n *\n * @returns A chain of resolved or rejected promises\n */\nexport function executePromisesSequentially(\n  promiseFactories: Array<any>,\n  kickstart?: unknown,\n): Promise<any> {\n  let result = Promise.resolve(kickstart);\n  promiseFactories.forEach((promiseFactory) => {\n    result = result.then(promiseFactory);\n  });\n  return result;\n}\n\n/**\n * @internal\n *\n * Determines whether the given connection string is an iothub connection string.\n * @param connectionString - The connection string.\n * @returns boolean.\n */\nexport function isIotHubConnectionString(connectionString: string): boolean {\n  connectionString = String(connectionString);\n\n  let result: boolean = false;\n  const model: any = parseConnectionString<any>(connectionString);\n  if (model && model.HostName && model.SharedAccessKey && model.SharedAccessKeyName) {\n    result = true;\n  }\n  return result;\n}\n\n/**\n * @internal\n */\nexport function isString(s: unknown): s is string {\n  return typeof s === \"string\";\n}\n\n/**\n * @internal\n */\nexport function isNumber(n: unknown): n is number {\n  return typeof n === \"number\";\n}\n"]}