{"version":3,"file":"operation.js","sourceRoot":"","sources":["../../../src/poller/operation.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  LroError,\n  InnerError,\n  Operation,\n  OperationStatus,\n  RestorableOperationState,\n  OperationState,\n} from \"./models.js\";\nimport { logger } from \"../logger.js\";\nimport { terminalStates } from \"./constants.js\";\n\n/**\n * Deserializes the state\n */\nexport function deserializeState<TResult, TState extends OperationState<TResult>>(\n  serializedState: string,\n): RestorableOperationState<TResult, TState> {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\n\nfunction setStateError<TResult, TState extends OperationState<TResult>>(inputs: {\n  state: TState;\n  isOperationError: (error: Error) => boolean;\n}): (error: Error) => never {\n  const { state, isOperationError } = inputs;\n  return (error: Error) => {\n    if (isOperationError(error)) {\n      state.error = error;\n      state.status = \"failed\";\n    }\n    throw error;\n  };\n}\n\nfunction appendReadableErrorMessage(currentMessage: string, innerMessage: string): string {\n  let message = currentMessage;\n  if (message.slice(-1) !== \".\") {\n    message = message + \".\";\n  }\n  return message + \" \" + innerMessage;\n}\n\nfunction simplifyError(err: LroError): {\n  code: string;\n  message: string;\n} {\n  let message = err.message;\n  let code = err.code;\n  let curErr = err as InnerError;\n  while (curErr.innererror) {\n    curErr = curErr.innererror;\n    code = curErr.code;\n    message = appendReadableErrorMessage(message, curErr.message);\n  }\n  return {\n    code,\n    message,\n  };\n}\n\nasync function processOperationStatus<\n  TState extends OperationState<TResult>,\n  TResult,\n  TResponse,\n>(result: {\n  status: OperationStatus;\n  response: TResponse;\n  state: RestorableOperationState<TResult, TState>;\n  processResult?: (result: TResponse, state: TState) => Promise<TResult>;\n  getError?: (response: TResponse) => LroError | undefined;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n}): Promise<void> {\n  const { state, status, isDone, processResult, getError, response, setErrorAsResult } = result;\n  switch (status) {\n    case \"succeeded\": {\n      state.status = \"succeeded\";\n      break;\n    }\n    case \"failed\": {\n      const err = getError?.(response);\n      let postfix = \"\";\n      if (err) {\n        const { code, message } = simplifyError(err);\n        postfix = `. ${code}. ${message}`;\n      }\n      const errStr = `The long-running operation has failed${postfix}`;\n      state.error = new Error(errStr);\n      state.status = \"failed\";\n      logger.warning(errStr);\n      break;\n    }\n    case \"canceled\": {\n      state.status = \"canceled\";\n      break;\n    }\n  }\n  if (\n    isDone?.(response, state) ||\n    (isDone === undefined &&\n      [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status))\n  ) {\n    state.result = await buildResult({\n      response,\n      state,\n      processResult,\n    });\n  }\n}\n\nasync function buildResult<TResponse, TResult, TState>(inputs: {\n  response: TResponse;\n  state: TState;\n  processResult?: (result: TResponse, state: TState) => Promise<TResult>;\n}): Promise<TResult> {\n  const { processResult, response, state } = inputs;\n  return processResult ? processResult(response, state) : (response as unknown as TResult);\n}\n\n/**\n * Initiates the long-running operation.\n */\nexport async function initOperation<\n  TResponse,\n  TResult,\n  TState extends OperationState<TResult>,\n>(inputs: {\n  init: Operation<TResponse, unknown>[\"init\"];\n  getOperationStatus: (inputs: {\n    response: TResponse;\n    state: RestorableOperationState<TResult, TState>;\n    operationLocation?: string;\n  }) => OperationStatus;\n  processResult?: (result: TResponse, state: TState) => Promise<TResult>;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  setErrorAsResult: boolean;\n}): Promise<RestorableOperationState<TResult, TState>> {\n  const { init, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } =\n    inputs;\n  const {\n    operationLocation,\n    resourceLocation,\n    initialRequestUrl,\n    requestMethod,\n    metadata,\n    response,\n  } = await init();\n  if (operationLocation) withOperationLocation?.(operationLocation, false);\n  const config = {\n    metadata,\n    operationLocation,\n    resourceLocation,\n    initialRequestUrl,\n    requestMethod,\n  };\n  logger.verbose(`LRO: Operation description:`, config);\n  const state = { status: \"running\", config } as any;\n  const status = getOperationStatus({ response, state, operationLocation });\n  await processOperationStatus({\n    state,\n    status,\n    response,\n    setErrorAsResult,\n    processResult,\n  });\n  return state;\n}\n\nasync function pollOperationHelper<\n  TResponse,\n  TState extends OperationState<TResult>,\n  TResult,\n  TOptions,\n>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  state: RestorableOperationState<TResult, TState>;\n  operationLocation: string;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TResult, TState>,\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TResult, TState>,\n  ) => string | undefined;\n  isOperationError: (error: Error) => boolean;\n  options?: TOptions;\n}): Promise<{\n  status: OperationStatus;\n  response: TResponse;\n}> {\n  const {\n    poll,\n    state,\n    operationLocation,\n    getOperationStatus,\n    getResourceLocation,\n    isOperationError,\n    options,\n  } = inputs;\n  const response = await poll(operationLocation, options).catch(\n    setStateError({\n      state,\n      isOperationError,\n    }),\n  );\n  const status = getOperationStatus(response, state);\n  logger.verbose(\n    `LRO: Status:\\n\\tPolling from: ${\n      state.config.operationLocation\n    }\\n\\tOperation status: ${status}\\n\\tPolling status: ${\n      terminalStates.includes(status) ? \"Stopped\" : \"Running\"\n    }`,\n  );\n  if (status === \"succeeded\") {\n    const resourceLocation = getResourceLocation(response, state);\n    if (resourceLocation !== undefined) {\n      return {\n        response: await poll(resourceLocation).catch(setStateError({ state, isOperationError })),\n        status,\n      };\n    }\n  }\n  return { response, status };\n}\n\n/** Polls the long-running operation. */\nexport async function pollOperation<\n  TResponse,\n  TResult,\n  TState extends OperationState<TResult>,\n  TOptions,\n>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  state: RestorableOperationState<TResult, TState>;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TResult, TState>,\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TResult, TState>,\n  ) => string | undefined;\n  isOperationError: (error: Error) => boolean;\n  getPollingInterval?: (response: TResponse) => number | undefined;\n  setDelay: (intervalInMs: number) => void;\n  getOperationLocation?: (\n    response: TResponse,\n    state: RestorableOperationState<TResult, TState>,\n  ) => string | undefined;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  processResult?: (result: TResponse, state: TState) => Promise<TResult>;\n  getError?: (response: TResponse) => LroError | undefined;\n  updateState?: (state: TState, lastResponse: TResponse) => void;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n  options?: TOptions;\n}): Promise<void> {\n  const {\n    poll,\n    state,\n    options,\n    getOperationStatus,\n    getResourceLocation,\n    getOperationLocation,\n    isOperationError,\n    withOperationLocation,\n    getPollingInterval,\n    processResult,\n    getError,\n    updateState,\n    setDelay,\n    isDone,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation } = state.config;\n  if (operationLocation !== undefined) {\n    const { response, status } = await pollOperationHelper({\n      poll,\n      getOperationStatus,\n      state,\n      operationLocation,\n      getResourceLocation,\n      isOperationError,\n      options,\n    });\n    await processOperationStatus({\n      status,\n      response,\n      state,\n      isDone,\n      processResult,\n      getError,\n      setErrorAsResult,\n    });\n\n    if (!terminalStates.includes(status)) {\n      const intervalInMs = getPollingInterval?.(response);\n      if (intervalInMs) setDelay(intervalInMs);\n      const location = getOperationLocation?.(response, state);\n      if (location !== undefined) {\n        const isUpdated = operationLocation !== location;\n        state.config.operationLocation = location;\n        withOperationLocation?.(location, isUpdated);\n      } else withOperationLocation?.(operationLocation, false);\n    }\n    updateState?.(state, response);\n  }\n}\n"]}