{"version":3,"file":"sse.js","sourceRoot":"","sources":["../../src/sse.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { IncomingMessage } from \"node:http\";\nimport type {\n  EventMessage,\n  EventMessageStream,\n  NodeJSReadableStream,\n  PartialSome,\n} from \"./models.js\";\nimport { createStream, ensureAsyncIterable } from \"./utils.js\";\n\nenum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Processes a response stream into a stream of events.\n * @param chunkStream - A stream of Uint8Array chunks\n * @returns A stream of EventMessage objects\n */\nexport function createSseStream(chunkStream: ReadableStream<Uint8Array>): EventMessageStream;\n/**\n * Processes a response stream into a stream of events.\n * @param chunkStream - A NodeJS HTTP response\n * @returns A stream of EventMessage objects\n */\nexport function createSseStream(chunkStream: IncomingMessage): EventMessageStream;\n/**\n * Processes a response stream into a stream of events.\n * @param chunkStream - A NodeJS Readable stream\n * @returns A stream of EventMessage objects\n */\nexport function createSseStream(chunkStream: NodeJSReadableStream): EventMessageStream;\nexport function createSseStream(\n  chunkStream: IncomingMessage | NodeJSReadableStream | ReadableStream<Uint8Array>,\n): EventMessageStream {\n  const { cancel, iterable } = ensureAsyncIterable(chunkStream);\n  const asyncIter = toMessage(toLine(iterable));\n  return createStream(asyncIter, cancel);\n}\n\nfunction concatBuffer(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction createMessage(): PartialSome<EventMessage, \"data\"> {\n  return {\n    data: undefined,\n    event: \"\",\n    id: \"\",\n    retry: undefined,\n  };\n}\n\nasync function* toLine(\n  chunkIter: AsyncIterable<Uint8Array>,\n): AsyncIterable<{ line: Uint8Array; fieldLen: number }> {\n  let buf: Uint8Array | undefined;\n  let bufIdx = 0;\n  let fieldLen = -1;\n  let discardTrailingNewline = false;\n  for await (const chunk of chunkIter) {\n    if (buf === undefined) {\n      buf = chunk;\n      bufIdx = 0;\n      fieldLen = -1;\n    } else {\n      buf = concatBuffer(buf, chunk);\n    }\n    const bufLen = buf.length;\n    let start = 0;\n    while (bufIdx < bufLen) {\n      if (discardTrailingNewline) {\n        if (buf[bufIdx] === ControlChars.NewLine) {\n          start = ++bufIdx;\n        }\n        discardTrailingNewline = false;\n      }\n      let end = -1;\n      for (; bufIdx < bufLen && end === -1; ++bufIdx) {\n        switch (buf[bufIdx]) {\n          case ControlChars.Colon:\n            if (fieldLen === -1) {\n              fieldLen = bufIdx - start;\n            }\n            break;\n          case ControlChars.CarriageReturn:\n            // We need to discard the trailing newline if any but can't do\n            // that now because we need to dispatch the current line first.\n            discardTrailingNewline = true;\n            end = bufIdx;\n            break;\n          case ControlChars.NewLine:\n            end = bufIdx;\n            break;\n        }\n      }\n      if (end === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next chunk and then continue parsing:\n        break;\n      }\n      yield { line: buf.subarray(start, end), fieldLen };\n      start = bufIdx; // we're now on the next line\n      fieldLen = -1;\n    }\n    if (start === bufLen) {\n      buf = undefined;\n    } else if (start !== 0) {\n      // discard already processed lines\n      buf = buf.subarray(start);\n      bufIdx -= start;\n    }\n  }\n}\n\nasync function* toMessage(\n  lineIter: AsyncIterable<{ line: Uint8Array; fieldLen: number }>,\n): AsyncIterableIterator<EventMessage> {\n  let message = createMessage();\n  const decoder = new TextDecoder();\n  for await (const { line, fieldLen } of lineIter) {\n    if (line.length === 0 && message.data !== undefined) {\n      // empty line denotes end of message. Yield and start a new message:\n      yield message as EventMessage;\n      message = createMessage();\n    } else if (fieldLen > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLen));\n      const valueOffset = fieldLen + (line[fieldLen + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case \"data\":\n          message.data = message.data ? message.data + \"\\n\" + value : value;\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          message.id = value;\n          break;\n        case \"retry\": {\n          const retry = parseInt(value, 10);\n          if (!isNaN(retry)) {\n            message.retry = retry;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n"]}