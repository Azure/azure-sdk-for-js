diff --git a/src/abort-controller/AbortError.ts b/src/abort-controller/AbortError.ts
index d075fbb..9f62db0 100644
--- a/src/abort-controller/AbortError.ts
+++ b/src/abort-controller/AbortError.ts
@@ -7,8 +7,8 @@
  * error matches `"AbortError"`.
  *
  * @example
- * ```ts snippet:AbortErrorSample
- * import { AbortError } from "@azure/abort-controller";
+ * ```ts snippet:ReadmeSampleAbortError
+ * import { AbortError } from "@typespec/ts-http-runtime";
  *
  * async function doAsyncWork(options: { abortSignal: AbortSignal }): Promise<void> {
  *   if (options.abortSignal.aborted) {
@@ -20,6 +20,7 @@
  *
  * const controller = new AbortController();
  * controller.abort();
+ *
  * try {
  *   doAsyncWork({ abortSignal: controller.signal });
  * } catch (e) {
diff --git a/src/abort-controller/AbortSignalLike.ts b/src/abort-controller/AbortSignalLike.ts
deleted file mode 100644
index b5b390d..0000000
--- a/src/abort-controller/AbortSignalLike.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * Allows the request to be aborted upon firing of the "abort" event.
- * Compatible with the browser built-in AbortSignal and common polyfills.
- */
-export interface AbortSignalLike {
-  /**
-   * Indicates if the signal has already been aborted.
-   */
-  readonly aborted: boolean;
-  /**
-   * Add new "abort" event listener, only support "abort" event.
-   */
-  addEventListener(
-    type: "abort",
-    listener: (this: AbortSignalLike, ev: any) => any,
-    options?: any,
-  ): void;
-  /**
-   * Remove "abort" event listener, only support "abort" event.
-   */
-  removeEventListener(
-    type: "abort",
-    listener: (this: AbortSignalLike, ev: any) => any,
-    options?: any,
-  ): void;
-}
diff --git a/src/abort-controller/index.ts b/src/abort-controller/index.ts
deleted file mode 100644
index 7f2adc4..0000000
--- a/src/abort-controller/index.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-declare global {
-  interface Event {}
-}
-
-export { AbortError } from "./AbortError.js";
-export { AbortSignalLike } from "./AbortSignalLike.js";
diff --git a/src/auth/azureKeyCredential.ts b/src/auth/azureKeyCredential.ts
deleted file mode 100644
index 65676e7..0000000
--- a/src/auth/azureKeyCredential.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { KeyCredential } from "./keyCredential.js";
-
-/**
- * A static-key-based credential that supports updating
- * the underlying key value.
- */
-export class AzureKeyCredential implements KeyCredential {
-  private _key: string;
-
-  /**
-   * The value of the key to be used in authentication
-   */
-  public get key(): string {
-    return this._key;
-  }
-
-  /**
-   * Create an instance of an AzureKeyCredential for use
-   * with a service client.
-   *
-   * @param key - The initial value of the key to use in authentication
-   */
-  constructor(key: string) {
-    if (!key) {
-      throw new Error("key must be a non-empty string");
-    }
-
-    this._key = key;
-  }
-
-  /**
-   * Change the value of the key.
-   *
-   * Updates will take effect upon the next request after
-   * updating the key value.
-   *
-   * @param newKey - The new key value to be used
-   */
-  public update(newKey: string): void {
-    this._key = newKey;
-  }
-}
diff --git a/src/auth/azureNamedKeyCredential.ts b/src/auth/azureNamedKeyCredential.ts
deleted file mode 100644
index 544c3c0..0000000
--- a/src/auth/azureNamedKeyCredential.ts
+++ /dev/null
@@ -1,88 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { isObjectWithProperties } from "@azure/core-util";
-
-/**
- * Represents a credential defined by a static API name and key.
- */
-export interface NamedKeyCredential {
-  /**
-   * The value of the API key represented as a string
-   */
-  readonly key: string;
-  /**
-   * The value of the API name represented as a string.
-   */
-  readonly name: string;
-}
-
-/**
- * A static name/key-based credential that supports updating
- * the underlying name and key values.
- */
-export class AzureNamedKeyCredential implements NamedKeyCredential {
-  private _key: string;
-  private _name: string;
-
-  /**
-   * The value of the key to be used in authentication.
-   */
-  public get key(): string {
-    return this._key;
-  }
-
-  /**
-   * The value of the name to be used in authentication.
-   */
-  public get name(): string {
-    return this._name;
-  }
-
-  /**
-   * Create an instance of an AzureNamedKeyCredential for use
-   * with a service client.
-   *
-   * @param name - The initial value of the name to use in authentication.
-   * @param key - The initial value of the key to use in authentication.
-   */
-  constructor(name: string, key: string) {
-    if (!name || !key) {
-      throw new TypeError("name and key must be non-empty strings");
-    }
-
-    this._name = name;
-    this._key = key;
-  }
-
-  /**
-   * Change the value of the key.
-   *
-   * Updates will take effect upon the next request after
-   * updating the key value.
-   *
-   * @param newName - The new name value to be used.
-   * @param newKey - The new key value to be used.
-   */
-  public update(newName: string, newKey: string): void {
-    if (!newName || !newKey) {
-      throw new TypeError("newName and newKey must be non-empty strings");
-    }
-
-    this._name = newName;
-    this._key = newKey;
-  }
-}
-
-/**
- * Tests an object to determine whether it implements NamedKeyCredential.
- *
- * @param credential - The assumed NamedKeyCredential to be tested.
- */
-export function isNamedKeyCredential(credential: unknown): credential is NamedKeyCredential {
-  return (
-    isObjectWithProperties(credential, ["name", "key"]) &&
-    typeof credential.key === "string" &&
-    typeof credential.name === "string"
-  );
-}
diff --git a/src/auth/azureSASCredential.ts b/src/auth/azureSASCredential.ts
deleted file mode 100644
index 045c639..0000000
--- a/src/auth/azureSASCredential.ts
+++ /dev/null
@@ -1,70 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { isObjectWithProperties } from "@azure/core-util";
-
-/**
- * Represents a credential defined by a static shared access signature.
- */
-export interface SASCredential {
-  /**
-   * The value of the shared access signature represented as a string
-   */
-  readonly signature: string;
-}
-
-/**
- * A static-signature-based credential that supports updating
- * the underlying signature value.
- */
-export class AzureSASCredential implements SASCredential {
-  private _signature: string;
-
-  /**
-   * The value of the shared access signature to be used in authentication
-   */
-  public get signature(): string {
-    return this._signature;
-  }
-
-  /**
-   * Create an instance of an AzureSASCredential for use
-   * with a service client.
-   *
-   * @param signature - The initial value of the shared access signature to use in authentication
-   */
-  constructor(signature: string) {
-    if (!signature) {
-      throw new Error("shared access signature must be a non-empty string");
-    }
-
-    this._signature = signature;
-  }
-
-  /**
-   * Change the value of the signature.
-   *
-   * Updates will take effect upon the next request after
-   * updating the signature value.
-   *
-   * @param newSignature - The new shared access signature value to be used
-   */
-  public update(newSignature: string): void {
-    if (!newSignature) {
-      throw new Error("shared access signature must be a non-empty string");
-    }
-
-    this._signature = newSignature;
-  }
-}
-
-/**
- * Tests an object to determine whether it implements SASCredential.
- *
- * @param credential - The assumed SASCredential to be tested.
- */
-export function isSASCredential(credential: unknown): credential is SASCredential {
-  return (
-    isObjectWithProperties(credential, ["signature"]) && typeof credential.signature === "string"
-  );
-}
diff --git a/src/auth/credentials.ts b/src/auth/credentials.ts
new file mode 100644
index 0000000..3079b40
--- /dev/null
+++ b/src/auth/credentials.ts
@@ -0,0 +1,106 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { OAuth2Flow } from "./oauth2Flows.js";
+
+/**
+ * Options used when creating and sending get OAuth 2 requests for this operation.
+ */
+export interface GetOAuth2TokenOptions {
+  /** Abort signal for the request */
+  abortSignal?: AbortSignal;
+}
+
+/**
+ * Options used when creating and sending get bearer token requests for this operation.
+ */
+export interface GetBearerTokenOptions {
+  /** Abort signal for the request */
+  abortSignal?: AbortSignal;
+}
+
+/**
+ * Credential for OAuth2 authentication flows.
+ */
+export interface OAuth2TokenCredential<TFlows extends OAuth2Flow> {
+  /**
+   * Gets an OAuth2 token for the specified flows.
+   * @param flows - The OAuth2 flows to use.
+   * @param options - Options for the request.
+   * @returns - a valid access token which was obtained through one of the flows specified in `flows`.
+   */
+  getOAuth2Token(flows: TFlows[], options?: GetOAuth2TokenOptions): Promise<string>;
+}
+
+/**
+ * Credential for Bearer token authentication.
+ */
+export interface BearerTokenCredential {
+  /**
+   * Gets a Bearer token for the specified flows.
+   * @param options - Options for the request.
+   * @returns - a valid access token.
+   */
+  getBearerToken(options?: GetBearerTokenOptions): Promise<string>;
+}
+
+/**
+ * Credential for HTTP Basic authentication.
+ * Provides username and password for basic authentication headers.
+ */
+export interface BasicCredential {
+  /** The username for basic authentication. */
+  username: string;
+  /** The password for basic authentication. */
+  password: string;
+}
+
+/**
+ * Credential for API Key authentication.
+ * Provides an API key that will be used in the request headers.
+ */
+export interface ApiKeyCredential {
+  /** The API key for authentication. */
+  key: string;
+}
+
+/**
+ * Union type of all supported authentication credentials.
+ */
+export type ClientCredential =
+  | OAuth2TokenCredential<OAuth2Flow>
+  | BearerTokenCredential
+  | BasicCredential
+  | ApiKeyCredential;
+
+/**
+ * Type guard to check if a credential is an OAuth2 token credential.
+ */
+export function isOAuth2TokenCredential(
+  credential: ClientCredential,
+): credential is OAuth2TokenCredential<OAuth2Flow> {
+  return "getOAuth2Token" in credential;
+}
+
+/**
+ * Type guard to check if a credential is a Bearer token credential.
+ */
+export function isBearerTokenCredential(
+  credential: ClientCredential,
+): credential is BearerTokenCredential {
+  return "getBearerToken" in credential;
+}
+
+/**
+ * Type guard to check if a credential is a Basic auth credential.
+ */
+export function isBasicCredential(credential: ClientCredential): credential is BasicCredential {
+  return "username" in credential && "password" in credential;
+}
+
+/**
+ * Type guard to check if a credential is an API key credential.
+ */
+export function isApiKeyCredential(credential: ClientCredential): credential is ApiKeyCredential {
+  return "key" in credential;
+}
diff --git a/src/auth/index.ts b/src/auth/index.ts
deleted file mode 100644
index 446268b..0000000
--- a/src/auth/index.ts
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-export { HttpMethods } from "@azure/core-util";
-export { AzureKeyCredential } from "./azureKeyCredential.js";
-export { KeyCredential, isKeyCredential } from "./keyCredential.js";
-export {
-  AzureNamedKeyCredential,
-  NamedKeyCredential,
-  isNamedKeyCredential,
-} from "./azureNamedKeyCredential.js";
-export { AzureSASCredential, SASCredential, isSASCredential } from "./azureSASCredential.js";
-
-export {
-  TokenCredential,
-  GetTokenOptions,
-  AccessToken,
-  isTokenCredential,
-} from "./tokenCredential.js";
-
-export { TracingContext } from "./tracing.js";
diff --git a/src/auth/keyCredential.ts b/src/auth/keyCredential.ts
deleted file mode 100644
index 9db25cf..0000000
--- a/src/auth/keyCredential.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { isObjectWithProperties } from "@azure/core-util";
-
-/**
- * Represents a credential defined by a static API key.
- */
-export interface KeyCredential {
-  /**
-   * The value of the API key represented as a string
-   */
-  readonly key: string;
-}
-
-/**
- * Tests an object to determine whether it implements KeyCredential.
- *
- * @param credential - The assumed KeyCredential to be tested.
- */
-export function isKeyCredential(credential: unknown): credential is KeyCredential {
-  return isObjectWithProperties(credential, ["key"]) && typeof credential.key === "string";
-}
diff --git a/src/auth/oauth2Flows.ts b/src/auth/oauth2Flows.ts
new file mode 100644
index 0000000..01f42e5
--- /dev/null
+++ b/src/auth/oauth2Flows.ts
@@ -0,0 +1,67 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/**
+ * Represents OAuth2 Authorization Code flow configuration.
+ */
+export interface AuthorizationCodeFlow {
+  /** Type of OAuth2 flow */
+  kind: "authorizationCode";
+  /** Authorization endpoint */
+  authorizationUrl: string;
+  /** Token endpoint */
+  tokenUrl: string;
+  /** Refresh token endpoint */
+  refreshUrl?: string;
+  /** OAuth2 scopes */
+  scopes?: string[];
+}
+
+/**
+ * Represents OAuth2 Client Credentials flow configuration.
+ */
+export interface ClientCredentialsFlow {
+  /** Type of OAuth2 flow */
+  kind: "clientCredentials";
+  /** Token endpoint */
+  tokenUrl: string;
+  /** Refresh token endpoints */
+  refreshUrl?: string[];
+  /** OAuth2 scopes */
+  scopes?: string[];
+}
+
+/**
+ * Represents OAuth2 Implicit flow configuration.
+ */
+export interface ImplicitFlow {
+  /** Type of OAuth2 flow */
+  kind: "implicit";
+  /** Authorization endpoint */
+  authorizationUrl: string;
+  /** Refresh token endpoint */
+  refreshUrl?: string;
+  /** OAuth2 scopes */
+  scopes?: string[];
+}
+
+/**
+ * Represents OAuth2 Password flow configuration.
+ */
+export interface PasswordFlow {
+  /** Type of OAuth2 flow */
+  kind: "password";
+  /** Token endpoint */
+  tokenUrl: string;
+  /** Refresh token endpoint */
+  refreshUrl?: string;
+  /** OAuth2 scopes */
+  scopes?: string[];
+}
+
+/** Union type of all supported OAuth2 flows */
+export type OAuth2Flow =
+  | AuthorizationCodeFlow
+  | ClientCredentialsFlow
+  | ImplicitFlow
+  | PasswordFlow;
diff --git a/src/auth/schemes.ts b/src/auth/schemes.ts
new file mode 100644
index 0000000..b5fb17b
--- /dev/null
+++ b/src/auth/schemes.ts
@@ -0,0 +1,66 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { OAuth2Flow } from "./oauth2Flows.js";
+
+/**
+ * Represents HTTP Basic authentication scheme.
+ * Basic authentication scheme requires a username and password to be provided with each request.
+ * The credentials are encoded using Base64 and included in the Authorization header.
+ */
+export interface BasicAuthScheme {
+  /** Type of auth scheme */
+  kind: "http";
+  /** Basic authentication scheme */
+  scheme: "basic";
+}
+
+/**
+ * Represents HTTP Bearer authentication scheme.
+ * Bearer authentication scheme requires a bearer token to be provided with each request.
+ * The token is included in the Authorization header with the "Bearer" prefix.
+ */
+export interface BearerAuthScheme {
+  /** Type of auth scheme */
+  kind: "http";
+  /** Bearer authentication scheme */
+  scheme: "bearer";
+}
+
+/**
+ * Represents an endpoint or operation that requires no authentication.
+ */
+export interface NoAuthAuthScheme {
+  /** Type of auth scheme */
+  kind: "noAuth";
+}
+
+/**
+ * Represents API Key authentication scheme.
+ * API Key authentication requires a key to be provided with each request.
+ * The key can be provided in different locations: query parameter, header, or cookie.
+ */
+export interface ApiKeyAuthScheme {
+  /** Type of auth scheme */
+  kind: "apiKey";
+  /** Location of the API key */
+  apiKeyLocation: "query" | "header" | "cookie";
+  /** Name of the API key parameter */
+  name: string;
+}
+
+/** Represents OAuth2 authentication scheme with specified flows */
+export interface OAuth2AuthScheme<TFlows extends OAuth2Flow[]> {
+  /** Type of auth scheme */
+  kind: "oauth2";
+  /** Supported OAuth2 flows */
+  flows: TFlows;
+}
+
+/** Union type of all supported authentication schemes */
+export type AuthScheme =
+  | BasicAuthScheme
+  | BearerAuthScheme
+  | NoAuthAuthScheme
+  | ApiKeyAuthScheme
+  | OAuth2AuthScheme<OAuth2Flow[]>;
diff --git a/src/auth/tokenCredential.ts b/src/auth/tokenCredential.ts
deleted file mode 100644
index 395b112..0000000
--- a/src/auth/tokenCredential.ts
+++ /dev/null
@@ -1,148 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AbortSignalLike } from "@azure/abort-controller";
-import type { TracingContext } from "./tracing.js";
-import type { HttpMethods } from "@azure/core-util";
-
-/**
- * Represents a credential capable of providing an authentication token.
- */
-export interface TokenCredential {
-  /**
-   * Gets the token provided by this credential.
-   *
-   * This method is called automatically by Azure SDK client libraries. You may call this method
-   * directly, but you must also handle token caching and token refreshing.
-   *
-   * @param scopes - The list of scopes for which the token will have access.
-   * @param options - The options used to configure any requests this
-   *                TokenCredential implementation might make.
-   */
-  getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
-}
-
-/**
- * Defines options for TokenCredential.getToken.
- */
-export interface GetTokenOptions {
-  /**
-   * The signal which can be used to abort requests.
-   */
-  abortSignal?: AbortSignalLike;
-  /**
-   * Options used when creating and sending HTTP requests for this operation.
-   */
-  requestOptions?: {
-    /**
-     * The number of milliseconds a request can take before automatically being terminated.
-     */
-    timeout?: number;
-  };
-  /**
-   * Options used when tracing is enabled.
-   */
-  tracingOptions?: {
-    /**
-     * Tracing Context for the current request.
-     */
-    tracingContext?: TracingContext;
-  };
-  /**
-   * Claim details to perform the Continuous Access Evaluation authentication flow
-   */
-  claims?: string;
-  /**
-   * Indicates whether to enable the Continuous Access Evaluation authentication flow
-   */
-  enableCae?: boolean;
-  /**
-   * Allows specifying a tenantId. Useful to handle challenges that provide tenant Id hints.
-   */
-  tenantId?: string;
-
-  /**
-   * Options for Proof of Possession token requests
-   */
-  proofOfPossessionOptions?: {
-    /**
-     * The nonce value required for PoP token requests.
-     * This is typically retrieved from the WWW-Authenticate header of a 401 challenge response.
-     * This is used in combination with {@link resourceRequestUrl} and {@link resourceRequestMethod} to generate the PoP token.
-     */
-    nonce: string;
-    /**
-     * The HTTP method of the request.
-     * This is used in combination with {@link resourceRequestUrl} and {@link nonce} to generate the PoP token.
-     */
-    resourceRequestMethod: HttpMethods;
-    /**
-     * The URL of the request.
-     * This is used in combination with {@link resourceRequestMethod} and {@link nonce} to generate the PoP token.
-     */
-    resourceRequestUrl: string;
-  };
-}
-
-/**
- * Represents an access token with an expiration time.
- */
-export interface AccessToken {
-  /**
-   * The access token returned by the authentication service.
-   */
-  token: string;
-
-  /**
-   * The access token's expiration timestamp in milliseconds, UNIX epoch time.
-   */
-  expiresOnTimestamp: number;
-
-  /**
-   * The timestamp when the access token should be refreshed, in milliseconds, UNIX epoch time.
-   */
-  refreshAfterTimestamp?: number;
-
-  /** Type of token - `Bearer` or `pop` */
-  tokenType?: "Bearer" | "pop";
-}
-
-/**
- * @internal
- * @param accessToken - Access token
- * @returns Whether a token is bearer type or not
- */
-export function isBearerToken(accessToken: AccessToken): boolean {
-  return !accessToken.tokenType || accessToken.tokenType === "Bearer";
-}
-
-/**
- * @internal
- * @param accessToken - Access token
- * @returns Whether a token is Pop token or not
- */
-export function isPopToken(accessToken: AccessToken): boolean {
-  return accessToken.tokenType === "pop";
-}
-
-/**
- * Tests an object to determine whether it implements TokenCredential.
- *
- * @param credential - The assumed TokenCredential to be tested.
- */
-export function isTokenCredential(credential: unknown): credential is TokenCredential {
-  // Check for an object with a 'getToken' function and possibly with
-  // a 'signRequest' function.  We do this check to make sure that
-  // a ServiceClientCredentials implementor (like TokenClientCredentials
-  // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
-  // it doesn't actually implement TokenCredential also.
-  const castCredential = credential as {
-    getToken: unknown;
-    signRequest: unknown;
-  };
-  return (
-    castCredential &&
-    typeof castCredential.getToken === "function" &&
-    (castCredential.signRequest === undefined || castCredential.getToken.length > 0)
-  );
-}
diff --git a/src/auth/tracing.ts b/src/auth/tracing.ts
deleted file mode 100644
index 8e846bb..0000000
--- a/src/auth/tracing.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-// The interfaces in this file should be kept in sync with those
-// found in the `@azure/core-tracing` package.
-
-/**
- * An interface structurally compatible with OpenTelemetry.
- */
-export interface TracingContext {
-  /**
-   * Get a value from the context.
-   *
-   * @param key - key which identifies a context value
-   */
-  getValue(key: symbol): unknown;
-  /**
-   * Create a new context which inherits from this context and has
-   * the given key set to the given value.
-   *
-   * @param key - context key for which to set the value
-   * @param value - value to set for the given key
-   */
-  setValue(key: symbol, value: unknown): TracingContext;
-  /**
-   * Return a new context which inherits from this context but does
-   * not contain a value for the given key.
-   *
-   * @param key - context key for which to clear a value
-   */
-  deleteValue(key: symbol): TracingContext;
-}
diff --git a/src/client/apiVersionPolicy.ts b/src/client/apiVersionPolicy.ts
index 56cb7b8..da27584 100644
--- a/src/client/apiVersionPolicy.ts
+++ b/src/client/apiVersionPolicy.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { PipelinePolicy } from "@azure/core-rest-pipeline";
+import type { PipelinePolicy } from "../pipeline.js";
 import type { ClientOptions } from "./common.js";
 
 export const apiVersionPolicyName = "ApiVersionPolicy";
diff --git a/src/client/clientHelpers.ts b/src/client/clientHelpers.ts
index 30dac33..d0a5cc1 100644
--- a/src/client/clientHelpers.ts
+++ b/src/client/clientHelpers.ts
@@ -1,84 +1,55 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { HttpClient, Pipeline } from "@azure/core-rest-pipeline";
-import {
-  bearerTokenAuthenticationPolicy,
-  createDefaultHttpClient,
-  createPipelineFromOptions,
-} from "@azure/core-rest-pipeline";
-import type { KeyCredential, TokenCredential } from "@azure/core-auth";
-import { isTokenCredential } from "@azure/core-auth";
-
+import type { HttpClient } from "../interfaces.js";
+import type { Pipeline } from "../pipeline.js";
+import { createDefaultHttpClient } from "../defaultHttpClient.js";
+import { createPipelineFromOptions } from "../createPipelineFromOptions.js";
 import type { ClientOptions } from "./common.js";
 import { apiVersionPolicy } from "./apiVersionPolicy.js";
-import { keyCredentialAuthenticationPolicy } from "./keyCredentialAuthenticationPolicy.js";
+import {
+  isApiKeyCredential,
+  isBasicCredential,
+  isBearerTokenCredential,
+  isOAuth2TokenCredential,
+} from "../auth/credentials.js";
+import { apiKeyAuthenticationPolicy } from "../policies/auth/apiKeyAuthenticationPolicy.js";
+import { basicAuthenticationPolicy } from "../policies/auth/basicAuthenticationPolicy.js";
+import { bearerAuthenticationPolicy } from "../policies/auth/bearerAuthenticationPolicy.js";
+import { oauth2AuthenticationPolicy } from "../policies/auth/oauth2AuthenticationPolicy.js";
 
 let cachedHttpClient: HttpClient | undefined;
 
-/**
- * Optional parameters for adding a credential policy to the pipeline.
- */
-export interface AddCredentialPipelinePolicyOptions {
-  /**
-   * Options related to the client.
-   */
-  clientOptions?: ClientOptions;
-  /**
-   * The credential to use.
-   */
-  credential?: TokenCredential | KeyCredential;
-}
-
-/**
- * Adds a credential policy to the pipeline if a credential is provided. If none is provided, no policy is added.
- */
-export function addCredentialPipelinePolicy(
-  pipeline: Pipeline,
-  endpoint: string,
-  options: AddCredentialPipelinePolicyOptions = {},
-): void {
-  const { credential, clientOptions } = options;
-  if (!credential) {
-    return;
-  }
-
-  if (isTokenCredential(credential)) {
-    const tokenPolicy = bearerTokenAuthenticationPolicy({
-      credential,
-      scopes: clientOptions?.credentials?.scopes ?? `${endpoint}/.default`,
-    });
-    pipeline.addPolicy(tokenPolicy);
-  } else if (isKeyCredential(credential)) {
-    if (!clientOptions?.credentials?.apiKeyHeaderName) {
-      throw new Error(`Missing API Key Header Name`);
-    }
-    const keyPolicy = keyCredentialAuthenticationPolicy(
-      credential,
-      clientOptions?.credentials?.apiKeyHeaderName,
-    );
-    pipeline.addPolicy(keyPolicy);
-  }
-}
-
 /**
  * Creates a default rest pipeline to re-use accross Rest Level Clients
  */
-export function createDefaultPipeline(
-  endpoint: string,
-  credential?: TokenCredential | KeyCredential,
-  options: ClientOptions = {},
-): Pipeline {
+export function createDefaultPipeline(options: ClientOptions = {}): Pipeline {
   const pipeline = createPipelineFromOptions(options);
 
   pipeline.addPolicy(apiVersionPolicy(options));
 
-  addCredentialPipelinePolicy(pipeline, endpoint, { credential, clientOptions: options });
-  return pipeline;
+  const { credential, authSchemes, allowInsecureConnection } = options;
+  if (credential) {
+    if (isApiKeyCredential(credential)) {
+      pipeline.addPolicy(
+        apiKeyAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection }),
+      );
+    } else if (isBasicCredential(credential)) {
+      pipeline.addPolicy(
+        basicAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection }),
+      );
+    } else if (isBearerTokenCredential(credential)) {
+      pipeline.addPolicy(
+        bearerAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection }),
+      );
+    } else if (isOAuth2TokenCredential(credential)) {
+      pipeline.addPolicy(
+        oauth2AuthenticationPolicy({ authSchemes, credential, allowInsecureConnection }),
+      );
+    }
   }
 
-function isKeyCredential(credential: any): credential is KeyCredential {
-  return (credential as KeyCredential).key !== undefined;
+  return pipeline;
 }
 
 export function getCachedDefaultHttpsClient(): HttpClient {
diff --git a/src/client/common.ts b/src/client/common.ts
index 58f6eba..4937868 100644
--- a/src/client/common.ts
+++ b/src/client/common.ts
@@ -3,19 +3,18 @@
 
 import type {
   HttpClient,
-  LogPolicyOptions,
-  Pipeline,
-  PipelineOptions,
-  PipelinePolicy,
   PipelineRequest,
   PipelineResponse,
   RawHttpHeaders,
   RequestBodyType,
   TransferProgressEvent,
-} from "@azure/core-rest-pipeline";
-import type { RawHttpHeadersInput } from "@azure/core-rest-pipeline";
-import type { AbortSignalLike } from "@azure/abort-controller";
-import type { OperationTracingOptions } from "@azure/core-tracing";
+  RawHttpHeadersInput,
+} from "../interfaces.js";
+import type { Pipeline, PipelinePolicy } from "../pipeline.js";
+import type { PipelineOptions } from "../createPipelineFromOptions.js";
+import type { LogPolicyOptions } from "../policies/logPolicy.js";
+import type { AuthScheme } from "../auth/schemes.js";
+import type { ClientCredential } from "../auth/credentials.js";
 
 /**
  * Shape of the default request parameters, this may be overridden by the specific
@@ -72,12 +71,7 @@ export type RequestParameters = {
   /**
    * The signal which can be used to abort requests.
    */
-  abortSignal?: AbortSignalLike;
-
-  /**
-   * Options used when tracing is enabled.
-   */
-  tracingOptions?: OperationTracingOptions;
+  abortSignal?: AbortSignal;
 
   /**
    * A function to be called each time a response is received from the server
@@ -91,16 +85,9 @@ export type RequestParameters = {
  * A function to be called each time a response is received from the server
  * while performing the requested operation.
  * May be called multiple times.
- *
- * This callback will be called with two parameters: the raw response, including headers and response body; and an error
- * object which will be provided if an error was thrown while processing the request.
- * The third __legacyError parameter is provided for backwards compatability only and will have an identical value to the `error` parameter.
  */
-export type RawResponseCallback = (
-  rawResponse: FullOperationResponse,
-  error?: unknown,
-  __legacyError?: unknown,
-) => void;
+// UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError parameter which was provided for backwards compatibility
+export type RawResponseCallback = (rawResponse: FullOperationResponse, error?: unknown) => void;
 
 /**
  * Wrapper object for http request and response. Deserialized object is stored in
@@ -130,16 +117,11 @@ export interface OperationOptions {
   /**
    * The signal which can be used to abort requests.
    */
-  abortSignal?: AbortSignalLike;
+  abortSignal?: AbortSignal;
   /**
    * Options used when creating and sending HTTP requests for this operation.
    */
   requestOptions?: OperationRequestOptions;
-  /**
-   * Options used when tracing is enabled.
-   */
-  tracingOptions?: OperationTracingOptions;
-
   /**
    * A function to be called each time a response is received from the server
    * while performing the requested operation.
@@ -201,8 +183,8 @@ export interface Client {
    * This method will be used to send request that would check the path to provide
    * strong types. When used by the codegen this type gets overridden with the generated
    * types. For example:
-   * ```typescript snippet:PathExample
-   * import { Client } from "@azure-rest/core-client";
+   * ```typescript snippet:ReadmeSamplePathExample
+   * import { Client } from "@typespec/ts-http-runtime";
    *
    * type MyClient = Client & {
    *   path: Routes;
@@ -217,18 +199,6 @@ export interface Client {
   pathUnchecked: PathUnchecked;
 }
 
-/**
- * A Node.js Readable stream that also has a `destroy` method.
- */
-export interface NodeJSReadableStream extends NodeJS.ReadableStream {
-  /**
-   * Destroy the stream. Optionally emit an 'error' event, and emit a
-   * 'close' event (unless emitClose is set to false). After this call,
-   * internal resources will be released.
-   */
-  destroy(error?: Error): void;
-}
-
 /**
  * Http Response which body is a NodeJS stream object
  */
@@ -236,7 +206,7 @@ export type HttpNodeStreamResponse = HttpResponse & {
   /**
    * Streamable body
    */
-  body?: NodeJSReadableStream;
+  body?: NodeJS.ReadableStream;
 };
 
 /**
@@ -333,23 +303,19 @@ export interface AdditionalPolicyConfig {
  */
 export type ClientOptions = PipelineOptions & {
   /**
-   * Credentials information
-   */
-  credentials?: {
-    /**
-     * Authentication scopes for AAD
+   * List of authentication schemes supported by the client.
+   * These schemes define how the client can authenticate requests.
    */
-    scopes?: string[];
-    /**
-     * Heder name for Client Secret authentication
-     */
-    apiKeyHeaderName?: string;
-  };
+  authSchemes?: AuthScheme[];
+
   /**
-   * Base url for the client
-   * @deprecated This property is deprecated and will be removed soon, please use endpoint instead
+   * The credential used to authenticate requests.
+   * Must be compatible with one of the specified authentication schemes.
    */
-  baseUrl?: string;
+  credential?: ClientCredential;
+
+  // UNBRANDED DIFFERENCE: The deprecated baseUrl property is removed in favor of the endpoint property in the unbranded Core package
+
   /**
    * Endpoint for the client
    */
@@ -374,6 +340,12 @@ export type ClientOptions = PipelineOptions & {
    * Options to configure request/response logging.
    */
   loggingOptions?: LogPolicyOptions;
+  /**
+   * Pipeline to use for the client. If not provided, a default pipeline will be created using the options provided.
+   * Use with caution -- when setting this option, all client options that are used in the creation of the default pipeline
+   * will be ignored.
+   */
+  pipeline?: Pipeline;
 };
 
 /**
diff --git a/src/client/getClient.ts b/src/client/getClient.ts
index af9b748..721f901 100644
--- a/src/client/getClient.ts
+++ b/src/client/getClient.ts
@@ -1,94 +1,127 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { KeyCredential, TokenCredential } from "@azure/core-auth";
-import { isKeyCredential, isTokenCredential } from "@azure/core-auth";
-import { type PipelineOptions } from "@azure/core-rest-pipeline";
+import type { HttpClient, HttpMethods } from "../interfaces.js";
+import type { Pipeline } from "../pipeline.js";
 import { createDefaultPipeline } from "./clientHelpers.js";
-import type { Client, ClientOptions, RequestParameters, StreamableMethod } from "./common.js";
-import {
-  getClient as tspGetClient,
-  type ClientOptions as TspClientOptions,
-} from "@typespec/ts-http-runtime";
-
-/**
- * Function to wrap RequestParameters so that we get the legacy onResponse behavior in core-client-rest
- */
-function wrapRequestParameters(parameters: RequestParameters): RequestParameters {
-  if (parameters.onResponse) {
-    return {
-      ...parameters,
-      onResponse(rawResponse, error) {
-        parameters.onResponse?.(rawResponse, error, error);
-      },
-    };
-  }
-
-  return parameters;
-}
+import type {
+  Client,
+  ClientOptions,
+  HttpBrowserStreamResponse,
+  HttpNodeStreamResponse,
+  RequestParameters,
+  ResourceMethods,
+  StreamableMethod,
+} from "./common.js";
+import { sendRequest } from "./sendRequest.js";
+import { buildRequestUrl } from "./urlHelpers.js";
+import { isNodeLike } from "../util/checkEnvironment.js";
 
-/**
- * Creates a client with a default pipeline
- * @param endpoint - Base endpoint for the client
- * @param options - Client options
- */
-export function getClient(endpoint: string, options?: ClientOptions): Client;
 /**
  * Creates a client with a default pipeline
  * @param endpoint - Base endpoint for the client
  * @param credentials - Credentials to authenticate the requests
  * @param options - Client options
  */
-export function getClient(
-  endpoint: string,
-  credentials?: TokenCredential | KeyCredential,
-  options?: ClientOptions,
-): Client;
-export function getClient(
-  endpoint: string,
-  credentialsOrPipelineOptions?: (TokenCredential | KeyCredential) | ClientOptions,
-  clientOptions: ClientOptions = {},
-): Client {
-  let credentials: TokenCredential | KeyCredential | undefined;
-  if (credentialsOrPipelineOptions) {
-    if (isCredential(credentialsOrPipelineOptions)) {
-      credentials = credentialsOrPipelineOptions;
-    } else {
-      clientOptions = credentialsOrPipelineOptions ?? {};
+export function getClient(endpoint: string, clientOptions: ClientOptions = {}): Client {
+  const pipeline = clientOptions.pipeline ?? createDefaultPipeline(clientOptions);
+  if (clientOptions.additionalPolicies?.length) {
+    for (const { policy, position } of clientOptions.additionalPolicies) {
+      // Sign happens after Retry and is commonly needed to occur
+      // before policies that intercept post-retry.
+      const afterPhase = position === "perRetry" ? "Sign" : undefined;
+      pipeline.addPolicy(policy, {
+        afterPhase,
+      });
     }
   }
 
-  const pipeline = createDefaultPipeline(endpoint, credentials, clientOptions);
-  const tspClient = tspGetClient(endpoint, {
-    ...clientOptions,
-    pipeline,
-  } as TspClientOptions) as Client;
+  const { allowInsecureConnection, httpClient } = clientOptions;
+  const endpointUrl = clientOptions.endpoint ?? endpoint;
+  const client = (path: string, ...args: Array<any>): ResourceMethods<StreamableMethod> => {
+    const getUrl = (requestOptions: RequestParameters): string =>
+      buildRequestUrl(endpointUrl, path, args, { allowInsecureConnection, ...requestOptions });
 
-  const client = (path: string, ...args: Array<any>) => {
     return {
       get: (requestOptions: RequestParameters = {}): StreamableMethod => {
-        return tspClient.path(path, ...args).get(wrapRequestParameters(requestOptions));
+        return buildOperation(
+          "GET",
+          getUrl(requestOptions),
+          pipeline,
+          requestOptions,
+          allowInsecureConnection,
+          httpClient,
+        );
       },
       post: (requestOptions: RequestParameters = {}): StreamableMethod => {
-        return tspClient.path(path, ...args).post(wrapRequestParameters(requestOptions));
+        return buildOperation(
+          "POST",
+          getUrl(requestOptions),
+          pipeline,
+          requestOptions,
+          allowInsecureConnection,
+          httpClient,
+        );
       },
       put: (requestOptions: RequestParameters = {}): StreamableMethod => {
-        return tspClient.path(path, ...args).put(wrapRequestParameters(requestOptions));
+        return buildOperation(
+          "PUT",
+          getUrl(requestOptions),
+          pipeline,
+          requestOptions,
+          allowInsecureConnection,
+          httpClient,
+        );
       },
       patch: (requestOptions: RequestParameters = {}): StreamableMethod => {
-        return tspClient.path(path, ...args).patch(wrapRequestParameters(requestOptions));
+        return buildOperation(
+          "PATCH",
+          getUrl(requestOptions),
+          pipeline,
+          requestOptions,
+          allowInsecureConnection,
+          httpClient,
+        );
       },
       delete: (requestOptions: RequestParameters = {}): StreamableMethod => {
-        return tspClient.path(path, ...args).delete(wrapRequestParameters(requestOptions));
+        return buildOperation(
+          "DELETE",
+          getUrl(requestOptions),
+          pipeline,
+          requestOptions,
+          allowInsecureConnection,
+          httpClient,
+        );
       },
       head: (requestOptions: RequestParameters = {}): StreamableMethod => {
-        return tspClient.path(path, ...args).head(wrapRequestParameters(requestOptions));
+        return buildOperation(
+          "HEAD",
+          getUrl(requestOptions),
+          pipeline,
+          requestOptions,
+          allowInsecureConnection,
+          httpClient,
+        );
       },
       options: (requestOptions: RequestParameters = {}): StreamableMethod => {
-        return tspClient.path(path, ...args).options(wrapRequestParameters(requestOptions));
+        return buildOperation(
+          "OPTIONS",
+          getUrl(requestOptions),
+          pipeline,
+          requestOptions,
+          allowInsecureConnection,
+          httpClient,
+        );
       },
       trace: (requestOptions: RequestParameters = {}): StreamableMethod => {
-        return tspClient.path(path, ...args).trace(wrapRequestParameters(requestOptions));
+        return buildOperation(
+          "TRACE",
+          getUrl(requestOptions),
+          pipeline,
+          requestOptions,
+          allowInsecureConnection,
+          httpClient,
+        );
       },
     };
   };
@@ -96,12 +129,58 @@ export function getClient(
   return {
     path: client,
     pathUnchecked: client,
-    pipeline: tspClient.pipeline,
+    pipeline,
   };
 }
 
-function isCredential(
-  param: (TokenCredential | KeyCredential) | PipelineOptions,
-): param is TokenCredential | KeyCredential {
-  return isKeyCredential(param) || isTokenCredential(param);
+function buildOperation(
+  method: HttpMethods,
+  url: string,
+  pipeline: Pipeline,
+  options: RequestParameters,
+  allowInsecureConnection?: boolean,
+  httpClient?: HttpClient,
+): StreamableMethod {
+  allowInsecureConnection = options.allowInsecureConnection ?? allowInsecureConnection;
+  return {
+    then: function (onFulfilled, onrejected) {
+      return sendRequest(
+        method,
+        url,
+        pipeline,
+        { ...options, allowInsecureConnection },
+        httpClient,
+      ).then(onFulfilled, onrejected);
+    },
+    async asBrowserStream() {
+      if (isNodeLike) {
+        throw new Error(
+          "`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.",
+        );
+      } else {
+        return sendRequest(
+          method,
+          url,
+          pipeline,
+          { ...options, allowInsecureConnection, responseAsStream: true },
+          httpClient,
+        ) as Promise<HttpBrowserStreamResponse>;
+      }
+    },
+    async asNodeStream() {
+      if (isNodeLike) {
+        return sendRequest(
+          method,
+          url,
+          pipeline,
+          { ...options, allowInsecureConnection, responseAsStream: true },
+          httpClient,
+        ) as Promise<HttpNodeStreamResponse>;
+      } else {
+        throw new Error(
+          "`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.",
+        );
+      }
+    },
+  };
 }
diff --git a/src/client/index.ts b/src/client/index.ts
deleted file mode 100644
index 1cd7d94..0000000
--- a/src/client/index.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * Azure Rest Core Client library for JavaScript
- * @packageDocumentation
- */
-
-export { createRestError } from "./restError.js";
-export {
-  addCredentialPipelinePolicy,
-  AddCredentialPipelinePolicyOptions,
-} from "./clientHelpers.js";
-export { operationOptionsToRequestParameters } from "./operationOptionHelpers.js";
-export * from "./getClient.js";
-export * from "./common.js";
diff --git a/src/client/keyCredentialAuthenticationPolicy.ts b/src/client/keyCredentialAuthenticationPolicy.ts
deleted file mode 100644
index 06bc091..0000000
--- a/src/client/keyCredentialAuthenticationPolicy.ts
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { KeyCredential } from "@azure/core-auth";
-import type {
-  PipelinePolicy,
-  PipelineRequest,
-  PipelineResponse,
-  SendRequest,
-} from "@azure/core-rest-pipeline";
-
-/**
- * The programmatic identifier of the bearerTokenAuthenticationPolicy.
- */
-export const keyCredentialAuthenticationPolicyName = "keyCredentialAuthenticationPolicy";
-
-export function keyCredentialAuthenticationPolicy(
-  credential: KeyCredential,
-  apiKeyHeaderName: string,
-): PipelinePolicy {
-  return {
-    name: keyCredentialAuthenticationPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      request.headers.set(apiKeyHeaderName, credential.key);
-      return next(request);
-    },
-  };
-}
diff --git a/src/client/multipart.ts b/src/client/multipart.ts
new file mode 100644
index 0000000..102ed57
--- /dev/null
+++ b/src/client/multipart.ts
@@ -0,0 +1,200 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { BodyPart, MultipartRequestBody, RawHttpHeadersInput } from "../interfaces.js";
+import { RestError } from "../restError.js";
+import { createHttpHeaders } from "../httpHeaders.js";
+import { stringToUint8Array } from "../util/bytesEncoding.js";
+import { isBinaryBody } from "../util/typeGuards.js";
+
+/**
+ * Describes a single part in a multipart body.
+ */
+export interface PartDescriptor {
+  /**
+   * Content type of this part. If set, this value will be used to set the Content-Type MIME header for this part, although explicitly
+   * setting the Content-Type header in the headers bag will override this value. If set to `null`, no content type will be inferred from
+   * the body field. Otherwise, the value of the Content-Type MIME header will be inferred based on the type of the body.
+   */
+  contentType?: string | null;
+
+  /**
+   * The disposition type of this part (for example, "form-data" for parts making up a multipart/form-data request). If set, this value
+   * will be used to set the Content-Disposition MIME header for this part, in addition to the `name` and `filename` properties.
+   * If the `name` or `filename` properties are set while `dispositionType` is left undefined, `dispositionType` will default to "form-data".
+   *
+   * Explicitly setting the Content-Disposition header in the headers bag will override this value.
+   */
+  dispositionType?: string;
+
+  /**
+   * The field name associated with this part. This value will be used to construct the Content-Disposition header,
+   * along with the `dispositionType` and `filename` properties, if the header has not been set in the `headers` bag.
+   */
+  name?: string;
+
+  /**
+   * The file name of the content if it is a file. This value will be used to construct the Content-Disposition header,
+   * along with the `dispositionType` and `name` properties, if the header has not been set in the `headers` bag.
+   */
+  filename?: string;
+
+  /**
+   * The multipart headers for this part of the multipart body. Values of the Content-Type and Content-Disposition headers set in the headers bag
+   * will take precedence over those computed from the request body or the contentType, dispositionType, name, and filename fields on this object.
+   */
+  headers?: RawHttpHeadersInput;
+
+  /**
+   * The body of this part of the multipart request.
+   */
+  body?: unknown;
+}
+
+type MultipartBodyType = BodyPart["body"];
+
+type HeaderValue = RawHttpHeadersInput[string];
+
+/**
+ * Get value of a header in the part descriptor ignoring case
+ */
+function getHeaderValue(descriptor: PartDescriptor, headerName: string): HeaderValue | undefined {
+  if (descriptor.headers) {
+    const actualHeaderName = Object.keys(descriptor.headers).find(
+      (x) => x.toLowerCase() === headerName.toLowerCase(),
+    );
+    if (actualHeaderName) {
+      return descriptor.headers[actualHeaderName];
+    }
+  }
+
+  return undefined;
+}
+
+function getPartContentType(descriptor: PartDescriptor): HeaderValue | undefined {
+  const contentTypeHeader = getHeaderValue(descriptor, "content-type");
+  if (contentTypeHeader) {
+    return contentTypeHeader;
+  }
+
+  // Special value of null means content type is to be omitted
+  if (descriptor.contentType === null) {
+    return undefined;
+  }
+
+  if (descriptor.contentType) {
+    return descriptor.contentType;
+  }
+
+  const { body } = descriptor;
+
+  if (body === null || body === undefined) {
+    return undefined;
+  }
+
+  if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
+    return "text/plain; charset=UTF-8";
+  }
+
+  if (body instanceof Blob) {
+    return body.type || "application/octet-stream";
+  }
+
+  if (isBinaryBody(body)) {
+    return "application/octet-stream";
+  }
+
+  // arbitrary non-text object -> generic JSON content type by default. We will try to JSON.stringify the body.
+  return "application/json";
+}
+
+/**
+ * Enclose value in quotes and escape special characters, for use in the Content-Disposition header
+ */
+function escapeDispositionField(value: string): string {
+  return JSON.stringify(value);
+}
+
+function getContentDisposition(descriptor: PartDescriptor): HeaderValue | undefined {
+  const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
+  if (contentDispositionHeader) {
+    return contentDispositionHeader;
+  }
+
+  if (
+    descriptor.dispositionType === undefined &&
+    descriptor.name === undefined &&
+    descriptor.filename === undefined
+  ) {
+    return undefined;
+  }
+
+  const dispositionType = descriptor.dispositionType ?? "form-data";
+
+  let disposition = dispositionType;
+  if (descriptor.name) {
+    disposition += `; name=${escapeDispositionField(descriptor.name)}`;
+  }
+
+  let filename: string | undefined = undefined;
+  if (descriptor.filename) {
+    filename = descriptor.filename;
+  } else if (typeof File !== "undefined" && descriptor.body instanceof File) {
+    const filenameFromFile = (descriptor.body as File).name;
+    if (filenameFromFile !== "") {
+      filename = filenameFromFile;
+    }
+  }
+
+  if (filename) {
+    disposition += `; filename=${escapeDispositionField(filename)}`;
+  }
+
+  return disposition;
+}
+
+function normalizeBody(body?: unknown, contentType?: HeaderValue): MultipartBodyType {
+  if (body === undefined) {
+    // zero-length body
+    return new Uint8Array([]);
+  }
+
+  // binary and primitives should go straight on the wire regardless of content type
+  if (isBinaryBody(body)) {
+    return body;
+  }
+  if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
+    return stringToUint8Array(String(body), "utf-8");
+  }
+
+  // stringify objects for JSON-ish content types e.g. application/json, application/merge-patch+json, application/vnd.oci.manifest.v1+json, application.json; charset=UTF-8
+  if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
+    return stringToUint8Array(JSON.stringify(body), "utf-8");
+  }
+
+  throw new RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
+}
+
+export function buildBodyPart(descriptor: PartDescriptor): BodyPart {
+  const contentType = getPartContentType(descriptor);
+  const contentDisposition = getContentDisposition(descriptor);
+  const headers = createHttpHeaders(descriptor.headers ?? {});
+
+  if (contentType) {
+    headers.set("content-type", contentType);
+  }
+  if (contentDisposition) {
+    headers.set("content-disposition", contentDisposition);
+  }
+
+  const body = normalizeBody(descriptor.body, contentType);
+
+  return {
+    headers,
+    body,
+  };
+}
+
+export function buildMultipartBody(parts: PartDescriptor[]): MultipartRequestBody {
+  return { parts: parts.map(buildBodyPart) };
+}
diff --git a/src/client/operationOptionHelpers.ts b/src/client/operationOptionHelpers.ts
index 39bbbdb..15bdc45 100644
--- a/src/client/operationOptionHelpers.ts
+++ b/src/client/operationOptionHelpers.ts
@@ -3,18 +3,20 @@
 
 import type { OperationOptions, RequestParameters } from "./common.js";
 
-import {
-  operationOptionsToRequestParameters as tspOperationOptionsToRequestParameters,
-  type OperationOptions as TspOperationOptions,
-} from "@typespec/ts-http-runtime";
-
 /**
  * Helper function to convert OperationOptions to RequestParameters
  * @param options - the options that are used by Modular layer to send the request
  * @returns the result of the conversion in RequestParameters of RLC layer
  */
 export function operationOptionsToRequestParameters(options: OperationOptions): RequestParameters {
-  return tspOperationOptionsToRequestParameters(
-    options as TspOperationOptions,
-  ) as RequestParameters;
+  return {
+    allowInsecureConnection: options.requestOptions?.allowInsecureConnection,
+    timeout: options.requestOptions?.timeout,
+    skipUrlEncoding: options.requestOptions?.skipUrlEncoding,
+    abortSignal: options.abortSignal,
+    onUploadProgress: options.requestOptions?.onUploadProgress,
+    onDownloadProgress: options.requestOptions?.onDownloadProgress,
+    headers: { ...options.requestOptions?.headers },
+    onResponse: options.onResponse,
+  };
 }
diff --git a/src/client/restError.ts b/src/client/restError.ts
index a2f59f9..6b630ef 100644
--- a/src/client/restError.ts
+++ b/src/client/restError.ts
@@ -1,14 +1,11 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { RestError } from "@azure/core-rest-pipeline";
+import type { PipelineResponse } from "../interfaces.js";
+import { RestError } from "../restError.js";
+import { createHttpHeaders } from "../httpHeaders.js";
 import type { PathUncheckedResponse } from "./common.js";
 
-import {
-  createRestError as tspCreateRestError,
-  type PathUncheckedResponse as TspPathUncheckedResponse,
-} from "@typespec/ts-http-runtime";
-
 /**
  * Creates a rest error from a PathUnchecked response
  */
@@ -21,9 +18,30 @@ export function createRestError(
   messageOrResponse: string | PathUncheckedResponse,
   response?: PathUncheckedResponse,
 ): RestError {
-  if (typeof messageOrResponse === "string") {
-    return tspCreateRestError(messageOrResponse, response! as TspPathUncheckedResponse);
-  } else {
-    return tspCreateRestError(messageOrResponse as TspPathUncheckedResponse);
+  const resp = typeof messageOrResponse === "string" ? response! : messageOrResponse;
+  const internalError = resp.body?.error ?? resp.body;
+  const message =
+    typeof messageOrResponse === "string"
+      ? messageOrResponse
+      : (internalError?.message ?? `Unexpected status code: ${resp.status}`);
+  return new RestError(message, {
+    statusCode: statusCodeToNumber(resp.status),
+    code: internalError?.code,
+    request: resp.request,
+    response: toPipelineResponse(resp),
+  });
+}
+
+function toPipelineResponse(response: PathUncheckedResponse): PipelineResponse {
+  return {
+    headers: createHttpHeaders(response.headers),
+    request: response.request,
+    status: statusCodeToNumber(response.status) ?? -1,
+  };
 }
+
+function statusCodeToNumber(statusCode: string): number | undefined {
+  const status = Number.parseInt(statusCode);
+
+  return Number.isNaN(status) ? undefined : status;
 }
diff --git a/src/client/sendRequest.ts b/src/client/sendRequest.ts
new file mode 100644
index 0000000..dc3b0f5
--- /dev/null
+++ b/src/client/sendRequest.ts
@@ -0,0 +1,230 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type {
+  HttpClient,
+  HttpMethods,
+  MultipartRequestBody,
+  PipelineRequest,
+  PipelineResponse,
+  RequestBodyType,
+} from "../interfaces.js";
+import { isRestError, RestError } from "../restError.js";
+import type { Pipeline } from "../pipeline.js";
+import { createHttpHeaders } from "../httpHeaders.js";
+import { createPipelineRequest } from "../pipelineRequest.js";
+import { getCachedDefaultHttpsClient } from "./clientHelpers.js";
+import { isReadableStream } from "../util/typeGuards.js";
+import type { HttpResponse, RequestParameters } from "./common.js";
+import type { PartDescriptor } from "./multipart.js";
+import { buildMultipartBody } from "./multipart.js";
+
+/**
+ * Helper function to send request used by the client
+ * @param method - method to use to send the request
+ * @param url - url to send the request to
+ * @param pipeline - pipeline with the policies to run when sending the request
+ * @param options - request options
+ * @param customHttpClient - a custom HttpClient to use when making the request
+ * @returns returns and HttpResponse
+ */
+export async function sendRequest(
+  method: HttpMethods,
+  url: string,
+  pipeline: Pipeline,
+  options: InternalRequestParameters = {},
+  customHttpClient?: HttpClient,
+): Promise<HttpResponse> {
+  const httpClient = customHttpClient ?? getCachedDefaultHttpsClient();
+  const request = buildPipelineRequest(method, url, options);
+
+  try {
+    const response = await pipeline.sendRequest(httpClient, request);
+    const headers = response.headers.toJSON();
+    const stream = response.readableStreamBody ?? response.browserStreamBody;
+    const parsedBody =
+      options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);
+    const body = stream ?? parsedBody;
+
+    if (options?.onResponse) {
+      options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });
+    }
+
+    return {
+      request,
+      headers,
+      status: `${response.status}`,
+      body,
+    };
+  } catch (e: unknown) {
+    if (isRestError(e) && e.response && options.onResponse) {
+      const { response } = e;
+      const rawHeaders = response.headers.toJSON();
+      // UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError property
+      options?.onResponse({ ...response, request, rawHeaders }, e);
+    }
+
+    throw e;
+  }
+}
+
+/**
+ * Function to determine the request content type
+ * @param options - request options InternalRequestParameters
+ * @returns returns the content-type
+ */
+function getRequestContentType(options: InternalRequestParameters = {}): string {
+  return (
+    options.contentType ??
+    (options.headers?.["content-type"] as string) ??
+    getContentType(options.body)
+  );
+}
+
+/**
+ * Function to determine the content-type of a body
+ * this is used if an explicit content-type is not provided
+ * @param body - body in the request
+ * @returns returns the content-type
+ */
+function getContentType(body: any): string | undefined {
+  if (ArrayBuffer.isView(body)) {
+    return "application/octet-stream";
+  }
+
+  if (typeof body === "string") {
+    try {
+      JSON.parse(body);
+      return "application/json";
+    } catch (error: any) {
+      // If we fail to parse the body, it is not json
+      return undefined;
+    }
+  }
+  // By default return json
+  return "application/json";
+}
+
+export interface InternalRequestParameters extends RequestParameters {
+  responseAsStream?: boolean;
+}
+
+function buildPipelineRequest(
+  method: HttpMethods,
+  url: string,
+  options: InternalRequestParameters = {},
+): PipelineRequest {
+  const requestContentType = getRequestContentType(options);
+  const { body, multipartBody } = getRequestBody(options.body, requestContentType);
+  const hasContent = body !== undefined || multipartBody !== undefined;
+
+  const headers = createHttpHeaders({
+    ...(options.headers ? options.headers : {}),
+    accept: options.accept ?? options.headers?.accept ?? "application/json",
+    ...(hasContent &&
+      requestContentType && {
+        "content-type": requestContentType,
+      }),
+  });
+
+  return createPipelineRequest({
+    url,
+    method,
+    body,
+    multipartBody,
+    headers,
+    allowInsecureConnection: options.allowInsecureConnection,
+    abortSignal: options.abortSignal,
+    onUploadProgress: options.onUploadProgress,
+    onDownloadProgress: options.onDownloadProgress,
+    timeout: options.timeout,
+    enableBrowserStreams: true,
+    streamResponseStatusCodes: options.responseAsStream
+      ? new Set([Number.POSITIVE_INFINITY])
+      : undefined,
+  });
+}
+
+interface RequestBody {
+  body?: RequestBodyType;
+  multipartBody?: MultipartRequestBody;
+}
+
+/**
+ * Prepares the body before sending the request
+ */
+function getRequestBody(body?: unknown, contentType: string = ""): RequestBody {
+  if (body === undefined) {
+    return { body: undefined };
+  }
+
+  if (typeof FormData !== "undefined" && body instanceof FormData) {
+    return { body };
+  }
+
+  if (isReadableStream(body)) {
+    return { body };
+  }
+
+  if (ArrayBuffer.isView(body)) {
+    return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
+  }
+
+  const firstType = contentType.split(";")[0];
+
+  switch (firstType) {
+    case "application/json":
+      return { body: JSON.stringify(body) };
+    case "multipart/form-data":
+      if (Array.isArray(body)) {
+        return { multipartBody: buildMultipartBody(body as PartDescriptor[]) };
+      }
+      return { body: JSON.stringify(body) };
+    case "text/plain":
+      return { body: String(body) };
+    default:
+      if (typeof body === "string") {
+        return { body };
+      }
+      return { body: JSON.stringify(body) };
+  }
+}
+
+/**
+ * Prepares the response body
+ */
+function getResponseBody(response: PipelineResponse): RequestBodyType | undefined {
+  // Set the default response type
+  const contentType = response.headers.get("content-type") ?? "";
+  const firstType = contentType.split(";")[0];
+  const bodyToParse = response.bodyAsText ?? "";
+
+  if (firstType === "text/plain") {
+    return String(bodyToParse);
+  }
+  // Default to "application/json" and fallback to string;
+  try {
+    return bodyToParse ? JSON.parse(bodyToParse) : undefined;
+  } catch (error: any) {
+    // If we were supposed to get a JSON object and failed to
+    // parse, throw a parse error
+    if (firstType === "application/json") {
+      throw createParseError(response, error);
+    }
+
+    // We are not sure how to handle the response so we return it as
+    // plain text.
+    return String(bodyToParse);
+  }
+}
+
+function createParseError(response: PipelineResponse, err: any): RestError {
+  const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
+  const errCode = err.code ?? RestError.PARSE_ERROR;
+  return new RestError(msg, {
+    code: errCode,
+    statusCode: response.status,
+    request: response.request,
+    response: response,
+  });
+}
diff --git a/src/client/urlHelpers.ts b/src/client/urlHelpers.ts
new file mode 100644
index 0000000..f30583b
--- /dev/null
+++ b/src/client/urlHelpers.ts
@@ -0,0 +1,219 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { PathParameterWithOptions, RequestParameters } from "./common.js";
+
+type QueryParameterStyle = "form" | "spaceDelimited" | "pipeDelimited";
+
+/**
+ * An object that can be passed as a query parameter, allowing for additional options to be set relating to how the parameter is encoded.
+ */
+interface QueryParameterWithOptions {
+  /**
+   * The value of the query parameter.
+   */
+  value: unknown;
+
+  /**
+   * If set to true, value must be an array. Setting this option to true will cause the array to be encoded as multiple query parameters.
+   * Setting it to false will cause the array values to be encoded as a single query parameter, with each value separated by a comma ','.
+   *
+   * For example, with `explode` set to true, a query parameter named "foo" with value ["a", "b", "c"] will be encoded as foo=a&foo=b&foo=c.
+   * If `explode` was set to false, the same example would instead be encouded as foo=a,b,c.
+   *
+   * Defaults to false.
+   */
+  explode?: boolean;
+
+  /**
+   * Style for encoding arrays. Three possible values:
+   * - "form": array values will be separated by a comma "," in the query parameter value.
+   * - "spaceDelimited": array values will be separated by a space (" ", url-encoded to "%20").
+   * - "pipeDelimited": array values will be separated by a pipe ("|").
+   *
+   * Defaults to "form".
+   */
+  style?: QueryParameterStyle;
+}
+
+function isQueryParameterWithOptions(x: unknown): x is QueryParameterWithOptions {
+  const value = (x as QueryParameterWithOptions).value as any;
+  return (
+    value !== undefined && value.toString !== undefined && typeof value.toString === "function"
+  );
+}
+
+/**
+ * Builds the request url, filling in query and path parameters
+ * @param endpoint - base url which can be a template url
+ * @param routePath - path to append to the endpoint
+ * @param pathParameters - values of the path parameters
+ * @param options - request parameters including query parameters
+ * @returns a full url with path and query parameters
+ */
+export function buildRequestUrl(
+  endpoint: string,
+  routePath: string,
+  pathParameters: (string | number | PathParameterWithOptions)[],
+  options: RequestParameters = {},
+): string {
+  if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
+    return routePath;
+  }
+  endpoint = buildBaseUrl(endpoint, options);
+  routePath = buildRoutePath(routePath, pathParameters, options);
+  const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);
+  const url = new URL(requestUrl);
+
+  return (
+    url
+      .toString()
+      // Remove double forward slashes
+      .replace(/([^:]\/)\/+/g, "$1")
+  );
+}
+
+function getQueryParamValue(
+  key: string,
+  allowReserved: boolean,
+  style: QueryParameterStyle,
+  param: any,
+): string {
+  let separator: string;
+  if (style === "pipeDelimited") {
+    separator = "|";
+  } else if (style === "spaceDelimited") {
+    separator = "%20";
+  } else {
+    separator = ",";
+  }
+
+  let paramValues: any[];
+  if (Array.isArray(param)) {
+    paramValues = param;
+  } else if (typeof param === "object" && param.toString === Object.prototype.toString) {
+    // If the parameter is an object without a custom toString implementation (e.g. a Date),
+    // then we should deconstruct the object into an array [key1, value1, key2, value2, ...].
+    paramValues = Object.entries(param).flat();
+  } else {
+    paramValues = [param];
+  }
+
+  const value = paramValues
+    .map((p) => {
+      if (p === null || p === undefined) {
+        return "";
+      }
+
+      if (!p.toString || typeof p.toString !== "function") {
+        throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
+      }
+
+      const rawValue = p.toISOString !== undefined ? p.toISOString() : p.toString();
+      return allowReserved ? rawValue : encodeURIComponent(rawValue);
+    })
+    .join(separator);
+
+  return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
+}
+
+function appendQueryParams(url: string, options: RequestParameters = {}): string {
+  if (!options.queryParameters) {
+    return url;
+  }
+  const parsedUrl = new URL(url);
+  const queryParams = options.queryParameters;
+
+  const paramStrings: string[] = [];
+  for (const key of Object.keys(queryParams)) {
+    const param = queryParams[key] as any;
+    if (param === undefined || param === null) {
+      continue;
+    }
+
+    const hasMetadata = isQueryParameterWithOptions(param);
+    const rawValue = hasMetadata ? param.value : param;
+    const explode = hasMetadata ? (param.explode ?? false) : false;
+    const style = hasMetadata && param.style ? param.style : "form";
+
+    if (explode) {
+      if (Array.isArray(rawValue)) {
+        for (const item of rawValue) {
+          paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, item));
+        }
+      } else if (typeof rawValue === "object") {
+        // For object explode, the name of the query parameter is ignored and we use the object key instead
+        for (const [actualKey, value] of Object.entries(rawValue)) {
+          paramStrings.push(
+            getQueryParamValue(actualKey, options.skipUrlEncoding ?? false, style, value),
+          );
+        }
+      } else {
+        // Explode doesn't really make sense for primitives
+        throw new Error("explode can only be set to true for objects and arrays");
+      }
+    } else {
+      paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, rawValue));
+    }
+  }
+
+  if (parsedUrl.search !== "") {
+    parsedUrl.search += "&";
+  }
+  parsedUrl.search += paramStrings.join("&");
+  return parsedUrl.toString();
+}
+
+export function buildBaseUrl(endpoint: string, options: RequestParameters): string {
+  if (!options.pathParameters) {
+    return endpoint;
+  }
+  const pathParams = options.pathParameters;
+  for (const [key, param] of Object.entries(pathParams)) {
+    if (param === undefined || param === null) {
+      throw new Error(`Path parameters ${key} must not be undefined or null`);
+    }
+    if (!param.toString || typeof param.toString !== "function") {
+      throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
+    }
+    let value = param.toISOString !== undefined ? param.toISOString() : String(param);
+    if (!options.skipUrlEncoding) {
+      value = encodeURIComponent(param);
+    }
+    endpoint = replaceAll(endpoint, `{${key}}`, value) ?? "";
+  }
+  return endpoint;
+}
+
+function buildRoutePath(
+  routePath: string,
+  pathParameters: (string | number | PathParameterWithOptions)[],
+  options: RequestParameters = {},
+): string {
+  for (const pathParam of pathParameters) {
+    const allowReserved = typeof pathParam === "object" && (pathParam.allowReserved ?? false);
+    let value = typeof pathParam === "object" ? pathParam.value : pathParam;
+
+    if (!options.skipUrlEncoding && !allowReserved) {
+      value = encodeURIComponent(value);
+    }
+
+    routePath = routePath.replace(/\{[\w-]+\}/, String(value));
+  }
+  return routePath;
+}
+
+/**
+ * Replace all of the instances of searchValue in value with the provided replaceValue.
+ * @param value - The value to search and replace in.
+ * @param searchValue - The value to search for in the value argument.
+ * @param replaceValue - The value to replace searchValue with in the value argument.
+ * @returns The value where each instance of searchValue was replaced with replacedValue.
+ */
+export function replaceAll(
+  value: string | undefined,
+  searchValue: string,
+  replaceValue: string,
+): string | undefined {
+  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
+}
diff --git a/src/constants.ts b/src/constants.ts
index 8136c63..0ff983d 100644
--- a/src/constants.ts
+++ b/src/constants.ts
@@ -1,6 +1,6 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-export const SDK_VERSION: string = "1.20.0";
+export const SDK_VERSION: string = "0.2.2";
 
 export const DEFAULT_RETRY_POLICY_COUNT = 3;
diff --git a/src/createPipelineFromOptions.ts b/src/createPipelineFromOptions.ts
index b8ebf02..fb56a78 100644
--- a/src/createPipelineFromOptions.ts
+++ b/src/createPipelineFromOptions.ts
@@ -6,17 +6,14 @@ import { type Pipeline, createEmptyPipeline } from "./pipeline.js";
 import type { Agent, PipelineRetryOptions, ProxySettings, TlsSettings } from "./interfaces.js";
 import { type RedirectPolicyOptions, redirectPolicy } from "./policies/redirectPolicy.js";
 import { type UserAgentPolicyOptions, userAgentPolicy } from "./policies/userAgentPolicy.js";
-import { multipartPolicy, multipartPolicyName } from "./policies/multipartPolicy.js";
 import { decompressResponsePolicy } from "./policies/decompressResponsePolicy.js";
 import { defaultRetryPolicy } from "./policies/defaultRetryPolicy.js";
 import { formDataPolicy } from "./policies/formDataPolicy.js";
-import { isNodeLike } from "@azure/core-util";
+import { isNodeLike } from "./util/checkEnvironment.js";
 import { proxyPolicy } from "./policies/proxyPolicy.js";
-import { setClientRequestIdPolicy } from "./policies/setClientRequestIdPolicy.js";
 import { agentPolicy } from "./policies/agentPolicy.js";
 import { tlsPolicy } from "./policies/tlsPolicy.js";
-import { tracingPolicy } from "./policies/tracingPolicy.js";
-import { wrapAbortSignalLikePolicy } from "./policies/wrapAbortSignalLikePolicy.js";
+import { multipartPolicy, multipartPolicyName } from "./policies/multipartPolicy.js";
 
 /**
  * Defines options that are used to configure the HTTP pipeline for
@@ -94,19 +91,13 @@ export function createPipelineFromOptions(options: InternalPipelineOptions): Pip
     pipeline.addPolicy(decompressResponsePolicy());
   }
 
-  pipeline.addPolicy(wrapAbortSignalLikePolicy());
-
   pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });
   pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
-  pipeline.addPolicy(setClientRequestIdPolicy(options.telemetryOptions?.clientRequestIdHeaderName));
   // The multipart policy is added after policies with no phase, so that
   // policies can be added between it and formDataPolicy to modify
   // properties (e.g., making the boundary constant in recorded tests).
   pipeline.addPolicy(multipartPolicy(), { afterPhase: "Deserialize" });
   pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
-  pipeline.addPolicy(tracingPolicy({ ...options.userAgentOptions, ...options.loggingOptions }), {
-    afterPhase: "Retry",
-  });
   if (isNodeLike) {
     // Both XHR and Fetch expect to handle redirects automatically,
     // so only include this policy when we're in Node.
diff --git a/src/defaultHttpClient-browser.mts b/src/defaultHttpClient-browser.mts
new file mode 100644
index 0000000..9fd4e7c
--- /dev/null
+++ b/src/defaultHttpClient-browser.mts
@@ -0,0 +1,12 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { HttpClient } from "./interfaces.js";
+import { createFetchHttpClient } from "./fetchHttpClient.js";
+
+/**
+ * Create the correct HttpClient for the current environment.
+ */
+export function createDefaultHttpClient(): HttpClient {
+  return createFetchHttpClient();
+}
diff --git a/src/defaultHttpClient-react-native.mts b/src/defaultHttpClient-react-native.mts
new file mode 100644
index 0000000..0640b78
--- /dev/null
+++ b/src/defaultHttpClient-react-native.mts
@@ -0,0 +1,12 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { HttpClient } from "./interfaces.js";
+import { createXhrHttpClient } from "./xhrHttpClient.js";
+
+/**
+ * Create the correct HttpClient for the current environment.
+ */
+export function createDefaultHttpClient(): HttpClient {
+  return createXhrHttpClient();
+}
diff --git a/src/defaultHttpClient.ts b/src/defaultHttpClient.ts
index b217f8c..7da85d9 100644
--- a/src/defaultHttpClient.ts
+++ b/src/defaultHttpClient.ts
@@ -2,29 +2,11 @@
 // Licensed under the MIT License.
 
 import type { HttpClient } from "./interfaces.js";
-import { createDefaultHttpClient as tspCreateDefaultHttpClient } from "@typespec/ts-http-runtime";
-import { wrapAbortSignalLike } from "./util/wrapAbortSignal.js";
-import { type PipelineRequest as TspPipelineRequest } from "@typespec/ts-http-runtime";
+import { createNodeHttpClient } from "./nodeHttpClient.js";
 
 /**
  * Create the correct HttpClient for the current environment.
  */
 export function createDefaultHttpClient(): HttpClient {
-  const client = tspCreateDefaultHttpClient();
-  return {
-    async sendRequest(request) {
-      // we wrap any AbortSignalLike here since the TypeSpec runtime expects a native AbortSignal.
-      // 99% of the time, this should be a no-op since a native AbortSignal is passed in.
-      const { abortSignal, cleanup } = request.abortSignal
-        ? wrapAbortSignalLike(request.abortSignal)
-        : {};
-      try {
-        // eslint-disable-next-line no-param-reassign
-        request.abortSignal = abortSignal;
-        return await client.sendRequest(request as TspPipelineRequest);
-      } finally {
-        cleanup?.();
-      }
-    },
-  };
+  return createNodeHttpClient();
 }
diff --git a/src/fetchHttpClient.ts b/src/fetchHttpClient.ts
new file mode 100644
index 0000000..e250048
--- /dev/null
+++ b/src/fetchHttpClient.ts
@@ -0,0 +1,325 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { AbortError } from "./abort-controller/AbortError.js";
+import type {
+  HttpClient,
+  HttpHeaders as PipelineHeaders,
+  PipelineRequest,
+  PipelineResponse,
+  TransferProgressEvent,
+} from "./interfaces.js";
+import { RestError } from "./restError.js";
+import { createHttpHeaders } from "./httpHeaders.js";
+import { isNodeReadableStream, isWebReadableStream } from "./util/typeGuards.js";
+
+/**
+ * Checks if the body is a Blob or Blob-like
+ */
+function isBlob(body: unknown): body is Blob {
+  // File objects count as a type of Blob, so we want to use instanceof explicitly
+  return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
+}
+
+/**
+ * A HttpClient implementation that uses window.fetch to send HTTP requests.
+ * @internal
+ */
+class FetchHttpClient implements HttpClient {
+  /**
+   * Makes a request over an underlying transport layer and returns the response.
+   * @param request - The request to be made.
+   */
+  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {
+    const url = new URL(request.url);
+    const isInsecure = url.protocol !== "https:";
+
+    if (isInsecure && !request.allowInsecureConnection) {
+      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
+    }
+
+    if (request.proxySettings) {
+      throw new Error("HTTP proxy is not supported in browser environment");
+    }
+
+    try {
+      return await makeRequest(request);
+    } catch (e: any) {
+      throw getError(e, request);
+    }
+  }
+}
+
+/**
+ * Sends a request
+ */
+async function makeRequest(request: PipelineRequest): Promise<PipelineResponse> {
+  const { abortController, abortControllerCleanup } = setupAbortSignal(request);
+  try {
+    const headers = buildFetchHeaders(request.headers);
+    const { streaming, body: requestBody } = buildRequestBody(request);
+    const requestInit: RequestInit = {
+      body: requestBody,
+      method: request.method,
+      headers: headers,
+      signal: abortController.signal,
+      // Cloudflare doesn't implement the full Fetch API spec
+      // because of some of it doesn't make sense in the edge.
+      // See https://github.com/cloudflare/workerd/issues/902
+      ...("credentials" in Request.prototype
+        ? { credentials: request.withCredentials ? "include" : "same-origin" }
+        : {}),
+      ...("cache" in Request.prototype ? { cache: "no-store" } : {}),
+    };
+
+    // According to https://fetch.spec.whatwg.org/#fetch-method,
+    // init.duplex must be set when body is a ReadableStream object.
+    // currently "half" is the only valid value.
+    if (streaming) {
+      (requestInit as any).duplex = "half";
+    }
+    /**
+     * Developers of the future:
+     * Do not set redirect: "manual" as part
+     * of request options.
+     * It will not work as you expect.
+     */
+    const response = await fetch(request.url, {
+      ...requestInit,
+      ...request.requestOverrides,
+    });
+    // If we're uploading a blob, we need to fire the progress event manually
+    if (isBlob(request.body) && request.onUploadProgress) {
+      request.onUploadProgress({ loadedBytes: request.body.size });
+    }
+    return buildPipelineResponse(response, request, abortControllerCleanup);
+  } catch (e) {
+    abortControllerCleanup?.();
+    throw e;
+  }
+}
+
+/**
+ * Creates a pipeline response from a Fetch response;
+ */
+async function buildPipelineResponse(
+  httpResponse: Response,
+  request: PipelineRequest,
+  abortControllerCleanup?: () => void,
+): Promise<PipelineResponse> {
+  const headers = buildPipelineHeaders(httpResponse);
+  const response: PipelineResponse = {
+    request,
+    headers,
+    status: httpResponse.status,
+  };
+
+  const bodyStream = isWebReadableStream(httpResponse.body)
+    ? buildBodyStream(httpResponse.body, {
+        onProgress: request.onDownloadProgress,
+        onEnd: abortControllerCleanup,
+      })
+    : httpResponse.body;
+
+  if (
+    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
+    request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||
+    request.streamResponseStatusCodes?.has(response.status)
+  ) {
+    if (request.enableBrowserStreams) {
+      response.browserStreamBody = bodyStream ?? undefined;
+    } else {
+      const responseStream = new Response(bodyStream);
+      response.blobBody = responseStream.blob();
+      abortControllerCleanup?.();
+    }
+  } else {
+    const responseStream = new Response(bodyStream);
+
+    response.bodyAsText = await responseStream.text();
+    abortControllerCleanup?.();
+  }
+
+  return response;
+}
+
+function setupAbortSignal(request: PipelineRequest): {
+  abortController: AbortController;
+  abortControllerCleanup: (() => void) | undefined;
+} {
+  const abortController = new AbortController();
+
+  // Cleanup function
+  let abortControllerCleanup: (() => void) | undefined;
+
+  /**
+   * Attach an abort listener to the request
+   */
+  let abortListener: ((event: any) => void) | undefined;
+  if (request.abortSignal) {
+    if (request.abortSignal.aborted) {
+      throw new AbortError("The operation was aborted. Request has already been canceled.");
+    }
+
+    abortListener = (event: Event) => {
+      if (event.type === "abort") {
+        abortController.abort();
+      }
+    };
+    request.abortSignal.addEventListener("abort", abortListener);
+    abortControllerCleanup = () => {
+      if (abortListener) {
+        request.abortSignal?.removeEventListener("abort", abortListener);
+      }
+    };
+  }
+
+  // If a timeout was passed, call the abort signal once the time elapses
+  if (request.timeout > 0) {
+    setTimeout(() => {
+      abortController.abort();
+    }, request.timeout);
+  }
+
+  return { abortController, abortControllerCleanup };
+}
+
+/**
+ * Gets the specific error
+ */
+// eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
+function getError(e: RestError, request: PipelineRequest): RestError {
+  if (e && e?.name === "AbortError") {
+    return e;
+  } else {
+    return new RestError(`Error sending request: ${e.message}`, {
+      code: e?.code ?? RestError.REQUEST_SEND_ERROR,
+      request,
+    });
+  }
+}
+
+/**
+ * Converts PipelineRequest headers to Fetch headers
+ */
+function buildFetchHeaders(pipelineHeaders: PipelineHeaders): Headers {
+  const headers = new Headers();
+  for (const [name, value] of pipelineHeaders) {
+    headers.append(name, value);
+  }
+
+  return headers;
+}
+
+function buildPipelineHeaders(httpResponse: Response): PipelineHeaders {
+  const responseHeaders = createHttpHeaders();
+  for (const [name, value] of httpResponse.headers) {
+    responseHeaders.set(name, value);
+  }
+
+  return responseHeaders;
+}
+
+interface BuildRequestBodyResponse {
+  body:
+    | string
+    | Blob
+    | ReadableStream<Uint8Array>
+    | ArrayBuffer
+    | ArrayBufferView
+    | FormData
+    | null
+    | undefined;
+  streaming: boolean;
+}
+
+function buildRequestBody(request: PipelineRequest): BuildRequestBodyResponse {
+  const body = typeof request.body === "function" ? request.body() : request.body;
+  if (isNodeReadableStream(body)) {
+    throw new Error("Node streams are not supported in browser environment.");
+  }
+
+  return isWebReadableStream(body)
+    ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) }
+    : { streaming: false, body };
+}
+
+/**
+ * Reads the request/response original stream and stream it through a new
+ * ReadableStream, this is done to be able to report progress in a way that
+ * all modern browsers support. TransformStreams would be an alternative,
+ * however they are not yet supported by all browsers i.e Firefox
+ */
+function buildBodyStream(
+  readableStream: ReadableStream<Uint8Array>,
+  options: { onProgress?: (progress: TransferProgressEvent) => void; onEnd?: () => void } = {},
+): ReadableStream<Uint8Array> {
+  let loadedBytes = 0;
+  const { onProgress, onEnd } = options;
+
+  // If the current browser supports pipeThrough we use a TransformStream
+  // to report progress
+  if (isTransformStreamSupported(readableStream)) {
+    return readableStream.pipeThrough(
+      new TransformStream({
+        transform(chunk, controller) {
+          if (chunk === null) {
+            controller.terminate();
+            return;
+          }
+
+          controller.enqueue(chunk);
+          loadedBytes += chunk.length;
+          if (onProgress) {
+            onProgress({ loadedBytes });
+          }
+        },
+        flush() {
+          onEnd?.();
+        },
+      }),
+    );
+  } else {
+    // If we can't use transform streams, wrap the original stream in a new readable stream
+    // and use pull to enqueue each chunk and report progress.
+    const reader = readableStream.getReader();
+    return new ReadableStream({
+      async pull(controller) {
+        const { done, value } = await reader.read();
+        // When no more data needs to be consumed, break the reading
+        if (done || !value) {
+          onEnd?.();
+          // Close the stream
+          controller.close();
+          reader.releaseLock();
+          return;
+        }
+
+        loadedBytes += value?.length ?? 0;
+
+        // Enqueue the next data chunk into our target stream
+        controller.enqueue(value);
+
+        if (onProgress) {
+          onProgress({ loadedBytes });
+        }
+      },
+      cancel(reason?: string) {
+        onEnd?.();
+        return reader.cancel(reason);
+      },
+    });
+  }
+}
+
+/**
+ * Create a new HttpClient instance for the browser environment.
+ * @internal
+ */
+export function createFetchHttpClient(): HttpClient {
+  return new FetchHttpClient();
+}
+
+function isTransformStreamSupported(readableStream: ReadableStream): boolean {
+  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;
+}
diff --git a/src/httpHeaders.ts b/src/httpHeaders.ts
index 94978eb..9e2914b 100644
--- a/src/httpHeaders.ts
+++ b/src/httpHeaders.ts
@@ -1,14 +1,107 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { HttpHeaders, RawHttpHeadersInput } from "./interfaces.js";
+import type { HttpHeaders, RawHttpHeaders, RawHttpHeadersInput } from "./interfaces.js";
 
-import { createHttpHeaders as tspCreateHttpHeaders } from "@typespec/ts-http-runtime";
+interface HeaderEntry {
+  name: string;
+  value: string;
+}
+
+function normalizeName(name: string): string {
+  return name.toLowerCase();
+}
+
+function* headerIterator(map: Map<string, HeaderEntry>): IterableIterator<[string, string]> {
+  for (const entry of map.values()) {
+    yield [entry.name, entry.value];
+  }
+}
+
+class HttpHeadersImpl implements HttpHeaders {
+  private readonly _headersMap: Map<string, HeaderEntry>;
+
+  constructor(rawHeaders?: RawHttpHeaders | RawHttpHeadersInput) {
+    this._headersMap = new Map<string, HeaderEntry>();
+    if (rawHeaders) {
+      for (const headerName of Object.keys(rawHeaders)) {
+        this.set(headerName, rawHeaders[headerName]);
+      }
+    }
+  }
+
+  /**
+   * Set a header in this collection with the provided name and value. The name is
+   * case-insensitive.
+   * @param name - The name of the header to set. This value is case-insensitive.
+   * @param value - The value of the header to set.
+   */
+  public set(name: string, value: string | number | boolean): void {
+    this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
+  }
+
+  /**
+   * Get the header value for the provided header name, or undefined if no header exists in this
+   * collection with the provided name.
+   * @param name - The name of the header. This value is case-insensitive.
+   */
+  public get(name: string): string | undefined {
+    return this._headersMap.get(normalizeName(name))?.value;
+  }
+
+  /**
+   * Get whether or not this header collection contains a header entry for the provided header name.
+   * @param name - The name of the header to set. This value is case-insensitive.
+   */
+  public has(name: string): boolean {
+    return this._headersMap.has(normalizeName(name));
+  }
+
+  /**
+   * Remove the header with the provided headerName.
+   * @param name - The name of the header to remove.
+   */
+  public delete(name: string): void {
+    this._headersMap.delete(normalizeName(name));
+  }
+
+  /**
+   * Get the JSON object representation of this HTTP header collection.
+   */
+  public toJSON(options: { preserveCase?: boolean } = {}): RawHttpHeaders {
+    const result: RawHttpHeaders = {};
+    if (options.preserveCase) {
+      for (const entry of this._headersMap.values()) {
+        result[entry.name] = entry.value;
+      }
+    } else {
+      for (const [normalizedName, entry] of this._headersMap) {
+        result[normalizedName] = entry.value;
+      }
+    }
+
+    return result;
+  }
+
+  /**
+   * Get the string representation of this HTTP header collection.
+   */
+  public toString(): string {
+    return JSON.stringify(this.toJSON({ preserveCase: true }));
+  }
+
+  /**
+   * Iterate over tuples of header [name, value] pairs.
+   */
+  [Symbol.iterator](): Iterator<[string, string]> {
+    return headerIterator(this._headersMap);
+  }
+}
 
 /**
  * Creates an object that satisfies the `HttpHeaders` interface.
  * @param rawHeaders - A simple object representing initial headers
  */
 export function createHttpHeaders(rawHeaders?: RawHttpHeadersInput): HttpHeaders {
-  return tspCreateHttpHeaders(rawHeaders);
+  return new HttpHeadersImpl(rawHeaders);
 }
diff --git a/src/index.ts b/src/index.ts
index 9cf0b30..1220eb5 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -9,117 +9,85 @@ declare global {
   interface TransformStream<I = any, O = any> {}
 }
 
-export type { HttpMethods } from "@azure/core-util";
+export { AbortError } from "./abort-controller/AbortError.js";
+export {
+  createClientLogger,
+  getLogLevel,
+  setLogLevel,
+  TypeSpecRuntimeLogger,
+  type Debugger,
+  type TypeSpecRuntimeClientLogger,
+  type TypeSpecRuntimeLogLevel,
+} from "./logger/logger.js";
+
 export type {
-  Agent,
   BodyPart,
-  FormDataMap,
   FormDataValue,
-  HttpClient,
-  HttpHeaders,
+  RawHttpHeaders,
   KeyObject,
-  MultipartRequestBody,
+  PxfObject,
+  HttpClient,
   PipelineRequest,
   PipelineResponse,
-  PipelineRetryOptions,
-  ProxySettings,
-  PxfObject,
-  RawHttpHeaders,
-  RawHttpHeadersInput,
-  RequestBodyType,
   SendRequest,
   TlsSettings,
+  Agent,
+  RequestBodyType,
+  FormDataMap,
+  HttpHeaders,
+  HttpMethods,
+  MultipartRequestBody,
   TransferProgressEvent,
+  ProxySettings,
+  RawHttpHeadersInput,
+  PipelineRetryOptions,
 } from "./interfaces.js";
+export { createHttpHeaders } from "./httpHeaders.js";
+export * from "./auth/schemes.js";
+export * from "./auth/oauth2Flows.js";
+export {
+  type BasicCredential,
+  type BearerTokenCredential,
+  type OAuth2TokenCredential,
+  type GetOAuth2TokenOptions,
+  type GetBearerTokenOptions,
+  type ApiKeyCredential,
+  type ClientCredential,
+} from "./auth/credentials.js";
+export { createPipelineRequest, type PipelineRequestOptions } from "./pipelineRequest.js";
 export {
-  type AddPolicyOptions as AddPipelineOptions,
-  type PipelinePhase,
-  type PipelinePolicy,
   type Pipeline,
+  type PipelinePolicy,
+  type AddPolicyOptions,
+  type PipelinePhase,
   createEmptyPipeline,
 } from "./pipeline.js";
-export {
-  createPipelineFromOptions,
-  type TelemetryOptions,
-  type InternalPipelineOptions,
-  type PipelineOptions,
-} from "./createPipelineFromOptions.js";
+export { RestError, isRestError, type RestErrorOptions } from "./restError.js";
+export { stringToUint8Array, uint8ArrayToString, type EncodingType } from "./util/bytesEncoding.js";
 export { createDefaultHttpClient } from "./defaultHttpClient.js";
-export { createHttpHeaders } from "./httpHeaders.js";
-export { createPipelineRequest, type PipelineRequestOptions } from "./pipelineRequest.js";
-export { RestError, type RestErrorOptions, isRestError } from "./restError.js";
-export {
-  decompressResponsePolicy,
-  decompressResponsePolicyName,
-} from "./policies/decompressResponsePolicy.js";
-export {
-  exponentialRetryPolicy,
-  type ExponentialRetryPolicyOptions,
-  exponentialRetryPolicyName,
-} from "./policies/exponentialRetryPolicy.js";
-export {
-  setClientRequestIdPolicy,
-  setClientRequestIdPolicyName,
-} from "./policies/setClientRequestIdPolicy.js";
-export { logPolicy, logPolicyName, type LogPolicyOptions } from "./policies/logPolicy.js";
-export { multipartPolicy, multipartPolicyName } from "./policies/multipartPolicy.js";
-export { proxyPolicy, proxyPolicyName, getDefaultProxySettings } from "./policies/proxyPolicy.js";
-export {
-  redirectPolicy,
-  redirectPolicyName,
-  type RedirectPolicyOptions,
-} from "./policies/redirectPolicy.js";
-export {
-  systemErrorRetryPolicy,
-  type SystemErrorRetryPolicyOptions,
-  systemErrorRetryPolicyName,
-} from "./policies/systemErrorRetryPolicy.js";
-export {
-  throttlingRetryPolicy,
-  throttlingRetryPolicyName,
-  type ThrottlingRetryPolicyOptions,
-} from "./policies/throttlingRetryPolicy.js";
-export {
-  retryPolicy,
-  type RetryPolicyOptions,
-  type RetryStrategy,
-  type RetryInformation,
-  type RetryModifiers,
-} from "./policies/retryPolicy.js";
-export {
-  tracingPolicy,
-  tracingPolicyName,
-  type TracingPolicyOptions,
-} from "./policies/tracingPolicy.js";
-export {
-  defaultRetryPolicy,
-  type DefaultRetryPolicyOptions,
-} from "./policies/defaultRetryPolicy.js";
-export {
-  userAgentPolicy,
-  userAgentPolicyName,
-  type UserAgentPolicyOptions,
-} from "./policies/userAgentPolicy.js";
-export { tlsPolicy, tlsPolicyName } from "./policies/tlsPolicy.js";
-export { formDataPolicy, formDataPolicyName } from "./policies/formDataPolicy.js";
-export {
-  bearerTokenAuthenticationPolicy,
-  type BearerTokenAuthenticationPolicyOptions,
-  bearerTokenAuthenticationPolicyName,
-  type ChallengeCallbacks,
-  type AuthorizeRequestOptions,
-  type AuthorizeRequestOnChallengeOptions,
-} from "./policies/bearerTokenAuthenticationPolicy.js";
-export { ndJsonPolicy, ndJsonPolicyName } from "./policies/ndJsonPolicy.js";
-export {
-  auxiliaryAuthenticationHeaderPolicy,
-  type AuxiliaryAuthenticationHeaderPolicyOptions,
-  auxiliaryAuthenticationHeaderPolicyName,
-} from "./policies/auxiliaryAuthenticationHeaderPolicy.js";
-export { agentPolicy, agentPolicyName } from "./policies/agentPolicy.js";
-export {
-  createFile,
-  createFileFromStream,
-  type CreateFileOptions,
-  type CreateFileFromStreamOptions,
-} from "./util/file.js";
+export { getClient } from "./client/getClient.js";
+export { operationOptionsToRequestParameters } from "./client/operationOptionHelpers.js";
+export { createRestError } from "./client/restError.js";
+export type {
+  Client,
+  ClientOptions,
+  OperationOptions,
+  AdditionalPolicyConfig,
+  PathUnchecked,
+  PathUncheckedResponse,
+  HttpResponse,
+  RawResponseCallback,
+  OperationRequestOptions,
+  PathParameters,
+  ResourceMethods,
+  PathParameterWithOptions,
+  StreamableMethod,
+  RequestParameters,
+  HttpNodeStreamResponse,
+  HttpBrowserStreamResponse,
+  FullOperationResponse,
+} from "./client/common.js";
+export type { PipelineOptions, TelemetryOptions } from "./createPipelineFromOptions.js";
+export type { LogPolicyOptions } from "./policies/logPolicy.js";
+export type { RedirectPolicyOptions } from "./policies/redirectPolicy.js";
+export type { UserAgentPolicyOptions } from "./policies/userAgentPolicy.js";
diff --git a/src/interfaces.ts b/src/interfaces.ts
index bbc7e3a..babbfd7 100644
--- a/src/interfaces.ts
+++ b/src/interfaces.ts
@@ -1,9 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { AbortSignalLike } from "@azure/abort-controller";
-import type { OperationTracingOptions } from "@azure/core-tracing";
-import type { HttpMethods } from "@azure/core-util";
+import type { AuthScheme } from "./auth/schemes.js";
 
 /**
  * A HttpHeaders collection represented as a simple JSON object.
@@ -135,6 +133,15 @@ export interface Agent {
  * Metadata about a request being made by the pipeline.
  */
 export interface PipelineRequest {
+  /**
+   * List of authentication schemes used for this specific request.
+   * These schemes define how the request will be authenticated.
+   * If provided, these schemes override the client level authentication schemes.
+   *
+   * If no auth schemes are provided at client or request level, defaults to no auth.
+   */
+  authSchemes?: AuthScheme[];
+
   /**
    * The URL to make the request to.
    */
@@ -202,12 +209,7 @@ export interface PipelineRequest {
   /**
    * Used to abort the request later.
    */
-  abortSignal?: AbortSignalLike;
-
-  /**
-   * Tracing options to use for any created Spans.
-   */
-  tracingOptions?: OperationTracingOptions;
+  abortSignal?: AbortSignal;
 
   /**
    * Callback which fires upon upload progress.
@@ -327,6 +329,21 @@ export type TransferProgressEvent = {
   loadedBytes: number;
 };
 
+// UNBRANDED DIFFERENCE: HttpMethods are defined at the top level in unbranded instead of core-util since we don't
+//                       need to worry about creating a cyclic dependency
+/**
+ * Supported HTTP methods to use when making requests.
+ */
+export type HttpMethods =
+  | "GET"
+  | "PUT"
+  | "POST"
+  | "DELETE"
+  | "PATCH"
+  | "HEAD"
+  | "OPTIONS"
+  | "TRACE";
+
 /**
  * Options to configure a proxy for outgoing requests (Node.js only).
  */
diff --git a/src/log.ts b/src/log.ts
index db967c2..32452a9 100644
--- a/src/log.ts
+++ b/src/log.ts
@@ -1,5 +1,5 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { createClientLogger } from "@azure/logger";
-export const logger = createClientLogger("core-rest-pipeline");
+import { createClientLogger } from "./logger/logger.js";
+export const logger = createClientLogger("ts-http-runtime");
diff --git a/src/logger/debug.ts b/src/logger/debug.ts
new file mode 100644
index 0000000..3ba9f34
--- /dev/null
+++ b/src/logger/debug.ts
@@ -0,0 +1,173 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { log } from "./log.js";
+
+/**
+ * A simple mechanism for enabling logging.
+ * Intended to mimic the publicly available `debug` package.
+ */
+export interface Debug {
+  /**
+   * Creates a new logger with the given namespace.
+   */
+  (namespace: string): Debugger;
+  /**
+   * The default log method (defaults to console)
+   */
+  log: (...args: any[]) => void;
+  /**
+   * Enables a particular set of namespaces.
+   * To enable multiple separate them with commas, e.g. "info,debug".
+   * Supports wildcards, e.g. "typeSpecRuntime:*"
+   * Supports skip syntax, e.g. "typeSpecRuntime:*,-typeSpecRuntime:storage:*" will enable
+   * everything under typeSpecRuntime except for things under typeSpecRuntime:storage.
+   */
+  enable: (namespaces: string) => void;
+  /**
+   * Checks if a particular namespace is enabled.
+   */
+  enabled: (namespace: string) => boolean;
+  /**
+   * Disables all logging, returns what was previously enabled.
+   */
+  disable: () => string;
+}
+
+/**
+ * A log function that can be dynamically enabled and redirected.
+ */
+export interface Debugger {
+  /**
+   * Logs the given arguments to the `log` method.
+   */
+  (...args: any[]): void;
+  /**
+   * True if this logger is active and logging.
+   */
+  enabled: boolean;
+  /**
+   * Used to cleanup/remove this logger.
+   */
+  destroy: () => boolean;
+  /**
+   * The current log method. Can be overridden to redirect output.
+   */
+  log: (...args: any[]) => void;
+  /**
+   * The namespace of this logger.
+   */
+  namespace: string;
+  /**
+   * Extends this logger with a child namespace.
+   * Namespaces are separated with a ':' character.
+   */
+  extend: (namespace: string) => Debugger;
+}
+
+const debugEnvVariable =
+  (typeof process !== "undefined" && process.env && process.env.DEBUG) || undefined;
+
+let enabledString: string | undefined;
+let enabledNamespaces: RegExp[] = [];
+let skippedNamespaces: RegExp[] = [];
+const debuggers: Debugger[] = [];
+
+if (debugEnvVariable) {
+  enable(debugEnvVariable);
+}
+
+const debugObj: Debug = Object.assign(
+  (namespace: string): Debugger => {
+    return createDebugger(namespace);
+  },
+  {
+    enable,
+    enabled,
+    disable,
+    log,
+  },
+);
+
+function enable(namespaces: string): void {
+  enabledString = namespaces;
+  enabledNamespaces = [];
+  skippedNamespaces = [];
+  const wildcard = /\*/g;
+  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
+  for (const ns of namespaceList) {
+    if (ns.startsWith("-")) {
+      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
+    } else {
+      enabledNamespaces.push(new RegExp(`^${ns}$`));
+    }
+  }
+  for (const instance of debuggers) {
+    instance.enabled = enabled(instance.namespace);
+  }
+}
+
+function enabled(namespace: string): boolean {
+  if (namespace.endsWith("*")) {
+    return true;
+  }
+
+  for (const skipped of skippedNamespaces) {
+    if (skipped.test(namespace)) {
+      return false;
+    }
+  }
+  for (const enabledNamespace of enabledNamespaces) {
+    if (enabledNamespace.test(namespace)) {
+      return true;
+    }
+  }
+  return false;
+}
+
+function disable(): string {
+  const result = enabledString || "";
+  enable("");
+  return result;
+}
+
+function createDebugger(namespace: string): Debugger {
+  const newDebugger: Debugger = Object.assign(debug, {
+    enabled: enabled(namespace),
+    destroy,
+    log: debugObj.log,
+    namespace,
+    extend,
+  });
+
+  function debug(...args: any[]): void {
+    if (!newDebugger.enabled) {
+      return;
+    }
+    if (args.length > 0) {
+      args[0] = `${namespace} ${args[0]}`;
+    }
+    newDebugger.log(...args);
+  }
+
+  debuggers.push(newDebugger);
+
+  return newDebugger;
+}
+
+function destroy(this: Debugger): boolean {
+  const index = debuggers.indexOf(this);
+  if (index >= 0) {
+    debuggers.splice(index, 1);
+    return true;
+  }
+  return false;
+}
+
+function extend(this: Debugger, namespace: string): Debugger {
+  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
+  newDebugger.log = this.log;
+  return newDebugger;
+}
+
+export default debugObj;
diff --git a/src/logger/internal.ts b/src/logger/internal.ts
new file mode 100644
index 0000000..6cdd9e5
--- /dev/null
+++ b/src/logger/internal.ts
@@ -0,0 +1,8 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export {
+  createLoggerContext,
+  type CreateLoggerContextOptions,
+  type LoggerContext,
+} from "./logger.js";
diff --git a/src/logger/log-browser.mts b/src/logger/log-browser.mts
new file mode 100644
index 0000000..6cc3fc5
--- /dev/null
+++ b/src/logger/log-browser.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export { log } from "./log.common.js";
diff --git a/src/logger/log-react-native.mts b/src/logger/log-react-native.mts
new file mode 100644
index 0000000..6cc3fc5
--- /dev/null
+++ b/src/logger/log-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export { log } from "./log.common.js";
diff --git a/src/logger/log.common.ts b/src/logger/log.common.ts
new file mode 100644
index 0000000..bc90332
--- /dev/null
+++ b/src/logger/log.common.ts
@@ -0,0 +1,19 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export function log(...args: any[]): void {
+  if (args.length > 0) {
+    const firstArg = String(args[0]);
+    if (firstArg.includes(":error")) {
+      console.error(...args);
+    } else if (firstArg.includes(":warning")) {
+      console.warn(...args);
+    } else if (firstArg.includes(":info")) {
+      console.info(...args);
+    } else if (firstArg.includes(":verbose")) {
+      console.debug(...args);
+    } else {
+      console.debug(...args);
+    }
+  }
+}
diff --git a/src/logger/log.ts b/src/logger/log.ts
new file mode 100644
index 0000000..c40a726
--- /dev/null
+++ b/src/logger/log.ts
@@ -0,0 +1,10 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { EOL } from "node:os";
+import util from "node:util";
+import * as process from "node:process";
+
+export function log(message: unknown, ...args: any[]): void {
+  process.stderr.write(`${util.format(message, ...args)}${EOL}`);
+}
diff --git a/src/logger/logger.ts b/src/logger/logger.ts
new file mode 100644
index 0000000..1002e6f
--- /dev/null
+++ b/src/logger/logger.ts
@@ -0,0 +1,253 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import debug from "./debug.js";
+
+import type { Debugger } from "./debug.js";
+export type { Debugger };
+
+/**
+ * The log levels supported by the logger.
+ * The log levels in order of most verbose to least verbose are:
+ * - verbose
+ * - info
+ * - warning
+ * - error
+ */
+export type TypeSpecRuntimeLogLevel = "verbose" | "info" | "warning" | "error";
+
+/**
+ * A TypeSpecRuntimeClientLogger is a function that can log to an appropriate severity level.
+ */
+export type TypeSpecRuntimeClientLogger = Debugger;
+
+/**
+ * Defines the methods available on the SDK-facing logger.
+ */
+export interface TypeSpecRuntimeLogger {
+  /**
+   * Used for failures the program is unlikely to recover from,
+   * such as Out of Memory.
+   */
+  error: Debugger;
+  /**
+   * Used when a function fails to perform its intended task.
+   * Usually this means the function will throw an exception.
+   * Not used for self-healing events (e.g. automatic retry)
+   */
+  warning: Debugger;
+  /**
+   * Used when a function operates normally.
+   */
+  info: Debugger;
+  /**
+   * Used for detailed troubleshooting scenarios. This is
+   * intended for use by developers / system administrators
+   * for diagnosing specific failures.
+   */
+  verbose: Debugger;
+}
+
+/**
+ * todo doc
+ */
+export interface LoggerContext {
+  /**
+   * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.
+   * @param level - The log level to enable for logging.
+   * Options from most verbose to least verbose are:
+   * - verbose
+   * - info
+   * - warning
+   * - error
+   */
+  setLogLevel(logLevel?: TypeSpecRuntimeLogLevel): void;
+
+  /**
+   * Retrieves the currently specified log level.
+   */
+  getLogLevel(): TypeSpecRuntimeLogLevel | undefined;
+
+  /**
+   * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.
+   * @param namespace - The name of the SDK package.
+   * @hidden
+   */
+  createClientLogger(namespace: string): TypeSpecRuntimeLogger;
+
+  /**
+   * The TypeSpecRuntimeClientLogger provides a mechanism for overriding where logs are output to.
+   * By default, logs are sent to stderr.
+   * Override the `log` method to redirect logs to another location.
+   */
+  logger: TypeSpecRuntimeClientLogger;
+}
+
+/**
+ * Option for creating a TypeSpecRuntimeLoggerContext.
+ */
+export interface CreateLoggerContextOptions {
+  /**
+   * The name of the environment variable to check for the log level.
+   */
+  logLevelEnvVarName: string;
+
+  /**
+   * The namespace of the logger.
+   */
+  namespace: string;
+}
+
+const TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
+
+type DebuggerWithLogLevel = Debugger & { level: TypeSpecRuntimeLogLevel };
+
+const levelMap = {
+  verbose: 400,
+  info: 300,
+  warning: 200,
+  error: 100,
+};
+
+function patchLogMethod(
+  parent: TypeSpecRuntimeClientLogger,
+  child: TypeSpecRuntimeClientLogger | DebuggerWithLogLevel,
+): void {
+  child.log = (...args) => {
+    parent.log(...args);
+  };
+}
+
+function isTypeSpecRuntimeLogLevel(level: string): level is TypeSpecRuntimeLogLevel {
+  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level as any);
+}
+
+/**
+ * Creates a logger context base on the provided options.
+ * @param options - The options for creating a logger context.
+ * @returns The logger context.
+ */
+export function createLoggerContext(options: CreateLoggerContextOptions): LoggerContext {
+  const registeredLoggers = new Set<DebuggerWithLogLevel>();
+  const logLevelFromEnv =
+    (typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName]) ||
+    undefined;
+
+  let logLevel: TypeSpecRuntimeLogLevel | undefined;
+
+  const clientLogger: TypeSpecRuntimeClientLogger = debug(options.namespace);
+  clientLogger.log = (...args) => {
+    debug.log(...args);
+  };
+
+  if (logLevelFromEnv) {
+    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
+    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
+      setLogLevel(logLevelFromEnv);
+    } else {
+      console.error(
+        `${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(
+          ", ",
+        )}.`,
+      );
+    }
+  }
+
+  function shouldEnable(logger: DebuggerWithLogLevel): boolean {
+    return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);
+  }
+
+  function createLogger(
+    parent: TypeSpecRuntimeClientLogger,
+    level: TypeSpecRuntimeLogLevel,
+  ): DebuggerWithLogLevel {
+    const logger: DebuggerWithLogLevel = Object.assign(parent.extend(level), {
+      level,
+    });
+
+    patchLogMethod(parent, logger);
+
+    if (shouldEnable(logger)) {
+      const enabledNamespaces = debug.disable();
+      debug.enable(enabledNamespaces + "," + logger.namespace);
+    }
+
+    registeredLoggers.add(logger);
+
+    return logger;
+  }
+
+  return {
+    setLogLevel(level?: TypeSpecRuntimeLogLevel): void {
+      if (level && !isTypeSpecRuntimeLogLevel(level)) {
+        throw new Error(
+          `Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`,
+        );
+      }
+      logLevel = level;
+
+      const enabledNamespaces = [];
+      for (const logger of registeredLoggers) {
+        if (shouldEnable(logger)) {
+          enabledNamespaces.push(logger.namespace);
+        }
+      }
+
+      debug.enable(enabledNamespaces.join(","));
+    },
+    getLogLevel(): TypeSpecRuntimeLogLevel | undefined {
+      return logLevel;
+    },
+    createClientLogger(namespace: string): TypeSpecRuntimeLogger {
+      const clientRootLogger: TypeSpecRuntimeClientLogger = clientLogger.extend(namespace);
+      patchLogMethod(clientLogger, clientRootLogger);
+      return {
+        error: createLogger(clientRootLogger, "error"),
+        warning: createLogger(clientRootLogger, "warning"),
+        info: createLogger(clientRootLogger, "info"),
+        verbose: createLogger(clientRootLogger, "verbose"),
+      };
+    },
+    logger: clientLogger,
+  };
+}
+
+const context = createLoggerContext({
+  logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
+  namespace: "typeSpecRuntime",
+});
+
+/**
+ * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.
+ * @param level - The log level to enable for logging.
+ * Options from most verbose to least verbose are:
+ * - verbose
+ * - info
+ * - warning
+ * - error
+ */
+// eslint-disable-next-line @typescript-eslint/no-redeclare
+export const TypeSpecRuntimeLogger: TypeSpecRuntimeClientLogger = context.logger;
+
+/**
+ * Retrieves the currently specified log level.
+ */
+export function setLogLevel(logLevel?: TypeSpecRuntimeLogLevel): void {
+  context.setLogLevel(logLevel);
+}
+
+/**
+ * Retrieves the currently specified log level.
+ */
+export function getLogLevel(): TypeSpecRuntimeLogLevel | undefined {
+  return context.getLogLevel();
+}
+
+/**
+ * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.
+ * @param namespace - The name of the SDK package.
+ * @hidden
+ */
+export function createClientLogger(namespace: string): TypeSpecRuntimeLogger {
+  return context.createClientLogger(namespace);
+}
diff --git a/src/nodeHttpClient.ts b/src/nodeHttpClient.ts
new file mode 100644
index 0000000..8f1aaee
--- /dev/null
+++ b/src/nodeHttpClient.ts
@@ -0,0 +1,402 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import * as http from "node:http";
+import * as https from "node:https";
+import * as zlib from "node:zlib";
+import { Transform } from "node:stream";
+import { AbortError } from "./abort-controller/AbortError.js";
+import type {
+  HttpClient,
+  HttpHeaders,
+  PipelineRequest,
+  PipelineResponse,
+  RequestBodyType,
+  TlsSettings,
+  TransferProgressEvent,
+} from "./interfaces.js";
+import { createHttpHeaders } from "./httpHeaders.js";
+import { RestError } from "./restError.js";
+import type { IncomingMessage } from "node:http";
+import { logger } from "./log.js";
+import { Sanitizer } from "./util/sanitizer.js";
+
+const DEFAULT_TLS_SETTINGS = {};
+
+function isReadableStream(body: any): body is NodeJS.ReadableStream {
+  return body && typeof body.pipe === "function";
+}
+
+function isStreamComplete(stream: NodeJS.ReadableStream): Promise<void> {
+  if (stream.readable === false) {
+    return Promise.resolve();
+  }
+
+  return new Promise((resolve) => {
+    const handler = (): void => {
+      resolve();
+      stream.removeListener("close", handler);
+      stream.removeListener("end", handler);
+      stream.removeListener("error", handler);
+    };
+
+    stream.on("close", handler);
+    stream.on("end", handler);
+    stream.on("error", handler);
+  });
+}
+
+function isArrayBuffer(body: any): body is ArrayBuffer | ArrayBufferView {
+  return body && typeof body.byteLength === "number";
+}
+
+class ReportTransform extends Transform {
+  private loadedBytes = 0;
+  private progressCallback: (progress: TransferProgressEvent) => void;
+
+  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
+  _transform(chunk: string | Buffer, _encoding: string, callback: Function): void {
+    this.push(chunk);
+    this.loadedBytes += chunk.length;
+    try {
+      this.progressCallback({ loadedBytes: this.loadedBytes });
+      callback();
+    } catch (e: any) {
+      callback(e);
+    }
+  }
+
+  constructor(progressCallback: (progress: TransferProgressEvent) => void) {
+    super();
+    this.progressCallback = progressCallback;
+  }
+}
+
+/**
+ * A HttpClient implementation that uses Node's "https" module to send HTTPS requests.
+ * @internal
+ */
+class NodeHttpClient implements HttpClient {
+  private cachedHttpAgent?: http.Agent;
+  private cachedHttpsAgents: WeakMap<TlsSettings, https.Agent> = new WeakMap();
+
+  /**
+   * Makes a request over an underlying transport layer and returns the response.
+   * @param request - The request to be made.
+   */
+  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {
+    const abortController = new AbortController();
+    let abortListener: ((event: any) => void) | undefined;
+    if (request.abortSignal) {
+      if (request.abortSignal.aborted) {
+        throw new AbortError("The operation was aborted. Request has already been canceled.");
+      }
+
+      abortListener = (event: Event) => {
+        if (event.type === "abort") {
+          abortController.abort();
+        }
+      };
+      request.abortSignal.addEventListener("abort", abortListener);
+    }
+
+    let timeoutId: ReturnType<typeof setTimeout> | undefined;
+    if (request.timeout > 0) {
+      timeoutId = setTimeout(() => {
+        const sanitizer = new Sanitizer();
+        logger.info(`request to '${sanitizer.sanitizeUrl(request.url)}' timed out. canceling...`);
+        abortController.abort();
+      }, request.timeout);
+    }
+
+    const acceptEncoding = request.headers.get("Accept-Encoding");
+    const shouldDecompress =
+      acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate");
+
+    let body = typeof request.body === "function" ? request.body() : request.body;
+    if (body && !request.headers.has("Content-Length")) {
+      const bodyLength = getBodyLength(body);
+      if (bodyLength !== null) {
+        request.headers.set("Content-Length", bodyLength);
+      }
+    }
+
+    let responseStream: NodeJS.ReadableStream | undefined;
+    try {
+      if (body && request.onUploadProgress) {
+        const onUploadProgress = request.onUploadProgress;
+        const uploadReportStream = new ReportTransform(onUploadProgress);
+        uploadReportStream.on("error", (e) => {
+          logger.error("Error in upload progress", e);
+        });
+        if (isReadableStream(body)) {
+          body.pipe(uploadReportStream);
+        } else {
+          uploadReportStream.end(body);
+        }
+
+        body = uploadReportStream;
+      }
+
+      const res = await this.makeRequest(request, abortController, body);
+
+      if (timeoutId !== undefined) {
+        clearTimeout(timeoutId);
+      }
+
+      const headers = getResponseHeaders(res);
+
+      const status = res.statusCode ?? 0;
+      const response: PipelineResponse = {
+        status,
+        headers,
+        request,
+      };
+
+      // Responses to HEAD must not have a body.
+      // If they do return a body, that body must be ignored.
+      if (request.method === "HEAD") {
+        // call resume() and not destroy() to avoid closing the socket
+        // and losing keep alive
+        res.resume();
+        return response;
+      }
+
+      responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
+
+      const onDownloadProgress = request.onDownloadProgress;
+      if (onDownloadProgress) {
+        const downloadReportStream = new ReportTransform(onDownloadProgress);
+        downloadReportStream.on("error", (e) => {
+          logger.error("Error in download progress", e);
+        });
+        responseStream.pipe(downloadReportStream);
+        responseStream = downloadReportStream;
+      }
+
+      if (
+        // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
+        request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||
+        request.streamResponseStatusCodes?.has(response.status)
+      ) {
+        response.readableStreamBody = responseStream;
+      } else {
+        response.bodyAsText = await streamToText(responseStream);
+      }
+
+      return response;
+    } finally {
+      // clean up event listener
+      if (request.abortSignal && abortListener) {
+        let uploadStreamDone = Promise.resolve();
+        if (isReadableStream(body)) {
+          uploadStreamDone = isStreamComplete(body);
+        }
+        let downloadStreamDone = Promise.resolve();
+        if (isReadableStream(responseStream)) {
+          downloadStreamDone = isStreamComplete(responseStream);
+        }
+        Promise.all([uploadStreamDone, downloadStreamDone])
+          .then(() => {
+            // eslint-disable-next-line promise/always-return
+            if (abortListener) {
+              request.abortSignal?.removeEventListener("abort", abortListener);
+            }
+          })
+          .catch((e) => {
+            logger.warning("Error when cleaning up abortListener on httpRequest", e);
+          });
+      }
+    }
+  }
+
+  private makeRequest(
+    request: PipelineRequest,
+    abortController: AbortController,
+    body?: RequestBodyType,
+  ): Promise<http.IncomingMessage> {
+    const url = new URL(request.url);
+
+    const isInsecure = url.protocol !== "https:";
+
+    if (isInsecure && !request.allowInsecureConnection) {
+      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
+    }
+
+    const agent = (request.agent as http.Agent) ?? this.getOrCreateAgent(request, isInsecure);
+    const options: http.RequestOptions = {
+      agent,
+      hostname: url.hostname,
+      path: `${url.pathname}${url.search}`,
+      port: url.port,
+      method: request.method,
+      headers: request.headers.toJSON({ preserveCase: true }),
+      ...request.requestOverrides,
+    };
+
+    return new Promise<http.IncomingMessage>((resolve, reject) => {
+      const req = isInsecure ? http.request(options, resolve) : https.request(options, resolve);
+
+      req.once("error", (err: Error & { code?: string }) => {
+        reject(
+          new RestError(err.message, { code: err.code ?? RestError.REQUEST_SEND_ERROR, request }),
+        );
+      });
+
+      abortController.signal.addEventListener("abort", () => {
+        const abortError = new AbortError(
+          "The operation was aborted. Rejecting from abort signal callback while making request.",
+        );
+        req.destroy(abortError);
+        reject(abortError);
+      });
+      if (body && isReadableStream(body)) {
+        body.pipe(req);
+      } else if (body) {
+        if (typeof body === "string" || Buffer.isBuffer(body)) {
+          req.end(body);
+        } else if (isArrayBuffer(body)) {
+          req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
+        } else {
+          logger.error("Unrecognized body type", body);
+          reject(new RestError("Unrecognized body type"));
+        }
+      } else {
+        // streams don't like "undefined" being passed as data
+        req.end();
+      }
+    });
+  }
+
+  private getOrCreateAgent(request: PipelineRequest, isInsecure: boolean): http.Agent {
+    const disableKeepAlive = request.disableKeepAlive;
+
+    // Handle Insecure requests first
+    if (isInsecure) {
+      if (disableKeepAlive) {
+        // keepAlive:false is the default so we don't need a custom Agent
+        return http.globalAgent;
+      }
+
+      if (!this.cachedHttpAgent) {
+        // If there is no cached agent create a new one and cache it.
+        this.cachedHttpAgent = new http.Agent({ keepAlive: true });
+      }
+      return this.cachedHttpAgent;
+    } else {
+      if (disableKeepAlive && !request.tlsSettings) {
+        // When there are no tlsSettings and keepAlive is false
+        // we don't need a custom agent
+        return https.globalAgent;
+      }
+
+      // We use the tlsSettings to index cached clients
+      const tlsSettings = request.tlsSettings ?? DEFAULT_TLS_SETTINGS;
+
+      // Get the cached agent or create a new one with the
+      // provided values for keepAlive and tlsSettings
+      let agent = this.cachedHttpsAgents.get(tlsSettings);
+
+      if (agent && agent.options.keepAlive === !disableKeepAlive) {
+        return agent;
+      }
+
+      logger.info("No cached TLS Agent exist, creating a new Agent");
+      agent = new https.Agent({
+        // keepAlive is true if disableKeepAlive is false.
+        keepAlive: !disableKeepAlive,
+        // Since we are spreading, if no tslSettings were provided, nothing is added to the agent options.
+        ...tlsSettings,
+      });
+
+      this.cachedHttpsAgents.set(tlsSettings, agent);
+      return agent;
+    }
+  }
+}
+
+function getResponseHeaders(res: IncomingMessage): HttpHeaders {
+  const headers = createHttpHeaders();
+  for (const header of Object.keys(res.headers)) {
+    const value = res.headers[header];
+    if (Array.isArray(value)) {
+      if (value.length > 0) {
+        headers.set(header, value[0]);
+      }
+    } else if (value) {
+      headers.set(header, value);
+    }
+  }
+  return headers;
+}
+
+function getDecodedResponseStream(
+  stream: IncomingMessage,
+  headers: HttpHeaders,
+): NodeJS.ReadableStream {
+  const contentEncoding = headers.get("Content-Encoding");
+  if (contentEncoding === "gzip") {
+    const unzip = zlib.createGunzip();
+    stream.pipe(unzip);
+    return unzip;
+  } else if (contentEncoding === "deflate") {
+    const inflate = zlib.createInflate();
+    stream.pipe(inflate);
+    return inflate;
+  }
+
+  return stream;
+}
+
+function streamToText(stream: NodeJS.ReadableStream): Promise<string> {
+  return new Promise<string>((resolve, reject) => {
+    const buffer: Buffer[] = [];
+
+    stream.on("data", (chunk) => {
+      if (Buffer.isBuffer(chunk)) {
+        buffer.push(chunk);
+      } else {
+        buffer.push(Buffer.from(chunk));
+      }
+    });
+    stream.on("end", () => {
+      resolve(Buffer.concat(buffer).toString("utf8"));
+    });
+    stream.on("error", (e) => {
+      if (e && e?.name === "AbortError") {
+        reject(e);
+      } else {
+        reject(
+          new RestError(`Error reading response as text: ${e.message}`, {
+            code: RestError.PARSE_ERROR,
+          }),
+        );
+      }
+    });
+  });
+}
+
+/** @internal */
+export function getBodyLength(body: RequestBodyType): number | null {
+  if (!body) {
+    return 0;
+  } else if (Buffer.isBuffer(body)) {
+    return body.length;
+  } else if (isReadableStream(body)) {
+    return null;
+  } else if (isArrayBuffer(body)) {
+    return body.byteLength;
+  } else if (typeof body === "string") {
+    return Buffer.from(body).length;
+  } else {
+    return null;
+  }
+}
+
+/**
+ * Create a new HttpClient instance for the NodeJS environment.
+ * @internal
+ */
+export function createNodeHttpClient(): HttpClient {
+  return new NodeHttpClient();
+}
diff --git a/src/pipeline.ts b/src/pipeline.ts
index b944058..f5612f8 100644
--- a/src/pipeline.ts
+++ b/src/pipeline.ts
@@ -2,7 +2,6 @@
 // Licensed under the MIT License.
 
 import type { HttpClient, PipelineRequest, PipelineResponse, SendRequest } from "./interfaces.js";
-import { createEmptyPipeline as tspCreateEmptyPipeline } from "@typespec/ts-http-runtime";
 
 /**
  * Policies are executed in phases.
@@ -15,6 +14,8 @@ import { createEmptyPipeline as tspCreateEmptyPipeline } from "@typespec/ts-http
  */
 export type PipelinePhase = "Deserialize" | "Serialize" | "Retry" | "Sign";
 
+const ValidPhaseNames = new Set<PipelinePhase>(["Deserialize", "Serialize", "Retry", "Sign"]);
+
 /**
  * Options when adding a policy to the pipeline.
  * Used to express dependencies on other policies.
@@ -91,10 +92,306 @@ export interface Pipeline {
   clone(): Pipeline;
 }
 
+interface PipelineDescriptor {
+  policy: PipelinePolicy;
+  options: AddPolicyOptions;
+}
+
+interface PolicyGraphNode {
+  policy: PipelinePolicy;
+  dependsOn: Set<PolicyGraphNode>;
+  dependants: Set<PolicyGraphNode>;
+  afterPhase?: Phase;
+}
+
+interface Phase {
+  name: PipelinePhase | "None";
+  policies: Set<PolicyGraphNode>;
+  hasRun: boolean;
+  hasAfterPolicies: boolean;
+}
+
+/**
+ * A private implementation of Pipeline.
+ * Do not export this class from the package.
+ * @internal
+ */
+class HttpPipeline implements Pipeline {
+  private _policies: PipelineDescriptor[] = [];
+  private _orderedPolicies?: PipelinePolicy[];
+
+  private constructor(policies?: PipelineDescriptor[]) {
+    this._policies = policies?.slice(0) ?? [];
+    this._orderedPolicies = undefined;
+  }
+
+  public addPolicy(policy: PipelinePolicy, options: AddPolicyOptions = {}): void {
+    if (options.phase && options.afterPhase) {
+      throw new Error("Policies inside a phase cannot specify afterPhase.");
+    }
+    if (options.phase && !ValidPhaseNames.has(options.phase)) {
+      throw new Error(`Invalid phase name: ${options.phase}`);
+    }
+    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
+      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
+    }
+    this._policies.push({
+      policy,
+      options,
+    });
+    this._orderedPolicies = undefined;
+  }
+
+  public removePolicy(options: { name?: string; phase?: string }): PipelinePolicy[] {
+    const removedPolicies: PipelinePolicy[] = [];
+
+    this._policies = this._policies.filter((policyDescriptor) => {
+      if (
+        (options.name && policyDescriptor.policy.name === options.name) ||
+        (options.phase && policyDescriptor.options.phase === options.phase)
+      ) {
+        removedPolicies.push(policyDescriptor.policy);
+        return false;
+      } else {
+        return true;
+      }
+    });
+    this._orderedPolicies = undefined;
+
+    return removedPolicies;
+  }
+
+  public sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse> {
+    const policies = this.getOrderedPolicies();
+
+    const pipeline = policies.reduceRight<SendRequest>(
+      (next, policy) => {
+        return (req: PipelineRequest) => {
+          return policy.sendRequest(req, next);
+        };
+      },
+      (req: PipelineRequest) => httpClient.sendRequest(req),
+    );
+
+    return pipeline(request);
+  }
+
+  public getOrderedPolicies(): PipelinePolicy[] {
+    if (!this._orderedPolicies) {
+      this._orderedPolicies = this.orderPolicies();
+    }
+    return this._orderedPolicies;
+  }
+
+  public clone(): Pipeline {
+    return new HttpPipeline(this._policies);
+  }
+
+  public static create(): Pipeline {
+    return new HttpPipeline();
+  }
+
+  private orderPolicies(): PipelinePolicy[] {
+    /**
+     * The goal of this method is to reliably order pipeline policies
+     * based on their declared requirements when they were added.
+     *
+     * Order is first determined by phase:
+     *
+     * 1. Serialize Phase
+     * 2. Policies not in a phase
+     * 3. Deserialize Phase
+     * 4. Retry Phase
+     * 5. Sign Phase
+     *
+     * Within each phase, policies are executed in the order
+     * they were added unless they were specified to execute
+     * before/after other policies or after a particular phase.
+     *
+     * To determine the final order, we will walk the policy list
+     * in phase order multiple times until all dependencies are
+     * satisfied.
+     *
+     * `afterPolicies` are the set of policies that must be
+     * executed before a given policy. This requirement is
+     * considered satisfied when each of the listed policies
+     * have been scheduled.
+     *
+     * `beforePolicies` are the set of policies that must be
+     * executed after a given policy. Since this dependency
+     * can be expressed by converting it into a equivalent
+     * `afterPolicies` declarations, they are normalized
+     * into that form for simplicity.
+     *
+     * An `afterPhase` dependency is considered satisfied when all
+     * policies in that phase have scheduled.
+     *
+     */
+    const result: PipelinePolicy[] = [];
+
+    // Track all policies we know about.
+    const policyMap: Map<string, PolicyGraphNode> = new Map<string, PolicyGraphNode>();
+
+    function createPhase(name: PipelinePhase | "None"): Phase {
+      return {
+        name,
+        policies: new Set<PolicyGraphNode>(),
+        hasRun: false,
+        hasAfterPolicies: false,
+      };
+    }
+
+    // Track policies for each phase.
+    const serializePhase = createPhase("Serialize");
+    const noPhase = createPhase("None");
+    const deserializePhase = createPhase("Deserialize");
+    const retryPhase = createPhase("Retry");
+    const signPhase = createPhase("Sign");
+
+    // a list of phases in order
+    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
+
+    // Small helper function to map phase name to each Phase
+    function getPhase(phase: PipelinePhase | undefined): Phase {
+      if (phase === "Retry") {
+        return retryPhase;
+      } else if (phase === "Serialize") {
+        return serializePhase;
+      } else if (phase === "Deserialize") {
+        return deserializePhase;
+      } else if (phase === "Sign") {
+        return signPhase;
+      } else {
+        return noPhase;
+      }
+    }
+
+    // First walk each policy and create a node to track metadata.
+    for (const descriptor of this._policies) {
+      const policy = descriptor.policy;
+      const options = descriptor.options;
+      const policyName = policy.name;
+      if (policyMap.has(policyName)) {
+        throw new Error("Duplicate policy names not allowed in pipeline");
+      }
+      const node: PolicyGraphNode = {
+        policy,
+        dependsOn: new Set<PolicyGraphNode>(),
+        dependants: new Set<PolicyGraphNode>(),
+      };
+      if (options.afterPhase) {
+        node.afterPhase = getPhase(options.afterPhase);
+        node.afterPhase.hasAfterPolicies = true;
+      }
+      policyMap.set(policyName, node);
+      const phase = getPhase(options.phase);
+      phase.policies.add(node);
+    }
+
+    // Now that each policy has a node, connect dependency references.
+    for (const descriptor of this._policies) {
+      const { policy, options } = descriptor;
+      const policyName = policy.name;
+      const node = policyMap.get(policyName);
+      if (!node) {
+        throw new Error(`Missing node for policy ${policyName}`);
+      }
+
+      if (options.afterPolicies) {
+        for (const afterPolicyName of options.afterPolicies) {
+          const afterNode = policyMap.get(afterPolicyName);
+          if (afterNode) {
+            // Linking in both directions helps later
+            // when we want to notify dependants.
+            node.dependsOn.add(afterNode);
+            afterNode.dependants.add(node);
+          }
+        }
+      }
+      if (options.beforePolicies) {
+        for (const beforePolicyName of options.beforePolicies) {
+          const beforeNode = policyMap.get(beforePolicyName);
+          if (beforeNode) {
+            // To execute before another node, make it
+            // depend on the current node.
+            beforeNode.dependsOn.add(node);
+            node.dependants.add(beforeNode);
+          }
+        }
+      }
+    }
+
+    function walkPhase(phase: Phase): void {
+      phase.hasRun = true;
+      // Sets iterate in insertion order
+      for (const node of phase.policies) {
+        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
+          // If this node is waiting on a phase to complete,
+          // we need to skip it for now.
+          // Even if the phase is empty, we should wait for it
+          // to be walked to avoid re-ordering policies.
+          continue;
+        }
+        if (node.dependsOn.size === 0) {
+          // If there's nothing else we're waiting for, we can
+          // add this policy to the result list.
+          result.push(node.policy);
+          // Notify anything that depends on this policy that
+          // the policy has been scheduled.
+          for (const dependant of node.dependants) {
+            dependant.dependsOn.delete(node);
+          }
+          policyMap.delete(node.policy.name);
+          phase.policies.delete(node);
+        }
+      }
+    }
+
+    function walkPhases(): void {
+      for (const phase of orderedPhases) {
+        walkPhase(phase);
+        // if the phase isn't complete
+        if (phase.policies.size > 0 && phase !== noPhase) {
+          if (!noPhase.hasRun) {
+            // Try running noPhase to see if that unblocks this phase next tick.
+            // This can happen if a phase that happens before noPhase
+            // is waiting on a noPhase policy to complete.
+            walkPhase(noPhase);
+          }
+          // Don't proceed to the next phase until this phase finishes.
+          return;
+        }
+
+        if (phase.hasAfterPolicies) {
+          // Run any policies unblocked by this phase
+          walkPhase(noPhase);
+        }
+      }
+    }
+
+    // Iterate until we've put every node in the result list.
+    let iteration = 0;
+    while (policyMap.size > 0) {
+      iteration++;
+      const initialResultLength = result.length;
+      // Keep walking each phase in order until we can order every node.
+      walkPhases();
+      // The result list *should* get at least one larger each time
+      // after the first full pass.
+      // Otherwise, we're going to loop forever.
+      if (result.length <= initialResultLength && iteration > 1) {
+        throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
+      }
+    }
+
+    return result;
+  }
+}
+
 /**
  * Creates a totally empty pipeline.
  * Useful for testing or creating a custom one.
  */
 export function createEmptyPipeline(): Pipeline {
-  return tspCreateEmptyPipeline() as Pipeline;
+  return HttpPipeline.create();
 }
diff --git a/src/pipelineRequest.ts b/src/pipelineRequest.ts
index 8c58dc8..81d925d 100644
--- a/src/pipelineRequest.ts
+++ b/src/pipelineRequest.ts
@@ -2,23 +2,17 @@
 // Licensed under the MIT License.
 
 import type {
-  Agent,
   FormDataMap,
   HttpHeaders,
+  HttpMethods,
   MultipartRequestBody,
   PipelineRequest,
   ProxySettings,
   RequestBodyType,
-  TlsSettings,
   TransferProgressEvent,
 } from "./interfaces.js";
-import type { AbortSignalLike } from "@azure/abort-controller";
-import type { OperationTracingOptions } from "@azure/core-tracing";
-import type { HttpMethods } from "@azure/core-util";
-import {
-  createPipelineRequest as tspCreatePipelineRequest,
-  type PipelineRequestOptions as TspPipelineRequestOptions,
-} from "@typespec/ts-http-runtime";
+import { createHttpHeaders } from "./httpHeaders.js";
+import { randomUUID } from "./util/uuidUtils.js";
 
 /**
  * Settings to initialize a request.
@@ -78,16 +72,6 @@ export interface PipelineRequestOptions {
    */
   streamResponseStatusCodes?: Set<number>;
 
-  /**
-   * NODEJS ONLY
-   *
-   * A Node-only option to provide a custom `http.Agent`/`https.Agent`.
-   * NOTE: usually this should be one instance shared by multiple requests so that the underlying
-   *       connection to the service can be reused.
-   * Does nothing when running in the browser.
-   */
-  agent?: Agent;
-
   /**
    * BROWSER ONLY
    *
@@ -99,9 +83,6 @@ export interface PipelineRequestOptions {
    */
   enableBrowserStreams?: boolean;
 
-  /** Settings for configuring TLS authentication */
-  tlsSettings?: TlsSettings;
-
   /**
    * Proxy configuration.
    */
@@ -115,12 +96,7 @@ export interface PipelineRequestOptions {
   /**
    * Used to abort the request later.
    */
-  abortSignal?: AbortSignalLike;
-
-  /**
-   * Options used to create a span when tracing is enabled.
-   */
-  tracingOptions?: OperationTracingOptions;
+  abortSignal?: AbortSignal;
 
   /**
    * Callback which fires upon upload progress.
@@ -146,14 +122,54 @@ export interface PipelineRequestOptions {
   requestOverrides?: Record<string, unknown>;
 }
 
+class PipelineRequestImpl implements PipelineRequest {
+  public url: string;
+  public method: HttpMethods;
+  public headers: HttpHeaders;
+  public timeout: number;
+  public withCredentials: boolean;
+  public body?: RequestBodyType;
+  public multipartBody?: MultipartRequestBody;
+  public formData?: FormDataMap;
+  public streamResponseStatusCodes?: Set<number>;
+  public enableBrowserStreams: boolean;
+
+  public proxySettings?: ProxySettings;
+  public disableKeepAlive: boolean;
+  public abortSignal?: AbortSignal;
+  public requestId: string;
+  public allowInsecureConnection?: boolean;
+  public onUploadProgress?: (progress: TransferProgressEvent) => void;
+  public onDownloadProgress?: (progress: TransferProgressEvent) => void;
+  public requestOverrides?: Record<string, unknown>;
+
+  constructor(options: PipelineRequestOptions) {
+    this.url = options.url;
+    this.body = options.body;
+    this.headers = options.headers ?? createHttpHeaders();
+    this.method = options.method ?? "GET";
+    this.timeout = options.timeout ?? 0;
+    this.multipartBody = options.multipartBody;
+    this.formData = options.formData;
+    this.disableKeepAlive = options.disableKeepAlive ?? false;
+    this.proxySettings = options.proxySettings;
+    this.streamResponseStatusCodes = options.streamResponseStatusCodes;
+    this.withCredentials = options.withCredentials ?? false;
+    this.abortSignal = options.abortSignal;
+    this.onUploadProgress = options.onUploadProgress;
+    this.onDownloadProgress = options.onDownloadProgress;
+    this.requestId = options.requestId || randomUUID();
+    this.allowInsecureConnection = options.allowInsecureConnection ?? false;
+    this.enableBrowserStreams = options.enableBrowserStreams ?? false;
+    this.requestOverrides = options.requestOverrides;
+  }
+}
+
 /**
  * Creates a new pipeline request with the given options.
  * This method is to allow for the easy setting of default values and not required.
  * @param options - The options to create the request with.
  */
 export function createPipelineRequest(options: PipelineRequestOptions): PipelineRequest {
-  // Cast required due to difference between ts-http-runtime requiring AbortSignal while core-rest-pipeline allows
-  // the more generic AbortSignalLike. The wrapAbortSignalLike pipeline policy will take care of ensuring that any AbortSignalLike in the request
-  // is converted into a true AbortSignal.
-  return tspCreatePipelineRequest(options as TspPipelineRequestOptions);
+  return new PipelineRequestImpl(options);
 }
diff --git a/src/policies/agentPolicy.ts b/src/policies/agentPolicy.ts
index b9c25da..7e29031 100644
--- a/src/policies/agentPolicy.ts
+++ b/src/policies/agentPolicy.ts
@@ -3,19 +3,24 @@
 
 import type { PipelinePolicy } from "../pipeline.js";
 import type { Agent } from "../interfaces.js";
-import {
-  agentPolicyName as tspAgentPolicyName,
-  agentPolicy as tspAgentPolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
 
 /**
  * Name of the Agent Policy
  */
-export const agentPolicyName = tspAgentPolicyName;
+export const agentPolicyName = "agentPolicy";
 
 /**
  * Gets a pipeline policy that sets http.agent
  */
 export function agentPolicy(agent?: Agent): PipelinePolicy {
-  return tspAgentPolicy(agent);
+  return {
+    name: agentPolicyName,
+    sendRequest: async (req, next) => {
+      // Users may define an agent on the request, honor it over the client level one
+      if (!req.agent) {
+        req.agent = agent;
+      }
+      return next(req);
+    },
+  };
 }
diff --git a/src/policies/auth/apiKeyAuthenticationPolicy.ts b/src/policies/auth/apiKeyAuthenticationPolicy.ts
new file mode 100644
index 0000000..ea33138
--- /dev/null
+++ b/src/policies/auth/apiKeyAuthenticationPolicy.ts
@@ -0,0 +1,60 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { ApiKeyCredential } from "../../auth/credentials.js";
+import type { AuthScheme } from "../../auth/schemes.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../../interfaces.js";
+import type { PipelinePolicy } from "../../pipeline.js";
+import { ensureSecureConnection } from "./checkInsecureConnection.js";
+
+/**
+ * Name of the API Key Authentication Policy
+ */
+export const apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
+
+/**
+ * Options for configuring the API key authentication policy
+ */
+export interface ApiKeyAuthenticationPolicyOptions {
+  /**
+   * The credential used to authenticate requests
+   */
+  credential: ApiKeyCredential;
+  /**
+   * Optional authentication schemes to use. If `authSchemes` is provided in both request and policy options, the request options will take precedence.
+   */
+  authSchemes?: AuthScheme[];
+  /**
+   * Allows for connecting to HTTP endpoints instead of enforcing HTTPS.
+   * CAUTION: Never use this option in production.
+   */
+  allowInsecureConnection?: boolean;
+}
+
+/**
+ * Gets a pipeline policy that adds API key authentication to requests
+ */
+export function apiKeyAuthenticationPolicy(
+  options: ApiKeyAuthenticationPolicyOptions,
+): PipelinePolicy {
+  return {
+    name: apiKeyAuthenticationPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
+      ensureSecureConnection(request, options);
+
+      const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "apiKey");
+
+      // Skip adding authentication header if no API key authentication scheme is found
+      if (!scheme) {
+        return next(request);
+      }
+      if (scheme.apiKeyLocation !== "header") {
+        throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
+      }
+
+      request.headers.set(scheme.name, options.credential.key);
+      return next(request);
+    },
+  };
+}
diff --git a/src/policies/auth/basicAuthenticationPolicy.ts b/src/policies/auth/basicAuthenticationPolicy.ts
new file mode 100644
index 0000000..e4486de
--- /dev/null
+++ b/src/policies/auth/basicAuthenticationPolicy.ts
@@ -0,0 +1,65 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { BasicCredential } from "../../auth/credentials.js";
+import type { AuthScheme } from "../../auth/schemes.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../../interfaces.js";
+import type { PipelinePolicy } from "../../pipeline.js";
+import { stringToUint8Array, uint8ArrayToString } from "../../util/bytesEncoding.js";
+import { ensureSecureConnection } from "./checkInsecureConnection.js";
+
+/**
+ * Name of the Basic Authentication Policy
+ */
+export const basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
+
+/**
+ * Options for configuring the basic authentication policy
+ */
+export interface BasicAuthenticationPolicyOptions {
+  /**
+   * The credential used to authenticate requests
+   */
+  credential: BasicCredential;
+  /**
+   * Optional authentication schemes to use. If not provided, schemes from the request will be used.
+   */
+  authSchemes?: AuthScheme[];
+  /**
+   * Allows for connecting to HTTP endpoints instead of enforcing HTTPS.
+   * CAUTION: Never use this option in production.
+   */
+  allowInsecureConnection?: boolean;
+}
+
+/**
+ * Gets a pipeline policy that adds basic authentication to requests
+ */
+export function basicAuthenticationPolicy(
+  options: BasicAuthenticationPolicyOptions,
+): PipelinePolicy {
+  return {
+    name: basicAuthenticationPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
+      ensureSecureConnection(request, options);
+
+      const scheme = (request.authSchemes ?? options.authSchemes)?.find(
+        (x) => x.kind === "http" && x.scheme === "basic",
+      );
+
+      // Skip adding authentication header if no basic authentication scheme is found
+      if (!scheme) {
+        return next(request);
+      }
+
+      const { username, password } = options.credential;
+      const headerValue = uint8ArrayToString(
+        stringToUint8Array(`${username}:${password}`, "utf-8"),
+        "base64",
+      );
+      request.headers.set("Authorization", `Basic ${headerValue}`);
+      return next(request);
+    },
+  };
+}
diff --git a/src/policies/auth/bearerAuthenticationPolicy.ts b/src/policies/auth/bearerAuthenticationPolicy.ts
new file mode 100644
index 0000000..d7e8010
--- /dev/null
+++ b/src/policies/auth/bearerAuthenticationPolicy.ts
@@ -0,0 +1,62 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { BearerTokenCredential } from "../../auth/credentials.js";
+import type { AuthScheme } from "../../auth/schemes.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../../interfaces.js";
+import type { PipelinePolicy } from "../../pipeline.js";
+import { ensureSecureConnection } from "./checkInsecureConnection.js";
+
+/**
+ * Name of the Bearer Authentication Policy
+ */
+export const bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
+
+/**
+ * Options for configuring the bearer authentication policy
+ */
+export interface BearerAuthenticationPolicyOptions {
+  /**
+   * The BearerTokenCredential implementation that can supply the bearer token.
+   */
+  credential: BearerTokenCredential;
+  /**
+   * Optional authentication schemes to use. If not provided, schemes from the request will be used.
+   */
+  authSchemes?: AuthScheme[];
+  /**
+   * Allows for connecting to HTTP endpoints instead of enforcing HTTPS.
+   * CAUTION: Never use this option in production.
+   */
+  allowInsecureConnection?: boolean;
+}
+
+/**
+ * Gets a pipeline policy that adds bearer token authentication to requests
+ */
+export function bearerAuthenticationPolicy(
+  options: BearerAuthenticationPolicyOptions,
+): PipelinePolicy {
+  return {
+    name: bearerAuthenticationPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
+      ensureSecureConnection(request, options);
+
+      const scheme = (request.authSchemes ?? options.authSchemes)?.find(
+        (x) => x.kind === "http" && x.scheme === "bearer",
+      );
+
+      // Skip adding authentication header if no bearer authentication scheme is found
+      if (!scheme) {
+        return next(request);
+      }
+
+      const token = await options.credential.getBearerToken({
+        abortSignal: request.abortSignal,
+      });
+      request.headers.set("Authorization", `Bearer ${token}`);
+      return next(request);
+    },
+  };
+}
diff --git a/src/policies/auth/checkInsecureConnection.ts b/src/policies/auth/checkInsecureConnection.ts
new file mode 100644
index 0000000..704f486
--- /dev/null
+++ b/src/policies/auth/checkInsecureConnection.ts
@@ -0,0 +1,65 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { PipelineRequest } from "../../interfaces.js";
+import { logger } from "../../log.js";
+
+// Ensure the warining is only emitted once
+let insecureConnectionWarningEmmitted = false;
+
+/**
+ * Checks if the request is allowed to be sent over an insecure connection.
+ *
+ * A request is allowed to be sent over an insecure connection when:
+ * - The `allowInsecureConnection` option is set to `true`.
+ * - The request has the `allowInsecureConnection` property set to `true`.
+ * - The request is being sent to `localhost` or `127.0.0.1`
+ */
+function allowInsecureConnection(
+  request: PipelineRequest,
+  options: { allowInsecureConnection?: boolean },
+): boolean {
+  if (options.allowInsecureConnection && request.allowInsecureConnection) {
+    const url = new URL(request.url);
+    if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+/**
+ * Logs a warning about sending a token over an insecure connection.
+ *
+ * This function will emit a node warning once, but log the warning every time.
+ */
+function emitInsecureConnectionWarning(): void {
+  const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
+
+  logger.warning(warning);
+
+  if (typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted) {
+    insecureConnectionWarningEmmitted = true;
+    process.emitWarning(warning);
+  }
+}
+
+/**
+ * Ensures that authentication is only allowed over HTTPS unless explicitly allowed.
+ * Throws an error if the connection is not secure and not explicitly allowed.
+ */
+export function ensureSecureConnection(
+  request: PipelineRequest,
+  options: { allowInsecureConnection?: boolean },
+): void {
+  if (!request.url.toLowerCase().startsWith("https://")) {
+    if (allowInsecureConnection(request, options)) {
+      emitInsecureConnectionWarning();
+    } else {
+      throw new Error(
+        "Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.",
+      );
+    }
+  }
+}
diff --git a/src/policies/auth/oauth2AuthenticationPolicy.ts b/src/policies/auth/oauth2AuthenticationPolicy.ts
new file mode 100644
index 0000000..5c76266
--- /dev/null
+++ b/src/policies/auth/oauth2AuthenticationPolicy.ts
@@ -0,0 +1,60 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { OAuth2Flow } from "../../auth/oauth2Flows.js";
+import type { OAuth2TokenCredential } from "../../auth/credentials.js";
+import type { AuthScheme } from "../../auth/schemes.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../../interfaces.js";
+import type { PipelinePolicy } from "../../pipeline.js";
+import { ensureSecureConnection } from "./checkInsecureConnection.js";
+
+/**
+ * Name of the OAuth2 Authentication Policy
+ */
+export const oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
+
+/**
+ * Options for configuring the OAuth2 authentication policy
+ */
+export interface OAuth2AuthenticationPolicyOptions<TFlows extends OAuth2Flow> {
+  /**
+   * The OAuth2TokenCredential implementation that can supply the bearer token.
+   */
+  credential: OAuth2TokenCredential<TFlows>;
+  /**
+   * Optional authentication schemes to use. If not provided, schemes from the request will be used.
+   */
+  authSchemes?: AuthScheme[];
+  /**
+   * Allows for connecting to HTTP endpoints instead of enforcing HTTPS.
+   * CAUTION: Never use this option in production.
+   */
+  allowInsecureConnection?: boolean;
+}
+
+/**
+ * Gets a pipeline policy that adds authorization header from OAuth2 schemes
+ */
+export function oauth2AuthenticationPolicy<TFlows extends OAuth2Flow>(
+  options: OAuth2AuthenticationPolicyOptions<TFlows>,
+): PipelinePolicy {
+  return {
+    name: oauth2AuthenticationPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
+      ensureSecureConnection(request, options);
+
+      const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "oauth2");
+
+      // Skip adding authentication header if no OAuth2 authentication scheme is found
+      if (!scheme) {
+        return next(request);
+      }
+      const token = await options.credential.getOAuth2Token(scheme.flows as TFlows[], {
+        abortSignal: request.abortSignal,
+      });
+      request.headers.set("Authorization", `Bearer ${token}`);
+      return next(request);
+    },
+  };
+}
diff --git a/src/policies/auxiliaryAuthenticationHeaderPolicy.ts b/src/policies/auxiliaryAuthenticationHeaderPolicy.ts
deleted file mode 100644
index 55110a0..0000000
--- a/src/policies/auxiliaryAuthenticationHeaderPolicy.ts
+++ /dev/null
@@ -1,106 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { GetTokenOptions, TokenCredential } from "@azure/core-auth";
-import type { AzureLogger } from "@azure/logger";
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-import { type AccessTokenGetter, createTokenCycler } from "../util/tokenCycler.js";
-import { logger as coreLogger } from "../log.js";
-import type { AuthorizeRequestOptions } from "./bearerTokenAuthenticationPolicy.js";
-
-/**
- * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.
- */
-export const auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
-const AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
-
-/**
- * Options to configure the auxiliaryAuthenticationHeaderPolicy
- */
-export interface AuxiliaryAuthenticationHeaderPolicyOptions {
-  /**
-   * TokenCredential list used to get token from auxiliary tenants and
-   * one credential for each tenant the client may need to access
-   */
-  credentials?: TokenCredential[];
-  /**
-   * Scopes depend on the cloud your application runs in
-   */
-  scopes: string | string[];
-  /**
-   * A logger can be sent for debugging purposes.
-   */
-  logger?: AzureLogger;
-}
-
-async function sendAuthorizeRequest(options: AuthorizeRequestOptions): Promise<string> {
-  const { scopes, getAccessToken, request } = options;
-  const getTokenOptions: GetTokenOptions = {
-    abortSignal: request.abortSignal,
-    tracingOptions: request.tracingOptions,
-  };
-
-  return (await getAccessToken(scopes, getTokenOptions))?.token ?? "";
-}
-
-/**
- * A policy for external tokens to `x-ms-authorization-auxiliary` header.
- * This header will be used when creating a cross-tenant application we may need to handle authentication requests
- * for resources that are in different tenants.
- * You could see [ARM docs](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works
- */
-export function auxiliaryAuthenticationHeaderPolicy(
-  options: AuxiliaryAuthenticationHeaderPolicyOptions,
-): PipelinePolicy {
-  const { credentials, scopes } = options;
-  const logger = options.logger || coreLogger;
-  const tokenCyclerMap = new WeakMap<TokenCredential, AccessTokenGetter>();
-
-  return {
-    name: auxiliaryAuthenticationHeaderPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      if (!request.url.toLowerCase().startsWith("https://")) {
-        throw new Error(
-          "Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.",
-        );
-      }
-      if (!credentials || credentials.length === 0) {
-        logger.info(
-          `${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`,
-        );
-        return next(request);
-      }
-
-      const tokenPromises: Promise<string>[] = [];
-      for (const credential of credentials) {
-        let getAccessToken = tokenCyclerMap.get(credential);
-        if (!getAccessToken) {
-          getAccessToken = createTokenCycler(credential);
-          tokenCyclerMap.set(credential, getAccessToken);
-        }
-        tokenPromises.push(
-          sendAuthorizeRequest({
-            scopes: Array.isArray(scopes) ? scopes : [scopes],
-            request,
-            getAccessToken,
-            logger,
-          }),
-        );
-      }
-      const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
-      if (auxiliaryTokens.length === 0) {
-        logger.warning(
-          `None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`,
-        );
-        return next(request);
-      }
-      request.headers.set(
-        AUTHORIZATION_AUXILIARY_HEADER,
-        auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "),
-      );
-
-      return next(request);
-    },
-  };
-}
diff --git a/src/policies/bearerTokenAuthenticationPolicy.ts b/src/policies/bearerTokenAuthenticationPolicy.ts
deleted file mode 100644
index d67931e..0000000
--- a/src/policies/bearerTokenAuthenticationPolicy.ts
+++ /dev/null
@@ -1,384 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AccessToken, GetTokenOptions, TokenCredential } from "@azure/core-auth";
-import type { AzureLogger } from "@azure/logger";
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-import { createTokenCycler } from "../util/tokenCycler.js";
-import { logger as coreLogger } from "../log.js";
-import type { RestError } from "../restError.js";
-import { isRestError } from "../restError.js";
-
-/**
- * The programmatic identifier of the bearerTokenAuthenticationPolicy.
- */
-export const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
-
-/**
- * Options sent to the authorizeRequest callback
- */
-export interface AuthorizeRequestOptions {
-  /**
-   * The scopes for which the bearer token applies.
-   */
-  scopes: string[];
-  /**
-   * Function that retrieves either a cached access token or a new access token.
-   */
-  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;
-  /**
-   * Request that the policy is trying to fulfill.
-   */
-  request: PipelineRequest;
-  /**
-   * A logger, if one was sent through the HTTP pipeline.
-   */
-  logger?: AzureLogger;
-}
-
-/**
- * Options sent to the authorizeRequestOnChallenge callback
- */
-export interface AuthorizeRequestOnChallengeOptions {
-  /**
-   * The scopes for which the bearer token applies.
-   */
-  scopes: string[];
-  /**
-   * Function that retrieves either a cached access token or a new access token.
-   */
-  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;
-  /**
-   * Request that the policy is trying to fulfill.
-   */
-  request: PipelineRequest;
-  /**
-   * Response containing the challenge.
-   */
-  response: PipelineResponse;
-  /**
-   * A logger, if one was sent through the HTTP pipeline.
-   */
-  logger?: AzureLogger;
-}
-
-/**
- * Options to override the processing of [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.
- */
-export interface ChallengeCallbacks {
-  /**
-   * Allows for the authorization of the main request of this policy before it's sent.
-   */
-  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;
-  /**
-   * Allows to handle authentication challenges and to re-authorize the request.
-   * The response containing the challenge is `options.response`.
-   * If this method returns true, the underlying request will be sent once again.
-   * The request may be modified before being sent.
-   */
-  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;
-}
-
-/**
- * Options to configure the bearerTokenAuthenticationPolicy
- */
-export interface BearerTokenAuthenticationPolicyOptions {
-  /**
-   * The TokenCredential implementation that can supply the bearer token.
-   */
-  credential?: TokenCredential;
-  /**
-   * The scopes for which the bearer token applies.
-   */
-  scopes: string | string[];
-  /**
-   * Allows for the processing of [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.
-   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.
-   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.
-   */
-  challengeCallbacks?: ChallengeCallbacks;
-  /**
-   * A logger can be sent for debugging purposes.
-   */
-  logger?: AzureLogger;
-}
-/**
- * Try to send the given request.
- *
- * When a response is received, returns a tuple of the response received and, if the response was received
- * inside a thrown RestError, the RestError that was thrown.
- *
- * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it
- * will be rethrown.
- */
-async function trySendRequest(
-  request: PipelineRequest,
-  next: SendRequest,
-): Promise<[PipelineResponse, RestError | undefined]> {
-  try {
-    return [await next(request), undefined];
-  } catch (e: any) {
-    if (isRestError(e) && e.response) {
-      return [e.response, e];
-    } else {
-      throw e;
-    }
-  }
-}
-/**
- * Default authorize request handler
- */
-async function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {
-  const { scopes, getAccessToken, request } = options;
-  // Enable CAE true by default
-  const getTokenOptions: GetTokenOptions = {
-    abortSignal: request.abortSignal,
-    tracingOptions: request.tracingOptions,
-    enableCae: true,
-  };
-
-  const accessToken = await getAccessToken(scopes, getTokenOptions);
-
-  if (accessToken) {
-    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
-  }
-}
-
-/**
- * We will retrieve the challenge only if the response status code was 401,
- * and if the response contained the header "WWW-Authenticate" with a non-empty value.
- */
-function isChallengeResponse(response: PipelineResponse): boolean {
-  return response.status === 401 && response.headers.has("WWW-Authenticate");
-}
-
-/**
- * Re-authorize the request for CAE challenge.
- * The response containing the challenge is `options.response`.
- * If this method returns true, the underlying request will be sent once again.
- */
-async function authorizeRequestOnCaeChallenge(
-  onChallengeOptions: AuthorizeRequestOnChallengeOptions,
-  caeClaims: string,
-): Promise<boolean> {
-  const { scopes } = onChallengeOptions;
-
-  const accessToken = await onChallengeOptions.getAccessToken(scopes, {
-    enableCae: true,
-    claims: caeClaims,
-  });
-  if (!accessToken) {
-    return false;
-  }
-
-  onChallengeOptions.request.headers.set(
-    "Authorization",
-    `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`,
-  );
-  return true;
-}
-
-/**
- * A policy that can request a token from a TokenCredential implementation and
- * then apply it to the Authorization header of a request as a Bearer token.
- */
-export function bearerTokenAuthenticationPolicy(
-  options: BearerTokenAuthenticationPolicyOptions,
-): PipelinePolicy {
-  const { credential, scopes, challengeCallbacks } = options;
-  const logger = options.logger || coreLogger;
-  const callbacks = {
-    authorizeRequest:
-      challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
-    authorizeRequestOnChallenge:
-      challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks),
-  };
-
-  // This function encapsulates the entire process of reliably retrieving the token
-  // The options are left out of the public API until there's demand to configure this.
-  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`
-  // in order to pass through the `options` object.
-  const getAccessToken = credential
-    ? createTokenCycler(credential /* , options */)
-    : () => Promise.resolve(null);
-
-  return {
-    name: bearerTokenAuthenticationPolicyName,
-    /**
-     * If there's no challenge parameter:
-     * - It will try to retrieve the token using the cache, or the credential's getToken.
-     * - Then it will try the next policy with or without the retrieved token.
-     *
-     * It uses the challenge parameters to:
-     * - Skip a first attempt to get the token from the credential if there's no cached token,
-     *   since it expects the token to be retrievable only after the challenge.
-     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
-     * - Send an initial request to receive the challenge if it fails.
-     * - Process a challenge if the response contains it.
-     * - Retrieve a token with the challenge information, then re-send the request.
-     */
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      if (!request.url.toLowerCase().startsWith("https://")) {
-        throw new Error(
-          "Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.",
-        );
-      }
-
-      await callbacks.authorizeRequest({
-        scopes: Array.isArray(scopes) ? scopes : [scopes],
-        request,
-        getAccessToken,
-        logger,
-      });
-
-      let response: PipelineResponse;
-      let error: Error | undefined;
-      let shouldSendRequest: boolean;
-      [response, error] = await trySendRequest(request, next);
-
-      if (isChallengeResponse(response)) {
-        let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
-        // Handle CAE by default when receive CAE claim
-        if (claims) {
-          let parsedClaim: string;
-          // Return the response immediately if claims is not a valid base64 encoded string
-          try {
-            parsedClaim = atob(claims);
-          } catch (e) {
-            logger.warning(
-              `The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`,
-            );
-            return response;
-          }
-          shouldSendRequest = await authorizeRequestOnCaeChallenge(
-            {
-              scopes: Array.isArray(scopes) ? scopes : [scopes],
-              response,
-              request,
-              getAccessToken,
-              logger,
-            },
-            parsedClaim,
-          );
-          // Send updated request and handle response for RestError
-          if (shouldSendRequest) {
-            [response, error] = await trySendRequest(request, next);
-          }
-        } else if (callbacks.authorizeRequestOnChallenge) {
-          // Handle custom challenges when client provides custom callback
-          shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
-            scopes: Array.isArray(scopes) ? scopes : [scopes],
-            request,
-            response,
-            getAccessToken,
-            logger,
-          });
-
-          // Send updated request and handle response for RestError
-          if (shouldSendRequest) {
-            [response, error] = await trySendRequest(request, next);
-          }
-
-          // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this
-          if (isChallengeResponse(response)) {
-            claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate") as string);
-            if (claims) {
-              let parsedClaim: string;
-              try {
-                parsedClaim = atob(claims);
-              } catch (e) {
-                logger.warning(
-                  `The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`,
-                );
-                return response;
-              }
-
-              shouldSendRequest = await authorizeRequestOnCaeChallenge(
-                {
-                  scopes: Array.isArray(scopes) ? scopes : [scopes],
-                  response,
-                  request,
-                  getAccessToken,
-                  logger,
-                },
-                parsedClaim,
-              );
-              // Send updated request and handle response for RestError
-              if (shouldSendRequest) {
-                [response, error] = await trySendRequest(request, next);
-              }
-            }
-          }
-        }
-      }
-
-      if (error) {
-        throw error;
-      } else {
-        return response;
-      }
-    },
-  };
-}
-
-/**
- *
- * Interface to represent a parsed challenge.
- *
- * @internal
- */
-interface AuthChallenge {
-  scheme: string;
-  params: Record<string, string>;
-}
-
-/**
- * Converts: `Bearer a="b", c="d", Pop e="f", g="h"`.
- * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.
- *
- * @internal
- */
-export function parseChallenges(challenges: string): AuthChallenge[] {
-  // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a="b", c=d`
-  // The challenge regex captures parameteres with either quotes values or unquoted values
-  const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
-  // Parameter regex captures the claims group removed from the scheme in the format `a="b"` and `c="d"`
-  // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge
-  const paramRegex = /(\w+)="([^"]*)"/g;
-
-  const parsedChallenges: AuthChallenge[] = [];
-  let match;
-
-  // Iterate over each challenge match
-  while ((match = challengeRegex.exec(challenges)) !== null) {
-    const scheme = match[1];
-    const paramsString = match[2];
-    const params: Record<string, string> = {};
-    let paramMatch;
-
-    // Iterate over each parameter match
-    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
-      params[paramMatch[1]] = paramMatch[2];
-    }
-
-    parsedChallenges.push({ scheme, params });
-  }
-  return parsedChallenges;
-}
-
-/**
- * Parse a pipeline response and look for a CAE challenge with "Bearer" scheme
- * Return the value in the header without parsing the challenge
- * @internal
- */
-function getCaeChallengeClaims(challenges: string | undefined): string | undefined {
-  if (!challenges) {
-    return;
-  }
-  // Find all challenges present in the header
-  const parsedChallenges = parseChallenges(challenges);
-  return parsedChallenges.find(
-    (x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims",
-  )?.params.claims;
-}
diff --git a/src/policies/decompressResponsePolicy-browser.mts b/src/policies/decompressResponsePolicy-browser.mts
new file mode 100644
index 0000000..0cd7506
--- /dev/null
+++ b/src/policies/decompressResponsePolicy-browser.mts
@@ -0,0 +1,16 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/*
+ * NOTE: When moving this file, please update "browser" section in package.json
+ */
+
+export const decompressResponsePolicyName = "decompressResponsePolicy";
+
+/**
+ * decompressResponsePolicy is not supported in the browser and attempting
+ * to use it will raise an error.
+ */
+export function decompressResponsePolicy(): never {
+  throw new Error("decompressResponsePolicy is not supported in browser environment");
+}
diff --git a/src/policies/decompressResponsePolicy.ts b/src/policies/decompressResponsePolicy.ts
index 8842300..252e2ad 100644
--- a/src/policies/decompressResponsePolicy.ts
+++ b/src/policies/decompressResponsePolicy.ts
@@ -1,22 +1,27 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
 
-import {
-  decompressResponsePolicyName as tspDecompressResponsePolicyName,
-  decompressResponsePolicy as tspDecompressResponsePolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
-
 /**
  * The programmatic identifier of the decompressResponsePolicy.
  */
-export const decompressResponsePolicyName = tspDecompressResponsePolicyName;
+export const decompressResponsePolicyName = "decompressResponsePolicy";
 
 /**
  * A policy to enable response decompression according to Accept-Encoding header
  * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding
  */
 export function decompressResponsePolicy(): PipelinePolicy {
-  return tspDecompressResponsePolicy();
+  return {
+    name: decompressResponsePolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // HEAD requests have no body
+      if (request.method !== "HEAD") {
+        request.headers.set("Accept-Encoding", "gzip,deflate");
+      }
+      return next(request);
+    },
+  };
 }
diff --git a/src/policies/defaultRetryPolicy.ts b/src/policies/defaultRetryPolicy.ts
index 68fb77e..169a7ca 100644
--- a/src/policies/defaultRetryPolicy.ts
+++ b/src/policies/defaultRetryPolicy.ts
@@ -3,16 +3,15 @@
 
 import type { PipelineRetryOptions } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
-
-import {
-  defaultRetryPolicyName as tspDefaultRetryPolicyName,
-  defaultRetryPolicy as tspDefaultRetryPolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
+import { exponentialRetryStrategy } from "../retryStrategies/exponentialRetryStrategy.js";
+import { throttlingRetryStrategy } from "../retryStrategies/throttlingRetryStrategy.js";
+import { retryPolicy } from "./retryPolicy.js";
+import { DEFAULT_RETRY_POLICY_COUNT } from "../constants.js";
 
 /**
  * Name of the {@link defaultRetryPolicy}
  */
-export const defaultRetryPolicyName = tspDefaultRetryPolicyName;
+export const defaultRetryPolicyName = "defaultRetryPolicy";
 
 /**
  * Options that control how to retry failed requests.
@@ -26,5 +25,10 @@ export interface DefaultRetryPolicyOptions extends PipelineRetryOptions {}
  * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.
  */
 export function defaultRetryPolicy(options: DefaultRetryPolicyOptions = {}): PipelinePolicy {
-  return tspDefaultRetryPolicy(options);
+  return {
+    name: defaultRetryPolicyName,
+    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
+      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,
+    }).sendRequest,
+  };
 }
diff --git a/src/policies/exponentialRetryPolicy.ts b/src/policies/exponentialRetryPolicy.ts
index 289ca0a..24f6e16 100644
--- a/src/policies/exponentialRetryPolicy.ts
+++ b/src/policies/exponentialRetryPolicy.ts
@@ -2,16 +2,14 @@
 // Licensed under the MIT License.
 
 import type { PipelinePolicy } from "../pipeline.js";
-
-import {
-  exponentialRetryPolicyName as tspExponentialRetryPolicyName,
-  exponentialRetryPolicy as tspExponentialRetryPolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
+import { exponentialRetryStrategy } from "../retryStrategies/exponentialRetryStrategy.js";
+import { retryPolicy } from "./retryPolicy.js";
+import { DEFAULT_RETRY_POLICY_COUNT } from "../constants.js";
 
 /**
  * The programmatic identifier of the exponentialRetryPolicy.
  */
-export const exponentialRetryPolicyName = tspExponentialRetryPolicyName;
+export const exponentialRetryPolicyName = "exponentialRetryPolicy";
 
 /**
  * Options that control how to retry failed requests.
@@ -43,5 +41,15 @@ export interface ExponentialRetryPolicyOptions {
 export function exponentialRetryPolicy(
   options: ExponentialRetryPolicyOptions = {},
 ): PipelinePolicy {
-  return tspExponentialRetryPolicy(options);
+  return retryPolicy(
+    [
+      exponentialRetryStrategy({
+        ...options,
+        ignoreSystemErrors: true,
+      }),
+    ],
+    {
+      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,
+    },
+  );
 }
diff --git a/src/policies/formDataPolicy.ts b/src/policies/formDataPolicy.ts
index 07fa342..4265f06 100644
--- a/src/policies/formDataPolicy.ts
+++ b/src/policies/formDataPolicy.ts
@@ -1,21 +1,118 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
+import { stringToUint8Array } from "../util/bytesEncoding.js";
+import { isNodeLike } from "../util/checkEnvironment.js";
+import { createHttpHeaders } from "../httpHeaders.js";
+import type {
+  BodyPart,
+  FormDataMap,
+  FormDataValue,
+  PipelineRequest,
+  PipelineResponse,
+  SendRequest,
+} from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
 
-import {
-  formDataPolicyName as tspFormDataPolicyName,
-  formDataPolicy as tspFormDataPolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
-
 /**
  * The programmatic identifier of the formDataPolicy.
  */
-export const formDataPolicyName = tspFormDataPolicyName;
+export const formDataPolicyName = "formDataPolicy";
+
+function formDataToFormDataMap(formData: FormData): FormDataMap {
+  const formDataMap: FormDataMap = {};
+  for (const [key, value] of formData.entries()) {
+    formDataMap[key] ??= [];
+    (formDataMap[key] as FormDataValue[]).push(value);
+  }
+  return formDataMap;
+}
 
 /**
  * A policy that encodes FormData on the request into the body.
  */
 export function formDataPolicy(): PipelinePolicy {
-  return tspFormDataPolicy();
+  return {
+    name: formDataPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      if (isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
+        request.formData = formDataToFormDataMap(request.body);
+        request.body = undefined;
+      }
+
+      if (request.formData) {
+        const contentType = request.headers.get("Content-Type");
+        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
+          request.body = wwwFormUrlEncode(request.formData);
+        } else {
+          await prepareFormData(request.formData, request);
+        }
+
+        request.formData = undefined;
+      }
+      return next(request);
+    },
+  };
+}
+
+function wwwFormUrlEncode(formData: FormDataMap): string {
+  const urlSearchParams = new URLSearchParams();
+  for (const [key, value] of Object.entries(formData)) {
+    if (Array.isArray(value)) {
+      for (const subValue of value) {
+        urlSearchParams.append(key, subValue.toString());
+      }
+    } else {
+      urlSearchParams.append(key, value.toString());
+    }
+  }
+  return urlSearchParams.toString();
+}
+
+async function prepareFormData(formData: FormDataMap, request: PipelineRequest): Promise<void> {
+  // validate content type (multipart/form-data)
+  const contentType = request.headers.get("Content-Type");
+  if (contentType && !contentType.startsWith("multipart/form-data")) {
+    // content type is specified and is not multipart/form-data. Exit.
+    return;
+  }
+
+  request.headers.set("Content-Type", contentType ?? "multipart/form-data");
+
+  // set body to MultipartRequestBody using content from FormDataMap
+  const parts: BodyPart[] = [];
+
+  for (const [fieldName, values] of Object.entries(formData)) {
+    for (const value of Array.isArray(values) ? values : [values]) {
+      if (typeof value === "string") {
+        parts.push({
+          headers: createHttpHeaders({
+            "Content-Disposition": `form-data; name="${fieldName}"`,
+          }),
+          body: stringToUint8Array(value, "utf-8"),
+        });
+      } else if (value === undefined || value === null || typeof value !== "object") {
+        throw new Error(
+          `Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`,
+        );
+      } else {
+        // using || instead of ?? here since if value.name is empty we should create a file name
+        const fileName = (value as File).name || "blob";
+        const headers = createHttpHeaders();
+        headers.set(
+          "Content-Disposition",
+          `form-data; name="${fieldName}"; filename="${fileName}"`,
+        );
+
+        // again, || is used since an empty value.type means the content type is unset
+        headers.set("Content-Type", value.type || "application/octet-stream");
+
+        parts.push({
+          headers,
+          body: value,
+        });
+      }
+    }
+  }
+  request.multipartBody = { parts };
 }
diff --git a/src/policies/internal.ts b/src/policies/internal.ts
new file mode 100644
index 0000000..80a1dcd
--- /dev/null
+++ b/src/policies/internal.ts
@@ -0,0 +1,33 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export { agentPolicy, agentPolicyName } from "./agentPolicy.js";
+export {
+  decompressResponsePolicy,
+  decompressResponsePolicyName,
+} from "./decompressResponsePolicy.js";
+export {
+  defaultRetryPolicy,
+  defaultRetryPolicyName,
+  DefaultRetryPolicyOptions,
+} from "./defaultRetryPolicy.js";
+export {
+  exponentialRetryPolicy,
+  exponentialRetryPolicyName,
+  ExponentialRetryPolicyOptions,
+} from "./exponentialRetryPolicy.js";
+export { retryPolicy, RetryPolicyOptions } from "./retryPolicy.js";
+export {
+  RetryInformation,
+  RetryModifiers,
+  RetryStrategy,
+} from "../retryStrategies/retryStrategy.js";
+export { systemErrorRetryPolicy, systemErrorRetryPolicyName } from "./systemErrorRetryPolicy.js";
+export { throttlingRetryPolicy, throttlingRetryPolicyName } from "./throttlingRetryPolicy.js";
+export { formDataPolicy, formDataPolicyName } from "./formDataPolicy.js";
+export { logPolicy, logPolicyName, LogPolicyOptions } from "./logPolicy.js";
+export { multipartPolicy, multipartPolicyName } from "./multipartPolicy.js";
+export { proxyPolicy, proxyPolicyName, getDefaultProxySettings } from "./proxyPolicy.js";
+export { redirectPolicy, redirectPolicyName, RedirectPolicyOptions } from "./redirectPolicy.js";
+export { tlsPolicy, tlsPolicyName } from "./tlsPolicy.js";
+export { userAgentPolicy, userAgentPolicyName, UserAgentPolicyOptions } from "./userAgentPolicy.js";
diff --git a/src/policies/logPolicy.ts b/src/policies/logPolicy.ts
index 321bbec..6b7d1ab 100644
--- a/src/policies/logPolicy.ts
+++ b/src/policies/logPolicy.ts
@@ -1,18 +1,16 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { Debugger } from "@azure/logger";
+import type { Debugger } from "../logger/logger.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
 import { logger as coreLogger } from "../log.js";
-import {
-  logPolicyName as tspLogPolicyName,
-  logPolicy as tspLogPolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
+import { Sanitizer } from "../util/sanitizer.js";
 
 /**
  * The programmatic identifier of the logPolicy.
  */
-export const logPolicyName = tspLogPolicyName;
+export const logPolicyName = "logPolicy";
 
 /**
  * Options to configure the logPolicy.
@@ -45,8 +43,26 @@ export interface LogPolicyOptions {
  * @param options - Options to configure logPolicy.
  */
 export function logPolicy(options: LogPolicyOptions = {}): PipelinePolicy {
-  return tspLogPolicy({
-    logger: coreLogger.info,
-    ...options,
+  const logger = options.logger ?? coreLogger.info;
+  const sanitizer = new Sanitizer({
+    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
+    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
   });
+  return {
+    name: logPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      if (!logger.enabled) {
+        return next(request);
+      }
+
+      logger(`Request: ${sanitizer.sanitize(request)}`);
+
+      const response = await next(request);
+
+      logger(`Response status code: ${response.status}`);
+      logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
+
+      return response;
+    },
+  };
 }
diff --git a/src/policies/multipartPolicy.ts b/src/policies/multipartPolicy.ts
index 1e6560f..268c132 100644
--- a/src/policies/multipartPolicy.ts
+++ b/src/policies/multipartPolicy.ts
@@ -1,41 +1,155 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
+import type { BodyPart, HttpHeaders, PipelineRequest, PipelineResponse } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
+import { stringToUint8Array } from "../util/bytesEncoding.js";
+import { isBlob } from "../util/typeGuards.js";
+import { randomUUID } from "../util/uuidUtils.js";
+import { concat } from "../util/concat.js";
 
-import {
-  multipartPolicyName as tspMultipartPolicyName,
-  multipartPolicy as tspMultipartPolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
-import type {
-  PipelineRequest as TspPipelineRequest,
-  SendRequest as TspSendRequest,
-} from "@typespec/ts-http-runtime";
-import { getRawContent, hasRawContent } from "../util/file.js";
+function generateBoundary(): string {
+  return `----AzSDKFormBoundary${randomUUID()}`;
+}
+
+function encodeHeaders(headers: HttpHeaders): string {
+  let result = "";
+  for (const [key, value] of headers) {
+    result += `${key}: ${value}\r\n`;
+  }
+  return result;
+}
+
+function getLength(
+  source:
+    | (() => ReadableStream<Uint8Array>)
+    | (() => NodeJS.ReadableStream)
+    | Uint8Array
+    | Blob
+    | ReadableStream
+    | NodeJS.ReadableStream,
+): number | undefined {
+  if (source instanceof Uint8Array) {
+    return source.byteLength;
+  } else if (isBlob(source)) {
+    // if was created using createFile then -1 means we have an unknown size
+    return source.size === -1 ? undefined : source.size;
+  } else {
+    return undefined;
+  }
+}
+
+function getTotalLength(
+  sources: (
+    | (() => ReadableStream<Uint8Array>)
+    | (() => NodeJS.ReadableStream)
+    | Uint8Array
+    | Blob
+    | ReadableStream
+    | NodeJS.ReadableStream
+  )[],
+): number | undefined {
+  let total = 0;
+  for (const source of sources) {
+    const partLength = getLength(source);
+    if (partLength === undefined) {
+      return undefined;
+    } else {
+      total += partLength;
+    }
+  }
+  return total;
+}
+
+async function buildRequestBody(
+  request: PipelineRequest,
+  parts: BodyPart[],
+  boundary: string,
+): Promise<void> {
+  const sources = [
+    stringToUint8Array(`--${boundary}`, "utf-8"),
+    ...parts.flatMap((part) => [
+      stringToUint8Array("\r\n", "utf-8"),
+      stringToUint8Array(encodeHeaders(part.headers), "utf-8"),
+      stringToUint8Array("\r\n", "utf-8"),
+      part.body,
+      stringToUint8Array(`\r\n--${boundary}`, "utf-8"),
+    ]),
+    stringToUint8Array("--\r\n\r\n", "utf-8"),
+  ];
+
+  const contentLength = getTotalLength(sources);
+  if (contentLength) {
+    request.headers.set("Content-Length", contentLength);
+  }
+
+  request.body = await concat(sources);
+}
 
 /**
  * Name of multipart policy
  */
-export const multipartPolicyName = tspMultipartPolicyName;
+export const multipartPolicyName = "multipartPolicy";
+
+const maxBoundaryLength = 70;
+const validBoundaryCharacters = new Set(
+  `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`,
+);
+
+function assertValidBoundary(boundary: string): void {
+  if (boundary.length > maxBoundaryLength) {
+    throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
+  }
+
+  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
+    throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
+  }
+}
 
 /**
  * Pipeline policy for multipart requests
  */
 export function multipartPolicy(): PipelinePolicy {
-  const tspPolicy = tspMultipartPolicy();
-
   return {
     name: multipartPolicyName,
-    sendRequest: async (request, next) => {
-      if (request.multipartBody) {
-        for (const part of request.multipartBody.parts) {
-          if (hasRawContent(part.body)) {
-            part.body = getRawContent(part.body);
+    async sendRequest(request, next): Promise<PipelineResponse> {
+      if (!request.multipartBody) {
+        return next(request);
       }
+
+      if (request.body) {
+        throw new Error("multipartBody and regular body cannot be set at the same time");
       }
+
+      let boundary = request.multipartBody.boundary;
+
+      const contentTypeHeader = request.headers.get("Content-Type") ?? "multipart/mixed";
+      const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
+      if (!parsedHeader) {
+        throw new Error(
+          `Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`,
+        );
+      }
+
+      const [, contentType, parsedBoundary] = parsedHeader;
+      if (parsedBoundary && boundary && parsedBoundary !== boundary) {
+        throw new Error(
+          `Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`,
+        );
       }
 
-      return tspPolicy.sendRequest(request as TspPipelineRequest, next as TspSendRequest);
+      boundary ??= parsedBoundary;
+      if (boundary) {
+        assertValidBoundary(boundary);
+      } else {
+        boundary = generateBoundary();
+      }
+      request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
+      await buildRequestBody(request, request.multipartBody.parts, boundary);
+
+      request.multipartBody = undefined;
+
+      return next(request);
     },
   };
 }
diff --git a/src/policies/ndJsonPolicy.ts b/src/policies/ndJsonPolicy.ts
deleted file mode 100644
index deeee45..0000000
--- a/src/policies/ndJsonPolicy.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-
-/**
- * The programmatic identifier of the ndJsonPolicy.
- */
-export const ndJsonPolicyName = "ndJsonPolicy";
-
-/**
- * ndJsonPolicy is a policy used to control keep alive settings for every request.
- */
-export function ndJsonPolicy(): PipelinePolicy {
-  return {
-    name: ndJsonPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      // There currently isn't a good way to bypass the serializer
-      if (typeof request.body === "string" && request.body.startsWith("[")) {
-        const body = JSON.parse(request.body);
-        if (Array.isArray(body)) {
-          request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
-        }
-      }
-      return next(request);
-    },
-  };
-}
diff --git a/src/policies/proxyPolicy-browser.mts b/src/policies/proxyPolicy-browser.mts
new file mode 100644
index 0000000..8cb0239
--- /dev/null
+++ b/src/policies/proxyPolicy-browser.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./proxyPolicy.common.js";
diff --git a/src/policies/proxyPolicy-react-native.mts b/src/policies/proxyPolicy-react-native.mts
new file mode 100644
index 0000000..8cb0239
--- /dev/null
+++ b/src/policies/proxyPolicy-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./proxyPolicy.common.js";
diff --git a/src/policies/proxyPolicy.common.ts b/src/policies/proxyPolicy.common.ts
new file mode 100644
index 0000000..9ae41a5
--- /dev/null
+++ b/src/policies/proxyPolicy.common.ts
@@ -0,0 +1,27 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export const proxyPolicyName = "proxyPolicy";
+const errorMessage = "proxyPolicy is not supported in browser environment";
+
+export function getDefaultProxySettings(): never {
+  throw new Error(errorMessage);
+}
+
+/**
+ * proxyPolicy is not supported in the browser and attempting
+ * to use it will raise an error.
+ */
+export function proxyPolicy(): never {
+  throw new Error(errorMessage);
+}
+
+/**
+ * A function to reset the cached agents.
+ * proxyPolicy is not supported in the browser and attempting
+ * to use it will raise an error.
+ * @internal
+ */
+export function resetCachedProxyAgents(): never {
+  throw new Error(errorMessage);
+}
diff --git a/src/policies/proxyPolicy.ts b/src/policies/proxyPolicy.ts
index 0ba9403..22b8c0f 100644
--- a/src/policies/proxyPolicy.ts
+++ b/src/policies/proxyPolicy.ts
@@ -1,19 +1,111 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { ProxySettings } from "../interfaces.js";
+import type * as http from "http";
+import type * as https from "https";
+import { HttpsProxyAgent } from "https-proxy-agent";
+import { HttpProxyAgent } from "http-proxy-agent";
+import type {
+  PipelineRequest,
+  PipelineResponse,
+  ProxySettings,
+  SendRequest,
+} from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
+import { logger } from "../log.js";
 
-import {
-  proxyPolicy as tspProxyPolicy,
-  proxyPolicyName as tspProxyPolicyName,
-  getDefaultProxySettings as tspGetDefaultProxySettings,
-} from "@typespec/ts-http-runtime/internal/policies";
+const HTTPS_PROXY = "HTTPS_PROXY";
+const HTTP_PROXY = "HTTP_PROXY";
+const ALL_PROXY = "ALL_PROXY";
+const NO_PROXY = "NO_PROXY";
 
 /**
  * The programmatic identifier of the proxyPolicy.
  */
-export const proxyPolicyName = tspProxyPolicyName;
+export const proxyPolicyName = "proxyPolicy";
+
+/**
+ * Stores the patterns specified in NO_PROXY environment variable.
+ * @internal
+ */
+export const globalNoProxyList: string[] = [];
+let noProxyListLoaded: boolean = false;
+
+/** A cache of whether a host should bypass the proxy. */
+const globalBypassedMap: Map<string, boolean> = new Map();
+
+function getEnvironmentValue(name: string): string | undefined {
+  if (process.env[name]) {
+    return process.env[name];
+  } else if (process.env[name.toLowerCase()]) {
+    return process.env[name.toLowerCase()];
+  }
+  return undefined;
+}
+
+function loadEnvironmentProxyValue(): string | undefined {
+  if (!process) {
+    return undefined;
+  }
+
+  const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
+  const allProxy = getEnvironmentValue(ALL_PROXY);
+  const httpProxy = getEnvironmentValue(HTTP_PROXY);
+
+  return httpsProxy || allProxy || httpProxy;
+}
+
+/**
+ * Check whether the host of a given `uri` matches any pattern in the no proxy list.
+ * If there's a match, any request sent to the same host shouldn't have the proxy settings set.
+ * This implementation is a port of https://github.com/Azure/azure-sdk-for-net/blob/8cca811371159e527159c7eb65602477898683e2/sdk/core/Azure.Core/src/Pipeline/Internal/HttpEnvironmentProxy.cs#L210
+ */
+function isBypassed(
+  uri: string,
+  noProxyList: string[],
+  bypassedMap?: Map<string, boolean>,
+): boolean | undefined {
+  if (noProxyList.length === 0) {
+    return false;
+  }
+  const host = new URL(uri).hostname;
+  if (bypassedMap?.has(host)) {
+    return bypassedMap.get(host);
+  }
+  let isBypassedFlag = false;
+  for (const pattern of noProxyList) {
+    if (pattern[0] === ".") {
+      // This should match either domain it self or any subdomain or host
+      // .foo.com will match foo.com it self or *.foo.com
+      if (host.endsWith(pattern)) {
+        isBypassedFlag = true;
+      } else {
+        if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
+          isBypassedFlag = true;
+        }
+      }
+    } else {
+      if (host === pattern) {
+        isBypassedFlag = true;
+      }
+    }
+  }
+  bypassedMap?.set(host, isBypassedFlag);
+  return isBypassedFlag;
+}
+
+export function loadNoProxy(): string[] {
+  const noProxy = getEnvironmentValue(NO_PROXY);
+  noProxyListLoaded = true;
+  if (noProxy) {
+    return noProxy
+      .split(",")
+      .map((item) => item.trim())
+      .filter((item) => item.length);
+  }
+
+  return [];
+}
 
 /**
  * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.
@@ -23,7 +115,92 @@ export const proxyPolicyName = tspProxyPolicyName;
  * @deprecated - Internally this method is no longer necessary when setting proxy information.
  */
 export function getDefaultProxySettings(proxyUrl?: string): ProxySettings | undefined {
-  return tspGetDefaultProxySettings(proxyUrl);
+  if (!proxyUrl) {
+    proxyUrl = loadEnvironmentProxyValue();
+    if (!proxyUrl) {
+      return undefined;
+    }
+  }
+
+  const parsedUrl = new URL(proxyUrl);
+  const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
+  return {
+    host: schema + parsedUrl.hostname,
+    port: Number.parseInt(parsedUrl.port || "80"),
+    username: parsedUrl.username,
+    password: parsedUrl.password,
+  };
+}
+
+/**
+ * This method attempts to parse a proxy URL from the environment
+ * variables `HTTPS_PROXY` or `HTTP_PROXY`.
+ */
+function getDefaultProxySettingsInternal(): URL | undefined {
+  const envProxy = loadEnvironmentProxyValue();
+  return envProxy ? new URL(envProxy) : undefined;
+}
+
+function getUrlFromProxySettings(settings: ProxySettings): URL {
+  let parsedProxyUrl: URL;
+  try {
+    parsedProxyUrl = new URL(settings.host);
+  } catch {
+    throw new Error(
+      `Expecting a valid host string in proxy settings, but found "${settings.host}".`,
+    );
+  }
+
+  parsedProxyUrl.port = String(settings.port);
+  if (settings.username) {
+    parsedProxyUrl.username = settings.username;
+  }
+  if (settings.password) {
+    parsedProxyUrl.password = settings.password;
+  }
+
+  return parsedProxyUrl;
+}
+
+function setProxyAgentOnRequest(
+  request: PipelineRequest,
+  cachedAgents: CachedAgents,
+  proxyUrl: URL,
+): void {
+  // Custom Agent should take precedence so if one is present
+  // we should skip to avoid overwriting it.
+  if (request.agent) {
+    return;
+  }
+
+  const url = new URL(request.url);
+
+  const isInsecure = url.protocol !== "https:";
+
+  if (request.tlsSettings) {
+    logger.warning(
+      "TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.",
+    );
+  }
+
+  const headers = request.headers.toJSON();
+
+  if (isInsecure) {
+    if (!cachedAgents.httpProxyAgent) {
+      cachedAgents.httpProxyAgent = new HttpProxyAgent(proxyUrl, { headers });
+    }
+    request.agent = cachedAgents.httpProxyAgent;
+  } else {
+    if (!cachedAgents.httpsProxyAgent) {
+      cachedAgents.httpsProxyAgent = new HttpsProxyAgent(proxyUrl, { headers });
+    }
+    request.agent = cachedAgents.httpsProxyAgent;
+  }
+}
+
+interface CachedAgents {
+  httpsProxyAgent?: https.Agent;
+  httpProxyAgent?: http.Agent;
 }
 
 /**
@@ -40,5 +217,37 @@ export function proxyPolicy(
     customNoProxyList?: string[];
   },
 ): PipelinePolicy {
-  return tspProxyPolicy(proxySettings, options);
+  if (!noProxyListLoaded) {
+    globalNoProxyList.push(...loadNoProxy());
+  }
+
+  const defaultProxy = proxySettings
+    ? getUrlFromProxySettings(proxySettings)
+    : getDefaultProxySettingsInternal();
+
+  const cachedAgents: CachedAgents = {};
+
+  return {
+    name: proxyPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      if (
+        !request.proxySettings &&
+        defaultProxy &&
+        !isBypassed(
+          request.url,
+          options?.customNoProxyList ?? globalNoProxyList,
+          options?.customNoProxyList ? undefined : globalBypassedMap,
+        )
+      ) {
+        setProxyAgentOnRequest(request, cachedAgents, defaultProxy);
+      } else if (request.proxySettings) {
+        setProxyAgentOnRequest(
+          request,
+          cachedAgents,
+          getUrlFromProxySettings(request.proxySettings),
+        );
+      }
+      return next(request);
+    },
+  };
 }
diff --git a/src/policies/redirectPolicy.ts b/src/policies/redirectPolicy.ts
index 8a5f51c..1b8bf2c 100644
--- a/src/policies/redirectPolicy.ts
+++ b/src/policies/redirectPolicy.ts
@@ -1,17 +1,18 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
 
-import {
-  redirectPolicyName as tspRedirectPolicyName,
-  redirectPolicy as tspRedirectPolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
-
 /**
  * The programmatic identifier of the redirectPolicy.
  */
-export const redirectPolicyName = tspRedirectPolicyName;
+export const redirectPolicyName = "redirectPolicy";
+
+/**
+ * Methods that are allowed to follow redirects 301 and 302
+ */
+const allowedRedirect = ["GET", "HEAD"];
 
 /**
  * Options for how redirect responses are handled.
@@ -31,5 +32,49 @@ export interface RedirectPolicyOptions {
  * @param options - Options to control policy behavior.
  */
 export function redirectPolicy(options: RedirectPolicyOptions = {}): PipelinePolicy {
-  return tspRedirectPolicy(options);
+  const { maxRetries = 20 } = options;
+  return {
+    name: redirectPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      const response = await next(request);
+      return handleRedirect(next, response, maxRetries);
+    },
+  };
+}
+
+async function handleRedirect(
+  next: SendRequest,
+  response: PipelineResponse,
+  maxRetries: number,
+  currentRetries: number = 0,
+): Promise<PipelineResponse> {
+  const { request, status, headers } = response;
+  const locationHeader = headers.get("location");
+  if (
+    locationHeader &&
+    (status === 300 ||
+      (status === 301 && allowedRedirect.includes(request.method)) ||
+      (status === 302 && allowedRedirect.includes(request.method)) ||
+      (status === 303 && request.method === "POST") ||
+      status === 307) &&
+    currentRetries < maxRetries
+  ) {
+    const url = new URL(locationHeader, request.url);
+    request.url = url.toString();
+
+    // POST request with Status code 303 should be converted into a
+    // redirected GET request if the redirect url is present in the location header
+    if (status === 303) {
+      request.method = "GET";
+      request.headers.delete("Content-Length");
+      delete request.body;
+    }
+
+    request.headers.delete("Authorization");
+
+    const res = await next(request);
+    return handleRedirect(next, res, maxRetries, currentRetries + 1);
+  }
+
+  return response;
 }
diff --git a/src/policies/retryPolicy.ts b/src/policies/retryPolicy.ts
index db876b9..242dbef 100644
--- a/src/policies/retryPolicy.ts
+++ b/src/policies/retryPolicy.ts
@@ -1,78 +1,22 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
-import { type AzureLogger, createClientLogger } from "@azure/logger";
-import { DEFAULT_RETRY_POLICY_COUNT } from "../constants.js";
-
-import {
-  retryPolicy as tspRetryPolicy,
-  type RetryStrategy as TspRetryStrategy,
-} from "@typespec/ts-http-runtime/internal/policies";
-import type { PipelineResponse } from "../interfaces.js";
+import { delay } from "../util/helpers.js";
+import type { RetryStrategy } from "../retryStrategies/retryStrategy.js";
 import type { RestError } from "../restError.js";
+import { AbortError } from "../abort-controller/AbortError.js";
+import type { TypeSpecRuntimeLogger } from "../logger/logger.js";
+import { createClientLogger } from "../logger/logger.js";
+import { DEFAULT_RETRY_POLICY_COUNT } from "../constants.js";
 
-const retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
+const retryPolicyLogger = createClientLogger("ts-http-runtime retryPolicy");
 
 /**
- * Information provided to the retry strategy about the current progress of the retry policy.
- */
-export interface RetryInformation {
-  /**
-   * A {@link PipelineResponse}, if the last retry attempt succeeded.
-   */
-  response?: PipelineResponse;
-  /**
-   * A {@link RestError}, if the last retry attempt failed.
-   */
-  responseError?: RestError;
-  /**
-   * Total number of retries so far.
+ * The programmatic identifier of the retryPolicy.
  */
-  retryCount: number;
-}
-
-/**
- * Properties that can modify the behavior of the retry policy.
- */
-export interface RetryModifiers {
-  /**
-   * If true, allows skipping the current strategy from running on the retry policy.
-   */
-  skipStrategy?: boolean;
-  /**
-   * Indicates to retry against this URL.
-   */
-  redirectTo?: string;
-  /**
-   * Controls whether to retry in a given number of milliseconds.
-   * If provided, a new retry will be attempted.
-   */
-  retryAfterInMs?: number;
-  /**
-   * Indicates to throw this error instead of retrying.
-   */
-  errorToThrow?: RestError;
-}
-
-/**
- * A retry strategy is intended to define whether to retry or not, and how to retry.
- */
-export interface RetryStrategy {
-  /**
-   * Name of the retry strategy. Used for logging.
-   */
-  name: string;
-  /**
-   * Logger. If it's not provided, a default logger for all retry strategies is used.
-   */
-  logger?: AzureLogger;
-  /**
-   * Function that determines how to proceed with the subsequent requests.
-   * @param state - Retry state
-   */
-  retry(state: RetryInformation): RetryModifiers;
-}
+const retryPolicyName = "retryPolicy";
 
 /**
  * Options to the {@link retryPolicy}
@@ -85,7 +29,7 @@ export interface RetryPolicyOptions {
   /**
    * Logger. If it's not provided, a default logger is used.
    */
-  logger?: AzureLogger;
+  logger?: TypeSpecRuntimeLogger;
 }
 
 /**
@@ -95,11 +39,117 @@ export function retryPolicy(
   strategies: RetryStrategy[],
   options: RetryPolicyOptions = { maxRetries: DEFAULT_RETRY_POLICY_COUNT },
 ): PipelinePolicy {
-  // Cast is required since the TSP runtime retry strategy type is slightly different
-  // very deep down (using real AbortSignal vs. AbortSignalLike in RestError).
-  // In practice the difference doesn't actually matter.
-  return tspRetryPolicy(strategies as TspRetryStrategy[], {
-    logger: retryPolicyLogger,
-    ...options,
+  const logger = options.logger || retryPolicyLogger;
+  return {
+    name: retryPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      let response: PipelineResponse | undefined;
+      let responseError: RestError | undefined;
+      let retryCount = -1;
+
+      retryRequest: while (true) {
+        retryCount += 1;
+        response = undefined;
+        responseError = undefined;
+
+        try {
+          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
+          response = await next(request);
+          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
+        } catch (e: any) {
+          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
+
+          // RestErrors are valid targets for the retry strategies.
+          // If none of the retry strategies can work with them, they will be thrown later in this policy.
+          // If the received error is not a RestError, it is immediately thrown.
+          responseError = e as RestError;
+          if (!e || responseError.name !== "RestError") {
+            throw e;
+          }
+
+          response = responseError.response;
+        }
+
+        if (request.abortSignal?.aborted) {
+          logger.error(`Retry ${retryCount}: Request aborted.`);
+          const abortError = new AbortError();
+          throw abortError;
+        }
+
+        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {
+          logger.info(
+            `Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`,
+          );
+          if (responseError) {
+            throw responseError;
+          } else if (response) {
+            return response;
+          } else {
+            throw new Error("Maximum retries reached with no response or error to throw");
+          }
+        }
+
+        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
+
+        strategiesLoop: for (const strategy of strategies) {
+          const strategyLogger = strategy.logger || logger;
+          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
+
+          const modifiers = strategy.retry({
+            retryCount,
+            response,
+            responseError,
           });
+
+          if (modifiers.skipStrategy) {
+            strategyLogger.info(`Retry ${retryCount}: Skipped.`);
+            continue strategiesLoop;
+          }
+
+          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
+
+          if (errorToThrow) {
+            strategyLogger.error(
+              `Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`,
+              errorToThrow,
+            );
+            throw errorToThrow;
+          }
+
+          if (retryAfterInMs || retryAfterInMs === 0) {
+            strategyLogger.info(
+              `Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`,
+            );
+            await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });
+            continue retryRequest;
+          }
+
+          if (redirectTo) {
+            strategyLogger.info(
+              `Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`,
+            );
+            request.url = redirectTo;
+            continue retryRequest;
+          }
+        }
+
+        if (responseError) {
+          logger.info(
+            `None of the retry strategies could work with the received error. Throwing it.`,
+          );
+          throw responseError;
+        }
+        if (response) {
+          logger.info(
+            `None of the retry strategies could work with the received response. Returning it.`,
+          );
+          return response;
+        }
+
+        // If all the retries skip and there's no response,
+        // we're still in the retry loop, so a new request will be sent
+        // until `maxRetries` is reached.
+      }
+    },
+  };
 }
diff --git a/src/policies/setClientRequestIdPolicy.ts b/src/policies/setClientRequestIdPolicy.ts
deleted file mode 100644
index a40d4ab..0000000
--- a/src/policies/setClientRequestIdPolicy.ts
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-
-/**
- * The programmatic identifier of the setClientRequestIdPolicy.
- */
-export const setClientRequestIdPolicyName = "setClientRequestIdPolicy";
-
-/**
- * Each PipelineRequest gets a unique id upon creation.
- * This policy passes that unique id along via an HTTP header to enable better
- * telemetry and tracing.
- * @param requestIdHeaderName - The name of the header to pass the request ID to.
- */
-export function setClientRequestIdPolicy(
-  requestIdHeaderName = "x-ms-client-request-id",
-): PipelinePolicy {
-  return {
-    name: setClientRequestIdPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      if (!request.headers.has(requestIdHeaderName)) {
-        request.headers.set(requestIdHeaderName, request.requestId);
-      }
-      return next(request);
-    },
-  };
-}
diff --git a/src/policies/systemErrorRetryPolicy.ts b/src/policies/systemErrorRetryPolicy.ts
index bb25330..4c8bf62 100644
--- a/src/policies/systemErrorRetryPolicy.ts
+++ b/src/policies/systemErrorRetryPolicy.ts
@@ -2,16 +2,14 @@
 // Licensed under the MIT License.
 
 import type { PipelinePolicy } from "../pipeline.js";
-
-import {
-  systemErrorRetryPolicy as tspSystemErrorRetryPolicy,
-  systemErrorRetryPolicyName as tspSystemErrorRetryPolicyName,
-} from "@typespec/ts-http-runtime/internal/policies";
+import { exponentialRetryStrategy } from "../retryStrategies/exponentialRetryStrategy.js";
+import { retryPolicy } from "./retryPolicy.js";
+import { DEFAULT_RETRY_POLICY_COUNT } from "../constants.js";
 
 /**
  * Name of the {@link systemErrorRetryPolicy}
  */
-export const systemErrorRetryPolicyName = tspSystemErrorRetryPolicyName;
+export const systemErrorRetryPolicyName = "systemErrorRetryPolicy";
 
 /**
  * Options that control how to retry failed requests.
@@ -45,5 +43,18 @@ export interface SystemErrorRetryPolicyOptions {
 export function systemErrorRetryPolicy(
   options: SystemErrorRetryPolicyOptions = {},
 ): PipelinePolicy {
-  return tspSystemErrorRetryPolicy(options);
+  return {
+    name: systemErrorRetryPolicyName,
+    sendRequest: retryPolicy(
+      [
+        exponentialRetryStrategy({
+          ...options,
+          ignoreHttpStatusCodes: true,
+        }),
+      ],
+      {
+        maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,
+      },
+    ).sendRequest,
+  };
 }
diff --git a/src/policies/throttlingRetryPolicy.ts b/src/policies/throttlingRetryPolicy.ts
index 9d36e06..a7d0252 100644
--- a/src/policies/throttlingRetryPolicy.ts
+++ b/src/policies/throttlingRetryPolicy.ts
@@ -2,16 +2,14 @@
 // Licensed under the MIT License.
 
 import type { PipelinePolicy } from "../pipeline.js";
-
-import {
-  throttlingRetryPolicyName as tspThrottlingRetryPolicyName,
-  throttlingRetryPolicy as tspThrottlingRetryPolicy,
-} from "@typespec/ts-http-runtime/internal/policies";
+import { throttlingRetryStrategy } from "../retryStrategies/throttlingRetryStrategy.js";
+import { retryPolicy } from "./retryPolicy.js";
+import { DEFAULT_RETRY_POLICY_COUNT } from "../constants.js";
 
 /**
  * Name of the {@link throttlingRetryPolicy}
  */
-export const throttlingRetryPolicyName = tspThrottlingRetryPolicyName;
+export const throttlingRetryPolicyName = "throttlingRetryPolicy";
 
 /**
  * Options that control how to retry failed requests.
@@ -34,5 +32,10 @@ export interface ThrottlingRetryPolicyOptions {
  * @param options - Options that configure retry logic.
  */
 export function throttlingRetryPolicy(options: ThrottlingRetryPolicyOptions = {}): PipelinePolicy {
-  return tspThrottlingRetryPolicy(options);
+  return {
+    name: throttlingRetryPolicyName,
+    sendRequest: retryPolicy([throttlingRetryStrategy()], {
+      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,
+    }).sendRequest,
+  };
 }
diff --git a/src/policies/tlsPolicy.ts b/src/policies/tlsPolicy.ts
index 36dfb26..0e78872 100644
--- a/src/policies/tlsPolicy.ts
+++ b/src/policies/tlsPolicy.ts
@@ -4,19 +4,23 @@
 import type { PipelinePolicy } from "../pipeline.js";
 import type { TlsSettings } from "../interfaces.js";
 
-import {
-  tlsPolicy as tspTlsPolicy,
-  tlsPolicyName as tspTlsPolicyName,
-} from "@typespec/ts-http-runtime/internal/policies";
-
 /**
  * Name of the TLS Policy
  */
-export const tlsPolicyName = tspTlsPolicyName;
+export const tlsPolicyName = "tlsPolicy";
 
 /**
  * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.
  */
 export function tlsPolicy(tlsSettings?: TlsSettings): PipelinePolicy {
-  return tspTlsPolicy(tlsSettings);
+  return {
+    name: tlsPolicyName,
+    sendRequest: async (req, next) => {
+      // Users may define a request tlsSettings, honor those over the client level one
+      if (!req.tlsSettings) {
+        req.tlsSettings = tlsSettings;
+      }
+      return next(req);
+    },
+  };
 }
diff --git a/src/policies/tracingPolicy.ts b/src/policies/tracingPolicy.ts
deleted file mode 100644
index b633c17..0000000
--- a/src/policies/tracingPolicy.ts
+++ /dev/null
@@ -1,174 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import {
-  type TracingClient,
-  type TracingContext,
-  type TracingSpan,
-  createTracingClient,
-} from "@azure/core-tracing";
-import { SDK_VERSION } from "../constants.js";
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-import { getUserAgentValue } from "../util/userAgent.js";
-import { logger } from "../log.js";
-import { getErrorMessage, isError } from "@azure/core-util";
-import { isRestError } from "../restError.js";
-import { Sanitizer } from "@typespec/ts-http-runtime/internal/util";
-
-/**
- * The programmatic identifier of the tracingPolicy.
- */
-export const tracingPolicyName = "tracingPolicy";
-
-/**
- * Options to configure the tracing policy.
- */
-export interface TracingPolicyOptions {
-  /**
-   * String prefix to add to the user agent logged as metadata
-   * on the generated Span.
-   * Defaults to an empty string.
-   */
-  userAgentPrefix?: string;
-  /**
-   * Query string names whose values will be logged when logging is enabled. By default no
-   * query string values are logged.
-   */
-  additionalAllowedQueryParameters?: string[];
-}
-
-/**
- * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
- * that has SpanOptions with a parent.
- * Requests made without a parent Span will not be recorded.
- * @param options - Options to configure the telemetry logged by the tracing policy.
- */
-export function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {
-  const userAgentPromise = getUserAgentValue(options.userAgentPrefix);
-  const sanitizer = new Sanitizer({
-    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
-  });
-  const tracingClient = tryCreateTracingClient();
-
-  return {
-    name: tracingPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      if (!tracingClient) {
-        return next(request);
-      }
-
-      const userAgent = await userAgentPromise;
-
-      const spanAttributes = {
-        "http.url": sanitizer.sanitizeUrl(request.url),
-        "http.method": request.method,
-        "http.user_agent": userAgent,
-        requestId: request.requestId,
-      };
-      if (userAgent) {
-        spanAttributes["http.user_agent"] = userAgent;
-      }
-
-      const { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};
-
-      if (!span || !tracingContext) {
-        return next(request);
-      }
-
-      try {
-        const response = await tracingClient.withContext(tracingContext, next, request);
-        tryProcessResponse(span, response);
-        return response;
-      } catch (err: any) {
-        tryProcessError(span, err);
-        throw err;
-      }
-    },
-  };
-}
-
-function tryCreateTracingClient(): TracingClient | undefined {
-  try {
-    return createTracingClient({
-      namespace: "",
-      packageName: "@azure/core-rest-pipeline",
-      packageVersion: SDK_VERSION,
-    });
-  } catch (e: unknown) {
-    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
-    return undefined;
-  }
-}
-
-function tryCreateSpan(
-  tracingClient: TracingClient,
-  request: PipelineRequest,
-  spanAttributes: Record<string, unknown>,
-): { span: TracingSpan; tracingContext: TracingContext } | undefined {
-  try {
-    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
-    const { span, updatedOptions } = tracingClient.startSpan(
-      `HTTP ${request.method}`,
-      { tracingOptions: request.tracingOptions },
-      {
-        spanKind: "client",
-        spanAttributes,
-      },
-    );
-
-    // If the span is not recording, don't do any more work.
-    if (!span.isRecording()) {
-      span.end();
-      return undefined;
-    }
-
-    // set headers
-    const headers = tracingClient.createRequestHeaders(
-      updatedOptions.tracingOptions.tracingContext,
-    );
-    for (const [key, value] of Object.entries(headers)) {
-      request.headers.set(key, value);
-    }
-    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
-  } catch (e: any) {
-    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
-    return undefined;
-  }
-}
-
-function tryProcessError(span: TracingSpan, error: unknown): void {
-  try {
-    span.setStatus({
-      status: "error",
-      error: isError(error) ? error : undefined,
-    });
-    if (isRestError(error) && error.statusCode) {
-      span.setAttribute("http.status_code", error.statusCode);
-    }
-    span.end();
-  } catch (e: any) {
-    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
-  }
-}
-
-function tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {
-  try {
-    span.setAttribute("http.status_code", response.status);
-    const serviceRequestId = response.headers.get("x-ms-request-id");
-    if (serviceRequestId) {
-      span.setAttribute("serviceRequestId", serviceRequestId);
-    }
-    // Per semantic conventions, only set the status to error if the status code is 4xx or 5xx.
-    // Otherwise, the status MUST remain unset.
-    // https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
-    if (response.status >= 400) {
-      span.setStatus({
-        status: "error",
-      });
-    }
-    span.end();
-  } catch (e: any) {
-    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
-  }
-}
diff --git a/src/policies/wrapAbortSignalLikePolicy.ts b/src/policies/wrapAbortSignalLikePolicy.ts
deleted file mode 100644
index a33b7a0..0000000
--- a/src/policies/wrapAbortSignalLikePolicy.ts
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { type PipelinePolicy } from "../pipeline.js";
-import { wrapAbortSignalLike } from "../util/wrapAbortSignal.js";
-
-export const wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
-
-/**
- * Policy that ensure that any AbortSignalLike is wrapped in a native AbortSignal for processing by the pipeline.
- * Since the ts-http-runtime expects a native AbortSignal, this policy is used to ensure that any AbortSignalLike is wrapped in a native AbortSignal.
- *
- * @returns - created policy
- */
-export function wrapAbortSignalLikePolicy(): PipelinePolicy {
-  return {
-    name: wrapAbortSignalLikePolicyName,
-    sendRequest: async (request, next) => {
-      if (!request.abortSignal) {
-        return next(request);
-      }
-
-      const { abortSignal, cleanup } = wrapAbortSignalLike(request.abortSignal);
-      // eslint-disable-next-line no-param-reassign
-      request.abortSignal = abortSignal;
-      try {
-        return await next(request);
-      } finally {
-        cleanup?.();
-      }
-    },
-  };
-}
diff --git a/src/restError.ts b/src/restError.ts
index 90b5645..722db2a 100644
--- a/src/restError.ts
+++ b/src/restError.ts
@@ -1,13 +1,12 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
+import { isError } from "./util/error.js";
 import type { PipelineRequest, PipelineResponse } from "./interfaces.js";
+import { custom } from "./util/inspect.js";
+import { Sanitizer } from "./util/sanitizer.js";
 
-import type { RestErrorOptions as TspRestErrorOptions } from "@typespec/ts-http-runtime";
-import {
-  RestError as TspRestError,
-  isRestError as tspIsRestError,
-} from "@typespec/ts-http-runtime";
+const errorSanitizer = new Sanitizer();
 
 /**
  * The options supported by RestError.
@@ -72,13 +71,32 @@ export class RestError extends Error {
 
   constructor(message: string, options: RestErrorOptions = {}) {
     super(message);
+    this.name = "RestError";
+    this.code = options.code;
+    this.statusCode = options.statusCode;
 
-    // what is this??
-    // it turns out that you can return from a constructor and it causes
-    // calling `new` to return the value you return.
-    // this lets us wrap the TypeSpec RestError so that calling this constructor will give you the same type of object as calling the TypeSpec one,
-    // even though the constructor signatures (through RestErrorOptions) are slightly different.
-    return new TspRestError(message, options as TspRestErrorOptions);
+    // The request and response may contain sensitive information in the headers or body.
+    // To help prevent this sensitive information being accidentally logged, the request and response
+    // properties are marked as non-enumerable here. This prevents them showing up in the output of
+    // JSON.stringify and console.log.
+    Object.defineProperty(this, "request", { value: options.request, enumerable: false });
+    Object.defineProperty(this, "response", { value: options.response, enumerable: false });
+
+    // Logging method for util.inspect in Node
+    Object.defineProperty(this, custom, {
+      value: () => {
+        // Extract non-enumerable properties and add them back. This is OK since in this output the request and
+        // response get sanitized.
+        return `RestError: ${this.message} \n ${errorSanitizer.sanitize({
+          ...this,
+          request: this.request,
+          response: this.response,
+        })}`;
+      },
+      enumerable: false,
+    });
+
+    Object.setPrototypeOf(this, RestError.prototype);
   }
 }
 
@@ -87,5 +105,8 @@ export class RestError extends Error {
  * @param e - Something caught by a catch clause.
  */
 export function isRestError(e: unknown): e is RestError {
-  return tspIsRestError(e);
+  if (e instanceof RestError) {
+    return true;
+  }
+  return isError(e) && e.name === "RestError";
 }
diff --git a/src/retryStrategies/exponentialRetryStrategy.ts b/src/retryStrategies/exponentialRetryStrategy.ts
new file mode 100644
index 0000000..568e864
--- /dev/null
+++ b/src/retryStrategies/exponentialRetryStrategy.ts
@@ -0,0 +1,104 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { PipelineResponse } from "../interfaces.js";
+import type { RestError } from "../restError.js";
+import { calculateRetryDelay } from "../util/delay.js";
+import type { RetryStrategy } from "./retryStrategy.js";
+import { isThrottlingRetryResponse } from "./throttlingRetryStrategy.js";
+
+// intervals are in milliseconds
+const DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
+const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
+
+/**
+ * A retry strategy that retries with an exponentially increasing delay in these two cases:
+ * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
+ * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).
+ */
+export function exponentialRetryStrategy(
+  options: {
+    /**
+     * The amount of delay in milliseconds between retry attempts. Defaults to 1000
+     * (1 second.) The delay increases exponentially with each retry up to a maximum
+     * specified by maxRetryDelayInMs.
+     */
+    retryDelayInMs?: number;
+
+    /**
+     * The maximum delay in milliseconds allowed before retrying an operation. Defaults
+     * to 64000 (64 seconds).
+     */
+    maxRetryDelayInMs?: number;
+
+    /**
+     * If true it won't retry if it received a system error.
+     */
+    ignoreSystemErrors?: boolean;
+
+    /**
+     * If true it won't retry if it received a non-fatal HTTP status code.
+     */
+    ignoreHttpStatusCodes?: boolean;
+  } = {},
+): RetryStrategy {
+  const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;
+  const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
+
+  return {
+    name: "exponentialRetryStrategy",
+    retry({ retryCount, response, responseError }) {
+      const matchedSystemError = isSystemError(responseError);
+      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
+
+      const isExponential = isExponentialRetryResponse(response);
+      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
+      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
+
+      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
+        return { skipStrategy: true };
+      }
+
+      if (responseError && !matchedSystemError && !isExponential) {
+        return { errorToThrow: responseError };
+      }
+
+      return calculateRetryDelay(retryCount, {
+        retryDelayInMs: retryInterval,
+        maxRetryDelayInMs: maxRetryInterval,
+      });
+    },
+  };
+}
+
+/**
+ * A response is a retry response if it has status codes:
+ * - 408, or
+ * - Greater or equal than 500, except for 501 and 505.
+ */
+export function isExponentialRetryResponse(response?: PipelineResponse): boolean {
+  return Boolean(
+    response &&
+      response.status !== undefined &&
+      (response.status >= 500 || response.status === 408) &&
+      response.status !== 501 &&
+      response.status !== 505,
+  );
+}
+
+/**
+ * Determines whether an error from a pipeline response was triggered in the network layer.
+ */
+export function isSystemError(err?: RestError): boolean {
+  if (!err) {
+    return false;
+  }
+  return (
+    err.code === "ETIMEDOUT" ||
+    err.code === "ESOCKETTIMEDOUT" ||
+    err.code === "ECONNREFUSED" ||
+    err.code === "ECONNRESET" ||
+    err.code === "ENOENT" ||
+    err.code === "ENOTFOUND"
+  );
+}
diff --git a/src/retryStrategies/retryStrategy.ts b/src/retryStrategies/retryStrategy.ts
new file mode 100644
index 0000000..bc11b52
--- /dev/null
+++ b/src/retryStrategies/retryStrategy.ts
@@ -0,0 +1,66 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { TypeSpecRuntimeLogger } from "../logger/logger.js";
+import type { PipelineResponse } from "../interfaces.js";
+import type { RestError } from "../restError.js";
+
+/**
+ * Information provided to the retry strategy about the current progress of the retry policy.
+ */
+export interface RetryInformation {
+  /**
+   * A {@link PipelineResponse}, if the last retry attempt succeeded.
+   */
+  response?: PipelineResponse;
+  /**
+   * A {@link RestError}, if the last retry attempt failed.
+   */
+  responseError?: RestError;
+  /**
+   * Total number of retries so far.
+   */
+  retryCount: number;
+}
+
+/**
+ * Properties that can modify the behavior of the retry policy.
+ */
+export interface RetryModifiers {
+  /**
+   * If true, allows skipping the current strategy from running on the retry policy.
+   */
+  skipStrategy?: boolean;
+  /**
+   * Indicates to retry against this URL.
+   */
+  redirectTo?: string;
+  /**
+   * Controls whether to retry in a given number of milliseconds.
+   * If provided, a new retry will be attempted.
+   */
+  retryAfterInMs?: number;
+  /**
+   * Indicates to throw this error instead of retrying.
+   */
+  errorToThrow?: RestError;
+}
+
+/**
+ * A retry strategy is intended to define whether to retry or not, and how to retry.
+ */
+export interface RetryStrategy {
+  /**
+   * Name of the retry strategy. Used for logging.
+   */
+  name: string;
+  /**
+   * Logger. If it's not provided, a default logger for all retry strategies is used.
+   */
+  logger?: TypeSpecRuntimeLogger;
+  /**
+   * Function that determines how to proceed with the subsequent requests.
+   * @param state - Retry state
+   */
+  retry(state: RetryInformation): RetryModifiers;
+}
diff --git a/src/retryStrategies/throttlingRetryStrategy.ts b/src/retryStrategies/throttlingRetryStrategy.ts
new file mode 100644
index 0000000..d0f7298
--- /dev/null
+++ b/src/retryStrategies/throttlingRetryStrategy.ts
@@ -0,0 +1,79 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { PipelineResponse } from "../interfaces.js";
+import { parseHeaderValueAsNumber } from "../util/helpers.js";
+import type { RetryStrategy } from "./retryStrategy.js";
+
+/**
+ * The header that comes back from services representing
+ * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).
+ */
+const RetryAfterHeader = "Retry-After";
+/**
+ * The headers that come back from services representing
+ * the amount of time (minimum) to wait to retry.
+ *
+ * "retry-after-ms", "x-ms-retry-after-ms" : milliseconds
+ * "Retry-After" : seconds or timestamp
+ */
+const AllRetryAfterHeaders: string[] = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
+
+/**
+ * A response is a throttling retry response if it has a throttling status code (429 or 503),
+ * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
+ *
+ * Returns the `retryAfterInMs` value if the response is a throttling retry response.
+ * If not throttling retry response, returns `undefined`.
+ *
+ * @internal
+ */
+function getRetryAfterInMs(response?: PipelineResponse): number | undefined {
+  if (!(response && [429, 503].includes(response.status))) return undefined;
+  try {
+    // Headers: "retry-after-ms", "x-ms-retry-after-ms", "Retry-After"
+    for (const header of AllRetryAfterHeaders) {
+      const retryAfterValue = parseHeaderValueAsNumber(response, header);
+      if (retryAfterValue === 0 || retryAfterValue) {
+        // "Retry-After" header ==> seconds
+        // "retry-after-ms", "x-ms-retry-after-ms" headers ==> milli-seconds
+        const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
+        return retryAfterValue * multiplyingFactor; // in milli-seconds
+      }
+    }
+
+    // RetryAfterHeader ("Retry-After") has a special case where it might be formatted as a date instead of a number of seconds
+    const retryAfterHeader = response.headers.get(RetryAfterHeader);
+    if (!retryAfterHeader) return;
+
+    const date = Date.parse(retryAfterHeader);
+    const diff = date - Date.now();
+    // negative diff would mean a date in the past, so retry asap with 0 milliseconds
+    return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
+  } catch {
+    return undefined;
+  }
+}
+
+/**
+ * A response is a retry response if it has a throttling status code (429 or 503),
+ * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
+ */
+export function isThrottlingRetryResponse(response?: PipelineResponse): boolean {
+  return Number.isFinite(getRetryAfterInMs(response));
+}
+
+export function throttlingRetryStrategy(): RetryStrategy {
+  return {
+    name: "throttlingRetryStrategy",
+    retry({ response }) {
+      const retryAfterInMs = getRetryAfterInMs(response);
+      if (!Number.isFinite(retryAfterInMs)) {
+        return { skipStrategy: true };
+      }
+      return {
+        retryAfterInMs,
+      };
+    },
+  };
+}
diff --git a/src/tracing/index.ts b/src/tracing/index.ts
deleted file mode 100644
index 8992d7a..0000000
--- a/src/tracing/index.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-export {
-  AddEventOptions,
-  Instrumenter,
-  InstrumenterSpanOptions,
-  OperationTracingOptions,
-  OptionsWithTracingContext,
-  Resolved,
-  SpanStatus,
-  SpanStatusError,
-  SpanStatusSuccess,
-  TracingClient,
-  TracingClientOptions,
-  TracingContext,
-  TracingSpan,
-  TracingSpanKind,
-  TracingSpanLink,
-  TracingSpanOptions,
-} from "./interfaces.js";
-export { useInstrumenter } from "./instrumenter.js";
-export { createTracingClient } from "./tracingClient.js";
diff --git a/src/tracing/instrumenter.ts b/src/tracing/instrumenter.ts
deleted file mode 100644
index 28f5729..0000000
--- a/src/tracing/instrumenter.ts
+++ /dev/null
@@ -1,84 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type {
-  Instrumenter,
-  InstrumenterSpanOptions,
-  TracingContext,
-  TracingSpan,
-} from "./interfaces.js";
-
-import { createTracingContext } from "./tracingContext.js";
-import { state } from "./state.js";
-
-export function createDefaultTracingSpan(): TracingSpan {
-  return {
-    end: () => {
-      // noop
-    },
-    isRecording: () => false,
-    recordException: () => {
-      // noop
-    },
-    setAttribute: () => {
-      // noop
-    },
-    setStatus: () => {
-      // noop
-    },
-    addEvent: () => {
-      // noop
-    },
-  };
-}
-
-export function createDefaultInstrumenter(): Instrumenter {
-  return {
-    createRequestHeaders: (): Record<string, string> => {
-      return {};
-    },
-    parseTraceparentHeader: (): TracingContext | undefined => {
-      return undefined;
-    },
-    startSpan: (
-      _name: string,
-      spanOptions: InstrumenterSpanOptions,
-    ): { span: TracingSpan; tracingContext: TracingContext } => {
-      return {
-        span: createDefaultTracingSpan(),
-        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext }),
-      };
-    },
-    withContext<
-      CallbackArgs extends unknown[],
-      Callback extends (...args: CallbackArgs) => ReturnType<Callback>,
-    >(
-      _context: TracingContext,
-      callback: Callback,
-      ...callbackArgs: CallbackArgs
-    ): ReturnType<Callback> {
-      return callback(...callbackArgs);
-    },
-  };
-}
-
-/**
- * Extends the Azure SDK with support for a given instrumenter implementation.
- *
- * @param instrumenter - The instrumenter implementation to use.
- */
-export function useInstrumenter(instrumenter: Instrumenter): void {
-  state.instrumenterImplementation = instrumenter;
-}
-
-/**
- * Gets the currently set instrumenter, a No-Op instrumenter by default.
- *
- * @returns The currently set instrumenter
- */
-export function getInstrumenter(): Instrumenter {
-  if (!state.instrumenterImplementation) {
-    state.instrumenterImplementation = createDefaultInstrumenter();
-  }
-  return state.instrumenterImplementation;
-}
diff --git a/src/tracing/interfaces.ts b/src/tracing/interfaces.ts
deleted file mode 100644
index 7da11e7..0000000
--- a/src/tracing/interfaces.ts
+++ /dev/null
@@ -1,331 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * A narrower version of TypeScript 4.5's Awaited type which Recursively
- * unwraps the "awaited type", emulating the behavior of `await`.
- */
-export type Resolved<T> = T extends { then(onfulfilled: infer F): any } // `await` only unwraps object types with a callable `then`. Non-object types are not unwrapped
-  ? F extends (value: infer V) => any // if the argument to `then` is callable, extracts the first argument
-    ? Resolved<V> // recursively unwrap the value
-    : never // the argument to `then` was not callable
-  : T; // non-object or non-thenable
-
-/**
- * Represents a client that can integrate with the currently configured {@link Instrumenter}.
- *
- * Create an instance using {@link createTracingClient}.
- */
-export interface TracingClient {
-  /**
-   * Wraps a callback in a tracing span, calls the callback, and closes the span.
-   *
-   * This is the primary interface for using Tracing and will handle error recording as well as setting the status on the span.
-   *
-   * Both synchronous and asynchronous functions will be awaited in order to reflect the result of the callback on the span.
-   *
-   * Example:
-   *
-   * ```ts snippet:ReadmeSampleWithSpanExample
-   * import { createTracingClient } from "@azure/core-tracing";
-   *
-   * const tracingClient = createTracingClient({
-   *   namespace: "test.namespace",
-   *   packageName: "test-package",
-   *   packageVersion: "1.0.0",
-   * });
-   *
-   * const options = {};
-   *
-   * const myOperationResult = await tracingClient.withSpan(
-   *   "myClassName.myOperationName",
-   *   options,
-   *   (updatedOptions) => {
-   *     // Do something with the updated options.
-   *     return "myOperationResult";
-   *   },
-   * );
-   * ```
-   * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
-   * @param operationOptions - The original options passed to the method. The callback will receive these options with the newly created {@link TracingContext}.
-   * @param callback - The callback to be invoked with the updated options and newly created {@link TracingSpan}.
-   */
-  withSpan<
-    Options extends { tracingOptions?: OperationTracingOptions },
-    Callback extends (
-      updatedOptions: Options,
-      span: Omit<TracingSpan, "end">,
-    ) => ReturnType<Callback>,
-  >(
-    name: string,
-    operationOptions: Options,
-    callback: Callback,
-    spanOptions?: TracingSpanOptions,
-  ): Promise<Resolved<ReturnType<Callback>>>;
-  /**
-   * Starts a given span but does not set it as the active span.
-   *
-   * You must end the span using {@link TracingSpan.end}.
-   *
-   * Most of the time you will want to use {@link withSpan} instead.
-   *
-   * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
-   * @param operationOptions - The original operation options.
-   * @param spanOptions - The options to use when creating the span.
-   *
-   * @returns A {@link TracingSpan} and the updated operation options.
-   */
-  startSpan<Options extends { tracingOptions?: OperationTracingOptions }>(
-    name: string,
-    operationOptions?: Options,
-    spanOptions?: TracingSpanOptions,
-  ): {
-    span: TracingSpan;
-    updatedOptions: OptionsWithTracingContext<Options>;
-  };
-  /**
-   * Wraps a callback with an active context and calls the callback.
-   * Depending on the implementation, this may set the globally available active context.
-   *
-   * Useful when you want to leave the boundaries of the SDK (make a request or callback to user code) and are unable to use the {@link withSpan} API.
-   *
-   * @param context - The {@link TracingContext} to use as the active context in the scope of the callback.
-   * @param callback - The callback to be invoked with the given context set as the globally active context.
-   * @param callbackArgs - The callback arguments.
-   */
-  withContext<
-    CallbackArgs extends unknown[],
-    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,
-  >(
-    context: TracingContext,
-    callback: Callback,
-    ...callbackArgs: CallbackArgs
-  ): ReturnType<Callback>;
-
-  /**
-   * Parses a traceparent header value into a {@link TracingSpanContext}.
-   *
-   * @param traceparentHeader - The traceparent header to parse.
-   * @returns An implementation-specific identifier for the span.
-   */
-  parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined;
-
-  /**
-   * Creates a set of request headers to propagate tracing information to a backend.
-   *
-   * @param tracingContext - The context containing the span to propagate.
-   * @returns The set of headers to add to a request.
-   */
-  createRequestHeaders(tracingContext?: TracingContext): Record<string, string>;
-}
-
-/**
- * Options that can be passed to {@link createTracingClient}
- */
-export interface TracingClientOptions {
-  /** The value of the az.namespace tracing attribute on newly created spans. */
-  namespace: string;
-  /** The name of the package invoking this trace. */
-  packageName: string;
-  /** An optional version of the package invoking this trace. */
-  packageVersion?: string;
-}
-
-/** The kind of span. */
-export type TracingSpanKind = "client" | "server" | "producer" | "consumer" | "internal";
-
-/** Options used to configure the newly created span. */
-export interface TracingSpanOptions {
-  /** The kind of span. Implementations should default this to "client". */
-  spanKind?: TracingSpanKind;
-  /** A collection of {@link TracingSpanLink} to link to this span. */
-  spanLinks?: TracingSpanLink[];
-  /** Initial set of attributes to set on a span. */
-  spanAttributes?: { [key: string]: unknown };
-}
-
-/** A pointer from the current {@link TracingSpan} to another span in the same or a different trace. */
-export interface TracingSpanLink {
-  /** The {@link TracingContext} containing the span context to link to. */
-  tracingContext: TracingContext;
-  /** A set of attributes on the link. */
-  attributes?: { [key: string]: unknown };
-}
-
-/**
- * Represents an implementation agnostic instrumenter.
- */
-export interface Instrumenter {
-  /**
-   * Creates a new {@link TracingSpan} with the given name and options and sets it on a new context.
-   * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
-   * @param spanOptions - The options to use when creating the span.
-   *
-   * @returns A {@link TracingSpan} that can be used to end the span, and the context this span has been set on.
-   */
-  startSpan(
-    name: string,
-    spanOptions: InstrumenterSpanOptions,
-  ): { span: TracingSpan; tracingContext: TracingContext };
-  /**
-   * Wraps a callback with an active context and calls the callback.
-   * Depending on the implementation, this may set the globally available active context.
-   *
-   * @param context - The {@link TracingContext} to use as the active context in the scope of the callback.
-   * @param callback - The callback to be invoked with the given context set as the globally active context.
-   * @param callbackArgs - The callback arguments.
-   */
-  withContext<
-    CallbackArgs extends unknown[],
-    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,
-  >(
-    context: TracingContext,
-    callback: Callback,
-    ...callbackArgs: CallbackArgs
-  ): ReturnType<Callback>;
-
-  /**
-   * Provides an implementation-specific method to parse a {@link https://www.w3.org/TR/trace-context/#traceparent-header}
-   * into a {@link TracingSpanContext} which can be used to link non-parented spans together.
-   */
-  parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined;
-  /**
-   * Provides an implementation-specific method to serialize a {@link TracingSpan} to a set of headers.
-   * @param tracingContext - The context containing the span to serialize.
-   */
-  createRequestHeaders(tracingContext?: TracingContext): Record<string, string>;
-}
-
-/**
- * Options passed to {@link Instrumenter.startSpan} as a superset of {@link TracingSpanOptions}.
- */
-export interface InstrumenterSpanOptions extends TracingSpanOptions {
-  /** The name of the package invoking this trace. */
-  packageName: string;
-  /** The version of the package invoking this trace. */
-  packageVersion?: string;
-  /** The current tracing context. Defaults to an implementation-specific "active" context. */
-  tracingContext?: TracingContext;
-}
-
-/**
- * Status representing a successful operation that can be sent to {@link TracingSpan.setStatus}
- */
-export type SpanStatusSuccess = { status: "success" };
-
-/**
- * Status representing an error that can be sent to {@link TracingSpan.setStatus}
- */
-export type SpanStatusError = { status: "error"; error?: Error | string };
-
-/**
- * Represents the statuses that can be passed to {@link TracingSpan.setStatus}.
- *
- * By default, all spans will be created with status "unset".
- */
-export type SpanStatus = SpanStatusSuccess | SpanStatusError;
-
-/**
- * Represents options you can pass to {@link TracingSpan.addEvent}.
- */
-export interface AddEventOptions {
-  /**
-   * A set of attributes to attach to the event.
-   */
-  attributes?: Record<string, unknown>;
-  /**
-   * The start time of the event.
-   */
-  startTime?: Date;
-}
-
-/**
- * Represents an implementation agnostic tracing span.
- */
-export interface TracingSpan {
-  /**
-   * Sets the status of the span. When an error is provided, it will be recorded on the span as well.
-   *
-   * @param status - The {@link SpanStatus} to set on the span.
-   */
-  setStatus(status: SpanStatus): void;
-
-  /**
-   * Sets a given attribute on a span.
-   *
-   * @param name - The attribute's name.
-   * @param value - The attribute's value to set. May be any non-nullish value.
-   */
-  setAttribute(name: string, value: unknown): void;
-
-  /**
-   * Ends the span.
-   */
-  end(): void;
-
-  /**
-   * Records an exception on a {@link TracingSpan} without modifying its status.
-   *
-   * When recording an unhandled exception that should fail the span, please use {@link TracingSpan.setStatus} instead.
-   *
-   * @param exception - The exception to record on the span.
-   *
-   */
-  recordException(exception: Error | string): void;
-
-  /**
-   * Returns true if this {@link TracingSpan} is recording information.
-   *
-   * Depending on the span implementation, this may return false if the span is not being sampled.
-   */
-  isRecording(): boolean;
-
-  /**
-   * Adds an event to the span.
-   */
-  addEvent?(name: string, options?: AddEventOptions): void;
-}
-
-/** An immutable context bag of tracing values for the current operation. */
-export interface TracingContext {
-  /**
-   * Sets a given object on a context.
-   * @param key - The key of the given context value.
-   * @param value - The value to set on the context.
-   *
-   * @returns - A new context with the given value set.
-   */
-  setValue(key: symbol, value: unknown): TracingContext;
-  /**
-   * Gets an object from the context if it exists.
-   * @param key - The key of the given context value.
-   *
-   * @returns - The value of the given context value if it exists, otherwise `undefined`.
-   */
-  getValue(key: symbol): unknown;
-  /**
-   * Deletes an object from the context if it exists.
-   * @param key - The key of the given context value to delete.
-   */
-  deleteValue(key: symbol): TracingContext;
-}
-
-/**
- * Tracing options to set on an operation.
- */
-export interface OperationTracingOptions {
-  /** The context to use for created Tracing Spans. */
-  tracingContext?: TracingContext;
-}
-
-/**
- * A utility type for when we know a TracingContext has been set
- * as part of an operation's options.
- */
-export type OptionsWithTracingContext<
-  Options extends { tracingOptions?: OperationTracingOptions },
-> = Options & {
-  tracingOptions: {
-    tracingContext: TracingContext;
-  };
-};
diff --git a/src/tracing/state-browser.mts b/src/tracing/state-browser.mts
deleted file mode 100644
index 6e56271..0000000
--- a/src/tracing/state-browser.mts
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { Instrumenter } from "./interfaces.js";
-
-/**
- * Browser-only implementation of the module's state. The browser esm variant will not load the commonjs state, so we do not need to share state between the two.
- */
-export const state = {
-  instrumenterImplementation: undefined as Instrumenter | undefined,
-};
diff --git a/src/tracing/state-cjs.cts b/src/tracing/state-cjs.cts
deleted file mode 100644
index 181bfa0..0000000
--- a/src/tracing/state-cjs.cts
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * @internal
- *
- * Holds the singleton instrumenter, to be shared across CJS and ESM imports.
- */
-export const state = {
-  instrumenterImplementation: undefined,
-};
diff --git a/src/tracing/state.ts b/src/tracing/state.ts
deleted file mode 100644
index c7e7a4a..0000000
--- a/src/tracing/state.ts
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { Instrumenter } from "./interfaces.js";
-// @ts-expect-error The recommended approach to sharing module state between ESM and CJS.
-// See https://github.com/isaacs/tshy/blob/main/README.md#module-local-state for additional information.
-import { state as cjsState } from "../commonjs/state.js";
-
-/**
- * Defines the shared state between CJS and ESM by re-exporting the CJS state.
- */
-export const state = cjsState as {
-  instrumenterImplementation: Instrumenter | undefined;
-};
diff --git a/src/tracing/tracingClient.ts b/src/tracing/tracingClient.ts
deleted file mode 100644
index 3e9603d..0000000
--- a/src/tracing/tracingClient.ts
+++ /dev/null
@@ -1,121 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type {
-  OperationTracingOptions,
-  OptionsWithTracingContext,
-  Resolved,
-  TracingClient,
-  TracingClientOptions,
-  TracingContext,
-  TracingSpan,
-  TracingSpanOptions,
-} from "./interfaces.js";
-import { getInstrumenter } from "./instrumenter.js";
-import { knownContextKeys } from "./tracingContext.js";
-
-/**
- * Creates a new tracing client.
- *
- * @param options - Options used to configure the tracing client.
- * @returns - An instance of {@link TracingClient}.
- */
-export function createTracingClient(options: TracingClientOptions): TracingClient {
-  const { namespace, packageName, packageVersion } = options;
-
-  function startSpan<Options extends { tracingOptions?: OperationTracingOptions }>(
-    name: string,
-    operationOptions?: Options,
-    spanOptions?: TracingSpanOptions,
-  ): {
-    span: TracingSpan;
-    updatedOptions: OptionsWithTracingContext<Options>;
-  } {
-    const startSpanResult = getInstrumenter().startSpan(name, {
-      ...spanOptions,
-      packageName: packageName,
-      packageVersion: packageVersion,
-      tracingContext: operationOptions?.tracingOptions?.tracingContext,
-    });
-    let tracingContext = startSpanResult.tracingContext;
-    const span = startSpanResult.span;
-    if (!tracingContext.getValue(knownContextKeys.namespace)) {
-      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
-    }
-    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
-    const updatedOptions: OptionsWithTracingContext<Options> = Object.assign({}, operationOptions, {
-      tracingOptions: { ...operationOptions?.tracingOptions, tracingContext },
-    });
-
-    return {
-      span,
-      updatedOptions,
-    };
-  }
-
-  async function withSpan<
-    Options extends { tracingOptions?: OperationTracingOptions },
-    Callback extends (
-      updatedOptions: Options,
-      span: Omit<TracingSpan, "end">,
-    ) => ReturnType<Callback>,
-  >(
-    name: string,
-    operationOptions: Options,
-    callback: Callback,
-    spanOptions?: TracingSpanOptions,
-  ): Promise<Resolved<ReturnType<Callback>>> {
-    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
-    try {
-      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () =>
-        Promise.resolve(callback(updatedOptions, span)),
-      );
-      span.setStatus({ status: "success" });
-      return result as ReturnType<typeof withSpan>;
-    } catch (err: any) {
-      span.setStatus({ status: "error", error: err });
-      throw err;
-    } finally {
-      span.end();
-    }
-  }
-
-  function withContext<
-    CallbackArgs extends unknown[],
-    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,
-  >(
-    context: TracingContext,
-    callback: Callback,
-    ...callbackArgs: CallbackArgs
-  ): ReturnType<Callback> {
-    return getInstrumenter().withContext(context, callback, ...callbackArgs);
-  }
-
-  /**
-   * Parses a traceparent header value into a span identifier.
-   *
-   * @param traceparentHeader - The traceparent header to parse.
-   * @returns An implementation-specific identifier for the span.
-   */
-  function parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined {
-    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
-  }
-
-  /**
-   * Creates a set of request headers to propagate tracing information to a backend.
-   *
-   * @param tracingContext - The context containing the span to serialize.
-   * @returns The set of headers to add to a request.
-   */
-  function createRequestHeaders(tracingContext?: TracingContext): Record<string, string> {
-    return getInstrumenter().createRequestHeaders(tracingContext);
-  }
-
-  return {
-    startSpan,
-    withSpan,
-    withContext,
-    parseTraceparentHeader,
-    createRequestHeaders,
-  };
-}
diff --git a/src/tracing/tracingContext.ts b/src/tracing/tracingContext.ts
deleted file mode 100644
index 84999ab..0000000
--- a/src/tracing/tracingContext.ts
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { TracingContext, TracingSpan } from "./interfaces.js";
-
-/** @internal */
-export const knownContextKeys = {
-  span: Symbol.for("@azure/core-tracing span"),
-  namespace: Symbol.for("@azure/core-tracing namespace"),
-};
-
-/**
- * Creates a new {@link TracingContext} with the given options.
- * @param options - A set of known keys that may be set on the context.
- * @returns A new {@link TracingContext} with the given options.
- *
- * @internal
- */
-export function createTracingContext(options: CreateTracingContextOptions = {}): TracingContext {
-  let context: TracingContext = new TracingContextImpl(options.parentContext);
-  if (options.span) {
-    context = context.setValue(knownContextKeys.span, options.span);
-  }
-  if (options.namespace) {
-    context = context.setValue(knownContextKeys.namespace, options.namespace);
-  }
-  return context;
-}
-
-/** @internal */
-export class TracingContextImpl implements TracingContext {
-  private _contextMap: Map<symbol, unknown>;
-  constructor(initialContext?: TracingContext) {
-    this._contextMap =
-      initialContext instanceof TracingContextImpl
-        ? new Map<symbol, unknown>(initialContext._contextMap)
-        : new Map();
-  }
-
-  setValue(key: symbol, value: unknown): TracingContext {
-    const newContext = new TracingContextImpl(this);
-    newContext._contextMap.set(key, value);
-    return newContext;
-  }
-
-  getValue(key: symbol): unknown {
-    return this._contextMap.get(key);
-  }
-
-  deleteValue(key: symbol): TracingContext {
-    const newContext = new TracingContextImpl(this);
-    newContext._contextMap.delete(key);
-    return newContext;
-  }
-}
-
-/**
- * Represents a set of items that can be set when creating a new {@link TracingContext}.
- */
-export interface CreateTracingContextOptions {
-  /** The {@link parentContext} - the newly created context will contain all the values of the parent context unless overridden. */
-  parentContext?: TracingContext;
-  /** An initial span to set on the context. */
-  span?: TracingSpan;
-  /** The namespace to set on any child spans. */
-  namespace?: string;
-}
diff --git a/src/util/aborterUtils.ts b/src/util/aborterUtils.ts
deleted file mode 100644
index ce29be9..0000000
--- a/src/util/aborterUtils.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AbortSignalLike } from "@azure/abort-controller";
-
-/**
- * Options related to abort controller.
- */
-export interface AbortOptions {
-  /**
-   * The abortSignal associated with containing operation.
-   */
-  abortSignal?: AbortSignalLike;
-  /**
-   * The abort error message associated with containing operation.
-   */
-  abortErrorMsg?: string;
-}
-
-/**
- * Represents a function that returns a promise that can be aborted.
- */
-export type AbortablePromiseBuilder<T> = (abortOptions: {
-  abortSignal?: AbortSignalLike;
-}) => Promise<T>;
-
-/**
- * promise.race() wrapper that aborts rest of promises as soon as the first promise settles.
- */
-export async function cancelablePromiseRace<T extends unknown[]>(
-  abortablePromiseBuilders: AbortablePromiseBuilder<T[number]>[],
-  options?: { abortSignal?: AbortSignalLike },
-): Promise<T[number]> {
-  const aborter = new AbortController();
-  function abortHandler(): void {
-    aborter.abort();
-  }
-  options?.abortSignal?.addEventListener("abort", abortHandler);
-  try {
-    return await Promise.race(
-      abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })),
-    );
-  } finally {
-    aborter.abort();
-    options?.abortSignal?.removeEventListener("abort", abortHandler);
-  }
-}
diff --git a/src/util/bytesEncoding-browser.mts b/src/util/bytesEncoding-browser.mts
new file mode 100644
index 0000000..b01f15e
--- /dev/null
+++ b/src/util/bytesEncoding-browser.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./bytesEncoding.common.js";
diff --git a/src/util/bytesEncoding-react-native.mts b/src/util/bytesEncoding-react-native.mts
new file mode 100644
index 0000000..b01f15e
--- /dev/null
+++ b/src/util/bytesEncoding-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./bytesEncoding.common.js";
diff --git a/src/util/bytesEncoding.common.ts b/src/util/bytesEncoding.common.ts
new file mode 100644
index 0000000..2f8191a
--- /dev/null
+++ b/src/util/bytesEncoding.common.ts
@@ -0,0 +1,131 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+declare global {
+  // stub these out for the browser
+  function btoa(input: string): string;
+  function atob(input: string): string;
+}
+
+/** The supported character encoding type */
+export type EncodingType = "utf-8" | "base64" | "base64url" | "hex";
+
+/**
+ * The helper that transforms bytes with specific character encoding into string
+ * @param bytes - the uint8array bytes
+ * @param format - the format we use to encode the byte
+ * @returns a string of the encoded string
+ */
+export function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string {
+  switch (format) {
+    case "utf-8":
+      return uint8ArrayToUtf8String(bytes);
+    case "base64":
+      return uint8ArrayToBase64(bytes);
+    case "base64url":
+      return uint8ArrayToBase64Url(bytes);
+    case "hex":
+      return uint8ArrayToHexString(bytes);
+  }
+}
+
+/**
+ * The helper that transforms string to specific character encoded bytes array.
+ * @param value - the string to be converted
+ * @param format - the format we use to decode the value
+ * @returns a uint8array
+ */
+export function stringToUint8Array(value: string, format: EncodingType): Uint8Array {
+  switch (format) {
+    case "utf-8":
+      return utf8StringToUint8Array(value);
+    case "base64":
+      return base64ToUint8Array(value);
+    case "base64url":
+      return base64UrlToUint8Array(value);
+    case "hex":
+      return hexStringToUint8Array(value);
+  }
+}
+
+/**
+ * Decodes a Uint8Array into a Base64 string.
+ * @internal
+ */
+export function uint8ArrayToBase64(bytes: Uint8Array): string {
+  return btoa([...bytes].map((x) => String.fromCharCode(x)).join(""));
+}
+
+/**
+ * Decodes a Uint8Array into a Base64Url string.
+ * @internal
+ */
+export function uint8ArrayToBase64Url(bytes: Uint8Array): string {
+  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
+}
+
+/**
+ * Decodes a Uint8Array into a javascript string.
+ * @internal
+ */
+export function uint8ArrayToUtf8String(bytes: Uint8Array): string {
+  const decoder = new TextDecoder();
+  const dataString = decoder.decode(bytes);
+  return dataString;
+}
+
+/**
+ * Decodes a Uint8Array into a hex string
+ * @internal
+ */
+export function uint8ArrayToHexString(bytes: Uint8Array): string {
+  return [...bytes].map((x) => x.toString(16).padStart(2, "0")).join("");
+}
+
+/**
+ * Encodes a JavaScript string into a Uint8Array.
+ * @internal
+ */
+export function utf8StringToUint8Array(value: string): Uint8Array {
+  return new TextEncoder().encode(value);
+}
+
+/**
+ * Encodes a Base64 string into a Uint8Array.
+ * @internal
+ */
+export function base64ToUint8Array(value: string): Uint8Array {
+  return new Uint8Array([...atob(value)].map((x) => x.charCodeAt(0)));
+}
+
+/**
+ * Encodes a Base64Url string into a Uint8Array.
+ * @internal
+ */
+export function base64UrlToUint8Array(value: string): Uint8Array {
+  const base64String = value.replace(/-/g, "+").replace(/_/g, "/");
+  return base64ToUint8Array(base64String);
+}
+
+const hexDigits = new Set("0123456789abcdefABCDEF");
+
+/**
+ * Encodes a hex string into a Uint8Array
+ * @internal
+ */
+export function hexStringToUint8Array(value: string): Uint8Array {
+  // If value has odd length, the last character will be ignored, consistent with NodeJS Buffer behavior
+  const bytes = new Uint8Array(value.length / 2);
+  for (let i = 0; i < value.length / 2; ++i) {
+    const highNibble = value[2 * i];
+    const lowNibble = value[2 * i + 1];
+    if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {
+      // Replicate Node Buffer behavior by exiting early when we encounter an invalid byte
+      return bytes.slice(0, i);
+    }
+
+    bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);
+  }
+
+  return bytes;
+}
diff --git a/src/util/bytesEncoding.ts b/src/util/bytesEncoding.ts
new file mode 100644
index 0000000..b6507af
--- /dev/null
+++ b/src/util/bytesEncoding.ts
@@ -0,0 +1,25 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/** The supported character encoding type */
+export type EncodingType = "utf-8" | "base64" | "base64url" | "hex";
+
+/**
+ * The helper that transforms bytes with specific character encoding into string
+ * @param bytes - the uint8array bytes
+ * @param format - the format we use to encode the byte
+ * @returns a string of the encoded string
+ */
+export function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string {
+  return Buffer.from(bytes).toString(format);
+}
+
+/**
+ * The helper that transforms string to specific character encoded bytes array.
+ * @param value - the string to be converted
+ * @param format - the format we use to decode the value
+ * @returns a uint8array
+ */
+export function stringToUint8Array(value: string, format: EncodingType): Uint8Array {
+  return Buffer.from(value, format);
+}
diff --git a/src/util/checkEnvironment.ts b/src/util/checkEnvironment.ts
new file mode 100644
index 0000000..bc38b5d
--- /dev/null
+++ b/src/util/checkEnvironment.ts
@@ -0,0 +1,84 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+interface Window {
+  document: unknown;
+}
+
+interface DedicatedWorkerGlobalScope {
+  constructor: {
+    name: string;
+  };
+
+  importScripts: (...paths: string[]) => void;
+}
+
+interface Navigator {
+  product: string;
+}
+
+interface DenoGlobal {
+  version: {
+    deno: string;
+  };
+}
+
+interface BunGlobal {
+  version: string;
+}
+
+// eslint-disable-next-line @azure/azure-sdk/ts-no-window
+declare const window: Window;
+declare const self: DedicatedWorkerGlobalScope;
+declare const Deno: DenoGlobal;
+declare const Bun: BunGlobal;
+declare const navigator: Navigator;
+
+/**
+ * A constant that indicates whether the environment the code is running is a Web Browser.
+ */
+// eslint-disable-next-line @azure/azure-sdk/ts-no-window
+export const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
+
+/**
+ * A constant that indicates whether the environment the code is running is a Web Worker.
+ */
+export const isWebWorker =
+  typeof self === "object" &&
+  typeof self?.importScripts === "function" &&
+  (self.constructor?.name === "DedicatedWorkerGlobalScope" ||
+    self.constructor?.name === "ServiceWorkerGlobalScope" ||
+    self.constructor?.name === "SharedWorkerGlobalScope");
+
+/**
+ * A constant that indicates whether the environment the code is running is Deno.
+ */
+export const isDeno =
+  typeof Deno !== "undefined" &&
+  typeof Deno.version !== "undefined" &&
+  typeof Deno.version.deno !== "undefined";
+
+/**
+ * A constant that indicates whether the environment the code is running is Bun.sh.
+ */
+export const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
+
+/**
+ * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
+ */
+export const isNodeLike =
+  typeof globalThis.process !== "undefined" &&
+  Boolean(globalThis.process.version) &&
+  Boolean(globalThis.process.versions?.node);
+
+/**
+ * A constant that indicates whether the environment the code is running is Node.JS.
+ */
+export const isNodeRuntime = isNodeLike && !isBun && !isDeno;
+
+/**
+ * A constant that indicates whether the environment the code is running is in React-Native.
+ */
+// https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
+export const isReactNative =
+  typeof navigator !== "undefined" && navigator?.product === "ReactNative";
diff --git a/src/util/concat-browser.mts b/src/util/concat-browser.mts
new file mode 100644
index 0000000..83a8af3
--- /dev/null
+++ b/src/util/concat-browser.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./concat.common.js";
diff --git a/src/util/concat-react-native.mts b/src/util/concat-react-native.mts
new file mode 100644
index 0000000..83a8af3
--- /dev/null
+++ b/src/util/concat-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./concat.common.js";
diff --git a/src/util/concat.common.ts b/src/util/concat.common.ts
new file mode 100644
index 0000000..44a4962
--- /dev/null
+++ b/src/util/concat.common.ts
@@ -0,0 +1,55 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { isWebReadableStream } from "./typeGuards.js";
+
+/**
+ * Drain the content of the given ReadableStream into a Blob.
+ * The blob's content may end up in memory or on disk dependent on size.
+ */
+function drain(stream: ReadableStream<Uint8Array>): Promise<Blob> {
+  return new Response(stream).blob();
+}
+
+async function toBlobPart(
+  source: ReadableStream<Uint8Array> | Blob | Uint8Array,
+): Promise<BlobPart> {
+  if (source instanceof Blob || source instanceof Uint8Array) {
+    return source;
+  }
+
+  if (isWebReadableStream(source)) {
+    return drain(source);
+  } else {
+    throw new Error(
+      "Unsupported source type. Only Blob, Uint8Array, and ReadableStream are supported in browser.",
+    );
+  }
+}
+
+/**
+ * Accepted binary data types for concat
+ *
+ * @internal
+ */
+type ConcatSource = ReadableStream<Uint8Array> | Blob | Uint8Array;
+
+/**
+ * Utility function that concatenates a set of binary inputs into one combined output.
+ *
+ * @param sources - array of sources for the concatenation
+ * @returns - in Node, a (() =\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.
+ *           In browser, returns a `Blob` representing all the concatenated inputs.
+ *
+ * @internal
+ */
+export async function concat(
+  sources: (ConcatSource | (() => ConcatSource))[],
+): Promise<(() => NodeJS.ReadableStream) | Blob> {
+  const parts = [];
+  for (const source of sources) {
+    parts.push(await toBlobPart(typeof source === "function" ? source() : source));
+  }
+
+  return new Blob(parts);
+}
diff --git a/src/util/concat.ts b/src/util/concat.ts
new file mode 100644
index 0000000..4177903
--- /dev/null
+++ b/src/util/concat.ts
@@ -0,0 +1,91 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { Readable } from "stream";
+import type { ReadableStream as AsyncIterableReadableStream } from "stream/web";
+import { isBlob } from "./typeGuards.js";
+
+async function* streamAsyncIterator(
+  this: ReadableStream<Uint8Array>,
+): AsyncIterableIterator<Uint8Array> {
+  const reader = this.getReader();
+  try {
+    while (true) {
+      const { done, value } = await reader.read();
+      if (done) {
+        return;
+      }
+
+      yield value;
+    }
+  } finally {
+    reader.releaseLock();
+  }
+}
+
+function makeAsyncIterable<T>(webStream: any): asserts webStream is AsyncIterableReadableStream<T> {
+  if (!webStream[Symbol.asyncIterator]) {
+    webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
+  }
+
+  if (!webStream.values) {
+    webStream.values = streamAsyncIterator.bind(webStream);
+  }
+}
+
+function ensureNodeStream(
+  stream: ReadableStream<Uint8Array> | NodeJS.ReadableStream,
+): NodeJS.ReadableStream {
+  if (stream instanceof ReadableStream) {
+    makeAsyncIterable<Uint8Array>(stream);
+    return Readable.fromWeb(stream);
+  } else {
+    return stream;
+  }
+}
+
+function toStream(
+  source: ReadableStream<Uint8Array> | NodeJS.ReadableStream | Uint8Array | Blob,
+): NodeJS.ReadableStream {
+  if (source instanceof Uint8Array) {
+    return Readable.from(Buffer.from(source));
+  } else if (isBlob(source)) {
+    return toStream(source);
+  } else {
+    return ensureNodeStream(source);
+  }
+}
+
+/**
+ * Accepted binary data types for concat
+ *
+ * @internal
+ */
+export type ConcatSource = ReadableStream<Uint8Array> | NodeJS.ReadableStream | Uint8Array | Blob;
+
+/**
+ * Utility function that concatenates a set of binary inputs into one combined output.
+ *
+ * @param sources - array of sources for the concatenation
+ * @returns - in Node, a (() =\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.
+ *           In browser, returns a `Blob` representing all the concatenated inputs.
+ *
+ * @internal
+ */
+export async function concat(
+  sources: (ConcatSource | (() => ConcatSource))[],
+): Promise<(() => NodeJS.ReadableStream) | Blob> {
+  return function () {
+    const streams = sources.map((x) => (typeof x === "function" ? x() : x)).map(toStream);
+
+    return Readable.from(
+      (async function* () {
+        for (const stream of streams as NodeJS.ReadableStream[]) {
+          for await (const chunk of stream) {
+            yield chunk;
+          }
+        }
+      })(),
+    );
+  };
+}
diff --git a/src/util/createAbortablePromise.ts b/src/util/createAbortablePromise.ts
deleted file mode 100644
index 25cf55a..0000000
--- a/src/util/createAbortablePromise.ts
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { AbortError } from "@azure/abort-controller";
-import type { AbortOptions } from "./aborterUtils.js";
-
-/**
- * Options for the createAbortablePromise function.
- */
-export interface CreateAbortablePromiseOptions extends AbortOptions {
-  /** A function to be called if the promise was aborted */
-  cleanupBeforeAbort?: () => void;
-}
-
-/**
- * Creates an abortable promise.
- * @param buildPromise - A function that takes the resolve and reject functions as parameters.
- * @param options - The options for the abortable promise.
- * @returns A promise that can be aborted.
- */
-export function createAbortablePromise<T>(
-  buildPromise: (
-    resolve: (value: T | PromiseLike<T>) => void,
-    reject: (reason?: any) => void,
-  ) => void,
-  options?: CreateAbortablePromiseOptions,
-): Promise<T> {
-  const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};
-  return new Promise((resolve, reject) => {
-    function rejectOnAbort(): void {
-      reject(new AbortError(abortErrorMsg ?? "The operation was aborted."));
-    }
-    function removeListeners(): void {
-      abortSignal?.removeEventListener("abort", onAbort);
-    }
-    function onAbort(): void {
-      cleanupBeforeAbort?.();
-      removeListeners();
-      rejectOnAbort();
-    }
-    if (abortSignal?.aborted) {
-      return rejectOnAbort();
-    }
-    try {
-      buildPromise(
-        (x) => {
-          removeListeners();
-          resolve(x);
-        },
-        (x) => {
-          removeListeners();
-          reject(x);
-        },
-      );
-    } catch (err) {
-      reject(err);
-    }
-    abortSignal?.addEventListener("abort", onAbort);
-  });
-}
diff --git a/src/util/delay.ts b/src/util/delay.ts
index ab8ae56..1003a96 100644
--- a/src/util/delay.ts
+++ b/src/util/delay.ts
@@ -1,37 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { AbortOptions } from "./aborterUtils.js";
-import { createAbortablePromise } from "./createAbortablePromise.js";
-import { getRandomIntegerInclusive } from "@typespec/ts-http-runtime/internal/util";
-
-const StandardAbortMessage = "The delay was aborted.";
-
-/**
- * Options for support abort functionality for the delay method
- */
-export interface DelayOptions extends AbortOptions {}
-
-/**
- * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
- * @param timeInMs - The number of milliseconds to be delayed.
- * @param options - The options for delay - currently abort options
- * @returns Promise that is resolved after timeInMs
- */
-export function delay(timeInMs: number, options?: DelayOptions): Promise<void> {
-  let token: ReturnType<typeof setTimeout>;
-  const { abortSignal, abortErrorMsg } = options ?? {};
-  return createAbortablePromise(
-    (resolve) => {
-      token = setTimeout(resolve, timeInMs);
-    },
-    {
-      cleanupBeforeAbort: () => clearTimeout(token),
-      abortSignal,
-      abortErrorMsg: abortErrorMsg ?? StandardAbortMessage,
-    },
-  );
-}
+import { getRandomIntegerInclusive } from "./random.js";
 
 /**
  * Calculates the delay interval for retry attempts using exponential delay with jitter.
diff --git a/src/util/error.ts b/src/util/error.ts
index 508e2d5..34ec31c 100644
--- a/src/util/error.ts
+++ b/src/util/error.ts
@@ -1,28 +1,17 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { isError } from "@typespec/ts-http-runtime/internal/util";
+import { isObject } from "./object.js";
 
 /**
- * Given what is thought to be an error object, return the message if possible.
- * If the message is missing, returns a stringified version of the input.
- * @param e - Something thrown from a try block
- * @returns The error message or a string of the input
+ * Typeguard for an error object shape (has name and message)
+ * @param e - Something caught by a catch clause.
  */
-export function getErrorMessage(e: unknown): string {
-  if (isError(e)) {
-    return e.message;
-  } else {
-    let stringified: string;
-    try {
-      if (typeof e === "object" && e) {
-        stringified = JSON.stringify(e);
-      } else {
-        stringified = String(e);
-      }
-    } catch (err: any) {
-      stringified = "[unable to stringify input]";
-    }
-    return `Unknown error ${stringified}`;
+export function isError(e: unknown): e is Error {
+  if (isObject(e)) {
+    const hasName = typeof e.name === "string";
+    const hasMessage = typeof e.message === "string";
+    return hasName && hasMessage;
   }
+  return false;
 }
diff --git a/src/util/file.ts b/src/util/file.ts
deleted file mode 100644
index 02ba689..0000000
--- a/src/util/file.ts
+++ /dev/null
@@ -1,180 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { isNodeLike } from "@azure/core-util";
-
-function isNodeReadableStream(x: unknown): x is NodeJS.ReadableStream {
-  return Boolean(x && typeof (x as NodeJS.ReadableStream)["pipe"] === "function");
-}
-
-/**
- * Options passed into createFile specifying metadata about the file.
- */
-export interface CreateFileOptions {
-  /**
-   * The MIME type of the file.
-   */
-  type?: string;
-
-  /**
-   * Last modified time of the file as a UNIX timestamp.
-   * This will default to the current date.
-   */
-  lastModified?: number;
-
-  /**
-   * relative path of this file when uploading a directory.
-   */
-  webkitRelativePath?: string;
-}
-
-/**
- * Extra options for createFile when a stream is being passed in.
- */
-export interface CreateFileFromStreamOptions extends CreateFileOptions {
-  /**
-   * Size of the file represented by the stream in bytes.
-   *
-   * This will be used by the pipeline when calculating the Content-Length header
-   * for the overall request.
-   */
-  size?: number;
-}
-
-const unimplementedMethods = {
-  arrayBuffer: () => {
-    throw new Error("Not implemented");
-  },
-  bytes: () => {
-    throw new Error("Not implemented");
-  },
-  slice: () => {
-    throw new Error("Not implemented");
-  },
-  text: () => {
-    throw new Error("Not implemented");
-  },
-};
-
-/**
- * Private symbol used as key on objects created using createFile containing the
- * original source of the file object.
- *
- * This is used in Node to access the original Node stream without using Blob#stream, which
- * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and
- * Readable#to/fromWeb in Node versions we support:
- * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)
- * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)
- *
- * Once these versions are no longer supported, we may be able to stop doing this.
- *
- * @internal
- */
-const rawContent: unique symbol = Symbol("rawContent");
-
-/**
- * Type signature of a blob-like object with a raw content property.
- */
-export interface RawContent extends Blob {
-  [rawContent](): Uint8Array | NodeJS.ReadableStream | ReadableStream<Uint8Array>;
-}
-
-/**
- * Type guard to check if a given object is a blob-like object with a raw content property.
- */
-export function hasRawContent(x: unknown): x is RawContent {
-  return typeof (x as RawContent)[rawContent] === "function";
-}
-
-/**
- * Extract the raw content from a given blob-like object. If the input was created using createFile
- * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.
- * For true instances of Blob and File, returns the actual blob.
- *
- * @internal
- */
-export function getRawContent(
-  blob: Blob,
-): Blob | NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array {
-  if (hasRawContent(blob)) {
-    return blob[rawContent]();
-  } else {
-    return blob;
-  }
-}
-
-/**
- * Create an object that implements the File interface. This object is intended to be
- * passed into RequestBodyType.formData, and is not guaranteed to work as expected in
- * other situations.
- *
- * Use this function to:
- * - Create a File object for use in RequestBodyType.formData in environments where the
- *   global File object is unavailable.
- * - Create a File-like object from a readable stream without reading the stream into memory.
- *
- * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is
- *                  passed in a request's form data map, the stream will not be read into memory
- *                  and instead will be streamed when the request is made. In the event of a retry, the
- *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.
- * @param name - the name of the file.
- * @param options - optional metadata about the file, e.g. file name, file size, MIME type.
- */
-export function createFileFromStream(
-  stream: () => ReadableStream<Uint8Array> | NodeJS.ReadableStream,
-  name: string,
-  options: CreateFileFromStreamOptions = {},
-): File {
-  return {
-    ...unimplementedMethods,
-    type: options.type ?? "",
-    lastModified: options.lastModified ?? new Date().getTime(),
-    webkitRelativePath: options.webkitRelativePath ?? "",
-    size: options.size ?? -1,
-    name,
-    stream: () => {
-      const s = stream();
-      if (isNodeReadableStream(s)) {
-        throw new Error(
-          "Not supported: a Node stream was provided as input to createFileFromStream.",
-        );
-      }
-
-      return s;
-    },
-    [rawContent]: stream,
-  } as File & RawContent;
-}
-
-/**
- * Create an object that implements the File interface. This object is intended to be
- * passed into RequestBodyType.formData, and is not guaranteed to work as expected in
- * other situations.
- *
- * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.
- *
- * @param content - the content of the file as a Uint8Array in memory.
- * @param name - the name of the file.
- * @param options - optional metadata about the file, e.g. file name, file size, MIME type.
- */
-export function createFile(
-  content: Uint8Array,
-  name: string,
-  options: CreateFileOptions = {},
-): File {
-  if (isNodeLike) {
-    return {
-      ...unimplementedMethods,
-      type: options.type ?? "",
-      lastModified: options.lastModified ?? new Date().getTime(),
-      webkitRelativePath: options.webkitRelativePath ?? "",
-      size: content.byteLength,
-      name,
-      arrayBuffer: async () => content.buffer,
-      stream: () => new Blob([content]).stream(),
-      [rawContent]: () => content,
-    } as File & RawContent;
-  } else {
-    return new File([content], name, options);
-  }
-}
diff --git a/src/util/helpers.ts b/src/util/helpers.ts
new file mode 100644
index 0000000..a5b7c9d
--- /dev/null
+++ b/src/util/helpers.ts
@@ -0,0 +1,78 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { AbortError } from "../abort-controller/AbortError.js";
+import type { PipelineResponse } from "../interfaces.js";
+
+const StandardAbortMessage = "The operation was aborted.";
+
+/**
+ * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.
+ * @param delayInMs - The number of milliseconds to be delayed.
+ * @param value - The value to be resolved with after a timeout of t milliseconds.
+ * @param options - The options for delay - currently abort options
+ *                  - abortSignal - The abortSignal associated with containing operation.
+ *                  - abortErrorMsg - The abort error message associated with containing operation.
+ * @returns Resolved promise
+ */
+export function delay<T>(
+  delayInMs: number,
+  value?: T,
+  options?: {
+    abortSignal?: AbortSignal;
+    abortErrorMsg?: string;
+  },
+): Promise<T | void> {
+  return new Promise((resolve, reject) => {
+    let timer: ReturnType<typeof setTimeout> | undefined = undefined;
+    let onAborted: (() => void) | undefined = undefined;
+
+    const rejectOnAbort = (): void => {
+      return reject(
+        new AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage),
+      );
+    };
+
+    const removeListeners = (): void => {
+      if (options?.abortSignal && onAborted) {
+        options.abortSignal.removeEventListener("abort", onAborted);
+      }
+    };
+
+    onAborted = (): void => {
+      if (timer) {
+        clearTimeout(timer);
+      }
+      removeListeners();
+      return rejectOnAbort();
+    };
+
+    if (options?.abortSignal && options.abortSignal.aborted) {
+      return rejectOnAbort();
+    }
+
+    timer = setTimeout(() => {
+      removeListeners();
+      resolve(value);
+    }, delayInMs);
+
+    if (options?.abortSignal) {
+      options.abortSignal.addEventListener("abort", onAborted);
+    }
+  });
+}
+
+/**
+ * @internal
+ * @returns the parsed value or undefined if the parsed value is invalid.
+ */
+export function parseHeaderValueAsNumber(
+  response: PipelineResponse,
+  headerName: string,
+): number | undefined {
+  const value = response.headers.get(headerName);
+  if (!value) return;
+  const valueAsNum = Number(value);
+  if (Number.isNaN(valueAsNum)) return;
+  return valueAsNum;
+}
diff --git a/src/util/index.ts b/src/util/index.ts
deleted file mode 100644
index abfafb3..0000000
--- a/src/util/index.ts
+++ /dev/null
@@ -1,186 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import * as tspRuntime from "@typespec/ts-http-runtime/internal/util";
-
-export {
-  type AbortOptions,
-  type AbortablePromiseBuilder,
-  cancelablePromiseRace,
-} from "./aborterUtils.js";
-export {
-  type CreateAbortablePromiseOptions,
-  createAbortablePromise,
-} from "./createAbortablePromise.js";
-export { type DelayOptions, delay } from "./delay.js";
-export { getErrorMessage } from "./error.js";
-export { isDefined, isObjectWithProperties, objectHasProperty } from "./typeGuards.js";
-
-/**
- * Calculates the delay interval for retry attempts using exponential delay with jitter.
- *
- * @param retryAttempt - The current retry attempt number.
- *
- * @param config - The exponential retry configuration.
- *
- * @returns An object containing the calculated retry delay.
- */
-export function calculateRetryDelay(
-  retryAttempt: number,
-  config: {
-    retryDelayInMs: number;
-    maxRetryDelayInMs: number;
-  },
-): {
-  retryAfterInMs: number;
-} {
-  return tspRuntime.calculateRetryDelay(retryAttempt, config);
-}
-
-/**
- * Generates a SHA-256 hash.
- *
- * @param content - The data to be included in the hash.
- *
- * @param encoding - The textual encoding to use for the returned hash.
- */
-export function computeSha256Hash(content: string, encoding: "base64" | "hex"): Promise<string> {
-  return tspRuntime.computeSha256Hash(content, encoding);
-}
-
-/**
- * Generates a SHA-256 HMAC signature.
- *
- * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
- *
- * @param stringToSign - The data to be signed.
- *
- * @param encoding - The textual encoding to use for the returned HMAC digest.
- */
-export function computeSha256Hmac(
-  key: string,
-  stringToSign: string,
-  encoding: "base64" | "hex",
-): Promise<string> {
-  return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
-}
-
-/**
- * Returns a random integer value between a lower and upper bound, inclusive of both bounds. Note that this uses Math.random and isn't secure. If you need to use this for any kind of security purpose, find a better source of random.
- *
- * @param min - The smallest integer value allowed.
- *
- * @param max - The largest integer value allowed.
- */
-export function getRandomIntegerInclusive(min: number, max: number): number {
-  return tspRuntime.getRandomIntegerInclusive(min, max);
-}
-
-/**
- * Typeguard for an error object shape (has name and message)
- *
- * @param e - Something caught by a catch clause.
- */
-export function isError(e: unknown): e is Error {
-  return tspRuntime.isError(e);
-}
-
-/**
- * Helper to determine when an input is a generic JS object.
- *
- * @returns true when input is an object type that is not null, Array, RegExp, or Date.
- */
-export function isObject(input: unknown): input is UnknownObject {
-  return tspRuntime.isObject(input);
-}
-
-/**
- * Generated Universally Unique Identifier
- *
- * @returns RFC4122 v4 UUID.
- */
-export function randomUUID(): string {
-  return tspRuntime.randomUUID();
-}
-
-/**
- * Supported HTTP methods to use when making requests.
- *
- * @public
- */
-export type HttpMethods =
-  | "GET"
-  | "PUT"
-  | "POST"
-  | "DELETE"
-  | "PATCH"
-  | "HEAD"
-  | "OPTIONS"
-  | "TRACE";
-
-/**
- * A generic shape for a plain JS object.
- */
-export type UnknownObject = {
-  [s: string]: unknown;
-};
-
-/**
- * A constant that indicates whether the environment the code is running is a Web Browser.
- */
-export const isBrowser: boolean = tspRuntime.isBrowser;
-/**
- * A constant that indicates whether the environment the code is running is Bun.sh.
- */
-export const isBun: boolean = tspRuntime.isBun;
-/**
- * A constant that indicates whether the environment the code is running is Deno.
- */
-export const isDeno: boolean = tspRuntime.isDeno;
-/**
- * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
- *
- * @deprecated
- *
- * Use `isNodeLike` instead.
- */
-export const isNode: boolean = tspRuntime.isNodeLike;
-/**
- * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
- */
-export const isNodeLike: boolean = tspRuntime.isNodeLike;
-/**
- * A constant that indicates whether the environment the code is running is Node.JS.
- */
-export const isNodeRuntime: boolean = tspRuntime.isNodeRuntime;
-/**
- * A constant that indicates whether the environment the code is running is in React-Native.
- */
-export const isReactNative: boolean = tspRuntime.isReactNative;
-/**
- * A constant that indicates whether the environment the code is running is a Web Worker.
- */
-export const isWebWorker: boolean = tspRuntime.isWebWorker;
-
-/** The supported character encoding type */
-export type EncodingType = "utf-8" | "base64" | "base64url" | "hex";
-
-/**
- * The helper that transforms bytes with specific character encoding into string
- * @param bytes - the uint8array bytes
- * @param format - the format we use to encode the byte
- * @returns a string of the encoded string
- */
-export function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string {
-  return tspRuntime.uint8ArrayToString(bytes, format);
-}
-
-/**
- * The helper that transforms string to specific character encoded bytes array.
- * @param value - the string to be converted
- * @param format - the format we use to decode the value
- * @returns a uint8array
- */
-export function stringToUint8Array(value: string, format: EncodingType): Uint8Array {
-  return tspRuntime.stringToUint8Array(value, format);
-}
diff --git a/src/util/inspect-browser.mts b/src/util/inspect-browser.mts
new file mode 100644
index 0000000..fccd45b
--- /dev/null
+++ b/src/util/inspect-browser.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./inspect.common.js";
diff --git a/src/util/inspect-react-native.mts b/src/util/inspect-react-native.mts
new file mode 100644
index 0000000..fccd45b
--- /dev/null
+++ b/src/util/inspect-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./inspect.common.js";
diff --git a/src/client/dom.d.ts b/src/util/inspect.common.ts
similarity index 70%
rename from src/client/dom.d.ts
rename to src/util/inspect.common.ts
index eabe718..3b8883b 100644
--- a/src/client/dom.d.ts
+++ b/src/util/inspect.common.ts
@@ -1,4 +1,4 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-/// <reference lib="dom" />
+export const custom = Symbol();
diff --git a/src/util/inspect.ts b/src/util/inspect.ts
new file mode 100644
index 0000000..8ef0f31
--- /dev/null
+++ b/src/util/inspect.ts
@@ -0,0 +1,6 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { inspect } from "node:util";
+
+export const custom = inspect.custom;
diff --git a/src/util/internal.ts b/src/util/internal.ts
new file mode 100644
index 0000000..ce8873a
--- /dev/null
+++ b/src/util/internal.ts
@@ -0,0 +1,20 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export { calculateRetryDelay } from "./delay.js";
+export { getRandomIntegerInclusive } from "./random.js";
+export { isObject, type UnknownObject } from "./object.js";
+export { isError } from "./error.js";
+export { computeSha256Hash, computeSha256Hmac } from "./sha256.js";
+export { randomUUID } from "./uuidUtils.js";
+export {
+  isBrowser,
+  isBun,
+  isNodeLike,
+  isNodeRuntime,
+  isDeno,
+  isReactNative,
+  isWebWorker,
+} from "./checkEnvironment.js";
+export { stringToUint8Array, uint8ArrayToString, type EncodingType } from "./bytesEncoding.js";
+export { Sanitizer, type SanitizerOptions } from "./sanitizer.js";
diff --git a/src/util/object.ts b/src/util/object.ts
new file mode 100644
index 0000000..bbc8d69
--- /dev/null
+++ b/src/util/object.ts
@@ -0,0 +1,21 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/**
+ * A generic shape for a plain JS object.
+ */
+export type UnknownObject = { [s: string]: unknown };
+
+/**
+ * Helper to determine when an input is a generic JS object.
+ * @returns true when input is an object type that is not null, Array, RegExp, or Date.
+ */
+export function isObject(input: unknown): input is UnknownObject {
+  return (
+    typeof input === "object" &&
+    input !== null &&
+    !Array.isArray(input) &&
+    !(input instanceof RegExp) &&
+    !(input instanceof Date)
+  );
+}
diff --git a/src/util/random.ts b/src/util/random.ts
new file mode 100644
index 0000000..5130ca6
--- /dev/null
+++ b/src/util/random.ts
@@ -0,0 +1,21 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/**
+ * Returns a random integer value between a lower and upper bound,
+ * inclusive of both bounds.
+ * Note that this uses Math.random and isn't secure. If you need to use
+ * this for any kind of security purpose, find a better source of random.
+ * @param min - The smallest integer value allowed.
+ * @param max - The largest integer value allowed.
+ */
+export function getRandomIntegerInclusive(min: number, max: number): number {
+  // Make sure inputs are integers.
+  min = Math.ceil(min);
+  max = Math.floor(max);
+  // Pick a random offset from zero to the size of the range.
+  // Since Math.random() can never return 1, we have to make the range one larger
+  // in order to be inclusive of the maximum value after we take the floor.
+  const offset = Math.floor(Math.random() * (max - min + 1));
+  return offset + min;
+}
diff --git a/src/util/sanitizer.ts b/src/util/sanitizer.ts
new file mode 100644
index 0000000..bf8848f
--- /dev/null
+++ b/src/util/sanitizer.ts
@@ -0,0 +1,194 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { type UnknownObject, isObject } from "./object.js";
+
+/**
+ * Sanitizer options
+ */
+export interface SanitizerOptions {
+  /**
+   * Header names whose values will be logged when logging is enabled.
+   * Defaults include a list of well-known safe headers. Any headers
+   * specified in this field will be added to that list.  Any other values will
+   * be written to logs as "REDACTED".
+   */
+  additionalAllowedHeaderNames?: string[];
+
+  /**
+   * Query string names whose values will be logged when logging is enabled. By default no
+   * query string values are logged.
+   */
+  additionalAllowedQueryParameters?: string[];
+}
+
+const RedactedString = "REDACTED";
+
+// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts
+const defaultAllowedHeaderNames = [
+  "x-ms-client-request-id",
+  "x-ms-return-client-request-id",
+  "x-ms-useragent",
+  "x-ms-correlation-request-id",
+  "x-ms-request-id",
+  "client-request-id",
+  "ms-cv",
+  "return-client-request-id",
+  "traceparent",
+
+  "Access-Control-Allow-Credentials",
+  "Access-Control-Allow-Headers",
+  "Access-Control-Allow-Methods",
+  "Access-Control-Allow-Origin",
+  "Access-Control-Expose-Headers",
+  "Access-Control-Max-Age",
+  "Access-Control-Request-Headers",
+  "Access-Control-Request-Method",
+  "Origin",
+
+  "Accept",
+  "Accept-Encoding",
+  "Cache-Control",
+  "Connection",
+  "Content-Length",
+  "Content-Type",
+  "Date",
+  "ETag",
+  "Expires",
+  "If-Match",
+  "If-Modified-Since",
+  "If-None-Match",
+  "If-Unmodified-Since",
+  "Last-Modified",
+  "Pragma",
+  "Request-Id",
+  "Retry-After",
+  "Server",
+  "Transfer-Encoding",
+  "User-Agent",
+  "WWW-Authenticate",
+];
+
+const defaultAllowedQueryParameters: string[] = ["api-version"];
+
+/**
+ * A utility class to sanitize objects for logging.
+ */
+export class Sanitizer {
+  private allowedHeaderNames: Set<string>;
+  private allowedQueryParameters: Set<string>;
+
+  constructor({
+    additionalAllowedHeaderNames: allowedHeaderNames = [],
+    additionalAllowedQueryParameters: allowedQueryParameters = [],
+  }: SanitizerOptions = {}) {
+    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
+    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
+
+    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
+    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
+  }
+
+  /**
+   * Sanitizes an object for logging.
+   * @param obj - The object to sanitize
+   * @returns - The sanitized object as a string
+   */
+  public sanitize(obj: unknown): string {
+    const seen = new Set<unknown>();
+    return JSON.stringify(
+      obj,
+      (key: string, value: unknown) => {
+        // Ensure Errors include their interesting non-enumerable members
+        if (value instanceof Error) {
+          return {
+            ...value,
+            name: value.name,
+            message: value.message,
+          };
+        }
+
+        if (key === "headers") {
+          return this.sanitizeHeaders(value as UnknownObject);
+        } else if (key === "url") {
+          return this.sanitizeUrl(value as string);
+        } else if (key === "query") {
+          return this.sanitizeQuery(value as UnknownObject);
+        } else if (key === "body") {
+          // Don't log the request body
+          return undefined;
+        } else if (key === "response") {
+          // Don't log response again
+          return undefined;
+        } else if (key === "operationSpec") {
+          // When using sendOperationRequest, the request carries a massive
+          // field with the autorest spec. No need to log it.
+          return undefined;
+        } else if (Array.isArray(value) || isObject(value)) {
+          if (seen.has(value)) {
+            return "[Circular]";
+          }
+          seen.add(value);
+        }
+
+        return value;
+      },
+      2,
+    );
+  }
+
+  /**
+   * Sanitizes a URL for logging.
+   * @param value - The URL to sanitize
+   * @returns - The sanitized URL as a string
+   */
+  public sanitizeUrl(value: string): string {
+    if (typeof value !== "string" || value === null || value === "") {
+      return value;
+    }
+
+    const url = new URL(value);
+
+    if (!url.search) {
+      return value;
+    }
+
+    for (const [key] of url.searchParams) {
+      if (!this.allowedQueryParameters.has(key.toLowerCase())) {
+        url.searchParams.set(key, RedactedString);
+      }
+    }
+
+    return url.toString();
+  }
+
+  private sanitizeHeaders(obj: UnknownObject): UnknownObject {
+    const sanitized: UnknownObject = {};
+    for (const key of Object.keys(obj)) {
+      if (this.allowedHeaderNames.has(key.toLowerCase())) {
+        sanitized[key] = obj[key];
+      } else {
+        sanitized[key] = RedactedString;
+      }
+    }
+    return sanitized;
+  }
+
+  private sanitizeQuery(value: UnknownObject): UnknownObject {
+    if (typeof value !== "object" || value === null) {
+      return value;
+    }
+
+    const sanitized: UnknownObject = {};
+
+    for (const k of Object.keys(value)) {
+      if (this.allowedQueryParameters.has(k.toLowerCase())) {
+        sanitized[k] = value[k];
+      } else {
+        sanitized[k] = RedactedString;
+      }
+    }
+
+    return sanitized;
+  }
+}
diff --git a/src/util/sha256-browser.mts b/src/util/sha256-browser.mts
new file mode 100644
index 0000000..b24713e
--- /dev/null
+++ b/src/util/sha256-browser.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./sha256.common.js";
diff --git a/src/util/sha256-react-native.mts b/src/util/sha256-react-native.mts
new file mode 100644
index 0000000..b24713e
--- /dev/null
+++ b/src/util/sha256-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./sha256.common.js";
diff --git a/src/util/sha256.common.ts b/src/util/sha256.common.ts
new file mode 100644
index 0000000..38429e2
--- /dev/null
+++ b/src/util/sha256.common.ts
@@ -0,0 +1,118 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { stringToUint8Array, uint8ArrayToString } from "./bytesEncoding.js";
+
+// stubs for browser self.crypto
+interface JsonWebKey {}
+interface CryptoKey {}
+type KeyUsage =
+  | "decrypt"
+  | "deriveBits"
+  | "deriveKey"
+  | "encrypt"
+  | "sign"
+  | "unwrapKey"
+  | "verify"
+  | "wrapKey";
+interface Algorithm {
+  name: string;
+}
+interface SubtleCrypto {
+  importKey(
+    format: string,
+    keyData: JsonWebKey,
+    algorithm: HmacImportParams,
+    extractable: boolean,
+    usage: KeyUsage[],
+  ): Promise<CryptoKey>;
+  sign(
+    algorithm: HmacImportParams,
+    key: CryptoKey,
+    data: ArrayBufferView | ArrayBuffer,
+  ): Promise<ArrayBuffer>;
+  digest(algorithm: Algorithm, data: ArrayBufferView | ArrayBuffer): Promise<ArrayBuffer>;
+}
+interface Crypto {
+  readonly subtle: SubtleCrypto;
+  getRandomValues<T extends ArrayBufferView | null>(array: T): T;
+}
+declare const self: {
+  crypto: Crypto;
+};
+interface HmacImportParams {
+  name: string;
+  hash: Algorithm;
+  length?: number;
+}
+
+let subtleCrypto: SubtleCrypto | undefined;
+
+/**
+ * Returns a cached reference to the Web API crypto.subtle object.
+ * @internal
+ */
+function getCrypto(): SubtleCrypto {
+  if (subtleCrypto) {
+    return subtleCrypto;
+  }
+
+  if (!self.crypto || !self.crypto.subtle) {
+    throw new Error("Your browser environment does not support cryptography functions.");
+  }
+
+  subtleCrypto = self.crypto.subtle;
+  return subtleCrypto;
+}
+
+/**
+ * Generates a SHA-256 HMAC signature.
+ * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
+ * @param stringToSign - The data to be signed.
+ * @param encoding - The textual encoding to use for the returned HMAC digest.
+ */
+export async function computeSha256Hmac(
+  key: string,
+  stringToSign: string,
+  encoding: "base64" | "hex",
+): Promise<string> {
+  const crypto = getCrypto();
+  const keyBytes = stringToUint8Array(key, "base64");
+  const stringToSignBytes = stringToUint8Array(stringToSign, "utf-8");
+
+  const cryptoKey = await crypto.importKey(
+    "raw",
+    keyBytes,
+    {
+      name: "HMAC",
+      hash: { name: "SHA-256" },
+    },
+    false,
+    ["sign"],
+  );
+  const signature = await crypto.sign(
+    {
+      name: "HMAC",
+      hash: { name: "SHA-256" },
+    },
+    cryptoKey,
+    stringToSignBytes,
+  );
+
+  return uint8ArrayToString(new Uint8Array(signature), encoding);
+}
+
+/**
+ * Generates a SHA-256 hash.
+ * @param content - The data to be included in the hash.
+ * @param encoding - The textual encoding to use for the returned hash.
+ */
+export async function computeSha256Hash(
+  content: string,
+  encoding: "base64" | "hex",
+): Promise<string> {
+  const contentBytes = stringToUint8Array(content, "utf-8");
+  const digest = await getCrypto().digest({ name: "SHA-256" }, contentBytes);
+
+  return uint8ArrayToString(new Uint8Array(digest), encoding);
+}
diff --git a/src/util/sha256.ts b/src/util/sha256.ts
new file mode 100644
index 0000000..794d26a
--- /dev/null
+++ b/src/util/sha256.ts
@@ -0,0 +1,32 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { createHash, createHmac } from "node:crypto";
+
+/**
+ * Generates a SHA-256 HMAC signature.
+ * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
+ * @param stringToSign - The data to be signed.
+ * @param encoding - The textual encoding to use for the returned HMAC digest.
+ */
+export async function computeSha256Hmac(
+  key: string,
+  stringToSign: string,
+  encoding: "base64" | "hex",
+): Promise<string> {
+  const decodedKey = Buffer.from(key, "base64");
+
+  return createHmac("sha256", decodedKey).update(stringToSign).digest(encoding);
+}
+
+/**
+ * Generates a SHA-256 hash.
+ * @param content - The data to be included in the hash.
+ * @param encoding - The textual encoding to use for the returned hash.
+ */
+export async function computeSha256Hash(
+  content: string,
+  encoding: "base64" | "hex",
+): Promise<string> {
+  return createHash("sha256").update(content).digest(encoding);
+}
diff --git a/src/util/tokenCycler.ts b/src/util/tokenCycler.ts
deleted file mode 100644
index 31c7d87..0000000
--- a/src/util/tokenCycler.ts
+++ /dev/null
@@ -1,232 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AccessToken, GetTokenOptions, TokenCredential } from "@azure/core-auth";
-import { delay } from "@azure/core-util";
-
-/**
- * A function that gets a promise of an access token and allows providing
- * options.
- *
- * @param options - the options to pass to the underlying token provider
- */
-export type AccessTokenGetter = (
-  scopes: string | string[],
-  options: GetTokenOptions,
-) => Promise<AccessToken>;
-
-export interface TokenCyclerOptions {
-  /**
-   * The window of time before token expiration during which the token will be
-   * considered unusable due to risk of the token expiring before sending the
-   * request.
-   *
-   * This will only become meaningful if the refresh fails for over
-   * (refreshWindow - forcedRefreshWindow) milliseconds.
-   */
-  forcedRefreshWindowInMs: number;
-  /**
-   * Interval in milliseconds to retry failed token refreshes.
-   */
-  retryIntervalInMs: number;
-  /**
-   * The window of time before token expiration during which
-   * we will attempt to refresh the token.
-   */
-  refreshWindowInMs: number;
-}
-
-// Default options for the cycler if none are provided
-export const DEFAULT_CYCLER_OPTIONS: TokenCyclerOptions = {
-  forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires
-  retryIntervalInMs: 3000, // Allow refresh attempts every 3s
-  refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry
-};
-
-/**
- * Converts an an unreliable access token getter (which may resolve with null)
- * into an AccessTokenGetter by retrying the unreliable getter in a regular
- * interval.
- *
- * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
- * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
- * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
- * @returns - A promise that, if it resolves, will resolve with an access token.
- */
-async function beginRefresh(
-  getAccessToken: () => Promise<AccessToken | null>,
-  retryIntervalInMs: number,
-  refreshTimeout: number,
-): Promise<AccessToken> {
-  // This wrapper handles exceptions gracefully as long as we haven't exceeded
-  // the timeout.
-  async function tryGetAccessToken(): Promise<AccessToken | null> {
-    if (Date.now() < refreshTimeout) {
-      try {
-        return await getAccessToken();
-      } catch {
-        return null;
-      }
-    } else {
-      const finalToken = await getAccessToken();
-
-      // Timeout is up, so throw if it's still null
-      if (finalToken === null) {
-        throw new Error("Failed to refresh access token.");
-      }
-
-      return finalToken;
-    }
-  }
-
-  let token: AccessToken | null = await tryGetAccessToken();
-
-  while (token === null) {
-    await delay(retryIntervalInMs);
-
-    token = await tryGetAccessToken();
-  }
-
-  return token;
-}
-
-/**
- * Creates a token cycler from a credential, scopes, and optional settings.
- *
- * A token cycler represents a way to reliably retrieve a valid access token
- * from a TokenCredential. It will handle initializing the token, refreshing it
- * when it nears expiration, and synchronizes refresh attempts to avoid
- * concurrency hazards.
- *
- * @param credential - the underlying TokenCredential that provides the access
- * token
- * @param tokenCyclerOptions - optionally override default settings for the cycler
- *
- * @returns - a function that reliably produces a valid access token
- */
-export function createTokenCycler(
-  credential: TokenCredential,
-  tokenCyclerOptions?: Partial<TokenCyclerOptions>,
-): AccessTokenGetter {
-  let refreshWorker: Promise<AccessToken> | null = null;
-  let token: AccessToken | null = null;
-  let tenantId: string | undefined;
-
-  const options = {
-    ...DEFAULT_CYCLER_OPTIONS,
-    ...tokenCyclerOptions,
-  };
-
-  /**
-   * This little holder defines several predicates that we use to construct
-   * the rules of refreshing the token.
-   */
-  const cycler = {
-    /**
-     * Produces true if a refresh job is currently in progress.
-     */
-    get isRefreshing(): boolean {
-      return refreshWorker !== null;
-    },
-    /**
-     * Produces true if the cycler SHOULD refresh (we are within the refresh
-     * window and not already refreshing)
-     */
-    get shouldRefresh(): boolean {
-      if (cycler.isRefreshing) {
-        return false;
-      }
-      if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) {
-        return true;
-      }
-
-      return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();
-    },
-    /**
-     * Produces true if the cycler MUST refresh (null or nearly-expired
-     * token).
-     */
-    get mustRefresh(): boolean {
-      return (
-        token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now()
-      );
-    },
-  };
-
-  /**
-   * Starts a refresh job or returns the existing job if one is already
-   * running.
-   */
-  function refresh(
-    scopes: string | string[],
-    getTokenOptions: GetTokenOptions,
-  ): Promise<AccessToken> {
-    if (!cycler.isRefreshing) {
-      // We bind `scopes` here to avoid passing it around a lot
-      const tryGetAccessToken = (): Promise<AccessToken | null> =>
-        credential.getToken(scopes, getTokenOptions);
-
-      // Take advantage of promise chaining to insert an assignment to `token`
-      // before the refresh can be considered done.
-      refreshWorker = beginRefresh(
-        tryGetAccessToken,
-        options.retryIntervalInMs,
-        // If we don't have a token, then we should timeout immediately
-        token?.expiresOnTimestamp ?? Date.now(),
-      )
-        .then((_token) => {
-          refreshWorker = null;
-          token = _token;
-          tenantId = getTokenOptions.tenantId;
-          return token;
-        })
-        .catch((reason) => {
-          // We also should reset the refresher if we enter a failed state.  All
-          // existing awaiters will throw, but subsequent requests will start a
-          // new retry chain.
-          refreshWorker = null;
-          token = null;
-          tenantId = undefined;
-          throw reason;
-        });
-    }
-
-    return refreshWorker as Promise<AccessToken>;
-  }
-
-  return async (scopes: string | string[], tokenOptions: GetTokenOptions): Promise<AccessToken> => {
-    //
-    // Simple rules:
-    // - If we MUST refresh, then return the refresh task, blocking
-    //   the pipeline until a token is available.
-    // - If we SHOULD refresh, then run refresh but don't return it
-    //   (we can still use the cached token).
-    // - Return the token, since it's fine if we didn't return in
-    //   step 1.
-    //
-
-    const hasClaimChallenge = Boolean(tokenOptions.claims);
-    const tenantIdChanged = tenantId !== tokenOptions.tenantId;
-
-    if (hasClaimChallenge) {
-      // If we've received a claim, we know the existing token isn't valid
-      // We want to clear it so that that refresh worker won't use the old expiration time as a timeout
-      token = null;
-    }
-
-    // If the tenantId passed in token options is different to the one we have
-    // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to
-    // refresh the token with the new tenantId or token.
-    const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
-
-    if (mustRefresh) {
-      return refresh(scopes, tokenOptions);
-    }
-
-    if (cycler.shouldRefresh) {
-      refresh(scopes, tokenOptions);
-    }
-
-    return token as AccessToken;
-  };
-}
diff --git a/src/util/typeGuards.ts b/src/util/typeGuards.ts
index 22a9cac..265ded3 100644
--- a/src/util/typeGuards.ts
+++ b/src/util/typeGuards.ts
@@ -1,46 +1,40 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-/**
- * Helper TypeGuard that checks if something is defined or not.
- * @param thing - Anything
- */
-export function isDefined<T>(thing: T | undefined | null): thing is T {
-  return typeof thing !== "undefined" && thing !== null;
+export function isNodeReadableStream(x: unknown): x is NodeJS.ReadableStream {
+  return Boolean(x && typeof (x as NodeJS.ReadableStream)["pipe"] === "function");
 }
 
-/**
- * Helper TypeGuard that checks if the input is an object with the specified properties.
- * @param thing - Anything.
- * @param properties - The name of the properties that should appear in the object.
- */
-export function isObjectWithProperties<Thing, PropertyName extends string>(
-  thing: Thing,
-  properties: PropertyName[],
-): thing is Thing & Record<PropertyName, unknown> {
-  if (!isDefined(thing) || typeof thing !== "object") {
-    return false;
+export function isWebReadableStream(x: unknown): x is ReadableStream {
+  return Boolean(
+    x &&
+      typeof (x as ReadableStream).getReader === "function" &&
+      typeof (x as ReadableStream).tee === "function",
+  );
 }
 
-  for (const property of properties) {
-    if (!objectHasProperty(thing, property)) {
-      return false;
-    }
+export function isBinaryBody(
+  body: unknown,
+): body is
+  | Uint8Array
+  | NodeJS.ReadableStream
+  | ReadableStream<Uint8Array>
+  | (() => NodeJS.ReadableStream)
+  | (() => ReadableStream<Uint8Array>)
+  | Blob {
+  return (
+    body !== undefined &&
+    (body instanceof Uint8Array ||
+      isReadableStream(body) ||
+      typeof body === "function" ||
+      body instanceof Blob)
+  );
 }
 
-  return true;
+export function isReadableStream(x: unknown): x is ReadableStream | NodeJS.ReadableStream {
+  return isNodeReadableStream(x) || isWebReadableStream(x);
 }
 
-/**
- * Helper TypeGuard that checks if the input is an object with the specified property.
- * @param thing - Any object.
- * @param property - The name of the property that should appear in the object.
- */
-export function objectHasProperty<Thing, PropertyName extends string>(
-  thing: Thing,
-  property: PropertyName,
-): thing is Thing & Record<PropertyName, unknown> {
-  return (
-    isDefined(thing) && typeof thing === "object" && property in (thing as Record<string, unknown>)
-  );
+export function isBlob(x: unknown): x is Blob {
+  return typeof (x as Blob).stream === "function";
 }
diff --git a/src/util/userAgent.ts b/src/util/userAgent.ts
index b8950b5..3ef33c8 100644
--- a/src/util/userAgent.ts
+++ b/src/util/userAgent.ts
@@ -25,7 +25,7 @@ export function getUserAgentHeaderName(): string {
  */
 export async function getUserAgentValue(prefix?: string): Promise<string> {
   const runtimeInfo = new Map<string, string>();
-  runtimeInfo.set("core-rest-pipeline", SDK_VERSION);
+  runtimeInfo.set("ts-http-runtime", SDK_VERSION);
   await setPlatformSpecificData(runtimeInfo);
   const defaultAgent = getUserAgentString(runtimeInfo);
   const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
diff --git a/src/util/uuidUtils-browser.mts b/src/util/uuidUtils-browser.mts
new file mode 100644
index 0000000..0e8d3c7
--- /dev/null
+++ b/src/util/uuidUtils-browser.mts
@@ -0,0 +1,27 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { generateUUID } from "./uuidUtils.common.js";
+
+interface Crypto {
+  randomUUID(): string;
+}
+
+declare const globalThis: {
+  crypto: Crypto;
+};
+
+// NOTE: This could be undefined if not used in a secure context
+const uuidFunction =
+  typeof globalThis?.crypto?.randomUUID === "function"
+    ? globalThis.crypto.randomUUID.bind(globalThis.crypto)
+    : generateUUID;
+
+/**
+ * Generated Universally Unique Identifier
+ *
+ * @returns RFC4122 v4 UUID.
+ */
+export function randomUUID(): string {
+  return uuidFunction();
+}
diff --git a/src/util/uuidUtils-react-native.mts b/src/util/uuidUtils-react-native.mts
new file mode 100644
index 0000000..cc49ba6
--- /dev/null
+++ b/src/util/uuidUtils-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export { randomUUID } from "./uuidUtils.common.js";
diff --git a/src/util/uuidUtils.common.ts b/src/util/uuidUtils.common.ts
new file mode 100644
index 0000000..1fa8b8f
--- /dev/null
+++ b/src/util/uuidUtils.common.ts
@@ -0,0 +1,39 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/**
+ * Generated Universally Unique Identifier
+ *
+ * @returns RFC4122 v4 UUID.
+ */
+export function generateUUID(): string {
+  let uuid = "";
+  for (let i = 0; i < 32; i++) {
+    // Generate a random number between 0 and 15
+    const randomNumber = Math.floor(Math.random() * 16);
+    // Set the UUID version to 4 in the 13th position
+    if (i === 12) {
+      uuid += "4";
+    } else if (i === 16) {
+      // Set the UUID variant to "10" in the 17th position
+      uuid += (randomNumber & 0x3) | 0x8;
+    } else {
+      // Add a random hexadecimal digit to the UUID string
+      uuid += randomNumber.toString(16);
+    }
+    // Add hyphens to the UUID string at the appropriate positions
+    if (i === 7 || i === 11 || i === 15 || i === 19) {
+      uuid += "-";
+    }
+  }
+  return uuid;
+}
+
+/**
+ * Generated Universally Unique Identifier
+ *
+ * @returns RFC4122 v4 UUID.
+ */
+export function randomUUID(): string {
+  return generateUUID();
+}
diff --git a/src/util/uuidUtils.ts b/src/util/uuidUtils.ts
new file mode 100644
index 0000000..3f6a12b
--- /dev/null
+++ b/src/util/uuidUtils.ts
@@ -0,0 +1,27 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { randomUUID as v4RandomUUID } from "node:crypto";
+
+interface Crypto {
+  randomUUID(): string;
+}
+
+declare const globalThis: {
+  crypto: Crypto;
+};
+
+// NOTE: This is a workaround until we can use `globalThis.crypto.randomUUID` in Node.js 19+.
+const uuidFunction =
+  typeof globalThis?.crypto?.randomUUID === "function"
+    ? globalThis.crypto.randomUUID.bind(globalThis.crypto)
+    : v4RandomUUID;
+
+/**
+ * Generated Universally Unique Identifier
+ *
+ * @returns RFC4122 v4 UUID.
+ */
+export function randomUUID(): string {
+  return uuidFunction();
+}
diff --git a/src/util/wrapAbortSignal.ts b/src/util/wrapAbortSignal.ts
deleted file mode 100644
index 7ca1ba6..0000000
--- a/src/util/wrapAbortSignal.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AbortSignalLike } from "@azure/abort-controller";
-
-/**
- * Creates a native AbortSignal which reflects the state of the provided AbortSignalLike.
- * If the AbortSignalLike is already a native AbortSignal, it is returned as is.
- * @param abortSignalLike - The AbortSignalLike to wrap.
- * @returns - An object containing the native AbortSignal and an optional cleanup function. The cleanup function should be called when the AbortSignal is no longer needed.
- */
-export function wrapAbortSignalLike(abortSignalLike: AbortSignalLike): {
-  abortSignal: AbortSignal;
-  cleanup?: () => void;
-} {
-  if (abortSignalLike instanceof AbortSignal) {
-    return { abortSignal: abortSignalLike };
-  }
-
-  if (abortSignalLike.aborted) {
-    return { abortSignal: AbortSignal.abort((abortSignalLike as any).reason) };
-  }
-
-  const controller = new AbortController();
-  let needsCleanup = true;
-  function cleanup(): void {
-    if (needsCleanup) {
-      abortSignalLike.removeEventListener("abort", listener);
-      needsCleanup = false;
-    }
-  }
-  function listener(): void {
-    controller.abort((abortSignalLike as any).reason);
-    cleanup();
-  }
-
-  abortSignalLike.addEventListener("abort", listener);
-  return { abortSignal: controller.signal, cleanup };
-}
diff --git a/src/xhrHttpClient.ts b/src/xhrHttpClient.ts
new file mode 100644
index 0000000..2a8f850
--- /dev/null
+++ b/src/xhrHttpClient.ts
@@ -0,0 +1,207 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { AbortError } from "./abort-controller/AbortError.js";
+import type {
+  HttpClient,
+  HttpHeaders,
+  PipelineRequest,
+  PipelineResponse,
+  TransferProgressEvent,
+} from "./interfaces.js";
+import { createHttpHeaders } from "./httpHeaders.js";
+import { RestError } from "./restError.js";
+import { isReadableStream } from "./util/typeGuards.js";
+
+/**
+ * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.
+ * @internal
+ */
+class XhrHttpClient implements HttpClient {
+  /**
+   * Makes a request over an underlying transport layer and returns the response.
+   * @param request - The request to be made.
+   */
+  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {
+    const url = new URL(request.url);
+    const isInsecure = url.protocol !== "https:";
+
+    if (isInsecure && !request.allowInsecureConnection) {
+      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
+    }
+
+    const xhr = new XMLHttpRequest();
+
+    if (request.proxySettings) {
+      throw new Error("HTTP proxy is not supported in browser environment");
+    }
+
+    const abortSignal = request.abortSignal;
+    if (abortSignal) {
+      if (abortSignal.aborted) {
+        throw new AbortError("The operation was aborted. Request has already been canceled.");
+      }
+
+      const listener = (): void => {
+        xhr.abort();
+      };
+      abortSignal.addEventListener("abort", listener);
+      xhr.addEventListener("readystatechange", () => {
+        if (xhr.readyState === XMLHttpRequest.DONE) {
+          abortSignal.removeEventListener("abort", listener);
+        }
+      });
+    }
+
+    addProgressListener(xhr.upload, request.onUploadProgress);
+    addProgressListener(xhr, request.onDownloadProgress);
+
+    xhr.open(request.method, request.url);
+    xhr.timeout = request.timeout;
+    xhr.withCredentials = request.withCredentials;
+    for (const [name, value] of request.headers) {
+      xhr.setRequestHeader(name, value);
+    }
+
+    xhr.responseType = request.streamResponseStatusCodes?.size ? "blob" : "text";
+
+    const body = typeof request.body === "function" ? request.body() : request.body;
+    if (isReadableStream(body)) {
+      throw new Error("streams are not supported in XhrHttpClient.");
+    }
+
+    xhr.send(body === undefined ? null : body);
+
+    if (xhr.responseType === "blob") {
+      return new Promise((resolve, reject) => {
+        handleBlobResponse(xhr, request, resolve, reject);
+        rejectOnTerminalEvent(request, xhr, reject);
+      });
+    } else {
+      return new Promise(function (resolve, reject) {
+        xhr.addEventListener("load", () =>
+          resolve({
+            request,
+            status: xhr.status,
+            headers: parseHeaders(xhr),
+            bodyAsText: xhr.responseText,
+          }),
+        );
+        rejectOnTerminalEvent(request, xhr, reject);
+      });
+    }
+  }
+}
+
+function handleBlobResponse(
+  xhr: XMLHttpRequest,
+  request: PipelineRequest,
+  res: (value: PipelineResponse | PromiseLike<PipelineResponse>) => void,
+  rej: (reason?: any) => void,
+): void {
+  xhr.addEventListener("readystatechange", () => {
+    // Resolve as soon as headers are loaded
+    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
+      if (
+        // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
+        request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||
+        request.streamResponseStatusCodes?.has(xhr.status)
+      ) {
+        const blobBody = new Promise<Blob>((resolve, reject) => {
+          xhr.addEventListener("load", () => {
+            resolve(xhr.response);
+          });
+          rejectOnTerminalEvent(request, xhr, reject);
+        });
+        res({
+          request,
+          status: xhr.status,
+          headers: parseHeaders(xhr),
+          blobBody,
+        });
+      } else {
+        xhr.addEventListener("load", () => {
+          // xhr.response is of Blob type if the request is sent with xhr.responseType === "blob"
+          // but the status code is not one of the stream response status codes,
+          // so treat it as text and convert from Blob to text
+          if (xhr.response) {
+            xhr.response
+              .text()
+              .then((text: string) => {
+                res({
+                  request: request,
+                  status: xhr.status,
+                  headers: parseHeaders(xhr),
+                  bodyAsText: text,
+                });
+                return;
+              })
+              .catch((e: any) => {
+                rej(e);
+              });
+          } else {
+            res({
+              request,
+              status: xhr.status,
+              headers: parseHeaders(xhr),
+            });
+          }
+        });
+      }
+    }
+  });
+}
+
+function addProgressListener(
+  xhr: XMLHttpRequestEventTarget,
+  listener?: (progress: TransferProgressEvent) => void,
+): void {
+  if (listener) {
+    xhr.addEventListener("progress", (rawEvent) =>
+      listener({
+        loadedBytes: rawEvent.loaded,
+      }),
+    );
+  }
+}
+
+function parseHeaders(xhr: XMLHttpRequest): HttpHeaders {
+  const responseHeaders = createHttpHeaders();
+  const headerLines = xhr
+    .getAllResponseHeaders()
+    .trim()
+    .split(/[\r\n]+/);
+  for (const line of headerLines) {
+    const index = line.indexOf(":");
+    const headerName = line.slice(0, index);
+    const headerValue = line.slice(index + 2);
+    responseHeaders.set(headerName, headerValue);
+  }
+  return responseHeaders;
+}
+
+function rejectOnTerminalEvent(
+  request: PipelineRequest,
+  xhr: XMLHttpRequest,
+  reject: (err: any) => void,
+): void {
+  xhr.addEventListener("error", () =>
+    reject(
+      new RestError(`Failed to send request to ${request.url}`, {
+        code: RestError.REQUEST_SEND_ERROR,
+        request,
+      }),
+    ),
+  );
+  const abortError = new AbortError("The operation was aborted.");
+  xhr.addEventListener("abort", () => reject(abortError));
+  xhr.addEventListener("timeout", () => reject(abortError));
+}
+
+/**
+ * Create a new HttpClient instance for the browser environment.
+ * @internal
+ */
+export function createXhrHttpClient(): HttpClient {
+  return new XhrHttpClient();
+}
