diff --git a/src/abort-controller/AbortError.ts b/src/abort-controller/AbortError.ts
index d075fbb..9f62db0 100644
--- a/src/abort-controller/AbortError.ts
+++ b/src/abort-controller/AbortError.ts
@@ -7,8 +7,8 @@
  * error matches `"AbortError"`.
  *
  * @example
- * ```ts snippet:AbortErrorSample
- * import { AbortError } from "@azure/abort-controller";
+ * ```ts snippet:ReadmeSampleAbortError
+ * import { AbortError } from "@typespec/ts-http-runtime";
  *
  * async function doAsyncWork(options: { abortSignal: AbortSignal }): Promise<void> {
  *   if (options.abortSignal.aborted) {
@@ -20,6 +20,7 @@
  *
  * const controller = new AbortController();
  * controller.abort();
+ *
  * try {
  *   doAsyncWork({ abortSignal: controller.signal });
  * } catch (e) {
diff --git a/src/abort-controller/AbortSignalLike.ts b/src/abort-controller/AbortSignalLike.ts
deleted file mode 100644
index b5b390d..0000000
--- a/src/abort-controller/AbortSignalLike.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * Allows the request to be aborted upon firing of the "abort" event.
- * Compatible with the browser built-in AbortSignal and common polyfills.
- */
-export interface AbortSignalLike {
-  /**
-   * Indicates if the signal has already been aborted.
-   */
-  readonly aborted: boolean;
-  /**
-   * Add new "abort" event listener, only support "abort" event.
-   */
-  addEventListener(
-    type: "abort",
-    listener: (this: AbortSignalLike, ev: any) => any,
-    options?: any,
-  ): void;
-  /**
-   * Remove "abort" event listener, only support "abort" event.
-   */
-  removeEventListener(
-    type: "abort",
-    listener: (this: AbortSignalLike, ev: any) => any,
-    options?: any,
-  ): void;
-}
diff --git a/src/abort-controller/index.ts b/src/abort-controller/index.ts
deleted file mode 100644
index 7f2adc4..0000000
--- a/src/abort-controller/index.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-declare global {
-  interface Event {}
-}
-
-export { AbortError } from "./AbortError.js";
-export { AbortSignalLike } from "./AbortSignalLike.js";
diff --git a/src/accessTokenCache.ts b/src/accessTokenCache.ts
deleted file mode 100644
index f8d603b..0000000
--- a/src/accessTokenCache.ts
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AccessToken } from "@azure/core-auth";
-
-/**
- * Defines the default token refresh buffer duration.
- */
-export const DefaultTokenRefreshBufferMs = 2 * 60 * 1000; // 2 Minutes
-
-/**
- * Provides a cache for an AccessToken that was that
- * was returned from a TokenCredential.
- */
-export interface AccessTokenCache {
-  /**
-   * Sets the cached token.
-   *
-   * @param accessToken - The AccessToken to be cached or null to
-   *   clear the cached token.
-   */
-  setCachedToken(accessToken: AccessToken | undefined): void;
-
-  /**
-   * Returns the cached AccessToken or undefined if nothing is cached.
-   */
-  getCachedToken(): AccessToken | undefined;
-}
-
-/**
- * Provides an AccessTokenCache implementation which clears
- * the cached AccessToken's after the expiresOnTimestamp has
- * passed.
- * @internal
- */
-export class ExpiringAccessTokenCache implements AccessTokenCache {
-  private tokenRefreshBufferMs: number;
-  private cachedToken?: AccessToken;
-
-  /**
-   * Constructs an instance of ExpiringAccessTokenCache with
-   * an optional expiration buffer time.
-   */
-  constructor(tokenRefreshBufferMs: number = DefaultTokenRefreshBufferMs) {
-    this.tokenRefreshBufferMs = tokenRefreshBufferMs;
-  }
-
-  setCachedToken(accessToken: AccessToken | undefined): void {
-    this.cachedToken = accessToken;
-  }
-
-  getCachedToken(): AccessToken | undefined {
-    if (
-      this.cachedToken &&
-      Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp
-    ) {
-      this.cachedToken = undefined;
-    }
-
-    return this.cachedToken;
-  }
-}
diff --git a/src/auth/azureKeyCredential.ts b/src/auth/azureKeyCredential.ts
deleted file mode 100644
index 65676e7..0000000
--- a/src/auth/azureKeyCredential.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { KeyCredential } from "./keyCredential.js";
-
-/**
- * A static-key-based credential that supports updating
- * the underlying key value.
- */
-export class AzureKeyCredential implements KeyCredential {
-  private _key: string;
-
-  /**
-   * The value of the key to be used in authentication
-   */
-  public get key(): string {
-    return this._key;
-  }
-
-  /**
-   * Create an instance of an AzureKeyCredential for use
-   * with a service client.
-   *
-   * @param key - The initial value of the key to use in authentication
-   */
-  constructor(key: string) {
-    if (!key) {
-      throw new Error("key must be a non-empty string");
-    }
-
-    this._key = key;
-  }
-
-  /**
-   * Change the value of the key.
-   *
-   * Updates will take effect upon the next request after
-   * updating the key value.
-   *
-   * @param newKey - The new key value to be used
-   */
-  public update(newKey: string): void {
-    this._key = newKey;
-  }
-}
diff --git a/src/auth/azureNamedKeyCredential.ts b/src/auth/azureNamedKeyCredential.ts
deleted file mode 100644
index 544c3c0..0000000
--- a/src/auth/azureNamedKeyCredential.ts
+++ /dev/null
@@ -1,88 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { isObjectWithProperties } from "@azure/core-util";
-
-/**
- * Represents a credential defined by a static API name and key.
- */
-export interface NamedKeyCredential {
-  /**
-   * The value of the API key represented as a string
-   */
-  readonly key: string;
-  /**
-   * The value of the API name represented as a string.
-   */
-  readonly name: string;
-}
-
-/**
- * A static name/key-based credential that supports updating
- * the underlying name and key values.
- */
-export class AzureNamedKeyCredential implements NamedKeyCredential {
-  private _key: string;
-  private _name: string;
-
-  /**
-   * The value of the key to be used in authentication.
-   */
-  public get key(): string {
-    return this._key;
-  }
-
-  /**
-   * The value of the name to be used in authentication.
-   */
-  public get name(): string {
-    return this._name;
-  }
-
-  /**
-   * Create an instance of an AzureNamedKeyCredential for use
-   * with a service client.
-   *
-   * @param name - The initial value of the name to use in authentication.
-   * @param key - The initial value of the key to use in authentication.
-   */
-  constructor(name: string, key: string) {
-    if (!name || !key) {
-      throw new TypeError("name and key must be non-empty strings");
-    }
-
-    this._name = name;
-    this._key = key;
-  }
-
-  /**
-   * Change the value of the key.
-   *
-   * Updates will take effect upon the next request after
-   * updating the key value.
-   *
-   * @param newName - The new name value to be used.
-   * @param newKey - The new key value to be used.
-   */
-  public update(newName: string, newKey: string): void {
-    if (!newName || !newKey) {
-      throw new TypeError("newName and newKey must be non-empty strings");
-    }
-
-    this._name = newName;
-    this._key = newKey;
-  }
-}
-
-/**
- * Tests an object to determine whether it implements NamedKeyCredential.
- *
- * @param credential - The assumed NamedKeyCredential to be tested.
- */
-export function isNamedKeyCredential(credential: unknown): credential is NamedKeyCredential {
-  return (
-    isObjectWithProperties(credential, ["name", "key"]) &&
-    typeof credential.key === "string" &&
-    typeof credential.name === "string"
-  );
-}
diff --git a/src/auth/azureSASCredential.ts b/src/auth/azureSASCredential.ts
deleted file mode 100644
index 045c639..0000000
--- a/src/auth/azureSASCredential.ts
+++ /dev/null
@@ -1,70 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { isObjectWithProperties } from "@azure/core-util";
-
-/**
- * Represents a credential defined by a static shared access signature.
- */
-export interface SASCredential {
-  /**
-   * The value of the shared access signature represented as a string
-   */
-  readonly signature: string;
-}
-
-/**
- * A static-signature-based credential that supports updating
- * the underlying signature value.
- */
-export class AzureSASCredential implements SASCredential {
-  private _signature: string;
-
-  /**
-   * The value of the shared access signature to be used in authentication
-   */
-  public get signature(): string {
-    return this._signature;
-  }
-
-  /**
-   * Create an instance of an AzureSASCredential for use
-   * with a service client.
-   *
-   * @param signature - The initial value of the shared access signature to use in authentication
-   */
-  constructor(signature: string) {
-    if (!signature) {
-      throw new Error("shared access signature must be a non-empty string");
-    }
-
-    this._signature = signature;
-  }
-
-  /**
-   * Change the value of the signature.
-   *
-   * Updates will take effect upon the next request after
-   * updating the signature value.
-   *
-   * @param newSignature - The new shared access signature value to be used
-   */
-  public update(newSignature: string): void {
-    if (!newSignature) {
-      throw new Error("shared access signature must be a non-empty string");
-    }
-
-    this._signature = newSignature;
-  }
-}
-
-/**
- * Tests an object to determine whether it implements SASCredential.
- *
- * @param credential - The assumed SASCredential to be tested.
- */
-export function isSASCredential(credential: unknown): credential is SASCredential {
-  return (
-    isObjectWithProperties(credential, ["signature"]) && typeof credential.signature === "string"
-  );
-}
diff --git a/src/auth/credentials.ts b/src/auth/credentials.ts
new file mode 100644
index 0000000..3079b40
--- /dev/null
+++ b/src/auth/credentials.ts
@@ -0,0 +1,106 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { OAuth2Flow } from "./oauth2Flows.js";
+
+/**
+ * Options used when creating and sending get OAuth 2 requests for this operation.
+ */
+export interface GetOAuth2TokenOptions {
+  /** Abort signal for the request */
+  abortSignal?: AbortSignal;
+}
+
+/**
+ * Options used when creating and sending get bearer token requests for this operation.
+ */
+export interface GetBearerTokenOptions {
+  /** Abort signal for the request */
+  abortSignal?: AbortSignal;
+}
+
+/**
+ * Credential for OAuth2 authentication flows.
+ */
+export interface OAuth2TokenCredential<TFlows extends OAuth2Flow> {
+  /**
+   * Gets an OAuth2 token for the specified flows.
+   * @param flows - The OAuth2 flows to use.
+   * @param options - Options for the request.
+   * @returns - a valid access token which was obtained through one of the flows specified in `flows`.
+   */
+  getOAuth2Token(flows: TFlows[], options?: GetOAuth2TokenOptions): Promise<string>;
+}
+
+/**
+ * Credential for Bearer token authentication.
+ */
+export interface BearerTokenCredential {
+  /**
+   * Gets a Bearer token for the specified flows.
+   * @param options - Options for the request.
+   * @returns - a valid access token.
+   */
+  getBearerToken(options?: GetBearerTokenOptions): Promise<string>;
+}
+
+/**
+ * Credential for HTTP Basic authentication.
+ * Provides username and password for basic authentication headers.
+ */
+export interface BasicCredential {
+  /** The username for basic authentication. */
+  username: string;
+  /** The password for basic authentication. */
+  password: string;
+}
+
+/**
+ * Credential for API Key authentication.
+ * Provides an API key that will be used in the request headers.
+ */
+export interface ApiKeyCredential {
+  /** The API key for authentication. */
+  key: string;
+}
+
+/**
+ * Union type of all supported authentication credentials.
+ */
+export type ClientCredential =
+  | OAuth2TokenCredential<OAuth2Flow>
+  | BearerTokenCredential
+  | BasicCredential
+  | ApiKeyCredential;
+
+/**
+ * Type guard to check if a credential is an OAuth2 token credential.
+ */
+export function isOAuth2TokenCredential(
+  credential: ClientCredential,
+): credential is OAuth2TokenCredential<OAuth2Flow> {
+  return "getOAuth2Token" in credential;
+}
+
+/**
+ * Type guard to check if a credential is a Bearer token credential.
+ */
+export function isBearerTokenCredential(
+  credential: ClientCredential,
+): credential is BearerTokenCredential {
+  return "getBearerToken" in credential;
+}
+
+/**
+ * Type guard to check if a credential is a Basic auth credential.
+ */
+export function isBasicCredential(credential: ClientCredential): credential is BasicCredential {
+  return "username" in credential && "password" in credential;
+}
+
+/**
+ * Type guard to check if a credential is an API key credential.
+ */
+export function isApiKeyCredential(credential: ClientCredential): credential is ApiKeyCredential {
+  return "key" in credential;
+}
diff --git a/src/auth/index.ts b/src/auth/index.ts
deleted file mode 100644
index 446268b..0000000
--- a/src/auth/index.ts
+++ /dev/null
@@ -1,20 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-export { HttpMethods } from "@azure/core-util";
-export { AzureKeyCredential } from "./azureKeyCredential.js";
-export { KeyCredential, isKeyCredential } from "./keyCredential.js";
-export {
-  AzureNamedKeyCredential,
-  NamedKeyCredential,
-  isNamedKeyCredential,
-} from "./azureNamedKeyCredential.js";
-export { AzureSASCredential, SASCredential, isSASCredential } from "./azureSASCredential.js";
-
-export {
-  TokenCredential,
-  GetTokenOptions,
-  AccessToken,
-  isTokenCredential,
-} from "./tokenCredential.js";
-
-export { TracingContext } from "./tracing.js";
diff --git a/src/auth/keyCredential.ts b/src/auth/keyCredential.ts
deleted file mode 100644
index 9db25cf..0000000
--- a/src/auth/keyCredential.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { isObjectWithProperties } from "@azure/core-util";
-
-/**
- * Represents a credential defined by a static API key.
- */
-export interface KeyCredential {
-  /**
-   * The value of the API key represented as a string
-   */
-  readonly key: string;
-}
-
-/**
- * Tests an object to determine whether it implements KeyCredential.
- *
- * @param credential - The assumed KeyCredential to be tested.
- */
-export function isKeyCredential(credential: unknown): credential is KeyCredential {
-  return isObjectWithProperties(credential, ["key"]) && typeof credential.key === "string";
-}
diff --git a/src/auth/oauth2Flows.ts b/src/auth/oauth2Flows.ts
new file mode 100644
index 0000000..01f42e5
--- /dev/null
+++ b/src/auth/oauth2Flows.ts
@@ -0,0 +1,67 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/**
+ * Represents OAuth2 Authorization Code flow configuration.
+ */
+export interface AuthorizationCodeFlow {
+  /** Type of OAuth2 flow */
+  kind: "authorizationCode";
+  /** Authorization endpoint */
+  authorizationUrl: string;
+  /** Token endpoint */
+  tokenUrl: string;
+  /** Refresh token endpoint */
+  refreshUrl?: string;
+  /** OAuth2 scopes */
+  scopes?: string[];
+}
+
+/**
+ * Represents OAuth2 Client Credentials flow configuration.
+ */
+export interface ClientCredentialsFlow {
+  /** Type of OAuth2 flow */
+  kind: "clientCredentials";
+  /** Token endpoint */
+  tokenUrl: string;
+  /** Refresh token endpoints */
+  refreshUrl?: string[];
+  /** OAuth2 scopes */
+  scopes?: string[];
+}
+
+/**
+ * Represents OAuth2 Implicit flow configuration.
+ */
+export interface ImplicitFlow {
+  /** Type of OAuth2 flow */
+  kind: "implicit";
+  /** Authorization endpoint */
+  authorizationUrl: string;
+  /** Refresh token endpoint */
+  refreshUrl?: string;
+  /** OAuth2 scopes */
+  scopes?: string[];
+}
+
+/**
+ * Represents OAuth2 Password flow configuration.
+ */
+export interface PasswordFlow {
+  /** Type of OAuth2 flow */
+  kind: "password";
+  /** Token endpoint */
+  tokenUrl: string;
+  /** Refresh token endpoint */
+  refreshUrl?: string;
+  /** OAuth2 scopes */
+  scopes?: string[];
+}
+
+/** Union type of all supported OAuth2 flows */
+export type OAuth2Flow =
+  | AuthorizationCodeFlow
+  | ClientCredentialsFlow
+  | ImplicitFlow
+  | PasswordFlow;
diff --git a/src/auth/schemes.ts b/src/auth/schemes.ts
new file mode 100644
index 0000000..b5fb17b
--- /dev/null
+++ b/src/auth/schemes.ts
@@ -0,0 +1,66 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { OAuth2Flow } from "./oauth2Flows.js";
+
+/**
+ * Represents HTTP Basic authentication scheme.
+ * Basic authentication scheme requires a username and password to be provided with each request.
+ * The credentials are encoded using Base64 and included in the Authorization header.
+ */
+export interface BasicAuthScheme {
+  /** Type of auth scheme */
+  kind: "http";
+  /** Basic authentication scheme */
+  scheme: "basic";
+}
+
+/**
+ * Represents HTTP Bearer authentication scheme.
+ * Bearer authentication scheme requires a bearer token to be provided with each request.
+ * The token is included in the Authorization header with the "Bearer" prefix.
+ */
+export interface BearerAuthScheme {
+  /** Type of auth scheme */
+  kind: "http";
+  /** Bearer authentication scheme */
+  scheme: "bearer";
+}
+
+/**
+ * Represents an endpoint or operation that requires no authentication.
+ */
+export interface NoAuthAuthScheme {
+  /** Type of auth scheme */
+  kind: "noAuth";
+}
+
+/**
+ * Represents API Key authentication scheme.
+ * API Key authentication requires a key to be provided with each request.
+ * The key can be provided in different locations: query parameter, header, or cookie.
+ */
+export interface ApiKeyAuthScheme {
+  /** Type of auth scheme */
+  kind: "apiKey";
+  /** Location of the API key */
+  apiKeyLocation: "query" | "header" | "cookie";
+  /** Name of the API key parameter */
+  name: string;
+}
+
+/** Represents OAuth2 authentication scheme with specified flows */
+export interface OAuth2AuthScheme<TFlows extends OAuth2Flow[]> {
+  /** Type of auth scheme */
+  kind: "oauth2";
+  /** Supported OAuth2 flows */
+  flows: TFlows;
+}
+
+/** Union type of all supported authentication schemes */
+export type AuthScheme =
+  | BasicAuthScheme
+  | BearerAuthScheme
+  | NoAuthAuthScheme
+  | ApiKeyAuthScheme
+  | OAuth2AuthScheme<OAuth2Flow[]>;
diff --git a/src/auth/tokenCredential.ts b/src/auth/tokenCredential.ts
deleted file mode 100644
index 395b112..0000000
--- a/src/auth/tokenCredential.ts
+++ /dev/null
@@ -1,148 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AbortSignalLike } from "@azure/abort-controller";
-import type { TracingContext } from "./tracing.js";
-import type { HttpMethods } from "@azure/core-util";
-
-/**
- * Represents a credential capable of providing an authentication token.
- */
-export interface TokenCredential {
-  /**
-   * Gets the token provided by this credential.
-   *
-   * This method is called automatically by Azure SDK client libraries. You may call this method
-   * directly, but you must also handle token caching and token refreshing.
-   *
-   * @param scopes - The list of scopes for which the token will have access.
-   * @param options - The options used to configure any requests this
-   *                TokenCredential implementation might make.
-   */
-  getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
-}
-
-/**
- * Defines options for TokenCredential.getToken.
- */
-export interface GetTokenOptions {
-  /**
-   * The signal which can be used to abort requests.
-   */
-  abortSignal?: AbortSignalLike;
-  /**
-   * Options used when creating and sending HTTP requests for this operation.
-   */
-  requestOptions?: {
-    /**
-     * The number of milliseconds a request can take before automatically being terminated.
-     */
-    timeout?: number;
-  };
-  /**
-   * Options used when tracing is enabled.
-   */
-  tracingOptions?: {
-    /**
-     * Tracing Context for the current request.
-     */
-    tracingContext?: TracingContext;
-  };
-  /**
-   * Claim details to perform the Continuous Access Evaluation authentication flow
-   */
-  claims?: string;
-  /**
-   * Indicates whether to enable the Continuous Access Evaluation authentication flow
-   */
-  enableCae?: boolean;
-  /**
-   * Allows specifying a tenantId. Useful to handle challenges that provide tenant Id hints.
-   */
-  tenantId?: string;
-
-  /**
-   * Options for Proof of Possession token requests
-   */
-  proofOfPossessionOptions?: {
-    /**
-     * The nonce value required for PoP token requests.
-     * This is typically retrieved from the WWW-Authenticate header of a 401 challenge response.
-     * This is used in combination with {@link resourceRequestUrl} and {@link resourceRequestMethod} to generate the PoP token.
-     */
-    nonce: string;
-    /**
-     * The HTTP method of the request.
-     * This is used in combination with {@link resourceRequestUrl} and {@link nonce} to generate the PoP token.
-     */
-    resourceRequestMethod: HttpMethods;
-    /**
-     * The URL of the request.
-     * This is used in combination with {@link resourceRequestMethod} and {@link nonce} to generate the PoP token.
-     */
-    resourceRequestUrl: string;
-  };
-}
-
-/**
- * Represents an access token with an expiration time.
- */
-export interface AccessToken {
-  /**
-   * The access token returned by the authentication service.
-   */
-  token: string;
-
-  /**
-   * The access token's expiration timestamp in milliseconds, UNIX epoch time.
-   */
-  expiresOnTimestamp: number;
-
-  /**
-   * The timestamp when the access token should be refreshed, in milliseconds, UNIX epoch time.
-   */
-  refreshAfterTimestamp?: number;
-
-  /** Type of token - `Bearer` or `pop` */
-  tokenType?: "Bearer" | "pop";
-}
-
-/**
- * @internal
- * @param accessToken - Access token
- * @returns Whether a token is bearer type or not
- */
-export function isBearerToken(accessToken: AccessToken): boolean {
-  return !accessToken.tokenType || accessToken.tokenType === "Bearer";
-}
-
-/**
- * @internal
- * @param accessToken - Access token
- * @returns Whether a token is Pop token or not
- */
-export function isPopToken(accessToken: AccessToken): boolean {
-  return accessToken.tokenType === "pop";
-}
-
-/**
- * Tests an object to determine whether it implements TokenCredential.
- *
- * @param credential - The assumed TokenCredential to be tested.
- */
-export function isTokenCredential(credential: unknown): credential is TokenCredential {
-  // Check for an object with a 'getToken' function and possibly with
-  // a 'signRequest' function.  We do this check to make sure that
-  // a ServiceClientCredentials implementor (like TokenClientCredentials
-  // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
-  // it doesn't actually implement TokenCredential also.
-  const castCredential = credential as {
-    getToken: unknown;
-    signRequest: unknown;
-  };
-  return (
-    castCredential &&
-    typeof castCredential.getToken === "function" &&
-    (castCredential.signRequest === undefined || castCredential.getToken.length > 0)
-  );
-}
diff --git a/src/auth/tracing.ts b/src/auth/tracing.ts
deleted file mode 100644
index 8e846bb..0000000
--- a/src/auth/tracing.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-// The interfaces in this file should be kept in sync with those
-// found in the `@azure/core-tracing` package.
-
-/**
- * An interface structurally compatible with OpenTelemetry.
- */
-export interface TracingContext {
-  /**
-   * Get a value from the context.
-   *
-   * @param key - key which identifies a context value
-   */
-  getValue(key: symbol): unknown;
-  /**
-   * Create a new context which inherits from this context and has
-   * the given key set to the given value.
-   *
-   * @param key - context key for which to set the value
-   * @param value - value to set for the given key
-   */
-  setValue(key: symbol, value: unknown): TracingContext;
-  /**
-   * Return a new context which inherits from this context but does
-   * not contain a value for the given key.
-   *
-   * @param key - context key for which to clear a value
-   */
-  deleteValue(key: symbol): TracingContext;
-}
diff --git a/src/client/apiVersionPolicy.ts b/src/client/apiVersionPolicy.ts
index 56cb7b8..da27584 100644
--- a/src/client/apiVersionPolicy.ts
+++ b/src/client/apiVersionPolicy.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { PipelinePolicy } from "@azure/core-rest-pipeline";
+import type { PipelinePolicy } from "../pipeline.js";
 import type { ClientOptions } from "./common.js";
 
 export const apiVersionPolicyName = "ApiVersionPolicy";
diff --git a/src/client/clientHelpers.ts b/src/client/clientHelpers.ts
index 30dac33..d0a5cc1 100644
--- a/src/client/clientHelpers.ts
+++ b/src/client/clientHelpers.ts
@@ -1,84 +1,55 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { HttpClient, Pipeline } from "@azure/core-rest-pipeline";
-import {
-  bearerTokenAuthenticationPolicy,
-  createDefaultHttpClient,
-  createPipelineFromOptions,
-} from "@azure/core-rest-pipeline";
-import type { KeyCredential, TokenCredential } from "@azure/core-auth";
-import { isTokenCredential } from "@azure/core-auth";
-
+import type { HttpClient } from "../interfaces.js";
+import type { Pipeline } from "../pipeline.js";
+import { createDefaultHttpClient } from "../defaultHttpClient.js";
+import { createPipelineFromOptions } from "../createPipelineFromOptions.js";
 import type { ClientOptions } from "./common.js";
 import { apiVersionPolicy } from "./apiVersionPolicy.js";
-import { keyCredentialAuthenticationPolicy } from "./keyCredentialAuthenticationPolicy.js";
+import {
+  isApiKeyCredential,
+  isBasicCredential,
+  isBearerTokenCredential,
+  isOAuth2TokenCredential,
+} from "../auth/credentials.js";
+import { apiKeyAuthenticationPolicy } from "../policies/auth/apiKeyAuthenticationPolicy.js";
+import { basicAuthenticationPolicy } from "../policies/auth/basicAuthenticationPolicy.js";
+import { bearerAuthenticationPolicy } from "../policies/auth/bearerAuthenticationPolicy.js";
+import { oauth2AuthenticationPolicy } from "../policies/auth/oauth2AuthenticationPolicy.js";
 
 let cachedHttpClient: HttpClient | undefined;
 
-/**
- * Optional parameters for adding a credential policy to the pipeline.
- */
-export interface AddCredentialPipelinePolicyOptions {
-  /**
-   * Options related to the client.
-   */
-  clientOptions?: ClientOptions;
-  /**
-   * The credential to use.
-   */
-  credential?: TokenCredential | KeyCredential;
-}
-
-/**
- * Adds a credential policy to the pipeline if a credential is provided. If none is provided, no policy is added.
- */
-export function addCredentialPipelinePolicy(
-  pipeline: Pipeline,
-  endpoint: string,
-  options: AddCredentialPipelinePolicyOptions = {},
-): void {
-  const { credential, clientOptions } = options;
-  if (!credential) {
-    return;
-  }
-
-  if (isTokenCredential(credential)) {
-    const tokenPolicy = bearerTokenAuthenticationPolicy({
-      credential,
-      scopes: clientOptions?.credentials?.scopes ?? `${endpoint}/.default`,
-    });
-    pipeline.addPolicy(tokenPolicy);
-  } else if (isKeyCredential(credential)) {
-    if (!clientOptions?.credentials?.apiKeyHeaderName) {
-      throw new Error(`Missing API Key Header Name`);
-    }
-    const keyPolicy = keyCredentialAuthenticationPolicy(
-      credential,
-      clientOptions?.credentials?.apiKeyHeaderName,
-    );
-    pipeline.addPolicy(keyPolicy);
-  }
-}
-
 /**
  * Creates a default rest pipeline to re-use accross Rest Level Clients
  */
-export function createDefaultPipeline(
-  endpoint: string,
-  credential?: TokenCredential | KeyCredential,
-  options: ClientOptions = {},
-): Pipeline {
+export function createDefaultPipeline(options: ClientOptions = {}): Pipeline {
   const pipeline = createPipelineFromOptions(options);
 
   pipeline.addPolicy(apiVersionPolicy(options));
 
-  addCredentialPipelinePolicy(pipeline, endpoint, { credential, clientOptions: options });
-  return pipeline;
+  const { credential, authSchemes, allowInsecureConnection } = options;
+  if (credential) {
+    if (isApiKeyCredential(credential)) {
+      pipeline.addPolicy(
+        apiKeyAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection }),
+      );
+    } else if (isBasicCredential(credential)) {
+      pipeline.addPolicy(
+        basicAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection }),
+      );
+    } else if (isBearerTokenCredential(credential)) {
+      pipeline.addPolicy(
+        bearerAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection }),
+      );
+    } else if (isOAuth2TokenCredential(credential)) {
+      pipeline.addPolicy(
+        oauth2AuthenticationPolicy({ authSchemes, credential, allowInsecureConnection }),
+      );
+    }
   }
 
-function isKeyCredential(credential: any): credential is KeyCredential {
-  return (credential as KeyCredential).key !== undefined;
+  return pipeline;
 }
 
 export function getCachedDefaultHttpsClient(): HttpClient {
diff --git a/src/client/common.ts b/src/client/common.ts
index 58f6eba..2fd91b4 100644
--- a/src/client/common.ts
+++ b/src/client/common.ts
@@ -3,19 +3,18 @@
 
 import type {
   HttpClient,
-  LogPolicyOptions,
-  Pipeline,
-  PipelineOptions,
-  PipelinePolicy,
   PipelineRequest,
   PipelineResponse,
   RawHttpHeaders,
   RequestBodyType,
   TransferProgressEvent,
-} from "@azure/core-rest-pipeline";
-import type { RawHttpHeadersInput } from "@azure/core-rest-pipeline";
-import type { AbortSignalLike } from "@azure/abort-controller";
-import type { OperationTracingOptions } from "@azure/core-tracing";
+  RawHttpHeadersInput,
+} from "../interfaces.js";
+import type { Pipeline, PipelinePolicy } from "../pipeline.js";
+import type { PipelineOptions } from "../createPipelineFromOptions.js";
+import type { LogPolicyOptions } from "../policies/logPolicy.js";
+import type { AuthScheme } from "../auth/schemes.js";
+import type { ClientCredential } from "../auth/credentials.js";
 
 /**
  * Shape of the default request parameters, this may be overridden by the specific
@@ -72,12 +71,7 @@ export type RequestParameters = {
   /**
    * The signal which can be used to abort requests.
    */
-  abortSignal?: AbortSignalLike;
-
-  /**
-   * Options used when tracing is enabled.
-   */
-  tracingOptions?: OperationTracingOptions;
+  abortSignal?: AbortSignal;
 
   /**
    * A function to be called each time a response is received from the server
@@ -91,16 +85,9 @@ export type RequestParameters = {
  * A function to be called each time a response is received from the server
  * while performing the requested operation.
  * May be called multiple times.
- *
- * This callback will be called with two parameters: the raw response, including headers and response body; and an error
- * object which will be provided if an error was thrown while processing the request.
- * The third __legacyError parameter is provided for backwards compatability only and will have an identical value to the `error` parameter.
  */
-export type RawResponseCallback = (
-  rawResponse: FullOperationResponse,
-  error?: unknown,
-  __legacyError?: unknown,
-) => void;
+// UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError parameter which was provided for backwards compatibility
+export type RawResponseCallback = (rawResponse: FullOperationResponse, error?: unknown) => void;
 
 /**
  * Wrapper object for http request and response. Deserialized object is stored in
@@ -130,16 +117,11 @@ export interface OperationOptions {
   /**
    * The signal which can be used to abort requests.
    */
-  abortSignal?: AbortSignalLike;
+  abortSignal?: AbortSignal;
   /**
    * Options used when creating and sending HTTP requests for this operation.
    */
   requestOptions?: OperationRequestOptions;
-  /**
-   * Options used when tracing is enabled.
-   */
-  tracingOptions?: OperationTracingOptions;
-
   /**
    * A function to be called each time a response is received from the server
    * while performing the requested operation.
@@ -201,8 +183,8 @@ export interface Client {
    * This method will be used to send request that would check the path to provide
    * strong types. When used by the codegen this type gets overridden with the generated
    * types. For example:
-   * ```typescript snippet:PathExample
-   * import { Client } from "@azure-rest/core-client";
+   * ```typescript snippet:ReadmeSamplePathExample
+   * import { Client } from "@typespec/ts-http-runtime";
    *
    * type MyClient = Client & {
    *   path: Routes;
@@ -217,18 +199,6 @@ export interface Client {
   pathUnchecked: PathUnchecked;
 }
 
-/**
- * A Node.js Readable stream that also has a `destroy` method.
- */
-export interface NodeJSReadableStream extends NodeJS.ReadableStream {
-  /**
-   * Destroy the stream. Optionally emit an 'error' event, and emit a
-   * 'close' event (unless emitClose is set to false). After this call,
-   * internal resources will be released.
-   */
-  destroy(error?: Error): void;
-}
-
 /**
  * Http Response which body is a NodeJS stream object
  */
@@ -236,7 +206,7 @@ export type HttpNodeStreamResponse = HttpResponse & {
   /**
    * Streamable body
    */
-  body?: NodeJSReadableStream;
+  body?: NodeJS.ReadableStream;
 };
 
 /**
@@ -333,23 +303,19 @@ export interface AdditionalPolicyConfig {
  */
 export type ClientOptions = PipelineOptions & {
   /**
-   * Credentials information
-   */
-  credentials?: {
-    /**
-     * Authentication scopes for AAD
-     */
-    scopes?: string[];
-    /**
-     * Heder name for Client Secret authentication
+   * List of authentication schemes supported by the client.
+   * These schemes define how the client can authenticate requests.
    */
-    apiKeyHeaderName?: string;
-  };
+  authSchemes?: AuthScheme[];
+
   /**
-   * Base url for the client
-   * @deprecated This property is deprecated and will be removed soon, please use endpoint instead
+   * The credential used to authenticate requests.
+   * Must be compatible with one of the specified authentication schemes.
    */
-  baseUrl?: string;
+  credential?: ClientCredential;
+
+  // UNBRANDED DIFFERENCE: The deprecated baseUrl property is removed in favor of the endpoint property in the unbranded Core package
+
   /**
    * Endpoint for the client
    */
diff --git a/src/client/getClient.ts b/src/client/getClient.ts
index 05bd395..e3f46d2 100644
--- a/src/client/getClient.ts
+++ b/src/client/getClient.ts
@@ -1,9 +1,8 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { KeyCredential, TokenCredential } from "@azure/core-auth";
-import { isKeyCredential, isTokenCredential } from "@azure/core-auth";
-import type { HttpClient, HttpMethods, Pipeline, PipelineOptions } from "@azure/core-rest-pipeline";
+import type { HttpClient, HttpMethods } from "../interfaces.js";
+import type { Pipeline } from "../pipeline.js";
 import { createDefaultPipeline } from "./clientHelpers.js";
 import type {
   Client,
@@ -11,44 +10,21 @@ import type {
   HttpBrowserStreamResponse,
   HttpNodeStreamResponse,
   RequestParameters,
+  ResourceMethods,
   StreamableMethod,
 } from "./common.js";
 import { sendRequest } from "./sendRequest.js";
 import { buildRequestUrl } from "./urlHelpers.js";
-import { isNodeLike } from "@azure/core-util";
+import { isNodeLike } from "../util/checkEnvironment.js";
 
-/**
- * Creates a client with a default pipeline
- * @param endpoint - Base endpoint for the client
- * @param options - Client options
- */
-export function getClient(endpoint: string, options?: ClientOptions): Client;
 /**
  * Creates a client with a default pipeline
  * @param endpoint - Base endpoint for the client
  * @param credentials - Credentials to authenticate the requests
  * @param options - Client options
  */
-export function getClient(
-  endpoint: string,
-  credentials?: TokenCredential | KeyCredential,
-  options?: ClientOptions,
-): Client;
-export function getClient(
-  endpoint: string,
-  credentialsOrPipelineOptions?: (TokenCredential | KeyCredential) | ClientOptions,
-  clientOptions: ClientOptions = {},
-): Client {
-  let credentials: TokenCredential | KeyCredential | undefined;
-  if (credentialsOrPipelineOptions) {
-    if (isCredential(credentialsOrPipelineOptions)) {
-      credentials = credentialsOrPipelineOptions;
-    } else {
-      clientOptions = credentialsOrPipelineOptions ?? {};
-    }
-  }
-
-  const pipeline = createDefaultPipeline(endpoint, credentials, clientOptions);
+export function getClient(endpoint: string, clientOptions: ClientOptions = {}): Client {
+  const pipeline = createDefaultPipeline(clientOptions);
   if (clientOptions.additionalPolicies?.length) {
     for (const { policy, position } of clientOptions.additionalPolicies) {
       // Sign happens after Retry and is commonly needed to occur
@@ -62,8 +38,8 @@ export function getClient(
 
   const { allowInsecureConnection, httpClient } = clientOptions;
   const endpointUrl = clientOptions.endpoint ?? endpoint;
-  const client = (path: string, ...args: Array<any>) => {
-    const getUrl = (requestOptions: RequestParameters) =>
+  const client = (path: string, ...args: Array<any>): ResourceMethods<StreamableMethod> => {
+    const getUrl = (requestOptions: RequestParameters): string =>
       buildRequestUrl(endpointUrl, path, args, { allowInsecureConnection, ...requestOptions });
 
     return {
@@ -208,9 +184,3 @@ function buildOperation(
     },
   };
 }
-
-function isCredential(
-  param: (TokenCredential | KeyCredential) | PipelineOptions,
-): param is TokenCredential | KeyCredential {
-  return isKeyCredential(param) || isTokenCredential(param);
-}
diff --git a/src/client/helpers/isBinaryBody.ts b/src/client/helpers/isBinaryBody.ts
deleted file mode 100644
index ef06c77..0000000
--- a/src/client/helpers/isBinaryBody.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { isReadableStream } from "./isReadableStream.js";
-
-export function isBinaryBody(
-  body: unknown,
-): body is
-  | Uint8Array
-  | NodeJS.ReadableStream
-  | ReadableStream<Uint8Array>
-  | (() => NodeJS.ReadableStream)
-  | (() => ReadableStream<Uint8Array>)
-  | Blob {
-  return (
-    body !== undefined &&
-    (body instanceof Uint8Array ||
-      isReadableStream(body) ||
-      typeof body === "function" ||
-      body instanceof Blob)
-  );
-}
diff --git a/src/client/helpers/isReadableStream-browser.mts b/src/client/helpers/isReadableStream-browser.mts
deleted file mode 100644
index 9d792bd..0000000
--- a/src/client/helpers/isReadableStream-browser.mts
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * Checks if the body is a ReadableStream supported by browsers
- * @internal
- */
-export function isReadableStream(body: unknown): body is ReadableStream {
-  return Boolean(
-    body &&
-      typeof (body as ReadableStream).getReader === "function" &&
-      typeof (body as ReadableStream).tee === "function",
-  );
-}
diff --git a/src/client/helpers/isReadableStream.ts b/src/client/helpers/isReadableStream.ts
deleted file mode 100644
index 5963319..0000000
--- a/src/client/helpers/isReadableStream.ts
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * Checks if the body is a ReadableStream supported by Node
- * @internal
- */
-export function isReadableStream(body: unknown): body is NodeJS.ReadableStream {
-  return Boolean(body) && typeof (body as any).pipe === "function";
-}
diff --git a/src/client/index.ts b/src/client/index.ts
deleted file mode 100644
index 1cd7d94..0000000
--- a/src/client/index.ts
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * Azure Rest Core Client library for JavaScript
- * @packageDocumentation
- */
-
-export { createRestError } from "./restError.js";
-export {
-  addCredentialPipelinePolicy,
-  AddCredentialPipelinePolicyOptions,
-} from "./clientHelpers.js";
-export { operationOptionsToRequestParameters } from "./operationOptionHelpers.js";
-export * from "./getClient.js";
-export * from "./common.js";
diff --git a/src/client/keyCredentialAuthenticationPolicy.ts b/src/client/keyCredentialAuthenticationPolicy.ts
deleted file mode 100644
index 06bc091..0000000
--- a/src/client/keyCredentialAuthenticationPolicy.ts
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { KeyCredential } from "@azure/core-auth";
-import type {
-  PipelinePolicy,
-  PipelineRequest,
-  PipelineResponse,
-  SendRequest,
-} from "@azure/core-rest-pipeline";
-
-/**
- * The programmatic identifier of the bearerTokenAuthenticationPolicy.
- */
-export const keyCredentialAuthenticationPolicyName = "keyCredentialAuthenticationPolicy";
-
-export function keyCredentialAuthenticationPolicy(
-  credential: KeyCredential,
-  apiKeyHeaderName: string,
-): PipelinePolicy {
-  return {
-    name: keyCredentialAuthenticationPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      request.headers.set(apiKeyHeaderName, credential.key);
-      return next(request);
-    },
-  };
-}
diff --git a/src/client/multipart.ts b/src/client/multipart.ts
index 175b5cd..102ed57 100644
--- a/src/client/multipart.ts
+++ b/src/client/multipart.ts
@@ -1,14 +1,11 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type {
-  BodyPart,
-  MultipartRequestBody,
-  RawHttpHeadersInput,
-} from "@azure/core-rest-pipeline";
-import { RestError, createHttpHeaders } from "@azure/core-rest-pipeline";
-import { stringToUint8Array } from "@azure/core-util";
-import { isBinaryBody } from "./helpers/isBinaryBody.js";
+import type { BodyPart, MultipartRequestBody, RawHttpHeadersInput } from "../interfaces.js";
+import { RestError } from "../restError.js";
+import { createHttpHeaders } from "../httpHeaders.js";
+import { stringToUint8Array } from "../util/bytesEncoding.js";
+import { isBinaryBody } from "../util/typeGuards.js";
 
 /**
  * Describes a single part in a multipart body.
diff --git a/src/client/operationOptionHelpers.ts b/src/client/operationOptionHelpers.ts
index c7c1eb6..15bdc45 100644
--- a/src/client/operationOptionHelpers.ts
+++ b/src/client/operationOptionHelpers.ts
@@ -16,7 +16,6 @@ export function operationOptionsToRequestParameters(options: OperationOptions):
     abortSignal: options.abortSignal,
     onUploadProgress: options.requestOptions?.onUploadProgress,
     onDownloadProgress: options.requestOptions?.onDownloadProgress,
-    tracingOptions: options.tracingOptions,
     headers: { ...options.requestOptions?.headers },
     onResponse: options.onResponse,
   };
diff --git a/src/client/restError.ts b/src/client/restError.ts
index 747e774..6b630ef 100644
--- a/src/client/restError.ts
+++ b/src/client/restError.ts
@@ -1,8 +1,9 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { PipelineResponse } from "@azure/core-rest-pipeline";
-import { RestError, createHttpHeaders } from "@azure/core-rest-pipeline";
+import type { PipelineResponse } from "../interfaces.js";
+import { RestError } from "../restError.js";
+import { createHttpHeaders } from "../httpHeaders.js";
 import type { PathUncheckedResponse } from "./common.js";
 
 /**
diff --git a/src/client/sendRequest.ts b/src/client/sendRequest.ts
index 4ee4778..dc3b0f5 100644
--- a/src/client/sendRequest.ts
+++ b/src/client/sendRequest.ts
@@ -5,19 +5,16 @@ import type {
   HttpClient,
   HttpMethods,
   MultipartRequestBody,
-  Pipeline,
   PipelineRequest,
   PipelineResponse,
   RequestBodyType,
-} from "@azure/core-rest-pipeline";
-import {
-  RestError,
-  createHttpHeaders,
-  createPipelineRequest,
-  isRestError,
-} from "@azure/core-rest-pipeline";
+} from "../interfaces.js";
+import { isRestError, RestError } from "../restError.js";
+import type { Pipeline } from "../pipeline.js";
+import { createHttpHeaders } from "../httpHeaders.js";
+import { createPipelineRequest } from "../pipelineRequest.js";
 import { getCachedDefaultHttpsClient } from "./clientHelpers.js";
-import { isReadableStream } from "./helpers/isReadableStream.js";
+import { isReadableStream } from "../util/typeGuards.js";
 import type { HttpResponse, RequestParameters } from "./common.js";
 import type { PartDescriptor } from "./multipart.js";
 import { buildMultipartBody } from "./multipart.js";
@@ -63,7 +60,8 @@ export async function sendRequest(
     if (isRestError(e) && e.response && options.onResponse) {
       const { response } = e;
       const rawHeaders = response.headers.toJSON();
-      options?.onResponse({ ...response, request, rawHeaders }, e, e);
+      // UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError property
+      options?.onResponse({ ...response, request, rawHeaders }, e);
     }
 
     throw e;
@@ -136,7 +134,6 @@ function buildPipelineRequest(
     multipartBody,
     headers,
     allowInsecureConnection: options.allowInsecureConnection,
-    tracingOptions: options.tracingOptions,
     abortSignal: options.abortSignal,
     onUploadProgress: options.onUploadProgress,
     onDownloadProgress: options.onDownloadProgress,
diff --git a/src/constants.ts b/src/constants.ts
index 201ff0d..248a49a 100644
--- a/src/constants.ts
+++ b/src/constants.ts
@@ -1,6 +1,6 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-export const SDK_VERSION: string = "1.19.2";
+export const SDK_VERSION: string = "0.2.1";
 
 export const DEFAULT_RETRY_POLICY_COUNT = 3;
diff --git a/src/createPipelineFromOptions.ts b/src/createPipelineFromOptions.ts
index fefe550..fb56a78 100644
--- a/src/createPipelineFromOptions.ts
+++ b/src/createPipelineFromOptions.ts
@@ -6,16 +6,14 @@ import { type Pipeline, createEmptyPipeline } from "./pipeline.js";
 import type { Agent, PipelineRetryOptions, ProxySettings, TlsSettings } from "./interfaces.js";
 import { type RedirectPolicyOptions, redirectPolicy } from "./policies/redirectPolicy.js";
 import { type UserAgentPolicyOptions, userAgentPolicy } from "./policies/userAgentPolicy.js";
-import { multipartPolicy, multipartPolicyName } from "./policies/multipartPolicy.js";
 import { decompressResponsePolicy } from "./policies/decompressResponsePolicy.js";
 import { defaultRetryPolicy } from "./policies/defaultRetryPolicy.js";
 import { formDataPolicy } from "./policies/formDataPolicy.js";
-import { isNodeLike } from "@azure/core-util";
+import { isNodeLike } from "./util/checkEnvironment.js";
 import { proxyPolicy } from "./policies/proxyPolicy.js";
-import { setClientRequestIdPolicy } from "./policies/setClientRequestIdPolicy.js";
 import { agentPolicy } from "./policies/agentPolicy.js";
 import { tlsPolicy } from "./policies/tlsPolicy.js";
-import { tracingPolicy } from "./policies/tracingPolicy.js";
+import { multipartPolicy, multipartPolicyName } from "./policies/multipartPolicy.js";
 
 /**
  * Defines options that are used to configure the HTTP pipeline for
@@ -95,15 +93,11 @@ export function createPipelineFromOptions(options: InternalPipelineOptions): Pip
 
   pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });
   pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
-  pipeline.addPolicy(setClientRequestIdPolicy(options.telemetryOptions?.clientRequestIdHeaderName));
   // The multipart policy is added after policies with no phase, so that
   // policies can be added between it and formDataPolicy to modify
   // properties (e.g., making the boundary constant in recorded tests).
   pipeline.addPolicy(multipartPolicy(), { afterPhase: "Deserialize" });
   pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
-  pipeline.addPolicy(tracingPolicy({ ...options.userAgentOptions, ...options.loggingOptions }), {
-    afterPhase: "Retry",
-  });
   if (isNodeLike) {
     // Both XHR and Fetch expect to handle redirects automatically,
     // so only include this policy when we're in Node.
diff --git a/src/fetchHttpClient.ts b/src/fetchHttpClient.ts
index ad162e3..ae5349c 100644
--- a/src/fetchHttpClient.ts
+++ b/src/fetchHttpClient.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { AbortError } from "@azure/abort-controller";
+import { AbortError } from "./abort-controller/AbortError.js";
 import type {
   HttpClient,
   HttpHeaders as PipelineHeaders,
diff --git a/src/index.ts b/src/index.ts
index 92a7ee9..e7d682b 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -9,116 +9,74 @@ declare global {
   interface TransformStream<I = any, O = any> {}
 }
 
-export type { HttpMethods } from "@azure/core-util";
+export { AbortError } from "./abort-controller/AbortError.js";
+export {
+  createClientLogger,
+  TypeSpecRuntimeLogger,
+  type TypeSpecRuntimeClientLogger,
+  type Debugger,
+} from "./logger/logger.js";
 export type {
-  Agent,
   BodyPart,
-  FormDataMap,
   FormDataValue,
-  HttpClient,
-  HttpHeaders,
+  RawHttpHeaders,
   KeyObject,
-  MultipartRequestBody,
+  PxfObject,
+  HttpClient,
   PipelineRequest,
   PipelineResponse,
-  PipelineRetryOptions,
-  ProxySettings,
-  PxfObject,
-  RawHttpHeaders,
-  RawHttpHeadersInput,
-  RequestBodyType,
   SendRequest,
   TlsSettings,
+  Agent,
+  RequestBodyType,
+  FormDataMap,
+  HttpHeaders,
+  HttpMethods,
+  MultipartRequestBody,
   TransferProgressEvent,
+  ProxySettings,
+  RawHttpHeadersInput,
+  PipelineRetryOptions,
 } from "./interfaces.js";
-export {
-  type AddPolicyOptions as AddPipelineOptions,
-  type PipelinePhase,
-  type PipelinePolicy,
-  type Pipeline,
-  createEmptyPipeline,
-} from "./pipeline.js";
-export {
-  createPipelineFromOptions,
-  type TelemetryOptions,
-  type InternalPipelineOptions,
-  type PipelineOptions,
-} from "./createPipelineFromOptions.js";
-export { createDefaultHttpClient } from "./defaultHttpClient.js";
 export { createHttpHeaders } from "./httpHeaders.js";
-export { createPipelineRequest, type PipelineRequestOptions } from "./pipelineRequest.js";
-export { RestError, type RestErrorOptions, isRestError } from "./restError.js";
-export {
-  decompressResponsePolicy,
-  decompressResponsePolicyName,
-} from "./policies/decompressResponsePolicy.js";
-export {
-  exponentialRetryPolicy,
-  type ExponentialRetryPolicyOptions,
-  exponentialRetryPolicyName,
-} from "./policies/exponentialRetryPolicy.js";
-export {
-  setClientRequestIdPolicy,
-  setClientRequestIdPolicyName,
-} from "./policies/setClientRequestIdPolicy.js";
-export { logPolicy, logPolicyName, type LogPolicyOptions } from "./policies/logPolicy.js";
-export { multipartPolicy, multipartPolicyName } from "./policies/multipartPolicy.js";
-export { proxyPolicy, proxyPolicyName, getDefaultProxySettings } from "./policies/proxyPolicy.js";
+export * from "./auth/schemes.js";
+export * from "./auth/oauth2Flows.js";
 export {
-  redirectPolicy,
-  redirectPolicyName,
-  type RedirectPolicyOptions,
-} from "./policies/redirectPolicy.js";
-export {
-  systemErrorRetryPolicy,
-  type SystemErrorRetryPolicyOptions,
-  systemErrorRetryPolicyName,
-} from "./policies/systemErrorRetryPolicy.js";
-export {
-  throttlingRetryPolicy,
-  throttlingRetryPolicyName,
-  type ThrottlingRetryPolicyOptions,
-} from "./policies/throttlingRetryPolicy.js";
-export { retryPolicy, type RetryPolicyOptions } from "./policies/retryPolicy.js";
+  type BasicCredential,
+  type BearerTokenCredential,
+  type OAuth2TokenCredential,
+  type GetOAuth2TokenOptions,
+  type GetBearerTokenOptions,
+  type ApiKeyCredential,
+  type ClientCredential,
+} from "./auth/credentials.js";
+export { createPipelineRequest, type PipelineRequestOptions } from "./pipelineRequest.js";
+export type { Pipeline, PipelinePolicy, AddPolicyOptions, PipelinePhase } from "./pipeline.js";
+export { RestError, isRestError, type RestErrorOptions } from "./restError.js";
+export { stringToUint8Array, uint8ArrayToString, type EncodingType } from "./util/bytesEncoding.js";
+export { getClient } from "./client/getClient.js";
+export { operationOptionsToRequestParameters } from "./client/operationOptionHelpers.js";
+export { createRestError } from "./client/restError.js";
 export type {
-  RetryStrategy,
-  RetryInformation,
-  RetryModifiers,
-} from "./retryStrategies/retryStrategy.js";
-export {
-  tracingPolicy,
-  tracingPolicyName,
-  type TracingPolicyOptions,
-} from "./policies/tracingPolicy.js";
-export {
-  defaultRetryPolicy,
-  type DefaultRetryPolicyOptions,
-} from "./policies/defaultRetryPolicy.js";
-export {
-  userAgentPolicy,
-  userAgentPolicyName,
-  type UserAgentPolicyOptions,
-} from "./policies/userAgentPolicy.js";
-export { tlsPolicy, tlsPolicyName } from "./policies/tlsPolicy.js";
-export { formDataPolicy, formDataPolicyName } from "./policies/formDataPolicy.js";
-export {
-  bearerTokenAuthenticationPolicy,
-  type BearerTokenAuthenticationPolicyOptions,
-  bearerTokenAuthenticationPolicyName,
-  type ChallengeCallbacks,
-  type AuthorizeRequestOptions,
-  type AuthorizeRequestOnChallengeOptions,
-} from "./policies/bearerTokenAuthenticationPolicy.js";
-export { ndJsonPolicy, ndJsonPolicyName } from "./policies/ndJsonPolicy.js";
-export {
-  auxiliaryAuthenticationHeaderPolicy,
-  type AuxiliaryAuthenticationHeaderPolicyOptions,
-  auxiliaryAuthenticationHeaderPolicyName,
-} from "./policies/auxiliaryAuthenticationHeaderPolicy.js";
-export { agentPolicy, agentPolicyName } from "./policies/agentPolicy.js";
-export {
-  createFile,
-  createFileFromStream,
-  type CreateFileOptions,
-  type CreateFileFromStreamOptions,
-} from "./util/file.js";
+  Client,
+  ClientOptions,
+  OperationOptions,
+  AdditionalPolicyConfig,
+  PathUnchecked,
+  PathUncheckedResponse,
+  HttpResponse,
+  RawResponseCallback,
+  OperationRequestOptions,
+  PathParameters,
+  ResourceMethods,
+  PathParameterWithOptions,
+  StreamableMethod,
+  RequestParameters,
+  HttpNodeStreamResponse,
+  HttpBrowserStreamResponse,
+  FullOperationResponse,
+} from "./client/common.js";
+export type { PipelineOptions, TelemetryOptions } from "./createPipelineFromOptions.js";
+export type { LogPolicyOptions } from "./policies/logPolicy.js";
+export type { RedirectPolicyOptions } from "./policies/redirectPolicy.js";
+export type { UserAgentPolicyOptions } from "./policies/userAgentPolicy.js";
diff --git a/src/interfaces.ts b/src/interfaces.ts
index ae5513d..28b26c8 100644
--- a/src/interfaces.ts
+++ b/src/interfaces.ts
@@ -1,9 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { AbortSignalLike } from "@azure/abort-controller";
-import type { OperationTracingOptions } from "@azure/core-tracing";
-import type { HttpMethods } from "@azure/core-util";
+import type { AuthScheme } from "./auth/schemes.js";
 
 /**
  * A HttpHeaders collection represented as a simple JSON object.
@@ -135,6 +133,15 @@ export interface Agent {
  * Metadata about a request being made by the pipeline.
  */
 export interface PipelineRequest {
+  /**
+   * List of authentication schemes used for this specific request.
+   * These schemes define how the request will be authenticated.
+   * If provided, these schemes override the client level authentication schemes.
+   *
+   * If no auth schemes are provided at client or request level, defaults to no auth.
+   */
+  authSchemes?: AuthScheme[];
+
   /**
    * The URL to make the request to.
    */
@@ -202,12 +209,7 @@ export interface PipelineRequest {
   /**
    * Used to abort the request later.
    */
-  abortSignal?: AbortSignalLike;
-
-  /**
-   * Tracing options to use for any created Spans.
-   */
-  tracingOptions?: OperationTracingOptions;
+  abortSignal?: AbortSignal;
 
   /**
    * Callback which fires upon upload progress.
@@ -315,6 +317,21 @@ export type TransferProgressEvent = {
   loadedBytes: number;
 };
 
+// UNBRANDED DIFFERENCE: HttpMethods are defined at the top level in unbranded instead of core-util since we don't
+//                       need to worry about creating a cyclic dependency
+/**
+ * Supported HTTP methods to use when making requests.
+ */
+export type HttpMethods =
+  | "GET"
+  | "PUT"
+  | "POST"
+  | "DELETE"
+  | "PATCH"
+  | "HEAD"
+  | "OPTIONS"
+  | "TRACE";
+
 /**
  * Options to configure a proxy for outgoing requests (Node.js only).
  */
diff --git a/src/log.ts b/src/log.ts
index db967c2..32452a9 100644
--- a/src/log.ts
+++ b/src/log.ts
@@ -1,5 +1,5 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { createClientLogger } from "@azure/logger";
-export const logger = createClientLogger("core-rest-pipeline");
+import { createClientLogger } from "./logger/logger.js";
+export const logger = createClientLogger("ts-http-runtime");
diff --git a/src/logger/debug.ts b/src/logger/debug.ts
index d29ccec..3ba9f34 100644
--- a/src/logger/debug.ts
+++ b/src/logger/debug.ts
@@ -19,9 +19,9 @@ export interface Debug {
   /**
    * Enables a particular set of namespaces.
    * To enable multiple separate them with commas, e.g. "info,debug".
-   * Supports wildcards, e.g. "azure:*"
-   * Supports skip syntax, e.g. "azure:*,-azure:storage:*" will enable
-   * everything under azure except for things under azure:storage.
+   * Supports wildcards, e.g. "typeSpecRuntime:*"
+   * Supports skip syntax, e.g. "typeSpecRuntime:*,-typeSpecRuntime:storage:*" will enable
+   * everything under typeSpecRuntime except for things under typeSpecRuntime:storage.
    */
   enable: (namespaces: string) => void;
   /**
diff --git a/src/logger/index.ts b/src/logger/logger.ts
similarity index 52%
rename from src/logger/index.ts
rename to src/logger/logger.ts
index 3e33a3b..3654566 100644
--- a/src/logger/index.ts
+++ b/src/logger/logger.ts
@@ -1,22 +1,24 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import debug, { type Debugger } from "./debug.js";
-export type { Debugger } from "./debug.js";
+import type { Debugger } from "./debug.js";
+import debug from "./debug.js";
+export { Debugger } from "./debug.js";
 
-const registeredLoggers = new Set<AzureDebugger>();
+const registeredLoggers = new Set<TypeSpecRuntimeDebugger>();
 const logLevelFromEnv =
-  (typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;
+  (typeof process !== "undefined" && process.env && process.env.TYPESPEC_RUNTIME_LOG_LEVEL) ||
+  undefined;
 
-let azureLogLevel: AzureLogLevel | undefined;
+let typeSpecRuntimeLogLevel: TypeSpecRuntimeLogLevel | undefined;
 
 /**
- * The AzureLogger provides a mechanism for overriding where logs are output to.
+ * The TypeSpecRuntimeLogger provides a mechanism for overriding where logs are output to.
  * By default, logs are sent to stderr.
  * Override the `log` method to redirect logs to another location.
  */
-export const AzureLogger: AzureClientLogger = debug("azure");
-AzureLogger.log = (...args) => {
+export const TypeSpecRuntimeLogger: TypeSpecRuntimeClientLogger = debug("typeSpecRuntime");
+TypeSpecRuntimeLogger.log = (...args) => {
   debug.log(...args);
 };
 
@@ -28,23 +30,23 @@ AzureLogger.log = (...args) => {
  * - warning
  * - error
  */
-export type AzureLogLevel = "verbose" | "info" | "warning" | "error";
-const AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
+export type TypeSpecRuntimeLogLevel = "verbose" | "info" | "warning" | "error";
+const TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
 
-type AzureDebugger = Debugger & { level: AzureLogLevel };
+type TypeSpecRuntimeDebugger = Debugger & { level: TypeSpecRuntimeLogLevel };
 
 /**
- * An AzureClientLogger is a function that can log to an appropriate severity level.
+ * An TypeSpecRuntimeClientLogger is a function that can log to an appropriate severity level.
  */
-export type AzureClientLogger = Debugger;
+export type TypeSpecRuntimeClientLogger = Debugger;
 
 if (logLevelFromEnv) {
   // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
-  if (isAzureLogLevel(logLevelFromEnv)) {
+  if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
     setLogLevel(logLevelFromEnv);
   } else {
     console.error(
-      `AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(
+      `TYPESPEC_RUNTIME_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(
         ", ",
       )}.`,
     );
@@ -60,13 +62,13 @@ if (logLevelFromEnv) {
  * - warning
  * - error
  */
-export function setLogLevel(level?: AzureLogLevel): void {
-  if (level && !isAzureLogLevel(level)) {
+export function setLogLevel(level?: TypeSpecRuntimeLogLevel): void {
+  if (level && !isTypeSpecRuntimeLogLevel(level)) {
     throw new Error(
-      `Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`,
+      `Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`,
     );
   }
-  azureLogLevel = level;
+  typeSpecRuntimeLogLevel = level;
 
   const enabledNamespaces = [];
   for (const logger of registeredLoggers) {
@@ -81,8 +83,8 @@ export function setLogLevel(level?: AzureLogLevel): void {
 /**
  * Retrieves the currently specified log level.
  */
-export function getLogLevel(): AzureLogLevel | undefined {
-  return azureLogLevel;
+export function getLogLevel(): TypeSpecRuntimeLogLevel | undefined {
+  return typeSpecRuntimeLogLevel;
 }
 
 const levelMap = {
@@ -96,7 +98,7 @@ const levelMap = {
  * Defines the methods available on the SDK-facing logger.
  */
 // eslint-disable-next-line @typescript-eslint/no-redeclare
-export interface AzureLogger {
+export interface TypeSpecRuntimeLogger {
   /**
    * Used for failures the program is unlikely to recover from,
    * such as Out of Memory.
@@ -121,13 +123,13 @@ export interface AzureLogger {
 }
 
 /**
- * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
+ * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.
  * @param namespace - The name of the SDK package.
  * @hidden
  */
-export function createClientLogger(namespace: string): AzureLogger {
-  const clientRootLogger: AzureClientLogger = AzureLogger.extend(namespace);
-  patchLogMethod(AzureLogger, clientRootLogger);
+export function createClientLogger(namespace: string): TypeSpecRuntimeLogger {
+  const clientRootLogger: TypeSpecRuntimeClientLogger = TypeSpecRuntimeLogger.extend(namespace);
+  patchLogMethod(TypeSpecRuntimeLogger, clientRootLogger);
   return {
     error: createLogger(clientRootLogger, "error"),
     warning: createLogger(clientRootLogger, "warning"),
@@ -136,14 +138,20 @@ export function createClientLogger(namespace: string): AzureLogger {
   };
 }
 
-function patchLogMethod(parent: AzureClientLogger, child: AzureClientLogger | AzureDebugger): void {
+function patchLogMethod(
+  parent: TypeSpecRuntimeClientLogger,
+  child: TypeSpecRuntimeClientLogger | TypeSpecRuntimeDebugger,
+): void {
   child.log = (...args) => {
     parent.log(...args);
   };
 }
 
-function createLogger(parent: AzureClientLogger, level: AzureLogLevel): AzureDebugger {
-  const logger: AzureDebugger = Object.assign(parent.extend(level), {
+function createLogger(
+  parent: TypeSpecRuntimeClientLogger,
+  level: TypeSpecRuntimeLogLevel,
+): TypeSpecRuntimeDebugger {
+  const logger: TypeSpecRuntimeDebugger = Object.assign(parent.extend(level), {
     level,
   });
 
@@ -159,10 +167,12 @@ function createLogger(parent: AzureClientLogger, level: AzureLogLevel): AzureDeb
   return logger;
 }
 
-function shouldEnable(logger: AzureDebugger): boolean {
-  return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
+function shouldEnable(logger: TypeSpecRuntimeDebugger): boolean {
+  return Boolean(
+    typeSpecRuntimeLogLevel && levelMap[logger.level] <= levelMap[typeSpecRuntimeLogLevel],
+  );
 }
 
-function isAzureLogLevel(logLevel: string): logLevel is AzureLogLevel {
-  return AZURE_LOG_LEVELS.includes(logLevel as any);
+function isTypeSpecRuntimeLogLevel(logLevel: string): logLevel is TypeSpecRuntimeLogLevel {
+  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(logLevel as any);
 }
diff --git a/src/nodeHttpClient.ts b/src/nodeHttpClient.ts
index 264a28e..2b974db 100644
--- a/src/nodeHttpClient.ts
+++ b/src/nodeHttpClient.ts
@@ -5,7 +5,7 @@ import * as http from "node:http";
 import * as https from "node:https";
 import * as zlib from "node:zlib";
 import { Transform } from "node:stream";
-import { AbortError } from "@azure/abort-controller";
+import { AbortError } from "./abort-controller/AbortError.js";
 import type {
   HttpClient,
   HttpHeaders,
diff --git a/src/pipelineRequest.ts b/src/pipelineRequest.ts
index 5947165..6c09a01 100644
--- a/src/pipelineRequest.ts
+++ b/src/pipelineRequest.ts
@@ -2,21 +2,17 @@
 // Licensed under the MIT License.
 
 import type {
-  Agent,
   FormDataMap,
   HttpHeaders,
+  HttpMethods,
   MultipartRequestBody,
   PipelineRequest,
   ProxySettings,
   RequestBodyType,
-  TlsSettings,
   TransferProgressEvent,
 } from "./interfaces.js";
 import { createHttpHeaders } from "./httpHeaders.js";
-import type { AbortSignalLike } from "@azure/abort-controller";
-import { randomUUID } from "@azure/core-util";
-import type { OperationTracingOptions } from "@azure/core-tracing";
-import type { HttpMethods } from "@azure/core-util";
+import { randomUUID } from "./util/uuidUtils.js";
 
 /**
  * Settings to initialize a request.
@@ -76,16 +72,6 @@ export interface PipelineRequestOptions {
    */
   streamResponseStatusCodes?: Set<number>;
 
-  /**
-   * NODEJS ONLY
-   *
-   * A Node-only option to provide a custom `http.Agent`/`https.Agent`.
-   * NOTE: usually this should be one instance shared by multiple requests so that the underlying
-   *       connection to the service can be reused.
-   * Does nothing when running in the browser.
-   */
-  agent?: Agent;
-
   /**
    * BROWSER ONLY
    *
@@ -97,9 +83,6 @@ export interface PipelineRequestOptions {
    */
   enableBrowserStreams?: boolean;
 
-  /** Settings for configuring TLS authentication */
-  tlsSettings?: TlsSettings;
-
   /**
    * Proxy configuration.
    */
@@ -113,12 +96,7 @@ export interface PipelineRequestOptions {
   /**
    * Used to abort the request later.
    */
-  abortSignal?: AbortSignalLike;
-
-  /**
-   * Options used to create a span when tracing is enabled.
-   */
-  tracingOptions?: OperationTracingOptions;
+  abortSignal?: AbortSignal;
 
   /**
    * Callback which fires upon upload progress.
@@ -143,16 +121,14 @@ class PipelineRequestImpl implements PipelineRequest {
   public formData?: FormDataMap;
   public streamResponseStatusCodes?: Set<number>;
   public enableBrowserStreams: boolean;
+
   public proxySettings?: ProxySettings;
   public disableKeepAlive: boolean;
-  public abortSignal?: AbortSignalLike;
+  public abortSignal?: AbortSignal;
   public requestId: string;
-  public tracingOptions?: OperationTracingOptions;
   public allowInsecureConnection?: boolean;
   public onUploadProgress?: (progress: TransferProgressEvent) => void;
   public onDownloadProgress?: (progress: TransferProgressEvent) => void;
-  public agent?: Agent;
-  public tlsSettings?: TlsSettings;
 
   constructor(options: PipelineRequestOptions) {
     this.url = options.url;
@@ -167,14 +143,11 @@ class PipelineRequestImpl implements PipelineRequest {
     this.streamResponseStatusCodes = options.streamResponseStatusCodes;
     this.withCredentials = options.withCredentials ?? false;
     this.abortSignal = options.abortSignal;
-    this.tracingOptions = options.tracingOptions;
     this.onUploadProgress = options.onUploadProgress;
     this.onDownloadProgress = options.onDownloadProgress;
     this.requestId = options.requestId || randomUUID();
     this.allowInsecureConnection = options.allowInsecureConnection ?? false;
     this.enableBrowserStreams = options.enableBrowserStreams ?? false;
-    this.agent = options.agent;
-    this.tlsSettings = options.tlsSettings;
   }
 }
 
diff --git a/src/policies/auth/apiKeyAuthenticationPolicy.ts b/src/policies/auth/apiKeyAuthenticationPolicy.ts
new file mode 100644
index 0000000..ea33138
--- /dev/null
+++ b/src/policies/auth/apiKeyAuthenticationPolicy.ts
@@ -0,0 +1,60 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { ApiKeyCredential } from "../../auth/credentials.js";
+import type { AuthScheme } from "../../auth/schemes.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../../interfaces.js";
+import type { PipelinePolicy } from "../../pipeline.js";
+import { ensureSecureConnection } from "./checkInsecureConnection.js";
+
+/**
+ * Name of the API Key Authentication Policy
+ */
+export const apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
+
+/**
+ * Options for configuring the API key authentication policy
+ */
+export interface ApiKeyAuthenticationPolicyOptions {
+  /**
+   * The credential used to authenticate requests
+   */
+  credential: ApiKeyCredential;
+  /**
+   * Optional authentication schemes to use. If `authSchemes` is provided in both request and policy options, the request options will take precedence.
+   */
+  authSchemes?: AuthScheme[];
+  /**
+   * Allows for connecting to HTTP endpoints instead of enforcing HTTPS.
+   * CAUTION: Never use this option in production.
+   */
+  allowInsecureConnection?: boolean;
+}
+
+/**
+ * Gets a pipeline policy that adds API key authentication to requests
+ */
+export function apiKeyAuthenticationPolicy(
+  options: ApiKeyAuthenticationPolicyOptions,
+): PipelinePolicy {
+  return {
+    name: apiKeyAuthenticationPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
+      ensureSecureConnection(request, options);
+
+      const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "apiKey");
+
+      // Skip adding authentication header if no API key authentication scheme is found
+      if (!scheme) {
+        return next(request);
+      }
+      if (scheme.apiKeyLocation !== "header") {
+        throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
+      }
+
+      request.headers.set(scheme.name, options.credential.key);
+      return next(request);
+    },
+  };
+}
diff --git a/src/policies/auth/basicAuthenticationPolicy.ts b/src/policies/auth/basicAuthenticationPolicy.ts
new file mode 100644
index 0000000..e4486de
--- /dev/null
+++ b/src/policies/auth/basicAuthenticationPolicy.ts
@@ -0,0 +1,65 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { BasicCredential } from "../../auth/credentials.js";
+import type { AuthScheme } from "../../auth/schemes.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../../interfaces.js";
+import type { PipelinePolicy } from "../../pipeline.js";
+import { stringToUint8Array, uint8ArrayToString } from "../../util/bytesEncoding.js";
+import { ensureSecureConnection } from "./checkInsecureConnection.js";
+
+/**
+ * Name of the Basic Authentication Policy
+ */
+export const basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
+
+/**
+ * Options for configuring the basic authentication policy
+ */
+export interface BasicAuthenticationPolicyOptions {
+  /**
+   * The credential used to authenticate requests
+   */
+  credential: BasicCredential;
+  /**
+   * Optional authentication schemes to use. If not provided, schemes from the request will be used.
+   */
+  authSchemes?: AuthScheme[];
+  /**
+   * Allows for connecting to HTTP endpoints instead of enforcing HTTPS.
+   * CAUTION: Never use this option in production.
+   */
+  allowInsecureConnection?: boolean;
+}
+
+/**
+ * Gets a pipeline policy that adds basic authentication to requests
+ */
+export function basicAuthenticationPolicy(
+  options: BasicAuthenticationPolicyOptions,
+): PipelinePolicy {
+  return {
+    name: basicAuthenticationPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
+      ensureSecureConnection(request, options);
+
+      const scheme = (request.authSchemes ?? options.authSchemes)?.find(
+        (x) => x.kind === "http" && x.scheme === "basic",
+      );
+
+      // Skip adding authentication header if no basic authentication scheme is found
+      if (!scheme) {
+        return next(request);
+      }
+
+      const { username, password } = options.credential;
+      const headerValue = uint8ArrayToString(
+        stringToUint8Array(`${username}:${password}`, "utf-8"),
+        "base64",
+      );
+      request.headers.set("Authorization", `Basic ${headerValue}`);
+      return next(request);
+    },
+  };
+}
diff --git a/src/policies/auth/bearerAuthenticationPolicy.ts b/src/policies/auth/bearerAuthenticationPolicy.ts
new file mode 100644
index 0000000..d7e8010
--- /dev/null
+++ b/src/policies/auth/bearerAuthenticationPolicy.ts
@@ -0,0 +1,62 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { BearerTokenCredential } from "../../auth/credentials.js";
+import type { AuthScheme } from "../../auth/schemes.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../../interfaces.js";
+import type { PipelinePolicy } from "../../pipeline.js";
+import { ensureSecureConnection } from "./checkInsecureConnection.js";
+
+/**
+ * Name of the Bearer Authentication Policy
+ */
+export const bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
+
+/**
+ * Options for configuring the bearer authentication policy
+ */
+export interface BearerAuthenticationPolicyOptions {
+  /**
+   * The BearerTokenCredential implementation that can supply the bearer token.
+   */
+  credential: BearerTokenCredential;
+  /**
+   * Optional authentication schemes to use. If not provided, schemes from the request will be used.
+   */
+  authSchemes?: AuthScheme[];
+  /**
+   * Allows for connecting to HTTP endpoints instead of enforcing HTTPS.
+   * CAUTION: Never use this option in production.
+   */
+  allowInsecureConnection?: boolean;
+}
+
+/**
+ * Gets a pipeline policy that adds bearer token authentication to requests
+ */
+export function bearerAuthenticationPolicy(
+  options: BearerAuthenticationPolicyOptions,
+): PipelinePolicy {
+  return {
+    name: bearerAuthenticationPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
+      ensureSecureConnection(request, options);
+
+      const scheme = (request.authSchemes ?? options.authSchemes)?.find(
+        (x) => x.kind === "http" && x.scheme === "bearer",
+      );
+
+      // Skip adding authentication header if no bearer authentication scheme is found
+      if (!scheme) {
+        return next(request);
+      }
+
+      const token = await options.credential.getBearerToken({
+        abortSignal: request.abortSignal,
+      });
+      request.headers.set("Authorization", `Bearer ${token}`);
+      return next(request);
+    },
+  };
+}
diff --git a/src/policies/auth/checkInsecureConnection.ts b/src/policies/auth/checkInsecureConnection.ts
new file mode 100644
index 0000000..704f486
--- /dev/null
+++ b/src/policies/auth/checkInsecureConnection.ts
@@ -0,0 +1,65 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { PipelineRequest } from "../../interfaces.js";
+import { logger } from "../../log.js";
+
+// Ensure the warining is only emitted once
+let insecureConnectionWarningEmmitted = false;
+
+/**
+ * Checks if the request is allowed to be sent over an insecure connection.
+ *
+ * A request is allowed to be sent over an insecure connection when:
+ * - The `allowInsecureConnection` option is set to `true`.
+ * - The request has the `allowInsecureConnection` property set to `true`.
+ * - The request is being sent to `localhost` or `127.0.0.1`
+ */
+function allowInsecureConnection(
+  request: PipelineRequest,
+  options: { allowInsecureConnection?: boolean },
+): boolean {
+  if (options.allowInsecureConnection && request.allowInsecureConnection) {
+    const url = new URL(request.url);
+    if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+/**
+ * Logs a warning about sending a token over an insecure connection.
+ *
+ * This function will emit a node warning once, but log the warning every time.
+ */
+function emitInsecureConnectionWarning(): void {
+  const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
+
+  logger.warning(warning);
+
+  if (typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted) {
+    insecureConnectionWarningEmmitted = true;
+    process.emitWarning(warning);
+  }
+}
+
+/**
+ * Ensures that authentication is only allowed over HTTPS unless explicitly allowed.
+ * Throws an error if the connection is not secure and not explicitly allowed.
+ */
+export function ensureSecureConnection(
+  request: PipelineRequest,
+  options: { allowInsecureConnection?: boolean },
+): void {
+  if (!request.url.toLowerCase().startsWith("https://")) {
+    if (allowInsecureConnection(request, options)) {
+      emitInsecureConnectionWarning();
+    } else {
+      throw new Error(
+        "Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.",
+      );
+    }
+  }
+}
diff --git a/src/policies/auth/oauth2AuthenticationPolicy.ts b/src/policies/auth/oauth2AuthenticationPolicy.ts
new file mode 100644
index 0000000..5c76266
--- /dev/null
+++ b/src/policies/auth/oauth2AuthenticationPolicy.ts
@@ -0,0 +1,60 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import type { OAuth2Flow } from "../../auth/oauth2Flows.js";
+import type { OAuth2TokenCredential } from "../../auth/credentials.js";
+import type { AuthScheme } from "../../auth/schemes.js";
+import type { PipelineRequest, PipelineResponse, SendRequest } from "../../interfaces.js";
+import type { PipelinePolicy } from "../../pipeline.js";
+import { ensureSecureConnection } from "./checkInsecureConnection.js";
+
+/**
+ * Name of the OAuth2 Authentication Policy
+ */
+export const oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
+
+/**
+ * Options for configuring the OAuth2 authentication policy
+ */
+export interface OAuth2AuthenticationPolicyOptions<TFlows extends OAuth2Flow> {
+  /**
+   * The OAuth2TokenCredential implementation that can supply the bearer token.
+   */
+  credential: OAuth2TokenCredential<TFlows>;
+  /**
+   * Optional authentication schemes to use. If not provided, schemes from the request will be used.
+   */
+  authSchemes?: AuthScheme[];
+  /**
+   * Allows for connecting to HTTP endpoints instead of enforcing HTTPS.
+   * CAUTION: Never use this option in production.
+   */
+  allowInsecureConnection?: boolean;
+}
+
+/**
+ * Gets a pipeline policy that adds authorization header from OAuth2 schemes
+ */
+export function oauth2AuthenticationPolicy<TFlows extends OAuth2Flow>(
+  options: OAuth2AuthenticationPolicyOptions<TFlows>,
+): PipelinePolicy {
+  return {
+    name: oauth2AuthenticationPolicyName,
+    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
+      // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
+      ensureSecureConnection(request, options);
+
+      const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "oauth2");
+
+      // Skip adding authentication header if no OAuth2 authentication scheme is found
+      if (!scheme) {
+        return next(request);
+      }
+      const token = await options.credential.getOAuth2Token(scheme.flows as TFlows[], {
+        abortSignal: request.abortSignal,
+      });
+      request.headers.set("Authorization", `Bearer ${token}`);
+      return next(request);
+    },
+  };
+}
diff --git a/src/policies/auxiliaryAuthenticationHeaderPolicy.ts b/src/policies/auxiliaryAuthenticationHeaderPolicy.ts
deleted file mode 100644
index 55110a0..0000000
--- a/src/policies/auxiliaryAuthenticationHeaderPolicy.ts
+++ /dev/null
@@ -1,106 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { GetTokenOptions, TokenCredential } from "@azure/core-auth";
-import type { AzureLogger } from "@azure/logger";
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-import { type AccessTokenGetter, createTokenCycler } from "../util/tokenCycler.js";
-import { logger as coreLogger } from "../log.js";
-import type { AuthorizeRequestOptions } from "./bearerTokenAuthenticationPolicy.js";
-
-/**
- * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.
- */
-export const auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
-const AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
-
-/**
- * Options to configure the auxiliaryAuthenticationHeaderPolicy
- */
-export interface AuxiliaryAuthenticationHeaderPolicyOptions {
-  /**
-   * TokenCredential list used to get token from auxiliary tenants and
-   * one credential for each tenant the client may need to access
-   */
-  credentials?: TokenCredential[];
-  /**
-   * Scopes depend on the cloud your application runs in
-   */
-  scopes: string | string[];
-  /**
-   * A logger can be sent for debugging purposes.
-   */
-  logger?: AzureLogger;
-}
-
-async function sendAuthorizeRequest(options: AuthorizeRequestOptions): Promise<string> {
-  const { scopes, getAccessToken, request } = options;
-  const getTokenOptions: GetTokenOptions = {
-    abortSignal: request.abortSignal,
-    tracingOptions: request.tracingOptions,
-  };
-
-  return (await getAccessToken(scopes, getTokenOptions))?.token ?? "";
-}
-
-/**
- * A policy for external tokens to `x-ms-authorization-auxiliary` header.
- * This header will be used when creating a cross-tenant application we may need to handle authentication requests
- * for resources that are in different tenants.
- * You could see [ARM docs](https://learn.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works
- */
-export function auxiliaryAuthenticationHeaderPolicy(
-  options: AuxiliaryAuthenticationHeaderPolicyOptions,
-): PipelinePolicy {
-  const { credentials, scopes } = options;
-  const logger = options.logger || coreLogger;
-  const tokenCyclerMap = new WeakMap<TokenCredential, AccessTokenGetter>();
-
-  return {
-    name: auxiliaryAuthenticationHeaderPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      if (!request.url.toLowerCase().startsWith("https://")) {
-        throw new Error(
-          "Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.",
-        );
-      }
-      if (!credentials || credentials.length === 0) {
-        logger.info(
-          `${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`,
-        );
-        return next(request);
-      }
-
-      const tokenPromises: Promise<string>[] = [];
-      for (const credential of credentials) {
-        let getAccessToken = tokenCyclerMap.get(credential);
-        if (!getAccessToken) {
-          getAccessToken = createTokenCycler(credential);
-          tokenCyclerMap.set(credential, getAccessToken);
-        }
-        tokenPromises.push(
-          sendAuthorizeRequest({
-            scopes: Array.isArray(scopes) ? scopes : [scopes],
-            request,
-            getAccessToken,
-            logger,
-          }),
-        );
-      }
-      const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
-      if (auxiliaryTokens.length === 0) {
-        logger.warning(
-          `None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`,
-        );
-        return next(request);
-      }
-      request.headers.set(
-        AUTHORIZATION_AUXILIARY_HEADER,
-        auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "),
-      );
-
-      return next(request);
-    },
-  };
-}
diff --git a/src/policies/bearerTokenAuthenticationPolicy.ts b/src/policies/bearerTokenAuthenticationPolicy.ts
deleted file mode 100644
index d67931e..0000000
--- a/src/policies/bearerTokenAuthenticationPolicy.ts
+++ /dev/null
@@ -1,384 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AccessToken, GetTokenOptions, TokenCredential } from "@azure/core-auth";
-import type { AzureLogger } from "@azure/logger";
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-import { createTokenCycler } from "../util/tokenCycler.js";
-import { logger as coreLogger } from "../log.js";
-import type { RestError } from "../restError.js";
-import { isRestError } from "../restError.js";
-
-/**
- * The programmatic identifier of the bearerTokenAuthenticationPolicy.
- */
-export const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
-
-/**
- * Options sent to the authorizeRequest callback
- */
-export interface AuthorizeRequestOptions {
-  /**
-   * The scopes for which the bearer token applies.
-   */
-  scopes: string[];
-  /**
-   * Function that retrieves either a cached access token or a new access token.
-   */
-  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;
-  /**
-   * Request that the policy is trying to fulfill.
-   */
-  request: PipelineRequest;
-  /**
-   * A logger, if one was sent through the HTTP pipeline.
-   */
-  logger?: AzureLogger;
-}
-
-/**
- * Options sent to the authorizeRequestOnChallenge callback
- */
-export interface AuthorizeRequestOnChallengeOptions {
-  /**
-   * The scopes for which the bearer token applies.
-   */
-  scopes: string[];
-  /**
-   * Function that retrieves either a cached access token or a new access token.
-   */
-  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;
-  /**
-   * Request that the policy is trying to fulfill.
-   */
-  request: PipelineRequest;
-  /**
-   * Response containing the challenge.
-   */
-  response: PipelineResponse;
-  /**
-   * A logger, if one was sent through the HTTP pipeline.
-   */
-  logger?: AzureLogger;
-}
-
-/**
- * Options to override the processing of [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.
- */
-export interface ChallengeCallbacks {
-  /**
-   * Allows for the authorization of the main request of this policy before it's sent.
-   */
-  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;
-  /**
-   * Allows to handle authentication challenges and to re-authorize the request.
-   * The response containing the challenge is `options.response`.
-   * If this method returns true, the underlying request will be sent once again.
-   * The request may be modified before being sent.
-   */
-  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;
-}
-
-/**
- * Options to configure the bearerTokenAuthenticationPolicy
- */
-export interface BearerTokenAuthenticationPolicyOptions {
-  /**
-   * The TokenCredential implementation that can supply the bearer token.
-   */
-  credential?: TokenCredential;
-  /**
-   * The scopes for which the bearer token applies.
-   */
-  scopes: string | string[];
-  /**
-   * Allows for the processing of [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.
-   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.
-   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.
-   */
-  challengeCallbacks?: ChallengeCallbacks;
-  /**
-   * A logger can be sent for debugging purposes.
-   */
-  logger?: AzureLogger;
-}
-/**
- * Try to send the given request.
- *
- * When a response is received, returns a tuple of the response received and, if the response was received
- * inside a thrown RestError, the RestError that was thrown.
- *
- * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it
- * will be rethrown.
- */
-async function trySendRequest(
-  request: PipelineRequest,
-  next: SendRequest,
-): Promise<[PipelineResponse, RestError | undefined]> {
-  try {
-    return [await next(request), undefined];
-  } catch (e: any) {
-    if (isRestError(e) && e.response) {
-      return [e.response, e];
-    } else {
-      throw e;
-    }
-  }
-}
-/**
- * Default authorize request handler
- */
-async function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {
-  const { scopes, getAccessToken, request } = options;
-  // Enable CAE true by default
-  const getTokenOptions: GetTokenOptions = {
-    abortSignal: request.abortSignal,
-    tracingOptions: request.tracingOptions,
-    enableCae: true,
-  };
-
-  const accessToken = await getAccessToken(scopes, getTokenOptions);
-
-  if (accessToken) {
-    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
-  }
-}
-
-/**
- * We will retrieve the challenge only if the response status code was 401,
- * and if the response contained the header "WWW-Authenticate" with a non-empty value.
- */
-function isChallengeResponse(response: PipelineResponse): boolean {
-  return response.status === 401 && response.headers.has("WWW-Authenticate");
-}
-
-/**
- * Re-authorize the request for CAE challenge.
- * The response containing the challenge is `options.response`.
- * If this method returns true, the underlying request will be sent once again.
- */
-async function authorizeRequestOnCaeChallenge(
-  onChallengeOptions: AuthorizeRequestOnChallengeOptions,
-  caeClaims: string,
-): Promise<boolean> {
-  const { scopes } = onChallengeOptions;
-
-  const accessToken = await onChallengeOptions.getAccessToken(scopes, {
-    enableCae: true,
-    claims: caeClaims,
-  });
-  if (!accessToken) {
-    return false;
-  }
-
-  onChallengeOptions.request.headers.set(
-    "Authorization",
-    `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`,
-  );
-  return true;
-}
-
-/**
- * A policy that can request a token from a TokenCredential implementation and
- * then apply it to the Authorization header of a request as a Bearer token.
- */
-export function bearerTokenAuthenticationPolicy(
-  options: BearerTokenAuthenticationPolicyOptions,
-): PipelinePolicy {
-  const { credential, scopes, challengeCallbacks } = options;
-  const logger = options.logger || coreLogger;
-  const callbacks = {
-    authorizeRequest:
-      challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
-    authorizeRequestOnChallenge:
-      challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks),
-  };
-
-  // This function encapsulates the entire process of reliably retrieving the token
-  // The options are left out of the public API until there's demand to configure this.
-  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`
-  // in order to pass through the `options` object.
-  const getAccessToken = credential
-    ? createTokenCycler(credential /* , options */)
-    : () => Promise.resolve(null);
-
-  return {
-    name: bearerTokenAuthenticationPolicyName,
-    /**
-     * If there's no challenge parameter:
-     * - It will try to retrieve the token using the cache, or the credential's getToken.
-     * - Then it will try the next policy with or without the retrieved token.
-     *
-     * It uses the challenge parameters to:
-     * - Skip a first attempt to get the token from the credential if there's no cached token,
-     *   since it expects the token to be retrievable only after the challenge.
-     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
-     * - Send an initial request to receive the challenge if it fails.
-     * - Process a challenge if the response contains it.
-     * - Retrieve a token with the challenge information, then re-send the request.
-     */
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      if (!request.url.toLowerCase().startsWith("https://")) {
-        throw new Error(
-          "Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.",
-        );
-      }
-
-      await callbacks.authorizeRequest({
-        scopes: Array.isArray(scopes) ? scopes : [scopes],
-        request,
-        getAccessToken,
-        logger,
-      });
-
-      let response: PipelineResponse;
-      let error: Error | undefined;
-      let shouldSendRequest: boolean;
-      [response, error] = await trySendRequest(request, next);
-
-      if (isChallengeResponse(response)) {
-        let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
-        // Handle CAE by default when receive CAE claim
-        if (claims) {
-          let parsedClaim: string;
-          // Return the response immediately if claims is not a valid base64 encoded string
-          try {
-            parsedClaim = atob(claims);
-          } catch (e) {
-            logger.warning(
-              `The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`,
-            );
-            return response;
-          }
-          shouldSendRequest = await authorizeRequestOnCaeChallenge(
-            {
-              scopes: Array.isArray(scopes) ? scopes : [scopes],
-              response,
-              request,
-              getAccessToken,
-              logger,
-            },
-            parsedClaim,
-          );
-          // Send updated request and handle response for RestError
-          if (shouldSendRequest) {
-            [response, error] = await trySendRequest(request, next);
-          }
-        } else if (callbacks.authorizeRequestOnChallenge) {
-          // Handle custom challenges when client provides custom callback
-          shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
-            scopes: Array.isArray(scopes) ? scopes : [scopes],
-            request,
-            response,
-            getAccessToken,
-            logger,
-          });
-
-          // Send updated request and handle response for RestError
-          if (shouldSendRequest) {
-            [response, error] = await trySendRequest(request, next);
-          }
-
-          // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this
-          if (isChallengeResponse(response)) {
-            claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate") as string);
-            if (claims) {
-              let parsedClaim: string;
-              try {
-                parsedClaim = atob(claims);
-              } catch (e) {
-                logger.warning(
-                  `The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`,
-                );
-                return response;
-              }
-
-              shouldSendRequest = await authorizeRequestOnCaeChallenge(
-                {
-                  scopes: Array.isArray(scopes) ? scopes : [scopes],
-                  response,
-                  request,
-                  getAccessToken,
-                  logger,
-                },
-                parsedClaim,
-              );
-              // Send updated request and handle response for RestError
-              if (shouldSendRequest) {
-                [response, error] = await trySendRequest(request, next);
-              }
-            }
-          }
-        }
-      }
-
-      if (error) {
-        throw error;
-      } else {
-        return response;
-      }
-    },
-  };
-}
-
-/**
- *
- * Interface to represent a parsed challenge.
- *
- * @internal
- */
-interface AuthChallenge {
-  scheme: string;
-  params: Record<string, string>;
-}
-
-/**
- * Converts: `Bearer a="b", c="d", Pop e="f", g="h"`.
- * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.
- *
- * @internal
- */
-export function parseChallenges(challenges: string): AuthChallenge[] {
-  // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a="b", c=d`
-  // The challenge regex captures parameteres with either quotes values or unquoted values
-  const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
-  // Parameter regex captures the claims group removed from the scheme in the format `a="b"` and `c="d"`
-  // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge
-  const paramRegex = /(\w+)="([^"]*)"/g;
-
-  const parsedChallenges: AuthChallenge[] = [];
-  let match;
-
-  // Iterate over each challenge match
-  while ((match = challengeRegex.exec(challenges)) !== null) {
-    const scheme = match[1];
-    const paramsString = match[2];
-    const params: Record<string, string> = {};
-    let paramMatch;
-
-    // Iterate over each parameter match
-    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
-      params[paramMatch[1]] = paramMatch[2];
-    }
-
-    parsedChallenges.push({ scheme, params });
-  }
-  return parsedChallenges;
-}
-
-/**
- * Parse a pipeline response and look for a CAE challenge with "Bearer" scheme
- * Return the value in the header without parsing the challenge
- * @internal
- */
-function getCaeChallengeClaims(challenges: string | undefined): string | undefined {
-  if (!challenges) {
-    return;
-  }
-  // Find all challenges present in the header
-  const parsedChallenges = parseChallenges(challenges);
-  return parsedChallenges.find(
-    (x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims",
-  )?.params.claims;
-}
diff --git a/src/policies/formDataPolicy.ts b/src/policies/formDataPolicy.ts
index 86d7e12..4265f06 100644
--- a/src/policies/formDataPolicy.ts
+++ b/src/policies/formDataPolicy.ts
@@ -1,7 +1,8 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { isNodeLike, stringToUint8Array } from "@azure/core-util";
+import { stringToUint8Array } from "../util/bytesEncoding.js";
+import { isNodeLike } from "../util/checkEnvironment.js";
 import { createHttpHeaders } from "../httpHeaders.js";
 import type {
   BodyPart,
diff --git a/src/policies/logPolicy.ts b/src/policies/logPolicy.ts
index a8383c6..6b7d1ab 100644
--- a/src/policies/logPolicy.ts
+++ b/src/policies/logPolicy.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { Debugger } from "@azure/logger";
+import type { Debugger } from "../logger/logger.js";
 import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
 import { logger as coreLogger } from "../log.js";
diff --git a/src/policies/multipartPolicy.ts b/src/policies/multipartPolicy.ts
index 2b70494..268c132 100644
--- a/src/policies/multipartPolicy.ts
+++ b/src/policies/multipartPolicy.ts
@@ -1,11 +1,12 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { randomUUID, stringToUint8Array } from "@azure/core-util";
 import type { BodyPart, HttpHeaders, PipelineRequest, PipelineResponse } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
-import { concat } from "../util/concat.js";
+import { stringToUint8Array } from "../util/bytesEncoding.js";
 import { isBlob } from "../util/typeGuards.js";
+import { randomUUID } from "../util/uuidUtils.js";
+import { concat } from "../util/concat.js";
 
 function generateBoundary(): string {
   return `----AzSDKFormBoundary${randomUUID()}`;
diff --git a/src/policies/ndJsonPolicy.ts b/src/policies/ndJsonPolicy.ts
deleted file mode 100644
index deeee45..0000000
--- a/src/policies/ndJsonPolicy.ts
+++ /dev/null
@@ -1,29 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-
-/**
- * The programmatic identifier of the ndJsonPolicy.
- */
-export const ndJsonPolicyName = "ndJsonPolicy";
-
-/**
- * ndJsonPolicy is a policy used to control keep alive settings for every request.
- */
-export function ndJsonPolicy(): PipelinePolicy {
-  return {
-    name: ndJsonPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      // There currently isn't a good way to bypass the serializer
-      if (typeof request.body === "string" && request.body.startsWith("[")) {
-        const body = JSON.parse(request.body);
-        if (Array.isArray(body)) {
-          request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
-        }
-      }
-      return next(request);
-    },
-  };
-}
diff --git a/src/policies/retryPolicy.ts b/src/policies/retryPolicy.ts
index 6d2afd5..badccb2 100644
--- a/src/policies/retryPolicy.ts
+++ b/src/policies/retryPolicy.ts
@@ -4,10 +4,11 @@
 import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
 import type { PipelinePolicy } from "../pipeline.js";
 import { delay } from "../util/helpers.js";
-import { type AzureLogger, createClientLogger } from "@azure/logger";
 import type { RetryStrategy } from "../retryStrategies/retryStrategy.js";
 import type { RestError } from "../restError.js";
-import { AbortError } from "@azure/abort-controller";
+import { AbortError } from "../abort-controller/AbortError.js";
+import type { TypeSpecRuntimeLogger } from "../logger/logger.js";
+import { createClientLogger } from "../logger/logger.js";
 import { DEFAULT_RETRY_POLICY_COUNT } from "../constants.js";
 
 const retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
@@ -28,7 +29,7 @@ export interface RetryPolicyOptions {
   /**
    * Logger. If it's not provided, a default logger is used.
    */
-  logger?: AzureLogger;
+  logger?: TypeSpecRuntimeLogger;
 }
 
 /**
diff --git a/src/policies/setClientRequestIdPolicy.ts b/src/policies/setClientRequestIdPolicy.ts
deleted file mode 100644
index a40d4ab..0000000
--- a/src/policies/setClientRequestIdPolicy.ts
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-
-/**
- * The programmatic identifier of the setClientRequestIdPolicy.
- */
-export const setClientRequestIdPolicyName = "setClientRequestIdPolicy";
-
-/**
- * Each PipelineRequest gets a unique id upon creation.
- * This policy passes that unique id along via an HTTP header to enable better
- * telemetry and tracing.
- * @param requestIdHeaderName - The name of the header to pass the request ID to.
- */
-export function setClientRequestIdPolicy(
-  requestIdHeaderName = "x-ms-client-request-id",
-): PipelinePolicy {
-  return {
-    name: setClientRequestIdPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      if (!request.headers.has(requestIdHeaderName)) {
-        request.headers.set(requestIdHeaderName, request.requestId);
-      }
-      return next(request);
-    },
-  };
-}
diff --git a/src/policies/tracingPolicy.ts b/src/policies/tracingPolicy.ts
deleted file mode 100644
index 4f54b0d..0000000
--- a/src/policies/tracingPolicy.ts
+++ /dev/null
@@ -1,174 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import {
-  type TracingClient,
-  type TracingContext,
-  type TracingSpan,
-  createTracingClient,
-} from "@azure/core-tracing";
-import { SDK_VERSION } from "../constants.js";
-import type { PipelineRequest, PipelineResponse, SendRequest } from "../interfaces.js";
-import type { PipelinePolicy } from "../pipeline.js";
-import { getUserAgentValue } from "../util/userAgent.js";
-import { logger } from "../log.js";
-import { getErrorMessage, isError } from "@azure/core-util";
-import { isRestError } from "../restError.js";
-import { Sanitizer } from "../util/sanitizer.js";
-
-/**
- * The programmatic identifier of the tracingPolicy.
- */
-export const tracingPolicyName = "tracingPolicy";
-
-/**
- * Options to configure the tracing policy.
- */
-export interface TracingPolicyOptions {
-  /**
-   * String prefix to add to the user agent logged as metadata
-   * on the generated Span.
-   * Defaults to an empty string.
-   */
-  userAgentPrefix?: string;
-  /**
-   * Query string names whose values will be logged when logging is enabled. By default no
-   * query string values are logged.
-   */
-  additionalAllowedQueryParameters?: string[];
-}
-
-/**
- * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
- * that has SpanOptions with a parent.
- * Requests made without a parent Span will not be recorded.
- * @param options - Options to configure the telemetry logged by the tracing policy.
- */
-export function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {
-  const userAgentPromise = getUserAgentValue(options.userAgentPrefix);
-  const sanitizer = new Sanitizer({
-    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
-  });
-  const tracingClient = tryCreateTracingClient();
-
-  return {
-    name: tracingPolicyName,
-    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {
-      if (!tracingClient) {
-        return next(request);
-      }
-
-      const userAgent = await userAgentPromise;
-
-      const spanAttributes = {
-        "http.url": sanitizer.sanitizeUrl(request.url),
-        "http.method": request.method,
-        "http.user_agent": userAgent,
-        requestId: request.requestId,
-      };
-      if (userAgent) {
-        spanAttributes["http.user_agent"] = userAgent;
-      }
-
-      const { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};
-
-      if (!span || !tracingContext) {
-        return next(request);
-      }
-
-      try {
-        const response = await tracingClient.withContext(tracingContext, next, request);
-        tryProcessResponse(span, response);
-        return response;
-      } catch (err: any) {
-        tryProcessError(span, err);
-        throw err;
-      }
-    },
-  };
-}
-
-function tryCreateTracingClient(): TracingClient | undefined {
-  try {
-    return createTracingClient({
-      namespace: "",
-      packageName: "@azure/core-rest-pipeline",
-      packageVersion: SDK_VERSION,
-    });
-  } catch (e: unknown) {
-    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
-    return undefined;
-  }
-}
-
-function tryCreateSpan(
-  tracingClient: TracingClient,
-  request: PipelineRequest,
-  spanAttributes: Record<string, unknown>,
-): { span: TracingSpan; tracingContext: TracingContext } | undefined {
-  try {
-    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
-    const { span, updatedOptions } = tracingClient.startSpan(
-      `HTTP ${request.method}`,
-      { tracingOptions: request.tracingOptions },
-      {
-        spanKind: "client",
-        spanAttributes,
-      },
-    );
-
-    // If the span is not recording, don't do any more work.
-    if (!span.isRecording()) {
-      span.end();
-      return undefined;
-    }
-
-    // set headers
-    const headers = tracingClient.createRequestHeaders(
-      updatedOptions.tracingOptions.tracingContext,
-    );
-    for (const [key, value] of Object.entries(headers)) {
-      request.headers.set(key, value);
-    }
-    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
-  } catch (e: any) {
-    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
-    return undefined;
-  }
-}
-
-function tryProcessError(span: TracingSpan, error: unknown): void {
-  try {
-    span.setStatus({
-      status: "error",
-      error: isError(error) ? error : undefined,
-    });
-    if (isRestError(error) && error.statusCode) {
-      span.setAttribute("http.status_code", error.statusCode);
-    }
-    span.end();
-  } catch (e: any) {
-    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
-  }
-}
-
-function tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {
-  try {
-    span.setAttribute("http.status_code", response.status);
-    const serviceRequestId = response.headers.get("x-ms-request-id");
-    if (serviceRequestId) {
-      span.setAttribute("serviceRequestId", serviceRequestId);
-    }
-    // Per semantic conventions, only set the status to error if the status code is 4xx or 5xx.
-    // Otherwise, the status MUST remain unset.
-    // https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
-    if (response.status >= 400) {
-      span.setStatus({
-        status: "error",
-      });
-    }
-    span.end();
-  } catch (e: any) {
-    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
-  }
-}
diff --git a/src/restError.ts b/src/restError.ts
index a3d36bc..722db2a 100644
--- a/src/restError.ts
+++ b/src/restError.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { isError } from "@azure/core-util";
+import { isError } from "./util/error.js";
 import type { PipelineRequest, PipelineResponse } from "./interfaces.js";
 import { custom } from "./util/inspect.js";
 import { Sanitizer } from "./util/sanitizer.js";
diff --git a/src/retryStrategies/exponentialRetryStrategy.ts b/src/retryStrategies/exponentialRetryStrategy.ts
index c6943b8..568e864 100644
--- a/src/retryStrategies/exponentialRetryStrategy.ts
+++ b/src/retryStrategies/exponentialRetryStrategy.ts
@@ -3,7 +3,7 @@
 
 import type { PipelineResponse } from "../interfaces.js";
 import type { RestError } from "../restError.js";
-import { calculateRetryDelay } from "@azure/core-util";
+import { calculateRetryDelay } from "../util/delay.js";
 import type { RetryStrategy } from "./retryStrategy.js";
 import { isThrottlingRetryResponse } from "./throttlingRetryStrategy.js";
 
diff --git a/src/retryStrategies/retryStrategy.ts b/src/retryStrategies/retryStrategy.ts
index a8b94fc..bc11b52 100644
--- a/src/retryStrategies/retryStrategy.ts
+++ b/src/retryStrategies/retryStrategy.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { AzureLogger } from "@azure/logger";
+import type { TypeSpecRuntimeLogger } from "../logger/logger.js";
 import type { PipelineResponse } from "../interfaces.js";
 import type { RestError } from "../restError.js";
 
@@ -57,7 +57,7 @@ export interface RetryStrategy {
   /**
    * Logger. If it's not provided, a default logger for all retry strategies is used.
    */
-  logger?: AzureLogger;
+  logger?: TypeSpecRuntimeLogger;
   /**
    * Function that determines how to proceed with the subsequent requests.
    * @param state - Retry state
diff --git a/src/retryStrategies/throttlingRetryStrategy.ts b/src/retryStrategies/throttlingRetryStrategy.ts
index 2d4f87f..d0f7298 100644
--- a/src/retryStrategies/throttlingRetryStrategy.ts
+++ b/src/retryStrategies/throttlingRetryStrategy.ts
@@ -1,17 +1,17 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { PipelineResponse } from "../index.js";
+import type { PipelineResponse } from "../interfaces.js";
 import { parseHeaderValueAsNumber } from "../util/helpers.js";
 import type { RetryStrategy } from "./retryStrategy.js";
 
 /**
- * The header that comes back from Azure services representing
+ * The header that comes back from services representing
  * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).
  */
 const RetryAfterHeader = "Retry-After";
 /**
- * The headers that come back from Azure services representing
+ * The headers that come back from services representing
  * the amount of time (minimum) to wait to retry.
  *
  * "retry-after-ms", "x-ms-retry-after-ms" : milliseconds
diff --git a/src/tracing/index.ts b/src/tracing/index.ts
deleted file mode 100644
index 8992d7a..0000000
--- a/src/tracing/index.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-export {
-  AddEventOptions,
-  Instrumenter,
-  InstrumenterSpanOptions,
-  OperationTracingOptions,
-  OptionsWithTracingContext,
-  Resolved,
-  SpanStatus,
-  SpanStatusError,
-  SpanStatusSuccess,
-  TracingClient,
-  TracingClientOptions,
-  TracingContext,
-  TracingSpan,
-  TracingSpanKind,
-  TracingSpanLink,
-  TracingSpanOptions,
-} from "./interfaces.js";
-export { useInstrumenter } from "./instrumenter.js";
-export { createTracingClient } from "./tracingClient.js";
diff --git a/src/tracing/instrumenter.ts b/src/tracing/instrumenter.ts
deleted file mode 100644
index 28f5729..0000000
--- a/src/tracing/instrumenter.ts
+++ /dev/null
@@ -1,84 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type {
-  Instrumenter,
-  InstrumenterSpanOptions,
-  TracingContext,
-  TracingSpan,
-} from "./interfaces.js";
-
-import { createTracingContext } from "./tracingContext.js";
-import { state } from "./state.js";
-
-export function createDefaultTracingSpan(): TracingSpan {
-  return {
-    end: () => {
-      // noop
-    },
-    isRecording: () => false,
-    recordException: () => {
-      // noop
-    },
-    setAttribute: () => {
-      // noop
-    },
-    setStatus: () => {
-      // noop
-    },
-    addEvent: () => {
-      // noop
-    },
-  };
-}
-
-export function createDefaultInstrumenter(): Instrumenter {
-  return {
-    createRequestHeaders: (): Record<string, string> => {
-      return {};
-    },
-    parseTraceparentHeader: (): TracingContext | undefined => {
-      return undefined;
-    },
-    startSpan: (
-      _name: string,
-      spanOptions: InstrumenterSpanOptions,
-    ): { span: TracingSpan; tracingContext: TracingContext } => {
-      return {
-        span: createDefaultTracingSpan(),
-        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext }),
-      };
-    },
-    withContext<
-      CallbackArgs extends unknown[],
-      Callback extends (...args: CallbackArgs) => ReturnType<Callback>,
-    >(
-      _context: TracingContext,
-      callback: Callback,
-      ...callbackArgs: CallbackArgs
-    ): ReturnType<Callback> {
-      return callback(...callbackArgs);
-    },
-  };
-}
-
-/**
- * Extends the Azure SDK with support for a given instrumenter implementation.
- *
- * @param instrumenter - The instrumenter implementation to use.
- */
-export function useInstrumenter(instrumenter: Instrumenter): void {
-  state.instrumenterImplementation = instrumenter;
-}
-
-/**
- * Gets the currently set instrumenter, a No-Op instrumenter by default.
- *
- * @returns The currently set instrumenter
- */
-export function getInstrumenter(): Instrumenter {
-  if (!state.instrumenterImplementation) {
-    state.instrumenterImplementation = createDefaultInstrumenter();
-  }
-  return state.instrumenterImplementation;
-}
diff --git a/src/tracing/interfaces.ts b/src/tracing/interfaces.ts
deleted file mode 100644
index 7da11e7..0000000
--- a/src/tracing/interfaces.ts
+++ /dev/null
@@ -1,331 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * A narrower version of TypeScript 4.5's Awaited type which Recursively
- * unwraps the "awaited type", emulating the behavior of `await`.
- */
-export type Resolved<T> = T extends { then(onfulfilled: infer F): any } // `await` only unwraps object types with a callable `then`. Non-object types are not unwrapped
-  ? F extends (value: infer V) => any // if the argument to `then` is callable, extracts the first argument
-    ? Resolved<V> // recursively unwrap the value
-    : never // the argument to `then` was not callable
-  : T; // non-object or non-thenable
-
-/**
- * Represents a client that can integrate with the currently configured {@link Instrumenter}.
- *
- * Create an instance using {@link createTracingClient}.
- */
-export interface TracingClient {
-  /**
-   * Wraps a callback in a tracing span, calls the callback, and closes the span.
-   *
-   * This is the primary interface for using Tracing and will handle error recording as well as setting the status on the span.
-   *
-   * Both synchronous and asynchronous functions will be awaited in order to reflect the result of the callback on the span.
-   *
-   * Example:
-   *
-   * ```ts snippet:ReadmeSampleWithSpanExample
-   * import { createTracingClient } from "@azure/core-tracing";
-   *
-   * const tracingClient = createTracingClient({
-   *   namespace: "test.namespace",
-   *   packageName: "test-package",
-   *   packageVersion: "1.0.0",
-   * });
-   *
-   * const options = {};
-   *
-   * const myOperationResult = await tracingClient.withSpan(
-   *   "myClassName.myOperationName",
-   *   options,
-   *   (updatedOptions) => {
-   *     // Do something with the updated options.
-   *     return "myOperationResult";
-   *   },
-   * );
-   * ```
-   * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
-   * @param operationOptions - The original options passed to the method. The callback will receive these options with the newly created {@link TracingContext}.
-   * @param callback - The callback to be invoked with the updated options and newly created {@link TracingSpan}.
-   */
-  withSpan<
-    Options extends { tracingOptions?: OperationTracingOptions },
-    Callback extends (
-      updatedOptions: Options,
-      span: Omit<TracingSpan, "end">,
-    ) => ReturnType<Callback>,
-  >(
-    name: string,
-    operationOptions: Options,
-    callback: Callback,
-    spanOptions?: TracingSpanOptions,
-  ): Promise<Resolved<ReturnType<Callback>>>;
-  /**
-   * Starts a given span but does not set it as the active span.
-   *
-   * You must end the span using {@link TracingSpan.end}.
-   *
-   * Most of the time you will want to use {@link withSpan} instead.
-   *
-   * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
-   * @param operationOptions - The original operation options.
-   * @param spanOptions - The options to use when creating the span.
-   *
-   * @returns A {@link TracingSpan} and the updated operation options.
-   */
-  startSpan<Options extends { tracingOptions?: OperationTracingOptions }>(
-    name: string,
-    operationOptions?: Options,
-    spanOptions?: TracingSpanOptions,
-  ): {
-    span: TracingSpan;
-    updatedOptions: OptionsWithTracingContext<Options>;
-  };
-  /**
-   * Wraps a callback with an active context and calls the callback.
-   * Depending on the implementation, this may set the globally available active context.
-   *
-   * Useful when you want to leave the boundaries of the SDK (make a request or callback to user code) and are unable to use the {@link withSpan} API.
-   *
-   * @param context - The {@link TracingContext} to use as the active context in the scope of the callback.
-   * @param callback - The callback to be invoked with the given context set as the globally active context.
-   * @param callbackArgs - The callback arguments.
-   */
-  withContext<
-    CallbackArgs extends unknown[],
-    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,
-  >(
-    context: TracingContext,
-    callback: Callback,
-    ...callbackArgs: CallbackArgs
-  ): ReturnType<Callback>;
-
-  /**
-   * Parses a traceparent header value into a {@link TracingSpanContext}.
-   *
-   * @param traceparentHeader - The traceparent header to parse.
-   * @returns An implementation-specific identifier for the span.
-   */
-  parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined;
-
-  /**
-   * Creates a set of request headers to propagate tracing information to a backend.
-   *
-   * @param tracingContext - The context containing the span to propagate.
-   * @returns The set of headers to add to a request.
-   */
-  createRequestHeaders(tracingContext?: TracingContext): Record<string, string>;
-}
-
-/**
- * Options that can be passed to {@link createTracingClient}
- */
-export interface TracingClientOptions {
-  /** The value of the az.namespace tracing attribute on newly created spans. */
-  namespace: string;
-  /** The name of the package invoking this trace. */
-  packageName: string;
-  /** An optional version of the package invoking this trace. */
-  packageVersion?: string;
-}
-
-/** The kind of span. */
-export type TracingSpanKind = "client" | "server" | "producer" | "consumer" | "internal";
-
-/** Options used to configure the newly created span. */
-export interface TracingSpanOptions {
-  /** The kind of span. Implementations should default this to "client". */
-  spanKind?: TracingSpanKind;
-  /** A collection of {@link TracingSpanLink} to link to this span. */
-  spanLinks?: TracingSpanLink[];
-  /** Initial set of attributes to set on a span. */
-  spanAttributes?: { [key: string]: unknown };
-}
-
-/** A pointer from the current {@link TracingSpan} to another span in the same or a different trace. */
-export interface TracingSpanLink {
-  /** The {@link TracingContext} containing the span context to link to. */
-  tracingContext: TracingContext;
-  /** A set of attributes on the link. */
-  attributes?: { [key: string]: unknown };
-}
-
-/**
- * Represents an implementation agnostic instrumenter.
- */
-export interface Instrumenter {
-  /**
-   * Creates a new {@link TracingSpan} with the given name and options and sets it on a new context.
-   * @param name - The name of the span. By convention this should be `${className}.${methodName}`.
-   * @param spanOptions - The options to use when creating the span.
-   *
-   * @returns A {@link TracingSpan} that can be used to end the span, and the context this span has been set on.
-   */
-  startSpan(
-    name: string,
-    spanOptions: InstrumenterSpanOptions,
-  ): { span: TracingSpan; tracingContext: TracingContext };
-  /**
-   * Wraps a callback with an active context and calls the callback.
-   * Depending on the implementation, this may set the globally available active context.
-   *
-   * @param context - The {@link TracingContext} to use as the active context in the scope of the callback.
-   * @param callback - The callback to be invoked with the given context set as the globally active context.
-   * @param callbackArgs - The callback arguments.
-   */
-  withContext<
-    CallbackArgs extends unknown[],
-    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,
-  >(
-    context: TracingContext,
-    callback: Callback,
-    ...callbackArgs: CallbackArgs
-  ): ReturnType<Callback>;
-
-  /**
-   * Provides an implementation-specific method to parse a {@link https://www.w3.org/TR/trace-context/#traceparent-header}
-   * into a {@link TracingSpanContext} which can be used to link non-parented spans together.
-   */
-  parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined;
-  /**
-   * Provides an implementation-specific method to serialize a {@link TracingSpan} to a set of headers.
-   * @param tracingContext - The context containing the span to serialize.
-   */
-  createRequestHeaders(tracingContext?: TracingContext): Record<string, string>;
-}
-
-/**
- * Options passed to {@link Instrumenter.startSpan} as a superset of {@link TracingSpanOptions}.
- */
-export interface InstrumenterSpanOptions extends TracingSpanOptions {
-  /** The name of the package invoking this trace. */
-  packageName: string;
-  /** The version of the package invoking this trace. */
-  packageVersion?: string;
-  /** The current tracing context. Defaults to an implementation-specific "active" context. */
-  tracingContext?: TracingContext;
-}
-
-/**
- * Status representing a successful operation that can be sent to {@link TracingSpan.setStatus}
- */
-export type SpanStatusSuccess = { status: "success" };
-
-/**
- * Status representing an error that can be sent to {@link TracingSpan.setStatus}
- */
-export type SpanStatusError = { status: "error"; error?: Error | string };
-
-/**
- * Represents the statuses that can be passed to {@link TracingSpan.setStatus}.
- *
- * By default, all spans will be created with status "unset".
- */
-export type SpanStatus = SpanStatusSuccess | SpanStatusError;
-
-/**
- * Represents options you can pass to {@link TracingSpan.addEvent}.
- */
-export interface AddEventOptions {
-  /**
-   * A set of attributes to attach to the event.
-   */
-  attributes?: Record<string, unknown>;
-  /**
-   * The start time of the event.
-   */
-  startTime?: Date;
-}
-
-/**
- * Represents an implementation agnostic tracing span.
- */
-export interface TracingSpan {
-  /**
-   * Sets the status of the span. When an error is provided, it will be recorded on the span as well.
-   *
-   * @param status - The {@link SpanStatus} to set on the span.
-   */
-  setStatus(status: SpanStatus): void;
-
-  /**
-   * Sets a given attribute on a span.
-   *
-   * @param name - The attribute's name.
-   * @param value - The attribute's value to set. May be any non-nullish value.
-   */
-  setAttribute(name: string, value: unknown): void;
-
-  /**
-   * Ends the span.
-   */
-  end(): void;
-
-  /**
-   * Records an exception on a {@link TracingSpan} without modifying its status.
-   *
-   * When recording an unhandled exception that should fail the span, please use {@link TracingSpan.setStatus} instead.
-   *
-   * @param exception - The exception to record on the span.
-   *
-   */
-  recordException(exception: Error | string): void;
-
-  /**
-   * Returns true if this {@link TracingSpan} is recording information.
-   *
-   * Depending on the span implementation, this may return false if the span is not being sampled.
-   */
-  isRecording(): boolean;
-
-  /**
-   * Adds an event to the span.
-   */
-  addEvent?(name: string, options?: AddEventOptions): void;
-}
-
-/** An immutable context bag of tracing values for the current operation. */
-export interface TracingContext {
-  /**
-   * Sets a given object on a context.
-   * @param key - The key of the given context value.
-   * @param value - The value to set on the context.
-   *
-   * @returns - A new context with the given value set.
-   */
-  setValue(key: symbol, value: unknown): TracingContext;
-  /**
-   * Gets an object from the context if it exists.
-   * @param key - The key of the given context value.
-   *
-   * @returns - The value of the given context value if it exists, otherwise `undefined`.
-   */
-  getValue(key: symbol): unknown;
-  /**
-   * Deletes an object from the context if it exists.
-   * @param key - The key of the given context value to delete.
-   */
-  deleteValue(key: symbol): TracingContext;
-}
-
-/**
- * Tracing options to set on an operation.
- */
-export interface OperationTracingOptions {
-  /** The context to use for created Tracing Spans. */
-  tracingContext?: TracingContext;
-}
-
-/**
- * A utility type for when we know a TracingContext has been set
- * as part of an operation's options.
- */
-export type OptionsWithTracingContext<
-  Options extends { tracingOptions?: OperationTracingOptions },
-> = Options & {
-  tracingOptions: {
-    tracingContext: TracingContext;
-  };
-};
diff --git a/src/tracing/state-browser.mts b/src/tracing/state-browser.mts
deleted file mode 100644
index 6e56271..0000000
--- a/src/tracing/state-browser.mts
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { Instrumenter } from "./interfaces.js";
-
-/**
- * Browser-only implementation of the module's state. The browser esm variant will not load the commonjs state, so we do not need to share state between the two.
- */
-export const state = {
-  instrumenterImplementation: undefined as Instrumenter | undefined,
-};
diff --git a/src/tracing/state-cjs.cts b/src/tracing/state-cjs.cts
deleted file mode 100644
index 181bfa0..0000000
--- a/src/tracing/state-cjs.cts
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-/**
- * @internal
- *
- * Holds the singleton instrumenter, to be shared across CJS and ESM imports.
- */
-export const state = {
-  instrumenterImplementation: undefined,
-};
diff --git a/src/tracing/state.ts b/src/tracing/state.ts
deleted file mode 100644
index c7e7a4a..0000000
--- a/src/tracing/state.ts
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { Instrumenter } from "./interfaces.js";
-// @ts-expect-error The recommended approach to sharing module state between ESM and CJS.
-// See https://github.com/isaacs/tshy/blob/main/README.md#module-local-state for additional information.
-import { state as cjsState } from "../commonjs/state.js";
-
-/**
- * Defines the shared state between CJS and ESM by re-exporting the CJS state.
- */
-export const state = cjsState as {
-  instrumenterImplementation: Instrumenter | undefined;
-};
diff --git a/src/tracing/tracingClient.ts b/src/tracing/tracingClient.ts
deleted file mode 100644
index 3e9603d..0000000
--- a/src/tracing/tracingClient.ts
+++ /dev/null
@@ -1,121 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type {
-  OperationTracingOptions,
-  OptionsWithTracingContext,
-  Resolved,
-  TracingClient,
-  TracingClientOptions,
-  TracingContext,
-  TracingSpan,
-  TracingSpanOptions,
-} from "./interfaces.js";
-import { getInstrumenter } from "./instrumenter.js";
-import { knownContextKeys } from "./tracingContext.js";
-
-/**
- * Creates a new tracing client.
- *
- * @param options - Options used to configure the tracing client.
- * @returns - An instance of {@link TracingClient}.
- */
-export function createTracingClient(options: TracingClientOptions): TracingClient {
-  const { namespace, packageName, packageVersion } = options;
-
-  function startSpan<Options extends { tracingOptions?: OperationTracingOptions }>(
-    name: string,
-    operationOptions?: Options,
-    spanOptions?: TracingSpanOptions,
-  ): {
-    span: TracingSpan;
-    updatedOptions: OptionsWithTracingContext<Options>;
-  } {
-    const startSpanResult = getInstrumenter().startSpan(name, {
-      ...spanOptions,
-      packageName: packageName,
-      packageVersion: packageVersion,
-      tracingContext: operationOptions?.tracingOptions?.tracingContext,
-    });
-    let tracingContext = startSpanResult.tracingContext;
-    const span = startSpanResult.span;
-    if (!tracingContext.getValue(knownContextKeys.namespace)) {
-      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
-    }
-    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
-    const updatedOptions: OptionsWithTracingContext<Options> = Object.assign({}, operationOptions, {
-      tracingOptions: { ...operationOptions?.tracingOptions, tracingContext },
-    });
-
-    return {
-      span,
-      updatedOptions,
-    };
-  }
-
-  async function withSpan<
-    Options extends { tracingOptions?: OperationTracingOptions },
-    Callback extends (
-      updatedOptions: Options,
-      span: Omit<TracingSpan, "end">,
-    ) => ReturnType<Callback>,
-  >(
-    name: string,
-    operationOptions: Options,
-    callback: Callback,
-    spanOptions?: TracingSpanOptions,
-  ): Promise<Resolved<ReturnType<Callback>>> {
-    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
-    try {
-      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () =>
-        Promise.resolve(callback(updatedOptions, span)),
-      );
-      span.setStatus({ status: "success" });
-      return result as ReturnType<typeof withSpan>;
-    } catch (err: any) {
-      span.setStatus({ status: "error", error: err });
-      throw err;
-    } finally {
-      span.end();
-    }
-  }
-
-  function withContext<
-    CallbackArgs extends unknown[],
-    Callback extends (...args: CallbackArgs) => ReturnType<Callback>,
-  >(
-    context: TracingContext,
-    callback: Callback,
-    ...callbackArgs: CallbackArgs
-  ): ReturnType<Callback> {
-    return getInstrumenter().withContext(context, callback, ...callbackArgs);
-  }
-
-  /**
-   * Parses a traceparent header value into a span identifier.
-   *
-   * @param traceparentHeader - The traceparent header to parse.
-   * @returns An implementation-specific identifier for the span.
-   */
-  function parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined {
-    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
-  }
-
-  /**
-   * Creates a set of request headers to propagate tracing information to a backend.
-   *
-   * @param tracingContext - The context containing the span to serialize.
-   * @returns The set of headers to add to a request.
-   */
-  function createRequestHeaders(tracingContext?: TracingContext): Record<string, string> {
-    return getInstrumenter().createRequestHeaders(tracingContext);
-  }
-
-  return {
-    startSpan,
-    withSpan,
-    withContext,
-    parseTraceparentHeader,
-    createRequestHeaders,
-  };
-}
diff --git a/src/tracing/tracingContext.ts b/src/tracing/tracingContext.ts
deleted file mode 100644
index 84999ab..0000000
--- a/src/tracing/tracingContext.ts
+++ /dev/null
@@ -1,67 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { TracingContext, TracingSpan } from "./interfaces.js";
-
-/** @internal */
-export const knownContextKeys = {
-  span: Symbol.for("@azure/core-tracing span"),
-  namespace: Symbol.for("@azure/core-tracing namespace"),
-};
-
-/**
- * Creates a new {@link TracingContext} with the given options.
- * @param options - A set of known keys that may be set on the context.
- * @returns A new {@link TracingContext} with the given options.
- *
- * @internal
- */
-export function createTracingContext(options: CreateTracingContextOptions = {}): TracingContext {
-  let context: TracingContext = new TracingContextImpl(options.parentContext);
-  if (options.span) {
-    context = context.setValue(knownContextKeys.span, options.span);
-  }
-  if (options.namespace) {
-    context = context.setValue(knownContextKeys.namespace, options.namespace);
-  }
-  return context;
-}
-
-/** @internal */
-export class TracingContextImpl implements TracingContext {
-  private _contextMap: Map<symbol, unknown>;
-  constructor(initialContext?: TracingContext) {
-    this._contextMap =
-      initialContext instanceof TracingContextImpl
-        ? new Map<symbol, unknown>(initialContext._contextMap)
-        : new Map();
-  }
-
-  setValue(key: symbol, value: unknown): TracingContext {
-    const newContext = new TracingContextImpl(this);
-    newContext._contextMap.set(key, value);
-    return newContext;
-  }
-
-  getValue(key: symbol): unknown {
-    return this._contextMap.get(key);
-  }
-
-  deleteValue(key: symbol): TracingContext {
-    const newContext = new TracingContextImpl(this);
-    newContext._contextMap.delete(key);
-    return newContext;
-  }
-}
-
-/**
- * Represents a set of items that can be set when creating a new {@link TracingContext}.
- */
-export interface CreateTracingContextOptions {
-  /** The {@link parentContext} - the newly created context will contain all the values of the parent context unless overridden. */
-  parentContext?: TracingContext;
-  /** An initial span to set on the context. */
-  span?: TracingSpan;
-  /** The namespace to set on any child spans. */
-  namespace?: string;
-}
diff --git a/src/util/aborterUtils.ts b/src/util/aborterUtils.ts
deleted file mode 100644
index ce29be9..0000000
--- a/src/util/aborterUtils.ts
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AbortSignalLike } from "@azure/abort-controller";
-
-/**
- * Options related to abort controller.
- */
-export interface AbortOptions {
-  /**
-   * The abortSignal associated with containing operation.
-   */
-  abortSignal?: AbortSignalLike;
-  /**
-   * The abort error message associated with containing operation.
-   */
-  abortErrorMsg?: string;
-}
-
-/**
- * Represents a function that returns a promise that can be aborted.
- */
-export type AbortablePromiseBuilder<T> = (abortOptions: {
-  abortSignal?: AbortSignalLike;
-}) => Promise<T>;
-
-/**
- * promise.race() wrapper that aborts rest of promises as soon as the first promise settles.
- */
-export async function cancelablePromiseRace<T extends unknown[]>(
-  abortablePromiseBuilders: AbortablePromiseBuilder<T[number]>[],
-  options?: { abortSignal?: AbortSignalLike },
-): Promise<T[number]> {
-  const aborter = new AbortController();
-  function abortHandler(): void {
-    aborter.abort();
-  }
-  options?.abortSignal?.addEventListener("abort", abortHandler);
-  try {
-    return await Promise.race(
-      abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })),
-    );
-  } finally {
-    aborter.abort();
-    options?.abortSignal?.removeEventListener("abort", abortHandler);
-  }
-}
diff --git a/src/util/bytesEncoding-browser.mts b/src/util/bytesEncoding-browser.mts
new file mode 100644
index 0000000..b01f15e
--- /dev/null
+++ b/src/util/bytesEncoding-browser.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./bytesEncoding.common.js";
diff --git a/src/util/bytesEncoding-react-native.mts b/src/util/bytesEncoding-react-native.mts
new file mode 100644
index 0000000..b01f15e
--- /dev/null
+++ b/src/util/bytesEncoding-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./bytesEncoding.common.js";
diff --git a/src/util/bytesEncoding.common.ts b/src/util/bytesEncoding.common.ts
new file mode 100644
index 0000000..2f8191a
--- /dev/null
+++ b/src/util/bytesEncoding.common.ts
@@ -0,0 +1,131 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+declare global {
+  // stub these out for the browser
+  function btoa(input: string): string;
+  function atob(input: string): string;
+}
+
+/** The supported character encoding type */
+export type EncodingType = "utf-8" | "base64" | "base64url" | "hex";
+
+/**
+ * The helper that transforms bytes with specific character encoding into string
+ * @param bytes - the uint8array bytes
+ * @param format - the format we use to encode the byte
+ * @returns a string of the encoded string
+ */
+export function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string {
+  switch (format) {
+    case "utf-8":
+      return uint8ArrayToUtf8String(bytes);
+    case "base64":
+      return uint8ArrayToBase64(bytes);
+    case "base64url":
+      return uint8ArrayToBase64Url(bytes);
+    case "hex":
+      return uint8ArrayToHexString(bytes);
+  }
+}
+
+/**
+ * The helper that transforms string to specific character encoded bytes array.
+ * @param value - the string to be converted
+ * @param format - the format we use to decode the value
+ * @returns a uint8array
+ */
+export function stringToUint8Array(value: string, format: EncodingType): Uint8Array {
+  switch (format) {
+    case "utf-8":
+      return utf8StringToUint8Array(value);
+    case "base64":
+      return base64ToUint8Array(value);
+    case "base64url":
+      return base64UrlToUint8Array(value);
+    case "hex":
+      return hexStringToUint8Array(value);
+  }
+}
+
+/**
+ * Decodes a Uint8Array into a Base64 string.
+ * @internal
+ */
+export function uint8ArrayToBase64(bytes: Uint8Array): string {
+  return btoa([...bytes].map((x) => String.fromCharCode(x)).join(""));
+}
+
+/**
+ * Decodes a Uint8Array into a Base64Url string.
+ * @internal
+ */
+export function uint8ArrayToBase64Url(bytes: Uint8Array): string {
+  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
+}
+
+/**
+ * Decodes a Uint8Array into a javascript string.
+ * @internal
+ */
+export function uint8ArrayToUtf8String(bytes: Uint8Array): string {
+  const decoder = new TextDecoder();
+  const dataString = decoder.decode(bytes);
+  return dataString;
+}
+
+/**
+ * Decodes a Uint8Array into a hex string
+ * @internal
+ */
+export function uint8ArrayToHexString(bytes: Uint8Array): string {
+  return [...bytes].map((x) => x.toString(16).padStart(2, "0")).join("");
+}
+
+/**
+ * Encodes a JavaScript string into a Uint8Array.
+ * @internal
+ */
+export function utf8StringToUint8Array(value: string): Uint8Array {
+  return new TextEncoder().encode(value);
+}
+
+/**
+ * Encodes a Base64 string into a Uint8Array.
+ * @internal
+ */
+export function base64ToUint8Array(value: string): Uint8Array {
+  return new Uint8Array([...atob(value)].map((x) => x.charCodeAt(0)));
+}
+
+/**
+ * Encodes a Base64Url string into a Uint8Array.
+ * @internal
+ */
+export function base64UrlToUint8Array(value: string): Uint8Array {
+  const base64String = value.replace(/-/g, "+").replace(/_/g, "/");
+  return base64ToUint8Array(base64String);
+}
+
+const hexDigits = new Set("0123456789abcdefABCDEF");
+
+/**
+ * Encodes a hex string into a Uint8Array
+ * @internal
+ */
+export function hexStringToUint8Array(value: string): Uint8Array {
+  // If value has odd length, the last character will be ignored, consistent with NodeJS Buffer behavior
+  const bytes = new Uint8Array(value.length / 2);
+  for (let i = 0; i < value.length / 2; ++i) {
+    const highNibble = value[2 * i];
+    const lowNibble = value[2 * i + 1];
+    if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {
+      // Replicate Node Buffer behavior by exiting early when we encounter an invalid byte
+      return bytes.slice(0, i);
+    }
+
+    bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);
+  }
+
+  return bytes;
+}
diff --git a/src/util/bytesEncoding.ts b/src/util/bytesEncoding.ts
new file mode 100644
index 0000000..b6507af
--- /dev/null
+++ b/src/util/bytesEncoding.ts
@@ -0,0 +1,25 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/** The supported character encoding type */
+export type EncodingType = "utf-8" | "base64" | "base64url" | "hex";
+
+/**
+ * The helper that transforms bytes with specific character encoding into string
+ * @param bytes - the uint8array bytes
+ * @param format - the format we use to encode the byte
+ * @returns a string of the encoded string
+ */
+export function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string {
+  return Buffer.from(bytes).toString(format);
+}
+
+/**
+ * The helper that transforms string to specific character encoded bytes array.
+ * @param value - the string to be converted
+ * @param format - the format we use to decode the value
+ * @returns a uint8array
+ */
+export function stringToUint8Array(value: string, format: EncodingType): Uint8Array {
+  return Buffer.from(value, format);
+}
diff --git a/src/util/checkEnvironment.ts b/src/util/checkEnvironment.ts
new file mode 100644
index 0000000..bc38b5d
--- /dev/null
+++ b/src/util/checkEnvironment.ts
@@ -0,0 +1,84 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+interface Window {
+  document: unknown;
+}
+
+interface DedicatedWorkerGlobalScope {
+  constructor: {
+    name: string;
+  };
+
+  importScripts: (...paths: string[]) => void;
+}
+
+interface Navigator {
+  product: string;
+}
+
+interface DenoGlobal {
+  version: {
+    deno: string;
+  };
+}
+
+interface BunGlobal {
+  version: string;
+}
+
+// eslint-disable-next-line @azure/azure-sdk/ts-no-window
+declare const window: Window;
+declare const self: DedicatedWorkerGlobalScope;
+declare const Deno: DenoGlobal;
+declare const Bun: BunGlobal;
+declare const navigator: Navigator;
+
+/**
+ * A constant that indicates whether the environment the code is running is a Web Browser.
+ */
+// eslint-disable-next-line @azure/azure-sdk/ts-no-window
+export const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
+
+/**
+ * A constant that indicates whether the environment the code is running is a Web Worker.
+ */
+export const isWebWorker =
+  typeof self === "object" &&
+  typeof self?.importScripts === "function" &&
+  (self.constructor?.name === "DedicatedWorkerGlobalScope" ||
+    self.constructor?.name === "ServiceWorkerGlobalScope" ||
+    self.constructor?.name === "SharedWorkerGlobalScope");
+
+/**
+ * A constant that indicates whether the environment the code is running is Deno.
+ */
+export const isDeno =
+  typeof Deno !== "undefined" &&
+  typeof Deno.version !== "undefined" &&
+  typeof Deno.version.deno !== "undefined";
+
+/**
+ * A constant that indicates whether the environment the code is running is Bun.sh.
+ */
+export const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
+
+/**
+ * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
+ */
+export const isNodeLike =
+  typeof globalThis.process !== "undefined" &&
+  Boolean(globalThis.process.version) &&
+  Boolean(globalThis.process.versions?.node);
+
+/**
+ * A constant that indicates whether the environment the code is running is Node.JS.
+ */
+export const isNodeRuntime = isNodeLike && !isBun && !isDeno;
+
+/**
+ * A constant that indicates whether the environment the code is running is in React-Native.
+ */
+// https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
+export const isReactNative =
+  typeof navigator !== "undefined" && navigator?.product === "ReactNative";
diff --git a/src/util/concat.ts b/src/util/concat.ts
index 457bc22..cbadccf 100644
--- a/src/util/concat.ts
+++ b/src/util/concat.ts
@@ -1,8 +1,8 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { Readable } from "node:stream";
-import type { ReadableStream as AsyncIterableReadableStream } from "node:stream/web";
+import { Readable } from "stream";
+import type { ReadableStream as AsyncIterableReadableStream } from "stream/web";
 import { isBlob } from "./typeGuards.js";
 import { getRawContent } from "./file.js";
 
diff --git a/src/util/createAbortablePromise.ts b/src/util/createAbortablePromise.ts
deleted file mode 100644
index 25cf55a..0000000
--- a/src/util/createAbortablePromise.ts
+++ /dev/null
@@ -1,60 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import { AbortError } from "@azure/abort-controller";
-import type { AbortOptions } from "./aborterUtils.js";
-
-/**
- * Options for the createAbortablePromise function.
- */
-export interface CreateAbortablePromiseOptions extends AbortOptions {
-  /** A function to be called if the promise was aborted */
-  cleanupBeforeAbort?: () => void;
-}
-
-/**
- * Creates an abortable promise.
- * @param buildPromise - A function that takes the resolve and reject functions as parameters.
- * @param options - The options for the abortable promise.
- * @returns A promise that can be aborted.
- */
-export function createAbortablePromise<T>(
-  buildPromise: (
-    resolve: (value: T | PromiseLike<T>) => void,
-    reject: (reason?: any) => void,
-  ) => void,
-  options?: CreateAbortablePromiseOptions,
-): Promise<T> {
-  const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};
-  return new Promise((resolve, reject) => {
-    function rejectOnAbort(): void {
-      reject(new AbortError(abortErrorMsg ?? "The operation was aborted."));
-    }
-    function removeListeners(): void {
-      abortSignal?.removeEventListener("abort", onAbort);
-    }
-    function onAbort(): void {
-      cleanupBeforeAbort?.();
-      removeListeners();
-      rejectOnAbort();
-    }
-    if (abortSignal?.aborted) {
-      return rejectOnAbort();
-    }
-    try {
-      buildPromise(
-        (x) => {
-          removeListeners();
-          resolve(x);
-        },
-        (x) => {
-          removeListeners();
-          reject(x);
-        },
-      );
-    } catch (err) {
-      reject(err);
-    }
-    abortSignal?.addEventListener("abort", onAbort);
-  });
-}
diff --git a/src/util/delay.ts b/src/util/delay.ts
index ab8ae56..1003a96 100644
--- a/src/util/delay.ts
+++ b/src/util/delay.ts
@@ -1,37 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import type { AbortOptions } from "./aborterUtils.js";
-import { createAbortablePromise } from "./createAbortablePromise.js";
-import { getRandomIntegerInclusive } from "@typespec/ts-http-runtime/internal/util";
-
-const StandardAbortMessage = "The delay was aborted.";
-
-/**
- * Options for support abort functionality for the delay method
- */
-export interface DelayOptions extends AbortOptions {}
-
-/**
- * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
- * @param timeInMs - The number of milliseconds to be delayed.
- * @param options - The options for delay - currently abort options
- * @returns Promise that is resolved after timeInMs
- */
-export function delay(timeInMs: number, options?: DelayOptions): Promise<void> {
-  let token: ReturnType<typeof setTimeout>;
-  const { abortSignal, abortErrorMsg } = options ?? {};
-  return createAbortablePromise(
-    (resolve) => {
-      token = setTimeout(resolve, timeInMs);
-    },
-    {
-      cleanupBeforeAbort: () => clearTimeout(token),
-      abortSignal,
-      abortErrorMsg: abortErrorMsg ?? StandardAbortMessage,
-    },
-  );
-}
+import { getRandomIntegerInclusive } from "./random.js";
 
 /**
  * Calculates the delay interval for retry attempts using exponential delay with jitter.
diff --git a/src/util/error.ts b/src/util/error.ts
index 508e2d5..34ec31c 100644
--- a/src/util/error.ts
+++ b/src/util/error.ts
@@ -1,28 +1,17 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { isError } from "@typespec/ts-http-runtime/internal/util";
+import { isObject } from "./object.js";
 
 /**
- * Given what is thought to be an error object, return the message if possible.
- * If the message is missing, returns a stringified version of the input.
- * @param e - Something thrown from a try block
- * @returns The error message or a string of the input
+ * Typeguard for an error object shape (has name and message)
+ * @param e - Something caught by a catch clause.
  */
-export function getErrorMessage(e: unknown): string {
-  if (isError(e)) {
-    return e.message;
-  } else {
-    let stringified: string;
-    try {
-      if (typeof e === "object" && e) {
-        stringified = JSON.stringify(e);
-      } else {
-        stringified = String(e);
-      }
-    } catch (err: any) {
-      stringified = "[unable to stringify input]";
-    }
-    return `Unknown error ${stringified}`;
+export function isError(e: unknown): e is Error {
+  if (isObject(e)) {
+    const hasName = typeof e.name === "string";
+    const hasMessage = typeof e.message === "string";
+    return hasName && hasMessage;
   }
+  return false;
 }
diff --git a/src/util/file.ts b/src/util/file.ts
index 48d09e6..65c0e25 100644
--- a/src/util/file.ts
+++ b/src/util/file.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { isNodeLike } from "@azure/core-util";
+import { isNodeLike } from "./checkEnvironment.js";
 import { isNodeReadableStream } from "./typeGuards.js";
 
 /**
diff --git a/src/util/helpers.ts b/src/util/helpers.ts
index f6819e8..a5b7c9d 100644
--- a/src/util/helpers.ts
+++ b/src/util/helpers.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { AbortError, type AbortSignalLike } from "@azure/abort-controller";
+import { AbortError } from "../abort-controller/AbortError.js";
 import type { PipelineResponse } from "../interfaces.js";
 
 const StandardAbortMessage = "The operation was aborted.";
@@ -19,7 +19,7 @@ export function delay<T>(
   delayInMs: number,
   value?: T,
   options?: {
-    abortSignal?: AbortSignalLike;
+    abortSignal?: AbortSignal;
     abortErrorMsg?: string;
   },
 ): Promise<T | void> {
diff --git a/src/util/index.ts b/src/util/index.ts
deleted file mode 100644
index abfafb3..0000000
--- a/src/util/index.ts
+++ /dev/null
@@ -1,186 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import * as tspRuntime from "@typespec/ts-http-runtime/internal/util";
-
-export {
-  type AbortOptions,
-  type AbortablePromiseBuilder,
-  cancelablePromiseRace,
-} from "./aborterUtils.js";
-export {
-  type CreateAbortablePromiseOptions,
-  createAbortablePromise,
-} from "./createAbortablePromise.js";
-export { type DelayOptions, delay } from "./delay.js";
-export { getErrorMessage } from "./error.js";
-export { isDefined, isObjectWithProperties, objectHasProperty } from "./typeGuards.js";
-
-/**
- * Calculates the delay interval for retry attempts using exponential delay with jitter.
- *
- * @param retryAttempt - The current retry attempt number.
- *
- * @param config - The exponential retry configuration.
- *
- * @returns An object containing the calculated retry delay.
- */
-export function calculateRetryDelay(
-  retryAttempt: number,
-  config: {
-    retryDelayInMs: number;
-    maxRetryDelayInMs: number;
-  },
-): {
-  retryAfterInMs: number;
-} {
-  return tspRuntime.calculateRetryDelay(retryAttempt, config);
-}
-
-/**
- * Generates a SHA-256 hash.
- *
- * @param content - The data to be included in the hash.
- *
- * @param encoding - The textual encoding to use for the returned hash.
- */
-export function computeSha256Hash(content: string, encoding: "base64" | "hex"): Promise<string> {
-  return tspRuntime.computeSha256Hash(content, encoding);
-}
-
-/**
- * Generates a SHA-256 HMAC signature.
- *
- * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
- *
- * @param stringToSign - The data to be signed.
- *
- * @param encoding - The textual encoding to use for the returned HMAC digest.
- */
-export function computeSha256Hmac(
-  key: string,
-  stringToSign: string,
-  encoding: "base64" | "hex",
-): Promise<string> {
-  return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
-}
-
-/**
- * Returns a random integer value between a lower and upper bound, inclusive of both bounds. Note that this uses Math.random and isn't secure. If you need to use this for any kind of security purpose, find a better source of random.
- *
- * @param min - The smallest integer value allowed.
- *
- * @param max - The largest integer value allowed.
- */
-export function getRandomIntegerInclusive(min: number, max: number): number {
-  return tspRuntime.getRandomIntegerInclusive(min, max);
-}
-
-/**
- * Typeguard for an error object shape (has name and message)
- *
- * @param e - Something caught by a catch clause.
- */
-export function isError(e: unknown): e is Error {
-  return tspRuntime.isError(e);
-}
-
-/**
- * Helper to determine when an input is a generic JS object.
- *
- * @returns true when input is an object type that is not null, Array, RegExp, or Date.
- */
-export function isObject(input: unknown): input is UnknownObject {
-  return tspRuntime.isObject(input);
-}
-
-/**
- * Generated Universally Unique Identifier
- *
- * @returns RFC4122 v4 UUID.
- */
-export function randomUUID(): string {
-  return tspRuntime.randomUUID();
-}
-
-/**
- * Supported HTTP methods to use when making requests.
- *
- * @public
- */
-export type HttpMethods =
-  | "GET"
-  | "PUT"
-  | "POST"
-  | "DELETE"
-  | "PATCH"
-  | "HEAD"
-  | "OPTIONS"
-  | "TRACE";
-
-/**
- * A generic shape for a plain JS object.
- */
-export type UnknownObject = {
-  [s: string]: unknown;
-};
-
-/**
- * A constant that indicates whether the environment the code is running is a Web Browser.
- */
-export const isBrowser: boolean = tspRuntime.isBrowser;
-/**
- * A constant that indicates whether the environment the code is running is Bun.sh.
- */
-export const isBun: boolean = tspRuntime.isBun;
-/**
- * A constant that indicates whether the environment the code is running is Deno.
- */
-export const isDeno: boolean = tspRuntime.isDeno;
-/**
- * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
- *
- * @deprecated
- *
- * Use `isNodeLike` instead.
- */
-export const isNode: boolean = tspRuntime.isNodeLike;
-/**
- * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
- */
-export const isNodeLike: boolean = tspRuntime.isNodeLike;
-/**
- * A constant that indicates whether the environment the code is running is Node.JS.
- */
-export const isNodeRuntime: boolean = tspRuntime.isNodeRuntime;
-/**
- * A constant that indicates whether the environment the code is running is in React-Native.
- */
-export const isReactNative: boolean = tspRuntime.isReactNative;
-/**
- * A constant that indicates whether the environment the code is running is a Web Worker.
- */
-export const isWebWorker: boolean = tspRuntime.isWebWorker;
-
-/** The supported character encoding type */
-export type EncodingType = "utf-8" | "base64" | "base64url" | "hex";
-
-/**
- * The helper that transforms bytes with specific character encoding into string
- * @param bytes - the uint8array bytes
- * @param format - the format we use to encode the byte
- * @returns a string of the encoded string
- */
-export function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string {
-  return tspRuntime.uint8ArrayToString(bytes, format);
-}
-
-/**
- * The helper that transforms string to specific character encoded bytes array.
- * @param value - the string to be converted
- * @param format - the format we use to decode the value
- * @returns a uint8array
- */
-export function stringToUint8Array(value: string, format: EncodingType): Uint8Array {
-  return tspRuntime.stringToUint8Array(value, format);
-}
diff --git a/src/util/internal.ts b/src/util/internal.ts
new file mode 100644
index 0000000..4bae54a
--- /dev/null
+++ b/src/util/internal.ts
@@ -0,0 +1,19 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export { calculateRetryDelay } from "./delay.js";
+export { getRandomIntegerInclusive } from "./random.js";
+export { isObject, type UnknownObject } from "./object.js";
+export { isError } from "./error.js";
+export { computeSha256Hash, computeSha256Hmac } from "./sha256.js";
+export { randomUUID } from "./uuidUtils.js";
+export {
+  isBrowser,
+  isBun,
+  isNodeLike,
+  isNodeRuntime,
+  isDeno,
+  isReactNative,
+  isWebWorker,
+} from "./checkEnvironment.js";
+export { stringToUint8Array, uint8ArrayToString, type EncodingType } from "./bytesEncoding.js";
diff --git a/src/util/object.ts b/src/util/object.ts
new file mode 100644
index 0000000..bbc8d69
--- /dev/null
+++ b/src/util/object.ts
@@ -0,0 +1,21 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/**
+ * A generic shape for a plain JS object.
+ */
+export type UnknownObject = { [s: string]: unknown };
+
+/**
+ * Helper to determine when an input is a generic JS object.
+ * @returns true when input is an object type that is not null, Array, RegExp, or Date.
+ */
+export function isObject(input: unknown): input is UnknownObject {
+  return (
+    typeof input === "object" &&
+    input !== null &&
+    !Array.isArray(input) &&
+    !(input instanceof RegExp) &&
+    !(input instanceof Date)
+  );
+}
diff --git a/src/util/random.ts b/src/util/random.ts
new file mode 100644
index 0000000..5130ca6
--- /dev/null
+++ b/src/util/random.ts
@@ -0,0 +1,21 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/**
+ * Returns a random integer value between a lower and upper bound,
+ * inclusive of both bounds.
+ * Note that this uses Math.random and isn't secure. If you need to use
+ * this for any kind of security purpose, find a better source of random.
+ * @param min - The smallest integer value allowed.
+ * @param max - The largest integer value allowed.
+ */
+export function getRandomIntegerInclusive(min: number, max: number): number {
+  // Make sure inputs are integers.
+  min = Math.ceil(min);
+  max = Math.floor(max);
+  // Pick a random offset from zero to the size of the range.
+  // Since Math.random() can never return 1, we have to make the range one larger
+  // in order to be inclusive of the maximum value after we take the floor.
+  const offset = Math.floor(Math.random() * (max - min + 1));
+  return offset + min;
+}
diff --git a/src/util/sanitizer.ts b/src/util/sanitizer.ts
index 46654b9..be4f21e 100644
--- a/src/util/sanitizer.ts
+++ b/src/util/sanitizer.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { type UnknownObject, isObject } from "@azure/core-util";
+import { type UnknownObject, isObject } from "./object.js";
 
 /**
  * @internal
diff --git a/src/client/dom.d.ts b/src/util/sha256-browser.mts
similarity index 67%
rename from src/client/dom.d.ts
rename to src/util/sha256-browser.mts
index eabe718..b24713e 100644
--- a/src/client/dom.d.ts
+++ b/src/util/sha256-browser.mts
@@ -1,4 +1,4 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-/// <reference lib="dom" />
+export * from "./sha256.common.js";
diff --git a/src/util/sha256-react-native.mts b/src/util/sha256-react-native.mts
new file mode 100644
index 0000000..b24713e
--- /dev/null
+++ b/src/util/sha256-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export * from "./sha256.common.js";
diff --git a/src/util/sha256.common.ts b/src/util/sha256.common.ts
new file mode 100644
index 0000000..38429e2
--- /dev/null
+++ b/src/util/sha256.common.ts
@@ -0,0 +1,118 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { stringToUint8Array, uint8ArrayToString } from "./bytesEncoding.js";
+
+// stubs for browser self.crypto
+interface JsonWebKey {}
+interface CryptoKey {}
+type KeyUsage =
+  | "decrypt"
+  | "deriveBits"
+  | "deriveKey"
+  | "encrypt"
+  | "sign"
+  | "unwrapKey"
+  | "verify"
+  | "wrapKey";
+interface Algorithm {
+  name: string;
+}
+interface SubtleCrypto {
+  importKey(
+    format: string,
+    keyData: JsonWebKey,
+    algorithm: HmacImportParams,
+    extractable: boolean,
+    usage: KeyUsage[],
+  ): Promise<CryptoKey>;
+  sign(
+    algorithm: HmacImportParams,
+    key: CryptoKey,
+    data: ArrayBufferView | ArrayBuffer,
+  ): Promise<ArrayBuffer>;
+  digest(algorithm: Algorithm, data: ArrayBufferView | ArrayBuffer): Promise<ArrayBuffer>;
+}
+interface Crypto {
+  readonly subtle: SubtleCrypto;
+  getRandomValues<T extends ArrayBufferView | null>(array: T): T;
+}
+declare const self: {
+  crypto: Crypto;
+};
+interface HmacImportParams {
+  name: string;
+  hash: Algorithm;
+  length?: number;
+}
+
+let subtleCrypto: SubtleCrypto | undefined;
+
+/**
+ * Returns a cached reference to the Web API crypto.subtle object.
+ * @internal
+ */
+function getCrypto(): SubtleCrypto {
+  if (subtleCrypto) {
+    return subtleCrypto;
+  }
+
+  if (!self.crypto || !self.crypto.subtle) {
+    throw new Error("Your browser environment does not support cryptography functions.");
+  }
+
+  subtleCrypto = self.crypto.subtle;
+  return subtleCrypto;
+}
+
+/**
+ * Generates a SHA-256 HMAC signature.
+ * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
+ * @param stringToSign - The data to be signed.
+ * @param encoding - The textual encoding to use for the returned HMAC digest.
+ */
+export async function computeSha256Hmac(
+  key: string,
+  stringToSign: string,
+  encoding: "base64" | "hex",
+): Promise<string> {
+  const crypto = getCrypto();
+  const keyBytes = stringToUint8Array(key, "base64");
+  const stringToSignBytes = stringToUint8Array(stringToSign, "utf-8");
+
+  const cryptoKey = await crypto.importKey(
+    "raw",
+    keyBytes,
+    {
+      name: "HMAC",
+      hash: { name: "SHA-256" },
+    },
+    false,
+    ["sign"],
+  );
+  const signature = await crypto.sign(
+    {
+      name: "HMAC",
+      hash: { name: "SHA-256" },
+    },
+    cryptoKey,
+    stringToSignBytes,
+  );
+
+  return uint8ArrayToString(new Uint8Array(signature), encoding);
+}
+
+/**
+ * Generates a SHA-256 hash.
+ * @param content - The data to be included in the hash.
+ * @param encoding - The textual encoding to use for the returned hash.
+ */
+export async function computeSha256Hash(
+  content: string,
+  encoding: "base64" | "hex",
+): Promise<string> {
+  const contentBytes = stringToUint8Array(content, "utf-8");
+  const digest = await getCrypto().digest({ name: "SHA-256" }, contentBytes);
+
+  return uint8ArrayToString(new Uint8Array(digest), encoding);
+}
diff --git a/src/util/sha256.ts b/src/util/sha256.ts
new file mode 100644
index 0000000..794d26a
--- /dev/null
+++ b/src/util/sha256.ts
@@ -0,0 +1,32 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { createHash, createHmac } from "node:crypto";
+
+/**
+ * Generates a SHA-256 HMAC signature.
+ * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
+ * @param stringToSign - The data to be signed.
+ * @param encoding - The textual encoding to use for the returned HMAC digest.
+ */
+export async function computeSha256Hmac(
+  key: string,
+  stringToSign: string,
+  encoding: "base64" | "hex",
+): Promise<string> {
+  const decodedKey = Buffer.from(key, "base64");
+
+  return createHmac("sha256", decodedKey).update(stringToSign).digest(encoding);
+}
+
+/**
+ * Generates a SHA-256 hash.
+ * @param content - The data to be included in the hash.
+ * @param encoding - The textual encoding to use for the returned hash.
+ */
+export async function computeSha256Hash(
+  content: string,
+  encoding: "base64" | "hex",
+): Promise<string> {
+  return createHash("sha256").update(content).digest(encoding);
+}
diff --git a/src/util/tokenCycler.ts b/src/util/tokenCycler.ts
deleted file mode 100644
index 32e2343..0000000
--- a/src/util/tokenCycler.ts
+++ /dev/null
@@ -1,232 +0,0 @@
-// Copyright (c) Microsoft Corporation.
-// Licensed under the MIT License.
-
-import type { AccessToken, GetTokenOptions, TokenCredential } from "@azure/core-auth";
-import { delay } from "./helpers.js";
-
-/**
- * A function that gets a promise of an access token and allows providing
- * options.
- *
- * @param options - the options to pass to the underlying token provider
- */
-export type AccessTokenGetter = (
-  scopes: string | string[],
-  options: GetTokenOptions,
-) => Promise<AccessToken>;
-
-export interface TokenCyclerOptions {
-  /**
-   * The window of time before token expiration during which the token will be
-   * considered unusable due to risk of the token expiring before sending the
-   * request.
-   *
-   * This will only become meaningful if the refresh fails for over
-   * (refreshWindow - forcedRefreshWindow) milliseconds.
-   */
-  forcedRefreshWindowInMs: number;
-  /**
-   * Interval in milliseconds to retry failed token refreshes.
-   */
-  retryIntervalInMs: number;
-  /**
-   * The window of time before token expiration during which
-   * we will attempt to refresh the token.
-   */
-  refreshWindowInMs: number;
-}
-
-// Default options for the cycler if none are provided
-export const DEFAULT_CYCLER_OPTIONS: TokenCyclerOptions = {
-  forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires
-  retryIntervalInMs: 3000, // Allow refresh attempts every 3s
-  refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry
-};
-
-/**
- * Converts an an unreliable access token getter (which may resolve with null)
- * into an AccessTokenGetter by retrying the unreliable getter in a regular
- * interval.
- *
- * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
- * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
- * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
- * @returns - A promise that, if it resolves, will resolve with an access token.
- */
-async function beginRefresh(
-  getAccessToken: () => Promise<AccessToken | null>,
-  retryIntervalInMs: number,
-  refreshTimeout: number,
-): Promise<AccessToken> {
-  // This wrapper handles exceptions gracefully as long as we haven't exceeded
-  // the timeout.
-  async function tryGetAccessToken(): Promise<AccessToken | null> {
-    if (Date.now() < refreshTimeout) {
-      try {
-        return await getAccessToken();
-      } catch {
-        return null;
-      }
-    } else {
-      const finalToken = await getAccessToken();
-
-      // Timeout is up, so throw if it's still null
-      if (finalToken === null) {
-        throw new Error("Failed to refresh access token.");
-      }
-
-      return finalToken;
-    }
-  }
-
-  let token: AccessToken | null = await tryGetAccessToken();
-
-  while (token === null) {
-    await delay(retryIntervalInMs);
-
-    token = await tryGetAccessToken();
-  }
-
-  return token;
-}
-
-/**
- * Creates a token cycler from a credential, scopes, and optional settings.
- *
- * A token cycler represents a way to reliably retrieve a valid access token
- * from a TokenCredential. It will handle initializing the token, refreshing it
- * when it nears expiration, and synchronizes refresh attempts to avoid
- * concurrency hazards.
- *
- * @param credential - the underlying TokenCredential that provides the access
- * token
- * @param tokenCyclerOptions - optionally override default settings for the cycler
- *
- * @returns - a function that reliably produces a valid access token
- */
-export function createTokenCycler(
-  credential: TokenCredential,
-  tokenCyclerOptions?: Partial<TokenCyclerOptions>,
-): AccessTokenGetter {
-  let refreshWorker: Promise<AccessToken> | null = null;
-  let token: AccessToken | null = null;
-  let tenantId: string | undefined;
-
-  const options = {
-    ...DEFAULT_CYCLER_OPTIONS,
-    ...tokenCyclerOptions,
-  };
-
-  /**
-   * This little holder defines several predicates that we use to construct
-   * the rules of refreshing the token.
-   */
-  const cycler = {
-    /**
-     * Produces true if a refresh job is currently in progress.
-     */
-    get isRefreshing(): boolean {
-      return refreshWorker !== null;
-    },
-    /**
-     * Produces true if the cycler SHOULD refresh (we are within the refresh
-     * window and not already refreshing)
-     */
-    get shouldRefresh(): boolean {
-      if (cycler.isRefreshing) {
-        return false;
-      }
-      if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) {
-        return true;
-      }
-
-      return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();
-    },
-    /**
-     * Produces true if the cycler MUST refresh (null or nearly-expired
-     * token).
-     */
-    get mustRefresh(): boolean {
-      return (
-        token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now()
-      );
-    },
-  };
-
-  /**
-   * Starts a refresh job or returns the existing job if one is already
-   * running.
-   */
-  function refresh(
-    scopes: string | string[],
-    getTokenOptions: GetTokenOptions,
-  ): Promise<AccessToken> {
-    if (!cycler.isRefreshing) {
-      // We bind `scopes` here to avoid passing it around a lot
-      const tryGetAccessToken = (): Promise<AccessToken | null> =>
-        credential.getToken(scopes, getTokenOptions);
-
-      // Take advantage of promise chaining to insert an assignment to `token`
-      // before the refresh can be considered done.
-      refreshWorker = beginRefresh(
-        tryGetAccessToken,
-        options.retryIntervalInMs,
-        // If we don't have a token, then we should timeout immediately
-        token?.expiresOnTimestamp ?? Date.now(),
-      )
-        .then((_token) => {
-          refreshWorker = null;
-          token = _token;
-          tenantId = getTokenOptions.tenantId;
-          return token;
-        })
-        .catch((reason) => {
-          // We also should reset the refresher if we enter a failed state.  All
-          // existing awaiters will throw, but subsequent requests will start a
-          // new retry chain.
-          refreshWorker = null;
-          token = null;
-          tenantId = undefined;
-          throw reason;
-        });
-    }
-
-    return refreshWorker as Promise<AccessToken>;
-  }
-
-  return async (scopes: string | string[], tokenOptions: GetTokenOptions): Promise<AccessToken> => {
-    //
-    // Simple rules:
-    // - If we MUST refresh, then return the refresh task, blocking
-    //   the pipeline until a token is available.
-    // - If we SHOULD refresh, then run refresh but don't return it
-    //   (we can still use the cached token).
-    // - Return the token, since it's fine if we didn't return in
-    //   step 1.
-    //
-
-    const hasClaimChallenge = Boolean(tokenOptions.claims);
-    const tenantIdChanged = tenantId !== tokenOptions.tenantId;
-
-    if (hasClaimChallenge) {
-      // If we've received a claim, we know the existing token isn't valid
-      // We want to clear it so that that refresh worker won't use the old expiration time as a timeout
-      token = null;
-    }
-
-    // If the tenantId passed in token options is different to the one we have
-    // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to
-    // refresh the token with the new tenantId or token.
-    const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
-
-    if (mustRefresh) {
-      return refresh(scopes, tokenOptions);
-    }
-
-    if (cycler.shouldRefresh) {
-      refresh(scopes, tokenOptions);
-    }
-
-    return token as AccessToken;
-  };
-}
diff --git a/src/util/typeGuards.ts b/src/util/typeGuards.ts
index 22a9cac..265ded3 100644
--- a/src/util/typeGuards.ts
+++ b/src/util/typeGuards.ts
@@ -1,46 +1,40 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-/**
- * Helper TypeGuard that checks if something is defined or not.
- * @param thing - Anything
- */
-export function isDefined<T>(thing: T | undefined | null): thing is T {
-  return typeof thing !== "undefined" && thing !== null;
+export function isNodeReadableStream(x: unknown): x is NodeJS.ReadableStream {
+  return Boolean(x && typeof (x as NodeJS.ReadableStream)["pipe"] === "function");
 }
 
-/**
- * Helper TypeGuard that checks if the input is an object with the specified properties.
- * @param thing - Anything.
- * @param properties - The name of the properties that should appear in the object.
- */
-export function isObjectWithProperties<Thing, PropertyName extends string>(
-  thing: Thing,
-  properties: PropertyName[],
-): thing is Thing & Record<PropertyName, unknown> {
-  if (!isDefined(thing) || typeof thing !== "object") {
-    return false;
+export function isWebReadableStream(x: unknown): x is ReadableStream {
+  return Boolean(
+    x &&
+      typeof (x as ReadableStream).getReader === "function" &&
+      typeof (x as ReadableStream).tee === "function",
+  );
 }
 
-  for (const property of properties) {
-    if (!objectHasProperty(thing, property)) {
-      return false;
-    }
+export function isBinaryBody(
+  body: unknown,
+): body is
+  | Uint8Array
+  | NodeJS.ReadableStream
+  | ReadableStream<Uint8Array>
+  | (() => NodeJS.ReadableStream)
+  | (() => ReadableStream<Uint8Array>)
+  | Blob {
+  return (
+    body !== undefined &&
+    (body instanceof Uint8Array ||
+      isReadableStream(body) ||
+      typeof body === "function" ||
+      body instanceof Blob)
+  );
 }
 
-  return true;
+export function isReadableStream(x: unknown): x is ReadableStream | NodeJS.ReadableStream {
+  return isNodeReadableStream(x) || isWebReadableStream(x);
 }
 
-/**
- * Helper TypeGuard that checks if the input is an object with the specified property.
- * @param thing - Any object.
- * @param property - The name of the property that should appear in the object.
- */
-export function objectHasProperty<Thing, PropertyName extends string>(
-  thing: Thing,
-  property: PropertyName,
-): thing is Thing & Record<PropertyName, unknown> {
-  return (
-    isDefined(thing) && typeof thing === "object" && property in (thing as Record<string, unknown>)
-  );
+export function isBlob(x: unknown): x is Blob {
+  return typeof (x as Blob).stream === "function";
 }
diff --git a/src/util/userAgent.ts b/src/util/userAgent.ts
index b8950b5..3ef33c8 100644
--- a/src/util/userAgent.ts
+++ b/src/util/userAgent.ts
@@ -25,7 +25,7 @@ export function getUserAgentHeaderName(): string {
  */
 export async function getUserAgentValue(prefix?: string): Promise<string> {
   const runtimeInfo = new Map<string, string>();
-  runtimeInfo.set("core-rest-pipeline", SDK_VERSION);
+  runtimeInfo.set("ts-http-runtime", SDK_VERSION);
   await setPlatformSpecificData(runtimeInfo);
   const defaultAgent = getUserAgentString(runtimeInfo);
   const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
diff --git a/src/util/uuidUtils-browser.mts b/src/util/uuidUtils-browser.mts
new file mode 100644
index 0000000..0e8d3c7
--- /dev/null
+++ b/src/util/uuidUtils-browser.mts
@@ -0,0 +1,27 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { generateUUID } from "./uuidUtils.common.js";
+
+interface Crypto {
+  randomUUID(): string;
+}
+
+declare const globalThis: {
+  crypto: Crypto;
+};
+
+// NOTE: This could be undefined if not used in a secure context
+const uuidFunction =
+  typeof globalThis?.crypto?.randomUUID === "function"
+    ? globalThis.crypto.randomUUID.bind(globalThis.crypto)
+    : generateUUID;
+
+/**
+ * Generated Universally Unique Identifier
+ *
+ * @returns RFC4122 v4 UUID.
+ */
+export function randomUUID(): string {
+  return uuidFunction();
+}
diff --git a/src/util/uuidUtils-react-native.mts b/src/util/uuidUtils-react-native.mts
new file mode 100644
index 0000000..cc49ba6
--- /dev/null
+++ b/src/util/uuidUtils-react-native.mts
@@ -0,0 +1,4 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+export { randomUUID } from "./uuidUtils.common.js";
diff --git a/src/util/uuidUtils.common.ts b/src/util/uuidUtils.common.ts
new file mode 100644
index 0000000..1fa8b8f
--- /dev/null
+++ b/src/util/uuidUtils.common.ts
@@ -0,0 +1,39 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+/**
+ * Generated Universally Unique Identifier
+ *
+ * @returns RFC4122 v4 UUID.
+ */
+export function generateUUID(): string {
+  let uuid = "";
+  for (let i = 0; i < 32; i++) {
+    // Generate a random number between 0 and 15
+    const randomNumber = Math.floor(Math.random() * 16);
+    // Set the UUID version to 4 in the 13th position
+    if (i === 12) {
+      uuid += "4";
+    } else if (i === 16) {
+      // Set the UUID variant to "10" in the 17th position
+      uuid += (randomNumber & 0x3) | 0x8;
+    } else {
+      // Add a random hexadecimal digit to the UUID string
+      uuid += randomNumber.toString(16);
+    }
+    // Add hyphens to the UUID string at the appropriate positions
+    if (i === 7 || i === 11 || i === 15 || i === 19) {
+      uuid += "-";
+    }
+  }
+  return uuid;
+}
+
+/**
+ * Generated Universally Unique Identifier
+ *
+ * @returns RFC4122 v4 UUID.
+ */
+export function randomUUID(): string {
+  return generateUUID();
+}
diff --git a/src/util/uuidUtils.ts b/src/util/uuidUtils.ts
new file mode 100644
index 0000000..3f6a12b
--- /dev/null
+++ b/src/util/uuidUtils.ts
@@ -0,0 +1,27 @@
+// Copyright (c) Microsoft Corporation.
+// Licensed under the MIT License.
+
+import { randomUUID as v4RandomUUID } from "node:crypto";
+
+interface Crypto {
+  randomUUID(): string;
+}
+
+declare const globalThis: {
+  crypto: Crypto;
+};
+
+// NOTE: This is a workaround until we can use `globalThis.crypto.randomUUID` in Node.js 19+.
+const uuidFunction =
+  typeof globalThis?.crypto?.randomUUID === "function"
+    ? globalThis.crypto.randomUUID.bind(globalThis.crypto)
+    : v4RandomUUID;
+
+/**
+ * Generated Universally Unique Identifier
+ *
+ * @returns RFC4122 v4 UUID.
+ */
+export function randomUUID(): string {
+  return uuidFunction();
+}
diff --git a/src/xhrHttpClient.ts b/src/xhrHttpClient.ts
index 4a0acaa..2a8f850 100644
--- a/src/xhrHttpClient.ts
+++ b/src/xhrHttpClient.ts
@@ -1,7 +1,7 @@
 // Copyright (c) Microsoft Corporation.
 // Licensed under the MIT License.
 
-import { AbortError } from "@azure/abort-controller";
+import { AbortError } from "./abort-controller/AbortError.js";
 import type {
   HttpClient,
   HttpHeaders,
