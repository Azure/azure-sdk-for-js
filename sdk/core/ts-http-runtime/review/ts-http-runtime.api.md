## API Report File for "@typespec/ts-http-runtime"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

// @public
export type AbortablePromiseBuilder<T> = (abortOptions: {
    abortSignal?: AbortSignalLike;
}) => Promise<T>;

// @public
export class AbortError extends Error {
    constructor(message?: string);
}

// @public
export interface AbortOptions {
    abortErrorMsg?: string;
    abortSignal?: AbortSignalLike;
}

// @public
export interface AbortSignalLike {
    readonly aborted: boolean;
    addEventListener(type: "abort", listener: (this: AbortSignalLike, ev: any) => any, options?: any): void;
    removeEventListener(type: "abort", listener: (this: AbortSignalLike, ev: any) => any, options?: any): void;
}

// @public
export interface AccessToken {
    expiresOnTimestamp: number;
    token: string;
}

// @public
export function addCredentialPipelinePolicy(pipeline: Pipeline, baseUrl: string, options?: AddCredentialPipelinePolicyOptions): void;

// @public
export interface AddCredentialPipelinePolicyOptions {
    clientOptions?: ClientOptions;
    // Warning: (ae-forgotten-export) The symbol "KeyCredential" needs to be exported by the entry point index.d.ts
    credential?: TokenCredential | KeyCredential;
}

// @public
export interface AdditionalPolicyConfig {
    policy: PipelinePolicy;
    position: "perCall" | "perRetry";
}

// @public
export interface AddPipelineOptions {
    afterPhase?: PipelinePhase;
    afterPolicies?: string[];
    beforePolicies?: string[];
    phase?: PipelinePhase;
}

// @public
export interface Agent {
    destroy(): void;
    maxFreeSockets: number;
    maxSockets: number;
    requests: unknown;
    sockets: unknown;
}

// @public
export interface AuthorizeRequestOnChallengeOptions {
    getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;
    logger?: TypeSpecRuntimeLogger;
    request: PipelineRequest;
    response: PipelineResponse;
    scopes: string[];
}

// @public
export interface AuthorizeRequestOptions {
    getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;
    logger?: TypeSpecRuntimeLogger;
    request: PipelineRequest;
    scopes: string[];
}

// @public
export function bearerTokenAuthenticationPolicy(options: BearerTokenAuthenticationPolicyOptions): PipelinePolicy;

// @public
export const bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";

// @public
export interface BearerTokenAuthenticationPolicyOptions {
    challengeCallbacks?: ChallengeCallbacks;
    credential?: TokenCredential;
    logger?: TypeSpecRuntimeLogger;
    scopes: string | string[];
}

// @public
export function cancelablePromiseRace<T extends unknown[]>(abortablePromiseBuilders: AbortablePromiseBuilder<T[number]>[], options?: {
    abortSignal?: AbortSignalLike;
}): Promise<T[number]>;

// @public
export interface ChallengeCallbacks {
    authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;
    authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;
}

// @public
export interface Client {
    path: Function;
    pathUnchecked: PathUnchecked;
    pipeline: Pipeline;
}

// @public
export type ClientOptions = PipelineOptions & {
    credentials?: {
        scopes?: string[];
        apiKeyHeaderName?: string;
    };
    baseUrl?: string;
    apiVersion?: string;
    allowInsecureConnection?: boolean;
    additionalPolicies?: AdditionalPolicyConfig[];
    httpClient?: HttpClient;
    loggingOptions?: LogPolicyOptions;
};

// @public
export function computeSha256Hash(content: string, encoding: "base64" | "hex"): Promise<string>;

// @public
export function computeSha256Hmac(key: string, stringToSign: string, encoding: "base64" | "hex"): Promise<string>;

// @public
export function createAbortablePromise<T>(buildPromise: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void, options?: CreateAbortablePromiseOptions): Promise<T>;

// @public
export interface CreateAbortablePromiseOptions extends AbortOptions {
    cleanupBeforeAbort?: () => void;
}

// @public
export function createDefaultHttpClient(): HttpClient;

// @public
export function createEmptyPipeline(): Pipeline;

// @public
export function createHttpHeaders(rawHeaders?: RawHttpHeadersInput): HttpHeaders;

// @public
export function createPipelineFromOptions(options: InternalPipelineOptions): Pipeline;

// @public
export function createPipelineRequest(options: PipelineRequestOptions): PipelineRequest;

// @public
export function createRestError(message: string, response: PathUncheckedResponse): RestError;

// @public
export function createTracingClient(options: TracingClientOptions): TracingClient;

// @public
export interface Debugger {
    (...args: any[]): void;
    destroy: () => boolean;
    enabled: boolean;
    extend: (namespace: string) => Debugger;
    log: (...args: any[]) => void;
    namespace: string;
}

// @public
export function decompressResponsePolicy(): PipelinePolicy;

// @public
export const decompressResponsePolicyName = "decompressResponsePolicy";

// @public
export function defaultRetryPolicy(options?: DefaultRetryPolicyOptions): PipelinePolicy;

// @public
export interface DefaultRetryPolicyOptions extends PipelineRetryOptions {
}

// @public
export function delay(timeInMs: number, options?: DelayOptions_2): Promise<void>;

// @public
interface DelayOptions_2 extends AbortOptions {
}
export { DelayOptions_2 as DelayOptions }

// @public
export type EncodingType = "utf-8" | "base64" | "base64url" | "hex";

// @public
export interface ErrorModel {
    code: string;
    details: Array<ErrorModel>;
    innererror?: InnerError;
    message: string;
    target?: string;
}

// @public
export interface ErrorResponse {
    error: ErrorModel;
}

// @public
export type FormDataMap = {
    [key: string]: FormDataValue | FormDataValue[];
};

// @public
export function formDataPolicy(): PipelinePolicy;

// @public
export const formDataPolicyName = "formDataPolicy";

// @public
export type FormDataValue = string | Blob;

// @public
export interface FullOperationResponse extends PipelineResponse {
    parsedBody?: RequestBodyType;
    rawHeaders?: RawHttpHeaders;
    request: PipelineRequest;
}

// @public
export function getClient(baseUrl: string, options?: ClientOptions): Client;

// @public
export function getClient(baseUrl: string, credentials?: TokenCredential | KeyCredential, options?: ClientOptions): Client;

// @public
export function getDefaultProxySettings(proxyUrl?: string): ProxySettings | undefined;

// @public
export function getErrorMessage(e: unknown): string;

// @public
export function getRandomIntegerInclusive(min: number, max: number): number;

// @public
export interface GetTokenOptions {
    abortSignal?: AbortSignalLike;
    claims?: string;
    enableCae?: boolean;
    requestOptions?: {
        timeout?: number;
    };
    tenantId?: string;
    tracingOptions?: {
        tracingContext?: TracingContext;
    };
}

// @public
export type HttpBrowserStreamResponse = HttpResponse & {
    body?: ReadableStream<Uint8Array>;
};

// @public
export interface HttpClient {
    sendRequest: SendRequest;
}

// @public
export interface HttpHeaders extends Iterable<[string, string]> {
    delete(name: string): void;
    get(name: string): string | undefined;
    has(name: string): boolean;
    set(name: string, value: string | number | boolean): void;
    toJSON(options?: {
        preserveCase?: boolean;
    }): RawHttpHeaders;
}

// @public
export type HttpMethods = "GET" | "PUT" | "POST" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS" | "TRACE";

// @public
export type HttpNodeStreamResponse = HttpResponse & {
    body?: NodeJS.ReadableStream;
};

// @public
export type HttpResponse = {
    request: PipelineRequest;
    headers: RawHttpHeaders;
    body: unknown;
    status: string;
};

// @public
export interface InnerError {
    code: string;
    innererror?: InnerError;
}

// @public
export interface Instrumenter {
    createRequestHeaders(tracingContext?: TracingContext): Record<string, string>;
    parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined;
    startSpan(name: string, spanOptions: InstrumenterSpanOptions): {
        span: TracingSpan;
        tracingContext: TracingContext;
    };
    withContext<CallbackArgs extends unknown[], Callback extends (...args: CallbackArgs) => ReturnType<Callback>>(context: TracingContext, callback: Callback, ...callbackArgs: CallbackArgs): ReturnType<Callback>;
}

// @public
export interface InstrumenterSpanOptions extends TracingSpanOptions {
    packageName: string;
    packageVersion?: string;
    tracingContext?: TracingContext;
}

// @public
export interface InternalPipelineOptions extends PipelineOptions {
    loggingOptions?: LogPolicyOptions;
}

// @public
export const isBrowser: boolean;

// @public
export const isBun: boolean;

// @public
export function isDefined<T>(thing: T | undefined | null): thing is T;

// @public
export const isDeno: boolean;

// @public
export function isError(e: unknown): e is Error;

// @public
export const isNode: boolean;

// @public
export function isObject(input: unknown): input is UnknownObject;

// @public
export function isObjectWithProperties<Thing, PropertyName extends string>(thing: Thing, properties: PropertyName[]): thing is Thing & Record<PropertyName, unknown>;

// @public
export const isReactNative: boolean;

// @public
export function isRestError(e: unknown): e is RestError;

// @public
export const isWebWorker: boolean;

// @public
export interface KeyObject {
    passphrase?: string | undefined;
    pem: string | Buffer;
}

// @public
export function logPolicy(options?: LogPolicyOptions): PipelinePolicy;

// @public
export const logPolicyName = "logPolicy";

// @public
export interface LogPolicyOptions {
    additionalAllowedHeaderNames?: string[];
    additionalAllowedQueryParameters?: string[];
    logger?: Debugger;
}

// @public
export function objectHasProperty<Thing, PropertyName extends string>(thing: Thing, property: PropertyName): thing is Thing & Record<PropertyName, unknown>;

// @public
export interface OperationOptions {
    abortSignal?: AbortSignalLike;
    onResponse?: RawResponseCallback;
    requestOptions?: OperationRequestOptions;
    tracingOptions?: OperationTracingOptions;
}

// @public
export function operationOptionsToRequestParameters(options: OperationOptions): RequestParameters;

// @public
export interface OperationRequestOptions {
    allowInsecureConnection?: boolean;
    headers?: RawHttpHeadersInput;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    skipUrlEncoding?: boolean;
    timeout?: number;
}

// @public
export interface OperationTracingOptions {
    tracingContext?: TracingContext;
}

// @public
export type OptionsWithTracingContext<Options extends {
    tracingOptions?: OperationTracingOptions;
}> = Options & {
    tracingOptions: {
        tracingContext: TracingContext;
    };
};

// @public
export type PathParameters<TRoute extends string> = TRoute extends `${infer _Head}/{${infer _Param}}${infer Tail}` ? [
pathParameter: string,
...pathParameters: PathParameters<Tail>
] : [
];

// @public
export type PathUnchecked = <TPath extends string>(path: TPath, ...args: PathParameters<TPath>) => ResourceMethods<StreamableMethod>;

// @public
export type PathUncheckedResponse = HttpResponse & {
    body: any;
};

// @public
export interface Pipeline {
    addPolicy(policy: PipelinePolicy, options?: AddPipelineOptions): void;
    clone(): Pipeline;
    getOrderedPolicies(): PipelinePolicy[];
    removePolicy(options: {
        name?: string;
        phase?: PipelinePhase;
    }): PipelinePolicy[];
    sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;
}

// @public
export interface PipelineOptions {
    proxyOptions?: ProxySettings;
    redirectOptions?: RedirectPolicyOptions;
    retryOptions?: PipelineRetryOptions;
    telemetryOptions?: TelemetryOptions;
    tlsOptions?: TlsSettings;
    userAgentOptions?: UserAgentPolicyOptions;
}

// @public
export type PipelinePhase = "Deserialize" | "Serialize" | "Retry" | "Sign";

// @public
export interface PipelinePolicy {
    name: string;
    sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;
}

// @public
export interface PipelineRequest {
    abortSignal?: AbortSignalLike;
    agent?: Agent;
    allowInsecureConnection?: boolean;
    body?: RequestBodyType;
    disableKeepAlive?: boolean;
    enableBrowserStreams?: boolean;
    formData?: FormDataMap;
    headers: HttpHeaders;
    method: HttpMethods;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    proxySettings?: ProxySettings;
    requestId: string;
    streamResponseStatusCodes?: Set<number>;
    timeout: number;
    tlsSettings?: TlsSettings;
    tracingOptions?: OperationTracingOptions;
    url: string;
    withCredentials: boolean;
}

// @public
export interface PipelineRequestOptions {
    abortSignal?: AbortSignalLike;
    allowInsecureConnection?: boolean;
    body?: RequestBodyType;
    disableKeepAlive?: boolean;
    enableBrowserStreams?: boolean;
    formData?: FormDataMap;
    headers?: HttpHeaders;
    method?: HttpMethods;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    proxySettings?: ProxySettings;
    requestId?: string;
    streamResponseStatusCodes?: Set<number>;
    timeout?: number;
    tracingOptions?: OperationTracingOptions;
    url: string;
    withCredentials?: boolean;
}

// @public
export interface PipelineResponse {
    blobBody?: Promise<Blob>;
    bodyAsText?: string | null;
    browserStreamBody?: ReadableStream<Uint8Array>;
    headers: HttpHeaders;
    readableStreamBody?: NodeJS.ReadableStream;
    request: PipelineRequest;
    status: number;
}

// @public
export interface PipelineRetryOptions {
    maxRetries?: number;
    maxRetryDelayInMs?: number;
    retryDelayInMs?: number;
}

// @public
export function proxyPolicy(proxySettings?: ProxySettings | undefined, options?: {
    customNoProxyList?: string[];
}): PipelinePolicy;

// @public
export const proxyPolicyName = "proxyPolicy";

// @public
export interface ProxySettings {
    host: string;
    password?: string;
    port: number;
    username?: string;
}

// @public
export interface PxfObject {
    buf: string | Buffer;
    passphrase?: string | undefined;
}

// @public
export function randomUUID(): string;

// @public
export type RawHttpHeaders = {
    [headerName: string]: string;
};

// @public
export type RawHttpHeadersInput = Record<string, string | number | boolean>;

// @public
export type RawResponseCallback = (rawResponse: FullOperationResponse, error?: unknown) => void;

// @public
export function redirectPolicy(options?: RedirectPolicyOptions): PipelinePolicy;

// @public
export const redirectPolicyName = "redirectPolicy";

// @public
export interface RedirectPolicyOptions {
    maxRetries?: number;
}

// @public
export type RequestBodyType = NodeJS.ReadableStream | (() => NodeJS.ReadableStream) | ReadableStream<Uint8Array> | (() => ReadableStream<Uint8Array>) | Blob | ArrayBuffer | ArrayBufferView | FormData | string | null;

// @public
export type RequestParameters = {
    headers?: RawHttpHeadersInput;
    accept?: string;
    body?: unknown;
    queryParameters?: Record<string, unknown>;
    contentType?: string;
    allowInsecureConnection?: boolean;
    skipUrlEncoding?: boolean;
    pathParameters?: Record<string, any>;
    timeout?: number;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    abortSignal?: AbortSignalLike;
    tracingOptions?: OperationTracingOptions;
    onResponse?: RawResponseCallback;
};

// @public
export type Resolved<T> = T extends {
    then(onfulfilled: infer F): any;
} ? F extends (value: infer V) => any ? Resolved<V> : never : T;

// @public
export interface ResourceMethods<TResponse = PromiseLike<PathUncheckedResponse>> {
    delete: (options?: RequestParameters) => TResponse;
    get: (options?: RequestParameters) => TResponse;
    head: (options?: RequestParameters) => TResponse;
    options: (options?: RequestParameters) => TResponse;
    patch: (options?: RequestParameters) => TResponse;
    post: (options?: RequestParameters) => TResponse;
    put: (options?: RequestParameters) => TResponse;
    trace: (options?: RequestParameters) => TResponse;
}

// @public
export class RestError extends Error {
    constructor(message: string, options?: RestErrorOptions);
    code?: string;
    details?: unknown;
    static readonly PARSE_ERROR: string;
    request?: PipelineRequest;
    static readonly REQUEST_SEND_ERROR: string;
    response?: PipelineResponse;
    statusCode?: number;
}

// @public
export interface RestErrorOptions {
    code?: string;
    request?: PipelineRequest;
    response?: PipelineResponse;
    statusCode?: number;
}

// @public
export type SendRequest = (request: PipelineRequest) => Promise<PipelineResponse>;

// @public
export type SpanStatus = SpanStatusSuccess | SpanStatusError;

// @public
export type SpanStatusError = {
    status: "error";
    error?: Error | string;
};

// @public
export type SpanStatusSuccess = {
    status: "success";
};

// @public
export type StreamableMethod<TResponse = PathUncheckedResponse> = PromiseLike<TResponse> & {
    asNodeStream: () => Promise<HttpNodeStreamResponse>;
    asBrowserStream: () => Promise<HttpBrowserStreamResponse>;
};

// @public
export function stringToUint8Array(value: string, format: EncodingType): Uint8Array;

// @public
export interface TelemetryOptions {
    clientRequestIdHeaderName?: string;
}

// @public
export function tlsPolicy(tlsSettings?: TlsSettings): PipelinePolicy;

// @public
export const tlsPolicyName = "tlsPolicy";

// @public
export interface TlsSettings {
    ca?: string | Buffer | Array<string | Buffer> | undefined;
    cert?: string | Buffer | Array<string | Buffer> | undefined;
    key?: string | Buffer | Array<Buffer | KeyObject> | undefined;
    passphrase?: string | undefined;
    pfx?: string | Buffer | Array<string | Buffer | PxfObject> | undefined;
}

// @public
export interface TokenCredential {
    getToken(scopes: string | string[], options?: GetTokenOptions): Promise<AccessToken | null>;
}

// @public
export interface TracingClient {
    createRequestHeaders(tracingContext?: TracingContext): Record<string, string>;
    parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined;
    startSpan<Options extends {
        tracingOptions?: OperationTracingOptions;
    }>(name: string, operationOptions?: Options, spanOptions?: TracingSpanOptions): {
        span: TracingSpan;
        updatedOptions: OptionsWithTracingContext<Options>;
    };
    withContext<CallbackArgs extends unknown[], Callback extends (...args: CallbackArgs) => ReturnType<Callback>>(context: TracingContext, callback: Callback, ...callbackArgs: CallbackArgs): ReturnType<Callback>;
    withSpan<Options extends {
        tracingOptions?: OperationTracingOptions;
    }, Callback extends (updatedOptions: Options, span: Omit<TracingSpan, "end">) => ReturnType<Callback>>(name: string, operationOptions: Options, callback: Callback, spanOptions?: TracingSpanOptions): Promise<Resolved<ReturnType<Callback>>>;
}

// @public
export interface TracingClientOptions {
    namespace: string;
    packageName: string;
    packageVersion?: string;
}

// @public
export interface TracingContext {
    deleteValue(key: symbol): TracingContext;
    getValue(key: symbol): unknown;
    setValue(key: symbol, value: unknown): TracingContext;
}

// @public
export function tracingPolicy(options?: TracingPolicyOptions): PipelinePolicy;

// @public
export const tracingPolicyName = "tracingPolicy";

// @public
export interface TracingPolicyOptions {
    userAgentPrefix?: string;
}

// @public
export interface TracingSpan {
    end(): void;
    isRecording(): boolean;
    recordException(exception: Error | string): void;
    setAttribute(name: string, value: unknown): void;
    setStatus(status: SpanStatus): void;
}

// @public
export type TracingSpanKind = "client" | "server" | "producer" | "consumer" | "internal";

// @public
export interface TracingSpanLink {
    attributes?: {
        [key: string]: unknown;
    };
    tracingContext: TracingContext;
}

// @public
export interface TracingSpanOptions {
    spanAttributes?: {
        [key: string]: unknown;
    };
    spanKind?: TracingSpanKind;
    spanLinks?: TracingSpanLink[];
}

// @public
export type TransferProgressEvent = {
    loadedBytes: number;
};

// @public
export type TypeSpecRuntimeClientLogger = Debugger;

// @public
export const TypeSpecRuntimeLogger: TypeSpecRuntimeClientLogger;

// @public
export interface TypeSpecRuntimeLogger {
    error: Debugger;
    info: Debugger;
    verbose: Debugger;
    warning: Debugger;
}

// @public
export type TypeSpecRuntimeLogLevel = "verbose" | "info" | "warning" | "error";

// @public
export function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string;

// @public
export type UnknownObject = {
    [s: string]: unknown;
};

// @public
export function useInstrumenter(instrumenter: Instrumenter): void;

// @public
export function userAgentPolicy(options?: UserAgentPolicyOptions): PipelinePolicy;

// @public
export const userAgentPolicyName = "userAgentPolicy";

// @public
export interface UserAgentPolicyOptions {
    userAgentPrefix?: string;
}

// (No @packageDocumentation comment for this package)

```
