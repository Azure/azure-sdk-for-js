## API Report File for "@azure/core-http"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AbortSignalLike } from '@azure/abort-controller';
import { AccessToken } from '@azure/core-auth';
import { Context } from '@azure/core-tracing';
import { Debugger } from '@azure/logger';
import { GetTokenOptions } from '@azure/core-auth';
import { isTokenCredential } from '@azure/core-auth';
import { OperationTracingOptions } from '@azure/core-tracing';
import { Span } from '@azure/core-tracing';
import { SpanOptions } from '@azure/core-tracing';
import { TokenCredential } from '@azure/core-auth';

export { AbortSignalLike }

export { AccessToken }

// @public
export interface AccessTokenCache {
    getCachedToken(): AccessToken | undefined;
    setCachedToken(accessToken: AccessToken | undefined): void;
}

// @public @deprecated
export class AccessTokenRefresher {
    constructor(credential: TokenCredential, scopes: string | string[], requiredMillisecondsBeforeNewRefresh?: number);
    isReady(): boolean;
    refresh(options: GetTokenOptions): Promise<AccessToken | undefined>;
}

// @public
export interface ApiKeyCredentialOptions {
    inHeader?: {
        [x: string]: any;
    };
    inQuery?: {
        [x: string]: any;
    };
}

// @public
export class ApiKeyCredentials implements ServiceClientCredentials {
    constructor(options: ApiKeyCredentialOptions);
    signRequest(webResource: WebResourceLike): Promise<WebResourceLike>;
}

// @public
export function applyMixins(targetCtorParam: unknown, sourceCtors: any[]): void;

// @public
export type Authenticator = (challenge: unknown) => Promise<string>;

// @public
export interface BaseMapper {
    constraints?: MapperConstraints;
    defaultValue?: any;
    isConstant?: boolean;
    nullable?: boolean;
    readOnly?: boolean;
    required?: boolean;
    serializedName?: string;
    type: MapperType;
    xmlElementName?: string;
    xmlIsAttribute?: boolean;
    xmlIsWrapped?: boolean;
    xmlName?: string;
    xmlNamespace?: string;
    xmlNamespacePrefix?: string;
}

// @public
export abstract class BaseRequestPolicy implements RequestPolicy {
    protected constructor(
    _nextPolicy: RequestPolicy,
    _options: RequestPolicyOptionsLike);
    log(logLevel: HttpPipelineLogLevel, message: string): void;
    readonly _nextPolicy: RequestPolicy;
    readonly _options: RequestPolicyOptionsLike;
    abstract sendRequest(webResource: WebResourceLike): Promise<HttpOperationResponse>;
    shouldLog(logLevel: HttpPipelineLogLevel): boolean;
}

// @public
export class BasicAuthenticationCredentials implements ServiceClientCredentials {
    constructor(userName: string, password: string, authorizationScheme?: string);
    authorizationScheme: string;
    password: string;
    signRequest(webResource: WebResourceLike): Promise<WebResourceLike>;
    userName: string;
}

// @public
export function bearerTokenAuthenticationPolicy(credential: TokenCredential, scopes: string | string[]): RequestPolicyFactory;

// @public
export type CommonRequestInfo = string;

// @public
export type CommonRequestInit = Omit<RequestInit, "body" | "headers" | "signal"> & {
    body?: any;
    headers?: any;
    signal?: any;
};

// @public
export type CommonResponse = Omit<Response, "body" | "trailer" | "formData"> & {
    body: any;
    trailer: any;
    formData: any;
};

// @public
export interface CompositeMapper extends BaseMapper {
    type: CompositeMapperType;
}

// @public
export interface CompositeMapperType {
    additionalProperties?: Mapper;
    className?: string;
    modelProperties?: {
        [propertyName: string]: Mapper;
    };
    name: "Composite";
    polymorphicDiscriminator?: PolymorphicDiscriminator;
    uberParent?: string;
}

// @public
export const Constants: {
    coreHttpVersion: string;
    HTTP: string;
    HTTPS: string;
    HTTP_PROXY: string;
    HTTPS_PROXY: string;
    NO_PROXY: string;
    ALL_PROXY: string;
    HttpConstants: {
        HttpVerbs: {
            PUT: string;
            GET: string;
            DELETE: string;
            POST: string;
            MERGE: string;
            HEAD: string;
            PATCH: string;
        };
        StatusCodes: {
            TooManyRequests: number;
            ServiceUnavailable: number;
        };
    };
    HeaderConstants: {
        AUTHORIZATION: string;
        AUTHORIZATION_SCHEME: string;
        RETRY_AFTER: string;
        USER_AGENT: string;
    };
};

// @public
export function createPipelineFromOptions(pipelineOptions: InternalPipelineOptions, authPolicyFactory?: RequestPolicyFactory): ServiceClientOptions;

// @public @deprecated
export function createSpanFunction(args: SpanConfig): <T extends OperationOptions>(operationName: string, operationOptions: T) => {
    span: Span;
    updatedOptions: T;
};

// @public
export class DefaultHttpClient extends FetchHttpClient {
    fetch(input: CommonRequestInfo, init?: CommonRequestInit): Promise<CommonResponse>;
    prepareRequest(httpRequest: WebResourceLike): Promise<Partial<RequestInit>>;
    processRequest(operationResponse: HttpOperationResponse): Promise<void>;
}

// @public
export function delay<T>(delayInMs: number, value?: T, options?: {
    abortSignal?: AbortSignalLike;
    abortErrorMsg?: string;
}): Promise<T | void>;

// @public
export interface DeserializationContentTypes {
    json?: string[];
    xml?: string[];
}

// @public
export interface DeserializationOptions {
    expectedContentTypes: DeserializationContentTypes;
}

// @public
export function deserializationPolicy(deserializationContentTypes?: DeserializationContentTypes, parsingOptions?: SerializerOptions): RequestPolicyFactory;

// @public
export function deserializeResponseBody(jsonContentTypes: string[], xmlContentTypes: string[], response: HttpOperationResponse, options?: SerializerOptions): Promise<HttpOperationResponse>;

// @public
export interface DictionaryMapper extends BaseMapper {
    headerCollectionPrefix?: string;
    type: DictionaryMapperType;
}

// @public
export interface DictionaryMapperType {
    name: "Dictionary";
    value: Mapper;
}

// @public
export function disableResponseDecompressionPolicy(): RequestPolicyFactory;

// @public
export function encodeUri(uri: string): string;

// @public
export interface EnumMapper extends BaseMapper {
    type: EnumMapperType;
}

// @public
export interface EnumMapperType {
    allowedValues: any[];
    name: "Enum";
}

// @public
export function executePromisesSequentially(promiseFactories: Array<any>, kickstart: unknown): Promise<any>;

// @public @deprecated
export class ExpiringAccessTokenCache implements AccessTokenCache {
    constructor(tokenRefreshBufferMs?: number);
    getCachedToken(): AccessToken | undefined;
    setCachedToken(accessToken: AccessToken | undefined): void;
}

// @public
export function exponentialRetryPolicy(retryCount?: number, retryInterval?: number, maxRetryInterval?: number): RequestPolicyFactory;

// @public
export abstract class FetchHttpClient implements HttpClient {
    abstract fetch(input: CommonRequestInfo, init?: CommonRequestInit): Promise<CommonResponse>;
    abstract prepareRequest(httpRequest: WebResourceLike): Promise<Partial<RequestInit>>;
    abstract processRequest(operationResponse: HttpOperationResponse): Promise<void>;
    sendRequest(httpRequest: WebResourceLike): Promise<HttpOperationResponse>;
}

// @public
export function flattenResponse(_response: HttpOperationResponse, responseSpec: OperationResponse | undefined): RestResponse;

// @public
export function generateClientRequestIdPolicy(requestIdHeaderName?: string): RequestPolicyFactory;

// @public
export function generateUuid(): string;

// @public
export function getDefaultProxySettings(proxyUrl?: string): ProxySettings | undefined;

// @public
export function getDefaultUserAgentValue(): string;

export { GetTokenOptions }

// @public
export interface HttpClient extends RequestPolicy {
}

// @public
export interface HttpHeader {
    name: string;
    value: string;
}

// @public
export class HttpHeaders implements HttpHeadersLike {
    constructor(rawHeaders?: RawHttpHeaders);
    clone(): HttpHeaders;
    contains(headerName: string): boolean;
    get(headerName: string): string | undefined;
    headerNames(): string[];
    headersArray(): HttpHeader[];
    headerValues(): string[];
    rawHeaders(): RawHttpHeaders;
    remove(headerName: string): boolean;
    set(headerName: string, headerValue: string | number): void;
    toJson(options?: {
        preserveCase?: boolean;
    }): RawHttpHeaders;
    toString(): string;
}

// @public
export interface HttpHeadersLike {
    clone(): HttpHeadersLike;
    contains(headerName: string): boolean;
    get(headerName: string): string | undefined;
    headerNames(): string[];
    headersArray(): HttpHeader[];
    headerValues(): string[];
    rawHeaders(): RawHttpHeaders;
    remove(headerName: string): boolean;
    set(headerName: string, headerValue: string | number): void;
    toJson(options?: {
        preserveCase?: boolean;
    }): RawHttpHeaders;
}

// @public
export type HttpMethods = "GET" | "PUT" | "POST" | "DELETE" | "PATCH" | "HEAD" | "OPTIONS" | "TRACE";

// @public
export interface HttpOperationResponse extends HttpResponse {
    blobBody?: Promise<Blob>;
    bodyAsText?: string | null;
    parsedBody?: any;
    parsedHeaders?: {
        [key: string]: any;
    };
    readableStreamBody?: NodeJS.ReadableStream;
}

// @public
export interface HttpPipelineLogger {
    log(logLevel: HttpPipelineLogLevel, message: string): void;
    minimumLogLevel: HttpPipelineLogLevel;
}

// @public
export enum HttpPipelineLogLevel {
    ERROR = 1,
    INFO = 3,
    OFF = 0,
    WARNING = 2
}

// @public
export type HttpRequestBody = Blob | string | ArrayBuffer | ArrayBufferView | (() => NodeJS.ReadableStream);

// @public
export interface HttpResponse {
    headers: HttpHeadersLike;
    request: WebResourceLike;
    status: number;
}

// @public
export interface InternalPipelineOptions extends PipelineOptions {
    decompressResponse?: boolean;
    deserializationOptions?: DeserializationOptions;
    loggingOptions?: LogPolicyOptions;
    sendStreamingJson?: boolean;
}

// @public
export function isDuration(value: string): boolean;

// @public
export const isNode: boolean;

export { isTokenCredential }

// @public
export function isValidUuid(uuid: string): boolean;

// @public
export interface KeepAliveOptions {
    // (undocumented)
    enable: boolean;
}

// @public
export function keepAlivePolicy(keepAliveOptions?: KeepAliveOptions): RequestPolicyFactory;

// @public
export function logPolicy(loggingOptions?: LogPolicyOptions): RequestPolicyFactory;

// @public
export interface LogPolicyOptions {
    allowedHeaderNames?: string[];
    allowedQueryParameters?: string[];
    logger?: Debugger;
}

// @public
export type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;

// @public
export interface MapperConstraints {
    ExclusiveMaximum?: number;
    ExclusiveMinimum?: number;
    InclusiveMaximum?: number;
    InclusiveMinimum?: number;
    MaxItems?: number;
    MaxLength?: number;
    MinItems?: number;
    MinLength?: number;
    MultipleOf?: number;
    Pattern?: RegExp;
    UniqueItems?: true;
}

// @public
export type MapperType = SimpleMapperType | CompositeMapperType | SequenceMapperType | DictionaryMapperType | EnumMapperType;

// @public (undocumented)
export const MapperType: {
    Date: "Date";
    Base64Url: "Base64Url";
    Boolean: "Boolean";
    ByteArray: "ByteArray";
    DateTime: "DateTime";
    DateTimeRfc1123: "DateTimeRfc1123";
    Object: "Object";
    Stream: "Stream";
    String: "String";
    TimeSpan: "TimeSpan";
    UnixTime: "UnixTime";
    Number: "Number";
    Composite: "Composite";
    Sequence: "Sequence";
    Dictionary: "Dictionary";
    Enum: "Enum";
};

// @public
export interface OperationArguments {
    [parameterName: string]: any;
    options?: RequestOptionsBase;
}

// @public
export interface OperationOptions {
    abortSignal?: AbortSignalLike;
    requestOptions?: OperationRequestOptions;
    tracingOptions?: OperationTracingOptions;
}

// @public
export function operationOptionsToRequestOptionsBase<T extends OperationOptions>(opts: T): RequestOptionsBase;

// @public
export interface OperationParameter {
    mapper: Mapper;
    parameterPath: ParameterPath;
}

// @public
export interface OperationQueryParameter extends OperationParameter {
    collectionFormat?: QueryCollectionFormat;
    skipEncoding?: boolean;
}

// @public (undocumented)
export interface OperationRequestOptions {
    customHeaders?: {
        [key: string]: string;
    };
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);
    timeout?: number;
}

// @public
export interface OperationResponse {
    bodyMapper?: Mapper;
    headersMapper?: Mapper;
    isError?: boolean;
}

// @public
export interface OperationSpec {
    readonly baseUrl?: string;
    readonly contentType?: string;
    readonly formDataParameters?: ReadonlyArray<OperationParameter>;
    readonly headerParameters?: ReadonlyArray<OperationParameter>;
    readonly httpMethod: HttpMethods;
    readonly isXML?: boolean;
    readonly mediaType?: "json" | "xml" | "form" | "binary" | "multipart" | "text" | "unknown" | string;
    readonly path?: string;
    readonly queryParameters?: ReadonlyArray<OperationQueryParameter>;
    readonly requestBody?: OperationParameter;
    readonly responses: {
        [responseCode: string]: OperationResponse;
    };
    readonly serializer: Serializer;
    readonly urlParameters?: ReadonlyArray<OperationURLParameter>;
}

// @public
export interface OperationURLParameter extends OperationParameter {
    skipEncoding?: boolean;
}

// @public (undocumented)
export type ParameterPath = string | string[] | {
    [propertyName: string]: ParameterPath;
};

// @public
export interface ParameterValue {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    skipUrlEncoding: boolean;
    // (undocumented)
    value: any;
}

// @public
export function parseXML(str: string, opts?: SerializerOptions): Promise<any>;

// @public
export interface PipelineOptions {
    httpClient?: HttpClient;
    // (undocumented)
    keepAliveOptions?: KeepAliveOptions;
    proxyOptions?: ProxyOptions;
    redirectOptions?: RedirectOptions;
    retryOptions?: RetryOptions;
    userAgentOptions?: UserAgentOptions;
}

// @public
export interface PolymorphicDiscriminator {
    // (undocumented)
    [key: string]: string;
    // (undocumented)
    clientName: string;
    serializedName: string;
}

// @public @deprecated
export function promiseToCallback(promise: Promise<any>): (cb: Function) => void;

// @public
export function promiseToServiceCallback<T>(promise: Promise<HttpOperationResponse>): (cb: ServiceCallback<T>) => void;

// @public (undocumented)
export type ProxyOptions = ProxySettings;

// @public
export function proxyPolicy(proxySettings?: ProxySettings, options?: {
    customNoProxyList?: string[];
}): RequestPolicyFactory;

// @public
export interface ProxySettings {
    host: string;
    password?: string;
    port: number;
    username?: string;
}

// @public
export enum QueryCollectionFormat {
    // (undocumented)
    Csv = ",",
    // (undocumented)
    Multi = "Multi",
    // (undocumented)
    Pipes = "|",
    // (undocumented)
    Ssv = " ",
    // (undocumented)
    Tsv = "\t"
}

// @public
export type RawHttpHeaders = {
    [headerName: string]: string;
};

// @public
export interface RedirectOptions {
    // (undocumented)
    handleRedirects: boolean;
    // (undocumented)
    maxRetries?: number;
}

// @public (undocumented)
export function redirectPolicy(maximumRetries?: number): RequestPolicyFactory;

// @public
export interface RequestOptionsBase {
    // (undocumented)
    [key: string]: any;
    abortSignal?: AbortSignalLike;
    customHeaders?: {
        [key: string]: string;
    };
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    serializerOptions?: SerializerOptions;
    shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);
    timeout?: number;
    tracingContext?: Context;
}

// @public
export interface RequestPolicy {
    sendRequest(httpRequest: WebResourceLike): Promise<HttpOperationResponse>;
}

// @public
export type RequestPolicyFactory = {
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptionsLike): RequestPolicy;
};

// @public
export class RequestPolicyOptions {
    constructor(_logger?: HttpPipelineLogger | undefined);
    log(logLevel: HttpPipelineLogLevel, message: string): void;
    shouldLog(logLevel: HttpPipelineLogLevel): boolean;
}

// @public
export interface RequestPolicyOptionsLike {
    log(logLevel: HttpPipelineLogLevel, message: string): void;
    shouldLog(logLevel: HttpPipelineLogLevel): boolean;
}

// @public (undocumented)
export interface RequestPrepareOptions {
    // (undocumented)
    abortSignal?: AbortSignalLike;
    baseUrl?: string;
    body?: any;
    bodyIsStream?: boolean;
    deserializationMapper?: Record<string, unknown>;
    disableClientRequestId?: boolean;
    disableJsonStringifyOnBody?: boolean;
    // (undocumented)
    formData?: {
        [key: string]: any;
    };
    headers?: {
        [key: string]: any;
    };
    mappers?: {
        [x: string]: any;
    };
    method: HttpMethods;
    // (undocumented)
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    // (undocumented)
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    pathParameters?: {
        [key: string]: any | ParameterValue;
    };
    pathTemplate?: string;
    queryParameters?: {
        [key: string]: any | ParameterValue;
    };
    serializationMapper?: Mapper;
    spanOptions?: SpanOptions;
    tracingContext?: Context;
    url?: string;
}

// @public (undocumented)
export class RestError extends Error {
    constructor(message: string, code?: string, statusCode?: number, request?: WebResourceLike, response?: HttpOperationResponse);
    // (undocumented)
    code?: string;
    // (undocumented)
    details?: unknown;
    // (undocumented)
    static readonly PARSE_ERROR: string;
    // (undocumented)
    request?: WebResourceLike;
    // (undocumented)
    static readonly REQUEST_SEND_ERROR: string;
    // (undocumented)
    response?: HttpOperationResponse;
    // (undocumented)
    statusCode?: number;
}

// @public
export interface RestResponse {
    // (undocumented)
    [key: string]: any;
    _response: HttpOperationResponse;
}

// @public
export enum RetryMode {
    // (undocumented)
    Exponential = 0
}

// @public
export interface RetryOptions {
    maxRetries?: number;
    maxRetryDelayInMs?: number;
    mode?: RetryMode;
    retryDelayInMs?: number;
}

// @public
export interface SequenceMapper extends BaseMapper {
    type: SequenceMapperType;
}

// @public
export interface SequenceMapperType {
    element: Mapper;
    name: "Sequence";
}

// @public
export function serializeObject(toSerialize: unknown): any;

// @public
export class Serializer {
    constructor(modelMappers?: {
        [key: string]: any;
    }, isXML?: boolean | undefined);
    deserialize(mapper: Mapper, responseBody: unknown, objectName: string, options?: SerializerOptions): any;
    // (undocumented)
    readonly isXML?: boolean | undefined;
    // (undocumented)
    readonly modelMappers: {
        [key: string]: any;
    };
    serialize(mapper: Mapper, object: unknown, objectName?: string, options?: SerializerOptions): any;
    // (undocumented)
    validateConstraints(mapper: Mapper, value: unknown, objectName: string): void;
}

// @public
export interface SerializerOptions {
    includeRoot?: boolean;
    rootName?: string;
    xmlCharKey?: string;
}

// @public
export interface ServiceCallback<TResult> {
    (err: Error | RestError | null, result?: TResult, request?: WebResourceLike, response?: HttpOperationResponse): void;
}

// @public
export class ServiceClient {
    constructor(credentials?: TokenCredential | ServiceClientCredentials, options?: ServiceClientOptions);
    protected baseUri?: string;
    protected requestContentType?: string;
    sendOperationRequest(operationArguments: OperationArguments, operationSpec: OperationSpec, callback?: ServiceCallback<any>): Promise<RestResponse>;
    sendRequest(options: RequestPrepareOptions | WebResourceLike): Promise<HttpOperationResponse>;
}

// @public (undocumented)
export interface ServiceClientCredentials {
    signRequest(webResource: WebResourceLike): Promise<WebResourceLike>;
}

// @public
export interface ServiceClientOptions {
    clientRequestIdHeaderName?: string;
    credentialScopes?: string | string[];
    deserializationContentTypes?: DeserializationContentTypes;
    generateClientRequestIdHeader?: boolean;
    httpClient?: HttpClient;
    httpPipelineLogger?: HttpPipelineLogger;
    noRetryPolicy?: boolean;
    proxySettings?: ProxySettings;
    requestPolicyFactories?: RequestPolicyFactory[] | ((defaultRequestPolicyFactories: RequestPolicyFactory[]) => void | RequestPolicyFactory[]);
    rpRegistrationRetryTimeout?: number;
    userAgent?: string | ((defaultUserAgent: string) => string);
    userAgentHeaderName?: string | ((defaultUserAgentHeaderName: string) => string);
    withCredentials?: boolean;
}

// @public (undocumented)
export function signingPolicy(authenticationProvider: ServiceClientCredentials): RequestPolicyFactory;

// @public
export interface SimpleMapperType {
    // (undocumented)
    name: "Base64Url" | "Boolean" | "ByteArray" | "Date" | "DateTime" | "DateTimeRfc1123" | "Object" | "Stream" | "String" | "TimeSpan" | "UnixTime" | "Uuid" | "Number" | "any";
}

// @public @deprecated
export interface SpanConfig {
    namespace: string;
    packagePrefix: string;
}

// @public
export function stringifyXML(obj: unknown, opts?: SerializerOptions): string;

// @public
export function stripRequest(request: WebResourceLike): WebResourceLike;

// @public
export function stripResponse(response: HttpOperationResponse): any;

// @public (undocumented)
export function systemErrorRetryPolicy(retryCount?: number, retryInterval?: number, minRetryInterval?: number, maxRetryInterval?: number): RequestPolicyFactory;

// @public (undocumented)
export type TelemetryInfo = {
    key?: string;
    value?: string;
};

// @public (undocumented)
export function throttlingRetryPolicy(): RequestPolicyFactory;

export { TokenCredential }

// @public (undocumented)
export class TopicCredentials extends ApiKeyCredentials {
    constructor(topicKey: string);
}

// @public (undocumented)
export function tracingPolicy(tracingOptions?: TracingPolicyOptions): RequestPolicyFactory;

// @public (undocumented)
export interface TracingPolicyOptions {
    // (undocumented)
    userAgent?: string;
}

// @public
export type TransferProgressEvent = {
    loadedBytes: number;
};

// @public
export class URLBuilder {
    appendPath(path: string | undefined): void;
    getHost(): string | undefined;
    getPath(): string | undefined;
    getPort(): string | undefined;
    getQuery(): string | undefined;
    getQueryParameterValue(queryParameterName: string): string | string[] | undefined;
    getScheme(): string | undefined;
    // (undocumented)
    static parse(text: string): URLBuilder;
    replaceAll(searchValue: string, replaceValue: string): void;
    setHost(host: string | undefined): void;
    setPath(path: string | undefined): void;
    setPort(port: number | string | undefined): void;
    setQuery(query: string | undefined): void;
    setQueryParameter(queryParameterName: string, queryParameterValue: unknown): void;
    setScheme(scheme: string | undefined): void;
    // (undocumented)
    toString(): string;
}

// @public
export interface UrlParameterValue {
    skipUrlEncoding: boolean;
    value: string;
}

// @public
export class URLQuery {
    any(): boolean;
    get(parameterName: string): string | string[] | undefined;
    keys(): string[];
    static parse(text: string): URLQuery;
    set(parameterName: string, parameterValue: unknown): void;
    toString(): string;
}

// @public
export interface UserAgentOptions {
    // (undocumented)
    userAgentPrefix?: string;
}

// @public (undocumented)
export function userAgentPolicy(userAgentData?: TelemetryInfo): RequestPolicyFactory;

// @public
export class WebResource implements WebResourceLike {
    constructor(url?: string, method?: HttpMethods, body?: unknown, query?: {
        [key: string]: any;
    }, headers?: {
        [key: string]: any;
    } | HttpHeadersLike, streamResponseBody?: boolean, withCredentials?: boolean, abortSignal?: AbortSignalLike, timeout?: number, onUploadProgress?: (progress: TransferProgressEvent) => void, onDownloadProgress?: (progress: TransferProgressEvent) => void, proxySettings?: ProxySettings, keepAlive?: boolean, decompressResponse?: boolean, streamResponseStatusCodes?: Set<number>);
    // (undocumented)
    abortSignal?: AbortSignalLike;
    // (undocumented)
    body?: any;
    clone(): WebResource;
    decompressResponse?: boolean;
    // (undocumented)
    formData?: any;
    // (undocumented)
    headers: HttpHeadersLike;
    // (undocumented)
    keepAlive?: boolean;
    // (undocumented)
    method: HttpMethods;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    operationResponseGetter?: (operationSpec: OperationSpec, response: HttpOperationResponse) => undefined | OperationResponse;
    // (undocumented)
    operationSpec?: OperationSpec;
    prepare(options: RequestPrepareOptions): WebResource;
    // (undocumented)
    proxySettings?: ProxySettings;
    // (undocumented)
    query?: {
        [key: string]: any;
    };
    // (undocumented)
    requestId: string;
    shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);
    spanOptions?: SpanOptions;
    // @deprecated (undocumented)
    streamResponseBody?: boolean;
    streamResponseStatusCodes?: Set<number>;
    // (undocumented)
    timeout: number;
    tracingContext?: Context;
    // (undocumented)
    url: string;
    validateRequestProperties(): void;
    // (undocumented)
    withCredentials: boolean;
}

// @public
export interface WebResourceLike {
    abortSignal?: AbortSignalLike;
    body?: any;
    clone(): WebResourceLike;
    decompressResponse?: boolean;
    // (undocumented)
    formData?: any;
    headers: HttpHeadersLike;
    keepAlive?: boolean;
    method: HttpMethods;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    operationResponseGetter?: (operationSpec: OperationSpec, response: HttpOperationResponse) => undefined | OperationResponse;
    operationSpec?: OperationSpec;
    prepare(options: RequestPrepareOptions): WebResourceLike;
    proxySettings?: ProxySettings;
    query?: {
        [key: string]: any;
    };
    requestId: string;
    shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);
    // @deprecated (undocumented)
    streamResponseBody?: boolean;
    streamResponseStatusCodes?: Set<number>;
    timeout: number;
    tracingContext?: Context;
    url: string;
    validateRequestProperties(): void;
    withCredentials: boolean;
}

// @public
export const XML_ATTRKEY = "$";

// @public
export const XML_CHARKEY = "_";

// (No @packageDocumentation comment for this package)

```
