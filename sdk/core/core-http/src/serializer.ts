// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable eqeqeq */

import * as base64 from "./util/base64";
import * as utils from "./util/utils";
import { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from "./util/serializer.common";

// This file contains utility code to serialize and deserialize network operations according to `OperationSpec` objects generated by AutoRest.TypeScript from OpenAPI specifications.

/**
 * Used to map raw response objects to final shapes.
 * Helps packing and unpacking Dates and other encoded types that are not intrinsic to JSON.
 * Also allows pulling values from headers, as well as inserting default values and constants.
 */
export class Serializer {
  constructor(
    /**
     * The provided model mapper.
     */
    public readonly modelMappers: { [key: string]: any } = {},
    /**
     * Whether the contents are XML or not.
     */
    public readonly isXML?: boolean
  ) {}

  /**
   * Validates constraints, if any. This function will throw if the provided value does not respect those constraints.
   * @param mapper - The definition of data models.
   * @param value - The value.
   * @param objectName - Name of the object. Used in the error messages.
   * @deprecated Removing the constraints validation on client side.
   */
  validateConstraints(mapper: Mapper, value: unknown, objectName: string): void {
    const failValidation = (
      constraintName: keyof MapperConstraints,
      constraintValue: any
    ): Error => {
      throw new Error(
        `"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`
      );
    };
    if (mapper.constraints && value != undefined) {
      const valueAsNumber = value as number;
      const {
        ExclusiveMaximum,
        ExclusiveMinimum,
        InclusiveMaximum,
        InclusiveMinimum,
        MaxItems,
        MaxLength,
        MinItems,
        MinLength,
        MultipleOf,
        Pattern,
        UniqueItems,
      } = mapper.constraints;
      if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {
        failValidation("ExclusiveMaximum", ExclusiveMaximum);
      }
      if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {
        failValidation("ExclusiveMinimum", ExclusiveMinimum);
      }
      if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {
        failValidation("InclusiveMaximum", InclusiveMaximum);
      }
      if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {
        failValidation("InclusiveMinimum", InclusiveMinimum);
      }
      const valueAsArray = value as any[];
      if (MaxItems != undefined && valueAsArray.length > MaxItems) {
        failValidation("MaxItems", MaxItems);
      }
      if (MaxLength != undefined && valueAsArray.length > MaxLength) {
        failValidation("MaxLength", MaxLength);
      }
      if (MinItems != undefined && valueAsArray.length < MinItems) {
        failValidation("MinItems", MinItems);
      }
      if (MinLength != undefined && valueAsArray.length < MinLength) {
        failValidation("MinLength", MinLength);
      }
      if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {
        failValidation("MultipleOf", MultipleOf);
      }
      if (Pattern) {
        const pattern: RegExp = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
        if (typeof value !== "string" || value.match(pattern) === null) {
          failValidation("Pattern", Pattern);
        }
      }
      if (
        UniqueItems &&
        valueAsArray.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)
      ) {
        failValidation("UniqueItems", UniqueItems);
      }
    }
  }

  /**
   * Serialize the given object based on its metadata defined in the mapper.
   *
   * @param mapper - The mapper which defines the metadata of the serializable object.
   * @param object - A valid Javascript object to be serialized.
   * @param objectName - Name of the serialized object.
   * @param options - additional options to deserialization.
   * @returns A valid serialized Javascript object.
   */
  serialize(
    mapper: Mapper,
    object: unknown,
    objectName?: string,
    options: SerializerOptions = {}
  ): any {
    const updatedOptions: Required<SerializerOptions> = {
      rootName: options.rootName ?? "",
      includeRoot: options.includeRoot ?? false,
      xmlCharKey: options.xmlCharKey ?? XML_CHARKEY,
    };
    let payload: any = {};
    const mapperType = mapper.type.name as string;
    if (!objectName) {
      objectName = mapper.serializedName!;
    }
    if (mapperType.match(/^Sequence$/i) !== null) {
      payload = [];
    }

    if (mapper.isConstant) {
      object = mapper.defaultValue;
    }

    // This table of allowed values should help explain
    // the mapper.required and mapper.nullable properties.
    // X means "neither undefined or null are allowed".
    //           || required
    //           || true      | false
    //  nullable || ==========================
    //      true || null      | undefined/null
    //     false || X         | undefined
    // undefined || X         | undefined/null

    const { required, nullable } = mapper;

    if (required && nullable && object === undefined) {
      throw new Error(`${objectName} cannot be undefined.`);
    }
    if (required && !nullable && object == undefined) {
      throw new Error(`${objectName} cannot be null or undefined.`);
    }
    if (!required && nullable === false && object === null) {
      throw new Error(`${objectName} cannot be null.`);
    }

    if (object == undefined) {
      payload = object;
    } else {
      if (mapperType.match(/^any$/i) !== null) {
        payload = object;
      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
        payload = serializeBasicTypes(mapperType, objectName, object);
      } else if (mapperType.match(/^Enum$/i) !== null) {
        const enumMapper: EnumMapper = mapper as EnumMapper;
        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
      } else if (
        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null
      ) {
        payload = serializeDateTypes(mapperType, object, objectName);
      } else if (mapperType.match(/^ByteArray$/i) !== null) {
        payload = serializeByteArrayType(objectName, object as Uint8Array);
      } else if (mapperType.match(/^Base64Url$/i) !== null) {
        payload = serializeBase64UrlType(objectName, object as Uint8Array);
      } else if (mapperType.match(/^Sequence$/i) !== null) {
        payload = serializeSequenceType(
          this,
          mapper as SequenceMapper,
          object,
          objectName,
          Boolean(this.isXML),
          updatedOptions
        );
      } else if (mapperType.match(/^Dictionary$/i) !== null) {
        payload = serializeDictionaryType(
          this,
          mapper as DictionaryMapper,
          object,
          objectName,
          Boolean(this.isXML),
          updatedOptions
        );
      } else if (mapperType.match(/^Composite$/i) !== null) {
        payload = serializeCompositeType(
          this,
          mapper as CompositeMapper,
          object,
          objectName,
          Boolean(this.isXML),
          updatedOptions
        );
      }
    }
    return payload;
  }

  /**
   * Deserialize the given object based on its metadata defined in the mapper.
   *
   * @param mapper - The mapper which defines the metadata of the serializable object.
   * @param responseBody - A valid Javascript entity to be deserialized.
   * @param objectName - Name of the deserialized object.
   * @param options - Controls behavior of XML parser and builder.
   * @returns A valid deserialized Javascript object.
   */
  deserialize(
    mapper: Mapper,
    responseBody: unknown,
    objectName: string,
    options: SerializerOptions = {}
  ): any {
    const updatedOptions: Required<SerializerOptions> = {
      rootName: options.rootName ?? "",
      includeRoot: options.includeRoot ?? false,
      xmlCharKey: options.xmlCharKey ?? XML_CHARKEY,
    };
    if (responseBody == undefined) {
      if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
        // between the list being empty versus being missing,
        // so let's do the more user-friendly thing and return an empty list.
        responseBody = [];
      }
      // specifically check for undefined as default value can be a falsey value `0, "", false, null`
      if (mapper.defaultValue !== undefined) {
        responseBody = mapper.defaultValue;
      }
      return responseBody;
    }

    let payload: any;
    const mapperType = mapper.type.name;
    if (!objectName) {
      objectName = mapper.serializedName!;
    }

    if (mapperType.match(/^Composite$/i) !== null) {
      payload = deserializeCompositeType(
        this,
        mapper as CompositeMapper,
        responseBody,
        objectName,
        updatedOptions
      );
    } else {
      if (this.isXML) {
        const xmlCharKey = updatedOptions.xmlCharKey;
        const castResponseBody = responseBody as Record<string, unknown>;
        /**
         * If the mapper specifies this as a non-composite type value but the responseBody contains
         * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
         * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
         */
        if (
          castResponseBody[XML_ATTRKEY] != undefined &&
          castResponseBody[xmlCharKey] != undefined
        ) {
          responseBody = castResponseBody[xmlCharKey];
        }
      }

      if (mapperType.match(/^Number$/i) !== null) {
        payload = parseFloat(responseBody as string);
        if (isNaN(payload)) {
          payload = responseBody;
        }
      } else if (mapperType.match(/^Boolean$/i) !== null) {
        if (responseBody === "true") {
          payload = true;
        } else if (responseBody === "false") {
          payload = false;
        } else {
          payload = responseBody;
        }
      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
        payload = responseBody;
      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
        payload = new Date(responseBody as string);
      } else if (mapperType.match(/^UnixTime$/i) !== null) {
        payload = unixTimeToDate(responseBody as number);
      } else if (mapperType.match(/^ByteArray$/i) !== null) {
        payload = base64.decodeString(responseBody as string);
      } else if (mapperType.match(/^Base64Url$/i) !== null) {
        payload = base64UrlToByteArray(responseBody as string);
      } else if (mapperType.match(/^Sequence$/i) !== null) {
        payload = deserializeSequenceType(
          this,
          mapper as SequenceMapper,
          responseBody,
          objectName,
          updatedOptions
        );
      } else if (mapperType.match(/^Dictionary$/i) !== null) {
        payload = deserializeDictionaryType(
          this,
          mapper as DictionaryMapper,
          responseBody,
          objectName,
          updatedOptions
        );
      }
    }

    if (mapper.isConstant) {
      payload = mapper.defaultValue;
    }

    return payload;
  }
}

function trimEnd(str: string, ch: string): string {
  let len = str.length;
  while (len - 1 >= 0 && str[len - 1] === ch) {
    --len;
  }
  return str.substr(0, len);
}

function bufferToBase64Url(buffer: any): string | undefined {
  if (!buffer) {
    return undefined;
  }
  if (!(buffer instanceof Uint8Array)) {
    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
  }
  // Uint8Array to Base64.
  const str = base64.encodeByteArray(buffer);
  // Base64 to Base64Url.
  return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}

function base64UrlToByteArray(str: string): Uint8Array | undefined {
  if (!str) {
    return undefined;
  }
  if (str && typeof str.valueOf() !== "string") {
    throw new Error("Please provide an input of type string for converting to Uint8Array");
  }
  // Base64Url to Base64.
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  // Base64 to Uint8Array.
  return base64.decodeString(str);
}

function splitSerializeName(prop: string | undefined): string[] {
  const classes: string[] = [];
  let partialclass = "";
  if (prop) {
    const subwords = prop.split(".");

    for (const item of subwords) {
      if (item.charAt(item.length - 1) === "\\") {
        partialclass += item.substr(0, item.length - 1) + ".";
      } else {
        partialclass += item;
        classes.push(partialclass);
        partialclass = "";
      }
    }
  }

  return classes;
}

function dateToUnixTime(d: string | Date): number | undefined {
  if (!d) {
    return undefined;
  }

  if (typeof d.valueOf() === "string") {
    d = new Date(d as string);
  }
  return Math.floor((d as Date).getTime() / 1000);
}

function unixTimeToDate(n: number): Date | undefined {
  if (!n) {
    return undefined;
  }
  return new Date(n * 1000);
}

function serializeBasicTypes(typeName: string, objectName: string, value: any): any {
  if (value !== null && value !== undefined) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value !== "number") {
        throw new Error(`${objectName} with value ${value} must be of type number.`);
      }
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() !== "string") {
        throw new Error(`${objectName} with value "${value}" must be of type string.`);
      }
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() === "string" && utils.isValidUuid(value))) {
        throw new Error(
          `${objectName} with value "${value}" must be of type string and a valid uuid.`
        );
      }
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value !== "boolean") {
        throw new Error(`${objectName} with value ${value} must be of type boolean.`);
      }
    } else if (typeName.match(/^Stream$/i) !== null) {
      const objectType = typeof value;
      if (
        objectType !== "string" &&
        objectType !== "function" &&
        !(value instanceof ArrayBuffer) &&
        !ArrayBuffer.isView(value) &&
        !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)
      ) {
        throw new Error(
          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`
        );
      }
    }
  }

  return value;
}

function serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {
  if (!allowedValues) {
    throw new Error(
      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`
    );
  }
  const isPresent = allowedValues.some((item) => {
    if (typeof item.valueOf() === "string") {
      return item.toLowerCase() === value.toLowerCase();
    }
    return item === value;
  });
  if (!isPresent) {
    throw new Error(
      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(
        allowedValues
      )}.`
    );
  }
  return value;
}

function serializeByteArrayType(objectName: string, value: Uint8Array): string {
  let returnValue: string = "";
  if (value != undefined) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    returnValue = base64.encodeByteArray(value);
  }
  return returnValue;
}

function serializeBase64UrlType(objectName: string, value: Uint8Array): string {
  let returnValue: string = "";
  if (value != undefined) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    returnValue = bufferToBase64Url(value) || "";
  }
  return returnValue;
}

function serializeDateTypes(typeName: string, value: any, objectName: string): any {
  if (value != undefined) {
    if (typeName.match(/^Date$/i) !== null) {
      if (
        !(
          value instanceof Date ||
          (typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))
        )
      ) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value =
        value instanceof Date
          ? value.toISOString().substring(0, 10)
          : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (
        !(
          value instanceof Date ||
          (typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))
        )
      ) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (
        !(
          value instanceof Date ||
          (typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))
        )
      ) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
      }
      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (
        !(
          value instanceof Date ||
          (typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))
        )
      ) {
        throw new Error(
          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +
            `for it to be serialized in UnixTime/Epoch format.`
        );
      }
      value = dateToUnixTime(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null) {
      if (!utils.isDuration(value)) {
        throw new Error(
          `${objectName} must be a string in ISO 8601 format. Instead was "${value}".`
        );
      }
    }
  }
  return value;
}

function serializeSequenceType(
  serializer: Serializer,
  mapper: SequenceMapper,
  object: any,
  objectName: string,
  isXml: boolean,
  options: Required<SerializerOptions>
): any[] {
  if (!Array.isArray(object)) {
    throw new Error(`${objectName} must be of type Array.`);
  }
  const elementType = mapper.type.element;
  if (!elementType || typeof elementType !== "object") {
    throw new Error(
      `element" metadata for an Array must be defined in the ` +
        `mapper and it must of type "object" in ${objectName}.`
    );
  }
  const tempArray = [];
  for (let i = 0; i < object.length; i++) {
    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);

    if (isXml && elementType.xmlNamespace) {
      const xmlnsKey = elementType.xmlNamespacePrefix
        ? `xmlns:${elementType.xmlNamespacePrefix}`
        : "xmlns";
      if (elementType.type.name === "Composite") {
        tempArray[i] = { ...serializedValue };
        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      } else {
        tempArray[i] = {};
        tempArray[i][options.xmlCharKey] = serializedValue;
        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      }
    } else {
      tempArray[i] = serializedValue;
    }
  }
  return tempArray;
}

function serializeDictionaryType(
  serializer: Serializer,
  mapper: DictionaryMapper,
  object: any,
  objectName: string,
  isXml: boolean,
  options: Required<SerializerOptions>
): { [key: string]: any } {
  if (typeof object !== "object") {
    throw new Error(`${objectName} must be of type object.`);
  }
  const valueType = mapper.type.value;
  if (!valueType || typeof valueType !== "object") {
    throw new Error(
      `"value" metadata for a Dictionary must be defined in the ` +
        `mapper and it must of type "object" in ${objectName}.`
    );
  }
  const tempDictionary: { [key: string]: any } = {};
  for (const key of Object.keys(object)) {
    const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
    // If the element needs an XML namespace we need to add it within the $ property
    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
  }

  // Add the namespace to the root element if needed
  if (isXml && mapper.xmlNamespace) {
    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";

    const result = tempDictionary;
    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
    return result;
  }

  return tempDictionary;
}

/**
 * Resolves the additionalProperties property from a referenced mapper.
 * @param serializer - The serializer containing the entire set of mappers.
 * @param mapper - The composite mapper to resolve.
 * @param objectName - Name of the object being serialized.
 */
function resolveAdditionalProperties(
  serializer: Serializer,
  mapper: CompositeMapper,
  objectName: string
): SequenceMapper | BaseMapper | CompositeMapper | DictionaryMapper | EnumMapper | undefined {
  const additionalProperties = mapper.type.additionalProperties;

  if (!additionalProperties && mapper.type.className) {
    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
    return modelMapper?.type.additionalProperties;
  }

  return additionalProperties;
}

/**
 * Finds the mapper referenced by `className`.
 * @param serializer - The serializer containing the entire set of mappers
 * @param mapper - The composite mapper to resolve
 * @param objectName - Name of the object being serialized
 */
function resolveReferencedMapper(
  serializer: Serializer,
  mapper: CompositeMapper,
  objectName: string
): CompositeMapper | undefined {
  const className = mapper.type.className;
  if (!className) {
    throw new Error(
      `Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(
        mapper,
        undefined,
        2
      )}".`
    );
  }

  return serializer.modelMappers[className];
}

/**
 * Resolves a composite mapper's modelProperties.
 * @param serializer - The serializer containing the entire set of mappers
 * @param mapper - The composite mapper to resolve
 */
function resolveModelProperties(
  serializer: Serializer,
  mapper: CompositeMapper,
  objectName: string
): { [propertyName: string]: Mapper } {
  let modelProps = mapper.type.modelProperties;
  if (!modelProps) {
    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
    if (!modelMapper) {
      throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
    }
    modelProps = modelMapper?.type.modelProperties;
    if (!modelProps) {
      throw new Error(
        `modelProperties cannot be null or undefined in the ` +
          `mapper "${JSON.stringify(modelMapper)}" of type "${
            mapper.type.className
          }" for object "${objectName}".`
      );
    }
  }

  return modelProps;
}

function serializeCompositeType(
  serializer: Serializer,
  mapper: CompositeMapper,
  object: any,
  objectName: string,
  isXml: boolean,
  options: Required<SerializerOptions>
): any {
  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
    mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
  }

  if (object != undefined) {
    const payload: any = {};
    const modelProps = resolveModelProperties(serializer, mapper, objectName);
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      if (propertyMapper.readOnly) {
        continue;
      }

      let propName: string | undefined;
      let parentObject: any = payload;
      if (serializer.isXML) {
        if (propertyMapper.xmlIsWrapped) {
          propName = propertyMapper.xmlName;
        } else {
          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        }
      } else {
        const paths = splitSerializeName(propertyMapper.serializedName!);
        propName = paths.pop();

        for (const pathName of paths) {
          const childObject = parentObject[pathName];
          if (
            childObject == undefined &&
            (object[key] != undefined || propertyMapper.defaultValue !== undefined)
          ) {
            parentObject[pathName] = {};
          }
          parentObject = parentObject[pathName];
        }
      }

      if (parentObject != undefined) {
        if (isXml && mapper.xmlNamespace) {
          const xmlnsKey = mapper.xmlNamespacePrefix
            ? `xmlns:${mapper.xmlNamespacePrefix}`
            : "xmlns";
          parentObject[XML_ATTRKEY] = {
            ...parentObject[XML_ATTRKEY],
            [xmlnsKey]: mapper.xmlNamespace,
          };
        }
        const propertyObjectName =
          propertyMapper.serializedName !== ""
            ? objectName + "." + propertyMapper.serializedName
            : objectName;

        let toSerialize = object[key];
        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
        if (
          polymorphicDiscriminator &&
          polymorphicDiscriminator.clientName === key &&
          toSerialize == undefined
        ) {
          toSerialize = mapper.serializedName;
        }

        const serializedValue = serializer.serialize(
          propertyMapper,
          toSerialize,
          propertyObjectName,
          options
        );

        if (serializedValue !== undefined && propName != undefined) {
          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
          if (isXml && propertyMapper.xmlIsAttribute) {
            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
            // This keeps things simple while preventing name collision
            // with names in user documents.
            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};
            parentObject[XML_ATTRKEY][propName] = serializedValue;
          } else if (isXml && propertyMapper.xmlIsWrapped) {
            parentObject[propName] = { [propertyMapper.xmlElementName!]: value };
          } else {
            parentObject[propName] = value;
          }
        }
      }
    }

    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
    if (additionalPropertiesMapper) {
      const propNames = Object.keys(modelProps);
      for (const clientPropName in object) {
        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
        if (isAdditionalProperty) {
          payload[clientPropName] = serializer.serialize(
            additionalPropertiesMapper,
            object[clientPropName],
            objectName + '["' + clientPropName + '"]',
            options
          );
        }
      }
    }

    return payload;
  }
  return object;
}

function getXmlObjectValue(
  propertyMapper: Mapper,
  serializedValue: any,
  isXml: boolean,
  options: Required<SerializerOptions>
): any {
  if (!isXml || !propertyMapper.xmlNamespace) {
    return serializedValue;
  }

  const xmlnsKey = propertyMapper.xmlNamespacePrefix
    ? `xmlns:${propertyMapper.xmlNamespacePrefix}`
    : "xmlns";
  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };

  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[XML_ATTRKEY]) {
      return serializedValue;
    } else {
      const result: any = { ...serializedValue };
      result[XML_ATTRKEY] = xmlNamespace;
      return result;
    }
  }
  const result: any = {};
  result[options.xmlCharKey] = serializedValue;
  result[XML_ATTRKEY] = xmlNamespace;
  return result;
}

function isSpecialXmlProperty(propertyName: string, options: Required<SerializerOptions>): boolean {
  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);
}

function deserializeCompositeType(
  serializer: Serializer,
  mapper: CompositeMapper,
  responseBody: any,
  objectName: string,
  options: Required<SerializerOptions>
): any {
  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
    mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
  }

  const modelProps = resolveModelProperties(serializer, mapper, objectName);
  let instance: { [key: string]: any } = {};
  const handledPropertyNames: string[] = [];

  for (const key of Object.keys(modelProps)) {
    const propertyMapper = modelProps[key];
    const paths = splitSerializeName(modelProps[key].serializedName!);
    handledPropertyNames.push(paths[0]);
    const { serializedName, xmlName, xmlElementName } = propertyMapper;
    let propertyObjectName = objectName;
    if (serializedName !== "" && serializedName !== undefined) {
      propertyObjectName = objectName + "." + serializedName;
    }

    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;
    if (headerCollectionPrefix) {
      const dictionary: any = {};
      for (const headerKey of Object.keys(responseBody)) {
        if (headerKey.startsWith(headerCollectionPrefix)) {
          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(
            (propertyMapper as DictionaryMapper).type.value,
            responseBody[headerKey],
            propertyObjectName,
            options
          );
        }

        handledPropertyNames.push(headerKey);
      }
      instance[key] = dictionary;
    } else if (serializer.isXML) {
      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {
        instance[key] = serializer.deserialize(
          propertyMapper,
          responseBody[XML_ATTRKEY][xmlName!],
          propertyObjectName,
          options
        );
      } else {
        const propertyName = xmlElementName || xmlName || serializedName;
        if (propertyMapper.xmlIsWrapped) {
          /* a list of <xmlElementName> wrapped by <xmlName>
            For the xml example below
              <Cors>
                <CorsRule>...</CorsRule>
                <CorsRule>...</CorsRule>
              </Cors>
            the responseBody has
              {
                Cors: {
                  CorsRule: [{...}, {...}]
                }
              }
            xmlName is "Cors" and xmlElementName is"CorsRule".
          */
          const wrapped = responseBody[xmlName!];
          const elementList = wrapped?.[xmlElementName!] ?? [];
          instance[key] = serializer.deserialize(
            propertyMapper,
            elementList,
            propertyObjectName,
            options
          );
        } else {
          const property = responseBody[propertyName!];
          instance[key] = serializer.deserialize(
            propertyMapper,
            property,
            propertyObjectName,
            options
          );
        }
      }
    } else {
      // deserialize the property if it is present in the provided responseBody instance
      let propertyInstance;
      let res = responseBody;
      // traversing the object step by step.
      for (const item of paths) {
        if (!res) break;
        res = res[item];
      }
      propertyInstance = res;
      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
      // checking that the model property name (key)(ex: "fishtype") and the
      // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
      // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
      // is a better approach. The generator is not consistent with escaping '\.' in the
      // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
      // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
      // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
      // the transformation of model property name (ex: "fishtype") is done consistently.
      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
      if (
        polymorphicDiscriminator &&
        key === polymorphicDiscriminator.clientName &&
        propertyInstance == undefined
      ) {
        propertyInstance = mapper.serializedName;
      }

      let serializedValue;
      // paging
      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
        propertyInstance = responseBody[key];
        const arrayInstance = serializer.deserialize(
          propertyMapper,
          propertyInstance,
          propertyObjectName,
          options
        );
        // Copy over any properties that have already been added into the instance, where they do
        // not exist on the newly de-serialized array
        for (const [k, v] of Object.entries(instance)) {
          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
            arrayInstance[k] = v;
          }
        }
        instance = arrayInstance;
      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
        serializedValue = serializer.deserialize(
          propertyMapper,
          propertyInstance,
          propertyObjectName,
          options
        );
        instance[key] = serializedValue;
      }
    }
  }

  const additionalPropertiesMapper = mapper.type.additionalProperties;
  if (additionalPropertiesMapper) {
    const isAdditionalProperty = (responsePropName: string): boolean => {
      for (const clientPropName in modelProps) {
        const paths = splitSerializeName(modelProps[clientPropName].serializedName);
        if (paths[0] === responsePropName) {
          return false;
        }
      }
      return true;
    };

    for (const responsePropName in responseBody) {
      if (isAdditionalProperty(responsePropName)) {
        instance[responsePropName] = serializer.deserialize(
          additionalPropertiesMapper,
          responseBody[responsePropName],
          objectName + '["' + responsePropName + '"]',
          options
        );
      }
    }
  } else if (responseBody) {
    for (const key of Object.keys(responseBody)) {
      if (
        instance[key] === undefined &&
        !handledPropertyNames.includes(key) &&
        !isSpecialXmlProperty(key, options)
      ) {
        instance[key] = responseBody[key];
      }
    }
  }

  return instance;
}

function deserializeDictionaryType(
  serializer: Serializer,
  mapper: DictionaryMapper,
  responseBody: any,
  objectName: string,
  options: Required<SerializerOptions>
): { [key: string]: any } {
  const value = mapper.type.value;
  if (!value || typeof value !== "object") {
    throw new Error(
      `"value" metadata for a Dictionary must be defined in the ` +
        `mapper and it must of type "object" in ${objectName}`
    );
  }
  if (responseBody) {
    const tempDictionary: { [key: string]: any } = {};
    for (const key of Object.keys(responseBody)) {
      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
    }
    return tempDictionary;
  }
  return responseBody;
}

function deserializeSequenceType(
  serializer: Serializer,
  mapper: SequenceMapper,
  responseBody: any,
  objectName: string,
  options: Required<SerializerOptions>
): any[] {
  const element = mapper.type.element;
  if (!element || typeof element !== "object") {
    throw new Error(
      `element" metadata for an Array must be defined in the ` +
        `mapper and it must of type "object" in ${objectName}`
    );
  }
  if (responseBody) {
    if (!Array.isArray(responseBody)) {
      // xml2js will interpret a single element array as just the element, so force it to be an array
      responseBody = [responseBody];
    }

    const tempArray = [];
    for (let i = 0; i < responseBody.length; i++) {
      tempArray[i] = serializer.deserialize(
        element,
        responseBody[i],
        `${objectName}[${i}]`,
        options
      );
    }
    return tempArray;
  }
  return responseBody;
}

function getPolymorphicMapper(
  serializer: Serializer,
  mapper: CompositeMapper,
  object: any,
  polymorphicPropertyName: "clientName" | "serializedName"
): CompositeMapper {
  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
  if (polymorphicDiscriminator) {
    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
    if (discriminatorName != undefined) {
      const discriminatorValue = object[discriminatorName];
      if (discriminatorValue != undefined) {
        const typeName = mapper.type.uberParent || mapper.type.className;
        const indexDiscriminator =
          discriminatorValue === typeName
            ? discriminatorValue
            : typeName + "." + discriminatorValue;
        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];
        if (polymorphicMapper) {
          mapper = polymorphicMapper;
        }
      }
    }
  }
  return mapper;
}

function getPolymorphicDiscriminatorRecursively(
  serializer: Serializer,
  mapper: CompositeMapper
): PolymorphicDiscriminator | undefined {
  return (
    mapper.type.polymorphicDiscriminator ||
    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||
    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)
  );
}

function getPolymorphicDiscriminatorSafely(serializer: Serializer, typeName?: string): any {
  return (
    typeName &&
    serializer.modelMappers[typeName] &&
    serializer.modelMappers[typeName].type.polymorphicDiscriminator
  );
}

/**
 * Description of various value constraints such as integer ranges and string regex.
 */
export interface MapperConstraints {
  /**
   * The value should be less than or equal to the `InclusiveMaximum` value.
   */
  InclusiveMaximum?: number;
  /**
   * The value should be less than the `ExclusiveMaximum` value.
   */
  ExclusiveMaximum?: number;
  /**
   * The value should be greater than or equal to the `InclusiveMinimum` value.
   */
  InclusiveMinimum?: number;
  /**
   * The value should be greater than the `InclusiveMinimum` value.
   */
  ExclusiveMinimum?: number;
  /**
   * The length should be smaller than the `MaxLength`.
   */
  MaxLength?: number;
  /**
   * The length should be bigger than the `MinLength`.
   */
  MinLength?: number;
  /**
   * The value must match the pattern.
   */
  Pattern?: RegExp;
  /**
   * The value must contain fewer items than the MaxItems value.
   */
  MaxItems?: number;
  /**
   * The value must contain more items than the `MinItems` value.
   */
  MinItems?: number;
  /**
   * The value must contain only unique items.
   */
  UniqueItems?: true;
  /**
   * The value should be exactly divisible by the `MultipleOf` value.
   */
  MultipleOf?: number;
}

/**
 * Type of the mapper. Includes known mappers.
 */
export type MapperType =
  | SimpleMapperType
  | CompositeMapperType
  | SequenceMapperType
  | DictionaryMapperType
  | EnumMapperType;

/**
 * The type of a simple mapper.
 */
export interface SimpleMapperType {
  /**
   * Name of the type of the property.
   */
  name:
    | "Base64Url"
    | "Boolean"
    | "ByteArray"
    | "Date"
    | "DateTime"
    | "DateTimeRfc1123"
    | "Object"
    | "Stream"
    | "String"
    | "TimeSpan"
    | "UnixTime"
    | "Uuid"
    | "Number"
    | "any";
}

/**
 * Helps build a mapper that describes how to map a set of properties of an object based on other mappers.
 *
 * Only one of the following properties should be present: `className`, `modelProperties` and `additionalProperties`.
 */
export interface CompositeMapperType {
  /**
   * Name of the composite mapper type.
   */
  name: "Composite";

  /**
   * Use `className` to reference another type definition.
   */
  className?: string;

  /**
   * Use `modelProperties` when the reference to the other type has been resolved.
   */
  modelProperties?: { [propertyName: string]: Mapper };

  /**
   * Used when a model has `additionalProperties: true`. Allows the generic processing of unnamed model properties on the response object.
   */
  additionalProperties?: Mapper;

  /**
   * The name of the top-most parent scheme, the one that has no parents.
   */
  uberParent?: string;

  /**
   * A polymorphic discriminator.
   */
  polymorphicDiscriminator?: PolymorphicDiscriminator;
}

/**
 * Helps build a mapper that describes how to parse a sequence of mapped values.
 */
export interface SequenceMapperType {
  /**
   * Name of the sequence type mapper.
   */
  name: "Sequence";
  /**
   * The mapper to use to map each one of the properties of the sequence.
   */
  element: Mapper;
}

/**
 * Helps build a mapper that describes how to parse a dictionary of mapped values.
 */
export interface DictionaryMapperType {
  /**
   * Name of the sequence type mapper.
   */
  name: "Dictionary";
  /**
   * The mapper to use to map the value of each property in the dictionary.
   */
  value: Mapper;
}

/**
 * Helps build a mapper that describes how to parse an enum value.
 */
export interface EnumMapperType {
  /**
   * Name of the enum type mapper.
   */
  name: "Enum";
  /**
   * Values allowed by this mapper.
   */
  allowedValues: any[];
}

/**
 * The base definition of a mapper. Can be used for XML and plain JavaScript objects.
 */
export interface BaseMapper {
  /**
   * Name for the xml element
   */
  xmlName?: string;
  /**
   * Xml element namespace
   */
  xmlNamespace?: string;
  /**
   * Xml element namespace prefix
   */
  xmlNamespacePrefix?: string;
  /**
   * Determines if the current property should be serialized as an attribute of the parent xml element
   */
  xmlIsAttribute?: boolean;
  /**
   * Name for the xml elements when serializing an array
   */
  xmlElementName?: string;
  /**
   * Whether or not the current property should have a wrapping XML element
   */
  xmlIsWrapped?: boolean;
  /**
   * Whether or not the current property is readonly
   */
  readOnly?: boolean;
  /**
   * Whether or not the current property is a constant
   */
  isConstant?: boolean;
  /**
   * Whether or not the current property is required
   */
  required?: boolean;
  /**
   * Whether or not the current property allows mull as a value
   */
  nullable?: boolean;
  /**
   * The name to use when serializing
   */
  serializedName?: string;
  /**
   * Type of the mapper
   */
  type: MapperType;
  /**
   * Default value when one is not explicitly provided
   */
  defaultValue?: any;
  /**
   * Constraints to test the current value against
   */
  constraints?: MapperConstraints;
}

/**
 * Mappers are definitions of the data models used in the library.
 * These data models are part of the Operation or Client definitions in the responses or parameters.
 */
export type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;

/**
 * Used to disambiguate discriminated type unions.
 * For example, if response can have many shapes but also includes a 'kind' field (or similar),
 * that field can be used to determine how to deserialize the response to the correct type.
 */
export interface PolymorphicDiscriminator {
  /**
   * Name of the discriminant property in the original JSON payload, e.g. `@odata.kind`.
   */
  serializedName: string;
  /**
   * Name to use on the resulting object instead of the original property name.
   * Useful since the JSON property could be difficult to work with.
   * For example: For a field received as `@odata.kind`, the final object could instead include a property simply named `kind`.
   */
  clientName: string;
  /**
   * It may contain any other property.
   */
  [key: string]: string;
}

/**
 * A mapper composed of other mappers.
 */
export interface CompositeMapper extends BaseMapper {
  /**
   * The type descriptor of the `CompositeMapper`.
   */
  type: CompositeMapperType;
}

/**
 * A mapper describing arrays.
 */
export interface SequenceMapper extends BaseMapper {
  /**
   * The type descriptor of the `SequenceMapper`.
   */
  type: SequenceMapperType;
}

/**
 * A mapper describing plain JavaScript objects used as key/value pairs.
 */
export interface DictionaryMapper extends BaseMapper {
  /**
   * The type descriptor of the `DictionaryMapper`.
   */
  type: DictionaryMapperType;
  /**
   * Optionally, a prefix to add to the header collection.
   */
  headerCollectionPrefix?: string;
}

/**
 * A mapper describing an enum value.
 */
export interface EnumMapper extends BaseMapper {
  /**
   * The type descriptor of the `EnumMapper`.
   */
  type: EnumMapperType;
}

/**
 * An interface representing an URL parameter value.
 */
export interface UrlParameterValue {
  /**
   * The URL value.
   */
  value: string;
  /**
   * Whether to keep or skip URL encoding.
   */
  skipUrlEncoding: boolean;
}

/**
 * Utility function that serializes an object that might contain binary information into a plain object, array or a string.
 */
export function serializeObject(toSerialize: unknown): any {
  const castToSerialize = toSerialize as Record<string, unknown>;
  if (toSerialize == undefined) return undefined;
  if (toSerialize instanceof Uint8Array) {
    toSerialize = base64.encodeByteArray(toSerialize);
    return toSerialize;
  } else if (toSerialize instanceof Date) {
    return toSerialize.toISOString();
  } else if (Array.isArray(toSerialize)) {
    const array = [];
    for (let i = 0; i < toSerialize.length; i++) {
      array.push(serializeObject(toSerialize[i]));
    }
    return array;
  } else if (typeof toSerialize === "object") {
    const dictionary: { [key: string]: any } = {};
    for (const property in toSerialize) {
      dictionary[property] = serializeObject(castToSerialize[property]);
    }
    return dictionary;
  }
  return toSerialize;
}

/**
 * Utility function to create a K:V from a list of strings
 */
function strEnum<T extends string>(o: Array<T>): { [K in T]: K } {
  const result: any = {};
  for (const key of o) {
    result[key] = key;
  }
  return result;
}

/**
 * String enum containing the string types of property mappers.
 */
// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MapperType = strEnum([
  "Base64Url",
  "Boolean",
  "ByteArray",
  "Composite",
  "Date",
  "DateTime",
  "DateTimeRfc1123",
  "Dictionary",
  "Enum",
  "Number",
  "Object",
  "Sequence",
  "String",
  "Stream",
  "TimeSpan",
  "UnixTime",
]);
