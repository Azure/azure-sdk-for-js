## API Report File for "@azure-rest/core-client"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import type { HttpClient } from '@azure/core-rest-pipeline';
import type { KeyCredential } from '@azure/core-auth';
import type { LogPolicyOptions } from '@azure/core-rest-pipeline';
import type { OperationTracingOptions } from '@azure/core-tracing';
import type { Pipeline } from '@azure/core-rest-pipeline';
import type { PipelineOptions } from '@azure/core-rest-pipeline';
import type { PipelinePolicy } from '@azure/core-rest-pipeline';
import type { PipelineRequest } from '@azure/core-rest-pipeline';
import type { PipelineResponse } from '@azure/core-rest-pipeline';
import type { RawHttpHeaders } from '@azure/core-rest-pipeline';
import type { RawHttpHeadersInput } from '@azure/core-rest-pipeline';
import type { RequestBodyType } from '@azure/core-rest-pipeline';
import { RestError } from '@azure/core-rest-pipeline';
import type { TokenCredential } from '@azure/core-auth';
import type { TransferProgressEvent } from '@azure/core-rest-pipeline';

// @public
export function addCredentialPipelinePolicy(pipeline: Pipeline, endpoint: string, options?: AddCredentialPipelinePolicyOptions): void;

// @public
export interface AddCredentialPipelinePolicyOptions {
    clientOptions?: ClientOptions;
    credential?: TokenCredential | KeyCredential;
}

// @public
export interface AdditionalPolicyConfig {
    policy: PipelinePolicy;
    position: "perCall" | "perRetry";
}

// @public
export interface Client {
    path: Function;
    pathUnchecked: PathUnchecked;
    pipeline: Pipeline;
}

// @public
export type ClientOptions = PipelineOptions & {
    credentials?: {
        scopes?: string[];
        apiKeyHeaderName?: string;
    };
    baseUrl?: string;
    endpoint?: string;
    apiVersion?: string;
    allowInsecureConnection?: boolean;
    additionalPolicies?: AdditionalPolicyConfig[];
    httpClient?: HttpClient;
    loggingOptions?: LogPolicyOptions;
};

// @public
export function createRestError(response: PathUncheckedResponse): RestError;

// @public
export function createRestError(message: string, response: PathUncheckedResponse): RestError;

// @public
export interface ErrorModel {
    code: string;
    details: Array<ErrorModel>;
    innererror?: InnerError;
    message: string;
    target?: string;
}

// @public
export interface ErrorResponse {
    error: ErrorModel;
}

// @public
export interface FullOperationResponse extends PipelineResponse {
    parsedBody?: RequestBodyType;
    rawHeaders?: RawHttpHeaders;
    request: PipelineRequest;
}

// @public
export function getClient(endpoint: string, options?: ClientOptions): Client;

// @public
export function getClient(endpoint: string, credentials?: TokenCredential | KeyCredential, options?: ClientOptions): Client;

// @public
export type HttpBrowserStreamResponse = HttpResponse & {
    body?: ReadableStream<Uint8Array>;
};

// @public
export type HttpNodeStreamResponse = HttpResponse & {
    body?: NodeJSReadableStream;
};

// @public
export type HttpResponse = {
    request: PipelineRequest;
    headers: RawHttpHeaders;
    body: unknown;
    status: string;
};

// @public
export interface InnerError {
    code: string;
    innererror?: InnerError;
}

// @public
export interface NodeJSReadableStream extends NodeJS.ReadableStream {
    destroy(error?: Error): void;
}

// @public
export interface OperationOptions {
    abortSignal?: AbortSignalLike;
    onResponse?: RawResponseCallback;
    requestOptions?: OperationRequestOptions;
    tracingOptions?: OperationTracingOptions;
}

// @public
export function operationOptionsToRequestParameters(options: OperationOptions): RequestParameters;

// @public
export interface OperationRequestOptions {
    allowInsecureConnection?: boolean;
    headers?: RawHttpHeadersInput;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    skipUrlEncoding?: boolean;
    timeout?: number;
}

// @public
export type PathParameters<TRoute extends string> = TRoute extends `${infer _Head}/{${infer _Param}}${infer Tail}` ? [
pathParameter: string | number | PathParameterWithOptions,
...pathParameters: PathParameters<Tail>
] : [
];

// @public
export interface PathParameterWithOptions {
    allowReserved?: boolean;
    value: string | number;
}

// @public
export type PathUnchecked = <TPath extends string>(path: TPath, ...args: PathParameters<TPath>) => ResourceMethods<StreamableMethod>;

// @public
export type PathUncheckedResponse = HttpResponse & {
    body: any;
};

// @public
export type RawResponseCallback = (rawResponse: FullOperationResponse, error?: unknown, __legacyError?: unknown) => void;

// @public
export type RequestParameters = {
    headers?: RawHttpHeadersInput;
    accept?: string;
    body?: unknown;
    queryParameters?: Record<string, unknown>;
    contentType?: string;
    allowInsecureConnection?: boolean;
    skipUrlEncoding?: boolean;
    pathParameters?: Record<string, any>;
    timeout?: number;
    onUploadProgress?: (progress: TransferProgressEvent) => void;
    onDownloadProgress?: (progress: TransferProgressEvent) => void;
    abortSignal?: AbortSignalLike;
    tracingOptions?: OperationTracingOptions;
    onResponse?: RawResponseCallback;
};

// @public
export interface ResourceMethods<TResponse = PromiseLike<PathUncheckedResponse>> {
    delete: (options?: RequestParameters) => TResponse;
    get: (options?: RequestParameters) => TResponse;
    head: (options?: RequestParameters) => TResponse;
    options: (options?: RequestParameters) => TResponse;
    patch: (options?: RequestParameters) => TResponse;
    post: (options?: RequestParameters) => TResponse;
    put: (options?: RequestParameters) => TResponse;
    trace: (options?: RequestParameters) => TResponse;
}

// @public
export type StreamableMethod<TResponse = PathUncheckedResponse> = PromiseLike<TResponse> & {
    asNodeStream: () => Promise<HttpNodeStreamResponse>;
    asBrowserStream: () => Promise<HttpBrowserStreamResponse>;
};

```
