## API Report File for "@azure/arm-certificateregistration"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import type { OperationState } from '@azure/core-lro';
import type { PagedAsyncIterableIterator } from '@azure/core-paging';
import type { SimplePollerLike } from '@azure/core-lro';

// @public
export interface ApiDefinitionInfo {
    url?: string;
}

// @public
export interface ApiManagementConfig {
    id?: string;
}

// @public
export interface AppServiceCertificate {
    keyVaultId?: string;
    keyVaultSecretName?: string;
    readonly provisioningState?: KeyVaultSecretStatus;
}

// @public
export interface AppServiceCertificateCollection {
    readonly nextLink?: string;
    value: AppServiceCertificateResource[];
}

// @public
export interface AppServiceCertificateOrder extends Resource {
    readonly appServiceCertificateNotRenewableReasons?: ResourceNotRenewableReason[];
    autoRenew?: boolean;
    certificates?: {
        [propertyName: string]: AppServiceCertificate;
    };
    readonly contact?: CertificateOrderContact;
    csr?: string;
    distinguishedName?: string;
    readonly domainVerificationToken?: string;
    readonly expirationTime?: Date;
    readonly intermediate?: CertificateDetails;
    readonly isPrivateKeyExternal?: boolean;
    keySize?: number;
    readonly lastCertificateIssuanceTime?: Date;
    readonly nextAutoRenewalTimeStamp?: Date;
    productType?: CertificateProductType;
    readonly provisioningState?: ProvisioningState;
    readonly root?: CertificateDetails;
    readonly serialNumber?: string;
    readonly signedCertificate?: CertificateDetails;
    readonly status?: CertificateOrderStatus;
    validityInYears?: number;
}

// @public
export interface AppServiceCertificateOrderCollection {
    readonly nextLink?: string;
    value: AppServiceCertificateOrder[];
}

// @public
export interface AppServiceCertificateOrderPatchResource extends ProxyOnlyResource {
    readonly appServiceCertificateNotRenewableReasons?: ResourceNotRenewableReason[];
    autoRenew?: boolean;
    certificates?: {
        [propertyName: string]: AppServiceCertificate;
    };
    readonly contact?: CertificateOrderContact;
    csr?: string;
    distinguishedName?: string;
    readonly domainVerificationToken?: string;
    readonly expirationTime?: Date;
    readonly intermediate?: CertificateDetails;
    readonly isPrivateKeyExternal?: boolean;
    keySize?: number;
    readonly lastCertificateIssuanceTime?: Date;
    readonly nextAutoRenewalTimeStamp?: Date;
    productType?: CertificateProductType;
    readonly provisioningState?: ProvisioningState;
    readonly root?: CertificateDetails;
    readonly serialNumber?: string;
    readonly signedCertificate?: CertificateDetails;
    readonly status?: CertificateOrderStatus;
    validityInYears?: number;
}

// @public
export interface AppServiceCertificateOrders {
    beginCreateOrUpdate(resourceGroupName: string, certificateOrderName: string, certificateDistinguishedName: AppServiceCertificateOrder, options?: AppServiceCertificateOrdersCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<AppServiceCertificateOrdersCreateOrUpdateResponse>, AppServiceCertificateOrdersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, certificateOrderName: string, certificateDistinguishedName: AppServiceCertificateOrder, options?: AppServiceCertificateOrdersCreateOrUpdateOptionalParams): Promise<AppServiceCertificateOrdersCreateOrUpdateResponse>;
    beginCreateOrUpdateCertificate(resourceGroupName: string, certificateOrderName: string, name: string, keyVaultCertificate: AppServiceCertificateResource, options?: AppServiceCertificateOrdersCreateOrUpdateCertificateOptionalParams): Promise<SimplePollerLike<OperationState<AppServiceCertificateOrdersCreateOrUpdateCertificateResponse>, AppServiceCertificateOrdersCreateOrUpdateCertificateResponse>>;
    beginCreateOrUpdateCertificateAndWait(resourceGroupName: string, certificateOrderName: string, name: string, keyVaultCertificate: AppServiceCertificateResource, options?: AppServiceCertificateOrdersCreateOrUpdateCertificateOptionalParams): Promise<AppServiceCertificateOrdersCreateOrUpdateCertificateResponse>;
    delete(resourceGroupName: string, certificateOrderName: string, options?: AppServiceCertificateOrdersDeleteOptionalParams): Promise<void>;
    deleteCertificate(resourceGroupName: string, certificateOrderName: string, name: string, options?: AppServiceCertificateOrdersDeleteCertificateOptionalParams): Promise<void>;
    get(resourceGroupName: string, certificateOrderName: string, options?: AppServiceCertificateOrdersGetOptionalParams): Promise<AppServiceCertificateOrdersGetResponse>;
    getCertificate(resourceGroupName: string, certificateOrderName: string, name: string, options?: AppServiceCertificateOrdersGetCertificateOptionalParams): Promise<AppServiceCertificateOrdersGetCertificateResponse>;
    list(options?: AppServiceCertificateOrdersListOptionalParams): PagedAsyncIterableIterator<AppServiceCertificateOrder>;
    listByResourceGroup(resourceGroupName: string, options?: AppServiceCertificateOrdersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<AppServiceCertificateOrder>;
    listCertificates(resourceGroupName: string, certificateOrderName: string, options?: AppServiceCertificateOrdersListCertificatesOptionalParams): PagedAsyncIterableIterator<AppServiceCertificateResource>;
    reissue(resourceGroupName: string, certificateOrderName: string, reissueCertificateOrderRequest: ReissueCertificateOrderRequest, options?: AppServiceCertificateOrdersReissueOptionalParams): Promise<void>;
    renew(resourceGroupName: string, certificateOrderName: string, renewCertificateOrderRequest: RenewCertificateOrderRequest, options?: AppServiceCertificateOrdersRenewOptionalParams): Promise<void>;
    resendEmail(resourceGroupName: string, certificateOrderName: string, options?: AppServiceCertificateOrdersResendEmailOptionalParams): Promise<void>;
    resendRequestEmails(resourceGroupName: string, certificateOrderName: string, nameIdentifier: NameIdentifier, options?: AppServiceCertificateOrdersResendRequestEmailsOptionalParams): Promise<void>;
    retrieveCertificateActions(resourceGroupName: string, name: string, options?: AppServiceCertificateOrdersRetrieveCertificateActionsOptionalParams): Promise<AppServiceCertificateOrdersRetrieveCertificateActionsResponse>;
    retrieveCertificateEmailHistory(resourceGroupName: string, name: string, options?: AppServiceCertificateOrdersRetrieveCertificateEmailHistoryOptionalParams): Promise<AppServiceCertificateOrdersRetrieveCertificateEmailHistoryResponse>;
    retrieveSiteSeal(resourceGroupName: string, certificateOrderName: string, siteSealRequest: SiteSealRequest, options?: AppServiceCertificateOrdersRetrieveSiteSealOptionalParams): Promise<AppServiceCertificateOrdersRetrieveSiteSealResponse>;
    update(resourceGroupName: string, certificateOrderName: string, certificateDistinguishedName: AppServiceCertificateOrderPatchResource, options?: AppServiceCertificateOrdersUpdateOptionalParams): Promise<AppServiceCertificateOrdersUpdateResponse>;
    updateCertificate(resourceGroupName: string, certificateOrderName: string, name: string, keyVaultCertificate: AppServiceCertificatePatchResource, options?: AppServiceCertificateOrdersUpdateCertificateOptionalParams): Promise<AppServiceCertificateOrdersUpdateCertificateResponse>;
    validatePurchaseInformation(appServiceCertificateOrder: AppServiceCertificateOrder, options?: AppServiceCertificateOrdersValidatePurchaseInformationOptionalParams): Promise<void>;
    verifyDomainOwnership(resourceGroupName: string, certificateOrderName: string, options?: AppServiceCertificateOrdersVerifyDomainOwnershipOptionalParams): Promise<void>;
}

// @public
export interface AppServiceCertificateOrdersCreateOrUpdateCertificateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AppServiceCertificateOrdersCreateOrUpdateCertificateResponse = AppServiceCertificateResource;

// @public
export interface AppServiceCertificateOrdersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AppServiceCertificateOrdersCreateOrUpdateResponse = AppServiceCertificateOrder;

// @public
export interface AppServiceCertificateOrdersDeleteCertificateOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AppServiceCertificateOrdersDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AppServiceCertificateOrdersGetCertificateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersGetCertificateResponse = AppServiceCertificateResource;

// @public
export interface AppServiceCertificateOrdersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersGetResponse = AppServiceCertificateOrder;

// @public
export interface AppServiceCertificateOrdersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersListByResourceGroupNextResponse = AppServiceCertificateOrderCollection;

// @public
export interface AppServiceCertificateOrdersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersListByResourceGroupResponse = AppServiceCertificateOrderCollection;

// @public
export interface AppServiceCertificateOrdersListCertificatesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersListCertificatesNextResponse = AppServiceCertificateCollection;

// @public
export interface AppServiceCertificateOrdersListCertificatesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersListCertificatesResponse = AppServiceCertificateCollection;

// @public
export interface AppServiceCertificateOrdersListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersListNextResponse = AppServiceCertificateOrderCollection;

// @public
export interface AppServiceCertificateOrdersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersListResponse = AppServiceCertificateOrderCollection;

// @public
export interface AppServiceCertificateOrdersReissueOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AppServiceCertificateOrdersRenewOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AppServiceCertificateOrdersResendEmailOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AppServiceCertificateOrdersResendRequestEmailsOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AppServiceCertificateOrdersRetrieveCertificateActionsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersRetrieveCertificateActionsResponse = CertificateOrderAction[];

// @public
export interface AppServiceCertificateOrdersRetrieveCertificateEmailHistoryOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersRetrieveCertificateEmailHistoryResponse = CertificateEmail[];

// @public
export interface AppServiceCertificateOrdersRetrieveSiteSealOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersRetrieveSiteSealResponse = SiteSeal;

// @public
export interface AppServiceCertificateOrdersUpdateCertificateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersUpdateCertificateResponse = AppServiceCertificateResource;

// @public
export interface AppServiceCertificateOrdersUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AppServiceCertificateOrdersUpdateResponse = AppServiceCertificateOrder;

// @public
export interface AppServiceCertificateOrdersValidatePurchaseInformationOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AppServiceCertificateOrdersVerifyDomainOwnershipOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface AppServiceCertificatePatchResource extends ProxyOnlyResource {
    keyVaultId?: string;
    keyVaultSecretName?: string;
    readonly provisioningState?: KeyVaultSecretStatus;
}

// @public
export interface AppServiceCertificateResource extends Resource {
    keyVaultId?: string;
    keyVaultSecretName?: string;
    readonly provisioningState?: KeyVaultSecretStatus;
}

// @public
export interface AppServiceEnvironment {
    clusterSettings?: NameValuePair[];
    customDnsSuffixConfiguration?: CustomDnsSuffixConfiguration;
    dedicatedHostCount?: number;
    dnsSuffix?: string;
    frontEndScaleFactor?: number;
    readonly hasLinuxWorkers?: boolean;
    internalLoadBalancingMode?: LoadBalancingMode;
    ipsslAddressCount?: number;
    readonly maximumNumberOfMachines?: number;
    readonly multiRoleCount?: number;
    multiSize?: string;
    networkingConfiguration?: AseV3NetworkingConfiguration;
    readonly provisioningState?: ProvisioningState;
    readonly status?: HostingEnvironmentStatus;
    readonly suspended?: boolean;
    readonly upgradeAvailability?: UpgradeAvailability;
    upgradePreference?: UpgradePreference;
    userWhitelistedIpRanges?: string[];
    virtualNetwork: VirtualNetworkProfile;
    zoneRedundant?: boolean;
}

// @public
export interface AppServicePlan extends Resource {
    asyncScalingEnabled?: boolean;
    elasticScaleEnabled?: boolean;
    extendedLocation?: ExtendedLocation;
    freeOfferExpirationTime?: Date;
    readonly geoRegion?: string;
    hostingEnvironmentProfile?: HostingEnvironmentProfile;
    hyperV?: boolean;
    isSpot?: boolean;
    isXenon?: boolean;
    kubeEnvironmentProfile?: KubeEnvironmentProfile;
    maximumElasticWorkerCount?: number;
    readonly maximumNumberOfWorkers?: number;
    readonly numberOfSites?: number;
    readonly numberOfWorkers?: number;
    perSiteScaling?: boolean;
    readonly provisioningState?: ProvisioningState;
    reserved?: boolean;
    readonly resourceGroup?: string;
    sku?: SkuDescription;
    spotExpirationTime?: Date;
    readonly status?: StatusOptions;
    readonly subscription?: string;
    targetWorkerCount?: number;
    targetWorkerSizeId?: number;
    workerTierName?: string;
    zoneRedundant?: boolean;
}

// @public
export interface AppServicePlanCollection {
    readonly nextLink?: string;
    value: AppServicePlan[];
}

// @public
export interface ArmIdWrapper {
    readonly id?: string;
}

// @public
export interface AseV3NetworkingConfiguration extends ProxyOnlyResource {
    allowNewPrivateEndpointConnections?: boolean;
    readonly externalInboundIpAddresses?: string[];
    ftpEnabled?: boolean;
    inboundIpAddressOverride?: string;
    readonly internalInboundIpAddresses?: string[];
    readonly linuxOutboundIpAddresses?: string[];
    remoteDebugEnabled?: boolean;
    readonly windowsOutboundIpAddresses?: string[];
}

// @public
export type AuthenticationType = string;

// @public
export type AutoGeneratedDomainNameLabelScope = "TenantReuse" | "SubscriptionReuse" | "ResourceGroupReuse" | "NoReuse";

// @public
export interface AutoHealActions {
    actionType?: AutoHealActionType;
    customAction?: AutoHealCustomAction;
    minProcessExecutionTime?: string;
}

// @public
export type AutoHealActionType = "Recycle" | "LogEvent" | "CustomAction";

// @public
export interface AutoHealCustomAction {
    exe?: string;
    parameters?: string;
}

// @public
export interface AutoHealRules {
    actions?: AutoHealActions;
    triggers?: AutoHealTriggers;
}

// @public
export interface AutoHealTriggers {
    privateBytesInKB?: number;
    requests?: RequestsBasedTrigger;
    slowRequests?: SlowRequestsBasedTrigger;
    slowRequestsWithPath?: SlowRequestsBasedTrigger[];
    statusCodes?: StatusCodesBasedTrigger[];
    statusCodesRange?: StatusCodesRangeBasedTrigger[];
}

// @public
export type AzureResourceType = "Website" | "TrafficManager";

// @public
export interface AzureStorageInfoValue {
    accessKey?: string;
    accountName?: string;
    mountPath?: string;
    protocol?: AzureStorageProtocol;
    shareName?: string;
    readonly state?: AzureStorageState;
    type?: AzureStorageType;
}

// @public
export type AzureStorageProtocol = string;

// @public
export type AzureStorageState = "Ok" | "InvalidCredentials" | "InvalidShare" | "NotValidated";

// @public
export type AzureStorageType = "AzureFiles" | "AzureBlob";

// @public
export interface Capability {
    name?: string;
    reason?: string;
    value?: string;
}

// @public
export interface Certificate extends Resource {
    canonicalName?: string;
    readonly cerBlob?: Uint8Array;
    domainValidationMethod?: string;
    readonly expirationDate?: Date;
    readonly friendlyName?: string;
    readonly hostingEnvironmentProfile?: HostingEnvironmentProfile;
    hostNames?: string[];
    readonly issueDate?: Date;
    readonly issuer?: string;
    keyVaultId?: string;
    keyVaultSecretName?: string;
    readonly keyVaultSecretStatus?: KeyVaultSecretStatus;
    password?: string;
    pfxBlob?: Uint8Array;
    readonly publicKeyHash?: string;
    readonly selfLink?: string;
    serverFarmId?: string;
    readonly siteName?: string;
    readonly subjectName?: string;
    readonly thumbprint?: string;
    readonly valid?: boolean;
}

// @public
export interface CertificateCollection {
    readonly nextLink?: string;
    value: Certificate[];
}

// @public
export interface CertificateDetails {
    readonly issuer?: string;
    readonly notAfter?: Date;
    readonly notBefore?: Date;
    readonly rawData?: string;
    readonly serialNumber?: string;
    readonly signatureAlgorithm?: string;
    readonly subject?: string;
    readonly thumbprint?: string;
    readonly version?: number;
}

// @public
export interface CertificateEmail {
    emailId?: string;
    timeStamp?: Date;
}

// @public
export interface CertificateOrderAction {
    readonly actionType?: CertificateOrderActionType;
    readonly createdAt?: Date;
}

// @public
export type CertificateOrderActionType = "CertificateIssued" | "CertificateOrderCanceled" | "CertificateOrderCreated" | "CertificateRevoked" | "DomainValidationComplete" | "FraudDetected" | "OrgNameChange" | "OrgValidationComplete" | "SanDrop" | "FraudCleared" | "CertificateExpired" | "CertificateExpirationWarning" | "FraudDocumentationRequired" | "Unknown";

// @public (undocumented)
export interface CertificateOrderContact {
    // (undocumented)
    email?: string;
    // (undocumented)
    nameFirst?: string;
    // (undocumented)
    nameLast?: string;
    // (undocumented)
    phone?: string;
}

// @public
export interface CertificateOrdersDiagnostics {
    getAppServiceCertificateOrderDetectorResponse(resourceGroupName: string, certificateOrderName: string, detectorName: string, options?: CertificateOrdersDiagnosticsGetAppServiceCertificateOrderDetectorResponseOptionalParams): Promise<CertificateOrdersDiagnosticsGetAppServiceCertificateOrderDetectorResponseResponse>;
    listAppServiceCertificateOrderDetectorResponse(resourceGroupName: string, certificateOrderName: string, options?: CertificateOrdersDiagnosticsListAppServiceCertificateOrderDetectorResponseOptionalParams): PagedAsyncIterableIterator<DetectorResponse>;
}

// @public
export interface CertificateOrdersDiagnosticsGetAppServiceCertificateOrderDetectorResponseOptionalParams extends coreClient.OperationOptions {
    endTime?: Date;
    startTime?: Date;
    timeGrain?: string;
}

// @public
export type CertificateOrdersDiagnosticsGetAppServiceCertificateOrderDetectorResponseResponse = DetectorResponse;

// @public
export interface CertificateOrdersDiagnosticsListAppServiceCertificateOrderDetectorResponseNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CertificateOrdersDiagnosticsListAppServiceCertificateOrderDetectorResponseNextResponse = DetectorResponseCollection;

// @public
export interface CertificateOrdersDiagnosticsListAppServiceCertificateOrderDetectorResponseOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CertificateOrdersDiagnosticsListAppServiceCertificateOrderDetectorResponseResponse = DetectorResponseCollection;

// @public
export type CertificateOrderStatus = "Pendingissuance" | "Issued" | "Revoked" | "Canceled" | "Denied" | "Pendingrevocation" | "PendingRekey" | "Unused" | "Expired" | "NotSubmitted";

// @public
export interface CertificatePatchResource extends ProxyOnlyResource {
    canonicalName?: string;
    readonly cerBlob?: Uint8Array;
    domainValidationMethod?: string;
    readonly expirationDate?: Date;
    readonly friendlyName?: string;
    readonly hostingEnvironmentProfile?: HostingEnvironmentProfile;
    hostNames?: string[];
    readonly issueDate?: Date;
    readonly issuer?: string;
    keyVaultId?: string;
    keyVaultSecretName?: string;
    readonly keyVaultSecretStatus?: KeyVaultSecretStatus;
    password?: string;
    pfxBlob?: Uint8Array;
    readonly publicKeyHash?: string;
    readonly selfLink?: string;
    serverFarmId?: string;
    readonly siteName?: string;
    readonly subjectName?: string;
    readonly thumbprint?: string;
    readonly valid?: boolean;
}

// @public
export type CertificateProductType = "StandardDomainValidatedSsl" | "StandardDomainValidatedWildCardSsl";

// @public (undocumented)
export class CertificateRegistrationManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: CertificateRegistrationManagementClientOptionalParams);
    constructor(credentials: coreAuth.TokenCredential, options?: CertificateRegistrationManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    appServiceCertificateOrders: AppServiceCertificateOrders;
    // (undocumented)
    certificateOrdersDiagnostics: CertificateOrdersDiagnostics;
    // (undocumented)
    certificateRegistrationProvider: CertificateRegistrationProvider;
    // (undocumented)
    subscriptionId?: string;
}

// @public
export interface CertificateRegistrationManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface CertificateRegistrationProvider {
    listOperations(options?: CertificateRegistrationProviderListOperationsOptionalParams): PagedAsyncIterableIterator<CsmOperationDescription>;
}

// @public
export interface CertificateRegistrationProviderListOperationsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CertificateRegistrationProviderListOperationsNextResponse = CsmOperationCollection;

// @public
export interface CertificateRegistrationProviderListOperationsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CertificateRegistrationProviderListOperationsResponse = CsmOperationCollection;

// @public
export interface CipherSuites {
    suites?: string[];
}

// @public
export type ClientCertMode = "Required" | "Optional" | "OptionalInteractiveUser";

// @public
export interface CloningInfo {
    appSettingsOverrides?: {
        [propertyName: string]: string;
    };
    cloneCustomHostNames?: boolean;
    cloneSourceControl?: boolean;
    configureLoadBalancing?: boolean;
    correlationId?: string;
    hostingEnvironment?: string;
    overwrite?: boolean;
    sourceWebAppId: string;
    sourceWebAppLocation?: string;
    trafficManagerProfileId?: string;
    trafficManagerProfileName?: string;
}

// @public
export type ConnectionStringType = "MySql" | "SQLServer" | "SQLAzure" | "Custom" | "NotificationHub" | "ServiceBus" | "EventHub" | "ApiHub" | "DocDb" | "RedisCache" | "PostgreSQL";

// @public
export interface ConnStringInfo {
    connectionString?: string;
    name?: string;
    type?: ConnectionStringType;
}

// @public
export interface Container {
    args?: string[];
    command?: string[];
    env?: EnvironmentVar[];
    image?: string;
    name?: string;
    resources?: ContainerResources;
}

// @public
export interface ContainerResources {
    cpu?: number;
    memory?: string;
}

// @public
export interface CorsSettings {
    allowedOrigins?: string[];
    supportCredentials?: boolean;
}

// @public
export interface CsmOperationCollection {
    readonly nextLink?: string;
    value: CsmOperationDescription[];
}

// @public
export interface CsmOperationDescription {
    display?: CsmOperationDisplay;
    // (undocumented)
    isDataAction?: boolean;
    // (undocumented)
    name?: string;
    // (undocumented)
    origin?: string;
    properties?: CsmOperationDescriptionProperties;
}

// @public
export interface CsmOperationDescriptionProperties {
    serviceSpecification?: ServiceSpecification;
}

// @public
export interface CsmOperationDisplay {
    // (undocumented)
    description?: string;
    // (undocumented)
    operation?: string;
    // (undocumented)
    provider?: string;
    // (undocumented)
    resource?: string;
}

// @public
export interface CsmUsageQuota {
    currentValue?: number;
    limit?: number;
    name?: LocalizableString;
    nextResetTime?: Date;
    unit?: string;
}

// @public
export interface CsmUsageQuotaCollection {
    readonly nextLink?: string;
    value: CsmUsageQuota[];
}

// @public
export interface CustomDnsSuffixConfiguration extends ProxyOnlyResource {
    certificateUrl?: string;
    dnsSuffix?: string;
    keyVaultReferenceIdentity?: string;
    readonly provisioningDetails?: string;
    readonly provisioningState?: CustomDnsSuffixProvisioningState;
}

// @public
export type CustomDnsSuffixProvisioningState = "Succeeded" | "Failed" | "Degraded" | "InProgress";

// @public
export type CustomHostNameDnsRecordType = "CName" | "A";

// @public
export interface CustomScaleRule {
    auth?: ScaleRuleAuth[];
    metadata?: {
        [propertyName: string]: string;
    };
    type?: string;
}

// @public
export interface Dapr {
    appId?: string;
    appPort?: number;
    components?: DaprComponent[];
    enabled?: boolean;
}

// @public
export interface DaprComponent {
    metadata?: DaprMetadata[];
    name?: string;
    type?: string;
    version?: string;
}

// @public
export interface DaprConfig {
    appId?: string;
    appPort?: number;
    enableApiLogging?: boolean;
    enabled?: boolean;
    httpMaxRequestSize?: number;
    httpReadBufferSize?: number;
    logLevel?: DaprLogLevel;
}

// @public
export type DaprLogLevel = string;

// @public
export interface DaprMetadata {
    name?: string;
    secretRef?: string;
    value?: string;
}

// @public
export interface DataProviderMetadata {
    readonly propertyBag?: KeyValuePairStringObject[];
    // (undocumented)
    providerName?: string;
}

// @public
export interface DataTableResponseColumn {
    columnName?: string;
    columnType?: string;
    dataType?: string;
}

// @public
export interface DataTableResponseObject {
    columns?: DataTableResponseColumn[];
    rows?: string[][];
    tableName?: string;
}

// @public
export type DefaultAction = string;

// @public
export interface DefaultErrorResponse {
    readonly error?: DefaultErrorResponseError;
}

// @public
export interface DefaultErrorResponseError {
    readonly code?: string;
    // (undocumented)
    details?: DefaultErrorResponseErrorDetailsItem[];
    readonly innererror?: string;
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface DefaultErrorResponseErrorDetailsItem {
    readonly code?: string;
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface DeletedSite extends ProxyOnlyResource {
    readonly deletedSiteId?: number;
    readonly deletedSiteName?: string;
    readonly deletedTimestamp?: string;
    readonly geoRegionName?: string;
    readonly kindPropertiesKind?: string;
    readonly resourceGroup?: string;
    readonly slot?: string;
    readonly subscription?: string;
}

// @public
export interface DetectorInfo {
    readonly analysisType?: string[];
    readonly author?: string;
    readonly category?: string;
    readonly description?: string;
    readonly id?: string;
    readonly name?: string;
    readonly score?: number;
    readonly supportTopicList?: SupportTopic[];
    readonly type?: DetectorType;
}

// @public
export interface DetectorResponse extends ProxyOnlyResource {
    dataProvidersMetadata?: DataProviderMetadata[];
    dataset?: DiagnosticData[];
    metadata?: DetectorInfo;
    status?: Status;
    suggestedUtterances?: QueryUtterancesResults;
}

// @public
export interface DetectorResponseCollection {
    readonly nextLink?: string;
    value: DetectorResponse[];
}

// @public
export type DetectorType = "Detector" | "Analysis" | "CategoryOverview";

// @public
export interface DiagnosticData {
    renderingProperties?: Rendering;
    table?: DataTableResponseObject;
}

// @public
export interface Dimension {
    // (undocumented)
    displayName?: string;
    // (undocumented)
    internalName?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    toBeExportedForShoebox?: boolean;
}

// @public
export interface EnvironmentVar {
    name?: string;
    secretRef?: string;
    value?: string;
}

// @public
export interface ErrorEntity {
    code?: string;
    details?: ErrorEntity[];
    extendedCode?: string;
    innerErrors?: ErrorEntity[];
    message?: string;
    messageTemplate?: string;
    parameters?: string[];
    target?: string;
}

// @public
export interface Experiments {
    rampUpRules?: RampUpRule[];
}

// @public
export interface ExtendedLocation {
    name?: string;
    readonly type?: string;
}

// @public
export type FtpsState = string;

// @public
export interface FunctionAppConfig {
    deployment?: FunctionsDeployment;
    runtime?: FunctionsRuntime;
    scaleAndConcurrency?: FunctionsScaleAndConcurrency;
}

// @public
export interface FunctionsAlwaysReadyConfig {
    instanceCount?: number;
    name?: string;
}

// @public
export interface FunctionsDeployment {
    storage?: FunctionsDeploymentStorage;
}

// @public
export interface FunctionsDeploymentStorage {
    authentication?: FunctionsDeploymentStorageAuthentication;
    type?: FunctionsDeploymentStorageType;
    value?: string;
}

// @public
export interface FunctionsDeploymentStorageAuthentication {
    storageAccountConnectionStringName?: string;
    type?: AuthenticationType;
    userAssignedIdentityResourceId?: string;
}

// @public
export type FunctionsDeploymentStorageType = string;

// @public
export interface FunctionsRuntime {
    name?: RuntimeName;
    version?: string;
}

// @public
export interface FunctionsScaleAndConcurrency {
    alwaysReady?: FunctionsAlwaysReadyConfig[];
    instanceMemoryMB?: number;
    maximumInstanceCount?: number;
    triggers?: FunctionsScaleAndConcurrencyTriggers;
}

// @public
export interface FunctionsScaleAndConcurrencyTriggers {
    http?: FunctionsScaleAndConcurrencyTriggersHttp;
}

// @public
export interface FunctionsScaleAndConcurrencyTriggersHttp {
    perInstanceConcurrency?: number;
}

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface HandlerMapping {
    arguments?: string;
    extension?: string;
    scriptProcessor?: string;
}

// @public
export interface HostingEnvironmentProfile {
    id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export type HostingEnvironmentStatus = "Preparing" | "Ready" | "Scaling" | "Deleting";

// @public
export interface HostNameBinding extends ProxyOnlyResource {
    azureResourceName?: string;
    azureResourceType?: AzureResourceType;
    customHostNameDnsRecordType?: CustomHostNameDnsRecordType;
    domainId?: string;
    hostNameType?: HostNameType;
    siteName?: string;
    sslState?: SslState;
    thumbprint?: string;
    readonly virtualIP?: string;
}

// @public
export interface HostNameBindingCollection {
    readonly nextLink?: string;
    value: HostNameBinding[];
}

// @public
export interface HostNameSslState {
    hostType?: HostType;
    name?: string;
    sslState?: SslState;
    thumbprint?: string;
    toUpdate?: boolean;
    virtualIP?: string;
}

// @public
export type HostNameType = "Verified" | "Managed";

// @public
export type HostType = "Standard" | "Repository";

// @public
export interface HttpScaleRule {
    auth?: ScaleRuleAuth[];
    metadata?: {
        [propertyName: string]: string;
    };
}

// @public
export interface HybridConnection extends ProxyOnlyResource {
    hostname?: string;
    port?: number;
    relayArmUri?: string;
    relayName?: string;
    sendKeyName?: string;
    sendKeyValue?: string;
    serviceBusNamespace?: string;
    serviceBusSuffix?: string;
}

// @public
export interface Identifier extends ProxyOnlyResource {
    value?: string;
}

// @public
export interface IdentifierCollection {
    readonly nextLink?: string;
    value: Identifier[];
}

// @public
export type InsightStatus = "Critical" | "Warning" | "Info" | "Success" | "None";

// @public
export type IpFilterTag = string;

// @public
export type IPMode = "IPv4" | "IPv6" | "IPv4AndIPv6";

// @public
export interface IpSecurityRestriction {
    action?: string;
    description?: string;
    headers?: {
        [propertyName: string]: string[];
    };
    ipAddress?: string;
    name?: string;
    priority?: number;
    subnetMask?: string;
    subnetTrafficTag?: number;
    tag?: IpFilterTag;
    vnetSubnetResourceId?: string;
    vnetTrafficTag?: number;
}

// @public (undocumented)
export interface KeyValuePairStringObject {
    readonly key?: string;
    readonly value?: Record<string, unknown>;
}

// @public
export type KeyVaultSecretStatus = "Initialized" | "WaitingOnCertificateOrder" | "Succeeded" | "CertificateOrderFailed" | "OperationNotPermittedOnKeyVault" | "AzureServiceUnauthorizedToAccessKeyVault" | "KeyVaultDoesNotExist" | "KeyVaultSecretDoesNotExist" | "UnknownError" | "ExternalPrivateKey" | "Unknown";

// @public
export enum KnownAuthenticationType {
    StorageAccountConnectionString = "StorageAccountConnectionString",
    SystemAssignedIdentity = "SystemAssignedIdentity",
    UserAssignedIdentity = "UserAssignedIdentity"
}

// @public
export enum KnownAzureStorageProtocol {
    Http = "Http",
    Nfs = "Nfs",
    Smb = "Smb"
}

// @public
export enum KnownDaprLogLevel {
    Debug = "debug",
    Error = "error",
    Info = "info",
    Warn = "warn"
}

// @public
export enum KnownDefaultAction {
    Allow = "Allow",
    Deny = "Deny"
}

// @public
export enum KnownFtpsState {
    AllAllowed = "AllAllowed",
    Disabled = "Disabled",
    FtpsOnly = "FtpsOnly"
}

// @public
export enum KnownFunctionsDeploymentStorageType {
    BlobContainer = "blobContainer"
}

// @public
export enum KnownIpFilterTag {
    Default = "Default",
    ServiceTag = "ServiceTag",
    XffProxy = "XffProxy"
}

// @public
export enum KnownLoadBalancingMode {
    None = "None",
    Publishing = "Publishing",
    Web = "Web",
    WebPublishing = "Web, Publishing"
}

// @public
export enum KnownResourceNotRenewableReason {
    ExpirationNotInRenewalTimeRange = "ExpirationNotInRenewalTimeRange",
    RegistrationStatusNotSupportedForRenewal = "RegistrationStatusNotSupportedForRenewal",
    SubscriptionNotActive = "SubscriptionNotActive"
}

// @public
export enum KnownRouteType {
    Default = "DEFAULT",
    Inherited = "INHERITED",
    Static = "STATIC"
}

// @public
export enum KnownRuntimeName {
    Custom = "custom",
    DotnetIsolated = "dotnet-isolated",
    Java = "java",
    Node = "node",
    Powershell = "powershell",
    Python = "python"
}

// @public
export enum KnownScmType {
    BitbucketGit = "BitbucketGit",
    BitbucketHg = "BitbucketHg",
    CodePlexGit = "CodePlexGit",
    CodePlexHg = "CodePlexHg",
    Dropbox = "Dropbox",
    ExternalGit = "ExternalGit",
    ExternalHg = "ExternalHg",
    GitHub = "GitHub",
    LocalGit = "LocalGit",
    None = "None",
    OneDrive = "OneDrive",
    Tfs = "Tfs",
    VSO = "VSO",
    Vstsrm = "VSTSRM"
}

// @public
export enum KnownSupportedTlsVersions {
    One0 = "1.0",
    One1 = "1.1",
    One2 = "1.2",
    One3 = "1.3"
}

// @public
export enum KnownTlsCipherSuites {
    TLSAES128GCMSHA256 = "TLS_AES_128_GCM_SHA256",
    TLSAES256GCMSHA384 = "TLS_AES_256_GCM_SHA384",
    TLSEcdheEcdsaWithAES128CBCSHA256 = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
    TLSEcdheEcdsaWithAES128GCMSHA256 = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    TLSEcdheEcdsaWithAES256GCMSHA384 = "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
    TLSEcdheRSAWithAES128CBCSHA = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
    TLSEcdheRSAWithAES128CBCSHA256 = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
    TLSEcdheRSAWithAES128GCMSHA256 = "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    TLSEcdheRSAWithAES256CBCSHA = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
    TLSEcdheRSAWithAES256CBCSHA384 = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
    TLSEcdheRSAWithAES256GCMSHA384 = "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    TLSRSAWithAES128CBCSHA = "TLS_RSA_WITH_AES_128_CBC_SHA",
    TLSRSAWithAES128CBCSHA256 = "TLS_RSA_WITH_AES_128_CBC_SHA256",
    TLSRSAWithAES128GCMSHA256 = "TLS_RSA_WITH_AES_128_GCM_SHA256",
    TLSRSAWithAES256CBCSHA = "TLS_RSA_WITH_AES_256_CBC_SHA",
    TLSRSAWithAES256CBCSHA256 = "TLS_RSA_WITH_AES_256_CBC_SHA256",
    TLSRSAWithAES256GCMSHA384 = "TLS_RSA_WITH_AES_256_GCM_SHA384"
}

// @public
export enum KnownUpgradeAvailability {
    None = "None",
    Ready = "Ready"
}

// @public
export enum KnownUpgradePreference {
    Early = "Early",
    Late = "Late",
    Manual = "Manual",
    None = "None"
}

// @public
export interface KubeEnvironmentProfile {
    id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export type LoadBalancingMode = string;

// @public
export interface LocalizableString {
    localizedValue?: string;
    value?: string;
}

// @public
export interface LogSpecification {
    // (undocumented)
    blobDuration?: string;
    // (undocumented)
    displayName?: string;
    // (undocumented)
    logFilterPattern?: string;
    // (undocumented)
    name?: string;
}

// @public
export type ManagedPipelineMode = "Integrated" | "Classic";

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ManagedServiceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentity;
    };
}

// @public
export type ManagedServiceIdentityType = "SystemAssigned" | "UserAssigned" | "SystemAssigned, UserAssigned" | "None";

// @public
export interface MetricAvailability {
    // (undocumented)
    blobDuration?: string;
    // (undocumented)
    timeGrain?: string;
}

// @public
export interface MetricSpecification {
    // (undocumented)
    aggregationType?: string;
    // (undocumented)
    availabilities?: MetricAvailability[];
    // (undocumented)
    category?: string;
    // (undocumented)
    dimensions?: Dimension[];
    // (undocumented)
    displayDescription?: string;
    // (undocumented)
    displayName?: string;
    // (undocumented)
    enableRegionalMdmAccount?: boolean;
    // (undocumented)
    fillGapWithZero?: boolean;
    // (undocumented)
    isInternal?: boolean;
    // (undocumented)
    metricFilterPattern?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    sourceMdmAccount?: string;
    // (undocumented)
    sourceMdmNamespace?: string;
    // (undocumented)
    supportedAggregationTypes?: string[];
    // (undocumented)
    supportedTimeGrainTypes?: string[];
    // (undocumented)
    supportsInstanceLevelAggregation?: boolean;
    // (undocumented)
    unit?: string;
}

// @public
export interface NameIdentifier {
    name?: string;
}

// @public
export interface NameValuePair {
    name?: string;
    value?: string;
}

// @public
export interface Operation {
    createdTime?: Date;
    errors?: ErrorEntity[];
    expirationTime?: Date;
    geoMasterOperationId?: string;
    id?: string;
    modifiedTime?: Date;
    name?: string;
    status?: OperationStatus;
}

// @public
export type OperationStatus = "InProgress" | "Failed" | "Succeeded" | "TimedOut" | "Created";

// @public
export interface OutboundVnetRouting {
    allTraffic?: boolean;
    applicationTraffic?: boolean;
    backupRestoreTraffic?: boolean;
    contentShareTraffic?: boolean;
    imagePullTraffic?: boolean;
}

// @public (undocumented)
export interface PrivateEndpointConnectionCollection {
    readonly nextLink?: string;
    value: RemotePrivateEndpointConnectionARMResource[];
}

// @public
export interface PrivateLinkConnectionApprovalRequestResource extends ProxyOnlyResource {
    privateLinkServiceConnectionState?: PrivateLinkConnectionState;
}

// @public
export interface PrivateLinkConnectionState {
    actionsRequired?: string;
    description?: string;
    status?: string;
}

// @public
export interface PrivateLinkResource {
    // (undocumented)
    id: string;
    name: string;
    properties: PrivateLinkResourceProperties;
    // (undocumented)
    type: string;
}

// @public
export interface PrivateLinkResourceProperties {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    readonly requiredZoneNames?: string[];
}

// @public
export interface PrivateLinkResourcesWrapper {
    // (undocumented)
    value: PrivateLinkResource[];
}

// @public
export type ProvisioningState = "Succeeded" | "Failed" | "Canceled" | "InProgress" | "Deleting";

// @public
export interface ProxyOnlyResource {
    readonly id?: string;
    kind?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface PushSettings extends ProxyOnlyResource {
    dynamicTagsJson?: string;
    isPushEnabled?: boolean;
    tagsRequiringAuth?: string;
    tagWhitelistJson?: string;
}

// @public
export interface QueryUtterancesResult {
    sampleUtterance?: SampleUtterance;
    score?: number;
}

// @public
export interface QueryUtterancesResults {
    query?: string;
    results?: QueryUtterancesResult[];
}

// @public
export interface QueueScaleRule {
    auth?: ScaleRuleAuth[];
    queueLength?: number;
    queueName?: string;
}

// @public
export interface RampUpRule {
    actionHostName?: string;
    changeDecisionCallbackUrl?: string;
    changeIntervalInMinutes?: number;
    changeStep?: number;
    maxReroutePercentage?: number;
    minReroutePercentage?: number;
    name?: string;
    reroutePercentage?: number;
}

// @public
export type RedundancyMode = "None" | "Manual" | "Failover" | "ActiveActive" | "GeoRedundant";

// @public
export interface ReissueCertificateOrderRequest extends ProxyOnlyResource {
    csr?: string;
    delayExistingRevokeInHours?: number;
    isPrivateKeyExternal?: boolean;
    keySize?: number;
}

// @public
export interface RemotePrivateEndpointConnectionARMResource extends ProxyOnlyResource {
    ipAddresses?: string[];
    privateEndpoint?: ArmIdWrapper;
    privateLinkServiceConnectionState?: PrivateLinkConnectionState;
    readonly provisioningState?: string;
}

// @public
export interface Rendering {
    description?: string;
    title?: string;
    type?: RenderingType;
}

// @public
export type RenderingType = "NoGraph" | "Table" | "TimeSeries" | "TimeSeriesPerInstance" | "PieChart" | "DataSummary" | "Email" | "Insights" | "DynamicInsight" | "Markdown" | "Detector" | "DropDown" | "Card" | "Solution" | "Guage" | "Form" | "ChangeSets" | "ChangeAnalysisOnboarding" | "ChangesView" | "AppInsight" | "DependencyGraph" | "DownTime" | "SummaryCard" | "SearchComponent" | "AppInsightEnablement";

// @public
export interface RenewCertificateOrderRequest extends ProxyOnlyResource {
    csr?: string;
    isPrivateKeyExternal?: boolean;
    keySize?: number;
}

// @public
export interface RequestsBasedTrigger {
    count?: number;
    timeInterval?: string;
}

// @public
export interface Resource {
    readonly id?: string;
    kind?: string;
    location: string;
    readonly name?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export interface ResourceConfig {
    cpu?: number;
    memory?: string;
}

// @public
export type ResourceNotRenewableReason = string;

// @public
export type RouteType = string;

// @public
export type RuntimeName = string;

// @public
export interface SampleUtterance {
    links?: string[];
    qid?: string;
    text?: string;
}

// @public
export interface Scale {
    maxReplicas?: number;
    minReplicas?: number;
    rules?: ScaleRule[];
}

// @public
export interface ScaleRule {
    azureQueue?: QueueScaleRule;
    custom?: CustomScaleRule;
    http?: HttpScaleRule;
    name?: string;
}

// @public
export interface ScaleRuleAuth {
    secretRef?: string;
    triggerParameter?: string;
}

// @public
export type ScmType = string;

// @public
export interface ServiceSpecification {
    // (undocumented)
    logSpecifications?: LogSpecification[];
    // (undocumented)
    metricSpecifications?: MetricSpecification[];
}

// @public
export interface Site extends Resource {
    autoGeneratedDomainNameLabelScope?: AutoGeneratedDomainNameLabelScope;
    readonly availabilityState?: SiteAvailabilityState;
    clientAffinityEnabled?: boolean;
    clientAffinityPartitioningEnabled?: boolean;
    clientAffinityProxyEnabled?: boolean;
    clientCertEnabled?: boolean;
    clientCertExclusionPaths?: string;
    clientCertMode?: ClientCertMode;
    cloningInfo?: CloningInfo;
    containerSize?: number;
    customDomainVerificationId?: string;
    dailyMemoryTimeQuota?: number;
    daprConfig?: DaprConfig;
    readonly defaultHostName?: string;
    dnsConfiguration?: SiteDnsConfig;
    enabled?: boolean;
    readonly enabledHostNames?: string[];
    endToEndEncryptionEnabled?: boolean;
    extendedLocation?: ExtendedLocation;
    functionAppConfig?: FunctionAppConfig;
    hostingEnvironmentProfile?: HostingEnvironmentProfile;
    readonly hostNames?: string[];
    hostNamesDisabled?: boolean;
    hostNameSslStates?: HostNameSslState[];
    httpsOnly?: boolean;
    hyperV?: boolean;
    identity?: ManagedServiceIdentity;
    readonly inProgressOperationId?: string;
    ipMode?: IPMode;
    readonly isDefaultContainer?: boolean;
    isXenon?: boolean;
    keyVaultReferenceIdentity?: string;
    readonly lastModifiedTimeUtc?: Date;
    managedEnvironmentId?: string;
    readonly maxNumberOfWorkers?: number;
    readonly outboundIpAddresses?: string;
    outboundVnetRouting?: OutboundVnetRouting;
    readonly possibleOutboundIpAddresses?: string;
    publicNetworkAccess?: string;
    redundancyMode?: RedundancyMode;
    readonly repositorySiteName?: string;
    reserved?: boolean;
    resourceConfig?: ResourceConfig;
    readonly resourceGroup?: string;
    scmSiteAlsoStopped?: boolean;
    serverFarmId?: string;
    siteConfig?: SiteConfig;
    readonly sku?: string;
    readonly slotSwapStatus?: SlotSwapStatus;
    sshEnabled?: boolean;
    readonly state?: string;
    storageAccountRequired?: boolean;
    readonly suspendedTill?: Date;
    readonly targetSwapSlot?: string;
    readonly trafficManagerHostNames?: string[];
    readonly usageState?: UsageState;
    virtualNetworkSubnetId?: string;
    workloadProfileName?: string;
}

// @public
export type SiteAvailabilityState = "Normal" | "Limited" | "DisasterRecoveryMode";

// @public
export interface SiteConfig {
    acrUseManagedIdentityCreds?: boolean;
    acrUserManagedIdentityID?: string;
    alwaysOn?: boolean;
    apiDefinition?: ApiDefinitionInfo;
    apiManagementConfig?: ApiManagementConfig;
    appCommandLine?: string;
    appSettings?: NameValuePair[];
    autoHealEnabled?: boolean;
    autoHealRules?: AutoHealRules;
    autoSwapSlotName?: string;
    azureStorageAccounts?: {
        [propertyName: string]: AzureStorageInfoValue;
    };
    connectionStrings?: ConnStringInfo[];
    cors?: CorsSettings;
    defaultDocuments?: string[];
    detailedErrorLoggingEnabled?: boolean;
    documentRoot?: string;
    elasticWebAppScaleLimit?: number;
    experiments?: Experiments;
    ftpsState?: FtpsState;
    functionAppScaleLimit?: number;
    functionsRuntimeScaleMonitoringEnabled?: boolean;
    handlerMappings?: HandlerMapping[];
    healthCheckPath?: string;
    http20Enabled?: boolean;
    http20ProxyFlag?: number;
    httpLoggingEnabled?: boolean;
    ipSecurityRestrictions?: IpSecurityRestriction[];
    ipSecurityRestrictionsDefaultAction?: DefaultAction;
    javaContainer?: string;
    javaContainerVersion?: string;
    javaVersion?: string;
    keyVaultReferenceIdentity?: string;
    limits?: SiteLimits;
    linuxFxVersion?: string;
    loadBalancing?: SiteLoadBalancing;
    localMySqlEnabled?: boolean;
    logsDirectorySizeLimit?: number;
    readonly machineKey?: SiteMachineKey;
    managedPipelineMode?: ManagedPipelineMode;
    managedServiceIdentityId?: number;
    metadata?: NameValuePair[];
    minimumElasticInstanceCount?: number;
    minTlsCipherSuite?: TlsCipherSuites;
    minTlsVersion?: SupportedTlsVersions;
    netFrameworkVersion?: string;
    nodeVersion?: string;
    numberOfWorkers?: number;
    phpVersion?: string;
    powerShellVersion?: string;
    preWarmedInstanceCount?: number;
    publicNetworkAccess?: string;
    publishingUsername?: string;
    push?: PushSettings;
    pythonVersion?: string;
    remoteDebuggingEnabled?: boolean;
    remoteDebuggingVersion?: string;
    requestTracingEnabled?: boolean;
    requestTracingExpirationTime?: Date;
    scmIpSecurityRestrictions?: IpSecurityRestriction[];
    scmIpSecurityRestrictionsDefaultAction?: DefaultAction;
    scmIpSecurityRestrictionsUseMain?: boolean;
    scmMinTlsVersion?: SupportedTlsVersions;
    scmType?: ScmType;
    tracingOptions?: string;
    use32BitWorkerProcess?: boolean;
    virtualApplications?: VirtualApplication[];
    vnetName?: string;
    vnetPrivatePortsCount?: number;
    vnetRouteAllEnabled?: boolean;
    websiteTimeZone?: string;
    webSocketsEnabled?: boolean;
    windowsFxVersion?: string;
    xManagedServiceIdentityId?: number;
}

// @public (undocumented)
export interface SiteDnsConfig {
    dnsAltServer?: string;
    readonly dnsLegacySortOrder?: boolean;
    dnsMaxCacheTimeout?: number;
    dnsRetryAttemptCount?: number;
    dnsRetryAttemptTimeout?: number;
    dnsServers?: string[];
}

// @public
export interface SiteLimits {
    maxDiskSizeInMb?: number;
    maxMemoryInMb?: number;
    maxPercentageCpu?: number;
}

// @public
export type SiteLoadBalancing = "WeightedRoundRobin" | "LeastRequests" | "LeastResponseTime" | "WeightedTotalTraffic" | "RequestHash" | "PerSiteRoundRobin" | "LeastRequestsWithTieBreaker";

// @public
export interface SiteMachineKey {
    decryption?: string;
    decryptionKey?: string;
    validation?: string;
    validationKey?: string;
}

// @public
export interface SiteSeal {
    html: string;
}

// @public
export interface SiteSealRequest {
    lightTheme?: boolean;
    locale?: string;
}

// @public
export interface SkuCapacity {
    default?: number;
    elasticMaximum?: number;
    maximum?: number;
    minimum?: number;
    scaleType?: string;
}

// @public
export interface SkuDescription {
    capabilities?: Capability[];
    capacity?: number;
    family?: string;
    locations?: string[];
    name?: string;
    size?: string;
    skuCapacity?: SkuCapacity;
    tier?: string;
}

// @public
export interface SlotSwapStatus {
    readonly destinationSlotName?: string;
    readonly sourceSlotName?: string;
    readonly timestampUtc?: Date;
}

// @public
export interface SlowRequestsBasedTrigger {
    count?: number;
    path?: string;
    timeInterval?: string;
    timeTaken?: string;
}

// @public
export interface Snapshot extends ProxyOnlyResource {
    readonly time?: string;
}

// @public
export type SslState = "Disabled" | "SniEnabled" | "IpBasedEnabled";

// @public
export interface Status {
    message?: string;
    statusId?: InsightStatus;
}

// @public
export interface StatusCodesBasedTrigger {
    count?: number;
    path?: string;
    status?: number;
    subStatus?: number;
    timeInterval?: string;
    win32Status?: number;
}

// @public
export interface StatusCodesRangeBasedTrigger {
    count?: number;
    // (undocumented)
    path?: string;
    statusCodes?: string;
    timeInterval?: string;
}

// @public
export type StatusOptions = "Ready" | "Pending" | "Creating";

// @public
export interface StringDictionary extends ProxyOnlyResource {
    properties?: {
        [propertyName: string]: string;
    };
}

// @public
export type SupportedTlsVersions = string;

// @public
export interface SupportTopic {
    readonly id?: string;
    readonly pesId?: string;
}

// @public
export interface Template {
    containers?: Container[];
    dapr?: Dapr;
    revisionSuffix?: string;
    scale?: Scale;
}

// @public
export type TlsCipherSuites = string;

// @public
export type UpgradeAvailability = string;

// @public
export type UpgradePreference = string;

// @public
export type UsageState = "Normal" | "Exceeded";

// @public
export interface User extends ProxyOnlyResource {
    publishingPassword?: string;
    publishingPasswordHash?: string;
    publishingPasswordHashSalt?: string;
    publishingUserName?: string;
    scmUri?: string;
}

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface VirtualApplication {
    physicalPath?: string;
    preloadEnabled?: boolean;
    virtualDirectories?: VirtualDirectory[];
    virtualPath?: string;
}

// @public
export interface VirtualDirectory {
    physicalPath?: string;
    virtualPath?: string;
}

// @public
export interface VirtualNetworkProfile {
    id: string;
    readonly name?: string;
    subnet?: string;
    readonly type?: string;
}

// @public
export interface VnetGateway extends ProxyOnlyResource {
    vnetName?: string;
    vpnPackageUri?: string;
}

// @public
export interface VnetInfoResource extends ProxyOnlyResource {
    certBlob?: string;
    readonly certThumbprint?: string;
    dnsServers?: string;
    isSwift?: boolean;
    readonly resyncRequired?: boolean;
    readonly routes?: VnetRoute[];
    vnetResourceId?: string;
}

// @public
export interface VnetRoute extends ProxyOnlyResource {
    endAddress?: string;
    routeType?: RouteType;
    startAddress?: string;
}

// @public
export interface WebAppCollection {
    readonly nextLink?: string;
    value: Site[];
}

// (No @packageDocumentation comment for this package)

```
