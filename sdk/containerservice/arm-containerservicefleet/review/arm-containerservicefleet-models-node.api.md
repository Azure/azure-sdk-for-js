## API Report File for "@azure/arm-containerservicefleet"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type ActionType = string;

// @public
export type AdoptionPolicy = string;

// @public
export interface Affinity {
    clusterAffinity?: ClusterAffinity;
}

// @public
export interface AgentProfile {
    subnetId?: string;
    vmSize?: string;
}

// @public
export interface APIServerAccessProfile {
    enablePrivateCluster?: boolean;
    enableVnetIntegration?: boolean;
    subnetId?: string;
}

// @public
export type AutoUpgradeLastTriggerStatus = string;

// @public
export interface AutoUpgradeNodeImageSelection {
    type: AutoUpgradeNodeImageSelectionType;
}

// @public
export type AutoUpgradeNodeImageSelectionType = string;

// @public
export interface AutoUpgradeProfile extends ProxyResource {
    readonly eTag?: string;
    properties?: AutoUpgradeProfileProperties;
}

// @public
export interface AutoUpgradeProfileProperties {
    autoUpgradeProfileStatus?: AutoUpgradeProfileStatus;
    channel: UpgradeChannel;
    disabled?: boolean;
    longTermSupport?: boolean;
    nodeImageSelection?: AutoUpgradeNodeImageSelection;
    readonly provisioningState?: AutoUpgradeProfileProvisioningState;
    targetKubernetesVersion?: string;
    updateStrategyId?: string;
}

// @public
export type AutoUpgradeProfileProvisioningState = string;

// @public
export interface AutoUpgradeProfileStatus {
    readonly lastTriggeredAt?: Date;
    readonly lastTriggerError?: ErrorDetail;
    readonly lastTriggerStatus?: AutoUpgradeLastTriggerStatus;
    readonly lastTriggerUpgradeVersions?: string[];
}

// @public
export interface ClusterAffinity {
    requiredDuringSchedulingIgnoredDuringExecution?: ClusterSelector;
}

// @public
export interface ClusterResourcePlacementSpec {
    policy?: PlacementPolicy;
}

// @public
export interface ClusterSelector {
    clusterSelectorTerms: ClusterSelectorTerm[];
}

// @public
export interface ClusterSelectorTerm {
    labelSelector?: LabelSelector;
    propertySelector?: PropertySelector;
}

// @public
export type CreatedByType = string;

// @public
export type DeletePolicy = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: any;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface Fleet extends TrackedResource {
    readonly eTag?: string;
    identity?: ManagedServiceIdentity;
    properties?: FleetProperties;
}

// @public
export interface FleetCredentialResult {
    readonly name?: string;
    readonly value?: Uint8Array;
}

// @public
export interface FleetCredentialResults {
    readonly kubeconfigs?: FleetCredentialResult[];
}

// @public
export interface FleetHubProfile {
    agentProfile?: AgentProfile;
    apiServerAccessProfile?: APIServerAccessProfile;
    dnsPrefix?: string;
    readonly fqdn?: string;
    readonly kubernetesVersion?: string;
    readonly portalFqdn?: string;
}

// @public
export interface FleetManagedNamespace extends TrackedResource {
    readonly eTag?: string;
    properties?: FleetManagedNamespaceProperties;
}

// @public
export interface FleetManagedNamespacePatch {
    tags?: Record<string, string>;
}

// @public
export interface FleetManagedNamespaceProperties {
    adoptionPolicy: AdoptionPolicy;
    deletePolicy: DeletePolicy;
    managedNamespaceProperties?: ManagedNamespaceProperties;
    readonly portalFqdn?: string;
    propagationPolicy?: PropagationPolicy;
    readonly provisioningState?: FleetManagedNamespaceProvisioningState;
    readonly status?: FleetManagedNamespaceStatus;
}

// @public
export type FleetManagedNamespaceProvisioningState = string;

// @public
export interface FleetManagedNamespaceStatus {
    readonly lastOperationError?: ErrorDetail;
    readonly lastOperationId?: string;
}

// @public
export interface FleetMember extends ProxyResource {
    readonly eTag?: string;
    properties?: FleetMemberProperties;
}

// @public
export interface FleetMemberProperties {
    clusterResourceId: string;
    group?: string;
    labels?: Record<string, string>;
    readonly provisioningState?: FleetMemberProvisioningState;
    readonly status?: FleetMemberStatus;
}

// @public
export type FleetMemberProvisioningState = string;

// @public
export interface FleetMemberStatus {
    readonly lastOperationError?: ErrorDetail;
    readonly lastOperationId?: string;
}

// @public
export interface FleetMemberUpdate {
    properties?: FleetMemberUpdateProperties;
}

// @public
export interface FleetMemberUpdateProperties {
    group?: string;
    labels?: Record<string, string>;
}

// @public
export interface FleetPatch {
    identity?: ManagedServiceIdentity;
    tags?: Record<string, string>;
}

// @public
export interface FleetProperties {
    hubProfile?: FleetHubProfile;
    readonly provisioningState?: FleetProvisioningState;
    readonly status?: FleetStatus;
}

// @public
export type FleetProvisioningState = string;

// @public
export interface FleetStatus {
    readonly lastOperationError?: ErrorDetail;
    readonly lastOperationId?: string;
}

// @public
export interface FleetUpdateStrategy extends ProxyResource {
    readonly eTag?: string;
    properties?: FleetUpdateStrategyProperties;
}

// @public
export interface FleetUpdateStrategyProperties {
    readonly provisioningState?: FleetUpdateStrategyProvisioningState;
    strategy: UpdateRunStrategy;
}

// @public
export type FleetUpdateStrategyProvisioningState = string;

// @public
export interface Gate extends ProxyResource {
    readonly eTag?: string;
    properties?: GateProperties;
}

// @public
export interface GateConfiguration {
    displayName?: string;
    type: GateType;
}

// @public
export interface GatePatch {
    properties: GatePatchProperties;
}

// @public
export interface GatePatchProperties {
    state: GateState;
}

// @public
export interface GateProperties {
    displayName?: string;
    gateType: GateType;
    readonly provisioningState?: GateProvisioningState;
    state: GateState;
    target: GateTarget;
}

// @public
export type GateProvisioningState = string;

// @public
export type GateState = string;

// @public
export interface GateTarget {
    id: string;
    updateRunProperties?: UpdateRunGateTargetProperties;
}

// @public
export type GateType = string;

// @public
export interface GenerateResponse {
    readonly id: string;
}

// @public
export enum KnownActionType {
    Internal = "Internal"
}

// @public
export enum KnownAdoptionPolicy {
    Always = "Always",
    IfIdentical = "IfIdentical",
    Never = "Never"
}

// @public
export enum KnownAutoUpgradeLastTriggerStatus {
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownAutoUpgradeNodeImageSelectionType {
    Consistent = "Consistent",
    Latest = "Latest"
}

// @public
export enum KnownAutoUpgradeProfileProvisioningState {
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDeletePolicy {
    Delete = "Delete",
    Keep = "Keep"
}

// @public
export enum KnownFleetManagedNamespaceProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownFleetMemberProvisioningState {
    Canceled = "Canceled",
    Failed = "Failed",
    Joining = "Joining",
    Leaving = "Leaving",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownFleetProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownFleetUpdateStrategyProvisioningState {
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownGateProvisioningState {
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownGateState {
    Completed = "Completed",
    Pending = "Pending",
    Skipped = "Skipped"
}

// @public
export enum KnownGateType {
    Approval = "Approval"
}

// @public
export enum KnownLabelSelectorOperator {
    DoesNotExist = "DoesNotExist",
    Exists = "Exists",
    In = "In",
    NotIn = "NotIn"
}

// @public
export enum KnownManagedClusterUpgradeType {
    ControlPlaneOnly = "ControlPlaneOnly",
    Full = "Full",
    NodeImageOnly = "NodeImageOnly"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAndUserAssigned = "SystemAssigned, UserAssigned",
    SystemAssigned = "SystemAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownNodeImageSelectionType {
    Consistent = "Consistent",
    Custom = "Custom",
    Latest = "Latest"
}

// @public
export enum KnownOrigin {
    System = "system",
    User = "user",
    UserSystem = "user,system"
}

// @public
export enum KnownPlacementType {
    PickAll = "PickAll",
    PickFixed = "PickFixed"
}

// @public
export enum KnownPolicyRule {
    AllowAll = "AllowAll",
    AllowSameNamespace = "AllowSameNamespace",
    DenyAll = "DenyAll"
}

// @public
export enum KnownPropagationType {
    Placement = "Placement"
}

// @public
export enum KnownPropertySelectorOperator {
    Eq = "Eq",
    Ge = "Ge",
    Gt = "Gt",
    Le = "Le",
    Lt = "Lt",
    Ne = "Ne"
}

// @public
export enum KnownTaintEffect {
    NoSchedule = "NoSchedule"
}

// @public
export enum KnownTargetType {
    AfterStageWait = "AfterStageWait",
    Group = "Group",
    Member = "Member",
    Stage = "Stage"
}

// @public
export enum KnownTiming {
    After = "After",
    Before = "Before"
}

// @public
export enum KnownTolerationOperator {
    Equal = "Equal",
    Exists = "Exists"
}

// @public
export enum KnownUpdateRunProvisioningState {
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownUpdateState {
    Completed = "Completed",
    Failed = "Failed",
    NotStarted = "NotStarted",
    Pending = "Pending",
    Running = "Running",
    Skipped = "Skipped",
    Stopped = "Stopped",
    Stopping = "Stopping"
}

// @public
export enum KnownUpgradeChannel {
    NodeImage = "NodeImage",
    Rapid = "Rapid",
    Stable = "Stable",
    TargetKubernetesVersion = "TargetKubernetesVersion"
}

// @public
export enum KnownVersions {
    V20220902Preview = "2022-09-02-preview",
    V20230315Preview = "2023-03-15-preview",
    V20230615Preview = "2023-06-15-preview",
    V20230815Preview = "2023-08-15-preview",
    V20231015 = "2023-10-15",
    V20240202Preview = "2024-02-02-preview",
    V20240401 = "2024-04-01",
    V20240502Preview = "2024-05-02-preview",
    V20250301 = "2025-03-01",
    V20250401Preview = "2025-04-01-preview",
    V20250801Preview = "2025-08-01-preview"
}

// @public
export interface LabelSelector {
    matchExpressions?: LabelSelectorRequirement[];
    matchLabels?: Record<string, string>;
}

// @public
export type LabelSelectorOperator = string;

// @public
export interface LabelSelectorRequirement {
    key: string;
    operator: LabelSelectorOperator;
    values?: string[];
}

// @public
export interface ManagedClusterUpdate {
    nodeImageSelection?: NodeImageSelection;
    upgrade: ManagedClusterUpgradeSpec;
}

// @public
export interface ManagedClusterUpgradeSpec {
    kubernetesVersion?: string;
    type: ManagedClusterUpgradeType;
}

// @public
export type ManagedClusterUpgradeType = string;

// @public
export interface ManagedNamespaceProperties {
    annotations?: Record<string, string>;
    defaultNetworkPolicy?: NetworkPolicy;
    defaultResourceQuota?: ResourceQuota;
    labels?: Record<string, string>;
}

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentity>;
}

// @public
export type ManagedServiceIdentityType = string;

// @public
export interface MemberUpdateStatus {
    readonly clusterResourceId?: string;
    readonly message?: string;
    readonly name?: string;
    readonly operationId?: string;
    readonly status?: UpdateStatus;
}

// @public
export interface NetworkPolicy {
    egress?: PolicyRule;
    ingress?: PolicyRule;
}

// @public
export interface NodeImageSelection {
    customNodeImageVersions?: NodeImageVersion[];
    type: NodeImageSelectionType;
}

// @public
export interface NodeImageSelectionStatus {
    readonly selectedNodeImageVersions?: NodeImageVersion[];
}

// @public
export type NodeImageSelectionType = string;

// @public
export interface NodeImageVersion {
    readonly version?: string;
}

// @public
export interface Operation {
    readonly actionType?: ActionType;
    display?: OperationDisplay;
    readonly isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: Origin;
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export type Origin = string;

// @public
export interface PlacementPolicy {
    affinity?: Affinity;
    clusterNames?: string[];
    placementType?: PlacementType;
    tolerations?: Toleration[];
}

// @public
export interface PlacementProfile {
    defaultClusterResourcePlacement?: ClusterResourcePlacementSpec;
}

// @public
export type PlacementType = string;

// @public
export type PolicyRule = string;

// @public
export interface PropagationPolicy {
    placementProfile?: PlacementProfile;
    type: PropagationType;
}

// @public
export type PropagationType = string;

// @public
export interface PropertySelector {
    matchExpressions: PropertySelectorRequirement[];
}

// @public
export type PropertySelectorOperator = string;

// @public
export interface PropertySelectorRequirement {
    name: string;
    operator: PropertySelectorOperator;
    values: string[];
}

// @public
export interface ProxyResource extends Resource {
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceQuota {
    cpuLimit?: string;
    cpuRequest?: string;
    memoryLimit?: string;
    memoryRequest?: string;
}

// @public
export interface SkipProperties {
    targets: SkipTarget[];
}

// @public
export interface SkipTarget {
    name: string;
    type: TargetType;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export type TaintEffect = string;

// @public
export type TargetType = string;

// @public
export type Timing = string;

// @public
export interface Toleration {
    effect?: TaintEffect;
    key?: string;
    operator?: TolerationOperator;
    value?: string;
}

// @public
export type TolerationOperator = string;

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export interface UpdateGroup {
    afterGates?: GateConfiguration[];
    beforeGates?: GateConfiguration[];
    name: string;
}

// @public
export interface UpdateGroupStatus {
    readonly afterGates?: UpdateRunGateStatus[];
    readonly beforeGates?: UpdateRunGateStatus[];
    readonly members?: MemberUpdateStatus[];
    readonly name?: string;
    readonly status?: UpdateStatus;
}

// @public
export interface UpdateRun extends ProxyResource {
    readonly eTag?: string;
    properties?: UpdateRunProperties;
}

// @public
export interface UpdateRunGateStatus {
    readonly displayName?: string;
    readonly gateId?: string;
    readonly status?: UpdateStatus;
}

// @public
export interface UpdateRunGateTargetProperties {
    readonly group?: string;
    readonly name: string;
    readonly stage?: string;
    timing: Timing;
}

// @public
export interface UpdateRunProperties {
    readonly autoUpgradeProfileId?: string;
    managedClusterUpdate: ManagedClusterUpdate;
    readonly provisioningState?: UpdateRunProvisioningState;
    readonly status?: UpdateRunStatus;
    strategy?: UpdateRunStrategy;
    updateStrategyId?: string;
}

// @public
export type UpdateRunProvisioningState = string;

// @public
export interface UpdateRunStatus {
    readonly nodeImageSelection?: NodeImageSelectionStatus;
    readonly stages?: UpdateStageStatus[];
    readonly status?: UpdateStatus;
}

// @public
export interface UpdateRunStrategy {
    stages: UpdateStage[];
}

// @public
export interface UpdateStage {
    afterGates?: GateConfiguration[];
    afterStageWaitInSeconds?: number;
    beforeGates?: GateConfiguration[];
    groups?: UpdateGroup[];
    name: string;
}

// @public
export interface UpdateStageStatus {
    readonly afterGates?: UpdateRunGateStatus[];
    readonly afterStageWaitStatus?: WaitStatus;
    readonly beforeGates?: UpdateRunGateStatus[];
    readonly groups?: UpdateGroupStatus[];
    readonly name?: string;
    readonly status?: UpdateStatus;
}

// @public
export type UpdateState = string;

// @public
export interface UpdateStatus {
    readonly completedTime?: Date;
    readonly error?: ErrorDetail;
    readonly startTime?: Date;
    readonly state?: UpdateState;
}

// @public
export type UpgradeChannel = string;

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface WaitStatus {
    readonly status?: UpdateStatus;
    readonly waitDurationInSeconds?: number;
}

// (No @packageDocumentation comment for this package)

```
