## API Report File for "@azure/arm-containerservice"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import type { CancelOnProgress } from '@azure/core-lro';
import type { ClientOptions } from '@azure-rest/core-client';
import type { OperationOptions } from '@azure-rest/core-client';
import type { OperationState } from '@azure/core-lro';
import type { PathUncheckedResponse } from '@azure-rest/core-client';
import type { Pipeline } from '@azure/core-rest-pipeline';
import type { PollerLike } from '@azure/core-lro';
import type { TokenCredential } from '@azure/core-auth';

// @public
export interface AbsoluteMonthlySchedule {
    dayOfMonth: number;
    intervalMonths: number;
}

// @public
export type AccelerationMode = string;

// @public
export interface AccessProfile {
    kubeConfig?: Uint8Array;
}

// @public
export type AddonAutoscaling = string;

// @public
export type AdoptionPolicy = string;

// @public
export interface AdvancedNetworking {
    enabled?: boolean;
    observability?: AdvancedNetworkingObservability;
    performance?: AdvancedNetworkingPerformance;
    security?: AdvancedNetworkingSecurity;
}

// @public
export interface AdvancedNetworkingObservability {
    enabled?: boolean;
}

// @public
export interface AdvancedNetworkingPerformance {
    accelerationMode?: AccelerationMode;
}

// @public
export interface AdvancedNetworkingSecurity {
    advancedNetworkPolicies?: AdvancedNetworkPolicies;
    enabled?: boolean;
    transitEncryption?: AdvancedNetworkingSecurityTransitEncryption;
}

// @public
export interface AdvancedNetworkingSecurityTransitEncryption {
    type?: TransitEncryptionType;
}

// @public
export type AdvancedNetworkPolicies = string;

// @public
export interface AgentPool extends ProxyResource {
    artifactStreamingProfile?: AgentPoolArtifactStreamingProfile;
    availabilityZones?: string[];
    capacityReservationGroupID?: string;
    count?: number;
    creationData?: CreationData;
    readonly currentOrchestratorVersion?: string;
    enableAutoScaling?: boolean;
    enableEncryptionAtHost?: boolean;
    enableFips?: boolean;
    enableNodePublicIP?: boolean;
    enableUltraSSD?: boolean;
    readonly eTag?: string;
    gatewayProfile?: AgentPoolGatewayProfile;
    gpuInstanceProfile?: GPUInstanceProfile;
    gpuProfile?: GPUProfile;
    hostGroupID?: string;
    kubeletConfig?: KubeletConfig;
    kubeletDiskType?: KubeletDiskType;
    linuxOSConfig?: LinuxOSConfig;
    localDNSProfile?: LocalDNSProfile;
    maxCount?: number;
    maxPods?: number;
    messageOfTheDay?: string;
    minCount?: number;
    mode?: AgentPoolMode;
    networkProfile?: AgentPoolNetworkProfile;
    nodeCustomizationProfile?: NodeCustomizationProfile;
    readonly nodeImageVersion?: string;
    nodeInitializationTaints?: string[];
    nodeLabels?: Record<string, string>;
    nodePublicIPPrefixID?: string;
    nodeTaints?: string[];
    orchestratorVersion?: string;
    osDiskSizeGB?: number;
    osDiskType?: OSDiskType;
    osSKU?: Ossku;
    osType?: OSType;
    podIPAllocationMode?: PodIPAllocationMode;
    podSubnetID?: string;
    powerState?: PowerState;
    readonly provisioningState?: string;
    proximityPlacementGroupID?: string;
    scaleDownMode?: ScaleDownMode;
    scaleSetEvictionPolicy?: ScaleSetEvictionPolicy;
    scaleSetPriority?: ScaleSetPriority;
    securityProfile?: AgentPoolSecurityProfile;
    spotMaxPrice?: number;
    status?: AgentPoolStatus;
    tags?: Record<string, string>;
    typePropertiesType?: AgentPoolType;
    upgradeSettings?: AgentPoolUpgradeSettings;
    upgradeSettingsBlueGreen?: AgentPoolBlueGreenUpgradeSettings;
    upgradeStrategy?: UpgradeStrategy;
    virtualMachineNodesStatus?: VirtualMachineNodes[];
    virtualMachinesProfile?: VirtualMachinesProfile;
    vmSize?: string;
    vnetSubnetID?: string;
    windowsProfile?: AgentPoolWindowsProfile;
    workloadRuntime?: WorkloadRuntime;
}

// @public
export interface AgentPoolArtifactStreamingProfile {
    enabled?: boolean;
}

// @public
export interface AgentPoolAvailableVersions {
    agentPoolVersions?: AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem[];
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface AgentPoolAvailableVersionsProperties {
    agentPoolVersions?: AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem[];
}

// @public
export interface AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem {
    default?: boolean;
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface AgentPoolBlueGreenUpgradeSettings {
    batchSoakDurationInMinutes?: number;
    drainBatchSize?: string;
    drainTimeoutInMinutes?: number;
    finalSoakDurationInMinutes?: number;
}

// @public
export interface AgentPoolDeleteMachinesParameter {
    machineNames: string[];
}

// @public
export interface AgentPoolGatewayProfile {
    publicIPPrefixSize?: number;
}

// @public
export type AgentPoolMode = string;

// @public
export interface AgentPoolNetworkProfile {
    allowedHostPorts?: PortRange[];
    applicationSecurityGroups?: string[];
    nodePublicIPTags?: IPTag[];
}

// @public
export interface AgentPoolRecentlyUsedVersion {
    nodeImageVersion?: string;
    orchestratorVersion?: string;
    timestamp?: Date;
}

// @public
export interface AgentPoolsAbortLatestOperationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface AgentPoolsCompleteUpgradeOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface AgentPoolsCreateOrUpdateOptionalParams extends OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    updateIntervalInMs?: number;
}

// @public
export interface AgentPoolsDeleteMachinesOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface AgentPoolsDeleteOptionalParams extends OperationOptions {
    ifMatch?: string;
    ignorePodDisruptionBudget?: boolean;
    updateIntervalInMs?: number;
}

// @public
export interface AgentPoolSecurityProfile {
    enableSecureBoot?: boolean;
    enableVtpm?: boolean;
    sshAccess?: AgentPoolSSHAccess;
}

// @public
export interface AgentPoolsGetAvailableAgentPoolVersionsOptionalParams extends OperationOptions {
}

// @public
export interface AgentPoolsGetOptionalParams extends OperationOptions {
}

// @public
export interface AgentPoolsGetUpgradeProfileOptionalParams extends OperationOptions {
}

// @public
export interface AgentPoolsListOptionalParams extends OperationOptions {
}

// @public
export interface AgentPoolsOperations {
    abortLatestOperation: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsAbortLatestOperationOptionalParams) => PollerLike<OperationState<void>, void>;
    // @deprecated (undocumented)
    beginAbortLatestOperation: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsAbortLatestOperationOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginAbortLatestOperationAndWait: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsAbortLatestOperationOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginCompleteUpgrade: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsCompleteUpgradeOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginCompleteUpgradeAndWait: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsCompleteUpgradeOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginCreateOrUpdate: (resourceGroupName: string, resourceName: string, agentPoolName: string, parameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams) => Promise<SimplePollerLike<OperationState<AgentPool>, AgentPool>>;
    // @deprecated (undocumented)
    beginCreateOrUpdateAndWait: (resourceGroupName: string, resourceName: string, agentPoolName: string, parameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams) => Promise<AgentPool>;
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginDeleteMachines: (resourceGroupName: string, resourceName: string, agentPoolName: string, machines: AgentPoolDeleteMachinesParameter, options?: AgentPoolsDeleteMachinesOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteMachinesAndWait: (resourceGroupName: string, resourceName: string, agentPoolName: string, machines: AgentPoolDeleteMachinesParameter, options?: AgentPoolsDeleteMachinesOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginUpgradeNodeImageVersion: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsUpgradeNodeImageVersionOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginUpgradeNodeImageVersionAndWait: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsUpgradeNodeImageVersionOptionalParams) => Promise<void>;
    completeUpgrade: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsCompleteUpgradeOptionalParams) => PollerLike<OperationState<void>, void>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, agentPoolName: string, parameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams) => PollerLike<OperationState<AgentPool>, AgentPool>;
    delete: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    deleteMachines: (resourceGroupName: string, resourceName: string, agentPoolName: string, machines: AgentPoolDeleteMachinesParameter, options?: AgentPoolsDeleteMachinesOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsGetOptionalParams) => Promise<AgentPool>;
    getAvailableAgentPoolVersions: (resourceGroupName: string, resourceName: string, options?: AgentPoolsGetAvailableAgentPoolVersionsOptionalParams) => Promise<AgentPoolAvailableVersions>;
    getUpgradeProfile: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsGetUpgradeProfileOptionalParams) => Promise<AgentPoolUpgradeProfile>;
    list: (resourceGroupName: string, resourceName: string, options?: AgentPoolsListOptionalParams) => PagedAsyncIterableIterator<AgentPool>;
    upgradeNodeImageVersion: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsUpgradeNodeImageVersionOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export type AgentPoolSSHAccess = string;

// @public
export interface AgentPoolStatus {
    readonly provisioningError?: ErrorDetail;
}

// @public
export interface AgentPoolsUpgradeNodeImageVersionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolType = string;

// @public
export interface AgentPoolUpgradeProfile extends ProxyResource {
    componentsByReleases?: ComponentsByRelease[];
    kubernetesVersion: string;
    latestNodeImageVersion?: string;
    osType: OSType;
    readonly recentlyUsedVersions?: AgentPoolRecentlyUsedVersion[];
    upgrades?: AgentPoolUpgradeProfilePropertiesUpgradesItem[];
}

// @public
export interface AgentPoolUpgradeProfileProperties {
    componentsByReleases?: ComponentsByRelease[];
    kubernetesVersion: string;
    latestNodeImageVersion?: string;
    osType: OSType;
    readonly recentlyUsedVersions?: AgentPoolRecentlyUsedVersion[];
    upgrades?: AgentPoolUpgradeProfilePropertiesUpgradesItem[];
}

// @public
export interface AgentPoolUpgradeProfilePropertiesUpgradesItem {
    isOutOfSupport?: boolean;
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface AgentPoolUpgradeSettings {
    drainTimeoutInMinutes?: number;
    maxBlockedNodes?: string;
    maxSurge?: string;
    maxUnavailable?: string;
    nodeSoakDurationInMinutes?: number;
    undrainableNodeBehavior?: UndrainableNodeBehavior;
}

// @public
export interface AgentPoolWindowsProfile {
    disableOutboundNat?: boolean;
}

// @public
export type ArtifactSource = string;

// @public
export interface AutoScaleProfile {
    maxCount?: number;
    minCount?: number;
    size?: string;
}

// @public
export enum AzureClouds {
    AZURE_CHINA_CLOUD = "AZURE_CHINA_CLOUD",
    AZURE_PUBLIC_CLOUD = "AZURE_PUBLIC_CLOUD",
    AZURE_US_GOVERNMENT = "AZURE_US_GOVERNMENT"
}

// @public
export interface AzureKeyVaultKms {
    enabled?: boolean;
    keyId?: string;
    keyVaultNetworkAccess?: KeyVaultNetworkAccessTypes;
    keyVaultResourceId?: string;
}

// @public
export type AzureSupportedClouds = `${AzureClouds}`;

// @public
export type BackendPoolType = string;

// @public
export type ClusterServiceLoadBalancerHealthProbeMode = string;

// @public
export interface ClusterUpgradeSettings {
    overrideSettings?: UpgradeOverrideSettings;
}

// @public
export type Code = string;

// @public
export interface CommandResultProperties {
    readonly exitCode?: number;
    readonly finishedAt?: Date;
    readonly logs?: string;
    readonly provisioningState?: string;
    readonly reason?: string;
    readonly startedAt?: Date;
}

// @public
export interface CompatibleVersions {
    name?: string;
    versions?: string[];
}

// @public
export interface Component {
    hasBreakingChanges?: boolean;
    name?: string;
    version?: string;
}

// @public
export interface ComponentsByRelease {
    components?: Component[];
    kubernetesVersion?: string;
}

// @public
export type ConnectionStatus = string;

// @public (undocumented)
export class ContainerServiceClient {
    constructor(credential: TokenCredential, options?: ContainerServiceClientOptionalParams);
    constructor(credential: TokenCredential, subscriptionId: string, options?: ContainerServiceClientOptionalParams);
    readonly agentPools: AgentPoolsOperations;
    readonly containerService: ContainerServiceOperations;
    readonly identityBindings: IdentityBindingsOperations;
    readonly jwtAuthenticators: JWTAuthenticatorsOperations;
    readonly loadBalancers: LoadBalancersOperations;
    readonly machines: MachinesOperations;
    readonly maintenanceConfigurations: MaintenanceConfigurationsOperations;
    readonly managedClusters: ManagedClustersOperations;
    readonly managedClusterSnapshots: ManagedClusterSnapshotsOperations;
    readonly managedNamespaces: ManagedNamespacesOperations;
    readonly meshMemberships: MeshMembershipsOperations;
    readonly operations: OperationsOperations;
    readonly operationStatusResult: OperationStatusResultOperations;
    readonly pipeline: Pipeline;
    readonly privateEndpointConnections: PrivateEndpointConnectionsOperations;
    readonly privateLinkResources: PrivateLinkResourcesOperations;
    readonly resolvePrivateLinkServiceId: ResolvePrivateLinkServiceIdOperations;
    readonly snapshots: SnapshotsOperations;
    readonly trustedAccessRoleBindings: TrustedAccessRoleBindingsOperations;
    readonly trustedAccessRoles: TrustedAccessRolesOperations;
}

// @public
export interface ContainerServiceClientOptionalParams extends ClientOptions {
    apiVersion?: string;
    cloudSetting?: AzureSupportedClouds;
}

// @public
export interface ContainerServiceLinuxProfile {
    adminUsername: string;
    ssh: ContainerServiceSshConfiguration;
}

// @public
export interface ContainerServiceListNodeImageVersionsOptionalParams extends OperationOptions {
}

// @public
export interface ContainerServiceNetworkProfile {
    advancedNetworking?: AdvancedNetworking;
    dnsServiceIP?: string;
    ipFamilies?: IpFamily[];
    kubeProxyConfig?: ContainerServiceNetworkProfileKubeProxyConfig;
    loadBalancerProfile?: ManagedClusterLoadBalancerProfile;
    loadBalancerSku?: LoadBalancerSku;
    natGatewayProfile?: ManagedClusterNATGatewayProfile;
    networkDataplane?: NetworkDataplane;
    networkMode?: NetworkMode;
    networkPlugin?: NetworkPlugin;
    networkPluginMode?: NetworkPluginMode;
    networkPolicy?: NetworkPolicy;
    outboundType?: OutboundType;
    podCidr?: string;
    podCidrs?: string[];
    podLinkLocalAccess?: PodLinkLocalAccess;
    serviceCidr?: string;
    serviceCidrs?: string[];
    staticEgressGatewayProfile?: ManagedClusterStaticEgressGatewayProfile;
}

// @public
export interface ContainerServiceNetworkProfileKubeProxyConfig {
    enabled?: boolean;
    ipvsConfig?: ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig;
    mode?: Mode;
}

// @public
export interface ContainerServiceNetworkProfileKubeProxyConfigIpvsConfig {
    scheduler?: IpvsScheduler;
    tcpFinTimeoutSeconds?: number;
    tcpTimeoutSeconds?: number;
    udpTimeoutSeconds?: number;
}

// @public
export interface ContainerServiceOperations {
    listNodeImageVersions: (location: string, options?: ContainerServiceListNodeImageVersionsOptionalParams) => PagedAsyncIterableIterator<NodeImageVersion>;
}

// @public
export interface ContainerServiceSshConfiguration {
    publicKeys: ContainerServiceSshPublicKey[];
}

// @public
export interface ContainerServiceSshPublicKey {
    keyData: string;
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export type CreatedByType = string;

// @public
export interface CreationData {
    sourceResourceId?: string;
}

// @public
export interface CredentialResult {
    readonly name?: string;
    readonly value?: Uint8Array;
}

// @public
export interface CredentialResults {
    readonly kubeconfigs?: CredentialResult[];
}

// @public
export interface DailySchedule {
    intervalDays: number;
}

// @public
export interface DateSpan {
    end: Date;
    start: Date;
}

// @public
export interface DelegatedResource {
    location?: string;
    referralResource?: string;
    resourceId?: string;
    tenantId?: string;
}

// @public
export type DeletePolicy = string;

// @public
export type DriftAction = string;

// @public
export type DriverType = string;

// @public
export interface EndpointDependency {
    domainName?: string;
    endpointDetails?: EndpointDetail[];
}

// @public
export interface EndpointDetail {
    description?: string;
    ipAddress?: string;
    port?: number;
    protocol?: string;
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: any;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export type Expander = string;

// @public
export interface ExtendedLocation {
    name?: string;
    type?: ExtendedLocationTypes;
}

// @public
export type ExtendedLocationTypes = string;

// @public
export type Format = string;

// @public
export type GPUDriver = string;

// @public
export type GPUInstanceProfile = string;

// @public
export interface GPUProfile {
    driver?: GPUDriver;
    driverType?: DriverType;
}

// @public
export interface GuardrailsAvailableVersion extends ProxyResource {
    properties: GuardrailsAvailableVersionsProperties;
}

// @public
export interface GuardrailsAvailableVersionsProperties {
    // (undocumented)
    readonly isDefaultVersion?: boolean;
    readonly support?: GuardrailsSupport;
}

// @public
export type GuardrailsSupport = string;

// @public
export interface IdentityBinding extends ProxyResource {
    readonly eTag?: string;
    properties?: IdentityBindingProperties;
}

// @public
export interface IdentityBindingManagedIdentityProfile {
    readonly clientId?: string;
    readonly objectId?: string;
    resourceId: string;
    readonly tenantId?: string;
}

// @public
export interface IdentityBindingOidcIssuerProfile {
    readonly oidcIssuerUrl?: string;
}

// @public
export interface IdentityBindingProperties {
    managedIdentity: IdentityBindingManagedIdentityProfile;
    readonly oidcIssuer?: IdentityBindingOidcIssuerProfile;
    readonly provisioningState?: IdentityBindingProvisioningState;
}

// @public
export type IdentityBindingProvisioningState = string;

// @public
export interface IdentityBindingsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface IdentityBindingsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface IdentityBindingsGetOptionalParams extends OperationOptions {
}

// @public
export interface IdentityBindingsListByManagedClusterOptionalParams extends OperationOptions {
}

// @public
export interface IdentityBindingsOperations {
    // @deprecated (undocumented)
    beginCreateOrUpdate: (resourceGroupName: string, resourceName: string, identityBindingName: string, parameters: IdentityBinding, options?: IdentityBindingsCreateOrUpdateOptionalParams) => Promise<SimplePollerLike<OperationState<IdentityBinding>, IdentityBinding>>;
    // @deprecated (undocumented)
    beginCreateOrUpdateAndWait: (resourceGroupName: string, resourceName: string, identityBindingName: string, parameters: IdentityBinding, options?: IdentityBindingsCreateOrUpdateOptionalParams) => Promise<IdentityBinding>;
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, identityBindingName: string, options?: IdentityBindingsDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, identityBindingName: string, options?: IdentityBindingsDeleteOptionalParams) => Promise<void>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, identityBindingName: string, parameters: IdentityBinding, options?: IdentityBindingsCreateOrUpdateOptionalParams) => PollerLike<OperationState<IdentityBinding>, IdentityBinding>;
    delete: (resourceGroupName: string, resourceName: string, identityBindingName: string, options?: IdentityBindingsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, identityBindingName: string, options?: IdentityBindingsGetOptionalParams) => Promise<IdentityBinding>;
    listByManagedCluster: (resourceGroupName: string, resourceName: string, options?: IdentityBindingsListByManagedClusterOptionalParams) => PagedAsyncIterableIterator<IdentityBinding>;
}

// @public
export type InfrastructureEncryption = string;

// @public
export type IpFamily = string;

// @public
export interface IPTag {
    ipTagType?: string;
    tag?: string;
}

// @public
export type IpvsScheduler = string;

// @public
export interface IstioCertificateAuthority {
    plugin?: IstioPluginCertificateAuthority;
}

// @public
export interface IstioComponents {
    egressGateways?: IstioEgressGateway[];
    ingressGateways?: IstioIngressGateway[];
    proxyRedirectionMechanism?: ProxyRedirectionMechanism;
}

// @public
export interface IstioEgressGateway {
    enabled: boolean;
    gatewayConfigurationName?: string;
    name: string;
    namespace?: string;
}

// @public
export interface IstioIngressGateway {
    enabled: boolean;
    mode: IstioIngressGatewayMode;
}

// @public
export type IstioIngressGatewayMode = string;

// @public
export interface IstioPluginCertificateAuthority {
    certChainObjectName?: string;
    certObjectName?: string;
    keyObjectName?: string;
    keyVaultId?: string;
    rootCertObjectName?: string;
}

// @public
export interface IstioServiceMesh {
    certificateAuthority?: IstioCertificateAuthority;
    components?: IstioComponents;
    revisions?: string[];
}

// @public
export interface JWTAuthenticator extends ProxyResource {
    properties: JWTAuthenticatorProperties;
}

// @public
export interface JWTAuthenticatorClaimMappingExpression {
    expression: string;
}

// @public
export interface JWTAuthenticatorClaimMappings {
    extra?: JWTAuthenticatorExtraClaimMappingExpression[];
    groups?: JWTAuthenticatorClaimMappingExpression;
    uid?: JWTAuthenticatorClaimMappingExpression;
    username: JWTAuthenticatorClaimMappingExpression;
}

// @public
export interface JWTAuthenticatorExtraClaimMappingExpression {
    key: string;
    valueExpression: string;
}

// @public
export interface JWTAuthenticatorIssuer {
    audiences: string[];
    url: string;
}

// @public
export interface JWTAuthenticatorProperties {
    claimMappings: JWTAuthenticatorClaimMappings;
    claimValidationRules?: JWTAuthenticatorValidationRule[];
    issuer: JWTAuthenticatorIssuer;
    readonly provisioningState?: JWTAuthenticatorProvisioningState;
    userValidationRules?: JWTAuthenticatorValidationRule[];
}

// @public
export type JWTAuthenticatorProvisioningState = string;

// @public
export interface JWTAuthenticatorsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface JWTAuthenticatorsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface JWTAuthenticatorsGetOptionalParams extends OperationOptions {
}

// @public
export interface JWTAuthenticatorsListByManagedClusterOptionalParams extends OperationOptions {
}

// @public
export interface JWTAuthenticatorsOperations {
    // @deprecated (undocumented)
    beginCreateOrUpdate: (resourceGroupName: string, resourceName: string, jwtAuthenticatorName: string, parameters: JWTAuthenticator, options?: JWTAuthenticatorsCreateOrUpdateOptionalParams) => Promise<SimplePollerLike<OperationState<JWTAuthenticator>, JWTAuthenticator>>;
    // @deprecated (undocumented)
    beginCreateOrUpdateAndWait: (resourceGroupName: string, resourceName: string, jwtAuthenticatorName: string, parameters: JWTAuthenticator, options?: JWTAuthenticatorsCreateOrUpdateOptionalParams) => Promise<JWTAuthenticator>;
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, jwtAuthenticatorName: string, options?: JWTAuthenticatorsDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, jwtAuthenticatorName: string, options?: JWTAuthenticatorsDeleteOptionalParams) => Promise<void>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, jwtAuthenticatorName: string, parameters: JWTAuthenticator, options?: JWTAuthenticatorsCreateOrUpdateOptionalParams) => PollerLike<OperationState<JWTAuthenticator>, JWTAuthenticator>;
    delete: (resourceGroupName: string, resourceName: string, jwtAuthenticatorName: string, options?: JWTAuthenticatorsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, jwtAuthenticatorName: string, options?: JWTAuthenticatorsGetOptionalParams) => Promise<JWTAuthenticator>;
    listByManagedCluster: (resourceGroupName: string, resourceName: string, options?: JWTAuthenticatorsListByManagedClusterOptionalParams) => PagedAsyncIterableIterator<JWTAuthenticator>;
}

// @public
export interface JWTAuthenticatorValidationRule {
    expression: string;
    message?: string;
}

// @public
export type KeyVaultNetworkAccessTypes = string;

// @public
export enum KnownAccelerationMode {
    BpfVeth = "BpfVeth",
    None = "None"
}

// @public
export enum KnownAddonAutoscaling {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownAdoptionPolicy {
    Always = "Always",
    IfIdentical = "IfIdentical",
    Never = "Never"
}

// @public
export enum KnownAdvancedNetworkPolicies {
    Fqdn = "FQDN",
    L7 = "L7",
    None = "None"
}

// @public
export enum KnownAgentPoolMode {
    Gateway = "Gateway",
    Machines = "Machines",
    ManagedSystem = "ManagedSystem",
    System = "System",
    User = "User"
}

// @public
export enum KnownAgentPoolSSHAccess {
    Disabled = "Disabled",
    EntraId = "EntraId",
    LocalUser = "LocalUser"
}

// @public
export enum KnownAgentPoolType {
    AvailabilitySet = "AvailabilitySet",
    VirtualMachines = "VirtualMachines",
    VirtualMachineScaleSets = "VirtualMachineScaleSets"
}

// @public
export enum KnownArtifactSource {
    Cache = "Cache",
    Direct = "Direct"
}

// @public
export enum KnownBackendPoolType {
    NodeIP = "NodeIP",
    NodeIPConfiguration = "NodeIPConfiguration"
}

// @public
export enum KnownClusterServiceLoadBalancerHealthProbeMode {
    ServiceNodePort = "ServiceNodePort",
    Shared = "Shared"
}

// @public
export enum KnownCode {
    Running = "Running",
    Stopped = "Stopped"
}

// @public
export enum KnownConnectionStatus {
    Approved = "Approved",
    Disconnected = "Disconnected",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDeletePolicy {
    Delete = "Delete",
    Keep = "Keep"
}

// @public
export enum KnownDriftAction {
    Recreate = "Recreate",
    Synced = "Synced"
}

// @public
export enum KnownDriverType {
    Cuda = "CUDA",
    Grid = "GRID"
}

// @public
export enum KnownExpander {
    LeastWaste = "least-waste",
    MostPods = "most-pods",
    Priority = "priority",
    Random = "random"
}

// @public
export enum KnownExtendedLocationTypes {
    EdgeZone = "EdgeZone"
}

// @public
export enum KnownFormat {
    Azure = "azure",
    Exec = "exec"
}

// @public
export enum KnownGPUDriver {
    Install = "Install",
    None = "None"
}

// @public
export enum KnownGPUInstanceProfile {
    MIG1G = "MIG1g",
    MIG2G = "MIG2g",
    MIG3G = "MIG3g",
    MIG4G = "MIG4g",
    MIG7G = "MIG7g"
}

// @public
export enum KnownGuardrailsSupport {
    Preview = "Preview",
    Stable = "Stable"
}

// @public
export enum KnownIdentityBindingProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownInfrastructureEncryption {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownIpFamily {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownIpvsScheduler {
    LeastConnection = "LeastConnection",
    RoundRobin = "RoundRobin"
}

// @public
export enum KnownIstioIngressGatewayMode {
    External = "External",
    Internal = "Internal"
}

// @public
export enum KnownJWTAuthenticatorProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownKeyVaultNetworkAccessTypes {
    Private = "Private",
    Public = "Public"
}

// @public
export enum KnownKubeletDiskType {
    OS = "OS",
    Temporary = "Temporary"
}

// @public
export enum KnownKubernetesSupportPlan {
    AKSLongTermSupport = "AKSLongTermSupport",
    KubernetesOfficial = "KubernetesOfficial"
}

// @public
export enum KnownLicenseType {
    None = "None",
    WindowsServer = "Windows_Server"
}

// @public
export enum KnownLoadBalancerSku {
    Basic = "basic",
    Standard = "standard"
}

// @public
export enum KnownLocalDNSForwardDestination {
    ClusterCoreDNS = "ClusterCoreDNS",
    VnetDNS = "VnetDNS"
}

// @public
export enum KnownLocalDNSForwardPolicy {
    Random = "Random",
    RoundRobin = "RoundRobin",
    Sequential = "Sequential"
}

// @public
export enum KnownLocalDNSMode {
    Disabled = "Disabled",
    Preferred = "Preferred",
    Required = "Required"
}

// @public
export enum KnownLocalDNSProtocol {
    ForceTCP = "ForceTCP",
    PreferUDP = "PreferUDP"
}

// @public
export enum KnownLocalDNSQueryLogging {
    Error = "Error",
    Log = "Log"
}

// @public
export enum KnownLocalDNSServeStale {
    Disable = "Disable",
    Immediate = "Immediate",
    Verify = "Verify"
}

// @public
export enum KnownLocalDNSState {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownManagedClusterPodIdentityProvisioningState {
    Assigned = "Assigned",
    Canceled = "Canceled",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownManagedClusterSKUName {
    Automatic = "Automatic",
    Base = "Base"
}

// @public
export enum KnownManagedClusterSKUTier {
    Free = "Free",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownManagedGatewayType {
    Disabled = "Disabled",
    Standard = "Standard"
}

// @public
export enum KnownMeshMembershipProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownMode {
    Iptables = "IPTABLES",
    Ipvs = "IPVS",
    Nftables = "NFTABLES"
}

// @public
export enum KnownNamespaceProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownNetworkDataplane {
    Azure = "azure",
    Cilium = "cilium"
}

// @public
export enum KnownNetworkMode {
    Bridge = "bridge",
    Transparent = "transparent"
}

// @public
export enum KnownNetworkPlugin {
    Azure = "azure",
    Kubenet = "kubenet",
    None = "none"
}

// @public
export enum KnownNetworkPluginMode {
    Overlay = "overlay"
}

// @public
export enum KnownNetworkPolicy {
    Azure = "azure",
    Calico = "calico",
    Cilium = "cilium",
    None = "none"
}

// @public
export enum KnownNginxIngressControllerType {
    AnnotationControlled = "AnnotationControlled",
    External = "External",
    Internal = "Internal",
    None = "None"
}

// @public
export enum KnownNodeOSUpgradeChannel {
    NodeImage = "NodeImage",
    None = "None",
    SecurityPatch = "SecurityPatch",
    Unmanaged = "Unmanaged"
}

// @public
export enum KnownNodeProvisioningDefaultNodePools {
    Auto = "Auto",
    None = "None"
}

// @public
export enum KnownNodeProvisioningMode {
    Auto = "Auto",
    Manual = "Manual"
}

// @public
export enum KnownOperator {
    DoesNotExist = "DoesNotExist",
    Exists = "Exists",
    In = "In",
    NotIn = "NotIn"
}

// @public
export enum KnownOSDiskType {
    Ephemeral = "Ephemeral",
    Managed = "Managed"
}

// @public
export enum KnownOssku {
    AzureLinux = "AzureLinux",
    AzureLinux3 = "AzureLinux3",
    CBLMariner = "CBLMariner",
    Flatcar = "Flatcar",
    Mariner = "Mariner",
    Ubuntu = "Ubuntu",
    Ubuntu2204 = "Ubuntu2204",
    Ubuntu2404 = "Ubuntu2404",
    Windows2019 = "Windows2019",
    Windows2022 = "Windows2022",
    Windows2025 = "Windows2025",
    WindowsAnnual = "WindowsAnnual"
}

// @public
export enum KnownOSType {
    Linux = "Linux",
    Windows = "Windows"
}

// @public
export enum KnownOutboundType {
    LoadBalancer = "loadBalancer",
    ManagedNATGateway = "managedNATGateway",
    None = "none",
    UserAssignedNATGateway = "userAssignedNATGateway",
    UserDefinedRouting = "userDefinedRouting"
}

// @public
export enum KnownPodIPAllocationMode {
    DynamicIndividual = "DynamicIndividual",
    StaticBlock = "StaticBlock"
}

// @public
export enum KnownPodLinkLocalAccess {
    Imds = "IMDS",
    None = "None"
}

// @public
export enum KnownPolicyRule {
    AllowAll = "AllowAll",
    AllowSameNamespace = "AllowSameNamespace",
    DenyAll = "DenyAll"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownProtocol {
    TCP = "TCP",
    UDP = "UDP"
}

// @public
export enum KnownProxyRedirectionMechanism {
    CNIChaining = "CNIChaining",
    InitContainers = "InitContainers"
}

// @public
export enum KnownPublicNetworkAccess {
    Disabled = "Disabled",
    Enabled = "Enabled",
    SecuredByPerimeter = "SecuredByPerimeter"
}

// @public
export enum KnownRestrictionLevel {
    ReadOnly = "ReadOnly",
    Unrestricted = "Unrestricted"
}

// @public
export enum KnownSafeguardsSupport {
    Preview = "Preview",
    Stable = "Stable"
}

// @public
export enum KnownScaleDownMode {
    Deallocate = "Deallocate",
    Delete = "Delete"
}

// @public
export enum KnownScaleSetEvictionPolicy {
    Deallocate = "Deallocate",
    Delete = "Delete"
}

// @public
export enum KnownScaleSetPriority {
    Regular = "Regular",
    Spot = "Spot"
}

// @public
export enum KnownSchedulerConfigMode {
    Default = "Default",
    ManagedByCRD = "ManagedByCRD"
}

// @public
export enum KnownSeccompDefault {
    RuntimeDefault = "RuntimeDefault",
    Unconfined = "Unconfined"
}

// @public
export enum KnownServiceMeshMode {
    Disabled = "Disabled",
    Istio = "Istio"
}

// @public
export enum KnownSnapshotType {
    ManagedCluster = "ManagedCluster",
    NodePool = "NodePool"
}

// @public
export enum KnownTransitEncryptionType {
    None = "None",
    WireGuard = "WireGuard"
}

// @public
export enum KnownTrustedAccessRoleBindingProvisioningState {
    Canceled = "Canceled",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownType {
    First = "First",
    Fourth = "Fourth",
    Last = "Last",
    Second = "Second",
    Third = "Third"
}

// @public
export enum KnownUndrainableNodeBehavior {
    Cordon = "Cordon",
    Schedule = "Schedule"
}

// @public
export enum KnownUpgradeChannel {
    NodeImage = "node-image",
    None = "none",
    Patch = "patch",
    Rapid = "rapid",
    Stable = "stable"
}

// @public
export enum KnownUpgradeStrategy {
    BlueGreen = "BlueGreen",
    Rolling = "Rolling"
}

// @public
export enum KnownVersions {
    V20251001 = "2025-10-01",
    V20251002Preview = "2025-10-02-preview"
}

// @public
export enum KnownVmState {
    Deleted = "Deleted",
    Running = "Running"
}

// @public
export enum KnownWeekDay {
    Friday = "Friday",
    Monday = "Monday",
    Saturday = "Saturday",
    Sunday = "Sunday",
    Thursday = "Thursday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday"
}

// @public
export enum KnownWorkloadRuntime {
    KataMshvVmIsolation = "KataMshvVmIsolation",
    KataVmIsolation = "KataVmIsolation",
    OCIContainer = "OCIContainer",
    WasmWasi = "WasmWasi"
}

// @public
export interface KubeletConfig {
    allowedUnsafeSysctls?: string[];
    containerLogMaxFiles?: number;
    containerLogMaxSizeMB?: number;
    cpuCfsQuota?: boolean;
    cpuCfsQuotaPeriod?: string;
    cpuManagerPolicy?: string;
    failSwapOn?: boolean;
    imageGcHighThreshold?: number;
    imageGcLowThreshold?: number;
    podMaxPids?: number;
    seccompDefault?: SeccompDefault;
    topologyManagerPolicy?: string;
}

// @public
export type KubeletDiskType = string;

// @public
export interface KubernetesPatchVersion {
    upgrades?: string[];
}

// @public
export interface KubernetesResourceObjectEncryptionProfile {
    infrastructureEncryption?: InfrastructureEncryption;
}

// @public
export type KubernetesSupportPlan = string;

// @public
export interface KubernetesVersion {
    capabilities?: KubernetesVersionCapabilities;
    isDefault?: boolean;
    isPreview?: boolean;
    patchVersions?: Record<string, KubernetesPatchVersion>;
    version?: string;
}

// @public
export interface KubernetesVersionCapabilities {
    // (undocumented)
    supportPlan?: KubernetesSupportPlan[];
}

// @public
export interface KubernetesVersionListResult {
    values?: KubernetesVersion[];
}

// @public
export interface LabelSelector {
    matchExpressions?: LabelSelectorRequirement[];
    matchLabels?: string[];
}

// @public
export interface LabelSelectorRequirement {
    key?: string;
    operator?: Operator;
    values?: string[];
}

// @public
export type LicenseType = string;

// @public
export interface LinuxOSConfig {
    swapFileSizeMB?: number;
    sysctls?: SysctlConfig;
    transparentHugePageDefrag?: string;
    transparentHugePageEnabled?: string;
}

// @public
export interface LoadBalancer extends ProxyResource {
    allowServicePlacement?: boolean;
    nodeSelector?: LabelSelector;
    primaryAgentPoolName?: string;
    readonly provisioningState?: string;
    serviceLabelSelector?: LabelSelector;
    serviceNamespaceSelector?: LabelSelector;
}

// @public
export interface LoadBalancerProperties {
    allowServicePlacement?: boolean;
    nodeSelector?: LabelSelector;
    primaryAgentPoolName: string;
    readonly provisioningState?: string;
    serviceLabelSelector?: LabelSelector;
    serviceNamespaceSelector?: LabelSelector;
}

// @public
export interface LoadBalancersCreateOrUpdateOptionalParams extends OperationOptions {
}

// @public
export interface LoadBalancersDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface LoadBalancersGetOptionalParams extends OperationOptions {
}

// @public
export type LoadBalancerSku = string;

// @public
export interface LoadBalancersListByManagedClusterOptionalParams extends OperationOptions {
}

// @public
export interface LoadBalancersOperations {
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, loadBalancerName: string, options?: LoadBalancersDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, loadBalancerName: string, options?: LoadBalancersDeleteOptionalParams) => Promise<void>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, loadBalancerName: string, parameters: LoadBalancer, options?: LoadBalancersCreateOrUpdateOptionalParams) => Promise<LoadBalancer>;
    delete: (resourceGroupName: string, resourceName: string, loadBalancerName: string, options?: LoadBalancersDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, loadBalancerName: string, options?: LoadBalancersGetOptionalParams) => Promise<LoadBalancer>;
    listByManagedCluster: (resourceGroupName: string, resourceName: string, options?: LoadBalancersListByManagedClusterOptionalParams) => PagedAsyncIterableIterator<LoadBalancer>;
}

// @public
export type LocalDNSForwardDestination = string;

// @public
export type LocalDNSForwardPolicy = string;

// @public
export type LocalDNSMode = string;

// @public
export interface LocalDNSOverride {
    cacheDurationInSeconds?: number;
    forwardDestination?: LocalDNSForwardDestination;
    forwardPolicy?: LocalDNSForwardPolicy;
    maxConcurrent?: number;
    protocol?: LocalDNSProtocol;
    queryLogging?: LocalDNSQueryLogging;
    serveStale?: LocalDNSServeStale;
    serveStaleDurationInSeconds?: number;
}

// @public
export interface LocalDNSProfile {
    kubeDNSOverrides?: Record<string, LocalDNSOverride>;
    mode?: LocalDNSMode;
    readonly state?: LocalDNSState;
    vnetDNSOverrides?: Record<string, LocalDNSOverride>;
}

// @public
export type LocalDNSProtocol = string;

// @public
export type LocalDNSQueryLogging = string;

// @public
export type LocalDNSServeStale = string;

// @public
export type LocalDNSState = string;

// @public
export interface Machine extends ProxyResource {
    properties?: MachineProperties;
    readonly zones?: string[];
}

// @public
export interface MachineHardwareProfile {
    gpuInstanceProfile?: GPUInstanceProfile;
    gpuProfile?: GPUProfile;
    vmSize?: string;
}

// @public
export interface MachineIpAddress {
    readonly family?: IpFamily;
    readonly ip?: string;
}

// @public
export interface MachineKubernetesProfile {
    artifactStreamingProfile?: AgentPoolArtifactStreamingProfile;
    readonly currentOrchestratorVersion?: string;
    kubeletConfig?: KubeletConfig;
    kubeletDiskType?: KubeletDiskType;
    maxPods?: number;
    nodeInitializationTaints?: string[];
    nodeLabels?: Record<string, string>;
    readonly nodeName?: string;
    nodeTaints?: string[];
    orchestratorVersion?: string;
    workloadRuntime?: WorkloadRuntime;
}

// @public
export interface MachineNetworkProperties {
    enableNodePublicIP?: boolean;
    readonly ipAddresses?: MachineIpAddress[];
    nodePublicIPPrefixID?: string;
    nodePublicIPTags?: IPTag[];
    podSubnetID?: string;
    vnetSubnetID?: string;
}

// @public
export interface MachineOSProfile {
    enableFips?: boolean;
    linuxProfile?: MachineOSProfileLinuxProfile;
    osDiskSizeGB?: number;
    osDiskType?: OSDiskType;
    osSKU?: Ossku;
    osType?: OSType;
    windowsProfile?: AgentPoolWindowsProfile;
}

// @public
export interface MachineOSProfileLinuxProfile {
    linuxOSConfig?: LinuxOSConfig;
    messageOfTheDay?: string;
}

// @public
export interface MachineProperties {
    readonly eTag?: string;
    hardware?: MachineHardwareProfile;
    kubernetes?: MachineKubernetesProfile;
    mode?: AgentPoolMode;
    readonly network?: MachineNetworkProperties;
    readonly nodeImageVersion?: string;
    operatingSystem?: MachineOSProfile;
    priority?: ScaleSetPriority;
    readonly provisioningState?: string;
    readonly resourceId?: string;
    security?: MachineSecurityProfile;
    readonly status?: MachineStatus;
    tags?: Record<string, string>;
}

// @public
export interface MachinesCreateOrUpdateOptionalParams extends OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    updateIntervalInMs?: number;
}

// @public
export interface MachineSecurityProfile {
    enableEncryptionAtHost?: boolean;
    enableSecureBoot?: boolean;
    enableVtpm?: boolean;
    sshAccess?: AgentPoolSSHAccess;
}

// @public
export interface MachinesGetOptionalParams extends OperationOptions {
}

// @public
export interface MachinesListOptionalParams extends OperationOptions {
}

// @public
export interface MachinesOperations {
    // @deprecated (undocumented)
    beginCreateOrUpdate: (resourceGroupName: string, resourceName: string, agentPoolName: string, machineName: string, parameters: Machine, options?: MachinesCreateOrUpdateOptionalParams) => Promise<SimplePollerLike<OperationState<Machine>, Machine>>;
    // @deprecated (undocumented)
    beginCreateOrUpdateAndWait: (resourceGroupName: string, resourceName: string, agentPoolName: string, machineName: string, parameters: Machine, options?: MachinesCreateOrUpdateOptionalParams) => Promise<Machine>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, agentPoolName: string, machineName: string, parameters: Machine, options?: MachinesCreateOrUpdateOptionalParams) => PollerLike<OperationState<Machine>, Machine>;
    get: (resourceGroupName: string, resourceName: string, agentPoolName: string, machineName: string, options?: MachinesGetOptionalParams) => Promise<Machine>;
    list: (resourceGroupName: string, resourceName: string, agentPoolName: string, options?: MachinesListOptionalParams) => PagedAsyncIterableIterator<Machine>;
}

// @public
export interface MachineStatus {
    readonly creationTimestamp?: Date;
    readonly driftAction?: DriftAction;
    readonly driftReason?: string;
    readonly provisioningError?: ErrorDetail;
    readonly vmState?: VmState;
}

// @public
export interface MaintenanceConfiguration extends ProxyResource {
    maintenanceWindow?: MaintenanceWindow;
    notAllowedTime?: TimeSpan[];
    timeInWeek?: TimeInWeek[];
}

// @public
export interface MaintenanceConfigurationProperties {
    maintenanceWindow?: MaintenanceWindow;
    notAllowedTime?: TimeSpan[];
    timeInWeek?: TimeInWeek[];
}

// @public
export interface MaintenanceConfigurationsCreateOrUpdateOptionalParams extends OperationOptions {
}

// @public
export interface MaintenanceConfigurationsDeleteOptionalParams extends OperationOptions {
}

// @public
export interface MaintenanceConfigurationsGetOptionalParams extends OperationOptions {
}

// @public
export interface MaintenanceConfigurationsListByManagedClusterOptionalParams extends OperationOptions {
}

// @public
export interface MaintenanceConfigurationsOperations {
    createOrUpdate: (resourceGroupName: string, resourceName: string, configName: string, parameters: MaintenanceConfiguration, options?: MaintenanceConfigurationsCreateOrUpdateOptionalParams) => Promise<MaintenanceConfiguration>;
    delete: (resourceGroupName: string, resourceName: string, configName: string, options?: MaintenanceConfigurationsDeleteOptionalParams) => Promise<void>;
    get: (resourceGroupName: string, resourceName: string, configName: string, options?: MaintenanceConfigurationsGetOptionalParams) => Promise<MaintenanceConfiguration>;
    listByManagedCluster: (resourceGroupName: string, resourceName: string, options?: MaintenanceConfigurationsListByManagedClusterOptionalParams) => PagedAsyncIterableIterator<MaintenanceConfiguration>;
}

// @public
export interface MaintenanceWindow {
    durationHours: number;
    notAllowedDates?: DateSpan[];
    schedule: Schedule;
    startDate?: Date;
    startTime: string;
    utcOffset?: string;
}

// @public
export interface ManagedCluster extends TrackedResource {
    aadProfile?: ManagedClusterAADProfile;
    addonProfiles?: Record<string, ManagedClusterAddonProfile>;
    agentPoolProfiles?: ManagedClusterAgentPoolProfile[];
    aiToolchainOperatorProfile?: ManagedClusterAIToolchainOperatorProfile;
    apiServerAccessProfile?: ManagedClusterAPIServerAccessProfile;
    autoScalerProfile?: ManagedClusterPropertiesAutoScalerProfile;
    autoUpgradeProfile?: ManagedClusterAutoUpgradeProfile;
    azureMonitorProfile?: ManagedClusterAzureMonitorProfile;
    readonly azurePortalFqdn?: string;
    bootstrapProfile?: ManagedClusterBootstrapProfile;
    creationData?: CreationData;
    readonly currentKubernetesVersion?: string;
    disableLocalAccounts?: boolean;
    diskEncryptionSetID?: string;
    dnsPrefix?: string;
    enableNamespaceResources?: boolean;
    enableRbac?: boolean;
    readonly eTag?: string;
    extendedLocation?: ExtendedLocation;
    readonly fqdn?: string;
    fqdnSubdomain?: string;
    hostedSystemProfile?: ManagedClusterHostedSystemProfile;
    httpProxyConfig?: ManagedClusterHttpProxyConfig;
    identity?: ManagedClusterIdentity;
    identityProfile?: Record<string, UserAssignedIdentity>;
    ingressProfile?: ManagedClusterIngressProfile;
    kind?: string;
    kubernetesVersion?: string;
    linuxProfile?: ContainerServiceLinuxProfile;
    readonly maxAgentPools?: number;
    metricsProfile?: ManagedClusterMetricsProfile;
    networkProfile?: ContainerServiceNetworkProfile;
    nodeProvisioningProfile?: ManagedClusterNodeProvisioningProfile;
    nodeResourceGroup?: string;
    nodeResourceGroupProfile?: ManagedClusterNodeResourceGroupProfile;
    oidcIssuerProfile?: ManagedClusterOidcIssuerProfile;
    podIdentityProfile?: ManagedClusterPodIdentityProfile;
    readonly powerState?: PowerState;
    readonly privateFqdn?: string;
    privateLinkResources?: PrivateLinkResource[];
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    readonly resourceUID?: string;
    schedulerProfile?: SchedulerProfile;
    securityProfile?: ManagedClusterSecurityProfile;
    serviceMeshProfile?: ServiceMeshProfile;
    servicePrincipalProfile?: ManagedClusterServicePrincipalProfile;
    sku?: ManagedClusterSKU;
    status?: ManagedClusterStatus;
    storageProfile?: ManagedClusterStorageProfile;
    supportPlan?: KubernetesSupportPlan;
    upgradeSettings?: ClusterUpgradeSettings;
    windowsProfile?: ManagedClusterWindowsProfile;
    workloadAutoScalerProfile?: ManagedClusterWorkloadAutoScalerProfile;
}

// @public
export interface ManagedClusterAADProfile {
    adminGroupObjectIDs?: string[];
    clientAppID?: string;
    enableAzureRbac?: boolean;
    managed?: boolean;
    serverAppID?: string;
    serverAppSecret?: string;
    tenantID?: string;
}

// @public
export interface ManagedClusterAccessProfile extends TrackedResource {
    kubeConfig?: Uint8Array;
}

// @public
export interface ManagedClusterAddonProfile {
    config?: Record<string, string>;
    enabled: boolean;
    readonly identity?: ManagedClusterAddonProfileIdentity;
}

// @public
export interface ManagedClusterAddonProfileIdentity extends UserAssignedIdentity {
}

// @public
export interface ManagedClusterAgentPoolProfile extends ManagedClusterAgentPoolProfileProperties {
    name: string;
}

// @public
export interface ManagedClusterAgentPoolProfileProperties {
    artifactStreamingProfile?: AgentPoolArtifactStreamingProfile;
    availabilityZones?: string[];
    capacityReservationGroupID?: string;
    count?: number;
    creationData?: CreationData;
    readonly currentOrchestratorVersion?: string;
    enableAutoScaling?: boolean;
    enableEncryptionAtHost?: boolean;
    enableFips?: boolean;
    enableNodePublicIP?: boolean;
    enableUltraSSD?: boolean;
    readonly eTag?: string;
    gatewayProfile?: AgentPoolGatewayProfile;
    gpuInstanceProfile?: GPUInstanceProfile;
    gpuProfile?: GPUProfile;
    hostGroupID?: string;
    kubeletConfig?: KubeletConfig;
    kubeletDiskType?: KubeletDiskType;
    linuxOSConfig?: LinuxOSConfig;
    localDNSProfile?: LocalDNSProfile;
    maxCount?: number;
    maxPods?: number;
    messageOfTheDay?: string;
    minCount?: number;
    mode?: AgentPoolMode;
    networkProfile?: AgentPoolNetworkProfile;
    nodeCustomizationProfile?: NodeCustomizationProfile;
    readonly nodeImageVersion?: string;
    nodeInitializationTaints?: string[];
    nodeLabels?: Record<string, string>;
    nodePublicIPPrefixID?: string;
    nodeTaints?: string[];
    orchestratorVersion?: string;
    osDiskSizeGB?: number;
    osDiskType?: OSDiskType;
    osSKU?: Ossku;
    osType?: OSType;
    podIPAllocationMode?: PodIPAllocationMode;
    podSubnetID?: string;
    powerState?: PowerState;
    readonly provisioningState?: string;
    proximityPlacementGroupID?: string;
    scaleDownMode?: ScaleDownMode;
    scaleSetEvictionPolicy?: ScaleSetEvictionPolicy;
    scaleSetPriority?: ScaleSetPriority;
    securityProfile?: AgentPoolSecurityProfile;
    spotMaxPrice?: number;
    status?: AgentPoolStatus;
    tags?: Record<string, string>;
    type?: AgentPoolType;
    upgradeSettings?: AgentPoolUpgradeSettings;
    upgradeSettingsBlueGreen?: AgentPoolBlueGreenUpgradeSettings;
    upgradeStrategy?: UpgradeStrategy;
    virtualMachineNodesStatus?: VirtualMachineNodes[];
    virtualMachinesProfile?: VirtualMachinesProfile;
    vmSize?: string;
    vnetSubnetID?: string;
    windowsProfile?: AgentPoolWindowsProfile;
    workloadRuntime?: WorkloadRuntime;
}

// @public
export interface ManagedClusterAIToolchainOperatorProfile {
    enabled?: boolean;
}

// @public
export interface ManagedClusterAPIServerAccessProfile {
    authorizedIPRanges?: string[];
    disableRunCommand?: boolean;
    enablePrivateCluster?: boolean;
    enablePrivateClusterPublicFqdn?: boolean;
    enableVnetIntegration?: boolean;
    privateDNSZone?: string;
    subnetId?: string;
}

// @public
export interface ManagedClusterAutoUpgradeProfile {
    nodeOSUpgradeChannel?: NodeOSUpgradeChannel;
    upgradeChannel?: UpgradeChannel;
}

// @public
export interface ManagedClusterAzureMonitorProfile {
    appMonitoring?: ManagedClusterAzureMonitorProfileAppMonitoring;
    containerInsights?: ManagedClusterAzureMonitorProfileContainerInsights;
    metrics?: ManagedClusterAzureMonitorProfileMetrics;
}

// @public
export interface ManagedClusterAzureMonitorProfileAppMonitoring {
    autoInstrumentation?: ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation;
    openTelemetryLogs?: ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs;
    openTelemetryMetrics?: ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics;
}

// @public
export interface ManagedClusterAzureMonitorProfileAppMonitoringAutoInstrumentation {
    enabled?: boolean;
}

// @public
export interface ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryLogs {
    enabled?: boolean;
    port?: number;
}

// @public
export interface ManagedClusterAzureMonitorProfileAppMonitoringOpenTelemetryMetrics {
    enabled?: boolean;
    port?: number;
}

// @public
export interface ManagedClusterAzureMonitorProfileContainerInsights {
    disableCustomMetrics?: boolean;
    disablePrometheusMetricsScraping?: boolean;
    enabled?: boolean;
    logAnalyticsWorkspaceResourceId?: string;
    syslogPort?: number;
}

// @public
export interface ManagedClusterAzureMonitorProfileKubeStateMetrics {
    metricAnnotationsAllowList?: string;
    metricLabelsAllowlist?: string;
}

// @public
export interface ManagedClusterAzureMonitorProfileMetrics {
    enabled: boolean;
    kubeStateMetrics?: ManagedClusterAzureMonitorProfileKubeStateMetrics;
}

// @public
export interface ManagedClusterBootstrapProfile {
    artifactSource?: ArtifactSource;
    containerRegistryId?: string;
}

// @public
export interface ManagedClusterCostAnalysis {
    enabled?: boolean;
}

// @public
export interface ManagedClusterHostedSystemProfile {
    enabled?: boolean;
}

// @public
export interface ManagedClusterHttpProxyConfig {
    readonly effectiveNoProxy?: string[];
    enabled?: boolean;
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string[];
    trustedCa?: string;
}

// @public
export interface ManagedClusterIdentity {
    delegatedResources?: Record<string, DelegatedResource>;
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ResourceIdentityType;
    userAssignedIdentities?: Record<string, ManagedServiceIdentityUserAssignedIdentitiesValue>;
}

// @public
export interface ManagedClusterIngressDefaultDomainProfile {
    readonly domainName?: string;
    enabled?: boolean;
}

// @public
export interface ManagedClusterIngressProfile {
    applicationLoadBalancer?: ManagedClusterIngressProfileApplicationLoadBalancer;
    gatewayAPI?: ManagedClusterIngressProfileGatewayConfiguration;
    webAppRouting?: ManagedClusterIngressProfileWebAppRouting;
}

// @public
export interface ManagedClusterIngressProfileApplicationLoadBalancer {
    enabled?: boolean;
    readonly identity?: UserAssignedIdentity;
}

// @public
export interface ManagedClusterIngressProfileGatewayConfiguration {
    installation?: ManagedGatewayType;
}

// @public
export interface ManagedClusterIngressProfileNginx {
    defaultIngressControllerType?: NginxIngressControllerType;
}

// @public
export interface ManagedClusterIngressProfileWebAppRouting {
    defaultDomain?: ManagedClusterIngressDefaultDomainProfile;
    dnsZoneResourceIds?: string[];
    enabled?: boolean;
    readonly identity?: UserAssignedIdentity;
    nginx?: ManagedClusterIngressProfileNginx;
}

// @public
export interface ManagedClusterLoadBalancerProfile {
    allocatedOutboundPorts?: number;
    backendPoolType?: BackendPoolType;
    clusterServiceLoadBalancerHealthProbeMode?: ClusterServiceLoadBalancerHealthProbeMode;
    readonly effectiveOutboundIPs?: ResourceReference[];
    enableMultipleStandardLoadBalancers?: boolean;
    idleTimeoutInMinutes?: number;
    managedOutboundIPs?: ManagedClusterLoadBalancerProfileManagedOutboundIPs;
    outboundIPPrefixes?: ManagedClusterLoadBalancerProfileOutboundIPPrefixes;
    outboundIPs?: ManagedClusterLoadBalancerProfileOutboundIPs;
}

// @public
export interface ManagedClusterLoadBalancerProfileManagedOutboundIPs {
    count?: number;
    countIPv6?: number;
}

// @public
export interface ManagedClusterLoadBalancerProfileOutboundIPPrefixes {
    publicIPPrefixes?: ResourceReference[];
}

// @public
export interface ManagedClusterLoadBalancerProfileOutboundIPs {
    publicIPs?: ResourceReference[];
}

// @public
export interface ManagedClusterManagedOutboundIPProfile {
    count?: number;
}

// @public
export interface ManagedClusterMetricsProfile {
    costAnalysis?: ManagedClusterCostAnalysis;
}

// @public
export interface ManagedClusterNATGatewayProfile {
    readonly effectiveOutboundIPs?: ResourceReference[];
    idleTimeoutInMinutes?: number;
    managedOutboundIPProfile?: ManagedClusterManagedOutboundIPProfile;
}

// @public
export interface ManagedClusterNodeProvisioningProfile {
    defaultNodePools?: NodeProvisioningDefaultNodePools;
    mode?: NodeProvisioningMode;
}

// @public
export interface ManagedClusterNodeResourceGroupProfile {
    restrictionLevel?: RestrictionLevel;
}

// @public
export interface ManagedClusterOidcIssuerProfile {
    enabled?: boolean;
    readonly issuerURL?: string;
}

// @public
export interface ManagedClusterPodIdentity {
    bindingSelector?: string;
    identity: UserAssignedIdentity;
    name: string;
    namespace: string;
    // (undocumented)
    readonly provisioningInfo?: ManagedClusterPodIdentityProvisioningInfo;
    readonly provisioningState?: ManagedClusterPodIdentityProvisioningState;
}

// @public
export interface ManagedClusterPodIdentityException {
    name: string;
    namespace: string;
    podLabels: Record<string, string>;
}

// @public
export interface ManagedClusterPodIdentityProfile {
    allowNetworkPluginKubenet?: boolean;
    enabled?: boolean;
    userAssignedIdentities?: ManagedClusterPodIdentity[];
    userAssignedIdentityExceptions?: ManagedClusterPodIdentityException[];
}

// @public
export interface ManagedClusterPodIdentityProvisioningError {
    error?: ManagedClusterPodIdentityProvisioningErrorBody;
}

// @public
export interface ManagedClusterPodIdentityProvisioningErrorBody {
    code?: string;
    details?: ManagedClusterPodIdentityProvisioningErrorBody[];
    message?: string;
    target?: string;
}

// @public
export interface ManagedClusterPodIdentityProvisioningInfo {
    error?: ManagedClusterPodIdentityProvisioningError;
}

// @public
export type ManagedClusterPodIdentityProvisioningState = string;

// @public
export interface ManagedClusterPoolUpgradeProfile {
    componentsByReleases?: ComponentsByRelease[];
    kubernetesVersion: string;
    name?: string;
    osType: OSType;
    upgrades?: ManagedClusterPoolUpgradeProfileUpgradesItem[];
}

// @public
export interface ManagedClusterPoolUpgradeProfileUpgradesItem {
    isOutOfSupport?: boolean;
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface ManagedClusterProperties {
    aadProfile?: ManagedClusterAADProfile;
    addonProfiles?: Record<string, ManagedClusterAddonProfile>;
    agentPoolProfiles?: ManagedClusterAgentPoolProfile[];
    aiToolchainOperatorProfile?: ManagedClusterAIToolchainOperatorProfile;
    apiServerAccessProfile?: ManagedClusterAPIServerAccessProfile;
    autoScalerProfile?: ManagedClusterPropertiesAutoScalerProfile;
    autoUpgradeProfile?: ManagedClusterAutoUpgradeProfile;
    azureMonitorProfile?: ManagedClusterAzureMonitorProfile;
    readonly azurePortalFqdn?: string;
    bootstrapProfile?: ManagedClusterBootstrapProfile;
    creationData?: CreationData;
    readonly currentKubernetesVersion?: string;
    disableLocalAccounts?: boolean;
    diskEncryptionSetID?: string;
    dnsPrefix?: string;
    enableNamespaceResources?: boolean;
    enableRbac?: boolean;
    readonly fqdn?: string;
    fqdnSubdomain?: string;
    hostedSystemProfile?: ManagedClusterHostedSystemProfile;
    httpProxyConfig?: ManagedClusterHttpProxyConfig;
    identityProfile?: Record<string, UserAssignedIdentity>;
    ingressProfile?: ManagedClusterIngressProfile;
    kubernetesVersion?: string;
    linuxProfile?: ContainerServiceLinuxProfile;
    readonly maxAgentPools?: number;
    metricsProfile?: ManagedClusterMetricsProfile;
    networkProfile?: ContainerServiceNetworkProfile;
    nodeProvisioningProfile?: ManagedClusterNodeProvisioningProfile;
    nodeResourceGroup?: string;
    nodeResourceGroupProfile?: ManagedClusterNodeResourceGroupProfile;
    oidcIssuerProfile?: ManagedClusterOidcIssuerProfile;
    podIdentityProfile?: ManagedClusterPodIdentityProfile;
    readonly powerState?: PowerState;
    readonly privateFqdn?: string;
    privateLinkResources?: PrivateLinkResource[];
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    readonly resourceUID?: string;
    schedulerProfile?: SchedulerProfile;
    securityProfile?: ManagedClusterSecurityProfile;
    serviceMeshProfile?: ServiceMeshProfile;
    servicePrincipalProfile?: ManagedClusterServicePrincipalProfile;
    status?: ManagedClusterStatus;
    storageProfile?: ManagedClusterStorageProfile;
    supportPlan?: KubernetesSupportPlan;
    upgradeSettings?: ClusterUpgradeSettings;
    windowsProfile?: ManagedClusterWindowsProfile;
    workloadAutoScalerProfile?: ManagedClusterWorkloadAutoScalerProfile;
}

// @public
export interface ManagedClusterPropertiesAutoScalerProfile {
    balanceSimilarNodeGroups?: string;
    daemonsetEvictionForEmptyNodes?: boolean;
    daemonsetEvictionForOccupiedNodes?: boolean;
    expander?: Expander;
    ignoreDaemonsetsUtilization?: boolean;
    maxEmptyBulkDelete?: string;
    maxGracefulTerminationSec?: string;
    maxNodeProvisionTime?: string;
    maxTotalUnreadyPercentage?: string;
    newPodScaleUpDelay?: string;
    okTotalUnreadyCount?: string;
    scaleDownDelayAfterAdd?: string;
    scaleDownDelayAfterDelete?: string;
    scaleDownDelayAfterFailure?: string;
    scaleDownUnneededTime?: string;
    scaleDownUnreadyTime?: string;
    scaleDownUtilizationThreshold?: string;
    scanInterval?: string;
    skipNodesWithLocalStorage?: string;
    skipNodesWithSystemPods?: string;
}

// @public
export interface ManagedClusterPropertiesForSnapshot {
    enableRbac?: boolean;
    kubernetesVersion?: string;
    readonly networkProfile?: NetworkProfileForSnapshot;
    sku?: ManagedClusterSKU;
}

// @public
export interface ManagedClustersAbortLatestOperationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersCreateOrUpdateOptionalParams extends OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersDeleteOptionalParams extends OperationOptions {
    ifMatch?: string;
    ignorePodDisruptionBudget?: boolean;
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClusterSecurityProfile {
    azureKeyVaultKms?: AzureKeyVaultKms;
    customCATrustCertificates?: Uint8Array[];
    defender?: ManagedClusterSecurityProfileDefender;
    imageCleaner?: ManagedClusterSecurityProfileImageCleaner;
    imageIntegrity?: ManagedClusterSecurityProfileImageIntegrity;
    kubernetesResourceObjectEncryptionProfile?: KubernetesResourceObjectEncryptionProfile;
    nodeRestriction?: ManagedClusterSecurityProfileNodeRestriction;
    workloadIdentity?: ManagedClusterSecurityProfileWorkloadIdentity;
}

// @public
export interface ManagedClusterSecurityProfileDefender {
    logAnalyticsWorkspaceResourceId?: string;
    securityGating?: ManagedClusterSecurityProfileDefenderSecurityGating;
    securityMonitoring?: ManagedClusterSecurityProfileDefenderSecurityMonitoring;
}

// @public
export interface ManagedClusterSecurityProfileDefenderSecurityGating {
    allowSecretAccess?: boolean;
    enabled?: boolean;
    identities?: ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem[];
}

// @public
export interface ManagedClusterSecurityProfileDefenderSecurityGatingIdentitiesItem {
    azureContainerRegistry?: string;
    identity?: UserAssignedIdentity;
}

// @public
export interface ManagedClusterSecurityProfileDefenderSecurityMonitoring {
    enabled?: boolean;
}

// @public
export interface ManagedClusterSecurityProfileImageCleaner {
    enabled?: boolean;
    intervalHours?: number;
}

// @public
export interface ManagedClusterSecurityProfileImageIntegrity {
    enabled?: boolean;
}

// @public
export interface ManagedClusterSecurityProfileNodeRestriction {
    enabled?: boolean;
}

// @public
export interface ManagedClusterSecurityProfileWorkloadIdentity {
    enabled?: boolean;
}

// @public
export interface ManagedClusterServicePrincipalProfile {
    clientId: string;
    secret?: string;
}

// @public
export interface ManagedClustersGetAccessProfileOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersGetCommandResultOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersGetGuardrailsVersionsOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersGetMeshRevisionProfileOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersGetMeshUpgradeProfileOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersGetOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersGetSafeguardsVersionsOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersGetUpgradeProfileOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterSKU {
    name?: ManagedClusterSKUName;
    tier?: ManagedClusterSKUTier;
}

// @public
export type ManagedClusterSKUName = string;

// @public
export type ManagedClusterSKUTier = string;

// @public
export interface ManagedClustersListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListClusterAdminCredentialsOptionalParams extends OperationOptions {
    serverFqdn?: string;
}

// @public
export interface ManagedClustersListClusterMonitoringUserCredentialsOptionalParams extends OperationOptions {
    serverFqdn?: string;
}

// @public
export interface ManagedClustersListClusterUserCredentialsOptionalParams extends OperationOptions {
    format?: Format;
    serverFqdn?: string;
}

// @public
export interface ManagedClustersListGuardrailsVersionsOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListKubernetesVersionsOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListMeshRevisionProfilesOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListMeshUpgradeProfilesOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListOutboundNetworkDependenciesEndpointsOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersListSafeguardsVersionsOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterSnapshot extends TrackedResource {
    creationData?: CreationData;
    readonly managedClusterPropertiesReadOnly?: ManagedClusterPropertiesForSnapshot;
    snapshotType?: SnapshotType;
}

// @public
export interface ManagedClusterSnapshotProperties {
    creationData?: CreationData;
    readonly managedClusterPropertiesReadOnly?: ManagedClusterPropertiesForSnapshot;
    snapshotType?: SnapshotType;
}

// @public
export interface ManagedClusterSnapshotsCreateOrUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterSnapshotsDeleteOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterSnapshotsGetOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterSnapshotsListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterSnapshotsListOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClusterSnapshotsOperations {
    createOrUpdate: (resourceGroupName: string, resourceName: string, parameters: ManagedClusterSnapshot, options?: ManagedClusterSnapshotsCreateOrUpdateOptionalParams) => Promise<ManagedClusterSnapshot>;
    delete: (resourceGroupName: string, resourceName: string, options?: ManagedClusterSnapshotsDeleteOptionalParams) => Promise<void>;
    get: (resourceGroupName: string, resourceName: string, options?: ManagedClusterSnapshotsGetOptionalParams) => Promise<ManagedClusterSnapshot>;
    list: (options?: ManagedClusterSnapshotsListOptionalParams) => PagedAsyncIterableIterator<ManagedClusterSnapshot>;
    listByResourceGroup: (resourceGroupName: string, options?: ManagedClusterSnapshotsListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<ManagedClusterSnapshot>;
    updateTags: (resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: ManagedClusterSnapshotsUpdateTagsOptionalParams) => Promise<ManagedClusterSnapshot>;
}

// @public
export interface ManagedClusterSnapshotsUpdateTagsOptionalParams extends OperationOptions {
}

// @public
export interface ManagedClustersOperations {
    abortLatestOperation: (resourceGroupName: string, resourceName: string, options?: ManagedClustersAbortLatestOperationOptionalParams) => PollerLike<OperationState<void>, void>;
    // @deprecated (undocumented)
    beginAbortLatestOperation: (resourceGroupName: string, resourceName: string, options?: ManagedClustersAbortLatestOperationOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginAbortLatestOperationAndWait: (resourceGroupName: string, resourceName: string, options?: ManagedClustersAbortLatestOperationOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginCreateOrUpdate: (resourceGroupName: string, resourceName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams) => Promise<SimplePollerLike<OperationState<ManagedCluster>, ManagedCluster>>;
    // @deprecated (undocumented)
    beginCreateOrUpdateAndWait: (resourceGroupName: string, resourceName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams) => Promise<ManagedCluster>;
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, options?: ManagedClustersDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, options?: ManagedClustersDeleteOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginRebalanceLoadBalancers: (resourceGroupName: string, resourceName: string, parameters: RebalanceLoadBalancersRequestBody, options?: ManagedClustersRebalanceLoadBalancersOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginRebalanceLoadBalancersAndWait: (resourceGroupName: string, resourceName: string, parameters: RebalanceLoadBalancersRequestBody, options?: ManagedClustersRebalanceLoadBalancersOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginResetAADProfile: (resourceGroupName: string, resourceName: string, parameters: ManagedClusterAADProfile, options?: ManagedClustersResetAADProfileOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginResetAADProfileAndWait: (resourceGroupName: string, resourceName: string, parameters: ManagedClusterAADProfile, options?: ManagedClustersResetAADProfileOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginResetServicePrincipalProfile: (resourceGroupName: string, resourceName: string, parameters: ManagedClusterServicePrincipalProfile, options?: ManagedClustersResetServicePrincipalProfileOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginResetServicePrincipalProfileAndWait: (resourceGroupName: string, resourceName: string, parameters: ManagedClusterServicePrincipalProfile, options?: ManagedClustersResetServicePrincipalProfileOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginRotateClusterCertificates: (resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateClusterCertificatesOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginRotateClusterCertificatesAndWait: (resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateClusterCertificatesOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginRotateServiceAccountSigningKeys: (resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateServiceAccountSigningKeysOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginRotateServiceAccountSigningKeysAndWait: (resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateServiceAccountSigningKeysOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginRunCommand: (resourceGroupName: string, resourceName: string, requestPayload: RunCommandRequest, options?: ManagedClustersRunCommandOptionalParams) => Promise<SimplePollerLike<OperationState<RunCommandResult>, RunCommandResult>>;
    // @deprecated (undocumented)
    beginRunCommandAndWait: (resourceGroupName: string, resourceName: string, requestPayload: RunCommandRequest, options?: ManagedClustersRunCommandOptionalParams) => Promise<RunCommandResult>;
    // @deprecated (undocumented)
    beginStart: (resourceGroupName: string, resourceName: string, options?: ManagedClustersStartOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginStartAndWait: (resourceGroupName: string, resourceName: string, options?: ManagedClustersStartOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginStop: (resourceGroupName: string, resourceName: string, options?: ManagedClustersStopOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginStopAndWait: (resourceGroupName: string, resourceName: string, options?: ManagedClustersStopOptionalParams) => Promise<void>;
    // @deprecated (undocumented)
    beginUpdateTags: (resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: ManagedClustersUpdateTagsOptionalParams) => Promise<SimplePollerLike<OperationState<ManagedCluster>, ManagedCluster>>;
    // @deprecated (undocumented)
    beginUpdateTagsAndWait: (resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: ManagedClustersUpdateTagsOptionalParams) => Promise<ManagedCluster>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams) => PollerLike<OperationState<ManagedCluster>, ManagedCluster>;
    delete: (resourceGroupName: string, resourceName: string, options?: ManagedClustersDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, options?: ManagedClustersGetOptionalParams) => Promise<ManagedCluster>;
    getAccessProfile: (resourceGroupName: string, resourceName: string, roleName: string, options?: ManagedClustersGetAccessProfileOptionalParams) => Promise<ManagedClusterAccessProfile>;
    getCommandResult: (resourceGroupName: string, resourceName: string, commandId: string, options?: ManagedClustersGetCommandResultOptionalParams) => Promise<RunCommandResult>;
    getGuardrailsVersions: (location: string, version: string, options?: ManagedClustersGetGuardrailsVersionsOptionalParams) => Promise<GuardrailsAvailableVersion>;
    getMeshRevisionProfile: (location: string, mode: string, options?: ManagedClustersGetMeshRevisionProfileOptionalParams) => Promise<MeshRevisionProfile>;
    getMeshUpgradeProfile: (resourceGroupName: string, resourceName: string, mode: string, options?: ManagedClustersGetMeshUpgradeProfileOptionalParams) => Promise<MeshUpgradeProfile>;
    getSafeguardsVersions: (location: string, version: string, options?: ManagedClustersGetSafeguardsVersionsOptionalParams) => Promise<SafeguardsAvailableVersion>;
    getUpgradeProfile: (resourceGroupName: string, resourceName: string, options?: ManagedClustersGetUpgradeProfileOptionalParams) => Promise<ManagedClusterUpgradeProfile>;
    list: (options?: ManagedClustersListOptionalParams) => PagedAsyncIterableIterator<ManagedCluster>;
    listByResourceGroup: (resourceGroupName: string, options?: ManagedClustersListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<ManagedCluster>;
    listClusterAdminCredentials: (resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterAdminCredentialsOptionalParams) => Promise<CredentialResults>;
    listClusterMonitoringUserCredentials: (resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterMonitoringUserCredentialsOptionalParams) => Promise<CredentialResults>;
    listClusterUserCredentials: (resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterUserCredentialsOptionalParams) => Promise<CredentialResults>;
    listGuardrailsVersions: (location: string, options?: ManagedClustersListGuardrailsVersionsOptionalParams) => PagedAsyncIterableIterator<GuardrailsAvailableVersion>;
    listKubernetesVersions: (location: string, options?: ManagedClustersListKubernetesVersionsOptionalParams) => Promise<KubernetesVersionListResult>;
    listMeshRevisionProfiles: (location: string, options?: ManagedClustersListMeshRevisionProfilesOptionalParams) => PagedAsyncIterableIterator<MeshRevisionProfile>;
    listMeshUpgradeProfiles: (resourceGroupName: string, resourceName: string, options?: ManagedClustersListMeshUpgradeProfilesOptionalParams) => PagedAsyncIterableIterator<MeshUpgradeProfile>;
    listOutboundNetworkDependenciesEndpoints: (resourceGroupName: string, resourceName: string, options?: ManagedClustersListOutboundNetworkDependenciesEndpointsOptionalParams) => PagedAsyncIterableIterator<OutboundEnvironmentEndpoint>;
    listSafeguardsVersions: (location: string, options?: ManagedClustersListSafeguardsVersionsOptionalParams) => PagedAsyncIterableIterator<SafeguardsAvailableVersion>;
    rebalanceLoadBalancers: (resourceGroupName: string, resourceName: string, parameters: RebalanceLoadBalancersRequestBody, options?: ManagedClustersRebalanceLoadBalancersOptionalParams) => PollerLike<OperationState<void>, void>;
    resetAADProfile: (resourceGroupName: string, resourceName: string, parameters: ManagedClusterAADProfile, options?: ManagedClustersResetAADProfileOptionalParams) => PollerLike<OperationState<void>, void>;
    resetServicePrincipalProfile: (resourceGroupName: string, resourceName: string, parameters: ManagedClusterServicePrincipalProfile, options?: ManagedClustersResetServicePrincipalProfileOptionalParams) => PollerLike<OperationState<void>, void>;
    rotateClusterCertificates: (resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateClusterCertificatesOptionalParams) => PollerLike<OperationState<void>, void>;
    rotateServiceAccountSigningKeys: (resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateServiceAccountSigningKeysOptionalParams) => PollerLike<OperationState<void>, void>;
    runCommand: (resourceGroupName: string, resourceName: string, requestPayload: RunCommandRequest, options?: ManagedClustersRunCommandOptionalParams) => PollerLike<OperationState<RunCommandResult>, RunCommandResult>;
    start: (resourceGroupName: string, resourceName: string, options?: ManagedClustersStartOptionalParams) => PollerLike<OperationState<void>, void>;
    stop: (resourceGroupName: string, resourceName: string, options?: ManagedClustersStopOptionalParams) => PollerLike<OperationState<void>, void>;
    updateTags: (resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: ManagedClustersUpdateTagsOptionalParams) => PollerLike<OperationState<ManagedCluster>, ManagedCluster>;
}

// @public
export interface ManagedClustersRebalanceLoadBalancersOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersResetAADProfileOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersResetServicePrincipalProfileOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersRotateClusterCertificatesOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersRotateServiceAccountSigningKeysOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersRunCommandOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersStartOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersStopOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClusterStaticEgressGatewayProfile {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStatus {
    readonly provisioningError?: ErrorDetail;
}

// @public
export interface ManagedClusterStorageProfile {
    blobCSIDriver?: ManagedClusterStorageProfileBlobCSIDriver;
    diskCSIDriver?: ManagedClusterStorageProfileDiskCSIDriver;
    fileCSIDriver?: ManagedClusterStorageProfileFileCSIDriver;
    snapshotController?: ManagedClusterStorageProfileSnapshotController;
}

// @public
export interface ManagedClusterStorageProfileBlobCSIDriver {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStorageProfileDiskCSIDriver {
    enabled?: boolean;
    version?: string;
}

// @public
export interface ManagedClusterStorageProfileFileCSIDriver {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStorageProfileSnapshotController {
    enabled?: boolean;
}

// @public
export interface ManagedClustersUpdateTagsOptionalParams extends OperationOptions {
    ifMatch?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClusterUpgradeProfile extends ProxyResource {
    agentPoolProfiles: ManagedClusterPoolUpgradeProfile[];
    controlPlaneProfile: ManagedClusterPoolUpgradeProfile;
}

// @public
export interface ManagedClusterUpgradeProfileProperties {
    agentPoolProfiles: ManagedClusterPoolUpgradeProfile[];
    controlPlaneProfile: ManagedClusterPoolUpgradeProfile;
}

// @public
export interface ManagedClusterWindowsProfile {
    adminPassword?: string;
    adminUsername: string;
    enableCSIProxy?: boolean;
    gmsaProfile?: WindowsGmsaProfile;
    licenseType?: LicenseType;
}

// @public
export interface ManagedClusterWorkloadAutoScalerProfile {
    keda?: ManagedClusterWorkloadAutoScalerProfileKeda;
    verticalPodAutoscaler?: ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler;
}

// @public
export interface ManagedClusterWorkloadAutoScalerProfileKeda {
    enabled: boolean;
}

// @public
export interface ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler {
    addonAutoscaling?: AddonAutoscaling;
    enabled: boolean;
}

// @public
export type ManagedGatewayType = string;

// @public
export interface ManagedNamespace extends Resource {
    readonly eTag?: string;
    location?: string;
    properties?: NamespaceProperties;
    tags?: Record<string, string>;
}

// @public
export interface ManagedNamespacesCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedNamespacesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ManagedNamespacesGetOptionalParams extends OperationOptions {
}

// @public
export interface ManagedNamespacesListByManagedClusterOptionalParams extends OperationOptions {
}

// @public
export interface ManagedNamespacesListCredentialOptionalParams extends OperationOptions {
}

// @public
export interface ManagedNamespacesOperations {
    // @deprecated (undocumented)
    beginCreateOrUpdate: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, parameters: ManagedNamespace, options?: ManagedNamespacesCreateOrUpdateOptionalParams) => Promise<SimplePollerLike<OperationState<ManagedNamespace>, ManagedNamespace>>;
    // @deprecated (undocumented)
    beginCreateOrUpdateAndWait: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, parameters: ManagedNamespace, options?: ManagedNamespacesCreateOrUpdateOptionalParams) => Promise<ManagedNamespace>;
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, options?: ManagedNamespacesDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, options?: ManagedNamespacesDeleteOptionalParams) => Promise<void>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, parameters: ManagedNamespace, options?: ManagedNamespacesCreateOrUpdateOptionalParams) => PollerLike<OperationState<ManagedNamespace>, ManagedNamespace>;
    delete: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, options?: ManagedNamespacesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, options?: ManagedNamespacesGetOptionalParams) => Promise<ManagedNamespace>;
    listByManagedCluster: (resourceGroupName: string, resourceName: string, options?: ManagedNamespacesListByManagedClusterOptionalParams) => PagedAsyncIterableIterator<ManagedNamespace>;
    listCredential: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, options?: ManagedNamespacesListCredentialOptionalParams) => Promise<CredentialResults>;
    update: (resourceGroupName: string, resourceName: string, managedNamespaceName: string, parameters: TagsObject, options?: ManagedNamespacesUpdateOptionalParams) => Promise<ManagedNamespace>;
}

// @public
export interface ManagedNamespacesUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ManagedServiceIdentityUserAssignedIdentitiesValue {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface ManualScaleProfile {
    count?: number;
    size?: string;
}

// @public
export interface MeshMembership extends ProxyResource {
    readonly eTag?: string;
    managedBy?: string;
    properties?: MeshMembershipProperties;
}

// @public
export interface MeshMembershipProperties {
    managedMeshID: string;
    readonly provisioningState?: MeshMembershipProvisioningState;
}

// @public
export type MeshMembershipProvisioningState = string;

// @public
export interface MeshMembershipsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface MeshMembershipsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface MeshMembershipsGetOptionalParams extends OperationOptions {
}

// @public
export interface MeshMembershipsListByManagedClusterOptionalParams extends OperationOptions {
}

// @public
export interface MeshMembershipsOperations {
    // @deprecated (undocumented)
    beginCreateOrUpdate: (resourceGroupName: string, resourceName: string, meshMembershipName: string, parameters: MeshMembership, options?: MeshMembershipsCreateOrUpdateOptionalParams) => Promise<SimplePollerLike<OperationState<MeshMembership>, MeshMembership>>;
    // @deprecated (undocumented)
    beginCreateOrUpdateAndWait: (resourceGroupName: string, resourceName: string, meshMembershipName: string, parameters: MeshMembership, options?: MeshMembershipsCreateOrUpdateOptionalParams) => Promise<MeshMembership>;
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, meshMembershipName: string, options?: MeshMembershipsDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, meshMembershipName: string, options?: MeshMembershipsDeleteOptionalParams) => Promise<void>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, meshMembershipName: string, parameters: MeshMembership, options?: MeshMembershipsCreateOrUpdateOptionalParams) => PollerLike<OperationState<MeshMembership>, MeshMembership>;
    delete: (resourceGroupName: string, resourceName: string, meshMembershipName: string, options?: MeshMembershipsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, meshMembershipName: string, options?: MeshMembershipsGetOptionalParams) => Promise<MeshMembership>;
    listByManagedCluster: (resourceGroupName: string, resourceName: string, options?: MeshMembershipsListByManagedClusterOptionalParams) => PagedAsyncIterableIterator<MeshMembership>;
}

// @public
export interface MeshRevision {
    compatibleWith?: CompatibleVersions[];
    revision?: string;
    upgrades?: string[];
}

// @public
export interface MeshRevisionProfile extends ProxyResource {
    properties?: MeshRevisionProfileProperties;
}

// @public
export interface MeshRevisionProfileProperties {
    // (undocumented)
    meshRevisions?: MeshRevision[];
}

// @public
export interface MeshUpgradeProfile extends ProxyResource {
    properties?: MeshUpgradeProfileProperties;
}

// @public
export interface MeshUpgradeProfileProperties extends MeshRevision {
}

// @public
export type Mode = string;

// @public
export interface NamespaceProperties {
    adoptionPolicy?: AdoptionPolicy;
    annotations?: Record<string, string>;
    defaultNetworkPolicy?: NetworkPolicies;
    defaultResourceQuota?: ResourceQuota;
    deletePolicy?: DeletePolicy;
    labels?: Record<string, string>;
    readonly portalFqdn?: string;
    readonly provisioningState?: NamespaceProvisioningState;
}

// @public
export type NamespaceProvisioningState = string;

// @public
export type NetworkDataplane = string;

// @public
export type NetworkMode = string;

// @public
export type NetworkPlugin = string;

// @public
export type NetworkPluginMode = string;

// @public
export interface NetworkPolicies {
    egress?: PolicyRule;
    ingress?: PolicyRule;
}

// @public
export type NetworkPolicy = string;

// @public
export interface NetworkProfileForSnapshot {
    loadBalancerSku?: LoadBalancerSku;
    networkMode?: NetworkMode;
    networkPlugin?: NetworkPlugin;
    networkPluginMode?: NetworkPluginMode;
    networkPolicy?: NetworkPolicy;
}

// @public
export type NginxIngressControllerType = string;

// @public
export interface NodeCustomizationProfile {
    nodeCustomizationId?: string;
}

// @public
export interface NodeImageVersion {
    fullName?: string;
    os?: string;
    sku?: string;
    version?: string;
}

// @public
export type NodeOSUpgradeChannel = string;

// @public
export type NodeProvisioningDefaultNodePools = string;

// @public
export type NodeProvisioningMode = string;

// @public
export interface OperationsListOptionalParams extends OperationOptions {
}

// @public
export interface OperationsOperations {
    list: (options?: OperationsListOptionalParams) => PagedAsyncIterableIterator<OperationValue>;
}

// @public
export interface OperationStatusResult {
    endTime?: Date;
    error?: ErrorDetail;
    id?: string;
    name?: string;
    operations?: OperationStatusResult[];
    percentComplete?: number;
    readonly resourceId?: string;
    startTime?: Date;
    status: string;
}

// @public
export interface OperationStatusResultGetByAgentPoolOptionalParams extends OperationOptions {
}

// @public
export interface OperationStatusResultGetOptionalParams extends OperationOptions {
}

// @public
export interface OperationStatusResultListOptionalParams extends OperationOptions {
}

// @public
export interface OperationStatusResultOperations {
    get: (resourceGroupName: string, resourceName: string, operationId: string, options?: OperationStatusResultGetOptionalParams) => Promise<OperationStatusResult>;
    getByAgentPool: (resourceGroupName: string, resourceName: string, agentPoolName: string, operationId: string, options?: OperationStatusResultGetByAgentPoolOptionalParams) => Promise<OperationStatusResult>;
    list: (resourceGroupName: string, resourceName: string, options?: OperationStatusResultListOptionalParams) => PagedAsyncIterableIterator<OperationStatusResult>;
}

// @public
export interface OperationValue {
    readonly description?: string;
    readonly name?: string;
    readonly operation?: string;
    readonly origin?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationValueDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export type Operator = string;

// @public
export type OSDiskType = string;

// @public
export type Ossku = string;

// @public
export type OSType = string;

// @public
export interface OutboundEnvironmentEndpoint {
    category?: string;
    endpoints?: EndpointDependency[];
}

// @public
export type OutboundType = string;

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export type PodIPAllocationMode = string;

// @public
export type PodLinkLocalAccess = string;

// @public
export type PolicyRule = string;

// @public
export interface PortRange {
    portEnd?: number;
    portStart?: number;
    protocol?: Protocol;
}

// @public
export interface PowerState {
    code?: Code;
}

// @public
export interface PrivateEndpoint {
    id?: string;
}

// @public
export interface PrivateEndpointConnection extends ProxyResource {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
}

// @public
export interface PrivateEndpointConnectionListResult {
    value?: PrivateEndpointConnection[];
}

// @public
export interface PrivateEndpointConnectionProperties {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends OperationOptions {
}

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends OperationOptions {
}

// @public
export interface PrivateEndpointConnectionsOperations {
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams) => Promise<void>;
    delete: (resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams) => Promise<PrivateEndpointConnection>;
    list: (resourceGroupName: string, resourceName: string, options?: PrivateEndpointConnectionsListOptionalParams) => Promise<PrivateEndpointConnectionListResult>;
    update: (resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionsUpdateOptionalParams) => Promise<PrivateEndpointConnection>;
}

// @public
export interface PrivateEndpointConnectionsUpdateOptionalParams extends OperationOptions {
}

// @public
export interface PrivateLinkResource {
    groupId?: string;
    id?: string;
    name?: string;
    readonly privateLinkServiceID?: string;
    requiredMembers?: string[];
    type?: string;
}

// @public
export interface PrivateLinkResourcesListOptionalParams extends OperationOptions {
}

// @public
export interface PrivateLinkResourcesListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkResourcesOperations {
    list: (resourceGroupName: string, resourceName: string, options?: PrivateLinkResourcesListOptionalParams) => Promise<PrivateLinkResourcesListResult>;
}

// @public
export interface PrivateLinkServiceConnectionState {
    description?: string;
    status?: ConnectionStatus;
}

// @public
export type Protocol = string;

// @public
export type ProxyRedirectionMechanism = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export type PublicNetworkAccess = string;

// @public
export interface RebalanceLoadBalancersRequestBody {
    loadBalancerNames?: string[];
}

// @public
export interface RelativeMonthlySchedule {
    dayOfWeek: WeekDay;
    intervalMonths: number;
    weekIndex: Type;
}

// @public
export interface ResolvePrivateLinkServiceIdOperations {
    post: (resourceGroupName: string, resourceName: string, parameters: PrivateLinkResource, options?: ResolvePrivateLinkServiceIdPostOptionalParams) => Promise<PrivateLinkResource>;
}

// @public
export interface ResolvePrivateLinkServiceIdPostOptionalParams extends OperationOptions {
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export type ResourceIdentityType = "SystemAssigned" | "UserAssigned" | "None";

// @public
export interface ResourceQuota {
    cpuLimit?: string;
    cpuRequest?: string;
    memoryLimit?: string;
    memoryRequest?: string;
}

// @public
export interface ResourceReference {
    id?: string;
}

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: ContainerServiceClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export type RestrictionLevel = string;

// @public
export interface RunCommandRequest {
    clusterToken?: string;
    command: string;
    context?: string;
}

// @public
export interface RunCommandResult {
    readonly exitCode?: number;
    readonly finishedAt?: Date;
    readonly id?: string;
    readonly logs?: string;
    readonly provisioningState?: string;
    readonly reason?: string;
    readonly startedAt?: Date;
}

// @public
export interface SafeguardsAvailableVersion extends ProxyResource {
    properties: SafeguardsAvailableVersionsProperties;
}

// @public
export interface SafeguardsAvailableVersionsProperties {
    // (undocumented)
    readonly isDefaultVersion?: boolean;
    readonly support?: SafeguardsSupport;
}

// @public
export type SafeguardsSupport = string;

// @public
export type ScaleDownMode = string;

// @public
export interface ScaleProfile {
    autoscale?: AutoScaleProfile;
    manual?: ManualScaleProfile[];
}

// @public
export type ScaleSetEvictionPolicy = string;

// @public
export type ScaleSetPriority = string;

// @public
export interface Schedule {
    absoluteMonthly?: AbsoluteMonthlySchedule;
    daily?: DailySchedule;
    relativeMonthly?: RelativeMonthlySchedule;
    weekly?: WeeklySchedule;
}

// @public
export type SchedulerConfigMode = string;

// @public
export interface SchedulerInstanceProfile {
    schedulerConfigMode?: SchedulerConfigMode;
}

// @public
export interface SchedulerProfile {
    schedulerInstanceProfiles?: SchedulerProfileSchedulerInstanceProfiles;
}

// @public
export interface SchedulerProfileSchedulerInstanceProfiles {
    upstream?: SchedulerInstanceProfile;
}

// @public
export type SeccompDefault = string;

// @public
export type ServiceMeshMode = string;

// @public
export interface ServiceMeshProfile {
    istio?: IstioServiceMesh;
    mode: ServiceMeshMode;
}

// @public
export interface SimplePollerLike<TState extends OperationState<TResult>, TResult> {
    getOperationState(): TState;
    getResult(): TResult | undefined;
    isDone(): boolean;
    // @deprecated
    isStopped(): boolean;
    onProgress(callback: (state: TState) => void): CancelOnProgress;
    poll(options?: {
        abortSignal?: AbortSignalLike;
    }): Promise<TState>;
    pollUntilDone(pollOptions?: {
        abortSignal?: AbortSignalLike;
    }): Promise<TResult>;
    serialize(): Promise<string>;
    // @deprecated
    stopPolling(): void;
    submitted(): Promise<void>;
    // @deprecated
    toString(): string;
}

// @public
export interface Snapshot extends TrackedResource {
    creationData?: CreationData;
    readonly enableFips?: boolean;
    readonly kubernetesVersion?: string;
    readonly nodeImageVersion?: string;
    readonly osSku?: Ossku;
    readonly osType?: OSType;
    snapshotType?: SnapshotType;
    readonly vmSize?: string;
}

// @public
export interface SnapshotProperties {
    creationData?: CreationData;
    readonly enableFips?: boolean;
    readonly kubernetesVersion?: string;
    readonly nodeImageVersion?: string;
    readonly osSku?: Ossku;
    readonly osType?: OSType;
    snapshotType?: SnapshotType;
    readonly vmSize?: string;
}

// @public
export interface SnapshotsCreateOrUpdateOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsDeleteOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsGetOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsListOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsOperations {
    createOrUpdate: (resourceGroupName: string, resourceName: string, parameters: Snapshot, options?: SnapshotsCreateOrUpdateOptionalParams) => Promise<Snapshot>;
    delete: (resourceGroupName: string, resourceName: string, options?: SnapshotsDeleteOptionalParams) => Promise<void>;
    get: (resourceGroupName: string, resourceName: string, options?: SnapshotsGetOptionalParams) => Promise<Snapshot>;
    list: (options?: SnapshotsListOptionalParams) => PagedAsyncIterableIterator<Snapshot>;
    listByResourceGroup: (resourceGroupName: string, options?: SnapshotsListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<Snapshot>;
    updateTags: (resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: SnapshotsUpdateTagsOptionalParams) => Promise<Snapshot>;
}

// @public
export interface SnapshotsUpdateTagsOptionalParams extends OperationOptions {
}

// @public
export type SnapshotType = string;

// @public
export interface SysctlConfig {
    fsAioMaxNr?: number;
    fsFileMax?: number;
    fsInotifyMaxUserWatches?: number;
    fsNrOpen?: number;
    kernelThreadsMax?: number;
    netCoreNetdevMaxBacklog?: number;
    netCoreOptmemMax?: number;
    netCoreRmemDefault?: number;
    netCoreRmemMax?: number;
    netCoreSomaxconn?: number;
    netCoreWmemDefault?: number;
    netCoreWmemMax?: number;
    netIpv4IpLocalPortRange?: string;
    netIpv4NeighDefaultGcThresh1?: number;
    netIpv4NeighDefaultGcThresh2?: number;
    netIpv4NeighDefaultGcThresh3?: number;
    netIpv4TcpFinTimeout?: number;
    netIpv4TcpkeepaliveIntvl?: number;
    netIpv4TcpKeepaliveProbes?: number;
    netIpv4TcpKeepaliveTime?: number;
    netIpv4TcpMaxSynBacklog?: number;
    netIpv4TcpMaxTwBuckets?: number;
    netIpv4TcpTwReuse?: boolean;
    netNetfilterNfConntrackBuckets?: number;
    netNetfilterNfConntrackMax?: number;
    vmMaxMapCount?: number;
    vmSwappiness?: number;
    vmVfsCachePressure?: number;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TagsObject {
    tags?: Record<string, string>;
}

// @public
export interface TimeInWeek {
    day?: WeekDay;
    hourSlots?: number[];
}

// @public
export interface TimeSpan {
    end?: Date;
    start?: Date;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export type TransitEncryptionType = string;

// @public
export interface TrustedAccessRole {
    readonly name?: string;
    readonly rules?: TrustedAccessRoleRule[];
    readonly sourceResourceType?: string;
}

// @public
export interface TrustedAccessRoleBinding extends ProxyResource {
    readonly provisioningState?: TrustedAccessRoleBindingProvisioningState;
    roles: string[];
    sourceResourceId: string;
}

// @public
export interface TrustedAccessRoleBindingProperties {
    readonly provisioningState?: TrustedAccessRoleBindingProvisioningState;
    roles: string[];
    sourceResourceId: string;
}

// @public
export type TrustedAccessRoleBindingProvisioningState = string;

// @public
export interface TrustedAccessRoleBindingsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TrustedAccessRoleBindingsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TrustedAccessRoleBindingsGetOptionalParams extends OperationOptions {
}

// @public
export interface TrustedAccessRoleBindingsListOptionalParams extends OperationOptions {
}

// @public
export interface TrustedAccessRoleBindingsOperations {
    // @deprecated (undocumented)
    beginCreateOrUpdate: (resourceGroupName: string, resourceName: string, trustedAccessRoleBindingName: string, trustedAccessRoleBinding: TrustedAccessRoleBinding, options?: TrustedAccessRoleBindingsCreateOrUpdateOptionalParams) => Promise<SimplePollerLike<OperationState<TrustedAccessRoleBinding>, TrustedAccessRoleBinding>>;
    // @deprecated (undocumented)
    beginCreateOrUpdateAndWait: (resourceGroupName: string, resourceName: string, trustedAccessRoleBindingName: string, trustedAccessRoleBinding: TrustedAccessRoleBinding, options?: TrustedAccessRoleBindingsCreateOrUpdateOptionalParams) => Promise<TrustedAccessRoleBinding>;
    // @deprecated (undocumented)
    beginDelete: (resourceGroupName: string, resourceName: string, trustedAccessRoleBindingName: string, options?: TrustedAccessRoleBindingsDeleteOptionalParams) => Promise<SimplePollerLike<OperationState<void>, void>>;
    // @deprecated (undocumented)
    beginDeleteAndWait: (resourceGroupName: string, resourceName: string, trustedAccessRoleBindingName: string, options?: TrustedAccessRoleBindingsDeleteOptionalParams) => Promise<void>;
    createOrUpdate: (resourceGroupName: string, resourceName: string, trustedAccessRoleBindingName: string, trustedAccessRoleBinding: TrustedAccessRoleBinding, options?: TrustedAccessRoleBindingsCreateOrUpdateOptionalParams) => PollerLike<OperationState<TrustedAccessRoleBinding>, TrustedAccessRoleBinding>;
    delete: (resourceGroupName: string, resourceName: string, trustedAccessRoleBindingName: string, options?: TrustedAccessRoleBindingsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, resourceName: string, trustedAccessRoleBindingName: string, options?: TrustedAccessRoleBindingsGetOptionalParams) => Promise<TrustedAccessRoleBinding>;
    list: (resourceGroupName: string, resourceName: string, options?: TrustedAccessRoleBindingsListOptionalParams) => PagedAsyncIterableIterator<TrustedAccessRoleBinding>;
}

// @public
export interface TrustedAccessRoleRule {
    readonly apiGroups?: string[];
    readonly nonResourceURLs?: string[];
    readonly resourceNames?: string[];
    readonly resources?: string[];
    readonly verbs?: string[];
}

// @public
export interface TrustedAccessRolesListOptionalParams extends OperationOptions {
}

// @public
export interface TrustedAccessRolesOperations {
    list: (location: string, options?: TrustedAccessRolesListOptionalParams) => PagedAsyncIterableIterator<TrustedAccessRole>;
}

// @public
export type Type = string;

// @public
export type UndrainableNodeBehavior = string;

// @public
export type UpgradeChannel = string;

// @public
export interface UpgradeOverrideSettings {
    forceUpgrade?: boolean;
    until?: Date;
}

// @public
export type UpgradeStrategy = string;

// @public
export interface UserAssignedIdentity {
    clientId?: string;
    objectId?: string;
    resourceId?: string;
}

// @public
export interface VirtualMachineNodes {
    count?: number;
    size?: string;
}

// @public
export interface VirtualMachinesProfile {
    scale?: ScaleProfile;
}

// @public
export type VmState = string;

// @public
export type WeekDay = string;

// @public
export interface WeeklySchedule {
    dayOfWeek: WeekDay;
    intervalWeeks: number;
}

// @public
export interface WindowsGmsaProfile {
    dnsServer?: string;
    enabled?: boolean;
    rootDomainName?: string;
}

// @public
export type WorkloadRuntime = string;

// (No @packageDocumentation comment for this package)

```
