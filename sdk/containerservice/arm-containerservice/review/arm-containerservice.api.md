## API Report File for "@azure/arm-containerservice"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

// @public
export interface AgentPool extends SubResource {
    availabilityZones?: string[];
    count?: number;
    creationData?: CreationData;
    readonly currentOrchestratorVersion?: string;
    enableAutoScaling?: boolean;
    enableEncryptionAtHost?: boolean;
    enableFips?: boolean;
    enableNodePublicIP?: boolean;
    enableUltraSSD?: boolean;
    gpuInstanceProfile?: GPUInstanceProfile;
    hostGroupID?: string;
    kubeletConfig?: KubeletConfig;
    kubeletDiskType?: KubeletDiskType;
    linuxOSConfig?: LinuxOSConfig;
    maxCount?: number;
    maxPods?: number;
    minCount?: number;
    mode?: AgentPoolMode;
    readonly nodeImageVersion?: string;
    nodeLabels?: {
        [propertyName: string]: string;
    };
    nodePublicIPPrefixID?: string;
    nodeTaints?: string[];
    orchestratorVersion?: string;
    osDiskSizeGB?: number;
    osDiskType?: OSDiskType;
    osSKU?: Ossku;
    osType?: OSType;
    podSubnetID?: string;
    powerState?: PowerState;
    readonly provisioningState?: string;
    proximityPlacementGroupID?: string;
    scaleDownMode?: ScaleDownMode;
    scaleSetEvictionPolicy?: ScaleSetEvictionPolicy;
    scaleSetPriority?: ScaleSetPriority;
    spotMaxPrice?: number;
    tags?: {
        [propertyName: string]: string;
    };
    typePropertiesType?: AgentPoolType;
    upgradeSettings?: AgentPoolUpgradeSettings;
    vmSize?: string;
    vnetSubnetID?: string;
    workloadRuntime?: WorkloadRuntime;
}

// @public
export interface AgentPoolAvailableVersions {
    agentPoolVersions?: AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem[];
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public (undocumented)
export interface AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem {
    default?: boolean;
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface AgentPoolListResult {
    readonly nextLink?: string;
    value?: AgentPool[];
}

// @public
export type AgentPoolMode = string;

// @public
export interface AgentPools {
    beginAbortLatestOperation(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsAbortLatestOperationOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsAbortLatestOperationResponse>, AgentPoolsAbortLatestOperationResponse>>;
    beginAbortLatestOperationAndWait(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsAbortLatestOperationOptionalParams): Promise<AgentPoolsAbortLatestOperationResponse>;
    beginCreateOrUpdate(resourceGroupName: string, resourceName: string, agentPoolName: string, parameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsCreateOrUpdateResponse>, AgentPoolsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, resourceName: string, agentPoolName: string, parameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams): Promise<AgentPoolsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsDeleteResponse>, AgentPoolsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams): Promise<AgentPoolsDeleteResponse>;
    beginUpgradeNodeImageVersion(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsUpgradeNodeImageVersionOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginUpgradeNodeImageVersionAndWait(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsUpgradeNodeImageVersionOptionalParams): Promise<void>;
    get(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsGetOptionalParams): Promise<AgentPoolsGetResponse>;
    getAvailableAgentPoolVersions(resourceGroupName: string, resourceName: string, options?: AgentPoolsGetAvailableAgentPoolVersionsOptionalParams): Promise<AgentPoolsGetAvailableAgentPoolVersionsResponse>;
    getUpgradeProfile(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsGetUpgradeProfileOptionalParams): Promise<AgentPoolsGetUpgradeProfileResponse>;
    list(resourceGroupName: string, resourceName: string, options?: AgentPoolsListOptionalParams): PagedAsyncIterableIterator<AgentPool>;
}

// @public
export interface AgentPoolsAbortLatestOperationHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface AgentPoolsAbortLatestOperationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsAbortLatestOperationResponse = AgentPoolsAbortLatestOperationHeaders;

// @public
export interface AgentPoolsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsCreateOrUpdateResponse = AgentPool;

// @public
export interface AgentPoolsDeleteHeaders {
    location?: string;
}

// @public
export interface AgentPoolsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsDeleteResponse = AgentPoolsDeleteHeaders;

// @public
export interface AgentPoolsGetAvailableAgentPoolVersionsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsGetAvailableAgentPoolVersionsResponse = AgentPoolAvailableVersions;

// @public
export interface AgentPoolsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsGetResponse = AgentPool;

// @public
export interface AgentPoolsGetUpgradeProfileOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsGetUpgradeProfileResponse = AgentPoolUpgradeProfile;

// @public
export interface AgentPoolsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsListNextResponse = AgentPoolListResult;

// @public
export interface AgentPoolsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsListResponse = AgentPoolListResult;

// @public
export interface AgentPoolsUpgradeNodeImageVersionHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface AgentPoolsUpgradeNodeImageVersionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolType = string;

// @public
export interface AgentPoolUpgradeProfile {
    readonly id?: string;
    kubernetesVersion: string;
    latestNodeImageVersion?: string;
    readonly name?: string;
    osType: OSType;
    readonly type?: string;
    upgrades?: AgentPoolUpgradeProfilePropertiesUpgradesItem[];
}

// @public (undocumented)
export interface AgentPoolUpgradeProfilePropertiesUpgradesItem {
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface AgentPoolUpgradeSettings {
    maxSurge?: string;
}

// @public
export interface AzureKeyVaultKms {
    enabled?: boolean;
    keyId?: string;
    keyVaultNetworkAccess?: KeyVaultNetworkAccessTypes;
    keyVaultResourceId?: string;
}

// @public
export interface CloudError {
    error?: CloudErrorBody;
}

// @public
export interface CloudErrorBody {
    code?: string;
    details?: CloudErrorBody[];
    message?: string;
    target?: string;
}

// @public
export type Code = string;

// @public
export type ConnectionStatus = string;

// @public (undocumented)
export class ContainerServiceClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: ContainerServiceClientOptionalParams);
    // (undocumented)
    agentPools: AgentPools;
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    maintenanceConfigurations: MaintenanceConfigurations;
    // (undocumented)
    managedClusters: ManagedClusters;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    resolvePrivateLinkServiceId: ResolvePrivateLinkServiceId;
    // (undocumented)
    snapshots: Snapshots;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface ContainerServiceClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface ContainerServiceDiagnosticsProfile {
    vmDiagnostics: ContainerServiceVMDiagnostics;
}

// @public
export interface ContainerServiceLinuxProfile {
    adminUsername: string;
    ssh: ContainerServiceSshConfiguration;
}

// @public
export interface ContainerServiceMasterProfile {
    count?: Count;
    dnsPrefix: string;
    firstConsecutiveStaticIP?: string;
    readonly fqdn?: string;
    osDiskSizeGB?: number;
    storageProfile?: ContainerServiceStorageProfileTypes;
    vmSize: ContainerServiceVMSizeTypes;
    vnetSubnetID?: string;
}

// @public
export interface ContainerServiceNetworkProfile {
    dnsServiceIP?: string;
    dockerBridgeCidr?: string;
    ipFamilies?: IpFamily[];
    loadBalancerProfile?: ManagedClusterLoadBalancerProfile;
    loadBalancerSku?: LoadBalancerSku;
    natGatewayProfile?: ManagedClusterNATGatewayProfile;
    networkMode?: NetworkMode;
    networkPlugin?: NetworkPlugin;
    networkPolicy?: NetworkPolicy;
    outboundType?: OutboundType;
    podCidr?: string;
    podCidrs?: string[];
    serviceCidr?: string;
    serviceCidrs?: string[];
}

// @public
export interface ContainerServiceSshConfiguration {
    publicKeys: ContainerServiceSshPublicKey[];
}

// @public
export interface ContainerServiceSshPublicKey {
    keyData: string;
}

// @public
export type ContainerServiceStorageProfileTypes = string;

// @public
export interface ContainerServiceVMDiagnostics {
    enabled: boolean;
    readonly storageUri?: string;
}

// @public
export type ContainerServiceVMSizeTypes = string;

// @public
export type Count = 1 | 3 | 5;

// @public
export type CreatedByType = string;

// @public
export interface CreationData {
    sourceResourceId?: string;
}

// @public
export interface CredentialResult {
    readonly name?: string;
    readonly value?: Uint8Array;
}

// @public
export interface CredentialResults {
    readonly kubeconfigs?: CredentialResult[];
}

// @public
export interface EndpointDependency {
    domainName?: string;
    endpointDetails?: EndpointDetail[];
}

// @public
export interface EndpointDetail {
    description?: string;
    ipAddress?: string;
    port?: number;
    protocol?: string;
}

// @public
export type Expander = string;

// @public
export interface ExtendedLocation {
    name?: string;
    type?: ExtendedLocationTypes;
}

// @public
export type ExtendedLocationTypes = string;

// @public
export type Format = string;

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export type GPUInstanceProfile = string;

// @public
export type IpFamily = string;

// @public
export type KeyVaultNetworkAccessTypes = string;

// @public
export enum KnownAgentPoolMode {
    System = "System",
    User = "User"
}

// @public
export enum KnownAgentPoolType {
    AvailabilitySet = "AvailabilitySet",
    VirtualMachineScaleSets = "VirtualMachineScaleSets"
}

// @public
export enum KnownCode {
    Running = "Running",
    Stopped = "Stopped"
}

// @public
export enum KnownConnectionStatus {
    Approved = "Approved",
    Disconnected = "Disconnected",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownContainerServiceStorageProfileTypes {
    ManagedDisks = "ManagedDisks",
    StorageAccount = "StorageAccount"
}

// @public
export enum KnownContainerServiceVMSizeTypes {
    StandardA1 = "Standard_A1",
    StandardA10 = "Standard_A10",
    StandardA11 = "Standard_A11",
    StandardA1V2 = "Standard_A1_v2",
    StandardA2 = "Standard_A2",
    StandardA2MV2 = "Standard_A2m_v2",
    StandardA2V2 = "Standard_A2_v2",
    StandardA3 = "Standard_A3",
    StandardA4 = "Standard_A4",
    StandardA4MV2 = "Standard_A4m_v2",
    StandardA4V2 = "Standard_A4_v2",
    StandardA5 = "Standard_A5",
    StandardA6 = "Standard_A6",
    StandardA7 = "Standard_A7",
    StandardA8 = "Standard_A8",
    StandardA8MV2 = "Standard_A8m_v2",
    StandardA8V2 = "Standard_A8_v2",
    StandardA9 = "Standard_A9",
    StandardB2Ms = "Standard_B2ms",
    StandardB2S = "Standard_B2s",
    StandardB4Ms = "Standard_B4ms",
    StandardB8Ms = "Standard_B8ms",
    StandardD1 = "Standard_D1",
    StandardD11 = "Standard_D11",
    StandardD11V2 = "Standard_D11_v2",
    StandardD11V2Promo = "Standard_D11_v2_Promo",
    StandardD12 = "Standard_D12",
    StandardD12V2 = "Standard_D12_v2",
    StandardD12V2Promo = "Standard_D12_v2_Promo",
    StandardD13 = "Standard_D13",
    StandardD13V2 = "Standard_D13_v2",
    StandardD13V2Promo = "Standard_D13_v2_Promo",
    StandardD14 = "Standard_D14",
    StandardD14V2 = "Standard_D14_v2",
    StandardD14V2Promo = "Standard_D14_v2_Promo",
    StandardD15V2 = "Standard_D15_v2",
    StandardD16SV3 = "Standard_D16s_v3",
    StandardD16V3 = "Standard_D16_v3",
    StandardD1V2 = "Standard_D1_v2",
    StandardD2 = "Standard_D2",
    StandardD2SV3 = "Standard_D2s_v3",
    StandardD2V2 = "Standard_D2_v2",
    StandardD2V2Promo = "Standard_D2_v2_Promo",
    StandardD2V3 = "Standard_D2_v3",
    StandardD3 = "Standard_D3",
    StandardD32SV3 = "Standard_D32s_v3",
    StandardD32V3 = "Standard_D32_v3",
    StandardD3V2 = "Standard_D3_v2",
    StandardD3V2Promo = "Standard_D3_v2_Promo",
    StandardD4 = "Standard_D4",
    StandardD4SV3 = "Standard_D4s_v3",
    StandardD4V2 = "Standard_D4_v2",
    StandardD4V2Promo = "Standard_D4_v2_Promo",
    StandardD4V3 = "Standard_D4_v3",
    StandardD5V2 = "Standard_D5_v2",
    StandardD5V2Promo = "Standard_D5_v2_Promo",
    StandardD64SV3 = "Standard_D64s_v3",
    StandardD64V3 = "Standard_D64_v3",
    StandardD8SV3 = "Standard_D8s_v3",
    StandardD8V3 = "Standard_D8_v3",
    StandardDS1 = "Standard_DS1",
    StandardDS11 = "Standard_DS11",
    StandardDS11V2 = "Standard_DS11_v2",
    StandardDS11V2Promo = "Standard_DS11_v2_Promo",
    StandardDS12 = "Standard_DS12",
    StandardDS12V2 = "Standard_DS12_v2",
    StandardDS12V2Promo = "Standard_DS12_v2_Promo",
    StandardDS13 = "Standard_DS13",
    StandardDS132V2 = "Standard_DS13-2_v2",
    StandardDS134V2 = "Standard_DS13-4_v2",
    StandardDS13V2 = "Standard_DS13_v2",
    StandardDS13V2Promo = "Standard_DS13_v2_Promo",
    StandardDS14 = "Standard_DS14",
    StandardDS144V2 = "Standard_DS14-4_v2",
    StandardDS148V2 = "Standard_DS14-8_v2",
    StandardDS14V2 = "Standard_DS14_v2",
    StandardDS14V2Promo = "Standard_DS14_v2_Promo",
    StandardDS15V2 = "Standard_DS15_v2",
    StandardDS1V2 = "Standard_DS1_v2",
    StandardDS2 = "Standard_DS2",
    StandardDS2V2 = "Standard_DS2_v2",
    StandardDS2V2Promo = "Standard_DS2_v2_Promo",
    StandardDS3 = "Standard_DS3",
    StandardDS3V2 = "Standard_DS3_v2",
    StandardDS3V2Promo = "Standard_DS3_v2_Promo",
    StandardDS4 = "Standard_DS4",
    StandardDS4V2 = "Standard_DS4_v2",
    StandardDS4V2Promo = "Standard_DS4_v2_Promo",
    StandardDS5V2 = "Standard_DS5_v2",
    StandardDS5V2Promo = "Standard_DS5_v2_Promo",
    StandardE16SV3 = "Standard_E16s_v3",
    StandardE16V3 = "Standard_E16_v3",
    StandardE2SV3 = "Standard_E2s_v3",
    StandardE2V3 = "Standard_E2_v3",
    StandardE3216SV3 = "Standard_E32-16s_v3",
    StandardE328SV3 = "Standard_E32-8s_v3",
    StandardE32SV3 = "Standard_E32s_v3",
    StandardE32V3 = "Standard_E32_v3",
    StandardE4SV3 = "Standard_E4s_v3",
    StandardE4V3 = "Standard_E4_v3",
    StandardE6416SV3 = "Standard_E64-16s_v3",
    StandardE6432SV3 = "Standard_E64-32s_v3",
    StandardE64SV3 = "Standard_E64s_v3",
    StandardE64V3 = "Standard_E64_v3",
    StandardE8SV3 = "Standard_E8s_v3",
    StandardE8V3 = "Standard_E8_v3",
    StandardF1 = "Standard_F1",
    StandardF16 = "Standard_F16",
    StandardF16S = "Standard_F16s",
    StandardF16SV2 = "Standard_F16s_v2",
    StandardF1S = "Standard_F1s",
    StandardF2 = "Standard_F2",
    StandardF2S = "Standard_F2s",
    StandardF2SV2 = "Standard_F2s_v2",
    StandardF32SV2 = "Standard_F32s_v2",
    StandardF4 = "Standard_F4",
    StandardF4S = "Standard_F4s",
    StandardF4SV2 = "Standard_F4s_v2",
    StandardF64SV2 = "Standard_F64s_v2",
    StandardF72SV2 = "Standard_F72s_v2",
    StandardF8 = "Standard_F8",
    StandardF8S = "Standard_F8s",
    StandardF8SV2 = "Standard_F8s_v2",
    StandardG1 = "Standard_G1",
    StandardG2 = "Standard_G2",
    StandardG3 = "Standard_G3",
    StandardG4 = "Standard_G4",
    StandardG5 = "Standard_G5",
    StandardGS1 = "Standard_GS1",
    StandardGS2 = "Standard_GS2",
    StandardGS3 = "Standard_GS3",
    StandardGS4 = "Standard_GS4",
    StandardGS44 = "Standard_GS4-4",
    StandardGS48 = "Standard_GS4-8",
    StandardGS5 = "Standard_GS5",
    StandardGS516 = "Standard_GS5-16",
    StandardGS58 = "Standard_GS5-8",
    StandardH16 = "Standard_H16",
    StandardH16M = "Standard_H16m",
    StandardH16Mr = "Standard_H16mr",
    StandardH16R = "Standard_H16r",
    StandardH8 = "Standard_H8",
    StandardH8M = "Standard_H8m",
    StandardL16S = "Standard_L16s",
    StandardL32S = "Standard_L32s",
    StandardL4S = "Standard_L4s",
    StandardL8S = "Standard_L8s",
    StandardM12832Ms = "Standard_M128-32ms",
    StandardM12864Ms = "Standard_M128-64ms",
    StandardM128Ms = "Standard_M128ms",
    StandardM128S = "Standard_M128s",
    StandardM6416Ms = "Standard_M64-16ms",
    StandardM6432Ms = "Standard_M64-32ms",
    StandardM64Ms = "Standard_M64ms",
    StandardM64S = "Standard_M64s",
    StandardNC12 = "Standard_NC12",
    StandardNC12SV2 = "Standard_NC12s_v2",
    StandardNC12SV3 = "Standard_NC12s_v3",
    StandardNC24 = "Standard_NC24",
    StandardNC24R = "Standard_NC24r",
    StandardNC24RsV2 = "Standard_NC24rs_v2",
    StandardNC24RsV3 = "Standard_NC24rs_v3",
    StandardNC24SV2 = "Standard_NC24s_v2",
    StandardNC24SV3 = "Standard_NC24s_v3",
    StandardNC6 = "Standard_NC6",
    StandardNC6SV2 = "Standard_NC6s_v2",
    StandardNC6SV3 = "Standard_NC6s_v3",
    StandardND12S = "Standard_ND12s",
    StandardND24Rs = "Standard_ND24rs",
    StandardND24S = "Standard_ND24s",
    StandardND6S = "Standard_ND6s",
    StandardNV12 = "Standard_NV12",
    StandardNV24 = "Standard_NV24",
    StandardNV6 = "Standard_NV6"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownExpander {
    LeastWaste = "least-waste",
    MostPods = "most-pods",
    Priority = "priority",
    Random = "random"
}

// @public
export enum KnownExtendedLocationTypes {
    EdgeZone = "EdgeZone"
}

// @public
export enum KnownFormat {
    Azure = "azure",
    Exec = "exec"
}

// @public
export enum KnownGPUInstanceProfile {
    MIG1G = "MIG1g",
    MIG2G = "MIG2g",
    MIG3G = "MIG3g",
    MIG4G = "MIG4g",
    MIG7G = "MIG7g"
}

// @public
export enum KnownIpFamily {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownKeyVaultNetworkAccessTypes {
    Private = "Private",
    Public = "Public"
}

// @public
export enum KnownKubeletDiskType {
    OS = "OS",
    Temporary = "Temporary"
}

// @public
export enum KnownLicenseType {
    None = "None",
    WindowsServer = "Windows_Server"
}

// @public
export enum KnownLoadBalancerSku {
    Basic = "basic",
    Standard = "standard"
}

// @public
export enum KnownManagedClusterPodIdentityProvisioningState {
    Assigned = "Assigned",
    Canceled = "Canceled",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownManagedClusterSKUName {
    Base = "Base",
    Basic = "Basic"
}

// @public
export enum KnownManagedClusterSKUTier {
    Free = "Free",
    Paid = "Paid",
    Standard = "Standard"
}

// @public
export enum KnownNetworkMode {
    Bridge = "bridge",
    Transparent = "transparent"
}

// @public
export enum KnownNetworkPlugin {
    Azure = "azure",
    Kubenet = "kubenet",
    None = "none"
}

// @public
export enum KnownNetworkPolicy {
    Azure = "azure",
    Calico = "calico"
}

// @public
export enum KnownOSDiskType {
    Ephemeral = "Ephemeral",
    Managed = "Managed"
}

// @public
export enum KnownOssku {
    CBLMariner = "CBLMariner",
    Ubuntu = "Ubuntu",
    Windows2019 = "Windows2019",
    Windows2022 = "Windows2022"
}

// @public
export enum KnownOSType {
    Linux = "Linux",
    Windows = "Windows"
}

// @public
export enum KnownOutboundType {
    LoadBalancer = "loadBalancer",
    ManagedNATGateway = "managedNATGateway",
    UserAssignedNATGateway = "userAssignedNATGateway",
    UserDefinedRouting = "userDefinedRouting"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownPublicNetworkAccess {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownScaleDownMode {
    Deallocate = "Deallocate",
    Delete = "Delete"
}

// @public
export enum KnownScaleSetEvictionPolicy {
    Deallocate = "Deallocate",
    Delete = "Delete"
}

// @public
export enum KnownScaleSetPriority {
    Regular = "Regular",
    Spot = "Spot"
}

// @public
export enum KnownSnapshotType {
    NodePool = "NodePool"
}

// @public
export enum KnownUpgradeChannel {
    NodeImage = "node-image",
    None = "none",
    Patch = "patch",
    Rapid = "rapid",
    Stable = "stable"
}

// @public
export enum KnownWeekDay {
    Friday = "Friday",
    Monday = "Monday",
    Saturday = "Saturday",
    Sunday = "Sunday",
    Thursday = "Thursday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday"
}

// @public
export enum KnownWorkloadRuntime {
    OCIContainer = "OCIContainer",
    WasmWasi = "WasmWasi"
}

// @public
export interface KubeletConfig {
    allowedUnsafeSysctls?: string[];
    containerLogMaxFiles?: number;
    containerLogMaxSizeMB?: number;
    cpuCfsQuota?: boolean;
    cpuCfsQuotaPeriod?: string;
    cpuManagerPolicy?: string;
    failSwapOn?: boolean;
    imageGcHighThreshold?: number;
    imageGcLowThreshold?: number;
    podMaxPids?: number;
    topologyManagerPolicy?: string;
}

// @public
export type KubeletDiskType = string;

// @public
export type LicenseType = string;

// @public
export interface LinuxOSConfig {
    swapFileSizeMB?: number;
    sysctls?: SysctlConfig;
    transparentHugePageDefrag?: string;
    transparentHugePageEnabled?: string;
}

// @public
export type LoadBalancerSku = string;

// @public
export interface MaintenanceConfiguration extends SubResource {
    notAllowedTime?: TimeSpan[];
    readonly systemData?: SystemData;
    timeInWeek?: TimeInWeek[];
}

// @public
export interface MaintenanceConfigurationListResult {
    readonly nextLink?: string;
    value?: MaintenanceConfiguration[];
}

// @public
export interface MaintenanceConfigurations {
    createOrUpdate(resourceGroupName: string, resourceName: string, configName: string, parameters: MaintenanceConfiguration, options?: MaintenanceConfigurationsCreateOrUpdateOptionalParams): Promise<MaintenanceConfigurationsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, resourceName: string, configName: string, options?: MaintenanceConfigurationsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, resourceName: string, configName: string, options?: MaintenanceConfigurationsGetOptionalParams): Promise<MaintenanceConfigurationsGetResponse>;
    listByManagedCluster(resourceGroupName: string, resourceName: string, options?: MaintenanceConfigurationsListByManagedClusterOptionalParams): PagedAsyncIterableIterator<MaintenanceConfiguration>;
}

// @public
export interface MaintenanceConfigurationsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MaintenanceConfigurationsCreateOrUpdateResponse = MaintenanceConfiguration;

// @public
export interface MaintenanceConfigurationsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface MaintenanceConfigurationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MaintenanceConfigurationsGetResponse = MaintenanceConfiguration;

// @public
export interface MaintenanceConfigurationsListByManagedClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MaintenanceConfigurationsListByManagedClusterNextResponse = MaintenanceConfigurationListResult;

// @public
export interface MaintenanceConfigurationsListByManagedClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MaintenanceConfigurationsListByManagedClusterResponse = MaintenanceConfigurationListResult;

// @public
export interface ManagedCluster extends TrackedResource {
    aadProfile?: ManagedClusterAADProfile;
    addonProfiles?: {
        [propertyName: string]: ManagedClusterAddonProfile;
    };
    agentPoolProfiles?: ManagedClusterAgentPoolProfile[];
    apiServerAccessProfile?: ManagedClusterAPIServerAccessProfile;
    autoScalerProfile?: ManagedClusterPropertiesAutoScalerProfile;
    autoUpgradeProfile?: ManagedClusterAutoUpgradeProfile;
    azureMonitorProfile?: ManagedClusterAzureMonitorProfile;
    readonly azurePortalFqdn?: string;
    readonly currentKubernetesVersion?: string;
    disableLocalAccounts?: boolean;
    diskEncryptionSetID?: string;
    dnsPrefix?: string;
    enablePodSecurityPolicy?: boolean;
    enableRbac?: boolean;
    extendedLocation?: ExtendedLocation;
    readonly fqdn?: string;
    fqdnSubdomain?: string;
    httpProxyConfig?: ManagedClusterHttpProxyConfig;
    identity?: ManagedClusterIdentity;
    identityProfile?: {
        [propertyName: string]: UserAssignedIdentity;
    };
    kubernetesVersion?: string;
    linuxProfile?: ContainerServiceLinuxProfile;
    readonly maxAgentPools?: number;
    networkProfile?: ContainerServiceNetworkProfile;
    nodeResourceGroup?: string;
    oidcIssuerProfile?: ManagedClusterOidcIssuerProfile;
    podIdentityProfile?: ManagedClusterPodIdentityProfile;
    readonly powerState?: PowerState;
    readonly privateFqdn?: string;
    privateLinkResources?: PrivateLinkResource[];
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    securityProfile?: ManagedClusterSecurityProfile;
    servicePrincipalProfile?: ManagedClusterServicePrincipalProfile;
    sku?: ManagedClusterSKU;
    storageProfile?: ManagedClusterStorageProfile;
    windowsProfile?: ManagedClusterWindowsProfile;
    workloadAutoScalerProfile?: ManagedClusterWorkloadAutoScalerProfile;
}

// @public
export interface ManagedClusterAADProfile {
    adminGroupObjectIDs?: string[];
    clientAppID?: string;
    enableAzureRbac?: boolean;
    managed?: boolean;
    serverAppID?: string;
    serverAppSecret?: string;
    tenantID?: string;
}

// @public
export interface ManagedClusterAccessProfile extends TrackedResource {
    kubeConfig?: Uint8Array;
}

// @public
export interface ManagedClusterAddonProfile {
    config?: {
        [propertyName: string]: string;
    };
    enabled: boolean;
    readonly identity?: ManagedClusterAddonProfileIdentity;
}

// @public
export interface ManagedClusterAddonProfileIdentity extends UserAssignedIdentity {
}

// @public
export interface ManagedClusterAgentPoolProfile extends ManagedClusterAgentPoolProfileProperties {
    name: string;
}

// @public
export interface ManagedClusterAgentPoolProfileProperties {
    availabilityZones?: string[];
    count?: number;
    creationData?: CreationData;
    readonly currentOrchestratorVersion?: string;
    enableAutoScaling?: boolean;
    enableEncryptionAtHost?: boolean;
    enableFips?: boolean;
    enableNodePublicIP?: boolean;
    enableUltraSSD?: boolean;
    gpuInstanceProfile?: GPUInstanceProfile;
    hostGroupID?: string;
    kubeletConfig?: KubeletConfig;
    kubeletDiskType?: KubeletDiskType;
    linuxOSConfig?: LinuxOSConfig;
    maxCount?: number;
    maxPods?: number;
    minCount?: number;
    mode?: AgentPoolMode;
    readonly nodeImageVersion?: string;
    nodeLabels?: {
        [propertyName: string]: string;
    };
    nodePublicIPPrefixID?: string;
    nodeTaints?: string[];
    orchestratorVersion?: string;
    osDiskSizeGB?: number;
    osDiskType?: OSDiskType;
    osSKU?: Ossku;
    osType?: OSType;
    podSubnetID?: string;
    powerState?: PowerState;
    readonly provisioningState?: string;
    proximityPlacementGroupID?: string;
    scaleDownMode?: ScaleDownMode;
    scaleSetEvictionPolicy?: ScaleSetEvictionPolicy;
    scaleSetPriority?: ScaleSetPriority;
    spotMaxPrice?: number;
    tags?: {
        [propertyName: string]: string;
    };
    type?: AgentPoolType;
    upgradeSettings?: AgentPoolUpgradeSettings;
    vmSize?: string;
    vnetSubnetID?: string;
    workloadRuntime?: WorkloadRuntime;
}

// @public
export interface ManagedClusterAPIServerAccessProfile {
    authorizedIPRanges?: string[];
    disableRunCommand?: boolean;
    enablePrivateCluster?: boolean;
    enablePrivateClusterPublicFqdn?: boolean;
    privateDNSZone?: string;
}

// @public
export interface ManagedClusterAutoUpgradeProfile {
    upgradeChannel?: UpgradeChannel;
}

// @public
export interface ManagedClusterAzureMonitorProfile {
    metrics?: ManagedClusterAzureMonitorProfileMetrics;
}

// @public
export interface ManagedClusterAzureMonitorProfileKubeStateMetrics {
    metricAnnotationsAllowList?: string;
    metricLabelsAllowlist?: string;
}

// @public
export interface ManagedClusterAzureMonitorProfileMetrics {
    enabled: boolean;
    kubeStateMetrics?: ManagedClusterAzureMonitorProfileKubeStateMetrics;
}

// @public
export interface ManagedClusterHttpProxyConfig {
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string[];
    trustedCa?: string;
}

// @public
export interface ManagedClusterIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ResourceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: ManagedServiceIdentityUserAssignedIdentitiesValue;
    };
}

// @public
export interface ManagedClusterListResult {
    readonly nextLink?: string;
    value?: ManagedCluster[];
}

// @public
export interface ManagedClusterLoadBalancerProfile {
    allocatedOutboundPorts?: number;
    effectiveOutboundIPs?: ResourceReference[];
    enableMultipleStandardLoadBalancers?: boolean;
    idleTimeoutInMinutes?: number;
    managedOutboundIPs?: ManagedClusterLoadBalancerProfileManagedOutboundIPs;
    outboundIPPrefixes?: ManagedClusterLoadBalancerProfileOutboundIPPrefixes;
    outboundIPs?: ManagedClusterLoadBalancerProfileOutboundIPs;
}

// @public
export interface ManagedClusterLoadBalancerProfileManagedOutboundIPs {
    count?: number;
    countIPv6?: number;
}

// @public
export interface ManagedClusterLoadBalancerProfileOutboundIPPrefixes {
    publicIPPrefixes?: ResourceReference[];
}

// @public
export interface ManagedClusterLoadBalancerProfileOutboundIPs {
    publicIPs?: ResourceReference[];
}

// @public
export interface ManagedClusterManagedOutboundIPProfile {
    count?: number;
}

// @public
export interface ManagedClusterNATGatewayProfile {
    effectiveOutboundIPs?: ResourceReference[];
    idleTimeoutInMinutes?: number;
    managedOutboundIPProfile?: ManagedClusterManagedOutboundIPProfile;
}

// @public
export interface ManagedClusterOidcIssuerProfile {
    enabled?: boolean;
    readonly issuerURL?: string;
}

// @public
export interface ManagedClusterPodIdentity {
    bindingSelector?: string;
    identity: UserAssignedIdentity;
    name: string;
    namespace: string;
    readonly provisioningInfo?: ManagedClusterPodIdentityProvisioningInfo;
    readonly provisioningState?: ManagedClusterPodIdentityProvisioningState;
}

// @public
export interface ManagedClusterPodIdentityException {
    name: string;
    namespace: string;
    podLabels: {
        [propertyName: string]: string;
    };
}

// @public
export interface ManagedClusterPodIdentityProfile {
    allowNetworkPluginKubenet?: boolean;
    enabled?: boolean;
    userAssignedIdentities?: ManagedClusterPodIdentity[];
    userAssignedIdentityExceptions?: ManagedClusterPodIdentityException[];
}

// @public
export interface ManagedClusterPodIdentityProvisioningError {
    error?: ManagedClusterPodIdentityProvisioningErrorBody;
}

// @public
export interface ManagedClusterPodIdentityProvisioningErrorBody {
    code?: string;
    details?: ManagedClusterPodIdentityProvisioningErrorBody[];
    message?: string;
    target?: string;
}

// @public (undocumented)
export interface ManagedClusterPodIdentityProvisioningInfo {
    error?: ManagedClusterPodIdentityProvisioningError;
}

// @public
export type ManagedClusterPodIdentityProvisioningState = string;

// @public
export interface ManagedClusterPoolUpgradeProfile {
    kubernetesVersion: string;
    name?: string;
    osType: OSType;
    upgrades?: ManagedClusterPoolUpgradeProfileUpgradesItem[];
}

// @public (undocumented)
export interface ManagedClusterPoolUpgradeProfileUpgradesItem {
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface ManagedClusterPropertiesAutoScalerProfile {
    balanceSimilarNodeGroups?: string;
    expander?: Expander;
    maxEmptyBulkDelete?: string;
    maxGracefulTerminationSec?: string;
    maxNodeProvisionTime?: string;
    maxTotalUnreadyPercentage?: string;
    newPodScaleUpDelay?: string;
    okTotalUnreadyCount?: string;
    scaleDownDelayAfterAdd?: string;
    scaleDownDelayAfterDelete?: string;
    scaleDownDelayAfterFailure?: string;
    scaleDownUnneededTime?: string;
    scaleDownUnreadyTime?: string;
    scaleDownUtilizationThreshold?: string;
    scanInterval?: string;
    skipNodesWithLocalStorage?: string;
    skipNodesWithSystemPods?: string;
}

// @public
export interface ManagedClusters {
    beginAbortLatestOperation(resourceGroupName: string, resourceName: string, options?: ManagedClustersAbortLatestOperationOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersAbortLatestOperationResponse>, ManagedClustersAbortLatestOperationResponse>>;
    beginAbortLatestOperationAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersAbortLatestOperationOptionalParams): Promise<ManagedClustersAbortLatestOperationResponse>;
    beginCreateOrUpdate(resourceGroupName: string, resourceName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersCreateOrUpdateResponse>, ManagedClustersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, resourceName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams): Promise<ManagedClustersCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, resourceName: string, options?: ManagedClustersDeleteOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersDeleteResponse>, ManagedClustersDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersDeleteOptionalParams): Promise<ManagedClustersDeleteResponse>;
    beginResetAADProfile(resourceGroupName: string, resourceName: string, parameters: ManagedClusterAADProfile, options?: ManagedClustersResetAADProfileOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginResetAADProfileAndWait(resourceGroupName: string, resourceName: string, parameters: ManagedClusterAADProfile, options?: ManagedClustersResetAADProfileOptionalParams): Promise<void>;
    beginResetServicePrincipalProfile(resourceGroupName: string, resourceName: string, parameters: ManagedClusterServicePrincipalProfile, options?: ManagedClustersResetServicePrincipalProfileOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginResetServicePrincipalProfileAndWait(resourceGroupName: string, resourceName: string, parameters: ManagedClusterServicePrincipalProfile, options?: ManagedClustersResetServicePrincipalProfileOptionalParams): Promise<void>;
    beginRotateClusterCertificates(resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateClusterCertificatesOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersRotateClusterCertificatesResponse>, ManagedClustersRotateClusterCertificatesResponse>>;
    beginRotateClusterCertificatesAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateClusterCertificatesOptionalParams): Promise<ManagedClustersRotateClusterCertificatesResponse>;
    beginRotateServiceAccountSigningKeys(resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateServiceAccountSigningKeysOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersRotateServiceAccountSigningKeysResponse>, ManagedClustersRotateServiceAccountSigningKeysResponse>>;
    beginRotateServiceAccountSigningKeysAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateServiceAccountSigningKeysOptionalParams): Promise<ManagedClustersRotateServiceAccountSigningKeysResponse>;
    beginRunCommand(resourceGroupName: string, resourceName: string, requestPayload: RunCommandRequest, options?: ManagedClustersRunCommandOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersRunCommandResponse>, ManagedClustersRunCommandResponse>>;
    beginRunCommandAndWait(resourceGroupName: string, resourceName: string, requestPayload: RunCommandRequest, options?: ManagedClustersRunCommandOptionalParams): Promise<ManagedClustersRunCommandResponse>;
    beginStart(resourceGroupName: string, resourceName: string, options?: ManagedClustersStartOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersStartResponse>, ManagedClustersStartResponse>>;
    beginStartAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersStartOptionalParams): Promise<ManagedClustersStartResponse>;
    beginStop(resourceGroupName: string, resourceName: string, options?: ManagedClustersStopOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersStopResponse>, ManagedClustersStopResponse>>;
    beginStopAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersStopOptionalParams): Promise<ManagedClustersStopResponse>;
    beginUpdateTags(resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: ManagedClustersUpdateTagsOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersUpdateTagsResponse>, ManagedClustersUpdateTagsResponse>>;
    beginUpdateTagsAndWait(resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: ManagedClustersUpdateTagsOptionalParams): Promise<ManagedClustersUpdateTagsResponse>;
    get(resourceGroupName: string, resourceName: string, options?: ManagedClustersGetOptionalParams): Promise<ManagedClustersGetResponse>;
    getAccessProfile(resourceGroupName: string, resourceName: string, roleName: string, options?: ManagedClustersGetAccessProfileOptionalParams): Promise<ManagedClustersGetAccessProfileResponse>;
    getCommandResult(resourceGroupName: string, resourceName: string, commandId: string, options?: ManagedClustersGetCommandResultOptionalParams): Promise<ManagedClustersGetCommandResultResponse>;
    getOSOptions(location: string, options?: ManagedClustersGetOSOptionsOptionalParams): Promise<ManagedClustersGetOSOptionsResponse>;
    getUpgradeProfile(resourceGroupName: string, resourceName: string, options?: ManagedClustersGetUpgradeProfileOptionalParams): Promise<ManagedClustersGetUpgradeProfileResponse>;
    list(options?: ManagedClustersListOptionalParams): PagedAsyncIterableIterator<ManagedCluster>;
    listByResourceGroup(resourceGroupName: string, options?: ManagedClustersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<ManagedCluster>;
    listClusterAdminCredentials(resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterAdminCredentialsOptionalParams): Promise<ManagedClustersListClusterAdminCredentialsResponse>;
    listClusterMonitoringUserCredentials(resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterMonitoringUserCredentialsOptionalParams): Promise<ManagedClustersListClusterMonitoringUserCredentialsResponse>;
    listClusterUserCredentials(resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterUserCredentialsOptionalParams): Promise<ManagedClustersListClusterUserCredentialsResponse>;
    listOutboundNetworkDependenciesEndpoints(resourceGroupName: string, resourceName: string, options?: ManagedClustersListOutboundNetworkDependenciesEndpointsOptionalParams): PagedAsyncIterableIterator<OutboundEnvironmentEndpoint>;
}

// @public
export interface ManagedClustersAbortLatestOperationHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ManagedClustersAbortLatestOperationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersAbortLatestOperationResponse = ManagedClustersAbortLatestOperationHeaders;

// @public
export interface ManagedClustersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersCreateOrUpdateResponse = ManagedCluster;

// @public
export interface ManagedClustersDeleteHeaders {
    location?: string;
}

// @public
export interface ManagedClustersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersDeleteResponse = ManagedClustersDeleteHeaders;

// @public
export interface ManagedClusterSecurityProfile {
    azureKeyVaultKms?: AzureKeyVaultKms;
    defender?: ManagedClusterSecurityProfileDefender;
}

// @public
export interface ManagedClusterSecurityProfileDefender {
    logAnalyticsWorkspaceResourceId?: string;
    securityMonitoring?: ManagedClusterSecurityProfileDefenderSecurityMonitoring;
}

// @public
export interface ManagedClusterSecurityProfileDefenderSecurityMonitoring {
    enabled?: boolean;
}

// @public
export interface ManagedClusterServicePrincipalProfile {
    clientId: string;
    secret?: string;
}

// @public
export interface ManagedClustersGetAccessProfileOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetAccessProfileResponse = ManagedClusterAccessProfile;

// @public
export interface ManagedClustersGetCommandResultHeaders {
    location?: string;
}

// @public
export interface ManagedClustersGetCommandResultOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetCommandResultResponse = RunCommandResult;

// @public
export interface ManagedClustersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagedClustersGetOSOptionsOptionalParams extends coreClient.OperationOptions {
    resourceType?: string;
}

// @public
export type ManagedClustersGetOSOptionsResponse = OSOptionProfile;

// @public
export type ManagedClustersGetResponse = ManagedCluster;

// @public
export interface ManagedClustersGetUpgradeProfileOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetUpgradeProfileResponse = ManagedClusterUpgradeProfile;

// @public
export interface ManagedClusterSKU {
    name?: ManagedClusterSKUName;
    tier?: ManagedClusterSKUTier;
}

// @public
export type ManagedClusterSKUName = string;

// @public
export type ManagedClusterSKUTier = string;

// @public
export interface ManagedClustersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListByResourceGroupNextResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListByResourceGroupResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListClusterAdminCredentialsOptionalParams extends coreClient.OperationOptions {
    serverFqdn?: string;
}

// @public
export type ManagedClustersListClusterAdminCredentialsResponse = CredentialResults;

// @public
export interface ManagedClustersListClusterMonitoringUserCredentialsOptionalParams extends coreClient.OperationOptions {
    serverFqdn?: string;
}

// @public
export type ManagedClustersListClusterMonitoringUserCredentialsResponse = CredentialResults;

// @public
export interface ManagedClustersListClusterUserCredentialsOptionalParams extends coreClient.OperationOptions {
    format?: Format;
    serverFqdn?: string;
}

// @public
export type ManagedClustersListClusterUserCredentialsResponse = CredentialResults;

// @public
export interface ManagedClustersListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListNextResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagedClustersListOutboundNetworkDependenciesEndpointsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListOutboundNetworkDependenciesEndpointsNextResponse = OutboundEnvironmentEndpointCollection;

// @public
export interface ManagedClustersListOutboundNetworkDependenciesEndpointsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListOutboundNetworkDependenciesEndpointsResponse = OutboundEnvironmentEndpointCollection;

// @public
export type ManagedClustersListResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersResetAADProfileHeaders {
    location?: string;
}

// @public
export interface ManagedClustersResetAADProfileOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersResetServicePrincipalProfileHeaders {
    location?: string;
}

// @public
export interface ManagedClustersResetServicePrincipalProfileOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersRotateClusterCertificatesHeaders {
    location?: string;
}

// @public
export interface ManagedClustersRotateClusterCertificatesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersRotateClusterCertificatesResponse = ManagedClustersRotateClusterCertificatesHeaders;

// @public
export interface ManagedClustersRotateServiceAccountSigningKeysHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ManagedClustersRotateServiceAccountSigningKeysOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersRotateServiceAccountSigningKeysResponse = ManagedClustersRotateServiceAccountSigningKeysHeaders;

// @public
export interface ManagedClustersRunCommandHeaders {
    location?: string;
}

// @public
export interface ManagedClustersRunCommandOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersRunCommandResponse = RunCommandResult;

// @public
export interface ManagedClustersStartHeaders {
    location?: string;
}

// @public
export interface ManagedClustersStartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersStartResponse = ManagedClustersStartHeaders;

// @public
export interface ManagedClustersStopHeaders {
    location?: string;
}

// @public
export interface ManagedClustersStopOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersStopResponse = ManagedClustersStopHeaders;

// @public
export interface ManagedClusterStorageProfile {
    blobCSIDriver?: ManagedClusterStorageProfileBlobCSIDriver;
    diskCSIDriver?: ManagedClusterStorageProfileDiskCSIDriver;
    fileCSIDriver?: ManagedClusterStorageProfileFileCSIDriver;
    snapshotController?: ManagedClusterStorageProfileSnapshotController;
}

// @public
export interface ManagedClusterStorageProfileBlobCSIDriver {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStorageProfileDiskCSIDriver {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStorageProfileFileCSIDriver {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStorageProfileSnapshotController {
    enabled?: boolean;
}

// @public
export interface ManagedClustersUpdateTagsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersUpdateTagsResponse = ManagedCluster;

// @public
export interface ManagedClusterUpgradeProfile {
    agentPoolProfiles: ManagedClusterPoolUpgradeProfile[];
    controlPlaneProfile: ManagedClusterPoolUpgradeProfile;
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface ManagedClusterWindowsProfile {
    adminPassword?: string;
    adminUsername: string;
    enableCSIProxy?: boolean;
    gmsaProfile?: WindowsGmsaProfile;
    licenseType?: LicenseType;
}

// @public
export interface ManagedClusterWorkloadAutoScalerProfile {
    keda?: ManagedClusterWorkloadAutoScalerProfileKeda;
}

// @public
export interface ManagedClusterWorkloadAutoScalerProfileKeda {
    enabled: boolean;
}

// @public (undocumented)
export interface ManagedServiceIdentityUserAssignedIdentitiesValue {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export type NetworkMode = string;

// @public
export type NetworkPlugin = string;

// @public
export type NetworkPolicy = string;

// @public
export interface OperationListResult {
    readonly value?: OperationValue[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<OperationValue>;
}

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface OperationValue {
    readonly description?: string;
    readonly name?: string;
    readonly operation?: string;
    readonly origin?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export type OSDiskType = string;

// @public
export interface OSOptionProfile {
    readonly id?: string;
    readonly name?: string;
    osOptionPropertyList: OSOptionProperty[];
    readonly type?: string;
}

// @public
export interface OSOptionProperty {
    enableFipsImage: boolean;
    osType: string;
}

// @public
export type Ossku = string;

// @public
export type OSType = string;

// @public
export interface OutboundEnvironmentEndpoint {
    category?: string;
    endpoints?: EndpointDependency[];
}

// @public
export interface OutboundEnvironmentEndpointCollection {
    readonly nextLink?: string;
    value: OutboundEnvironmentEndpoint[];
}

// @public
export type OutboundType = string;

// @public
export interface PowerState {
    code?: Code;
}

// @public
export interface PrivateEndpoint {
    id?: string;
}

// @public
export interface PrivateEndpointConnection {
    readonly id?: string;
    readonly name?: string;
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
    readonly type?: string;
}

// @public
export interface PrivateEndpointConnectionListResult {
    value?: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export interface PrivateEndpointConnections {
    beginDelete(resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams): Promise<PrivateEndpointConnectionsGetResponse>;
    list(resourceGroupName: string, resourceName: string, options?: PrivateEndpointConnectionsListOptionalParams): Promise<PrivateEndpointConnectionsListResponse>;
    update(resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionsUpdateOptionalParams): Promise<PrivateEndpointConnectionsUpdateResponse>;
}

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult;

// @public
export interface PrivateEndpointConnectionsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsUpdateResponse = PrivateEndpointConnection;

// @public
export interface PrivateLinkResource {
    groupId?: string;
    id?: string;
    name?: string;
    readonly privateLinkServiceID?: string;
    requiredMembers?: string[];
    type?: string;
}

// @public
export interface PrivateLinkResources {
    list(resourceGroupName: string, resourceName: string, options?: PrivateLinkResourcesListOptionalParams): Promise<PrivateLinkResourcesListResponse>;
}

// @public
export interface PrivateLinkResourcesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesListResponse = PrivateLinkResourcesListResult;

// @public
export interface PrivateLinkResourcesListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkServiceConnectionState {
    description?: string;
    status?: ConnectionStatus;
}

// @public
export type PublicNetworkAccess = string;

// @public
export interface ResolvePrivateLinkServiceId {
    post(resourceGroupName: string, resourceName: string, parameters: PrivateLinkResource, options?: ResolvePrivateLinkServiceIdPostOptionalParams): Promise<ResolvePrivateLinkServiceIdPostResponse>;
}

// @public
export interface ResolvePrivateLinkServiceIdPostOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ResolvePrivateLinkServiceIdPostResponse = PrivateLinkResource;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export type ResourceIdentityType = "SystemAssigned" | "UserAssigned" | "None";

// @public
export interface ResourceReference {
    id?: string;
}

// @public
export interface RunCommandRequest {
    clusterToken?: string;
    command: string;
    context?: string;
}

// @public
export interface RunCommandResult {
    readonly exitCode?: number;
    readonly finishedAt?: Date;
    readonly id?: string;
    readonly logs?: string;
    readonly provisioningState?: string;
    readonly reason?: string;
    readonly startedAt?: Date;
}

// @public
export type ScaleDownMode = string;

// @public
export type ScaleSetEvictionPolicy = string;

// @public
export type ScaleSetPriority = string;

// @public
export interface Snapshot extends TrackedResource {
    creationData?: CreationData;
    readonly enableFips?: boolean;
    readonly kubernetesVersion?: string;
    readonly nodeImageVersion?: string;
    readonly osSku?: Ossku;
    readonly osType?: OSType;
    snapshotType?: SnapshotType;
    readonly vmSize?: string;
}

// @public
export interface SnapshotListResult {
    readonly nextLink?: string;
    value?: Snapshot[];
}

// @public
export interface Snapshots {
    createOrUpdate(resourceGroupName: string, resourceName: string, parameters: Snapshot, options?: SnapshotsCreateOrUpdateOptionalParams): Promise<SnapshotsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, resourceName: string, options?: SnapshotsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, resourceName: string, options?: SnapshotsGetOptionalParams): Promise<SnapshotsGetResponse>;
    list(options?: SnapshotsListOptionalParams): PagedAsyncIterableIterator<Snapshot>;
    listByResourceGroup(resourceGroupName: string, options?: SnapshotsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Snapshot>;
    updateTags(resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: SnapshotsUpdateTagsOptionalParams): Promise<SnapshotsUpdateTagsResponse>;
}

// @public
export interface SnapshotsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsCreateOrUpdateResponse = Snapshot;

// @public
export interface SnapshotsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface SnapshotsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsGetResponse = Snapshot;

// @public
export interface SnapshotsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListByResourceGroupNextResponse = SnapshotListResult;

// @public
export interface SnapshotsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListByResourceGroupResponse = SnapshotListResult;

// @public
export interface SnapshotsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListNextResponse = SnapshotListResult;

// @public
export interface SnapshotsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListResponse = SnapshotListResult;

// @public
export interface SnapshotsUpdateTagsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsUpdateTagsResponse = Snapshot;

// @public
export type SnapshotType = string;

// @public
export interface SubResource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface SysctlConfig {
    fsAioMaxNr?: number;
    fsFileMax?: number;
    fsInotifyMaxUserWatches?: number;
    fsNrOpen?: number;
    kernelThreadsMax?: number;
    netCoreNetdevMaxBacklog?: number;
    netCoreOptmemMax?: number;
    netCoreRmemDefault?: number;
    netCoreRmemMax?: number;
    netCoreSomaxconn?: number;
    netCoreWmemDefault?: number;
    netCoreWmemMax?: number;
    netIpv4IpLocalPortRange?: string;
    netIpv4NeighDefaultGcThresh1?: number;
    netIpv4NeighDefaultGcThresh2?: number;
    netIpv4NeighDefaultGcThresh3?: number;
    netIpv4TcpFinTimeout?: number;
    netIpv4TcpkeepaliveIntvl?: number;
    netIpv4TcpKeepaliveProbes?: number;
    netIpv4TcpKeepaliveTime?: number;
    netIpv4TcpMaxSynBacklog?: number;
    netIpv4TcpMaxTwBuckets?: number;
    netIpv4TcpTwReuse?: boolean;
    netNetfilterNfConntrackBuckets?: number;
    netNetfilterNfConntrackMax?: number;
    vmMaxMapCount?: number;
    vmSwappiness?: number;
    vmVfsCachePressure?: number;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TagsObject {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface TimeInWeek {
    day?: WeekDay;
    hourSlots?: number[];
}

// @public
export interface TimeSpan {
    end?: Date;
    start?: Date;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type UpgradeChannel = string;

// @public
export interface UserAssignedIdentity {
    clientId?: string;
    objectId?: string;
    resourceId?: string;
}

// @public
export type WeekDay = string;

// @public
export interface WindowsGmsaProfile {
    dnsServer?: string;
    enabled?: boolean;
    rootDomainName?: string;
}

// @public
export type WorkloadRuntime = string;

// (No @packageDocumentation comment for this package)

```
