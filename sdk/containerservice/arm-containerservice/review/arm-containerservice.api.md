## API Report File for "@azure/arm-containerservice"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

// @public
export interface AbsoluteMonthlySchedule {
    dayOfMonth: number;
    intervalMonths: number;
}

// @public
export interface AgentPool extends SubResource {
    availabilityZones?: string[];
    count?: number;
    creationData?: CreationData;
    readonly currentOrchestratorVersion?: string;
    enableAutoScaling?: boolean;
    enableEncryptionAtHost?: boolean;
    enableFips?: boolean;
    enableNodePublicIP?: boolean;
    enableUltraSSD?: boolean;
    gpuInstanceProfile?: GPUInstanceProfile;
    hostGroupID?: string;
    kubeletConfig?: KubeletConfig;
    kubeletDiskType?: KubeletDiskType;
    linuxOSConfig?: LinuxOSConfig;
    maxCount?: number;
    maxPods?: number;
    minCount?: number;
    mode?: AgentPoolMode;
    readonly nodeImageVersion?: string;
    nodeLabels?: {
        [propertyName: string]: string;
    };
    nodePublicIPPrefixID?: string;
    nodeTaints?: string[];
    orchestratorVersion?: string;
    osDiskSizeGB?: number;
    osDiskType?: OSDiskType;
    osSKU?: Ossku;
    osType?: OSType;
    podSubnetID?: string;
    powerState?: PowerState;
    readonly provisioningState?: string;
    proximityPlacementGroupID?: string;
    scaleDownMode?: ScaleDownMode;
    scaleSetEvictionPolicy?: ScaleSetEvictionPolicy;
    scaleSetPriority?: ScaleSetPriority;
    spotMaxPrice?: number;
    tags?: {
        [propertyName: string]: string;
    };
    typePropertiesType?: AgentPoolType;
    upgradeSettings?: AgentPoolUpgradeSettings;
    vmSize?: string;
    vnetSubnetID?: string;
    workloadRuntime?: WorkloadRuntime;
}

// @public
export interface AgentPoolAvailableVersions {
    agentPoolVersions?: AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem[];
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public (undocumented)
export interface AgentPoolAvailableVersionsPropertiesAgentPoolVersionsItem {
    default?: boolean;
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface AgentPoolListResult {
    readonly nextLink?: string;
    value?: AgentPool[];
}

// @public
export type AgentPoolMode = string;

// @public
export interface AgentPools {
    beginAbortLatestOperation(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsAbortLatestOperationOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsAbortLatestOperationResponse>, AgentPoolsAbortLatestOperationResponse>>;
    beginAbortLatestOperationAndWait(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsAbortLatestOperationOptionalParams): Promise<AgentPoolsAbortLatestOperationResponse>;
    beginCreateOrUpdate(resourceGroupName: string, resourceName: string, agentPoolName: string, parameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsCreateOrUpdateResponse>, AgentPoolsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, resourceName: string, agentPoolName: string, parameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams): Promise<AgentPoolsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsDeleteResponse>, AgentPoolsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams): Promise<AgentPoolsDeleteResponse>;
    beginUpgradeNodeImageVersion(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsUpgradeNodeImageVersionOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginUpgradeNodeImageVersionAndWait(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsUpgradeNodeImageVersionOptionalParams): Promise<void>;
    get(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsGetOptionalParams): Promise<AgentPoolsGetResponse>;
    getAvailableAgentPoolVersions(resourceGroupName: string, resourceName: string, options?: AgentPoolsGetAvailableAgentPoolVersionsOptionalParams): Promise<AgentPoolsGetAvailableAgentPoolVersionsResponse>;
    getUpgradeProfile(resourceGroupName: string, resourceName: string, agentPoolName: string, options?: AgentPoolsGetUpgradeProfileOptionalParams): Promise<AgentPoolsGetUpgradeProfileResponse>;
    list(resourceGroupName: string, resourceName: string, options?: AgentPoolsListOptionalParams): PagedAsyncIterableIterator<AgentPool>;
}

// @public
export interface AgentPoolsAbortLatestOperationHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface AgentPoolsAbortLatestOperationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsAbortLatestOperationResponse = AgentPoolsAbortLatestOperationHeaders;

// @public
export interface AgentPoolsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsCreateOrUpdateResponse = AgentPool;

// @public
export interface AgentPoolsDeleteHeaders {
    location?: string;
}

// @public
export interface AgentPoolsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsDeleteResponse = AgentPoolsDeleteHeaders;

// @public
export interface AgentPoolsGetAvailableAgentPoolVersionsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsGetAvailableAgentPoolVersionsResponse = AgentPoolAvailableVersions;

// @public
export interface AgentPoolsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsGetResponse = AgentPool;

// @public
export interface AgentPoolsGetUpgradeProfileOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsGetUpgradeProfileResponse = AgentPoolUpgradeProfile;

// @public
export interface AgentPoolsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsListNextResponse = AgentPoolListResult;

// @public
export interface AgentPoolsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsListResponse = AgentPoolListResult;

// @public
export interface AgentPoolsUpgradeNodeImageVersionHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface AgentPoolsUpgradeNodeImageVersionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolType = string;

// @public
export interface AgentPoolUpgradeProfile {
    readonly id?: string;
    kubernetesVersion: string;
    latestNodeImageVersion?: string;
    readonly name?: string;
    osType: OSType;
    readonly type?: string;
    upgrades?: AgentPoolUpgradeProfilePropertiesUpgradesItem[];
}

// @public (undocumented)
export interface AgentPoolUpgradeProfilePropertiesUpgradesItem {
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface AgentPoolUpgradeSettings {
    drainTimeoutInMinutes?: number;
    maxSurge?: string;
}

// @public
export interface AzureKeyVaultKms {
    enabled?: boolean;
    keyId?: string;
    keyVaultNetworkAccess?: KeyVaultNetworkAccessTypes;
    keyVaultResourceId?: string;
}

// @public
export interface CloudError {
    error?: CloudErrorBody;
}

// @public
export interface CloudErrorBody {
    code?: string;
    details?: CloudErrorBody[];
    message?: string;
    target?: string;
}

// @public
export interface ClusterUpgradeSettings {
    overrideSettings?: UpgradeOverrideSettings;
}

// @public
export type Code = string;

// @public
export interface CompatibleVersions {
    name?: string;
    versions?: string[];
}

// @public
export type ConnectionStatus = string;

// @public (undocumented)
export class ContainerServiceClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: ContainerServiceClientOptionalParams);
    // (undocumented)
    agentPools: AgentPools;
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    maintenanceConfigurations: MaintenanceConfigurations;
    // (undocumented)
    managedClusters: ManagedClusters;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    privateLinkResources: PrivateLinkResources;
    // (undocumented)
    resolvePrivateLinkServiceId: ResolvePrivateLinkServiceId;
    // (undocumented)
    snapshots: Snapshots;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface ContainerServiceClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface ContainerServiceLinuxProfile {
    adminUsername: string;
    ssh: ContainerServiceSshConfiguration;
}

// @public
export interface ContainerServiceNetworkProfile {
    dnsServiceIP?: string;
    ipFamilies?: IpFamily[];
    loadBalancerProfile?: ManagedClusterLoadBalancerProfile;
    loadBalancerSku?: LoadBalancerSku;
    natGatewayProfile?: ManagedClusterNATGatewayProfile;
    networkDataplane?: NetworkDataplane;
    networkMode?: NetworkMode;
    networkPlugin?: NetworkPlugin;
    networkPluginMode?: NetworkPluginMode;
    networkPolicy?: NetworkPolicy;
    outboundType?: OutboundType;
    podCidr?: string;
    podCidrs?: string[];
    serviceCidr?: string;
    serviceCidrs?: string[];
}

// @public
export interface ContainerServiceSshConfiguration {
    publicKeys: ContainerServiceSshPublicKey[];
}

// @public
export interface ContainerServiceSshPublicKey {
    keyData: string;
}

// @public
export type CreatedByType = string;

// @public
export interface CreationData {
    sourceResourceId?: string;
}

// @public
export interface CredentialResult {
    readonly name?: string;
    readonly value?: Uint8Array;
}

// @public
export interface CredentialResults {
    readonly kubeconfigs?: CredentialResult[];
}

// @public
export interface DailySchedule {
    intervalDays: number;
}

// @public
export interface DateSpan {
    end: Date;
    start: Date;
}

// @public
export interface DelegatedResource {
    location?: string;
    referralResource?: string;
    resourceId?: string;
    tenantId?: string;
}

// @public
export interface EndpointDependency {
    domainName?: string;
    endpointDetails?: EndpointDetail[];
}

// @public
export interface EndpointDetail {
    description?: string;
    ipAddress?: string;
    port?: number;
    protocol?: string;
}

// @public
export type Expander = string;

// @public
export interface ExtendedLocation {
    name?: string;
    type?: ExtendedLocationTypes;
}

// @public
export type ExtendedLocationTypes = string;

// @public
export type Format = string;

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export type GPUInstanceProfile = string;

// @public
export type IpFamily = string;

// @public
export interface IstioCertificateAuthority {
    plugin?: IstioPluginCertificateAuthority;
}

// @public
export interface IstioComponents {
    egressGateways?: IstioEgressGateway[];
    ingressGateways?: IstioIngressGateway[];
}

// @public
export interface IstioEgressGateway {
    enabled: boolean;
    nodeSelector?: {
        [propertyName: string]: string;
    };
}

// @public
export interface IstioIngressGateway {
    enabled: boolean;
    mode: IstioIngressGatewayMode;
}

// @public
export type IstioIngressGatewayMode = string;

// @public
export interface IstioPluginCertificateAuthority {
    certChainObjectName?: string;
    certObjectName?: string;
    keyObjectName?: string;
    keyVaultId?: string;
    rootCertObjectName?: string;
}

// @public
export interface IstioServiceMesh {
    certificateAuthority?: IstioCertificateAuthority;
    components?: IstioComponents;
    revisions?: string[];
}

// @public
export type KeyVaultNetworkAccessTypes = string;

// @public
export enum KnownAgentPoolMode {
    System = "System",
    User = "User"
}

// @public
export enum KnownAgentPoolType {
    AvailabilitySet = "AvailabilitySet",
    VirtualMachineScaleSets = "VirtualMachineScaleSets"
}

// @public
export enum KnownCode {
    Running = "Running",
    Stopped = "Stopped"
}

// @public
export enum KnownConnectionStatus {
    Approved = "Approved",
    Disconnected = "Disconnected",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownExpander {
    LeastWaste = "least-waste",
    MostPods = "most-pods",
    Priority = "priority",
    Random = "random"
}

// @public
export enum KnownExtendedLocationTypes {
    EdgeZone = "EdgeZone"
}

// @public
export enum KnownFormat {
    Azure = "azure",
    Exec = "exec"
}

// @public
export enum KnownGPUInstanceProfile {
    MIG1G = "MIG1g",
    MIG2G = "MIG2g",
    MIG3G = "MIG3g",
    MIG4G = "MIG4g",
    MIG7G = "MIG7g"
}

// @public
export enum KnownIpFamily {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

// @public
export enum KnownIstioIngressGatewayMode {
    External = "External",
    Internal = "Internal"
}

// @public
export enum KnownKeyVaultNetworkAccessTypes {
    Private = "Private",
    Public = "Public"
}

// @public
export enum KnownKubeletDiskType {
    OS = "OS",
    Temporary = "Temporary"
}

// @public
export enum KnownKubernetesSupportPlan {
    AKSLongTermSupport = "AKSLongTermSupport",
    KubernetesOfficial = "KubernetesOfficial"
}

// @public
export enum KnownLicenseType {
    None = "None",
    WindowsServer = "Windows_Server"
}

// @public
export enum KnownLoadBalancerSku {
    Basic = "basic",
    Standard = "standard"
}

// @public
export enum KnownManagedClusterPodIdentityProvisioningState {
    Assigned = "Assigned",
    Canceled = "Canceled",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownManagedClusterSKUName {
    Base = "Base"
}

// @public
export enum KnownManagedClusterSKUTier {
    Free = "Free",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownNetworkDataplane {
    Azure = "azure",
    Cilium = "cilium"
}

// @public
export enum KnownNetworkMode {
    Bridge = "bridge",
    Transparent = "transparent"
}

// @public
export enum KnownNetworkPlugin {
    Azure = "azure",
    Kubenet = "kubenet",
    None = "none"
}

// @public
export enum KnownNetworkPluginMode {
    Overlay = "overlay"
}

// @public
export enum KnownNetworkPolicy {
    Azure = "azure",
    Calico = "calico",
    Cilium = "cilium"
}

// @public
export enum KnownNodeOSUpgradeChannel {
    NodeImage = "NodeImage",
    None = "None",
    Unmanaged = "Unmanaged"
}

// @public
export enum KnownOSDiskType {
    Ephemeral = "Ephemeral",
    Managed = "Managed"
}

// @public
export enum KnownOssku {
    AzureLinux = "AzureLinux",
    CBLMariner = "CBLMariner",
    Ubuntu = "Ubuntu",
    Windows2019 = "Windows2019",
    Windows2022 = "Windows2022"
}

// @public
export enum KnownOSType {
    Linux = "Linux",
    Windows = "Windows"
}

// @public
export enum KnownOutboundType {
    LoadBalancer = "loadBalancer",
    ManagedNATGateway = "managedNATGateway",
    UserAssignedNATGateway = "userAssignedNATGateway",
    UserDefinedRouting = "userDefinedRouting"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownPublicNetworkAccess {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownScaleDownMode {
    Deallocate = "Deallocate",
    Delete = "Delete"
}

// @public
export enum KnownScaleSetEvictionPolicy {
    Deallocate = "Deallocate",
    Delete = "Delete"
}

// @public
export enum KnownScaleSetPriority {
    Regular = "Regular",
    Spot = "Spot"
}

// @public
export enum KnownServiceMeshMode {
    Disabled = "Disabled",
    Istio = "Istio"
}

// @public
export enum KnownSnapshotType {
    NodePool = "NodePool"
}

// @public
export enum KnownType {
    First = "First",
    Fourth = "Fourth",
    Last = "Last",
    Second = "Second",
    Third = "Third"
}

// @public
export enum KnownUpgradeChannel {
    NodeImage = "node-image",
    None = "none",
    Patch = "patch",
    Rapid = "rapid",
    Stable = "stable"
}

// @public
export enum KnownWeekDay {
    Friday = "Friday",
    Monday = "Monday",
    Saturday = "Saturday",
    Sunday = "Sunday",
    Thursday = "Thursday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday"
}

// @public
export enum KnownWorkloadRuntime {
    OCIContainer = "OCIContainer",
    WasmWasi = "WasmWasi"
}

// @public
export interface KubeletConfig {
    allowedUnsafeSysctls?: string[];
    containerLogMaxFiles?: number;
    containerLogMaxSizeMB?: number;
    cpuCfsQuota?: boolean;
    cpuCfsQuotaPeriod?: string;
    cpuManagerPolicy?: string;
    failSwapOn?: boolean;
    imageGcHighThreshold?: number;
    imageGcLowThreshold?: number;
    podMaxPids?: number;
    topologyManagerPolicy?: string;
}

// @public
export type KubeletDiskType = string;

// @public
export interface KubernetesPatchVersion {
    upgrades?: string[];
}

// @public
export type KubernetesSupportPlan = string;

// @public
export interface KubernetesVersion {
    capabilities?: KubernetesVersionCapabilities;
    isPreview?: boolean;
    patchVersions?: {
        [propertyName: string]: KubernetesPatchVersion;
    };
    version?: string;
}

// @public
export interface KubernetesVersionCapabilities {
    // (undocumented)
    supportPlan?: KubernetesSupportPlan[];
}

// @public
export interface KubernetesVersionListResult {
    values?: KubernetesVersion[];
}

// @public
export type LicenseType = string;

// @public
export interface LinuxOSConfig {
    swapFileSizeMB?: number;
    sysctls?: SysctlConfig;
    transparentHugePageDefrag?: string;
    transparentHugePageEnabled?: string;
}

// @public
export type LoadBalancerSku = string;

// @public
export interface MaintenanceConfiguration extends SubResource {
    maintenanceWindow?: MaintenanceWindow;
    notAllowedTime?: TimeSpan[];
    readonly systemData?: SystemData;
    timeInWeek?: TimeInWeek[];
}

// @public
export interface MaintenanceConfigurationListResult {
    readonly nextLink?: string;
    value?: MaintenanceConfiguration[];
}

// @public
export interface MaintenanceConfigurations {
    createOrUpdate(resourceGroupName: string, resourceName: string, configName: string, parameters: MaintenanceConfiguration, options?: MaintenanceConfigurationsCreateOrUpdateOptionalParams): Promise<MaintenanceConfigurationsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, resourceName: string, configName: string, options?: MaintenanceConfigurationsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, resourceName: string, configName: string, options?: MaintenanceConfigurationsGetOptionalParams): Promise<MaintenanceConfigurationsGetResponse>;
    listByManagedCluster(resourceGroupName: string, resourceName: string, options?: MaintenanceConfigurationsListByManagedClusterOptionalParams): PagedAsyncIterableIterator<MaintenanceConfiguration>;
}

// @public
export interface MaintenanceConfigurationsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MaintenanceConfigurationsCreateOrUpdateResponse = MaintenanceConfiguration;

// @public
export interface MaintenanceConfigurationsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface MaintenanceConfigurationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MaintenanceConfigurationsGetResponse = MaintenanceConfiguration;

// @public
export interface MaintenanceConfigurationsListByManagedClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MaintenanceConfigurationsListByManagedClusterNextResponse = MaintenanceConfigurationListResult;

// @public
export interface MaintenanceConfigurationsListByManagedClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MaintenanceConfigurationsListByManagedClusterResponse = MaintenanceConfigurationListResult;

// @public
export interface MaintenanceWindow {
    durationHours: number;
    notAllowedDates?: DateSpan[];
    schedule: Schedule;
    startDate?: Date;
    startTime: string;
    utcOffset?: string;
}

// @public
export interface ManagedCluster extends TrackedResource {
    aadProfile?: ManagedClusterAADProfile;
    addonProfiles?: {
        [propertyName: string]: ManagedClusterAddonProfile;
    };
    agentPoolProfiles?: ManagedClusterAgentPoolProfile[];
    apiServerAccessProfile?: ManagedClusterAPIServerAccessProfile;
    autoScalerProfile?: ManagedClusterPropertiesAutoScalerProfile;
    autoUpgradeProfile?: ManagedClusterAutoUpgradeProfile;
    azureMonitorProfile?: ManagedClusterAzureMonitorProfile;
    readonly azurePortalFqdn?: string;
    readonly currentKubernetesVersion?: string;
    disableLocalAccounts?: boolean;
    diskEncryptionSetID?: string;
    dnsPrefix?: string;
    enablePodSecurityPolicy?: boolean;
    enableRbac?: boolean;
    extendedLocation?: ExtendedLocation;
    readonly fqdn?: string;
    fqdnSubdomain?: string;
    httpProxyConfig?: ManagedClusterHttpProxyConfig;
    identity?: ManagedClusterIdentity;
    identityProfile?: {
        [propertyName: string]: UserAssignedIdentity;
    };
    kubernetesVersion?: string;
    linuxProfile?: ContainerServiceLinuxProfile;
    readonly maxAgentPools?: number;
    networkProfile?: ContainerServiceNetworkProfile;
    nodeResourceGroup?: string;
    oidcIssuerProfile?: ManagedClusterOidcIssuerProfile;
    podIdentityProfile?: ManagedClusterPodIdentityProfile;
    readonly powerState?: PowerState;
    readonly privateFqdn?: string;
    privateLinkResources?: PrivateLinkResource[];
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    readonly resourceUID?: string;
    securityProfile?: ManagedClusterSecurityProfile;
    serviceMeshProfile?: ServiceMeshProfile;
    servicePrincipalProfile?: ManagedClusterServicePrincipalProfile;
    sku?: ManagedClusterSKU;
    storageProfile?: ManagedClusterStorageProfile;
    supportPlan?: KubernetesSupportPlan;
    upgradeSettings?: ClusterUpgradeSettings;
    windowsProfile?: ManagedClusterWindowsProfile;
    workloadAutoScalerProfile?: ManagedClusterWorkloadAutoScalerProfile;
}

// @public
export interface ManagedClusterAADProfile {
    adminGroupObjectIDs?: string[];
    clientAppID?: string;
    enableAzureRbac?: boolean;
    managed?: boolean;
    serverAppID?: string;
    serverAppSecret?: string;
    tenantID?: string;
}

// @public
export interface ManagedClusterAccessProfile extends TrackedResource {
    kubeConfig?: Uint8Array;
}

// @public
export interface ManagedClusterAddonProfile {
    config?: {
        [propertyName: string]: string;
    };
    enabled: boolean;
    readonly identity?: ManagedClusterAddonProfileIdentity;
}

// @public
export interface ManagedClusterAddonProfileIdentity extends UserAssignedIdentity {
}

// @public
export interface ManagedClusterAgentPoolProfile extends ManagedClusterAgentPoolProfileProperties {
    name: string;
}

// @public
export interface ManagedClusterAgentPoolProfileProperties {
    availabilityZones?: string[];
    count?: number;
    creationData?: CreationData;
    readonly currentOrchestratorVersion?: string;
    enableAutoScaling?: boolean;
    enableEncryptionAtHost?: boolean;
    enableFips?: boolean;
    enableNodePublicIP?: boolean;
    enableUltraSSD?: boolean;
    gpuInstanceProfile?: GPUInstanceProfile;
    hostGroupID?: string;
    kubeletConfig?: KubeletConfig;
    kubeletDiskType?: KubeletDiskType;
    linuxOSConfig?: LinuxOSConfig;
    maxCount?: number;
    maxPods?: number;
    minCount?: number;
    mode?: AgentPoolMode;
    readonly nodeImageVersion?: string;
    nodeLabels?: {
        [propertyName: string]: string;
    };
    nodePublicIPPrefixID?: string;
    nodeTaints?: string[];
    orchestratorVersion?: string;
    osDiskSizeGB?: number;
    osDiskType?: OSDiskType;
    osSKU?: Ossku;
    osType?: OSType;
    podSubnetID?: string;
    powerState?: PowerState;
    readonly provisioningState?: string;
    proximityPlacementGroupID?: string;
    scaleDownMode?: ScaleDownMode;
    scaleSetEvictionPolicy?: ScaleSetEvictionPolicy;
    scaleSetPriority?: ScaleSetPriority;
    spotMaxPrice?: number;
    tags?: {
        [propertyName: string]: string;
    };
    type?: AgentPoolType;
    upgradeSettings?: AgentPoolUpgradeSettings;
    vmSize?: string;
    vnetSubnetID?: string;
    workloadRuntime?: WorkloadRuntime;
}

// @public
export interface ManagedClusterAPIServerAccessProfile {
    authorizedIPRanges?: string[];
    disableRunCommand?: boolean;
    enablePrivateCluster?: boolean;
    enablePrivateClusterPublicFqdn?: boolean;
    privateDNSZone?: string;
}

// @public
export interface ManagedClusterAutoUpgradeProfile {
    nodeOSUpgradeChannel?: NodeOSUpgradeChannel;
    upgradeChannel?: UpgradeChannel;
}

// @public
export interface ManagedClusterAzureMonitorProfile {
    metrics?: ManagedClusterAzureMonitorProfileMetrics;
}

// @public
export interface ManagedClusterAzureMonitorProfileKubeStateMetrics {
    metricAnnotationsAllowList?: string;
    metricLabelsAllowlist?: string;
}

// @public
export interface ManagedClusterAzureMonitorProfileMetrics {
    enabled: boolean;
    kubeStateMetrics?: ManagedClusterAzureMonitorProfileKubeStateMetrics;
}

// @public
export interface ManagedClusterHttpProxyConfig {
    httpProxy?: string;
    httpsProxy?: string;
    noProxy?: string[];
    trustedCa?: string;
}

// @public
export interface ManagedClusterIdentity {
    delegatedResources?: {
        [propertyName: string]: DelegatedResource;
    };
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ResourceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: ManagedServiceIdentityUserAssignedIdentitiesValue;
    };
}

// @public
export interface ManagedClusterListResult {
    readonly nextLink?: string;
    value?: ManagedCluster[];
}

// @public
export interface ManagedClusterLoadBalancerProfile {
    allocatedOutboundPorts?: number;
    effectiveOutboundIPs?: ResourceReference[];
    enableMultipleStandardLoadBalancers?: boolean;
    idleTimeoutInMinutes?: number;
    managedOutboundIPs?: ManagedClusterLoadBalancerProfileManagedOutboundIPs;
    outboundIPPrefixes?: ManagedClusterLoadBalancerProfileOutboundIPPrefixes;
    outboundIPs?: ManagedClusterLoadBalancerProfileOutboundIPs;
}

// @public
export interface ManagedClusterLoadBalancerProfileManagedOutboundIPs {
    count?: number;
    countIPv6?: number;
}

// @public
export interface ManagedClusterLoadBalancerProfileOutboundIPPrefixes {
    publicIPPrefixes?: ResourceReference[];
}

// @public
export interface ManagedClusterLoadBalancerProfileOutboundIPs {
    publicIPs?: ResourceReference[];
}

// @public
export interface ManagedClusterManagedOutboundIPProfile {
    count?: number;
}

// @public
export interface ManagedClusterNATGatewayProfile {
    effectiveOutboundIPs?: ResourceReference[];
    idleTimeoutInMinutes?: number;
    managedOutboundIPProfile?: ManagedClusterManagedOutboundIPProfile;
}

// @public
export interface ManagedClusterOidcIssuerProfile {
    enabled?: boolean;
    readonly issuerURL?: string;
}

// @public
export interface ManagedClusterPodIdentity {
    bindingSelector?: string;
    identity: UserAssignedIdentity;
    name: string;
    namespace: string;
    readonly provisioningInfo?: ManagedClusterPodIdentityProvisioningInfo;
    readonly provisioningState?: ManagedClusterPodIdentityProvisioningState;
}

// @public
export interface ManagedClusterPodIdentityException {
    name: string;
    namespace: string;
    podLabels: {
        [propertyName: string]: string;
    };
}

// @public
export interface ManagedClusterPodIdentityProfile {
    allowNetworkPluginKubenet?: boolean;
    enabled?: boolean;
    userAssignedIdentities?: ManagedClusterPodIdentity[];
    userAssignedIdentityExceptions?: ManagedClusterPodIdentityException[];
}

// @public
export interface ManagedClusterPodIdentityProvisioningError {
    error?: ManagedClusterPodIdentityProvisioningErrorBody;
}

// @public
export interface ManagedClusterPodIdentityProvisioningErrorBody {
    code?: string;
    details?: ManagedClusterPodIdentityProvisioningErrorBody[];
    message?: string;
    target?: string;
}

// @public (undocumented)
export interface ManagedClusterPodIdentityProvisioningInfo {
    error?: ManagedClusterPodIdentityProvisioningError;
}

// @public
export type ManagedClusterPodIdentityProvisioningState = string;

// @public
export interface ManagedClusterPoolUpgradeProfile {
    kubernetesVersion: string;
    name?: string;
    osType: OSType;
    upgrades?: ManagedClusterPoolUpgradeProfileUpgradesItem[];
}

// @public (undocumented)
export interface ManagedClusterPoolUpgradeProfileUpgradesItem {
    isPreview?: boolean;
    kubernetesVersion?: string;
}

// @public
export interface ManagedClusterPropertiesAutoScalerProfile {
    balanceSimilarNodeGroups?: string;
    expander?: Expander;
    maxEmptyBulkDelete?: string;
    maxGracefulTerminationSec?: string;
    maxNodeProvisionTime?: string;
    maxTotalUnreadyPercentage?: string;
    newPodScaleUpDelay?: string;
    okTotalUnreadyCount?: string;
    scaleDownDelayAfterAdd?: string;
    scaleDownDelayAfterDelete?: string;
    scaleDownDelayAfterFailure?: string;
    scaleDownUnneededTime?: string;
    scaleDownUnreadyTime?: string;
    scaleDownUtilizationThreshold?: string;
    scanInterval?: string;
    skipNodesWithLocalStorage?: string;
    skipNodesWithSystemPods?: string;
}

// @public
export interface ManagedClusters {
    beginAbortLatestOperation(resourceGroupName: string, resourceName: string, options?: ManagedClustersAbortLatestOperationOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersAbortLatestOperationResponse>, ManagedClustersAbortLatestOperationResponse>>;
    beginAbortLatestOperationAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersAbortLatestOperationOptionalParams): Promise<ManagedClustersAbortLatestOperationResponse>;
    beginCreateOrUpdate(resourceGroupName: string, resourceName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersCreateOrUpdateResponse>, ManagedClustersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, resourceName: string, parameters: ManagedCluster, options?: ManagedClustersCreateOrUpdateOptionalParams): Promise<ManagedClustersCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, resourceName: string, options?: ManagedClustersDeleteOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersDeleteResponse>, ManagedClustersDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersDeleteOptionalParams): Promise<ManagedClustersDeleteResponse>;
    beginResetAADProfile(resourceGroupName: string, resourceName: string, parameters: ManagedClusterAADProfile, options?: ManagedClustersResetAADProfileOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginResetAADProfileAndWait(resourceGroupName: string, resourceName: string, parameters: ManagedClusterAADProfile, options?: ManagedClustersResetAADProfileOptionalParams): Promise<void>;
    beginResetServicePrincipalProfile(resourceGroupName: string, resourceName: string, parameters: ManagedClusterServicePrincipalProfile, options?: ManagedClustersResetServicePrincipalProfileOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginResetServicePrincipalProfileAndWait(resourceGroupName: string, resourceName: string, parameters: ManagedClusterServicePrincipalProfile, options?: ManagedClustersResetServicePrincipalProfileOptionalParams): Promise<void>;
    beginRotateClusterCertificates(resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateClusterCertificatesOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersRotateClusterCertificatesResponse>, ManagedClustersRotateClusterCertificatesResponse>>;
    beginRotateClusterCertificatesAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateClusterCertificatesOptionalParams): Promise<ManagedClustersRotateClusterCertificatesResponse>;
    beginRotateServiceAccountSigningKeys(resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateServiceAccountSigningKeysOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersRotateServiceAccountSigningKeysResponse>, ManagedClustersRotateServiceAccountSigningKeysResponse>>;
    beginRotateServiceAccountSigningKeysAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersRotateServiceAccountSigningKeysOptionalParams): Promise<ManagedClustersRotateServiceAccountSigningKeysResponse>;
    beginRunCommand(resourceGroupName: string, resourceName: string, requestPayload: RunCommandRequest, options?: ManagedClustersRunCommandOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersRunCommandResponse>, ManagedClustersRunCommandResponse>>;
    beginRunCommandAndWait(resourceGroupName: string, resourceName: string, requestPayload: RunCommandRequest, options?: ManagedClustersRunCommandOptionalParams): Promise<ManagedClustersRunCommandResponse>;
    beginStart(resourceGroupName: string, resourceName: string, options?: ManagedClustersStartOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersStartResponse>, ManagedClustersStartResponse>>;
    beginStartAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersStartOptionalParams): Promise<ManagedClustersStartResponse>;
    beginStop(resourceGroupName: string, resourceName: string, options?: ManagedClustersStopOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersStopResponse>, ManagedClustersStopResponse>>;
    beginStopAndWait(resourceGroupName: string, resourceName: string, options?: ManagedClustersStopOptionalParams): Promise<ManagedClustersStopResponse>;
    beginUpdateTags(resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: ManagedClustersUpdateTagsOptionalParams): Promise<SimplePollerLike<OperationState<ManagedClustersUpdateTagsResponse>, ManagedClustersUpdateTagsResponse>>;
    beginUpdateTagsAndWait(resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: ManagedClustersUpdateTagsOptionalParams): Promise<ManagedClustersUpdateTagsResponse>;
    get(resourceGroupName: string, resourceName: string, options?: ManagedClustersGetOptionalParams): Promise<ManagedClustersGetResponse>;
    getAccessProfile(resourceGroupName: string, resourceName: string, roleName: string, options?: ManagedClustersGetAccessProfileOptionalParams): Promise<ManagedClustersGetAccessProfileResponse>;
    getCommandResult(resourceGroupName: string, resourceName: string, commandId: string, options?: ManagedClustersGetCommandResultOptionalParams): Promise<ManagedClustersGetCommandResultResponse>;
    getMeshRevisionProfile(location: string, mode: string, options?: ManagedClustersGetMeshRevisionProfileOptionalParams): Promise<ManagedClustersGetMeshRevisionProfileResponse>;
    getMeshUpgradeProfile(resourceGroupName: string, resourceName: string, mode: string, options?: ManagedClustersGetMeshUpgradeProfileOptionalParams): Promise<ManagedClustersGetMeshUpgradeProfileResponse>;
    getOSOptions(location: string, options?: ManagedClustersGetOSOptionsOptionalParams): Promise<ManagedClustersGetOSOptionsResponse>;
    getUpgradeProfile(resourceGroupName: string, resourceName: string, options?: ManagedClustersGetUpgradeProfileOptionalParams): Promise<ManagedClustersGetUpgradeProfileResponse>;
    list(options?: ManagedClustersListOptionalParams): PagedAsyncIterableIterator<ManagedCluster>;
    listByResourceGroup(resourceGroupName: string, options?: ManagedClustersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<ManagedCluster>;
    listClusterAdminCredentials(resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterAdminCredentialsOptionalParams): Promise<ManagedClustersListClusterAdminCredentialsResponse>;
    listClusterMonitoringUserCredentials(resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterMonitoringUserCredentialsOptionalParams): Promise<ManagedClustersListClusterMonitoringUserCredentialsResponse>;
    listClusterUserCredentials(resourceGroupName: string, resourceName: string, options?: ManagedClustersListClusterUserCredentialsOptionalParams): Promise<ManagedClustersListClusterUserCredentialsResponse>;
    listKubernetesVersions(location: string, options?: ManagedClustersListKubernetesVersionsOptionalParams): Promise<ManagedClustersListKubernetesVersionsResponse>;
    listMeshRevisionProfiles(location: string, options?: ManagedClustersListMeshRevisionProfilesOptionalParams): PagedAsyncIterableIterator<MeshRevisionProfile>;
    listMeshUpgradeProfiles(resourceGroupName: string, resourceName: string, options?: ManagedClustersListMeshUpgradeProfilesOptionalParams): PagedAsyncIterableIterator<MeshUpgradeProfile>;
    listOutboundNetworkDependenciesEndpoints(resourceGroupName: string, resourceName: string, options?: ManagedClustersListOutboundNetworkDependenciesEndpointsOptionalParams): PagedAsyncIterableIterator<OutboundEnvironmentEndpoint>;
}

// @public
export interface ManagedClustersAbortLatestOperationHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ManagedClustersAbortLatestOperationOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersAbortLatestOperationResponse = ManagedClustersAbortLatestOperationHeaders;

// @public
export interface ManagedClustersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersCreateOrUpdateResponse = ManagedCluster;

// @public
export interface ManagedClustersDeleteHeaders {
    location?: string;
}

// @public
export interface ManagedClustersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersDeleteResponse = ManagedClustersDeleteHeaders;

// @public
export interface ManagedClusterSecurityProfile {
    azureKeyVaultKms?: AzureKeyVaultKms;
    defender?: ManagedClusterSecurityProfileDefender;
    imageCleaner?: ManagedClusterSecurityProfileImageCleaner;
    workloadIdentity?: ManagedClusterSecurityProfileWorkloadIdentity;
}

// @public
export interface ManagedClusterSecurityProfileDefender {
    logAnalyticsWorkspaceResourceId?: string;
    securityMonitoring?: ManagedClusterSecurityProfileDefenderSecurityMonitoring;
}

// @public
export interface ManagedClusterSecurityProfileDefenderSecurityMonitoring {
    enabled?: boolean;
}

// @public
export interface ManagedClusterSecurityProfileImageCleaner {
    enabled?: boolean;
    intervalHours?: number;
}

// @public
export interface ManagedClusterSecurityProfileWorkloadIdentity {
    enabled?: boolean;
}

// @public
export interface ManagedClusterServicePrincipalProfile {
    clientId: string;
    secret?: string;
}

// @public
export interface ManagedClustersGetAccessProfileOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetAccessProfileResponse = ManagedClusterAccessProfile;

// @public
export interface ManagedClustersGetCommandResultHeaders {
    location?: string;
}

// @public
export interface ManagedClustersGetCommandResultOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetCommandResultResponse = RunCommandResult;

// @public
export interface ManagedClustersGetMeshRevisionProfileOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetMeshRevisionProfileResponse = MeshRevisionProfile;

// @public
export interface ManagedClustersGetMeshUpgradeProfileOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetMeshUpgradeProfileResponse = MeshUpgradeProfile;

// @public
export interface ManagedClustersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagedClustersGetOSOptionsOptionalParams extends coreClient.OperationOptions {
    resourceType?: string;
}

// @public
export type ManagedClustersGetOSOptionsResponse = OSOptionProfile;

// @public
export type ManagedClustersGetResponse = ManagedCluster;

// @public
export interface ManagedClustersGetUpgradeProfileOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersGetUpgradeProfileResponse = ManagedClusterUpgradeProfile;

// @public
export interface ManagedClusterSKU {
    name?: ManagedClusterSKUName;
    tier?: ManagedClusterSKUTier;
}

// @public
export type ManagedClusterSKUName = string;

// @public
export type ManagedClusterSKUTier = string;

// @public
export interface ManagedClustersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListByResourceGroupNextResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListByResourceGroupResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListClusterAdminCredentialsOptionalParams extends coreClient.OperationOptions {
    serverFqdn?: string;
}

// @public
export type ManagedClustersListClusterAdminCredentialsResponse = CredentialResults;

// @public
export interface ManagedClustersListClusterMonitoringUserCredentialsOptionalParams extends coreClient.OperationOptions {
    serverFqdn?: string;
}

// @public
export type ManagedClustersListClusterMonitoringUserCredentialsResponse = CredentialResults;

// @public
export interface ManagedClustersListClusterUserCredentialsOptionalParams extends coreClient.OperationOptions {
    format?: Format;
    serverFqdn?: string;
}

// @public
export type ManagedClustersListClusterUserCredentialsResponse = CredentialResults;

// @public
export interface ManagedClustersListKubernetesVersionsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListKubernetesVersionsResponse = KubernetesVersionListResult;

// @public
export interface ManagedClustersListMeshRevisionProfilesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListMeshRevisionProfilesNextResponse = MeshRevisionProfileList;

// @public
export interface ManagedClustersListMeshRevisionProfilesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListMeshRevisionProfilesResponse = MeshRevisionProfileList;

// @public
export interface ManagedClustersListMeshUpgradeProfilesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListMeshUpgradeProfilesNextResponse = MeshUpgradeProfileList;

// @public
export interface ManagedClustersListMeshUpgradeProfilesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListMeshUpgradeProfilesResponse = MeshUpgradeProfileList;

// @public
export interface ManagedClustersListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListNextResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagedClustersListOutboundNetworkDependenciesEndpointsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListOutboundNetworkDependenciesEndpointsNextResponse = OutboundEnvironmentEndpointCollection;

// @public
export interface ManagedClustersListOutboundNetworkDependenciesEndpointsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagedClustersListOutboundNetworkDependenciesEndpointsResponse = OutboundEnvironmentEndpointCollection;

// @public
export type ManagedClustersListResponse = ManagedClusterListResult;

// @public
export interface ManagedClustersResetAADProfileHeaders {
    location?: string;
}

// @public
export interface ManagedClustersResetAADProfileOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersResetServicePrincipalProfileHeaders {
    location?: string;
}

// @public
export interface ManagedClustersResetServicePrincipalProfileOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ManagedClustersRotateClusterCertificatesHeaders {
    location?: string;
}

// @public
export interface ManagedClustersRotateClusterCertificatesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersRotateClusterCertificatesResponse = ManagedClustersRotateClusterCertificatesHeaders;

// @public
export interface ManagedClustersRotateServiceAccountSigningKeysHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ManagedClustersRotateServiceAccountSigningKeysOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersRotateServiceAccountSigningKeysResponse = ManagedClustersRotateServiceAccountSigningKeysHeaders;

// @public
export interface ManagedClustersRunCommandHeaders {
    location?: string;
}

// @public
export interface ManagedClustersRunCommandOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersRunCommandResponse = RunCommandResult;

// @public
export interface ManagedClustersStartHeaders {
    location?: string;
}

// @public
export interface ManagedClustersStartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersStartResponse = ManagedClustersStartHeaders;

// @public
export interface ManagedClustersStopHeaders {
    location?: string;
}

// @public
export interface ManagedClustersStopOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersStopResponse = ManagedClustersStopHeaders;

// @public
export interface ManagedClusterStorageProfile {
    blobCSIDriver?: ManagedClusterStorageProfileBlobCSIDriver;
    diskCSIDriver?: ManagedClusterStorageProfileDiskCSIDriver;
    fileCSIDriver?: ManagedClusterStorageProfileFileCSIDriver;
    snapshotController?: ManagedClusterStorageProfileSnapshotController;
}

// @public
export interface ManagedClusterStorageProfileBlobCSIDriver {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStorageProfileDiskCSIDriver {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStorageProfileFileCSIDriver {
    enabled?: boolean;
}

// @public
export interface ManagedClusterStorageProfileSnapshotController {
    enabled?: boolean;
}

// @public
export interface ManagedClustersUpdateTagsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ManagedClustersUpdateTagsResponse = ManagedCluster;

// @public
export interface ManagedClusterUpgradeProfile {
    agentPoolProfiles: ManagedClusterPoolUpgradeProfile[];
    controlPlaneProfile: ManagedClusterPoolUpgradeProfile;
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface ManagedClusterWindowsProfile {
    adminPassword?: string;
    adminUsername: string;
    enableCSIProxy?: boolean;
    gmsaProfile?: WindowsGmsaProfile;
    licenseType?: LicenseType;
}

// @public
export interface ManagedClusterWorkloadAutoScalerProfile {
    keda?: ManagedClusterWorkloadAutoScalerProfileKeda;
    verticalPodAutoscaler?: ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler;
}

// @public
export interface ManagedClusterWorkloadAutoScalerProfileKeda {
    enabled: boolean;
}

// @public
export interface ManagedClusterWorkloadAutoScalerProfileVerticalPodAutoscaler {
    enabled: boolean;
}

// @public (undocumented)
export interface ManagedServiceIdentityUserAssignedIdentitiesValue {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface MeshRevision {
    compatibleWith?: CompatibleVersions[];
    revision?: string;
    upgrades?: string[];
}

// @public
export interface MeshRevisionProfile extends ProxyResource {
    properties?: MeshRevisionProfileProperties;
}

// @public
export interface MeshRevisionProfileList {
    readonly nextLink?: string;
    value?: MeshRevisionProfile[];
}

// @public
export interface MeshRevisionProfileProperties {
    // (undocumented)
    meshRevisions?: MeshRevision[];
}

// @public
export interface MeshUpgradeProfile extends ProxyResource {
    properties?: MeshUpgradeProfileProperties;
}

// @public
export interface MeshUpgradeProfileList {
    readonly nextLink?: string;
    value?: MeshUpgradeProfile[];
}

// @public
export interface MeshUpgradeProfileProperties extends MeshRevision {
}

// @public
export type NetworkDataplane = string;

// @public
export type NetworkMode = string;

// @public
export type NetworkPlugin = string;

// @public
export type NetworkPluginMode = string;

// @public
export type NetworkPolicy = string;

// @public
export type NodeOSUpgradeChannel = string;

// @public
export interface OperationListResult {
    readonly value?: OperationValue[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<OperationValue>;
}

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface OperationValue {
    readonly description?: string;
    readonly name?: string;
    readonly operation?: string;
    readonly origin?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export type OSDiskType = string;

// @public
export interface OSOptionProfile {
    readonly id?: string;
    readonly name?: string;
    osOptionPropertyList: OSOptionProperty[];
    readonly type?: string;
}

// @public
export interface OSOptionProperty {
    enableFipsImage: boolean;
    osType: string;
}

// @public
export type Ossku = string;

// @public
export type OSType = string;

// @public
export interface OutboundEnvironmentEndpoint {
    category?: string;
    endpoints?: EndpointDependency[];
}

// @public
export interface OutboundEnvironmentEndpointCollection {
    readonly nextLink?: string;
    value: OutboundEnvironmentEndpoint[];
}

// @public
export type OutboundType = string;

// @public
export interface PowerState {
    code?: Code;
}

// @public
export interface PrivateEndpoint {
    id?: string;
}

// @public
export interface PrivateEndpointConnection {
    readonly id?: string;
    readonly name?: string;
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
    readonly type?: string;
}

// @public
export interface PrivateEndpointConnectionListResult {
    value?: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export interface PrivateEndpointConnections {
    beginDelete(resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams): Promise<PrivateEndpointConnectionsGetResponse>;
    list(resourceGroupName: string, resourceName: string, options?: PrivateEndpointConnectionsListOptionalParams): Promise<PrivateEndpointConnectionsListResponse>;
    update(resourceGroupName: string, resourceName: string, privateEndpointConnectionName: string, parameters: PrivateEndpointConnection, options?: PrivateEndpointConnectionsUpdateOptionalParams): Promise<PrivateEndpointConnectionsUpdateResponse>;
}

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult;

// @public
export interface PrivateEndpointConnectionsUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsUpdateResponse = PrivateEndpointConnection;

// @public
export interface PrivateLinkResource {
    groupId?: string;
    id?: string;
    name?: string;
    readonly privateLinkServiceID?: string;
    requiredMembers?: string[];
    type?: string;
}

// @public
export interface PrivateLinkResources {
    list(resourceGroupName: string, resourceName: string, options?: PrivateLinkResourcesListOptionalParams): Promise<PrivateLinkResourcesListResponse>;
}

// @public
export interface PrivateLinkResourcesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateLinkResourcesListResponse = PrivateLinkResourcesListResult;

// @public
export interface PrivateLinkResourcesListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkServiceConnectionState {
    description?: string;
    status?: ConnectionStatus;
}

// @public
export interface ProxyResource extends Resource {
}

// @public
export type PublicNetworkAccess = string;

// @public
export interface RelativeMonthlySchedule {
    dayOfWeek: WeekDay;
    intervalMonths: number;
    weekIndex: Type;
}

// @public
export interface ResolvePrivateLinkServiceId {
    post(resourceGroupName: string, resourceName: string, parameters: PrivateLinkResource, options?: ResolvePrivateLinkServiceIdPostOptionalParams): Promise<ResolvePrivateLinkServiceIdPostResponse>;
}

// @public
export interface ResolvePrivateLinkServiceIdPostOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ResolvePrivateLinkServiceIdPostResponse = PrivateLinkResource;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export type ResourceIdentityType = "SystemAssigned" | "UserAssigned" | "None";

// @public
export interface ResourceReference {
    id?: string;
}

// @public
export interface RunCommandRequest {
    clusterToken?: string;
    command: string;
    context?: string;
}

// @public
export interface RunCommandResult {
    readonly exitCode?: number;
    readonly finishedAt?: Date;
    readonly id?: string;
    readonly logs?: string;
    readonly provisioningState?: string;
    readonly reason?: string;
    readonly startedAt?: Date;
}

// @public
export type ScaleDownMode = string;

// @public
export type ScaleSetEvictionPolicy = string;

// @public
export type ScaleSetPriority = string;

// @public
export interface Schedule {
    absoluteMonthly?: AbsoluteMonthlySchedule;
    daily?: DailySchedule;
    relativeMonthly?: RelativeMonthlySchedule;
    weekly?: WeeklySchedule;
}

// @public
export type ServiceMeshMode = string;

// @public
export interface ServiceMeshProfile {
    istio?: IstioServiceMesh;
    mode: ServiceMeshMode;
}

// @public
export interface Snapshot extends TrackedResource {
    creationData?: CreationData;
    readonly enableFips?: boolean;
    readonly kubernetesVersion?: string;
    readonly nodeImageVersion?: string;
    readonly osSku?: Ossku;
    readonly osType?: OSType;
    snapshotType?: SnapshotType;
    readonly vmSize?: string;
}

// @public
export interface SnapshotListResult {
    readonly nextLink?: string;
    value?: Snapshot[];
}

// @public
export interface Snapshots {
    createOrUpdate(resourceGroupName: string, resourceName: string, parameters: Snapshot, options?: SnapshotsCreateOrUpdateOptionalParams): Promise<SnapshotsCreateOrUpdateResponse>;
    delete(resourceGroupName: string, resourceName: string, options?: SnapshotsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, resourceName: string, options?: SnapshotsGetOptionalParams): Promise<SnapshotsGetResponse>;
    list(options?: SnapshotsListOptionalParams): PagedAsyncIterableIterator<Snapshot>;
    listByResourceGroup(resourceGroupName: string, options?: SnapshotsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Snapshot>;
    updateTags(resourceGroupName: string, resourceName: string, parameters: TagsObject, options?: SnapshotsUpdateTagsOptionalParams): Promise<SnapshotsUpdateTagsResponse>;
}

// @public
export interface SnapshotsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsCreateOrUpdateResponse = Snapshot;

// @public
export interface SnapshotsDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface SnapshotsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsGetResponse = Snapshot;

// @public
export interface SnapshotsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListByResourceGroupNextResponse = SnapshotListResult;

// @public
export interface SnapshotsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListByResourceGroupResponse = SnapshotListResult;

// @public
export interface SnapshotsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListNextResponse = SnapshotListResult;

// @public
export interface SnapshotsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListResponse = SnapshotListResult;

// @public
export interface SnapshotsUpdateTagsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsUpdateTagsResponse = Snapshot;

// @public
export type SnapshotType = string;

// @public
export interface SubResource {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface SysctlConfig {
    fsAioMaxNr?: number;
    fsFileMax?: number;
    fsInotifyMaxUserWatches?: number;
    fsNrOpen?: number;
    kernelThreadsMax?: number;
    netCoreNetdevMaxBacklog?: number;
    netCoreOptmemMax?: number;
    netCoreRmemDefault?: number;
    netCoreRmemMax?: number;
    netCoreSomaxconn?: number;
    netCoreWmemDefault?: number;
    netCoreWmemMax?: number;
    netIpv4IpLocalPortRange?: string;
    netIpv4NeighDefaultGcThresh1?: number;
    netIpv4NeighDefaultGcThresh2?: number;
    netIpv4NeighDefaultGcThresh3?: number;
    netIpv4TcpFinTimeout?: number;
    netIpv4TcpkeepaliveIntvl?: number;
    netIpv4TcpKeepaliveProbes?: number;
    netIpv4TcpKeepaliveTime?: number;
    netIpv4TcpMaxSynBacklog?: number;
    netIpv4TcpMaxTwBuckets?: number;
    netIpv4TcpTwReuse?: boolean;
    netNetfilterNfConntrackBuckets?: number;
    netNetfilterNfConntrackMax?: number;
    vmMaxMapCount?: number;
    vmSwappiness?: number;
    vmVfsCachePressure?: number;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TagsObject {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface TimeInWeek {
    day?: WeekDay;
    hourSlots?: number[];
}

// @public
export interface TimeSpan {
    end?: Date;
    start?: Date;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type Type = string;

// @public
export type UpgradeChannel = string;

// @public
export interface UpgradeOverrideSettings {
    forceUpgrade?: boolean;
    until?: Date;
}

// @public
export interface UserAssignedIdentity {
    clientId?: string;
    objectId?: string;
    resourceId?: string;
}

// @public
export type WeekDay = string;

// @public
export interface WeeklySchedule {
    dayOfWeek: WeekDay;
    intervalWeeks: number;
}

// @public
export interface WindowsGmsaProfile {
    dnsServer?: string;
    enabled?: boolean;
    rootDomainName?: string;
}

// @public
export type WorkloadRuntime = string;

// (No @packageDocumentation comment for this package)

```
