## API Report File for "@azure/arm-networkcloud"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

// @public
export interface AadConfiguration {
    adminGroupObjectIds: string[];
}

// @public
export type ActionType = string;

// @public
export interface AdministrativeCredentials {
    password: string;
    username: string;
}

// @public
export interface AdministratorConfiguration {
    adminUsername?: string;
    sshPublicKeys?: SshPublicKey[];
}

// @public
export interface AdministratorConfigurationPatch {
    sshPublicKeys?: SshPublicKey[];
}

// @public
export type AdvertiseToFabric = string;

// @public
export interface AgentOptions {
    hugepagesCount: number;
    hugepagesSize?: HugepagesSize;
}

// @public
export interface AgentPool extends TrackedResource {
    administratorConfiguration?: AdministratorConfiguration;
    agentOptions?: AgentOptions;
    attachedNetworkConfiguration?: AttachedNetworkConfiguration;
    availabilityZones?: string[];
    count: number;
    readonly detailedStatus?: AgentPoolDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation?: ExtendedLocation;
    readonly kubernetesVersion?: string;
    labels?: KubernetesLabel[];
    mode: AgentPoolMode;
    readonly provisioningState?: AgentPoolProvisioningState;
    taints?: KubernetesLabel[];
    upgradeSettings?: AgentPoolUpgradeSettings;
    vmSkuName: string;
}

// @public
export interface AgentPoolConfiguration {
    administratorConfiguration?: AdministratorConfiguration;
    agentOptions?: AgentOptions;
    attachedNetworkConfiguration?: AttachedNetworkConfiguration;
    availabilityZones?: string[];
    count: number;
    labels?: KubernetesLabel[];
    mode: AgentPoolMode;
    taints?: KubernetesLabel[];
    upgradeSettings?: AgentPoolUpgradeSettings;
    vmSkuName: string;
}

// @public
export type AgentPoolDetailedStatus = string;

// @public
export interface AgentPoolList {
    nextLink?: string;
    value?: AgentPool[];
}

// @public
export type AgentPoolMode = string;

// @public
export interface AgentPoolPatchParameters {
    administratorConfiguration?: NodePoolAdministratorConfigurationPatch;
    count?: number;
    tags?: {
        [propertyName: string]: string;
    };
    upgradeSettings?: AgentPoolUpgradeSettings;
}

// @public
export type AgentPoolProvisioningState = string;

// @public
export interface AgentPools {
    beginCreateOrUpdate(resourceGroupName: string, kubernetesClusterName: string, agentPoolName: string, agentPoolParameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsCreateOrUpdateResponse>, AgentPoolsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, kubernetesClusterName: string, agentPoolName: string, agentPoolParameters: AgentPool, options?: AgentPoolsCreateOrUpdateOptionalParams): Promise<AgentPoolsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, kubernetesClusterName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsDeleteResponse>, AgentPoolsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, kubernetesClusterName: string, agentPoolName: string, options?: AgentPoolsDeleteOptionalParams): Promise<AgentPoolsDeleteResponse>;
    beginUpdate(resourceGroupName: string, kubernetesClusterName: string, agentPoolName: string, options?: AgentPoolsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<AgentPoolsUpdateResponse>, AgentPoolsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, kubernetesClusterName: string, agentPoolName: string, options?: AgentPoolsUpdateOptionalParams): Promise<AgentPoolsUpdateResponse>;
    get(resourceGroupName: string, kubernetesClusterName: string, agentPoolName: string, options?: AgentPoolsGetOptionalParams): Promise<AgentPoolsGetResponse>;
    listByKubernetesCluster(resourceGroupName: string, kubernetesClusterName: string, options?: AgentPoolsListByKubernetesClusterOptionalParams): PagedAsyncIterableIterator<AgentPool>;
}

// @public
export interface AgentPoolsCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface AgentPoolsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsCreateOrUpdateResponse = AgentPool;

// @public
export interface AgentPoolsDeleteHeaders {
    location?: string;
}

// @public
export interface AgentPoolsDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsDeleteResponse = OperationStatusResult;

// @public
export interface AgentPoolsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsGetResponse = AgentPool;

// @public
export interface AgentPoolsListByKubernetesClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsListByKubernetesClusterNextResponse = AgentPoolList;

// @public
export interface AgentPoolsListByKubernetesClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AgentPoolsListByKubernetesClusterResponse = AgentPoolList;

// @public
export interface AgentPoolsUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface AgentPoolsUpdateOptionalParams extends coreClient.OperationOptions {
    agentPoolUpdateParameters?: AgentPoolPatchParameters;
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AgentPoolsUpdateResponse = AgentPool;

// @public
export interface AgentPoolUpgradeSettings {
    drainTimeout?: number;
    maxSurge?: string;
    maxUnavailable?: string;
}

// @public
export interface AnalyticsOutputSettings {
    analyticsWorkspaceId?: string;
    associatedIdentity?: IdentitySelector;
}

// @public
export interface AttachedNetworkConfiguration {
    l2Networks?: L2NetworkAttachmentConfiguration[];
    l3Networks?: L3NetworkAttachmentConfiguration[];
    trunkedNetworks?: TrunkedNetworkAttachmentConfiguration[];
}

// @public
export type AvailabilityLifecycle = string;

// @public
export interface AvailableUpgrade {
    readonly availabilityLifecycle?: AvailabilityLifecycle;
    readonly version?: string;
}

// @public
export interface BareMetalMachine extends TrackedResource {
    readonly associatedResourceIds?: string[];
    bmcConnectionString: string;
    bmcCredentials: AdministrativeCredentials;
    bmcMacAddress: string;
    bootMacAddress: string;
    readonly clusterId?: string;
    readonly cordonStatus?: BareMetalMachineCordonStatus;
    readonly detailedStatus?: BareMetalMachineDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly hardwareInventory?: HardwareInventory;
    readonly hardwareValidationStatus?: HardwareValidationStatus;
    readonly hybridAksClustersAssociatedIds?: string[];
    readonly kubernetesNodeName?: string;
    readonly kubernetesVersion?: string;
    machineClusterVersion?: string;
    machineDetails: string;
    machineName: string;
    readonly machineRoles?: string[];
    machineSkuId: string;
    readonly oamIpv4Address?: string;
    readonly oamIpv6Address?: string;
    readonly osImage?: string;
    readonly powerState?: BareMetalMachinePowerState;
    readonly provisioningState?: BareMetalMachineProvisioningState;
    rackId: string;
    rackSlot: number;
    readonly readyState?: BareMetalMachineReadyState;
    readonly runtimeProtectionStatus?: RuntimeProtectionStatus;
    readonly secretRotationStatus?: SecretRotationStatus[];
    serialNumber: string;
    readonly serviceTag?: string;
    readonly virtualMachinesAssociatedIds?: string[];
}

// @public
export interface BareMetalMachineCommandSpecification {
    arguments?: string[];
    command: string;
}

// @public
export interface BareMetalMachineConfigurationData {
    readonly bmcConnectionString?: string;
    bmcCredentials: AdministrativeCredentials;
    bmcMacAddress: string;
    bootMacAddress: string;
    machineDetails?: string;
    machineName?: string;
    rackSlot: number;
    serialNumber: string;
}

// @public
export interface BareMetalMachineCordonParameters {
    evacuate?: BareMetalMachineEvacuate;
}

// @public
export type BareMetalMachineCordonStatus = string;

// @public
export type BareMetalMachineDetailedStatus = string;

// @public
export type BareMetalMachineEvacuate = string;

// @public
export type BareMetalMachineHardwareValidationResult = string;

// @public
export interface BareMetalMachineKeySet extends TrackedResource {
    azureGroupId: string;
    readonly detailedStatus?: BareMetalMachineKeySetDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    expiration: Date;
    extendedLocation: ExtendedLocation;
    jumpHostsAllowed: string[];
    readonly lastValidation?: Date;
    osGroupName?: string;
    privilegeLevel: BareMetalMachineKeySetPrivilegeLevel;
    readonly provisioningState?: BareMetalMachineKeySetProvisioningState;
    userList: KeySetUser[];
    readonly userListStatus?: KeySetUserStatus[];
}

// @public
export type BareMetalMachineKeySetDetailedStatus = string;

// @public
export interface BareMetalMachineKeySetList {
    nextLink?: string;
    value?: BareMetalMachineKeySet[];
}

// @public
export interface BareMetalMachineKeySetPatchParameters {
    expiration?: Date;
    jumpHostsAllowed?: string[];
    tags?: {
        [propertyName: string]: string;
    };
    userList?: KeySetUser[];
}

// @public
export type BareMetalMachineKeySetPrivilegeLevel = string;

// @public
export type BareMetalMachineKeySetProvisioningState = string;

// @public
export interface BareMetalMachineKeySets {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, bareMetalMachineKeySetName: string, bareMetalMachineKeySetParameters: BareMetalMachineKeySet, options?: BareMetalMachineKeySetsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachineKeySetsCreateOrUpdateResponse>, BareMetalMachineKeySetsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, bareMetalMachineKeySetName: string, bareMetalMachineKeySetParameters: BareMetalMachineKeySet, options?: BareMetalMachineKeySetsCreateOrUpdateOptionalParams): Promise<BareMetalMachineKeySetsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, bareMetalMachineKeySetName: string, options?: BareMetalMachineKeySetsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachineKeySetsDeleteResponse>, BareMetalMachineKeySetsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, bareMetalMachineKeySetName: string, options?: BareMetalMachineKeySetsDeleteOptionalParams): Promise<BareMetalMachineKeySetsDeleteResponse>;
    beginUpdate(resourceGroupName: string, clusterName: string, bareMetalMachineKeySetName: string, options?: BareMetalMachineKeySetsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachineKeySetsUpdateResponse>, BareMetalMachineKeySetsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, clusterName: string, bareMetalMachineKeySetName: string, options?: BareMetalMachineKeySetsUpdateOptionalParams): Promise<BareMetalMachineKeySetsUpdateResponse>;
    get(resourceGroupName: string, clusterName: string, bareMetalMachineKeySetName: string, options?: BareMetalMachineKeySetsGetOptionalParams): Promise<BareMetalMachineKeySetsGetResponse>;
    listByCluster(resourceGroupName: string, clusterName: string, options?: BareMetalMachineKeySetsListByClusterOptionalParams): PagedAsyncIterableIterator<BareMetalMachineKeySet>;
}

// @public
export interface BareMetalMachineKeySetsCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface BareMetalMachineKeySetsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachineKeySetsCreateOrUpdateResponse = BareMetalMachineKeySet;

// @public
export interface BareMetalMachineKeySetsDeleteHeaders {
    location?: string;
}

// @public
export interface BareMetalMachineKeySetsDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachineKeySetsDeleteResponse = OperationStatusResult;

// @public
export interface BareMetalMachineKeySetsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BareMetalMachineKeySetsGetResponse = BareMetalMachineKeySet;

// @public
export interface BareMetalMachineKeySetsListByClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BareMetalMachineKeySetsListByClusterNextResponse = BareMetalMachineKeySetList;

// @public
export interface BareMetalMachineKeySetsListByClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BareMetalMachineKeySetsListByClusterResponse = BareMetalMachineKeySetList;

// @public
export interface BareMetalMachineKeySetsUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface BareMetalMachineKeySetsUpdateOptionalParams extends coreClient.OperationOptions {
    bareMetalMachineKeySetUpdateParameters?: BareMetalMachineKeySetPatchParameters;
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachineKeySetsUpdateResponse = BareMetalMachineKeySet;

// @public
export type BareMetalMachineKeySetUserSetupStatus = string;

// @public
export interface BareMetalMachineList {
    nextLink?: string;
    value?: BareMetalMachine[];
}

// @public
export interface BareMetalMachinePatchParameters {
    machineDetails?: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface BareMetalMachinePowerOffParameters {
    skipShutdown?: BareMetalMachineSkipShutdown;
}

// @public
export type BareMetalMachinePowerState = string;

// @public
export type BareMetalMachineProvisioningState = string;

// @public
export type BareMetalMachineReadyState = string;

// @public
export interface BareMetalMachineReplaceParameters {
    bmcCredentials?: AdministrativeCredentials;
    bmcMacAddress?: string;
    bootMacAddress?: string;
    machineName?: string;
    serialNumber?: string;
}

// @public
export interface BareMetalMachineRunCommandParameters {
    arguments?: string[];
    limitTimeSeconds: number;
    script: string;
}

// @public
export interface BareMetalMachineRunDataExtractsParameters {
    commands: BareMetalMachineCommandSpecification[];
    limitTimeSeconds: number;
}

// @public
export interface BareMetalMachineRunReadCommandsParameters {
    commands: BareMetalMachineCommandSpecification[];
    limitTimeSeconds: number;
}

// @public
export interface BareMetalMachines {
    beginCordon(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesCordonOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesCordonResponse>, BareMetalMachinesCordonResponse>>;
    beginCordonAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesCordonOptionalParams): Promise<BareMetalMachinesCordonResponse>;
    beginCreateOrUpdate(resourceGroupName: string, bareMetalMachineName: string, bareMetalMachineParameters: BareMetalMachine, options?: BareMetalMachinesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesCreateOrUpdateResponse>, BareMetalMachinesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, bareMetalMachineName: string, bareMetalMachineParameters: BareMetalMachine, options?: BareMetalMachinesCreateOrUpdateOptionalParams): Promise<BareMetalMachinesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesDeleteResponse>, BareMetalMachinesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesDeleteOptionalParams): Promise<BareMetalMachinesDeleteResponse>;
    beginPowerOff(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesPowerOffOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesPowerOffResponse>, BareMetalMachinesPowerOffResponse>>;
    beginPowerOffAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesPowerOffOptionalParams): Promise<BareMetalMachinesPowerOffResponse>;
    beginReimage(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesReimageOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesReimageResponse>, BareMetalMachinesReimageResponse>>;
    beginReimageAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesReimageOptionalParams): Promise<BareMetalMachinesReimageResponse>;
    beginReplace(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesReplaceOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesReplaceResponse>, BareMetalMachinesReplaceResponse>>;
    beginReplaceAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesReplaceOptionalParams): Promise<BareMetalMachinesReplaceResponse>;
    beginRestart(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesRestartOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesRestartResponse>, BareMetalMachinesRestartResponse>>;
    beginRestartAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesRestartOptionalParams): Promise<BareMetalMachinesRestartResponse>;
    beginRunCommand(resourceGroupName: string, bareMetalMachineName: string, bareMetalMachineRunCommandParameters: BareMetalMachineRunCommandParameters, options?: BareMetalMachinesRunCommandOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesRunCommandResponse>, BareMetalMachinesRunCommandResponse>>;
    beginRunCommandAndWait(resourceGroupName: string, bareMetalMachineName: string, bareMetalMachineRunCommandParameters: BareMetalMachineRunCommandParameters, options?: BareMetalMachinesRunCommandOptionalParams): Promise<BareMetalMachinesRunCommandResponse>;
    beginRunDataExtracts(resourceGroupName: string, bareMetalMachineName: string, bareMetalMachineRunDataExtractsParameters: BareMetalMachineRunDataExtractsParameters, options?: BareMetalMachinesRunDataExtractsOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesRunDataExtractsResponse>, BareMetalMachinesRunDataExtractsResponse>>;
    beginRunDataExtractsAndWait(resourceGroupName: string, bareMetalMachineName: string, bareMetalMachineRunDataExtractsParameters: BareMetalMachineRunDataExtractsParameters, options?: BareMetalMachinesRunDataExtractsOptionalParams): Promise<BareMetalMachinesRunDataExtractsResponse>;
    beginRunReadCommands(resourceGroupName: string, bareMetalMachineName: string, bareMetalMachineRunReadCommandsParameters: BareMetalMachineRunReadCommandsParameters, options?: BareMetalMachinesRunReadCommandsOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesRunReadCommandsResponse>, BareMetalMachinesRunReadCommandsResponse>>;
    beginRunReadCommandsAndWait(resourceGroupName: string, bareMetalMachineName: string, bareMetalMachineRunReadCommandsParameters: BareMetalMachineRunReadCommandsParameters, options?: BareMetalMachinesRunReadCommandsOptionalParams): Promise<BareMetalMachinesRunReadCommandsResponse>;
    beginStart(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesStartOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesStartResponse>, BareMetalMachinesStartResponse>>;
    beginStartAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesStartOptionalParams): Promise<BareMetalMachinesStartResponse>;
    beginUncordon(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesUncordonOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesUncordonResponse>, BareMetalMachinesUncordonResponse>>;
    beginUncordonAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesUncordonOptionalParams): Promise<BareMetalMachinesUncordonResponse>;
    beginUpdate(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<BareMetalMachinesUpdateResponse>, BareMetalMachinesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesUpdateOptionalParams): Promise<BareMetalMachinesUpdateResponse>;
    get(resourceGroupName: string, bareMetalMachineName: string, options?: BareMetalMachinesGetOptionalParams): Promise<BareMetalMachinesGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: BareMetalMachinesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<BareMetalMachine>;
    listBySubscription(options?: BareMetalMachinesListBySubscriptionOptionalParams): PagedAsyncIterableIterator<BareMetalMachine>;
}

// @public
export interface BareMetalMachinesCordonHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesCordonOptionalParams extends coreClient.OperationOptions {
    bareMetalMachineCordonParameters?: BareMetalMachineCordonParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesCordonResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface BareMetalMachinesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesCreateOrUpdateResponse = BareMetalMachine;

// @public
export interface BareMetalMachinesDeleteHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesDeleteResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BareMetalMachinesGetResponse = BareMetalMachine;

// @public
export type BareMetalMachineSkipShutdown = string;

// @public
export interface BareMetalMachinesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BareMetalMachinesListByResourceGroupNextResponse = BareMetalMachineList;

// @public
export interface BareMetalMachinesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BareMetalMachinesListByResourceGroupResponse = BareMetalMachineList;

// @public
export interface BareMetalMachinesListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BareMetalMachinesListBySubscriptionNextResponse = BareMetalMachineList;

// @public
export interface BareMetalMachinesListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BareMetalMachinesListBySubscriptionResponse = BareMetalMachineList;

// @public
export interface BareMetalMachinesPowerOffHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesPowerOffOptionalParams extends coreClient.OperationOptions {
    bareMetalMachinePowerOffParameters?: BareMetalMachinePowerOffParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesPowerOffResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesReimageHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesReimageOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesReimageResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesReplaceHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesReplaceOptionalParams extends coreClient.OperationOptions {
    bareMetalMachineReplaceParameters?: BareMetalMachineReplaceParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesReplaceResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesRestartHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesRestartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesRestartResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesRunCommandHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesRunCommandOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesRunCommandResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesRunDataExtractsHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesRunDataExtractsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesRunDataExtractsResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesRunReadCommandsHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesRunReadCommandsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesRunReadCommandsResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesStartHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesStartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesStartResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesUncordonHeaders {
    location?: string;
}

// @public
export interface BareMetalMachinesUncordonOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesUncordonResponse = OperationStatusResult;

// @public
export interface BareMetalMachinesUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface BareMetalMachinesUpdateOptionalParams extends coreClient.OperationOptions {
    bareMetalMachineUpdateParameters?: BareMetalMachinePatchParameters;
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BareMetalMachinesUpdateResponse = BareMetalMachine;

// @public
export type BfdEnabled = string;

// @public
export interface BgpAdvertisement {
    advertiseToFabric?: AdvertiseToFabric;
    communities?: string[];
    ipAddressPools: string[];
    peers?: string[];
}

// @public
export type BgpMultiHop = string;

// @public
export interface BgpServiceLoadBalancerConfiguration {
    bgpAdvertisements?: BgpAdvertisement[];
    bgpPeers?: ServiceLoadBalancerBgpPeer[];
    fabricPeeringEnabled?: FabricPeeringEnabled;
    ipAddressPools?: IpAddressPool[];
}

// @public
export interface BmcKeySet extends TrackedResource {
    azureGroupId: string;
    readonly detailedStatus?: BmcKeySetDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    expiration: Date;
    extendedLocation: ExtendedLocation;
    readonly lastValidation?: Date;
    privilegeLevel: BmcKeySetPrivilegeLevel;
    readonly provisioningState?: BmcKeySetProvisioningState;
    userList: KeySetUser[];
    readonly userListStatus?: KeySetUserStatus[];
}

// @public
export type BmcKeySetDetailedStatus = string;

// @public
export interface BmcKeySetList {
    nextLink?: string;
    value?: BmcKeySet[];
}

// @public
export interface BmcKeySetPatchParameters {
    expiration?: Date;
    tags?: {
        [propertyName: string]: string;
    };
    userList?: KeySetUser[];
}

// @public
export type BmcKeySetPrivilegeLevel = string;

// @public
export type BmcKeySetProvisioningState = string;

// @public
export interface BmcKeySets {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, bmcKeySetName: string, bmcKeySetParameters: BmcKeySet, options?: BmcKeySetsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<BmcKeySetsCreateOrUpdateResponse>, BmcKeySetsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, bmcKeySetName: string, bmcKeySetParameters: BmcKeySet, options?: BmcKeySetsCreateOrUpdateOptionalParams): Promise<BmcKeySetsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, bmcKeySetName: string, options?: BmcKeySetsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<BmcKeySetsDeleteResponse>, BmcKeySetsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, bmcKeySetName: string, options?: BmcKeySetsDeleteOptionalParams): Promise<BmcKeySetsDeleteResponse>;
    beginUpdate(resourceGroupName: string, clusterName: string, bmcKeySetName: string, options?: BmcKeySetsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<BmcKeySetsUpdateResponse>, BmcKeySetsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, clusterName: string, bmcKeySetName: string, options?: BmcKeySetsUpdateOptionalParams): Promise<BmcKeySetsUpdateResponse>;
    get(resourceGroupName: string, clusterName: string, bmcKeySetName: string, options?: BmcKeySetsGetOptionalParams): Promise<BmcKeySetsGetResponse>;
    listByCluster(resourceGroupName: string, clusterName: string, options?: BmcKeySetsListByClusterOptionalParams): PagedAsyncIterableIterator<BmcKeySet>;
}

// @public
export interface BmcKeySetsCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface BmcKeySetsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BmcKeySetsCreateOrUpdateResponse = BmcKeySet;

// @public
export interface BmcKeySetsDeleteHeaders {
    location?: string;
}

// @public
export interface BmcKeySetsDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BmcKeySetsDeleteResponse = OperationStatusResult;

// @public
export interface BmcKeySetsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BmcKeySetsGetResponse = BmcKeySet;

// @public
export interface BmcKeySetsListByClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BmcKeySetsListByClusterNextResponse = BmcKeySetList;

// @public
export interface BmcKeySetsListByClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BmcKeySetsListByClusterResponse = BmcKeySetList;

// @public
export interface BmcKeySetsUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface BmcKeySetsUpdateOptionalParams extends coreClient.OperationOptions {
    bmcKeySetUpdateParameters?: BmcKeySetPatchParameters;
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BmcKeySetsUpdateResponse = BmcKeySet;

// @public
export type BootstrapProtocol = string;

// @public
export interface CloudServicesNetwork extends TrackedResource {
    additionalEgressEndpoints?: EgressEndpoint[];
    readonly associatedResourceIds?: string[];
    readonly clusterId?: string;
    readonly detailedStatus?: CloudServicesNetworkDetailedStatus;
    readonly detailedStatusMessage?: string;
    enableDefaultEgressEndpoints?: CloudServicesNetworkEnableDefaultEgressEndpoints;
    readonly enabledEgressEndpoints?: EgressEndpoint[];
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly hybridAksClustersAssociatedIds?: string[];
    readonly interfaceName?: string;
    readonly provisioningState?: CloudServicesNetworkProvisioningState;
    readonly virtualMachinesAssociatedIds?: string[];
}

// @public
export type CloudServicesNetworkDetailedStatus = string;

// @public
export type CloudServicesNetworkEnableDefaultEgressEndpoints = string;

// @public
export interface CloudServicesNetworkList {
    nextLink?: string;
    value?: CloudServicesNetwork[];
}

// @public
export interface CloudServicesNetworkPatchParameters {
    additionalEgressEndpoints?: EgressEndpoint[];
    enableDefaultEgressEndpoints?: CloudServicesNetworkEnableDefaultEgressEndpoints;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type CloudServicesNetworkProvisioningState = string;

// @public
export interface CloudServicesNetworks {
    beginCreateOrUpdate(resourceGroupName: string, cloudServicesNetworkName: string, cloudServicesNetworkParameters: CloudServicesNetwork, options?: CloudServicesNetworksCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<CloudServicesNetworksCreateOrUpdateResponse>, CloudServicesNetworksCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, cloudServicesNetworkName: string, cloudServicesNetworkParameters: CloudServicesNetwork, options?: CloudServicesNetworksCreateOrUpdateOptionalParams): Promise<CloudServicesNetworksCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, cloudServicesNetworkName: string, options?: CloudServicesNetworksDeleteOptionalParams): Promise<SimplePollerLike<OperationState<CloudServicesNetworksDeleteResponse>, CloudServicesNetworksDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, cloudServicesNetworkName: string, options?: CloudServicesNetworksDeleteOptionalParams): Promise<CloudServicesNetworksDeleteResponse>;
    beginUpdate(resourceGroupName: string, cloudServicesNetworkName: string, options?: CloudServicesNetworksUpdateOptionalParams): Promise<SimplePollerLike<OperationState<CloudServicesNetworksUpdateResponse>, CloudServicesNetworksUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, cloudServicesNetworkName: string, options?: CloudServicesNetworksUpdateOptionalParams): Promise<CloudServicesNetworksUpdateResponse>;
    get(resourceGroupName: string, cloudServicesNetworkName: string, options?: CloudServicesNetworksGetOptionalParams): Promise<CloudServicesNetworksGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: CloudServicesNetworksListByResourceGroupOptionalParams): PagedAsyncIterableIterator<CloudServicesNetwork>;
    listBySubscription(options?: CloudServicesNetworksListBySubscriptionOptionalParams): PagedAsyncIterableIterator<CloudServicesNetwork>;
}

// @public
export interface CloudServicesNetworksCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface CloudServicesNetworksCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CloudServicesNetworksCreateOrUpdateResponse = CloudServicesNetwork;

// @public
export interface CloudServicesNetworksDeleteHeaders {
    location?: string;
}

// @public
export interface CloudServicesNetworksDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CloudServicesNetworksDeleteResponse = OperationStatusResult;

// @public
export interface CloudServicesNetworksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CloudServicesNetworksGetResponse = CloudServicesNetwork;

// @public
export interface CloudServicesNetworksListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CloudServicesNetworksListByResourceGroupNextResponse = CloudServicesNetworkList;

// @public
export interface CloudServicesNetworksListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CloudServicesNetworksListByResourceGroupResponse = CloudServicesNetworkList;

// @public
export interface CloudServicesNetworksListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CloudServicesNetworksListBySubscriptionNextResponse = CloudServicesNetworkList;

// @public
export interface CloudServicesNetworksListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CloudServicesNetworksListBySubscriptionResponse = CloudServicesNetworkList;

// @public
export interface CloudServicesNetworksUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface CloudServicesNetworksUpdateOptionalParams extends coreClient.OperationOptions {
    cloudServicesNetworkUpdateParameters?: CloudServicesNetworkPatchParameters;
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CloudServicesNetworksUpdateResponse = CloudServicesNetwork;

// @public
export interface Cluster extends TrackedResource {
    aggregatorOrSingleRackDefinition: RackDefinition;
    analyticsOutputSettings?: AnalyticsOutputSettings;
    analyticsWorkspaceId?: string;
    readonly availableUpgradeVersions?: ClusterAvailableUpgradeVersion[];
    readonly clusterCapacity?: ClusterCapacity;
    readonly clusterConnectionStatus?: ClusterConnectionStatus;
    readonly clusterExtendedLocation?: ExtendedLocation;
    clusterLocation?: string;
    readonly clusterManagerConnectionStatus?: ClusterManagerConnectionStatus;
    readonly clusterManagerId?: string;
    clusterServicePrincipal?: ServicePrincipalInformation;
    clusterType: ClusterType;
    clusterVersion: string;
    commandOutputSettings?: CommandOutputSettings;
    computeDeploymentThreshold?: ValidationThreshold;
    computeRackDefinitions?: RackDefinition[];
    readonly detailedStatus?: ClusterDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly hybridAksExtendedLocation?: ExtendedLocation;
    identity?: ManagedServiceIdentity;
    managedResourceGroupConfiguration?: ManagedResourceGroupConfiguration;
    readonly manualActionCount?: number;
    networkFabricId: string;
    readonly provisioningState?: ClusterProvisioningState;
    runtimeProtectionConfiguration?: RuntimeProtectionConfiguration;
    secretArchive?: ClusterSecretArchive;
    secretArchiveSettings?: SecretArchiveSettings;
    readonly supportExpiryDate?: string;
    updateStrategy?: ClusterUpdateStrategy;
    vulnerabilityScanningSettings?: VulnerabilityScanningSettings;
    readonly workloadResourceIds?: string[];
}

// @public
export interface ClusterAvailableUpgradeVersion {
    readonly controlImpact?: ControlImpact;
    readonly expectedDuration?: string;
    readonly impactDescription?: string;
    readonly supportExpiryDate?: string;
    readonly targetClusterVersion?: string;
    readonly workloadImpact?: WorkloadImpact;
}

// @public
export interface ClusterAvailableVersion {
    readonly supportExpiryDate?: string;
    readonly targetClusterVersion?: string;
}

// @public
export interface ClusterCapacity {
    availableApplianceStorageGB?: number;
    availableCoreCount?: number;
    availableHostStorageGB?: number;
    availableMemoryGB?: number;
    totalApplianceStorageGB?: number;
    totalCoreCount?: number;
    totalHostStorageGB?: number;
    totalMemoryGB?: number;
}

// @public
export type ClusterConnectionStatus = string;

// @public
export type ClusterContinueUpdateVersionMachineGroupTargetingMode = string;

// @public
export interface ClusterContinueUpdateVersionParameters {
    machineGroupTargetingMode?: ClusterContinueUpdateVersionMachineGroupTargetingMode;
}

// @public
export interface ClusterDeployParameters {
    skipValidationsForMachines?: string[];
}

// @public
export type ClusterDetailedStatus = string;

// @public
export interface ClusterList {
    nextLink?: string;
    value?: Cluster[];
}

// @public
export interface ClusterManager extends TrackedResource {
    analyticsWorkspaceId?: string;
    availabilityZones?: string[];
    readonly clusterVersions?: ClusterAvailableVersion[];
    readonly detailedStatus?: ClusterManagerDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    fabricControllerId: string;
    identity?: ManagedServiceIdentity;
    managedResourceGroupConfiguration?: ManagedResourceGroupConfiguration;
    readonly managerExtendedLocation?: ExtendedLocation;
    readonly provisioningState?: ClusterManagerProvisioningState;
    vmSize?: string;
}

// @public
export type ClusterManagerConnectionStatus = string;

// @public
export type ClusterManagerDetailedStatus = string;

// @public
export interface ClusterManagerList {
    nextLink?: string;
    value?: ClusterManager[];
}

// @public
export interface ClusterManagerPatchParameters {
    identity?: ManagedServiceIdentity;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type ClusterManagerProvisioningState = string;

// @public
export interface ClusterManagers {
    beginCreateOrUpdate(resourceGroupName: string, clusterManagerName: string, clusterManagerParameters: ClusterManager, options?: ClusterManagersCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ClusterManagersCreateOrUpdateResponse>, ClusterManagersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterManagerName: string, clusterManagerParameters: ClusterManager, options?: ClusterManagersCreateOrUpdateOptionalParams): Promise<ClusterManagersCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterManagerName: string, options?: ClusterManagersDeleteOptionalParams): Promise<SimplePollerLike<OperationState<ClusterManagersDeleteResponse>, ClusterManagersDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, clusterManagerName: string, options?: ClusterManagersDeleteOptionalParams): Promise<ClusterManagersDeleteResponse>;
    get(resourceGroupName: string, clusterManagerName: string, options?: ClusterManagersGetOptionalParams): Promise<ClusterManagersGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: ClusterManagersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<ClusterManager>;
    listBySubscription(options?: ClusterManagersListBySubscriptionOptionalParams): PagedAsyncIterableIterator<ClusterManager>;
    update(resourceGroupName: string, clusterManagerName: string, options?: ClusterManagersUpdateOptionalParams): Promise<ClusterManagersUpdateResponse>;
}

// @public
export interface ClusterManagersCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface ClusterManagersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClusterManagersCreateOrUpdateResponse = ClusterManager;

// @public
export interface ClusterManagersDeleteHeaders {
    location?: string;
}

// @public
export interface ClusterManagersDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClusterManagersDeleteResponse = OperationStatusResult;

// @public
export interface ClusterManagersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClusterManagersGetResponse = ClusterManager;

// @public
export interface ClusterManagersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClusterManagersListByResourceGroupNextResponse = ClusterManagerList;

// @public
export interface ClusterManagersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClusterManagersListByResourceGroupResponse = ClusterManagerList;

// @public
export interface ClusterManagersListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClusterManagersListBySubscriptionNextResponse = ClusterManagerList;

// @public
export interface ClusterManagersListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClusterManagersListBySubscriptionResponse = ClusterManagerList;

// @public
export interface ClusterManagersUpdateOptionalParams extends coreClient.OperationOptions {
    clusterManagerUpdateParameters?: ClusterManagerPatchParameters;
    ifMatch?: string;
    ifNoneMatch?: string;
}

// @public
export type ClusterManagersUpdateResponse = ClusterManager;

// @public
export interface ClusterMetricsConfiguration extends TrackedResource {
    collectionInterval: number;
    readonly detailedStatus?: ClusterMetricsConfigurationDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly disabledMetrics?: string[];
    enabledMetrics?: string[];
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly provisioningState?: ClusterMetricsConfigurationProvisioningState;
}

// @public
export type ClusterMetricsConfigurationDetailedStatus = string;

// @public
export interface ClusterMetricsConfigurationList {
    nextLink?: string;
    value?: ClusterMetricsConfiguration[];
}

// @public
export interface ClusterMetricsConfigurationPatchParameters {
    collectionInterval?: number;
    enabledMetrics?: string[];
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type ClusterMetricsConfigurationProvisioningState = string;

// @public
export interface ClusterPatchParameters {
    aggregatorOrSingleRackDefinition?: RackDefinition;
    analyticsOutputSettings?: AnalyticsOutputSettings;
    clusterLocation?: string;
    clusterServicePrincipal?: ServicePrincipalInformation;
    commandOutputSettings?: CommandOutputSettings;
    computeDeploymentThreshold?: ValidationThreshold;
    computeRackDefinitions?: RackDefinition[];
    identity?: ManagedServiceIdentity;
    runtimeProtectionConfiguration?: RuntimeProtectionConfiguration;
    secretArchive?: ClusterSecretArchive;
    secretArchiveSettings?: SecretArchiveSettings;
    tags?: {
        [propertyName: string]: string;
    };
    updateStrategy?: ClusterUpdateStrategy;
    vulnerabilityScanningSettings?: VulnerabilityScanningSettingsPatch;
}

// @public
export type ClusterProvisioningState = string;

// @public
export interface Clusters {
    beginContinueUpdateVersion(resourceGroupName: string, clusterName: string, clusterContinueUpdateVersionParameters: ClusterContinueUpdateVersionParameters, options?: ClustersContinueUpdateVersionOptionalParams): Promise<SimplePollerLike<OperationState<ClustersContinueUpdateVersionResponse>, ClustersContinueUpdateVersionResponse>>;
    beginContinueUpdateVersionAndWait(resourceGroupName: string, clusterName: string, clusterContinueUpdateVersionParameters: ClusterContinueUpdateVersionParameters, options?: ClustersContinueUpdateVersionOptionalParams): Promise<ClustersContinueUpdateVersionResponse>;
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, clusterParameters: Cluster, options?: ClustersCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ClustersCreateOrUpdateResponse>, ClustersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, clusterParameters: Cluster, options?: ClustersCreateOrUpdateOptionalParams): Promise<ClustersCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, options?: ClustersDeleteOptionalParams): Promise<SimplePollerLike<OperationState<ClustersDeleteResponse>, ClustersDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, options?: ClustersDeleteOptionalParams): Promise<ClustersDeleteResponse>;
    beginDeploy(resourceGroupName: string, clusterName: string, options?: ClustersDeployOptionalParams): Promise<SimplePollerLike<OperationState<ClustersDeployResponse>, ClustersDeployResponse>>;
    beginDeployAndWait(resourceGroupName: string, clusterName: string, options?: ClustersDeployOptionalParams): Promise<ClustersDeployResponse>;
    beginScanRuntime(resourceGroupName: string, clusterName: string, options?: ClustersScanRuntimeOptionalParams): Promise<SimplePollerLike<OperationState<ClustersScanRuntimeResponse>, ClustersScanRuntimeResponse>>;
    beginScanRuntimeAndWait(resourceGroupName: string, clusterName: string, options?: ClustersScanRuntimeOptionalParams): Promise<ClustersScanRuntimeResponse>;
    beginUpdate(resourceGroupName: string, clusterName: string, options?: ClustersUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ClustersUpdateResponse>, ClustersUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, clusterName: string, options?: ClustersUpdateOptionalParams): Promise<ClustersUpdateResponse>;
    beginUpdateVersion(resourceGroupName: string, clusterName: string, clusterUpdateVersionParameters: ClusterUpdateVersionParameters, options?: ClustersUpdateVersionOptionalParams): Promise<SimplePollerLike<OperationState<ClustersUpdateVersionResponse>, ClustersUpdateVersionResponse>>;
    beginUpdateVersionAndWait(resourceGroupName: string, clusterName: string, clusterUpdateVersionParameters: ClusterUpdateVersionParameters, options?: ClustersUpdateVersionOptionalParams): Promise<ClustersUpdateVersionResponse>;
    get(resourceGroupName: string, clusterName: string, options?: ClustersGetOptionalParams): Promise<ClustersGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: ClustersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Cluster>;
    listBySubscription(options?: ClustersListBySubscriptionOptionalParams): PagedAsyncIterableIterator<Cluster>;
}

// @public
export interface ClusterScanRuntimeParameters {
    scanActivity?: ClusterScanRuntimeParametersScanActivity;
}

// @public
export type ClusterScanRuntimeParametersScanActivity = string;

// @public
export interface ClustersContinueUpdateVersionHeaders {
    location?: string;
}

// @public
export interface ClustersContinueUpdateVersionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersContinueUpdateVersionResponse = OperationStatusResult;

// @public
export interface ClustersCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface ClustersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersCreateOrUpdateResponse = Cluster;

// @public
export interface ClustersDeleteHeaders {
    location?: string;
}

// @public
export interface ClustersDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersDeleteResponse = OperationStatusResult;

// @public
export interface ClustersDeployHeaders {
    location?: string;
}

// @public
export interface ClustersDeployOptionalParams extends coreClient.OperationOptions {
    clusterDeployParameters?: ClusterDeployParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersDeployResponse = OperationStatusResult;

// @public
export interface ClusterSecretArchive {
    keyVaultId: string;
    useKeyVault?: ClusterSecretArchiveEnabled;
}

// @public
export type ClusterSecretArchiveEnabled = string;

// @public
export interface ClustersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersGetResponse = Cluster;

// @public
export interface ClustersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListByResourceGroupNextResponse = ClusterList;

// @public
export interface ClustersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListByResourceGroupResponse = ClusterList;

// @public
export interface ClustersListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListBySubscriptionNextResponse = ClusterList;

// @public
export interface ClustersListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ClustersListBySubscriptionResponse = ClusterList;

// @public
export interface ClustersScanRuntimeHeaders {
    location?: string;
}

// @public
export interface ClustersScanRuntimeOptionalParams extends coreClient.OperationOptions {
    clusterScanRuntimeParameters?: ClusterScanRuntimeParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersScanRuntimeResponse = OperationStatusResult;

// @public
export interface ClustersUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ClustersUpdateOptionalParams extends coreClient.OperationOptions {
    clusterUpdateParameters?: ClusterPatchParameters;
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersUpdateResponse = Cluster;

// @public
export interface ClustersUpdateVersionHeaders {
    location?: string;
}

// @public
export interface ClustersUpdateVersionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ClustersUpdateVersionResponse = OperationStatusResult;

// @public
export type ClusterType = string;

// @public
export interface ClusterUpdateStrategy {
    maxUnavailable?: number;
    strategyType: ClusterUpdateStrategyType;
    thresholdType: ValidationThresholdType;
    thresholdValue: number;
    waitTimeMinutes?: number;
}

// @public
export type ClusterUpdateStrategyType = string;

// @public
export interface ClusterUpdateVersionParameters {
    targetClusterVersion: string;
}

// @public
export interface CommandOutputSettings {
    associatedIdentity?: IdentitySelector;
    containerUrl?: string;
}

// @public
interface Console_2 extends TrackedResource {
    readonly detailedStatus?: ConsoleDetailedStatus;
    readonly detailedStatusMessage?: string;
    enabled: ConsoleEnabled;
    readonly etag?: string;
    expiration?: Date;
    extendedLocation: ExtendedLocation;
    readonly privateLinkServiceId?: string;
    readonly provisioningState?: ConsoleProvisioningState;
    sshPublicKey: SshPublicKey;
    readonly virtualMachineAccessId?: string;
}
export { Console_2 as Console }

// @public
export type ConsoleDetailedStatus = string;

// @public
export type ConsoleEnabled = string;

// @public
export interface ConsoleList {
    nextLink?: string;
    value?: Console_2[];
}

// @public
export interface ConsolePatchParameters {
    enabled?: ConsoleEnabled;
    expiration?: Date;
    sshPublicKey?: SshPublicKey;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type ConsoleProvisioningState = string;

// @public
export interface Consoles {
    beginCreateOrUpdate(resourceGroupName: string, virtualMachineName: string, consoleName: string, consoleParameters: Console_2, options?: ConsolesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ConsolesCreateOrUpdateResponse>, ConsolesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, virtualMachineName: string, consoleName: string, consoleParameters: Console_2, options?: ConsolesCreateOrUpdateOptionalParams): Promise<ConsolesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, virtualMachineName: string, consoleName: string, options?: ConsolesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<ConsolesDeleteResponse>, ConsolesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, virtualMachineName: string, consoleName: string, options?: ConsolesDeleteOptionalParams): Promise<ConsolesDeleteResponse>;
    beginUpdate(resourceGroupName: string, virtualMachineName: string, consoleName: string, options?: ConsolesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ConsolesUpdateResponse>, ConsolesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, virtualMachineName: string, consoleName: string, options?: ConsolesUpdateOptionalParams): Promise<ConsolesUpdateResponse>;
    get(resourceGroupName: string, virtualMachineName: string, consoleName: string, options?: ConsolesGetOptionalParams): Promise<ConsolesGetResponse>;
    listByVirtualMachine(resourceGroupName: string, virtualMachineName: string, options?: ConsolesListByVirtualMachineOptionalParams): PagedAsyncIterableIterator<Console_2>;
}

// @public
export interface ConsolesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface ConsolesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConsolesCreateOrUpdateResponse = Console_2;

// @public
export interface ConsolesDeleteHeaders {
    location?: string;
}

// @public
export interface ConsolesDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConsolesDeleteResponse = OperationStatusResult;

// @public
export interface ConsolesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConsolesGetResponse = Console_2;

// @public
export interface ConsolesListByVirtualMachineNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConsolesListByVirtualMachineNextResponse = ConsoleList;

// @public
export interface ConsolesListByVirtualMachineOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConsolesListByVirtualMachineResponse = ConsoleList;

// @public
export interface ConsolesUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface ConsolesUpdateOptionalParams extends coreClient.OperationOptions {
    consoleUpdateParameters?: ConsolePatchParameters;
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConsolesUpdateResponse = Console_2;

// @public
export type ControlImpact = string;

// @public
export interface ControlPlaneNodeConfiguration {
    administratorConfiguration?: AdministratorConfiguration;
    availabilityZones?: string[];
    count: number;
    vmSkuName: string;
}

// @public
export interface ControlPlaneNodePatchConfiguration {
    administratorConfiguration?: AdministratorConfigurationPatch;
    count?: number;
}

// @public
export type CreatedByType = string;

// @public
export type DefaultGateway = string;

// @public
export type DeviceConnectionType = string;

// @public
export type DiskType = string;

// @public
export interface EgressEndpoint {
    category: string;
    endpoints: EndpointDependency[];
}

// @public
export interface EndpointDependency {
    domainName: string;
    port?: number;
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface ExtendedLocation {
    name: string;
    type: string;
}

// @public
export type FabricPeeringEnabled = string;

// @public
export type FeatureDetailedStatus = string;

// @public
export interface FeatureStatus {
    readonly detailedStatus?: FeatureDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly name?: string;
    readonly version?: string;
}

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface HardwareInventory {
    readonly additionalHostInformation?: string;
    readonly interfaces?: HardwareInventoryNetworkInterface[];
    readonly nics?: Nic[];
}

// @public
export interface HardwareInventoryNetworkInterface {
    readonly linkStatus?: string;
    readonly macAddress?: string;
    readonly name?: string;
    readonly networkInterfaceId?: string;
}

// @public
export interface HardwareValidationStatus {
    readonly lastValidationTime?: Date;
    readonly result?: BareMetalMachineHardwareValidationResult;
}

// @public
export type HugepagesSize = string;

// @public
export type HybridAksIpamEnabled = string;

// @public
export type HybridAksPluginType = string;

// @public
export interface IdentitySelector {
    identityType?: ManagedServiceIdentitySelectorType;
    userAssignedIdentityResourceId?: string;
}

// @public
export interface ImageRepositoryCredentials {
    password: string;
    registryUrl: string;
    username: string;
}

// @public
export interface InitialAgentPoolConfiguration {
    administratorConfiguration?: AdministratorConfiguration;
    agentOptions?: AgentOptions;
    attachedNetworkConfiguration?: AttachedNetworkConfiguration;
    availabilityZones?: string[];
    count: number;
    labels?: KubernetesLabel[];
    mode: AgentPoolMode;
    name: string;
    taints?: KubernetesLabel[];
    upgradeSettings?: AgentPoolUpgradeSettings;
    vmSkuName: string;
}

// @public
export interface IpAddressPool {
    addresses: string[];
    autoAssign?: BfdEnabled;
    name: string;
    onlyUseHostIps?: BfdEnabled;
}

// @public
export type IpAllocationType = string;

// @public
export interface KeySetUser {
    azureUserName: string;
    description?: string;
    sshPublicKey: SshPublicKey;
    userPrincipalName?: string;
}

// @public
export interface KeySetUserStatus {
    readonly azureUserName?: string;
    readonly status?: BareMetalMachineKeySetUserSetupStatus;
    readonly statusMessage?: string;
}

// @public
export enum KnownActionType {
    Internal = "Internal"
}

// @public
export enum KnownAdvertiseToFabric {
    False = "False",
    True = "True"
}

// @public
export enum KnownAgentPoolDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownAgentPoolMode {
    NotApplicable = "NotApplicable",
    System = "System",
    User = "User"
}

// @public
export enum KnownAgentPoolProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Deleting = "Deleting",
    Failed = "Failed",
    InProgress = "InProgress",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownAvailabilityLifecycle {
    GenerallyAvailable = "GenerallyAvailable",
    Preview = "Preview"
}

// @public
export enum KnownBareMetalMachineCordonStatus {
    Cordoned = "Cordoned",
    Uncordoned = "Uncordoned"
}

// @public
export enum KnownBareMetalMachineDetailedStatus {
    Available = "Available",
    Deprovisioning = "Deprovisioning",
    Error = "Error",
    Preparing = "Preparing",
    Provisioned = "Provisioned",
    Provisioning = "Provisioning"
}

// @public
export enum KnownBareMetalMachineEvacuate {
    False = "False",
    True = "True"
}

// @public
export enum KnownBareMetalMachineHardwareValidationResult {
    Fail = "Fail",
    Pass = "Pass"
}

// @public
export enum KnownBareMetalMachineKeySetDetailedStatus {
    AllActive = "AllActive",
    AllInvalid = "AllInvalid",
    SomeInvalid = "SomeInvalid",
    Validating = "Validating"
}

// @public
export enum KnownBareMetalMachineKeySetPrivilegeLevel {
    Standard = "Standard",
    Superuser = "Superuser"
}

// @public
export enum KnownBareMetalMachineKeySetProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownBareMetalMachineKeySetUserSetupStatus {
    Active = "Active",
    Invalid = "Invalid"
}

// @public
export enum KnownBareMetalMachinePowerState {
    Off = "Off",
    On = "On"
}

// @public
export enum KnownBareMetalMachineProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownBareMetalMachineReadyState {
    False = "False",
    True = "True"
}

// @public
export enum KnownBareMetalMachineSkipShutdown {
    False = "False",
    True = "True"
}

// @public
export enum KnownBfdEnabled {
    False = "False",
    True = "True"
}

// @public
export enum KnownBgpMultiHop {
    False = "False",
    True = "True"
}

// @public
export enum KnownBmcKeySetDetailedStatus {
    AllActive = "AllActive",
    AllInvalid = "AllInvalid",
    SomeInvalid = "SomeInvalid",
    Validating = "Validating"
}

// @public
export enum KnownBmcKeySetPrivilegeLevel {
    Administrator = "Administrator",
    ReadOnly = "ReadOnly"
}

// @public
export enum KnownBmcKeySetProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownBootstrapProtocol {
    PXE = "PXE"
}

// @public
export enum KnownCloudServicesNetworkDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownCloudServicesNetworkEnableDefaultEgressEndpoints {
    False = "False",
    True = "True"
}

// @public
export enum KnownCloudServicesNetworkProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownClusterConnectionStatus {
    Connected = "Connected",
    Disconnected = "Disconnected",
    Timeout = "Timeout",
    Undefined = "Undefined"
}

// @public
export enum KnownClusterContinueUpdateVersionMachineGroupTargetingMode {
    AlphaByRack = "AlphaByRack"
}

// @public
export enum KnownClusterDetailedStatus {
    Degraded = "Degraded",
    Deleting = "Deleting",
    Deploying = "Deploying",
    Disconnected = "Disconnected",
    Failed = "Failed",
    PendingDeployment = "PendingDeployment",
    Running = "Running",
    UpdatePaused = "UpdatePaused",
    Updating = "Updating"
}

// @public
export enum KnownClusterManagerConnectionStatus {
    Connected = "Connected",
    Unreachable = "Unreachable"
}

// @public
export enum KnownClusterManagerDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning",
    ProvisioningFailed = "ProvisioningFailed",
    UpdateFailed = "UpdateFailed",
    Updating = "Updating"
}

// @public
export enum KnownClusterManagerProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownClusterMetricsConfigurationDetailedStatus {
    Applied = "Applied",
    Error = "Error",
    Processing = "Processing"
}

// @public
export enum KnownClusterMetricsConfigurationProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownClusterProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating",
    Validating = "Validating"
}

// @public
export enum KnownClusterScanRuntimeParametersScanActivity {
    Scan = "Scan",
    Skip = "Skip"
}

// @public
export enum KnownClusterSecretArchiveEnabled {
    False = "False",
    True = "True"
}

// @public
export enum KnownClusterType {
    MultiRack = "MultiRack",
    SingleRack = "SingleRack"
}

// @public
export enum KnownClusterUpdateStrategyType {
    PauseAfterRack = "PauseAfterRack",
    Rack = "Rack"
}

// @public
export enum KnownConsoleDetailedStatus {
    Error = "Error",
    Ready = "Ready"
}

// @public
export enum KnownConsoleEnabled {
    False = "False",
    True = "True"
}

// @public
export enum KnownConsoleProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownControlImpact {
    False = "False",
    True = "True"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDefaultGateway {
    False = "False",
    True = "True"
}

// @public
export enum KnownDeviceConnectionType {
    PCI = "PCI"
}

// @public
export enum KnownDiskType {
    HDD = "HDD",
    SSD = "SSD"
}

// @public
export enum KnownFabricPeeringEnabled {
    False = "False",
    True = "True"
}

// @public
export enum KnownFeatureDetailedStatus {
    Failed = "Failed",
    Running = "Running",
    Unknown = "Unknown"
}

// @public
export enum KnownHugepagesSize {
    OneG = "1G",
    TwoM = "2M"
}

// @public
export enum KnownHybridAksIpamEnabled {
    False = "False",
    True = "True"
}

// @public
export enum KnownHybridAksPluginType {
    Dpdk = "DPDK",
    OSDevice = "OSDevice",
    Sriov = "SRIOV"
}

// @public
export enum KnownIpAllocationType {
    DualStack = "DualStack",
    IPV4 = "IPV4",
    IPV6 = "IPV6"
}

// @public
export enum KnownKubernetesClusterDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownKubernetesClusterFeatureAvailabilityLifecycle {
    GenerallyAvailable = "GenerallyAvailable",
    Preview = "Preview"
}

// @public
export enum KnownKubernetesClusterFeatureDetailedStatus {
    Error = "Error",
    Installed = "Installed",
    Provisioning = "Provisioning"
}

// @public
export enum KnownKubernetesClusterFeatureProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownKubernetesClusterFeatureRequired {
    False = "False",
    True = "True"
}

// @public
export enum KnownKubernetesClusterNodeDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning",
    Running = "Running",
    Scheduling = "Scheduling",
    Stopped = "Stopped",
    Terminating = "Terminating",
    Unknown = "Unknown"
}

// @public
export enum KnownKubernetesClusterProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Created = "Created",
    Deleting = "Deleting",
    Failed = "Failed",
    InProgress = "InProgress",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownKubernetesNodePowerState {
    Off = "Off",
    On = "On",
    Unknown = "Unknown"
}

// @public
export enum KnownKubernetesNodeRole {
    ControlPlane = "ControlPlane",
    Worker = "Worker"
}

// @public
export enum KnownKubernetesPluginType {
    Dpdk = "DPDK",
    Ipvlan = "IPVLAN",
    Macvlan = "MACVLAN",
    OSDevice = "OSDevice",
    Sriov = "SRIOV"
}

// @public
export enum KnownL2NetworkDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownL2NetworkProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownL3NetworkConfigurationIpamEnabled {
    False = "False",
    True = "True"
}

// @public
export enum KnownL3NetworkDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownL3NetworkProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownMachineSkuDiskConnectionType {
    Pcie = "PCIE",
    Raid = "RAID",
    SAS = "SAS",
    Sata = "SATA"
}

// @public
export enum KnownManagedServiceIdentitySelectorType {
    SystemAssignedIdentity = "SystemAssignedIdentity",
    UserAssignedIdentity = "UserAssignedIdentity"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownOrigin {
    System = "system",
    User = "user",
    UserSystem = "user,system"
}

// @public
export enum KnownOsDiskCreateOption {
    Ephemeral = "Ephemeral",
    Persistent = "Persistent"
}

// @public
export enum KnownOsDiskDeleteOption {
    Delete = "Delete"
}

// @public
export enum KnownRackDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownRackProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownRackSkuProvisioningState {
    Canceled = "Canceled",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownRackSkuType {
    Aggregator = "Aggregator",
    Compute = "Compute",
    Single = "Single"
}

// @public
export enum KnownRemoteVendorManagementFeature {
    Supported = "Supported",
    Unsupported = "Unsupported"
}

// @public
export enum KnownRemoteVendorManagementStatus {
    Disabled = "Disabled",
    Enabled = "Enabled",
    Unsupported = "Unsupported"
}

// @public
export enum KnownRuntimeProtectionEnforcementLevel {
    Audit = "Audit",
    Disabled = "Disabled",
    OnDemand = "OnDemand",
    Passive = "Passive",
    RealTime = "RealTime"
}

// @public
export enum KnownSkipShutdown {
    False = "False",
    True = "True"
}

// @public
export enum KnownStorageApplianceDetailedStatus {
    Available = "Available",
    Degraded = "Degraded",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownStorageApplianceProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownTrunkedNetworkDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownTrunkedNetworkProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownValidationThresholdGrouping {
    PerCluster = "PerCluster",
    PerRack = "PerRack"
}

// @public
export enum KnownValidationThresholdType {
    CountSuccess = "CountSuccess",
    PercentSuccess = "PercentSuccess"
}

// @public
export enum KnownVirtualMachineBootMethod {
    Bios = "BIOS",
    Uefi = "UEFI"
}

// @public
export enum KnownVirtualMachineDetailedStatus {
    Available = "Available",
    Error = "Error",
    Provisioning = "Provisioning",
    Running = "Running",
    Scheduling = "Scheduling",
    Stopped = "Stopped",
    Terminating = "Terminating",
    Unknown = "Unknown"
}

// @public
export enum KnownVirtualMachineDeviceModelType {
    T1 = "T1",
    T2 = "T2",
    T3 = "T3"
}

// @public
export enum KnownVirtualMachineIPAllocationMethod {
    Disabled = "Disabled",
    Dynamic = "Dynamic",
    Static = "Static"
}

// @public
export enum KnownVirtualMachineIsolateEmulatorThread {
    False = "False",
    True = "True"
}

// @public
export enum KnownVirtualMachinePlacementHintPodAffinityScope {
    Machine = "Machine",
    Rack = "Rack"
}

// @public
export enum KnownVirtualMachinePlacementHintType {
    Affinity = "Affinity",
    AntiAffinity = "AntiAffinity"
}

// @public
export enum KnownVirtualMachinePowerState {
    Off = "Off",
    On = "On",
    Unknown = "Unknown"
}

// @public
export enum KnownVirtualMachineProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownVirtualMachineSchedulingExecution {
    Hard = "Hard",
    Soft = "Soft"
}

// @public
export enum KnownVirtualMachineVirtioInterfaceType {
    Modern = "Modern",
    Transitional = "Transitional"
}

// @public
export enum KnownVolumeDetailedStatus {
    Active = "Active",
    Error = "Error",
    Provisioning = "Provisioning"
}

// @public
export enum KnownVolumeProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Failed = "Failed",
    Provisioning = "Provisioning",
    Succeeded = "Succeeded"
}

// @public
export enum KnownVulnerabilityScanningSettingsContainerScan {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownWorkloadImpact {
    False = "False",
    True = "True"
}

// @public
export interface KubernetesCluster extends TrackedResource {
    aadConfiguration?: AadConfiguration;
    administratorConfiguration?: AdministratorConfiguration;
    readonly attachedNetworkIds?: string[];
    readonly availableUpgrades?: AvailableUpgrade[];
    readonly clusterId?: string;
    readonly connectedClusterId?: string;
    readonly controlPlaneKubernetesVersion?: string;
    controlPlaneNodeConfiguration: ControlPlaneNodeConfiguration;
    readonly detailedStatus?: KubernetesClusterDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly featureStatuses?: FeatureStatus[];
    initialAgentPoolConfigurations: InitialAgentPoolConfiguration[];
    kubernetesVersion: string;
    managedResourceGroupConfiguration?: ManagedResourceGroupConfiguration;
    networkConfiguration: NetworkConfiguration;
    readonly nodes?: KubernetesClusterNode[];
    readonly provisioningState?: KubernetesClusterProvisioningState;
}

// @public
export type KubernetesClusterDetailedStatus = string;

// @public
export interface KubernetesClusterFeature extends TrackedResource {
    readonly availabilityLifecycle?: KubernetesClusterFeatureAvailabilityLifecycle;
    readonly detailedStatus?: KubernetesClusterFeatureDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    options?: StringKeyValuePair[];
    readonly provisioningState?: KubernetesClusterFeatureProvisioningState;
    readonly required?: KubernetesClusterFeatureRequired;
    readonly version?: string;
}

// @public
export type KubernetesClusterFeatureAvailabilityLifecycle = string;

// @public
export type KubernetesClusterFeatureDetailedStatus = string;

// @public
export interface KubernetesClusterFeatureList {
    nextLink?: string;
    value?: KubernetesClusterFeature[];
}

// @public
export interface KubernetesClusterFeaturePatchParameters {
    options?: StringKeyValuePair[];
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type KubernetesClusterFeatureProvisioningState = string;

// @public
export type KubernetesClusterFeatureRequired = string;

// @public
export interface KubernetesClusterFeatures {
    beginCreateOrUpdate(resourceGroupName: string, kubernetesClusterName: string, featureName: string, kubernetesClusterFeatureParameters: KubernetesClusterFeature, options?: KubernetesClusterFeaturesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<KubernetesClusterFeaturesCreateOrUpdateResponse>, KubernetesClusterFeaturesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, kubernetesClusterName: string, featureName: string, kubernetesClusterFeatureParameters: KubernetesClusterFeature, options?: KubernetesClusterFeaturesCreateOrUpdateOptionalParams): Promise<KubernetesClusterFeaturesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, kubernetesClusterName: string, featureName: string, options?: KubernetesClusterFeaturesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<KubernetesClusterFeaturesDeleteResponse>, KubernetesClusterFeaturesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, kubernetesClusterName: string, featureName: string, options?: KubernetesClusterFeaturesDeleteOptionalParams): Promise<KubernetesClusterFeaturesDeleteResponse>;
    beginUpdate(resourceGroupName: string, kubernetesClusterName: string, featureName: string, options?: KubernetesClusterFeaturesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<KubernetesClusterFeaturesUpdateResponse>, KubernetesClusterFeaturesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, kubernetesClusterName: string, featureName: string, options?: KubernetesClusterFeaturesUpdateOptionalParams): Promise<KubernetesClusterFeaturesUpdateResponse>;
    get(resourceGroupName: string, kubernetesClusterName: string, featureName: string, options?: KubernetesClusterFeaturesGetOptionalParams): Promise<KubernetesClusterFeaturesGetResponse>;
    listByKubernetesCluster(resourceGroupName: string, kubernetesClusterName: string, options?: KubernetesClusterFeaturesListByKubernetesClusterOptionalParams): PagedAsyncIterableIterator<KubernetesClusterFeature>;
}

// @public
export interface KubernetesClusterFeaturesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface KubernetesClusterFeaturesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type KubernetesClusterFeaturesCreateOrUpdateResponse = KubernetesClusterFeature;

// @public
export interface KubernetesClusterFeaturesDeleteHeaders {
    location?: string;
}

// @public
export interface KubernetesClusterFeaturesDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type KubernetesClusterFeaturesDeleteResponse = OperationStatusResult;

// @public
export interface KubernetesClusterFeaturesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type KubernetesClusterFeaturesGetResponse = KubernetesClusterFeature;

// @public
export interface KubernetesClusterFeaturesListByKubernetesClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type KubernetesClusterFeaturesListByKubernetesClusterNextResponse = KubernetesClusterFeatureList;

// @public
export interface KubernetesClusterFeaturesListByKubernetesClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type KubernetesClusterFeaturesListByKubernetesClusterResponse = KubernetesClusterFeatureList;

// @public
export interface KubernetesClusterFeaturesUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface KubernetesClusterFeaturesUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    kubernetesClusterFeatureUpdateParameters?: KubernetesClusterFeaturePatchParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type KubernetesClusterFeaturesUpdateResponse = KubernetesClusterFeature;

// @public
export interface KubernetesClusterList {
    nextLink?: string;
    value?: KubernetesCluster[];
}

// @public
export interface KubernetesClusterNode {
    readonly agentPoolId?: string;
    readonly availabilityZone?: string;
    readonly bareMetalMachineId?: string;
    readonly cpuCores?: number;
    readonly detailedStatus?: KubernetesClusterNodeDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly diskSizeGB?: number;
    readonly image?: string;
    readonly kubernetesVersion?: string;
    readonly labels?: KubernetesLabel[];
    readonly memorySizeGB?: number;
    readonly mode?: AgentPoolMode;
    readonly name?: string;
    readonly networkAttachments?: NetworkAttachment[];
    readonly powerState?: KubernetesNodePowerState;
    readonly role?: KubernetesNodeRole;
    readonly taints?: KubernetesLabel[];
    readonly vmSkuName?: string;
}

// @public
export type KubernetesClusterNodeDetailedStatus = string;

// @public
export interface KubernetesClusterPatchParameters {
    administratorConfiguration?: AdministratorConfigurationPatch;
    controlPlaneNodeConfiguration?: ControlPlaneNodePatchConfiguration;
    kubernetesVersion?: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type KubernetesClusterProvisioningState = string;

// @public
export interface KubernetesClusterRestartNodeParameters {
    nodeName: string;
}

// @public
export interface KubernetesClusters {
    beginCreateOrUpdate(resourceGroupName: string, kubernetesClusterName: string, kubernetesClusterParameters: KubernetesCluster, options?: KubernetesClustersCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<KubernetesClustersCreateOrUpdateResponse>, KubernetesClustersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, kubernetesClusterName: string, kubernetesClusterParameters: KubernetesCluster, options?: KubernetesClustersCreateOrUpdateOptionalParams): Promise<KubernetesClustersCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, kubernetesClusterName: string, options?: KubernetesClustersDeleteOptionalParams): Promise<SimplePollerLike<OperationState<KubernetesClustersDeleteResponse>, KubernetesClustersDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, kubernetesClusterName: string, options?: KubernetesClustersDeleteOptionalParams): Promise<KubernetesClustersDeleteResponse>;
    beginRestartNode(resourceGroupName: string, kubernetesClusterName: string, kubernetesClusterRestartNodeParameters: KubernetesClusterRestartNodeParameters, options?: KubernetesClustersRestartNodeOptionalParams): Promise<SimplePollerLike<OperationState<KubernetesClustersRestartNodeResponse>, KubernetesClustersRestartNodeResponse>>;
    beginRestartNodeAndWait(resourceGroupName: string, kubernetesClusterName: string, kubernetesClusterRestartNodeParameters: KubernetesClusterRestartNodeParameters, options?: KubernetesClustersRestartNodeOptionalParams): Promise<KubernetesClustersRestartNodeResponse>;
    beginUpdate(resourceGroupName: string, kubernetesClusterName: string, options?: KubernetesClustersUpdateOptionalParams): Promise<SimplePollerLike<OperationState<KubernetesClustersUpdateResponse>, KubernetesClustersUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, kubernetesClusterName: string, options?: KubernetesClustersUpdateOptionalParams): Promise<KubernetesClustersUpdateResponse>;
    get(resourceGroupName: string, kubernetesClusterName: string, options?: KubernetesClustersGetOptionalParams): Promise<KubernetesClustersGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: KubernetesClustersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<KubernetesCluster>;
    listBySubscription(options?: KubernetesClustersListBySubscriptionOptionalParams): PagedAsyncIterableIterator<KubernetesCluster>;
}

// @public
export interface KubernetesClustersCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface KubernetesClustersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type KubernetesClustersCreateOrUpdateResponse = KubernetesCluster;

// @public
export interface KubernetesClustersDeleteHeaders {
    location?: string;
}

// @public
export interface KubernetesClustersDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type KubernetesClustersDeleteResponse = OperationStatusResult;

// @public
export interface KubernetesClustersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type KubernetesClustersGetResponse = KubernetesCluster;

// @public
export interface KubernetesClustersListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type KubernetesClustersListByResourceGroupNextResponse = KubernetesClusterList;

// @public
export interface KubernetesClustersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type KubernetesClustersListByResourceGroupResponse = KubernetesClusterList;

// @public
export interface KubernetesClustersListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type KubernetesClustersListBySubscriptionNextResponse = KubernetesClusterList;

// @public
export interface KubernetesClustersListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type KubernetesClustersListBySubscriptionResponse = KubernetesClusterList;

// @public
export interface KubernetesClustersRestartNodeHeaders {
    location?: string;
}

// @public
export interface KubernetesClustersRestartNodeOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type KubernetesClustersRestartNodeResponse = OperationStatusResult;

// @public
export interface KubernetesClustersUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface KubernetesClustersUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    kubernetesClusterUpdateParameters?: KubernetesClusterPatchParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type KubernetesClustersUpdateResponse = KubernetesCluster;

// @public
export interface KubernetesLabel {
    key: string;
    value: string;
}

// @public
export type KubernetesNodePowerState = string;

// @public
export type KubernetesNodeRole = string;

// @public
export type KubernetesPluginType = string;

// @public
export interface L2Network extends TrackedResource {
    readonly associatedResourceIds?: string[];
    readonly clusterId?: string;
    readonly detailedStatus?: L2NetworkDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly hybridAksClustersAssociatedIds?: string[];
    hybridAksPluginType?: HybridAksPluginType;
    interfaceName?: string;
    l2IsolationDomainId: string;
    readonly provisioningState?: L2NetworkProvisioningState;
    readonly virtualMachinesAssociatedIds?: string[];
}

// @public
export interface L2NetworkAttachmentConfiguration {
    networkId: string;
    pluginType?: KubernetesPluginType;
}

// @public
export type L2NetworkDetailedStatus = string;

// @public
export interface L2NetworkList {
    nextLink?: string;
    value?: L2Network[];
}

// @public
export interface L2NetworkPatchParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type L2NetworkProvisioningState = string;

// @public
export interface L2Networks {
    beginCreateOrUpdate(resourceGroupName: string, l2NetworkName: string, l2NetworkParameters: L2Network, options?: L2NetworksCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<L2NetworksCreateOrUpdateResponse>, L2NetworksCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, l2NetworkName: string, l2NetworkParameters: L2Network, options?: L2NetworksCreateOrUpdateOptionalParams): Promise<L2NetworksCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, l2NetworkName: string, options?: L2NetworksDeleteOptionalParams): Promise<SimplePollerLike<OperationState<L2NetworksDeleteResponse>, L2NetworksDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, l2NetworkName: string, options?: L2NetworksDeleteOptionalParams): Promise<L2NetworksDeleteResponse>;
    get(resourceGroupName: string, l2NetworkName: string, options?: L2NetworksGetOptionalParams): Promise<L2NetworksGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: L2NetworksListByResourceGroupOptionalParams): PagedAsyncIterableIterator<L2Network>;
    listBySubscription(options?: L2NetworksListBySubscriptionOptionalParams): PagedAsyncIterableIterator<L2Network>;
    update(resourceGroupName: string, l2NetworkName: string, options?: L2NetworksUpdateOptionalParams): Promise<L2NetworksUpdateResponse>;
}

// @public
export interface L2NetworksCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface L2NetworksCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type L2NetworksCreateOrUpdateResponse = L2Network;

// @public
export interface L2NetworksDeleteHeaders {
    location?: string;
}

// @public
export interface L2NetworksDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type L2NetworksDeleteResponse = OperationStatusResult;

// @public
export interface L2NetworksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L2NetworksGetResponse = L2Network;

// @public
export interface L2NetworksListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L2NetworksListByResourceGroupNextResponse = L2NetworkList;

// @public
export interface L2NetworksListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L2NetworksListByResourceGroupResponse = L2NetworkList;

// @public
export interface L2NetworksListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L2NetworksListBySubscriptionNextResponse = L2NetworkList;

// @public
export interface L2NetworksListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L2NetworksListBySubscriptionResponse = L2NetworkList;

// @public
export interface L2NetworksUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    l2NetworkUpdateParameters?: L2NetworkPatchParameters;
}

// @public
export type L2NetworksUpdateResponse = L2Network;

// @public
export interface L2ServiceLoadBalancerConfiguration {
    ipAddressPools?: IpAddressPool[];
}

// @public
export interface L3Network extends TrackedResource {
    readonly associatedResourceIds?: string[];
    readonly clusterId?: string;
    readonly detailedStatus?: L3NetworkDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly hybridAksClustersAssociatedIds?: string[];
    hybridAksIpamEnabled?: HybridAksIpamEnabled;
    hybridAksPluginType?: HybridAksPluginType;
    interfaceName?: string;
    ipAllocationType?: IpAllocationType;
    ipv4ConnectedPrefix?: string;
    ipv6ConnectedPrefix?: string;
    l3IsolationDomainId: string;
    readonly provisioningState?: L3NetworkProvisioningState;
    readonly virtualMachinesAssociatedIds?: string[];
    vlan: number;
}

// @public
export interface L3NetworkAttachmentConfiguration {
    ipamEnabled?: L3NetworkConfigurationIpamEnabled;
    networkId: string;
    pluginType?: KubernetesPluginType;
}

// @public
export type L3NetworkConfigurationIpamEnabled = string;

// @public
export type L3NetworkDetailedStatus = string;

// @public
export interface L3NetworkList {
    nextLink?: string;
    value?: L3Network[];
}

// @public
export interface L3NetworkPatchParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type L3NetworkProvisioningState = string;

// @public
export interface L3Networks {
    beginCreateOrUpdate(resourceGroupName: string, l3NetworkName: string, l3NetworkParameters: L3Network, options?: L3NetworksCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<L3NetworksCreateOrUpdateResponse>, L3NetworksCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, l3NetworkName: string, l3NetworkParameters: L3Network, options?: L3NetworksCreateOrUpdateOptionalParams): Promise<L3NetworksCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, l3NetworkName: string, options?: L3NetworksDeleteOptionalParams): Promise<SimplePollerLike<OperationState<L3NetworksDeleteResponse>, L3NetworksDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, l3NetworkName: string, options?: L3NetworksDeleteOptionalParams): Promise<L3NetworksDeleteResponse>;
    get(resourceGroupName: string, l3NetworkName: string, options?: L3NetworksGetOptionalParams): Promise<L3NetworksGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: L3NetworksListByResourceGroupOptionalParams): PagedAsyncIterableIterator<L3Network>;
    listBySubscription(options?: L3NetworksListBySubscriptionOptionalParams): PagedAsyncIterableIterator<L3Network>;
    update(resourceGroupName: string, l3NetworkName: string, options?: L3NetworksUpdateOptionalParams): Promise<L3NetworksUpdateResponse>;
}

// @public
export interface L3NetworksCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface L3NetworksCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type L3NetworksCreateOrUpdateResponse = L3Network;

// @public
export interface L3NetworksDeleteHeaders {
    location?: string;
}

// @public
export interface L3NetworksDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type L3NetworksDeleteResponse = OperationStatusResult;

// @public
export interface L3NetworksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L3NetworksGetResponse = L3Network;

// @public
export interface L3NetworksListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L3NetworksListByResourceGroupNextResponse = L3NetworkList;

// @public
export interface L3NetworksListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L3NetworksListByResourceGroupResponse = L3NetworkList;

// @public
export interface L3NetworksListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L3NetworksListBySubscriptionNextResponse = L3NetworkList;

// @public
export interface L3NetworksListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type L3NetworksListBySubscriptionResponse = L3NetworkList;

// @public
export interface L3NetworksUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    l3NetworkUpdateParameters?: L3NetworkPatchParameters;
}

// @public
export type L3NetworksUpdateResponse = L3Network;

// @public
export interface LldpNeighbor {
    readonly portDescription?: string;
    readonly portName?: string;
    readonly systemDescription?: string;
    readonly systemName?: string;
}

// @public
export interface MachineDisk {
    readonly capacityGB?: number;
    readonly connection?: MachineSkuDiskConnectionType;
    readonly type?: DiskType;
}

// @public
export type MachineSkuDiskConnectionType = string;

// @public
export interface MachineSkuSlot {
    readonly bootstrapProtocol?: BootstrapProtocol;
    readonly cpuCores?: number;
    readonly cpuSockets?: number;
    readonly disks?: MachineDisk[];
    readonly generation?: string;
    readonly hardwareVersion?: string;
    readonly memoryCapacityGB?: number;
    readonly model?: string;
    readonly networkInterfaces?: NetworkInterface[];
    readonly rackSlot?: number;
    readonly totalThreads?: number;
    readonly vendor?: string;
}

// @public
export interface ManagedResourceGroupConfiguration {
    location?: string;
    name?: string;
}

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentity | null;
    };
}

// @public
export type ManagedServiceIdentitySelectorType = string;

// @public
export type ManagedServiceIdentityType = string;

// @public
export interface MetricsConfigurations {
    beginCreateOrUpdate(resourceGroupName: string, clusterName: string, metricsConfigurationName: string, metricsConfigurationParameters: ClusterMetricsConfiguration, options?: MetricsConfigurationsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<MetricsConfigurationsCreateOrUpdateResponse>, MetricsConfigurationsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, clusterName: string, metricsConfigurationName: string, metricsConfigurationParameters: ClusterMetricsConfiguration, options?: MetricsConfigurationsCreateOrUpdateOptionalParams): Promise<MetricsConfigurationsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, clusterName: string, metricsConfigurationName: string, options?: MetricsConfigurationsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<MetricsConfigurationsDeleteResponse>, MetricsConfigurationsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, clusterName: string, metricsConfigurationName: string, options?: MetricsConfigurationsDeleteOptionalParams): Promise<MetricsConfigurationsDeleteResponse>;
    beginUpdate(resourceGroupName: string, clusterName: string, metricsConfigurationName: string, options?: MetricsConfigurationsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<MetricsConfigurationsUpdateResponse>, MetricsConfigurationsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, clusterName: string, metricsConfigurationName: string, options?: MetricsConfigurationsUpdateOptionalParams): Promise<MetricsConfigurationsUpdateResponse>;
    get(resourceGroupName: string, clusterName: string, metricsConfigurationName: string, options?: MetricsConfigurationsGetOptionalParams): Promise<MetricsConfigurationsGetResponse>;
    listByCluster(resourceGroupName: string, clusterName: string, options?: MetricsConfigurationsListByClusterOptionalParams): PagedAsyncIterableIterator<ClusterMetricsConfiguration>;
}

// @public
export interface MetricsConfigurationsCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface MetricsConfigurationsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type MetricsConfigurationsCreateOrUpdateResponse = ClusterMetricsConfiguration;

// @public
export interface MetricsConfigurationsDeleteHeaders {
    location?: string;
}

// @public
export interface MetricsConfigurationsDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type MetricsConfigurationsDeleteResponse = OperationStatusResult;

// @public
export interface MetricsConfigurationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MetricsConfigurationsGetResponse = ClusterMetricsConfiguration;

// @public
export interface MetricsConfigurationsListByClusterNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MetricsConfigurationsListByClusterNextResponse = ClusterMetricsConfigurationList;

// @public
export interface MetricsConfigurationsListByClusterOptionalParams extends coreClient.OperationOptions {
}

// @public
export type MetricsConfigurationsListByClusterResponse = ClusterMetricsConfigurationList;

// @public
export interface MetricsConfigurationsUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface MetricsConfigurationsUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    metricsConfigurationUpdateParameters?: ClusterMetricsConfigurationPatchParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type MetricsConfigurationsUpdateResponse = ClusterMetricsConfiguration;

// @public
export interface NetworkAttachment {
    attachedNetworkId: string;
    defaultGateway?: DefaultGateway;
    ipAllocationMethod: VirtualMachineIPAllocationMethod;
    ipv4Address?: string;
    ipv6Address?: string;
    readonly macAddress?: string;
    networkAttachmentName?: string;
}

// @public (undocumented)
export class NetworkCloud extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: NetworkCloudOptionalParams);
    // (undocumented)
    agentPools: AgentPools;
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    bareMetalMachineKeySets: BareMetalMachineKeySets;
    // (undocumented)
    bareMetalMachines: BareMetalMachines;
    // (undocumented)
    bmcKeySets: BmcKeySets;
    // (undocumented)
    cloudServicesNetworks: CloudServicesNetworks;
    // (undocumented)
    clusterManagers: ClusterManagers;
    // (undocumented)
    clusters: Clusters;
    // (undocumented)
    consoles: Consoles;
    // (undocumented)
    kubernetesClusterFeatures: KubernetesClusterFeatures;
    // (undocumented)
    kubernetesClusters: KubernetesClusters;
    // (undocumented)
    l2Networks: L2Networks;
    // (undocumented)
    l3Networks: L3Networks;
    // (undocumented)
    metricsConfigurations: MetricsConfigurations;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    racks: Racks;
    // (undocumented)
    rackSkus: RackSkus;
    // (undocumented)
    storageAppliances: StorageAppliances;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    trunkedNetworks: TrunkedNetworks;
    // (undocumented)
    virtualMachines: VirtualMachines;
    // (undocumented)
    volumes: Volumes;
}

// @public
export interface NetworkCloudOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface NetworkConfiguration {
    attachedNetworkConfiguration?: AttachedNetworkConfiguration;
    bgpServiceLoadBalancerConfiguration?: BgpServiceLoadBalancerConfiguration;
    cloudServicesNetworkId: string;
    cniNetworkId: string;
    dnsServiceIp?: string;
    l2ServiceLoadBalancerConfiguration?: L2ServiceLoadBalancerConfiguration;
    podCidrs?: string[];
    serviceCidrs?: string[];
}

// @public
export interface NetworkInterface {
    readonly address?: string;
    readonly deviceConnectionType?: DeviceConnectionType;
    readonly model?: string;
    readonly physicalSlot?: number;
    readonly portCount?: number;
    readonly portSpeed?: number;
    readonly vendor?: string;
}

// @public
export interface Nic {
    readonly lldpNeighbor?: LldpNeighbor;
    readonly macAddress?: string;
    readonly name?: string;
}

// @public
export interface NodePoolAdministratorConfigurationPatch {
    sshPublicKeys?: SshPublicKey[];
}

// @public
export interface Operation {
    readonly actionType?: ActionType;
    display?: OperationDisplay;
    readonly isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: Origin;
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationListResult {
    readonly nextLink?: string;
    readonly value?: Operation[];
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<Operation>;
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = OperationListResult;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export interface OperationStatusResult {
    readonly endTime?: Date;
    readonly error?: ErrorDetail;
    readonly exitCode?: string;
    readonly id?: string;
    readonly name?: string;
    readonly operations?: OperationStatusResult[];
    readonly outputHead?: string;
    readonly percentComplete?: number;
    readonly resourceId?: string;
    readonly resultRef?: string;
    readonly resultUrl?: string;
    readonly startTime?: Date;
    status: string;
}

// @public
export type Origin = string;

// @public
export interface OsDisk {
    createOption?: OsDiskCreateOption;
    deleteOption?: OsDiskDeleteOption;
    diskSizeGB: number;
}

// @public
export type OsDiskCreateOption = string;

// @public
export type OsDiskDeleteOption = string;

// @public
export interface Rack extends TrackedResource {
    availabilityZone: string;
    readonly clusterId?: string;
    readonly detailedStatus?: RackDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly provisioningState?: RackProvisioningState;
    rackLocation: string;
    rackSerialNumber: string;
    rackSkuId: string;
}

// @public
export interface RackDefinition {
    availabilityZone?: string;
    bareMetalMachineConfigurationData?: BareMetalMachineConfigurationData[];
    networkRackId: string;
    rackLocation?: string;
    rackSerialNumber: string;
    rackSkuId: string;
    storageApplianceConfigurationData?: StorageApplianceConfigurationData[];
}

// @public
export type RackDetailedStatus = string;

// @public
export interface RackList {
    nextLink?: string;
    value?: Rack[];
}

// @public
export interface RackPatchParameters {
    rackLocation?: string;
    rackSerialNumber?: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type RackProvisioningState = string;

// @public
export interface Racks {
    beginCreateOrUpdate(resourceGroupName: string, rackName: string, rackParameters: Rack, options?: RacksCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<RacksCreateOrUpdateResponse>, RacksCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, rackName: string, rackParameters: Rack, options?: RacksCreateOrUpdateOptionalParams): Promise<RacksCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, rackName: string, options?: RacksDeleteOptionalParams): Promise<SimplePollerLike<OperationState<RacksDeleteResponse>, RacksDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, rackName: string, options?: RacksDeleteOptionalParams): Promise<RacksDeleteResponse>;
    beginUpdate(resourceGroupName: string, rackName: string, options?: RacksUpdateOptionalParams): Promise<SimplePollerLike<OperationState<RacksUpdateResponse>, RacksUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, rackName: string, options?: RacksUpdateOptionalParams): Promise<RacksUpdateResponse>;
    get(resourceGroupName: string, rackName: string, options?: RacksGetOptionalParams): Promise<RacksGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: RacksListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Rack>;
    listBySubscription(options?: RacksListBySubscriptionOptionalParams): PagedAsyncIterableIterator<Rack>;
}

// @public
export interface RacksCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface RacksCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type RacksCreateOrUpdateResponse = Rack;

// @public
export interface RacksDeleteHeaders {
    location?: string;
}

// @public
export interface RacksDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type RacksDeleteResponse = OperationStatusResult;

// @public
export interface RacksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RacksGetResponse = Rack;

// @public
export interface RackSku extends Resource {
    readonly computeMachines?: MachineSkuSlot[];
    readonly controllerMachines?: MachineSkuSlot[];
    readonly description?: string;
    readonly maxClusterSlots?: number;
    readonly provisioningState?: RackSkuProvisioningState;
    readonly rackType?: RackSkuType;
    readonly storageAppliances?: StorageApplianceSkuSlot[];
    readonly supportedRackSkuIds?: string[];
}

// @public
export interface RackSkuList {
    nextLink?: string;
    value?: RackSku[];
}

// @public
export type RackSkuProvisioningState = string;

// @public
export interface RackSkus {
    get(rackSkuName: string, options?: RackSkusGetOptionalParams): Promise<RackSkusGetResponse>;
    listBySubscription(options?: RackSkusListBySubscriptionOptionalParams): PagedAsyncIterableIterator<RackSku>;
}

// @public
export interface RackSkusGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RackSkusGetResponse = RackSku;

// @public
export interface RackSkusListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RackSkusListBySubscriptionNextResponse = RackSkuList;

// @public
export interface RackSkusListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RackSkusListBySubscriptionResponse = RackSkuList;

// @public
export type RackSkuType = string;

// @public
export interface RacksListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RacksListByResourceGroupNextResponse = RackList;

// @public
export interface RacksListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RacksListByResourceGroupResponse = RackList;

// @public
export interface RacksListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RacksListBySubscriptionNextResponse = RackList;

// @public
export interface RacksListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RacksListBySubscriptionResponse = RackList;

// @public
export interface RacksUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface RacksUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    rackUpdateParameters?: RackPatchParameters;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type RacksUpdateResponse = Rack;

// @public
export type RemoteVendorManagementFeature = string;

// @public
export type RemoteVendorManagementStatus = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface RuntimeProtectionConfiguration {
    enforcementLevel?: RuntimeProtectionEnforcementLevel;
}

// @public
export type RuntimeProtectionEnforcementLevel = string;

// @public
export interface RuntimeProtectionStatus {
    readonly definitionsLastUpdated?: Date;
    readonly definitionsVersion?: string;
    readonly scanCompletedTime?: Date;
    readonly scanScheduledTime?: Date;
    readonly scanStartedTime?: Date;
}

// @public
export interface SecretArchiveReference {
    readonly keyVaultId?: string;
    readonly secretName?: string;
    readonly secretVersion?: string;
}

// @public
export interface SecretArchiveSettings {
    associatedIdentity?: IdentitySelector;
    vaultUri?: string;
}

// @public
export interface SecretRotationStatus {
    readonly expirePeriodDays?: number;
    readonly lastRotationTime?: Date;
    readonly rotationPeriodDays?: number;
    readonly secretArchiveReference?: SecretArchiveReference;
    readonly secretType?: string;
}

// @public
export interface ServiceLoadBalancerBgpPeer {
    bfdEnabled?: BfdEnabled;
    bgpMultiHop?: BgpMultiHop;
    holdTime?: string;
    keepAliveTime?: string;
    myAsn?: number;
    name: string;
    password?: string;
    peerAddress: string;
    peerAsn: number;
    peerPort?: number;
}

// @public
export interface ServicePrincipalInformation {
    applicationId: string;
    password: string;
    principalId: string;
    tenantId: string;
}

// @public
export type SkipShutdown = string;

// @public
export interface SshPublicKey {
    keyData: string;
}

// @public
export interface StorageAppliance extends TrackedResource {
    administratorCredentials: AdministrativeCredentials;
    readonly capacity?: number;
    readonly capacityUsed?: number;
    readonly clusterId?: string;
    readonly detailedStatus?: StorageApplianceDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly managementIpv4Address?: string;
    readonly manufacturer?: string;
    readonly model?: string;
    readonly provisioningState?: StorageApplianceProvisioningState;
    rackId: string;
    rackSlot: number;
    readonly remoteVendorManagementFeature?: RemoteVendorManagementFeature;
    readonly remoteVendorManagementStatus?: RemoteVendorManagementStatus;
    readonly secretRotationStatus?: SecretRotationStatus[];
    serialNumber: string;
    storageApplianceSkuId: string;
    readonly version?: string;
}

// @public
export interface StorageApplianceConfigurationData {
    adminCredentials: AdministrativeCredentials;
    rackSlot: number;
    serialNumber: string;
    storageApplianceName?: string;
}

// @public
export type StorageApplianceDetailedStatus = string;

// @public
export interface StorageApplianceEnableRemoteVendorManagementParameters {
    supportEndpoints?: string[];
}

// @public
export interface StorageApplianceList {
    nextLink?: string;
    value?: StorageAppliance[];
}

// @public
export interface StorageAppliancePatchParameters {
    serialNumber?: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type StorageApplianceProvisioningState = string;

// @public
export interface StorageAppliances {
    beginCreateOrUpdate(resourceGroupName: string, storageApplianceName: string, storageApplianceParameters: StorageAppliance, options?: StorageAppliancesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<StorageAppliancesCreateOrUpdateResponse>, StorageAppliancesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, storageApplianceName: string, storageApplianceParameters: StorageAppliance, options?: StorageAppliancesCreateOrUpdateOptionalParams): Promise<StorageAppliancesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<StorageAppliancesDeleteResponse>, StorageAppliancesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesDeleteOptionalParams): Promise<StorageAppliancesDeleteResponse>;
    beginDisableRemoteVendorManagement(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesDisableRemoteVendorManagementOptionalParams): Promise<SimplePollerLike<OperationState<StorageAppliancesDisableRemoteVendorManagementResponse>, StorageAppliancesDisableRemoteVendorManagementResponse>>;
    beginDisableRemoteVendorManagementAndWait(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesDisableRemoteVendorManagementOptionalParams): Promise<StorageAppliancesDisableRemoteVendorManagementResponse>;
    beginEnableRemoteVendorManagement(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesEnableRemoteVendorManagementOptionalParams): Promise<SimplePollerLike<OperationState<StorageAppliancesEnableRemoteVendorManagementResponse>, StorageAppliancesEnableRemoteVendorManagementResponse>>;
    beginEnableRemoteVendorManagementAndWait(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesEnableRemoteVendorManagementOptionalParams): Promise<StorageAppliancesEnableRemoteVendorManagementResponse>;
    beginUpdate(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<StorageAppliancesUpdateResponse>, StorageAppliancesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesUpdateOptionalParams): Promise<StorageAppliancesUpdateResponse>;
    get(resourceGroupName: string, storageApplianceName: string, options?: StorageAppliancesGetOptionalParams): Promise<StorageAppliancesGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: StorageAppliancesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<StorageAppliance>;
    listBySubscription(options?: StorageAppliancesListBySubscriptionOptionalParams): PagedAsyncIterableIterator<StorageAppliance>;
}

// @public
export interface StorageAppliancesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface StorageAppliancesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAppliancesCreateOrUpdateResponse = StorageAppliance;

// @public
export interface StorageAppliancesDeleteHeaders {
    location?: string;
}

// @public
export interface StorageAppliancesDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAppliancesDeleteResponse = OperationStatusResult;

// @public
export interface StorageAppliancesDisableRemoteVendorManagementHeaders {
    location?: string;
}

// @public
export interface StorageAppliancesDisableRemoteVendorManagementOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAppliancesDisableRemoteVendorManagementResponse = OperationStatusResult;

// @public
export interface StorageAppliancesEnableRemoteVendorManagementHeaders {
    location?: string;
}

// @public
export interface StorageAppliancesEnableRemoteVendorManagementOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    storageApplianceEnableRemoteVendorManagementParameters?: StorageApplianceEnableRemoteVendorManagementParameters;
    updateIntervalInMs?: number;
}

// @public
export type StorageAppliancesEnableRemoteVendorManagementResponse = OperationStatusResult;

// @public
export interface StorageAppliancesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAppliancesGetResponse = StorageAppliance;

// @public
export interface StorageApplianceSkuSlot {
    readonly capacityGB?: number;
    readonly model?: string;
    readonly rackSlot?: number;
}

// @public
export interface StorageAppliancesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAppliancesListByResourceGroupNextResponse = StorageApplianceList;

// @public
export interface StorageAppliancesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAppliancesListByResourceGroupResponse = StorageApplianceList;

// @public
export interface StorageAppliancesListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAppliancesListBySubscriptionNextResponse = StorageApplianceList;

// @public
export interface StorageAppliancesListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAppliancesListBySubscriptionResponse = StorageApplianceList;

// @public
export interface StorageAppliancesUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface StorageAppliancesUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    storageApplianceUpdateParameters?: StorageAppliancePatchParameters;
    updateIntervalInMs?: number;
}

// @public
export type StorageAppliancesUpdateResponse = StorageAppliance;

// @public
export interface StorageProfile {
    osDisk: OsDisk;
    volumeAttachments?: string[];
}

// @public
export interface StringKeyValuePair {
    key: string;
    value: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TagsParameter {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface TrunkedNetwork extends TrackedResource {
    readonly associatedResourceIds?: string[];
    readonly clusterId?: string;
    readonly detailedStatus?: TrunkedNetworkDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly hybridAksClustersAssociatedIds?: string[];
    hybridAksPluginType?: HybridAksPluginType;
    interfaceName?: string;
    isolationDomainIds: string[];
    readonly provisioningState?: TrunkedNetworkProvisioningState;
    readonly virtualMachinesAssociatedIds?: string[];
    vlans: number[];
}

// @public
export interface TrunkedNetworkAttachmentConfiguration {
    networkId: string;
    pluginType?: KubernetesPluginType;
}

// @public
export type TrunkedNetworkDetailedStatus = string;

// @public
export interface TrunkedNetworkList {
    nextLink?: string;
    value?: TrunkedNetwork[];
}

// @public
export interface TrunkedNetworkPatchParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type TrunkedNetworkProvisioningState = string;

// @public
export interface TrunkedNetworks {
    beginCreateOrUpdate(resourceGroupName: string, trunkedNetworkName: string, trunkedNetworkParameters: TrunkedNetwork, options?: TrunkedNetworksCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<TrunkedNetworksCreateOrUpdateResponse>, TrunkedNetworksCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, trunkedNetworkName: string, trunkedNetworkParameters: TrunkedNetwork, options?: TrunkedNetworksCreateOrUpdateOptionalParams): Promise<TrunkedNetworksCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, trunkedNetworkName: string, options?: TrunkedNetworksDeleteOptionalParams): Promise<SimplePollerLike<OperationState<TrunkedNetworksDeleteResponse>, TrunkedNetworksDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, trunkedNetworkName: string, options?: TrunkedNetworksDeleteOptionalParams): Promise<TrunkedNetworksDeleteResponse>;
    get(resourceGroupName: string, trunkedNetworkName: string, options?: TrunkedNetworksGetOptionalParams): Promise<TrunkedNetworksGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: TrunkedNetworksListByResourceGroupOptionalParams): PagedAsyncIterableIterator<TrunkedNetwork>;
    listBySubscription(options?: TrunkedNetworksListBySubscriptionOptionalParams): PagedAsyncIterableIterator<TrunkedNetwork>;
    update(resourceGroupName: string, trunkedNetworkName: string, options?: TrunkedNetworksUpdateOptionalParams): Promise<TrunkedNetworksUpdateResponse>;
}

// @public
export interface TrunkedNetworksCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface TrunkedNetworksCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TrunkedNetworksCreateOrUpdateResponse = TrunkedNetwork;

// @public
export interface TrunkedNetworksDeleteHeaders {
    location?: string;
}

// @public
export interface TrunkedNetworksDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TrunkedNetworksDeleteResponse = OperationStatusResult;

// @public
export interface TrunkedNetworksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TrunkedNetworksGetResponse = TrunkedNetwork;

// @public
export interface TrunkedNetworksListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TrunkedNetworksListByResourceGroupNextResponse = TrunkedNetworkList;

// @public
export interface TrunkedNetworksListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TrunkedNetworksListByResourceGroupResponse = TrunkedNetworkList;

// @public
export interface TrunkedNetworksListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TrunkedNetworksListBySubscriptionNextResponse = TrunkedNetworkList;

// @public
export interface TrunkedNetworksListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TrunkedNetworksListBySubscriptionResponse = TrunkedNetworkList;

// @public
export interface TrunkedNetworksUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    trunkedNetworkUpdateParameters?: TrunkedNetworkPatchParameters;
}

// @public
export type TrunkedNetworksUpdateResponse = TrunkedNetwork;

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface ValidationThreshold {
    grouping: ValidationThresholdGrouping;
    type: ValidationThresholdType;
    value: number;
}

// @public
export type ValidationThresholdGrouping = string;

// @public
export type ValidationThresholdType = string;

// @public
export interface VirtualMachine extends TrackedResource {
    adminUsername: string;
    readonly availabilityZone?: string;
    readonly bareMetalMachineId?: string;
    bootMethod?: VirtualMachineBootMethod;
    cloudServicesNetworkAttachment: NetworkAttachment;
    readonly clusterId?: string;
    consoleExtendedLocation?: ExtendedLocation;
    cpuCores: number;
    readonly detailedStatus?: VirtualMachineDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    isolateEmulatorThread?: VirtualMachineIsolateEmulatorThread;
    memorySizeGB: number;
    networkAttachments?: NetworkAttachment[];
    networkData?: string;
    placementHints?: VirtualMachinePlacementHint[];
    readonly powerState?: VirtualMachinePowerState;
    readonly provisioningState?: VirtualMachineProvisioningState;
    sshPublicKeys?: SshPublicKey[];
    storageProfile: StorageProfile;
    userData?: string;
    virtioInterface?: VirtualMachineVirtioInterfaceType;
    vmDeviceModel?: VirtualMachineDeviceModelType;
    vmImage: string;
    vmImageRepositoryCredentials?: ImageRepositoryCredentials;
    readonly volumes?: string[];
}

// @public
export type VirtualMachineBootMethod = string;

// @public
export type VirtualMachineDetailedStatus = string;

// @public
export type VirtualMachineDeviceModelType = string;

// @public
export type VirtualMachineIPAllocationMethod = string;

// @public
export type VirtualMachineIsolateEmulatorThread = string;

// @public
export interface VirtualMachineList {
    nextLink?: string;
    value?: VirtualMachine[];
}

// @public
export interface VirtualMachinePatchParameters {
    tags?: {
        [propertyName: string]: string;
    };
    vmImageRepositoryCredentials?: ImageRepositoryCredentials;
}

// @public
export interface VirtualMachinePlacementHint {
    hintType: VirtualMachinePlacementHintType;
    resourceId: string;
    schedulingExecution: VirtualMachineSchedulingExecution;
    scope: VirtualMachinePlacementHintPodAffinityScope;
}

// @public
export type VirtualMachinePlacementHintPodAffinityScope = string;

// @public
export type VirtualMachinePlacementHintType = string;

// @public
export interface VirtualMachinePowerOffParameters {
    skipShutdown?: SkipShutdown;
}

// @public
export type VirtualMachinePowerState = string;

// @public
export type VirtualMachineProvisioningState = string;

// @public
export interface VirtualMachines {
    beginCreateOrUpdate(resourceGroupName: string, virtualMachineName: string, virtualMachineParameters: VirtualMachine, options?: VirtualMachinesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<VirtualMachinesCreateOrUpdateResponse>, VirtualMachinesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, virtualMachineName: string, virtualMachineParameters: VirtualMachine, options?: VirtualMachinesCreateOrUpdateOptionalParams): Promise<VirtualMachinesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<VirtualMachinesDeleteResponse>, VirtualMachinesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesDeleteOptionalParams): Promise<VirtualMachinesDeleteResponse>;
    beginPowerOff(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesPowerOffOptionalParams): Promise<SimplePollerLike<OperationState<VirtualMachinesPowerOffResponse>, VirtualMachinesPowerOffResponse>>;
    beginPowerOffAndWait(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesPowerOffOptionalParams): Promise<VirtualMachinesPowerOffResponse>;
    beginReimage(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesReimageOptionalParams): Promise<SimplePollerLike<OperationState<VirtualMachinesReimageResponse>, VirtualMachinesReimageResponse>>;
    beginReimageAndWait(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesReimageOptionalParams): Promise<VirtualMachinesReimageResponse>;
    beginRestart(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesRestartOptionalParams): Promise<SimplePollerLike<OperationState<VirtualMachinesRestartResponse>, VirtualMachinesRestartResponse>>;
    beginRestartAndWait(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesRestartOptionalParams): Promise<VirtualMachinesRestartResponse>;
    beginStart(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesStartOptionalParams): Promise<SimplePollerLike<OperationState<VirtualMachinesStartResponse>, VirtualMachinesStartResponse>>;
    beginStartAndWait(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesStartOptionalParams): Promise<VirtualMachinesStartResponse>;
    beginUpdate(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<VirtualMachinesUpdateResponse>, VirtualMachinesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesUpdateOptionalParams): Promise<VirtualMachinesUpdateResponse>;
    get(resourceGroupName: string, virtualMachineName: string, options?: VirtualMachinesGetOptionalParams): Promise<VirtualMachinesGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: VirtualMachinesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<VirtualMachine>;
    listBySubscription(options?: VirtualMachinesListBySubscriptionOptionalParams): PagedAsyncIterableIterator<VirtualMachine>;
}

// @public
export type VirtualMachineSchedulingExecution = string;

// @public
export interface VirtualMachinesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface VirtualMachinesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VirtualMachinesCreateOrUpdateResponse = VirtualMachine;

// @public
export interface VirtualMachinesDeleteHeaders {
    location?: string;
}

// @public
export interface VirtualMachinesDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VirtualMachinesDeleteResponse = OperationStatusResult;

// @public
export interface VirtualMachinesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VirtualMachinesGetResponse = VirtualMachine;

// @public
export interface VirtualMachinesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VirtualMachinesListByResourceGroupNextResponse = VirtualMachineList;

// @public
export interface VirtualMachinesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VirtualMachinesListByResourceGroupResponse = VirtualMachineList;

// @public
export interface VirtualMachinesListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VirtualMachinesListBySubscriptionNextResponse = VirtualMachineList;

// @public
export interface VirtualMachinesListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VirtualMachinesListBySubscriptionResponse = VirtualMachineList;

// @public
export interface VirtualMachinesPowerOffHeaders {
    location?: string;
}

// @public
export interface VirtualMachinesPowerOffOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
    virtualMachinePowerOffParameters?: VirtualMachinePowerOffParameters;
}

// @public
export type VirtualMachinesPowerOffResponse = OperationStatusResult;

// @public
export interface VirtualMachinesReimageHeaders {
    location?: string;
}

// @public
export interface VirtualMachinesReimageOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VirtualMachinesReimageResponse = OperationStatusResult;

// @public
export interface VirtualMachinesRestartHeaders {
    location?: string;
}

// @public
export interface VirtualMachinesRestartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VirtualMachinesRestartResponse = OperationStatusResult;

// @public
export interface VirtualMachinesStartHeaders {
    location?: string;
}

// @public
export interface VirtualMachinesStartOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VirtualMachinesStartResponse = OperationStatusResult;

// @public
export interface VirtualMachinesUpdateHeaders {
    azureAsyncOperation?: string;
    location?: string;
}

// @public
export interface VirtualMachinesUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
    virtualMachineUpdateParameters?: VirtualMachinePatchParameters;
}

// @public
export type VirtualMachinesUpdateResponse = VirtualMachine;

// @public
export type VirtualMachineVirtioInterfaceType = string;

// @public
export interface Volume extends TrackedResource {
    readonly attachedTo?: string[];
    readonly detailedStatus?: VolumeDetailedStatus;
    readonly detailedStatusMessage?: string;
    readonly etag?: string;
    extendedLocation: ExtendedLocation;
    readonly provisioningState?: VolumeProvisioningState;
    readonly serialNumber?: string;
    sizeMiB: number;
}

// @public
export type VolumeDetailedStatus = string;

// @public
export interface VolumeList {
    nextLink?: string;
    value?: Volume[];
}

// @public
export interface VolumePatchParameters {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type VolumeProvisioningState = string;

// @public
export interface Volumes {
    beginCreateOrUpdate(resourceGroupName: string, volumeName: string, volumeParameters: Volume, options?: VolumesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<VolumesCreateOrUpdateResponse>, VolumesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, volumeName: string, volumeParameters: Volume, options?: VolumesCreateOrUpdateOptionalParams): Promise<VolumesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, volumeName: string, options?: VolumesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<VolumesDeleteResponse>, VolumesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, volumeName: string, options?: VolumesDeleteOptionalParams): Promise<VolumesDeleteResponse>;
    get(resourceGroupName: string, volumeName: string, options?: VolumesGetOptionalParams): Promise<VolumesGetResponse>;
    listByResourceGroup(resourceGroupName: string, options?: VolumesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Volume>;
    listBySubscription(options?: VolumesListBySubscriptionOptionalParams): PagedAsyncIterableIterator<Volume>;
    update(resourceGroupName: string, volumeName: string, options?: VolumesUpdateOptionalParams): Promise<VolumesUpdateResponse>;
}

// @public
export interface VolumesCreateOrUpdateHeaders {
    azureAsyncOperation?: string;
}

// @public
export interface VolumesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumesCreateOrUpdateResponse = Volume;

// @public
export interface VolumesDeleteHeaders {
    location?: string;
}

// @public
export interface VolumesDeleteOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumesDeleteResponse = OperationStatusResult;

// @public
export interface VolumesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesGetResponse = Volume;

// @public
export interface VolumesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListByResourceGroupNextResponse = VolumeList;

// @public
export interface VolumesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListByResourceGroupResponse = VolumeList;

// @public
export interface VolumesListBySubscriptionNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListBySubscriptionNextResponse = VolumeList;

// @public
export interface VolumesListBySubscriptionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListBySubscriptionResponse = VolumeList;

// @public
export interface VolumesUpdateOptionalParams extends coreClient.OperationOptions {
    ifMatch?: string;
    ifNoneMatch?: string;
    volumeUpdateParameters?: VolumePatchParameters;
}

// @public
export type VolumesUpdateResponse = Volume;

// @public
export interface VulnerabilityScanningSettings {
    containerScan?: VulnerabilityScanningSettingsContainerScan;
}

// @public
export type VulnerabilityScanningSettingsContainerScan = string;

// @public
export interface VulnerabilityScanningSettingsPatch {
    containerScan?: VulnerabilityScanningSettingsContainerScan;
}

// @public
export type WorkloadImpact = string;

// (No @packageDocumentation comment for this package)

```
