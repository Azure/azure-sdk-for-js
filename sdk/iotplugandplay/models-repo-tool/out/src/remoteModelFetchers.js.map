{"version":3,"file":"remoteModelFetchers.js","sourceRoot":"","sources":["../../src/remoteModelFetchers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\r\n\r\n'use strict'\r\n\r\nimport * as dtmiConventions from './dtmiConventions'\r\nimport * as modelMetadata from './modelMetadata'\r\nimport * as coreHttp from '@azure/core-http'\r\nimport { DTDL } from './DTDL'\r\nimport { flattenDtdlResponse } from './modelFetcherHelper'\r\n\r\nasync function recursiveFetcher (dtmi: string, endpoint: string, tryFromExpanded: boolean): Promise<{[dtmi: string]: DTDL }> {\r\n  let dependencyModels: {[x:string]: DTDL} = {}\r\n  let fetchedModels: {[x: string]: DTDL }\r\n  try {\r\n    console.log(`Fetching: ${dtmi}`)\r\n    fetchedModels = await fetcher(dtmi, endpoint, tryFromExpanded)\r\n  } catch (error) {\r\n    if (tryFromExpanded && (error.code === 'ENOENT' || !(error.statusCode >= 200 && error.statusCode < 400))) {\r\n      console.log('Fetching from expanded failed. Trying without.')\r\n      console.log(`Fetching: ${dtmi}`)\r\n      fetchedModels = await fetcher(dtmi, endpoint, false)\r\n    } else {\r\n      throw error\r\n    }\r\n  }\r\n  const dtmis = Object.keys(fetchedModels)\r\n  for (let i = 0; i < dtmis.length; i++) {\r\n    const currentDtdl = fetchedModels[dtmis[i]]\r\n    const deps = modelMetadata.getModelMetadata(currentDtdl).componentSchemas\r\n    if (deps && deps.length > 0) {\r\n      for (let j = 0; j < deps.length; j++) {\r\n        if (Object.keys(dependencyModels).includes(deps[j]) || Object.keys(fetchedModels).includes(deps[j])) {\r\n          // do nothing\r\n        } else {\r\n          const fetchedDependencies = await recursiveFetcher(deps[j], endpoint, tryFromExpanded)\r\n          dependencyModels = { ...dependencyModels, ...fetchedDependencies }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (Object.keys(dependencyModels).length > 0) {\r\n    fetchedModels = { ...fetchedModels, ...dependencyModels }\r\n  }\r\n  return fetchedModels\r\n}\r\n\r\nasync function fetcher (dtmi: string, endpoint: string, tryFromExpanded: boolean): Promise<{[dtmi: string]: any }> {\r\n  const client = new coreHttp.ServiceClient()\r\n  const req: coreHttp.RequestPrepareOptions = {\r\n    url: dtmiConventions.dtmiToQualifiedPath(dtmi, endpoint, tryFromExpanded),\r\n    method: 'GET'\r\n  }\r\n  const res: coreHttp.HttpOperationResponse = await client.sendRequest(req)\r\n  if (res.status >= 200 && res.status < 400) {\r\n    const dtdlAsString = res.bodyAsText || ''\r\n    const parsedDtdl = JSON.parse(dtdlAsString)\r\n    if (Array.isArray(parsedDtdl)) {\r\n      const result = flattenDtdlResponse(parsedDtdl as DTDL[])\r\n      return result\r\n    } else {\r\n      const result = { [dtmi]: parsedDtdl as DTDL }\r\n      return result\r\n    }\r\n  } else {\r\n    throw new coreHttp.RestError('Error on HTTP Request in remote model fetcher', '404', 404, undefined, res)\r\n  }\r\n}\r\n\r\nexport { fetcher, recursiveFetcher }\r\n"]}