{"version":3,"file":"modelConverters.js","sourceRoot":"","sources":["../../../src/internal/modelConverters.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type {\n  BatchQueryRequest as GeneratedBatchQueryRequest,\n  BatchQueryResponse as GeneratedBatchQueryResponse,\n  BatchQueryResults as GeneratedBatchQueryResults,\n  BatchRequest as GeneratedBatchRequest,\n  ErrorInfo as GeneratedErrorInfo,\n  QueryBatchResponse as GeneratedQueryBatchResponse,\n  Table as GeneratedTable,\n  QueryBody,\n} from \"../generated/logquery/src/index.js\";\n\nimport type {\n  Metric as GeneratedMetric,\n  MetricsListOptionalParams as GeneratedMetricsListOptionalParams,\n  MetricsListResponse as GeneratedMetricsListResponse,\n  TimeSeriesElement as GeneratedTimeSeriesElement,\n} from \"../generated/metrics/src/index.js\";\n\nimport type {\n  MetricDefinition as GeneratedMetricDefinition,\n  MetricDefinitionsListOptionalParams as GeneratedMetricDefinitionsListOptionalParams,\n} from \"../generated/metricsdefinitions/src/index.js\";\n\nimport type { MetricNamespace as GeneratedMetricNamespace } from \"../generated/metricsnamespaces/src/index.js\";\nimport { formatPreferHeader } from \"./util.js\";\nimport type {\n  ListMetricDefinitionsOptions,\n  Metric,\n  MetricAvailability,\n  MetricDefinition,\n  MetricNamespace,\n  MetricsQueryOptions,\n  MetricsQueryResult,\n  TimeSeriesElement,\n} from \"../models/publicMetricsModels.js\";\nimport { createMetricsQueryResult, getMetricByName } from \"../models/publicMetricsModels.js\";\nimport type { FullOperationResponse } from \"@azure/core-client\";\nimport {\n  convertIntervalToTimeIntervalObject,\n  convertTimespanToInterval,\n} from \"../timespanConversion.js\";\nimport type {\n  LogsErrorInfo,\n  LogsQueryBatchResult,\n  LogsQueryError,\n  LogsQueryPartialResult,\n  LogsQuerySuccessfulResult,\n  LogsTable,\n  QueryBatch,\n} from \"../models/publicLogsModels.js\";\nimport { LogsQueryResultStatus } from \"../models/publicLogsModels.js\";\nimport type {\n  MetricsBatchBatchResponse as GeneratedMetricsBatchResponse,\n  MetricsBatchBatchOptionalParams as GeneratedMetricsBatchOptionalParams,\n} from \"../generated/metricBatch/src/index.js\";\nimport type { MetricsQueryResourcesOptions } from \"../models/publicBatchModels.js\";\n\n/**\n * @internal\n */\nexport function convertRequestForQueryBatch(batch: QueryBatch[]): GeneratedBatchRequest {\n  let id = 0;\n\n  const requests: GeneratedBatchQueryRequest[] = batch.map((query: QueryBatch) => {\n    const body: Exclude<QueryBody, \"timespan\"> &\n      Partial<\n        Pick<\n          QueryBatch,\n          | \"query\"\n          | \"workspaceId\"\n          | \"includeQueryStatistics\"\n          | \"additionalWorkspaces\"\n          | \"includeVisualization\"\n          | \"serverTimeoutInSeconds\"\n        >\n      > = {\n      workspaceId: query.workspaceId,\n      query: query.query,\n    };\n    if (query[\"additionalWorkspaces\"]) {\n      body[\"workspaces\"] = query[\"additionalWorkspaces\"].map((x) => x);\n    }\n    if (query[\"timespan\"]) {\n      body[\"timespan\"] = convertTimespanToInterval(query[\"timespan\"]);\n    }\n    delete body[\"workspaceId\"];\n    delete body[\"includeQueryStatistics\"];\n    delete body[\"includeVisualization\"];\n    delete body[\"additionalWorkspaces\"];\n    delete body[\"serverTimeoutInSeconds\"];\n\n    const generatedRequest: GeneratedBatchQueryRequest = {\n      id: id.toString(),\n      workspace: query.workspaceId,\n      headers: formatPreferHeader(query),\n      body,\n    };\n\n    ++id;\n\n    return generatedRequest;\n  });\n\n  return {\n    requests,\n  };\n}\n\n/**\n * @internal\n */\nexport function convertResponseForQueryBatch(\n  generatedResponse: GeneratedQueryBatchResponse,\n  rawResponse: FullOperationResponse,\n): LogsQueryBatchResult {\n  const fixApplied = fixInvalidBatchQueryResponse(generatedResponse, rawResponse);\n  /* Sort the ids that are passed in with the queries, as numbers instead of strings\n   * It is not guaranteed that service will return the responses for queries in the same order\n   * as the queries are passed in\n   */\n  const responseList = generatedResponse.responses || [];\n\n  const newResponse: LogsQueryBatchResult = responseList\n    ?.sort((a, b) => {\n      let left = 0;\n      if (a.id != null) {\n        left = parseInt(a.id, 10);\n      }\n\n      let right = 0;\n      if (b.id != null) {\n        right = parseInt(b.id, 10);\n      }\n\n      return left - right;\n    })\n    ?.map((response: GeneratedBatchQueryResponse) => convertBatchQueryResponseHelper(response));\n\n  (newResponse as any)[\"__fixApplied\"] = fixApplied;\n  return newResponse;\n}\n/**\n * This is a workaround for a service bug that we're investigating. The 'body' column will occasionally come\n * back as a JSON string, instead of being a JSON object.\n *\n * (examples, with excess stuff trimmed)\n * Correct: `{\"responses\":[{\"body\":{\"tables\":[{\"name\":\"PrimaryResult\",\"columns\":[{\"name\":\"stringcolumn\",\"type\":\"string\"}],\"rows\":[[\"hello\"]}`\n * Broken: `{\"responses\":[{\"body\":\"{\\\"tables\\\":[{\\\"name\\\":\\\"PrimaryResult\\\",\\\"columns\\\":[{\\\"name\\\":\\\"stringcolumn\\\",\\\"type\\\":\\\"string\\\"}],\\\"rows\\\":[[\\\"hello\\\"]}`\n *\n * Issue here: https://github.com/Azure/azure-sdk-for-js/issues/15688\n *\n * @internal\n */\nexport function fixInvalidBatchQueryResponse(\n  generatedResponse: GeneratedQueryBatchResponse,\n  rawResponse: FullOperationResponse,\n): boolean {\n  if (generatedResponse.responses == null) {\n    return false;\n  }\n\n  let hadToFix = false;\n\n  // the body here is incorrect, deserialize the correct one from the raw response itself.\n  const parsedBody = JSON.parse(rawResponse.bodyAsText!);\n  // fix whichever responses are in this broken state (each query has it's own\n  // response, so they're not all always broken)\n  for (let i = 0; i < generatedResponse.responses.length; ++i) {\n    if (generatedResponse.responses[i].body?.error != null) {\n      continue;\n    }\n\n    // deserialize the raw response from the service, since we'll need index into it.\n\n    generatedResponse.responses[i].body = parsedBody.responses[i].body;\n\n    hadToFix = true;\n  }\n\n  return hadToFix;\n}\n\n/**\n * @internal\n */\nexport function convertRequestForMetricsBatchQuery(\n  metricsQueryResourcesOptions: MetricsQueryResourcesOptions | undefined,\n): GeneratedMetricsBatchOptionalParams {\n  if (!metricsQueryResourcesOptions) {\n    return {};\n  }\n\n  return {\n    starttime: metricsQueryResourcesOptions.startTime?.toISOString(),\n    endtime: metricsQueryResourcesOptions.endTime?.toISOString(),\n    rollupby: metricsQueryResourcesOptions.rollUpBy,\n    ...metricsQueryResourcesOptions,\n  };\n}\n\n/**\n * @internal\n */\nexport function convertRequestForMetrics(\n  metricNames: string[],\n  queryMetricsOptions: MetricsQueryOptions | undefined,\n): GeneratedMetricsListOptionalParams {\n  if (!queryMetricsOptions) {\n    return {};\n  }\n\n  const { orderBy, aggregations, metricNamespace, timespan, granularity, rollUpBy, ...rest } =\n    queryMetricsOptions;\n\n  const obj: GeneratedMetricsListOptionalParams = {\n    ...rest,\n  };\n\n  if (timespan) {\n    obj.timespan = convertTimespanToInterval(timespan);\n  }\n\n  if (orderBy) {\n    obj.orderby = orderBy;\n  }\n  if (metricNames) {\n    obj.metricnames = metricNames.join(\",\");\n  }\n  if (aggregations) {\n    obj.aggregation = aggregations.join(\",\");\n  }\n  if (metricNamespace) {\n    obj.metricnamespace = metricNamespace;\n  }\n  if (granularity) {\n    obj.interval = granularity;\n  }\n  if (rollUpBy) {\n    obj.rollupby = rollUpBy;\n  }\n  return obj;\n}\n\n/**\n * @internal\n */\nexport function convertResponseForMetrics(\n  generatedResponse: GeneratedMetricsListResponse,\n): MetricsQueryResult {\n  const metrics: Metric[] = generatedResponse.value.map((metric: GeneratedMetric) => {\n    const metricObject = {\n      ...metric,\n      name: metric.name.value,\n      description: metric.displayDescription,\n      timeseries: metric.timeseries.map(\n        (ts: GeneratedTimeSeriesElement) =>\n          <TimeSeriesElement>{\n            data: ts.data,\n            metadataValues: ts.metadatavalues?.map((mv) => ({\n              ...mv,\n              name: mv.name?.value,\n            })),\n          },\n      ),\n    };\n    delete metricObject.displayDescription;\n    return metricObject;\n  });\n\n  const { resourceregion, value: _ignoredValue, interval, timespan, ...rest } = generatedResponse;\n\n  const obj: Omit<MetricsQueryResult, \"getMetricByName\"> = {\n    ...rest,\n    metrics,\n    timespan: convertIntervalToTimeIntervalObject(timespan),\n  };\n\n  if (resourceregion) {\n    obj.resourceRegion = resourceregion;\n  }\n  if (interval) {\n    obj.granularity = interval;\n  }\n\n  return createMetricsQueryResult(obj);\n}\n\n/**\n * @internal\n */\nexport function convertRequestOptionsForMetricsDefinitions(\n  options: ListMetricDefinitionsOptions | undefined,\n): GeneratedMetricDefinitionsListOptionalParams {\n  if (!options) {\n    return {};\n  }\n\n  const { metricNamespace, ...rest } = options;\n\n  const obj: GeneratedMetricDefinitionsListOptionalParams = {\n    ...rest,\n  };\n\n  if (metricNamespace) {\n    obj.metricnamespace = metricNamespace;\n  }\n\n  return obj;\n}\n\nexport function convertResponseForMetricBatch(\n  generatedResponse: GeneratedMetricsBatchResponse,\n): MetricsQueryResult[] {\n  const result: Array<MetricsQueryResult> = [];\n\n  generatedResponse?.values?.forEach((genDef) => {\n    const response: MetricsQueryResult = {\n      timespan: {\n        startTime: new Date(genDef.starttime),\n        endTime: new Date(genDef.endtime),\n      },\n      granularity: genDef.interval,\n      namespace: genDef.namespace,\n      resourceRegion: genDef.resourceregion,\n      resourceId: genDef.resourceid,\n      metrics: genDef.value.map((genValue) => {\n        return {\n          ...genValue,\n          description: genValue.displayDescription ?? \"\",\n          name: genValue.name.value,\n        };\n      }),\n      getMetricByName,\n    };\n    result.push(response);\n  });\n\n  return result;\n}\n\n/**\n * @internal\n */\nexport function convertResponseForMetricsDefinitions(\n  generatedResponse: Array<GeneratedMetricDefinition>,\n): Array<MetricDefinition> {\n  const definitions: Array<MetricDefinition> = generatedResponse?.map((genDef) => {\n    const { name, dimensions, displayDescription, metricAvailabilities, ...rest } = genDef;\n\n    const response: MetricDefinition = {\n      ...rest,\n    };\n\n    if (displayDescription) {\n      response.description = displayDescription;\n    }\n    if (name?.value) {\n      response.name = name.value;\n    }\n\n    const mappedMetricAvailabilities: Array<MetricAvailability> | undefined =\n      metricAvailabilities?.map((genMetricAvail) => {\n        return {\n          granularity: genMetricAvail.timeGrain,\n          retention: genMetricAvail.retention,\n        };\n      });\n\n    if (mappedMetricAvailabilities) {\n      response.metricAvailabilities = mappedMetricAvailabilities;\n    }\n    const mappedDimensions = dimensions?.map((dim) => dim.value);\n\n    if (mappedDimensions) {\n      response.dimensions = mappedDimensions;\n    }\n    return response;\n  });\n  return definitions;\n}\n\n/**\n * @internal\n */\nexport function convertResponseForMetricNamespaces(\n  generatedResponse: Array<GeneratedMetricNamespace>,\n): Array<MetricNamespace> {\n  const namespaces: Array<MetricNamespace> = generatedResponse?.map((genDef) => {\n    const { properties, ...rest } = genDef;\n\n    const response: MetricNamespace = {\n      ...rest,\n    };\n\n    if (properties) {\n      response.metricNamespaceName = properties.metricNamespaceName;\n    }\n\n    return response;\n  });\n  return namespaces;\n}\n\n/**\n * @internal\n */\nexport function convertGeneratedTable(table: GeneratedTable): LogsTable {\n  const dynamicsIndices: number[] = [];\n  const datesIndices: number[] = [];\n\n  // most columns convert on deserialization except for `dynamic` columns (basically JSON objects)\n  // and 'datetime' (strings that are ISO8601 formatted dates)\n  for (let i = 0; i < table.columns.length; ++i) {\n    if (table.columns[i].type === \"datetime\") {\n      datesIndices.push(i);\n    } else if (table.columns[i].type === \"dynamic\") {\n      dynamicsIndices.push(i);\n    }\n  }\n\n  return {\n    ...table,\n    rows: (table.rows as LogsTable[\"rows\"]).map((row) => {\n      for (const dynamicIndex of dynamicsIndices) {\n        try {\n          row[dynamicIndex] = JSON.parse(row[dynamicIndex] as string) as Record<string, unknown>;\n        } catch (_err: any) {\n          /* leave as is. */\n        }\n      }\n\n      for (const dateIndex of datesIndices) {\n        row[dateIndex] = new Date(row[dateIndex] as string);\n      }\n\n      return row;\n    }),\n    columnDescriptors: table.columns,\n  };\n}\n\n/**\n * @internal\n */\nexport function convertBatchQueryResponseHelper(\n  response: GeneratedBatchQueryResponse,\n): LogsQueryPartialResult | LogsQuerySuccessfulResult | LogsQueryError {\n  try {\n    const parsedResponseBody: GeneratedBatchQueryResults = JSON.parse(\n      response.body as any,\n    ) as GeneratedBatchQueryResults;\n\n    return computeResultType(parsedResponseBody);\n  } catch (e: any) {\n    if (response.body) return computeResultType(response.body);\n    else return {} as LogsQuerySuccessfulResult;\n  }\n}\n\nexport function computeResultType(\n  generatedResponse: GeneratedBatchQueryResults,\n): LogsQueryPartialResult | LogsQuerySuccessfulResult | LogsQueryError {\n  if (!generatedResponse.error) {\n    const result: LogsQuerySuccessfulResult = {\n      visualization: generatedResponse.render,\n      status: LogsQueryResultStatus.Success,\n      statistics: generatedResponse.statistics,\n      tables:\n        generatedResponse.tables?.map((table: GeneratedTable) => convertGeneratedTable(table)) ||\n        [],\n    };\n    return result;\n  } else {\n    if (generatedResponse.tables) {\n      const result: LogsQueryPartialResult = {\n        visualization: generatedResponse.render,\n        status: LogsQueryResultStatus.PartialFailure,\n        statistics: generatedResponse.statistics,\n        partialTables: generatedResponse.tables?.map((table: GeneratedTable) =>\n          convertGeneratedTable(table),\n        ),\n        partialError: mapError(generatedResponse.error),\n      };\n      return result;\n    } else {\n      const errorInfo: LogsErrorInfo = mapError(generatedResponse.error);\n      const result: LogsQueryError = {\n        status: LogsQueryResultStatus.Failure,\n        ...errorInfo,\n      };\n      return result;\n    }\n  }\n}\n\nexport function mapError(error: GeneratedErrorInfo): LogsErrorInfo {\n  let innermostError = error;\n  while (innermostError.innerError) {\n    innermostError = innermostError.innerError;\n  }\n\n  return {\n    name: \"Error\",\n    code: error.code,\n    message: `${error.message}.  ${innermostError.message}`,\n  };\n}\n"]}