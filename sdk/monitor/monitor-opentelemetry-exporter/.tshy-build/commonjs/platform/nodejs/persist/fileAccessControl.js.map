{"version":3,"file":"fileAccessControl.js","sourceRoot":"","sources":["../../../../../src/platform/nodejs/persist/fileAccessControl.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { existsSync } from \"node:fs\";\nimport { type as osType } from \"node:os\";\nimport { spawn, spawnSync } from \"node:child_process\";\nimport { diag } from \"@opentelemetry/api\";\nimport process from \"node:process\";\n\nexport class FileAccessControl {\n  private static ICACLS_PATH = `${process.env.SYSTEMDRIVE}/windows/system32/icacls.exe`;\n  private static POWERSHELL_PATH = `${process.env.SYSTEMDRIVE}/windows/system32/windowspowershell/v1.0/powershell.exe`;\n  private static ACLED_DIRECTORIES: { [id: string]: boolean } = {};\n  private static ACL_IDENTITY: string | null = null;\n  private static OS_FILE_PROTECTION_CHECKED = false;\n  public static OS_PROVIDES_FILE_PROTECTION = false;\n  public static USE_ICACLS = osType() === \"Windows_NT\";\n\n  // Check if file access control could be enabled\n  public static checkFileProtection(): void {\n    if (\n      !FileAccessControl.OS_PROVIDES_FILE_PROTECTION &&\n      !FileAccessControl.OS_FILE_PROTECTION_CHECKED\n    ) {\n      FileAccessControl.OS_FILE_PROTECTION_CHECKED = true;\n      // Node's chmod levels do not appropriately restrict file access on Windows\n      // Use the built-in command line tool ICACLS on Windows to properly restrict\n      // access to the temporary directory used for disk retry mode.\n      if (FileAccessControl.USE_ICACLS) {\n        // This should be async - but it's currently safer to have this synchronous\n        // This guarantees we can immediately fail setDiskRetryMode if we need to\n        try {\n          FileAccessControl.OS_PROVIDES_FILE_PROTECTION = existsSync(FileAccessControl.ICACLS_PATH);\n        } catch (e: any) {\n          // Ignore error\n        }\n        if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {\n          diag.warn(\n            \"Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.\",\n          );\n        }\n      } else {\n        // chmod works everywhere else\n        FileAccessControl.OS_PROVIDES_FILE_PROTECTION = true;\n      }\n    }\n  }\n\n  public static async applyACLRules(directory: string): Promise<void> {\n    if (FileAccessControl.USE_ICACLS) {\n      if (FileAccessControl.ACLED_DIRECTORIES[directory] === undefined) {\n        // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately\n        // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk\n        // This is better than the alternative of potentially infinitely spawned processes\n        FileAccessControl.ACLED_DIRECTORIES[directory] = false;\n        try {\n          // Restrict this directory to only current user and administrator access\n          const identity = await this._getACLIdentity();\n          await this._runICACLS(this._getACLArguments(directory, identity));\n          FileAccessControl.ACLED_DIRECTORIES[directory] = true;\n        } catch (ex: any) {\n          FileAccessControl.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is \"not yet tried\")\n          throw ex;\n        }\n      } else {\n        if (!FileAccessControl.ACLED_DIRECTORIES[directory]) {\n          throw new Error(\"Setting ACL restrictions did not succeed (cached result)\");\n        }\n      }\n    }\n  }\n\n  public static applyACLRulesSync(directory: string): void {\n    if (FileAccessControl.USE_ICACLS) {\n      // For performance, only run ACL rules if we haven't already during this session\n      if (FileAccessControl.ACLED_DIRECTORIES[directory] === undefined) {\n        this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));\n        FileAccessControl.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures\n        return;\n      } else if (!FileAccessControl.ACLED_DIRECTORIES[directory]) {\n        // falsy but not undefined\n        throw new Error(\"Setting ACL restrictions did not succeed (cached result)\");\n      }\n    }\n  }\n\n  private static _runICACLS(args: string[]): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const aclProc = spawn(FileAccessControl.ICACLS_PATH, args, <any>{\n        windowsHide: true,\n      });\n      aclProc.on(\"error\", (e: Error) => reject(e));\n      aclProc.on(\"close\", (code: number) => {\n        if (code === 0) {\n          resolve();\n        } else {\n          reject(\n            new Error(`Setting ACL restrictions did not succeed (ICACLS returned code ${code})`),\n          );\n        }\n      });\n    });\n  }\n\n  private static _runICACLSSync(args: string[]): void {\n    // Some very old versions of Node (< 0.11) don't have this\n    if (spawnSync) {\n      const aclProc = spawnSync(FileAccessControl.ICACLS_PATH, args, <any>{\n        windowsHide: true,\n      });\n      if (aclProc.error) {\n        throw aclProc.error;\n      } else if (aclProc.status !== 0) {\n        throw new Error(\n          `Setting ACL restrictions did not succeed (ICACLS returned code ${aclProc.status})`,\n        );\n      }\n    } else {\n      throw new Error(\"Could not synchronously call ICACLS under current version of Node.js\");\n    }\n  }\n\n  private static _getACLIdentity(): Promise<string> {\n    return new Promise((resolve, reject) => {\n      if (FileAccessControl.ACL_IDENTITY) {\n        resolve(FileAccessControl.ACL_IDENTITY);\n      }\n      const psProc = spawn(\n        FileAccessControl.POWERSHELL_PATH,\n        [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"],\n        <any>{\n          windowsHide: true,\n          stdio: [\"ignore\", \"pipe\", \"pipe\"], // Needed to prevent hanging on Win 7\n        },\n      );\n      let data = \"\";\n      psProc.stdout.on(\"data\", (d: string) => (data += d));\n      psProc.on(\"error\", (e: Error) => reject(e));\n      psProc.on(\"close\", (code: number) => {\n        FileAccessControl.ACL_IDENTITY = data && data.trim();\n        if (code === 0) {\n          resolve(FileAccessControl.ACL_IDENTITY);\n        } else {\n          reject(new Error(`Getting ACL identity did not succeed (PS returned code ${code})`));\n        }\n      });\n    });\n  }\n\n  private static _getACLIdentitySync(): string {\n    if (FileAccessControl.ACL_IDENTITY) {\n      return FileAccessControl.ACL_IDENTITY;\n    }\n    // Some very old versions of Node (< 0.11) don't have this\n    if (spawnSync) {\n      const psProc = spawnSync(\n        FileAccessControl.POWERSHELL_PATH,\n        [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"],\n        <any>{\n          windowsHide: true,\n          stdio: [\"ignore\", \"pipe\", \"pipe\"], // Needed to prevent hanging on Win 7\n        },\n      );\n      if (psProc.error) {\n        throw psProc.error;\n      } else if (psProc.status !== 0) {\n        throw new Error(`Getting ACL identity did not succeed (PS returned code ${psProc.status})`);\n      }\n      FileAccessControl.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();\n      return FileAccessControl.ACL_IDENTITY;\n    } else {\n      throw new Error(\"Could not synchronously get ACL identity under current version of Node.js\");\n    }\n  }\n\n  private static _getACLArguments(directory: string, identity: string): string[] {\n    return [\n      directory,\n      \"/grant\",\n      \"*S-1-5-32-544:(OI)(CI)F\", // Full permission for Administrators\n      \"/grant\",\n      `${identity}:(OI)(CI)F`, // Full permission for current user\n      \"/inheritance:r\",\n    ]; // Remove all inherited permissions\n  }\n}\n"]}