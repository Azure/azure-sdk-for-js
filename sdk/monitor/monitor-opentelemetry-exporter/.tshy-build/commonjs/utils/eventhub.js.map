{"version":3,"file":"eventhub.js","sourceRoot":"","sources":["../../../src/utils/eventhub.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;AAElC,4CAA8C;AAC9C,8CAA2D;AAC3D,8EAA6E;AAG7E,+EAAwF;AAExF,sEAAsF;AAEtF;;GAEG;AACH,MAAM,oBAAoB,GAAG,CAAC,IAAkB,EAAU,EAAE;IAC1D,IAAI,iBAAiB,GAAG,CAAC,CAAC;IAC1B,IAAI,eAAe,GAAG,CAAC,CAAC;IACxB,MAAM,WAAW,GAAG,IAAA,2BAAoB,EAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAEzD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,EAAE,UAAU,EAAE,EAAE,EAAE;QACpC,MAAM,YAAY,GAAG,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAG,sCAAa,CAAoB,CAAC;QACpE,IAAI,YAAY,EAAE,CAAC;YACjB,iBAAiB,IAAI,CAAC,CAAC;YACvB,eAAe,IAAI,WAAW,GAAG,CAAC,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;QAC9E,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,IAAI,CAAC,GAAG,CAAC,eAAe,GAAG,CAAC,iBAAiB,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AACjE,CAAC,CAAC;AAEF;;;;;GAKG;AACI,MAAM,iBAAiB,GAAG,CAC/B,IAAkB,EAClB,QAA4C,EACtC,EAAE;IACR,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,6BAAW,CAA6B,CAAC;IAC3E,MAAM,WAAW,GACf,CAAC,IAAI,CAAC,UAAU,CAAC,6CAAsB,CAAC;QACtC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC;QAC/B,SAAS,CACZ,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC,sBAAsB;IAC7C,MAAM,qBAAqB,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,uCAAqB,CAAC,IAAI,SAAS,CAAW,CAAC;IAE9F,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;QAClB,KAAK,cAAQ,CAAC,MAAM;YAClB,QAAQ,CAAC,IAAI,GAAG,SAAS,CAAC;YAC1B,QAAQ,CAAC,MAAM,GAAG,GAAG,WAAW,IAAI,qBAAqB,EAAE,CAAC;YAC5D,MAAM;QACR,KAAK,cAAQ,CAAC,QAAQ;YACpB,QAAQ,CAAC,IAAI,GAAG,mBAAmB,SAAS,EAAE,CAAC;YAC/C,QAAQ,CAAC,MAAM,GAAG,GAAG,WAAW,IAAI,qBAAqB,EAAE,CAAC;YAC5D,MAAM;QACR,KAAK,cAAQ,CAAC,QAAQ;YACpB,QAAQ,CAAC,IAAI,GAAG,mBAAmB,SAAS,EAAE,CAAC;YAC9C,QAAgB,CAAC,MAAM,GAAG,GAAG,WAAW,IAAI,qBAAqB,EAAE,CAAC;YACrE,QAAQ,CAAC,YAAY,mCAChB,QAAQ,CAAC,YAAY,KACxB,CAAC,4CAAmB,CAAC,EAAE,oBAAoB,CAAC,IAAI,CAAC,GAClD,CAAC;YACF,MAAM;QACR,QAAQ,CAAC,QAAQ;IACnB,CAAC;AACH,CAAC,CAAC;AA/BW,QAAA,iBAAiB,qBA+B5B","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { SpanKind } from \"@opentelemetry/api\";\nimport { hrTimeToMilliseconds } from \"@opentelemetry/core\";\nimport { SEMATTRS_NET_PEER_NAME } from \"@opentelemetry/semantic-conventions\";\nimport type { ReadableSpan } from \"@opentelemetry/sdk-trace-base\";\nimport type { RemoteDependencyData, RequestData } from \"../generated/index.js\";\nimport { TIME_SINCE_ENQUEUED, ENQUEUED_TIME } from \"./constants/applicationinsights.js\";\nimport type { MicrosoftEventHub } from \"./constants/span/azAttributes.js\";\nimport { AzNamespace, MessageBusDestination } from \"./constants/span/azAttributes.js\";\n\n/**\n * Average span.links[].attributes.enqueuedTime\n */\nconst getTimeSinceEnqueued = (span: ReadableSpan): number => {\n  let countEnqueueDiffs = 0;\n  let sumEnqueueDiffs = 0;\n  const startTimeMs = hrTimeToMilliseconds(span.startTime);\n\n  span.links.forEach(({ attributes }) => {\n    const enqueuedTime = attributes?.[ENQUEUED_TIME] as string | number;\n    if (enqueuedTime) {\n      countEnqueueDiffs += 1;\n      sumEnqueueDiffs += startTimeMs - (parseFloat(enqueuedTime.toString()) || 0);\n    }\n  });\n\n  return Math.max(sumEnqueueDiffs / (countEnqueueDiffs || 1), 0);\n};\n\n/**\n * Implementation of Mapping to Azure Monitor\n *\n * https://gist.github.com/lmolkova/e4215c0f44a49ef824983382762e6b92#mapping-to-azure-monitor-application-insights-telemetry\n * @internal\n */\nexport const parseEventHubSpan = (\n  span: ReadableSpan,\n  baseData: RequestData | RemoteDependencyData,\n): void => {\n  const namespace = span.attributes[AzNamespace] as typeof MicrosoftEventHub;\n  const peerAddress = (\n    (span.attributes[SEMATTRS_NET_PEER_NAME] ||\n      span.attributes[\"peer.address\"] ||\n      \"unknown\") as string\n  ).replace(/\\/$/g, \"\"); // remove trailing \"/\"\n  const messageBusDestination = (span.attributes[MessageBusDestination] || \"unknown\") as string;\n\n  switch (span.kind) {\n    case SpanKind.CLIENT:\n      baseData.type = namespace;\n      baseData.target = `${peerAddress}/${messageBusDestination}`;\n      break;\n    case SpanKind.PRODUCER:\n      baseData.type = `Queue Message | ${namespace}`;\n      baseData.target = `${peerAddress}/${messageBusDestination}`;\n      break;\n    case SpanKind.CONSUMER:\n      baseData.type = `Queue Message | ${namespace}`;\n      (baseData as any).source = `${peerAddress}/${messageBusDestination}`;\n      baseData.measurements = {\n        ...baseData.measurements,\n        [TIME_SINCE_ENQUEUED]: getTimeSinceEnqueued(span),\n      };\n      break;\n    default: // no op\n  }\n};\n"]}