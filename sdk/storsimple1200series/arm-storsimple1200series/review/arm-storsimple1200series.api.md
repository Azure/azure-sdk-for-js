## API Report File for "@azure/arm-storsimple1200series"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export type AccessControlRecord = BaseModel & {
    initiatorName: string;
};

// @public
export interface AccessControlRecordList {
    value: AccessControlRecord[];
}

// @public
export interface AccessControlRecords {
    beginCreateOrUpdate(accessControlRecordName: string, resourceGroupName: string, managerName: string, accessControlRecord: AccessControlRecord, options?: AccessControlRecordsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<AccessControlRecordsCreateOrUpdateResponse>, AccessControlRecordsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(accessControlRecordName: string, resourceGroupName: string, managerName: string, accessControlRecord: AccessControlRecord, options?: AccessControlRecordsCreateOrUpdateOptionalParams): Promise<AccessControlRecordsCreateOrUpdateResponse>;
    beginDelete(accessControlRecordName: string, resourceGroupName: string, managerName: string, options?: AccessControlRecordsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(accessControlRecordName: string, resourceGroupName: string, managerName: string, options?: AccessControlRecordsDeleteOptionalParams): Promise<void>;
    get(accessControlRecordName: string, resourceGroupName: string, managerName: string, options?: AccessControlRecordsGetOptionalParams): Promise<AccessControlRecordsGetResponse>;
    listByManager(resourceGroupName: string, managerName: string, options?: AccessControlRecordsListByManagerOptionalParams): PagedAsyncIterableIterator<AccessControlRecord>;
}

// @public
export interface AccessControlRecordsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AccessControlRecordsCreateOrUpdateResponse = AccessControlRecord;

// @public
export interface AccessControlRecordsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface AccessControlRecordsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccessControlRecordsGetResponse = AccessControlRecord;

// @public
export interface AccessControlRecordsListByManagerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccessControlRecordsListByManagerResponse = AccessControlRecordList;

// @public
export type Alert = BaseModel & {
    title: string;
    scope: AlertScope;
    alertType: string;
    appearedAtTime: Date;
    appearedAtSourceTime: Date;
    clearedAtTime?: Date;
    clearedAtSourceTime?: Date;
    source: AlertSource;
    recommendation?: string;
    resolutionReason?: string;
    severity: AlertSeverity;
    status: AlertStatus;
    errorDetails?: AlertErrorDetails;
    detailedInformation?: {
        [propertyName: string]: string;
    };
};

// @public
export type AlertEmailNotificationStatus = "Enabled" | "Disabled";

// @public
export interface AlertErrorDetails {
    errorCode?: string;
    errorMessage?: string;
    occurences?: number;
}

// @public
export interface AlertFilter {
    appearedOnTime?: Date;
    severity?: AlertSeverity;
    sourceName?: string;
    sourceType?: AlertSourceType;
    status?: AlertStatus;
}

// @public
export interface AlertList {
    nextLink?: string;
    value: Alert[];
}

// @public
export interface Alerts {
    clear(resourceGroupName: string, managerName: string, request: ClearAlertRequest, options?: AlertsClearOptionalParams): Promise<void>;
    listByManager(resourceGroupName: string, managerName: string, options?: AlertsListByManagerOptionalParams): PagedAsyncIterableIterator<Alert>;
    sendTestEmail(deviceName: string, resourceGroupName: string, managerName: string, request: SendTestAlertEmailRequest, options?: AlertsSendTestEmailOptionalParams): Promise<void>;
}

// @public
export interface AlertsClearOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AlertScope = "Resource" | "Device";

// @public
export type AlertSettings = BaseModel & {
    emailNotification: AlertEmailNotificationStatus;
    notificationToServiceOwners: ServiceOwnersAlertNotificationStatus;
    alertNotificationCulture: string;
    additionalRecipientEmailList?: string[];
};

// @public
export type AlertSeverity = "Informational" | "Warning" | "Critical";

// @public
export interface AlertsListByManagerNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type AlertsListByManagerNextResponse = AlertList;

// @public
export interface AlertsListByManagerOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type AlertsListByManagerResponse = AlertList;

// @public
export interface AlertSource {
    alertSourceType?: AlertSourceType;
    name?: string;
    timeZone?: string;
}

// @public
export type AlertSourceType = "Resource" | "Device";

// @public
export interface AlertsSendTestEmailOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AlertStatus = "Active" | "Cleared";

// @public
export interface AsymmetricEncryptedSecret {
    encryptionAlgorithm: EncryptionAlgorithm;
    encryptionCertificateThumbprint?: string;
    value: string;
}

// @public
export type AuthType = "Invalid" | "AccessControlService" | "AzureActiveDirectory";

// @public
export interface AvailableProviderOperation {
    display?: AvailableProviderOperationDisplay;
    name?: string;
    origin?: string;
    properties?: Record<string, unknown>;
}

// @public
export interface AvailableProviderOperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface AvailableProviderOperations {
    nextLink?: string;
    value: AvailableProviderOperation[];
}

// @public
export interface AvailableProviderOperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AvailableProviderOperationsListNextResponse = AvailableProviderOperations;

// @public
export interface AvailableProviderOperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AvailableProviderOperationsListResponse = AvailableProviderOperations;

// @public
export interface AvailableProviderOperationsOperations {
    list(options?: AvailableProviderOperationsListOptionalParams): PagedAsyncIterableIterator<AvailableProviderOperation>;
}

// @public
export type Backup = BaseModel & {
    targetId?: string;
    targetType?: string;
    sizeInBytes: number;
    createdTime?: Date;
    expirationTime?: Date;
    initiatedBy: InitiatedBy;
    deviceId: string;
    elements: BackupElement[];
};

// @public
export type BackupElement = BaseModel & {
    sizeInBytes: number;
    endpointName: string;
    dataPolicy: DataPolicy;
};

// @public
export interface BackupFilter {
    createdTime?: Date;
    initiatedBy?: InitiatedBy;
}

// @public
export interface BackupList {
    nextLink?: string;
    value: Backup[];
}

// @public
export interface Backups {
    beginClone(deviceName: string, backupName: string, elementName: string, resourceGroupName: string, managerName: string, cloneRequest: CloneRequest, options?: BackupsCloneOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginCloneAndWait(deviceName: string, backupName: string, elementName: string, resourceGroupName: string, managerName: string, cloneRequest: CloneRequest, options?: BackupsCloneOptionalParams): Promise<void>;
    beginDelete(deviceName: string, backupName: string, resourceGroupName: string, managerName: string, options?: BackupsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, backupName: string, resourceGroupName: string, managerName: string, options?: BackupsDeleteOptionalParams): Promise<void>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: BackupsListByDeviceOptionalParams): PagedAsyncIterableIterator<Backup>;
    listByManager(resourceGroupName: string, managerName: string, options?: BackupsListByManagerOptionalParams): PagedAsyncIterableIterator<Backup>;
}

// @public
export type BackupScheduleGroup = BaseModel & {
    startTime: Time;
};

// @public
export interface BackupScheduleGroupList {
    value: BackupScheduleGroup[];
}

// @public
export interface BackupScheduleGroups {
    beginCreateOrUpdate(deviceName: string, scheduleGroupName: string, resourceGroupName: string, managerName: string, scheduleGroup: BackupScheduleGroup, options?: BackupScheduleGroupsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<BackupScheduleGroupsCreateOrUpdateResponse>, BackupScheduleGroupsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, scheduleGroupName: string, resourceGroupName: string, managerName: string, scheduleGroup: BackupScheduleGroup, options?: BackupScheduleGroupsCreateOrUpdateOptionalParams): Promise<BackupScheduleGroupsCreateOrUpdateResponse>;
    beginDelete(deviceName: string, scheduleGroupName: string, resourceGroupName: string, managerName: string, options?: BackupScheduleGroupsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, scheduleGroupName: string, resourceGroupName: string, managerName: string, options?: BackupScheduleGroupsDeleteOptionalParams): Promise<void>;
    get(deviceName: string, scheduleGroupName: string, resourceGroupName: string, managerName: string, options?: BackupScheduleGroupsGetOptionalParams): Promise<BackupScheduleGroupsGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: BackupScheduleGroupsListByDeviceOptionalParams): PagedAsyncIterableIterator<BackupScheduleGroup>;
}

// @public
export interface BackupScheduleGroupsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BackupScheduleGroupsCreateOrUpdateResponse = BackupScheduleGroup;

// @public
export interface BackupScheduleGroupsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupScheduleGroupsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupScheduleGroupsGetResponse = BackupScheduleGroup;

// @public
export interface BackupScheduleGroupsListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupScheduleGroupsListByDeviceResponse = BackupScheduleGroupList;

// @public
export interface BackupsCloneOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupsListByDeviceNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    forFailover?: boolean;
}

// @public
export type BackupsListByDeviceNextResponse = BackupList;

// @public
export interface BackupsListByDeviceOptionalParams extends coreClient.OperationOptions {
    filter?: string;
    forFailover?: boolean;
}

// @public
export type BackupsListByDeviceResponse = BackupList;

// @public
export interface BackupsListByManagerNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type BackupsListByManagerNextResponse = BackupList;

// @public
export interface BackupsListByManagerOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type BackupsListByManagerResponse = BackupList;

// @public
export interface BaseModel {
    readonly id?: string;
    readonly name?: string;
    readonly type?: string;
}

// @public
export type ChapSettings = BaseModel & {
    password: AsymmetricEncryptedSecret;
};

// @public
export interface ChapSettingsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ChapSettingsCreateOrUpdateResponse = ChapSettings;

// @public
export interface ChapSettingsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ChapSettingsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ChapSettingsGetResponse = ChapSettings;

// @public
export interface ChapSettingsList {
    value: ChapSettings[];
}

// @public
export interface ChapSettingsListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ChapSettingsListByDeviceResponse = ChapSettingsList;

// @public
export interface ChapSettingsOperations {
    beginCreateOrUpdate(deviceName: string, chapUserName: string, resourceGroupName: string, managerName: string, chapSetting: ChapSettings, options?: ChapSettingsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<ChapSettingsCreateOrUpdateResponse>, ChapSettingsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, chapUserName: string, resourceGroupName: string, managerName: string, chapSetting: ChapSettings, options?: ChapSettingsCreateOrUpdateOptionalParams): Promise<ChapSettingsCreateOrUpdateResponse>;
    beginDelete(deviceName: string, chapUserName: string, resourceGroupName: string, managerName: string, options?: ChapSettingsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, chapUserName: string, resourceGroupName: string, managerName: string, options?: ChapSettingsDeleteOptionalParams): Promise<void>;
    get(deviceName: string, chapUserName: string, resourceGroupName: string, managerName: string, options?: ChapSettingsGetOptionalParams): Promise<ChapSettingsGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: ChapSettingsListByDeviceOptionalParams): PagedAsyncIterableIterator<ChapSettings>;
}

// @public
export interface ClearAlertRequest {
    alerts: string[];
    resolutionMessage?: string;
}

// @public
export interface CloneRequest {
    disk?: IscsiDisk;
    newEndpointName: string;
    share?: FileShare;
    targetAccessPointId: string;
    targetDeviceId: string;
}

// @public
export type CloudType = "Azure" | "S3" | "S3_RRS" | "OpenStack" | "HP";

// @public
export type ContractVersions = "InvalidVersion" | "V2011_09" | "V2012_02" | "V2012_05" | "V2012_12" | "V2013_04" | "V2013_10" | "V2013_11" | "V2014_04" | "V2014_06" | "V2014_07" | "V2014_09" | "V2014_10" | "V2014_12" | "V2015_01" | "V2015_02" | "V2015_04" | "V2015_05" | "V2015_06" | "V2015_07" | "V2015_08" | "V2015_10" | "V2015_12" | "V2016_01" | "V2016_02" | "V2016_04" | "V2016_05" | "V2016_07" | "V2016_08";

// @public
export type DataPolicy = "Invalid" | "Local" | "Tiered" | "Cloud";

// @public
export type Device = BaseModel & {
    activationTime?: Date;
    allowedDeviceOperations?: DeviceOperation[];
    culture?: string;
    deviceCapabilities?: SupportedDeviceCapabilities[];
    deviceDescription?: string;
    domainName?: string;
    deviceSoftwareVersion?: string;
    friendlySoftwareName?: string;
    deviceConfigurationStatus?: DeviceConfigurationStatus;
    modelDescription?: string;
    status?: DeviceStatus;
    typePropertiesType?: DeviceType;
    details?: DeviceDetails;
};

// @public
export type DeviceConfigurationStatus = "Complete" | "Pending";

// @public
export interface DeviceDetails {
    availableLocalStorageInBytes?: number;
    availableStorageInBytes?: number;
    endpointCount?: number;
    provisionedLocalStorageInBytes?: number;
    provisionedStorageInBytes?: number;
    totalBackupSizeInBytes?: number;
    totalLocalStorageInBytes?: number;
    totalStorageInBytes?: number;
    usingLocalStorageInBytes?: number;
    usingStorageInBytes?: number;
}

// @public
export interface DeviceList {
    value: Device[];
}

// @public
export type DeviceOperation = "None" | "Delete" | "DeleteWithWarning" | "DRSource" | "DRTarget" | "Browsable" | "ReadOnlyForDR" | "Deactivate";

// @public
export interface DevicePatch {
    deviceDescription?: string;
}

// @public
export interface Devices {
    beginCreateOrUpdateAlertSettings(deviceName: string, resourceGroupName: string, managerName: string, alertSettings: AlertSettings, options?: DevicesCreateOrUpdateAlertSettingsOptionalParams): Promise<PollerLike<PollOperationState<DevicesCreateOrUpdateAlertSettingsResponse>, DevicesCreateOrUpdateAlertSettingsResponse>>;
    beginCreateOrUpdateAlertSettingsAndWait(deviceName: string, resourceGroupName: string, managerName: string, alertSettings: AlertSettings, options?: DevicesCreateOrUpdateAlertSettingsOptionalParams): Promise<DevicesCreateOrUpdateAlertSettingsResponse>;
    beginCreateOrUpdateSecuritySettings(deviceName: string, resourceGroupName: string, managerName: string, securitySettings: SecuritySettings, options?: DevicesCreateOrUpdateSecuritySettingsOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginCreateOrUpdateSecuritySettingsAndWait(deviceName: string, resourceGroupName: string, managerName: string, securitySettings: SecuritySettings, options?: DevicesCreateOrUpdateSecuritySettingsOptionalParams): Promise<void>;
    beginDeactivate(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDeactivateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeactivateAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDeactivateOptionalParams): Promise<void>;
    beginDelete(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDeleteOptionalParams): Promise<void>;
    beginDownloadUpdates(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDownloadUpdatesOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDownloadUpdatesAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDownloadUpdatesOptionalParams): Promise<void>;
    beginFailover(deviceName: string, resourceGroupName: string, managerName: string, failoverRequest: FailoverRequest, options?: DevicesFailoverOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginFailoverAndWait(deviceName: string, resourceGroupName: string, managerName: string, failoverRequest: FailoverRequest, options?: DevicesFailoverOptionalParams): Promise<void>;
    beginInstallUpdates(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesInstallUpdatesOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginInstallUpdatesAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesInstallUpdatesOptionalParams): Promise<void>;
    beginPatch(deviceName: string, resourceGroupName: string, managerName: string, devicePatch: DevicePatch, options?: DevicesPatchOptionalParams): Promise<PollerLike<PollOperationState<DevicesPatchResponse>, DevicesPatchResponse>>;
    beginPatchAndWait(deviceName: string, resourceGroupName: string, managerName: string, devicePatch: DevicePatch, options?: DevicesPatchOptionalParams): Promise<DevicesPatchResponse>;
    beginScanForUpdates(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesScanForUpdatesOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginScanForUpdatesAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesScanForUpdatesOptionalParams): Promise<void>;
    get(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesGetOptionalParams): Promise<DevicesGetResponse>;
    getAlertSettings(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesGetAlertSettingsOptionalParams): Promise<DevicesGetAlertSettingsResponse>;
    getNetworkSettings(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesGetNetworkSettingsOptionalParams): Promise<DevicesGetNetworkSettingsResponse>;
    getTimeSettings(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesGetTimeSettingsOptionalParams): Promise<DevicesGetTimeSettingsResponse>;
    getUpdateSummary(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesGetUpdateSummaryOptionalParams): Promise<DevicesGetUpdateSummaryResponse>;
    listByManager(resourceGroupName: string, managerName: string, options?: DevicesListByManagerOptionalParams): PagedAsyncIterableIterator<Device>;
    listFailoverTarget(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesListFailoverTargetOptionalParams): PagedAsyncIterableIterator<Device>;
    listMetricDefinition(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
}

// @public
export interface DevicesCreateOrUpdateAlertSettingsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DevicesCreateOrUpdateAlertSettingsResponse = AlertSettings;

// @public
export interface DevicesCreateOrUpdateSecuritySettingsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesDeactivateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesDownloadUpdatesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesFailoverOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesGetAlertSettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesGetAlertSettingsResponse = AlertSettings;

// @public
export interface DevicesGetNetworkSettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesGetNetworkSettingsResponse = NetworkSettings;

// @public
export interface DevicesGetOptionalParams extends coreClient.OperationOptions {
    expand?: string;
}

// @public
export type DevicesGetResponse = Device;

// @public
export interface DevicesGetTimeSettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesGetTimeSettingsResponse = TimeSettings;

// @public
export interface DevicesGetUpdateSummaryOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesGetUpdateSummaryResponse = Updates;

// @public
export interface DevicesInstallUpdatesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesListByManagerOptionalParams extends coreClient.OperationOptions {
    expand?: string;
}

// @public
export type DevicesListByManagerResponse = DeviceList;

// @public
export interface DevicesListFailoverTargetOptionalParams extends coreClient.OperationOptions {
    expand?: string;
}

// @public
export type DevicesListFailoverTargetResponse = DeviceList;

// @public
export interface DevicesListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface DevicesListMetricsOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type DevicesListMetricsResponse = MetricList;

// @public
export interface DevicesPatchOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DevicesPatchResponse = Device;

// @public
export interface DevicesScanForUpdatesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DeviceStatus = "Unknown" | "Online" | "Offline" | "RequiresAttention" | "MaintenanceMode" | "Creating" | "Provisioning" | "Deleted" | "ReadyToSetup" | "Deactivated" | "Deactivating";

// @public
export type DeviceType = "Invalid" | "Appliance" | "VirtualAppliance" | "Series9000OnPremVirtualAppliance" | "Series9000VirtualAppliance" | "Series9000PhysicalAppliance";

// @public
export type DhcpStatus = "Enabled" | "Disabled";

// @public
export type DiskStatus = "Online" | "Offline";

// @public
export type DownloadPhase = "Unknown" | "Initializing" | "Downloading" | "Verifying";

// @public
export type EncryptionAlgorithm = "None" | "AES256" | "RSAES_PKCS1_v_1_5";

// @public
export type EncryptionSettings = BaseModel & {
    encryptionStatus: EncryptionStatus;
    keyRolloverStatus: KeyRolloverStatus;
};

// @public
export type EncryptionStatus = "Enabled" | "Disabled";

// @public (undocumented)
export interface ErrorModel {
    // (undocumented)
    errorCode: string;
    // (undocumented)
    message: Message;
    // (undocumented)
    values?: Item[];
}

// @public
export interface FailoverRequest {
    // (undocumented)
    accesspointIds?: string[];
    // (undocumented)
    keepSourceDevice?: boolean;
    // (undocumented)
    skipValidation?: boolean;
    // (undocumented)
    targetDeviceId?: string;
}

// @public
export type FileServer = BaseModel & {
    domainName: string;
    storageDomainId: string;
    backupScheduleGroupId: string;
    description?: string;
};

// @public
export interface FileServerList {
    value: FileServer[];
}

// @public
export interface FileServers {
    beginBackupNow(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, options?: FileServersBackupNowOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginBackupNowAndWait(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, options?: FileServersBackupNowOptionalParams): Promise<void>;
    beginCreateOrUpdate(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, fileServer: FileServer, options?: FileServersCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<FileServersCreateOrUpdateResponse>, FileServersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, fileServer: FileServer, options?: FileServersCreateOrUpdateOptionalParams): Promise<FileServersCreateOrUpdateResponse>;
    beginDelete(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, options?: FileServersDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, options?: FileServersDeleteOptionalParams): Promise<void>;
    get(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, options?: FileServersGetOptionalParams): Promise<FileServersGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: FileServersListByDeviceOptionalParams): PagedAsyncIterableIterator<FileServer>;
    listByManager(resourceGroupName: string, managerName: string, options?: FileServersListByManagerOptionalParams): PagedAsyncIterableIterator<FileServer>;
    listMetricDefinition(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, options?: FileServersListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, options?: FileServersListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
}

// @public
export interface FileServersBackupNowOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface FileServersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FileServersCreateOrUpdateResponse = FileServer;

// @public
export interface FileServersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface FileServersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileServersGetResponse = FileServer;

// @public
export interface FileServersListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileServersListByDeviceResponse = FileServerList;

// @public
export interface FileServersListByManagerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileServersListByManagerResponse = FileServerList;

// @public
export interface FileServersListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileServersListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface FileServersListMetricsOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type FileServersListMetricsResponse = MetricList;

// @public
export type FileShare = BaseModel & {
    description?: string;
    shareStatus: ShareStatus;
    dataPolicy: DataPolicy;
    adminUser: string;
    provisionedCapacityInBytes: number;
    readonly usedCapacityInBytes?: number;
    readonly localUsedCapacityInBytes?: number;
    monitoringStatus: MonitoringStatus;
};

// @public
export interface FileShareList {
    value: FileShare[];
}

// @public
export interface FileShares {
    beginCreateOrUpdate(deviceName: string, fileServerName: string, shareName: string, resourceGroupName: string, managerName: string, fileShare: FileShare, options?: FileSharesCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<FileSharesCreateOrUpdateResponse>, FileSharesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, fileServerName: string, shareName: string, resourceGroupName: string, managerName: string, fileShare: FileShare, options?: FileSharesCreateOrUpdateOptionalParams): Promise<FileSharesCreateOrUpdateResponse>;
    beginDelete(deviceName: string, fileServerName: string, shareName: string, resourceGroupName: string, managerName: string, options?: FileSharesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, fileServerName: string, shareName: string, resourceGroupName: string, managerName: string, options?: FileSharesDeleteOptionalParams): Promise<void>;
    get(deviceName: string, fileServerName: string, shareName: string, resourceGroupName: string, managerName: string, options?: FileSharesGetOptionalParams): Promise<FileSharesGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: FileSharesListByDeviceOptionalParams): PagedAsyncIterableIterator<FileShare>;
    listByFileServer(deviceName: string, fileServerName: string, resourceGroupName: string, managerName: string, options?: FileSharesListByFileServerOptionalParams): PagedAsyncIterableIterator<FileShare>;
    listMetricDefinition(deviceName: string, fileServerName: string, shareName: string, resourceGroupName: string, managerName: string, options?: FileSharesListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(deviceName: string, fileServerName: string, shareName: string, resourceGroupName: string, managerName: string, options?: FileSharesListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
}

// @public
export interface FileSharesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type FileSharesCreateOrUpdateResponse = FileShare;

// @public
export interface FileSharesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface FileSharesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileSharesGetResponse = FileShare;

// @public
export interface FileSharesListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileSharesListByDeviceResponse = FileShareList;

// @public
export interface FileSharesListByFileServerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileSharesListByFileServerResponse = FileShareList;

// @public
export interface FileSharesListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type FileSharesListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface FileSharesListMetricsOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type FileSharesListMetricsResponse = MetricList;

// @public
export type InitiatedBy = "Manual" | "Scheduled";

// @public
export interface IPConfig {
    gateway: string;
    ipAddress: string;
    prefixLength?: number;
}

// @public
export type IscsiDisk = BaseModel & {
    description?: string;
    diskStatus: DiskStatus;
    accessControlRecords: string[];
    dataPolicy: DataPolicy;
    provisionedCapacityInBytes: number;
    readonly usedCapacityInBytes?: number;
    readonly localUsedCapacityInBytes?: number;
    monitoringStatus: MonitoringStatus;
};

// @public
export interface IscsiDiskList {
    value: IscsiDisk[];
}

// @public
export interface IscsiDisks {
    beginCreateOrUpdate(deviceName: string, iscsiServerName: string, diskName: string, resourceGroupName: string, managerName: string, iscsiDisk: IscsiDisk, options?: IscsiDisksCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<IscsiDisksCreateOrUpdateResponse>, IscsiDisksCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, iscsiServerName: string, diskName: string, resourceGroupName: string, managerName: string, iscsiDisk: IscsiDisk, options?: IscsiDisksCreateOrUpdateOptionalParams): Promise<IscsiDisksCreateOrUpdateResponse>;
    beginDelete(deviceName: string, iscsiServerName: string, diskName: string, resourceGroupName: string, managerName: string, options?: IscsiDisksDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, iscsiServerName: string, diskName: string, resourceGroupName: string, managerName: string, options?: IscsiDisksDeleteOptionalParams): Promise<void>;
    get(deviceName: string, iscsiServerName: string, diskName: string, resourceGroupName: string, managerName: string, options?: IscsiDisksGetOptionalParams): Promise<IscsiDisksGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: IscsiDisksListByDeviceOptionalParams): PagedAsyncIterableIterator<IscsiDisk>;
    listByIscsiServer(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, options?: IscsiDisksListByIscsiServerOptionalParams): PagedAsyncIterableIterator<IscsiDisk>;
    listMetricDefinition(deviceName: string, iscsiServerName: string, diskName: string, resourceGroupName: string, managerName: string, options?: IscsiDisksListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(deviceName: string, iscsiServerName: string, diskName: string, resourceGroupName: string, managerName: string, options?: IscsiDisksListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
}

// @public
export interface IscsiDisksCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type IscsiDisksCreateOrUpdateResponse = IscsiDisk;

// @public
export interface IscsiDisksDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface IscsiDisksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type IscsiDisksGetResponse = IscsiDisk;

// @public
export interface IscsiDisksListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type IscsiDisksListByDeviceResponse = IscsiDiskList;

// @public
export interface IscsiDisksListByIscsiServerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type IscsiDisksListByIscsiServerResponse = IscsiDiskList;

// @public
export interface IscsiDisksListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type IscsiDisksListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface IscsiDisksListMetricsOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type IscsiDisksListMetricsResponse = MetricList;

// @public
export type IscsiServer = BaseModel & {
    storageDomainId: string;
    backupScheduleGroupId: string;
    description?: string;
    chapId?: string;
    reverseChapId?: string;
};

// @public
export interface IscsiServerList {
    value: IscsiServer[];
}

// @public
export interface IscsiServers {
    beginBackupNow(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, options?: IscsiServersBackupNowOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginBackupNowAndWait(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, options?: IscsiServersBackupNowOptionalParams): Promise<void>;
    beginCreateOrUpdate(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, iscsiServer: IscsiServer, options?: IscsiServersCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<IscsiServersCreateOrUpdateResponse>, IscsiServersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, iscsiServer: IscsiServer, options?: IscsiServersCreateOrUpdateOptionalParams): Promise<IscsiServersCreateOrUpdateResponse>;
    beginDelete(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, options?: IscsiServersDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, options?: IscsiServersDeleteOptionalParams): Promise<void>;
    get(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, options?: IscsiServersGetOptionalParams): Promise<IscsiServersGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: IscsiServersListByDeviceOptionalParams): PagedAsyncIterableIterator<IscsiServer>;
    listByManager(resourceGroupName: string, managerName: string, options?: IscsiServersListByManagerOptionalParams): PagedAsyncIterableIterator<IscsiServer>;
    listMetricDefinition(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, options?: IscsiServersListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(deviceName: string, iscsiServerName: string, resourceGroupName: string, managerName: string, options?: IscsiServersListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
}

// @public
export interface IscsiServersBackupNowOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface IscsiServersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type IscsiServersCreateOrUpdateResponse = IscsiServer;

// @public
export interface IscsiServersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface IscsiServersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type IscsiServersGetResponse = IscsiServer;

// @public
export interface IscsiServersListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type IscsiServersListByDeviceResponse = IscsiServerList;

// @public
export interface IscsiServersListByManagerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type IscsiServersListByManagerResponse = IscsiServerList;

// @public
export interface IscsiServersListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type IscsiServersListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface IscsiServersListMetricsOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type IscsiServersListMetricsResponse = MetricList;

// @public (undocumented)
export interface Item {
    // (undocumented)
    key: string;
    // (undocumented)
    value: string;
}

// @public
export type Job = BaseModel & {
    status: JobStatus;
    startTime?: Date;
    endTime?: Date;
    percentComplete: number;
    error?: JobErrorDetails;
    jobType?: JobType;
    targetId?: string;
    entityId?: string;
    entityType?: string;
    jobStages?: JobStage[];
    deviceId?: string;
    isCancellable?: boolean;
    stats?: JobStats;
    targetType?: TargetType;
    sourceDeviceId?: string;
    backupPointInTime?: Date;
    downloadProgress?: UpdateDownloadProgress;
    installProgress?: UpdateInstallProgress;
};

// @public
export interface JobErrorDetails {
    code: string;
    errorDetails?: JobErrorItem[];
    message: string;
}

// @public
export interface JobErrorItem {
    code: string;
    message: string;
    recommendations?: string[];
}

// @public
export interface JobFilter {
    jobType: JobType;
    startTime?: Date;
    status: JobStatus;
}

// @public
export interface JobList {
    nextLink?: string;
    value: Job[];
}

// @public
export interface Jobs {
    get(deviceName: string, jobName: string, resourceGroupName: string, managerName: string, options?: JobsGetOptionalParams): Promise<JobsGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: JobsListByDeviceOptionalParams): PagedAsyncIterableIterator<Job>;
    listByManager(resourceGroupName: string, managerName: string, options?: JobsListByManagerOptionalParams): PagedAsyncIterableIterator<Job>;
}

// @public
export interface JobsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type JobsGetResponse = Job;

// @public
export interface JobsListByDeviceNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type JobsListByDeviceNextResponse = JobList;

// @public
export interface JobsListByDeviceOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type JobsListByDeviceResponse = JobList;

// @public
export interface JobsListByManagerNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type JobsListByManagerNextResponse = JobList;

// @public
export interface JobsListByManagerOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type JobsListByManagerResponse = JobList;

// @public
export interface JobStage {
    detail?: string;
    errorCode?: string;
    message?: string;
    stageStatus: JobStatus;
}

// @public
export interface JobStats {
    completedWorkItemCount?: number;
    estimatedTimeRemaining?: number;
    totalWorkItemCount?: number;
}

// @public
export type JobStatus = "Invalid" | "Running" | "Succeeded" | "Failed" | "Canceled" | "Paused" | "Scheduled";

// @public
export type JobType = "Backup" | "Clone" | "Failover" | "DownloadUpdates" | "InstallUpdates";

// @public
export type KeyRolloverStatus = "Required" | "NotRequired";

// @public
export type Manager = Resource & {
    etag?: string;
    cisIntrinsicSettings?: ManagerIntrinsicSettings;
    sku?: ManagerSku;
    readonly provisioningState?: string;
};

// @public
export type ManagerExtendedInfo = BaseModel & {
    etag?: string;
    version?: string;
    integrityKey: string;
    encryptionKey?: string;
    encryptionKeyThumbprint?: string;
    portalCertificateThumbprint?: string;
    algorithm: string;
};

// @public
export interface ManagerIntrinsicSettings {
    type: ManagerType;
}

// @public
export interface ManagerList {
    value: Manager[];
}

// @public
export interface ManagerPatch {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface Managers {
    createExtendedInfo(resourceGroupName: string, managerName: string, managerExtendedInfo: ManagerExtendedInfo, options?: ManagersCreateExtendedInfoOptionalParams): Promise<ManagersCreateExtendedInfoResponse>;
    createOrUpdate(resourceGroupName: string, managerName: string, manager: Manager, options?: ManagersCreateOrUpdateOptionalParams): Promise<ManagersCreateOrUpdateResponse>;
    delete(resourceGroupName: string, managerName: string, options?: ManagersDeleteOptionalParams): Promise<void>;
    deleteExtendedInfo(resourceGroupName: string, managerName: string, options?: ManagersDeleteExtendedInfoOptionalParams): Promise<void>;
    get(resourceGroupName: string, managerName: string, options?: ManagersGetOptionalParams): Promise<ManagersGetResponse>;
    getEncryptionKey(resourceGroupName: string, managerName: string, options?: ManagersGetEncryptionKeyOptionalParams): Promise<ManagersGetEncryptionKeyResponse>;
    getEncryptionSettings(resourceGroupName: string, managerName: string, options?: ManagersGetEncryptionSettingsOptionalParams): Promise<ManagersGetEncryptionSettingsResponse>;
    getExtendedInfo(resourceGroupName: string, managerName: string, options?: ManagersGetExtendedInfoOptionalParams): Promise<ManagersGetExtendedInfoResponse>;
    list(options?: ManagersListOptionalParams): PagedAsyncIterableIterator<Manager>;
    listByResourceGroup(resourceGroupName: string, options?: ManagersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Manager>;
    listMetricDefinition(resourceGroupName: string, managerName: string, options?: ManagersListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(resourceGroupName: string, managerName: string, options?: ManagersListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
    update(resourceGroupName: string, managerName: string, parameters: ManagerPatch, options?: ManagersUpdateOptionalParams): Promise<ManagersUpdateResponse>;
    updateExtendedInfo(resourceGroupName: string, managerName: string, ifMatch: string, managerExtendedInfo: ManagerExtendedInfo, options?: ManagersUpdateExtendedInfoOptionalParams): Promise<ManagersUpdateExtendedInfoResponse>;
    uploadRegistrationCertificate(certificateName: string, resourceGroupName: string, managerName: string, uploadCertificateRequestrequest: UploadCertificateRequest, options?: ManagersUploadRegistrationCertificateOptionalParams): Promise<ManagersUploadRegistrationCertificateResponse>;
}

// @public
export interface ManagersCreateExtendedInfoOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersCreateExtendedInfoResponse = ManagerExtendedInfo;

// @public
export interface ManagersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersCreateOrUpdateResponse = Manager;

// @public
export interface ManagersDeleteExtendedInfoOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagersDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagersGetEncryptionKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetEncryptionKeyResponse = SymmetricEncryptedSecret;

// @public
export interface ManagersGetEncryptionSettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetEncryptionSettingsResponse = EncryptionSettings;

// @public
export interface ManagersGetExtendedInfoOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetExtendedInfoResponse = ManagerExtendedInfo;

// @public
export interface ManagersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetResponse = Manager;

// @public
export interface ManagerSku {
    name: "Standard";
}

// @public
export interface ManagersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersListByResourceGroupResponse = ManagerList;

// @public
export interface ManagersListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface ManagersListMetricsOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type ManagersListMetricsResponse = MetricList;

// @public
export interface ManagersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersListResponse = ManagerList;

// @public
export interface ManagersUpdateExtendedInfoOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersUpdateExtendedInfoResponse = ManagerExtendedInfo;

// @public
export interface ManagersUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersUpdateResponse = Manager;

// @public
export interface ManagersUploadRegistrationCertificateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersUploadRegistrationCertificateResponse = UploadCertificateResponse;

// @public
export type ManagerType = "GardaV1" | "HelsinkiV1";

// @public (undocumented)
export interface Message {
    // (undocumented)
    language?: string;
    // (undocumented)
    value?: string;
}

// @public
export type MetricAggregationType = "Average" | "Last" | "Maximum" | "Minimum" | "None" | "Total";

// @public
export interface MetricAvailablity {
    retention: string;
    timeGrain: string;
}

// @public
export interface MetricData {
    average: number;
    count: number;
    maximum: number;
    minimum: number;
    sum: number;
    timeStamp: Date;
}

// @public
export interface MetricDefinition {
    dimensions: MetricDimension[];
    metricAvailabilities: MetricAvailablity[];
    name: MetricName;
    primaryAggregationType: MetricAggregationType;
    resourceId: string;
    type: string;
    unit: MetricUnit;
}

// @public
export interface MetricDefinitionList {
    value: MetricDefinition[];
}

// @public
export interface MetricDimension {
    name: string;
    value: string;
}

// @public
export interface MetricFilter {
    endTime?: Date;
    name?: MetricNameFilter;
    startTime?: Date;
    timeGrain?: string;
}

// @public
export interface MetricList {
    value: Metrics[];
}

// @public
export interface MetricName {
    localizedValue: string;
    value: string;
}

// @public
export interface MetricNameFilter {
    value?: string;
}

// @public
export interface Metrics {
    dimensions: MetricDimension[];
    endTime: Date;
    name: MetricName;
    primaryAggregation: MetricAggregationType;
    resourceId: string;
    startTime: Date;
    timeGrain: string;
    type: string;
    unit: MetricUnit;
    values: MetricData[];
}

// @public
export type MetricUnit = "Bytes" | "BytesPerSecond" | "Count" | "CountPerSecond" | "Percent" | "Seconds";

// @public
export type MonitoringStatus = "Enabled" | "Disabled";

// @public
export interface NetworkAdapter {
    dhcpStatus: DhcpStatus;
    iPv4Info?: IPConfig;
    iPv6Info?: IPConfig;
    linkSpeed?: number;
    networkAdapterName: string;
}

// @public
export type NetworkSettings = BaseModel & {
    primaryDnsServer: string;
    secondaryDnsServer?: string;
    nodeNetworks: NodeNetwork[];
};

// @public
export interface NodeNetwork {
    networkAdapters: NetworkAdapter[];
}

// @public
export interface Resource {
    readonly id?: string;
    location: string;
    readonly name?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export type SecuritySettings = BaseModel & {
    deviceAdminPassword: AsymmetricEncryptedSecret;
};

// @public
export interface SendTestAlertEmailRequest {
    emailList: string[];
}

// @public
export type ServiceOwnersAlertNotificationStatus = "Enabled" | "Disabled";

// @public
export type ShareStatus = "Online" | "Offline";

// @public
export type SslStatus = "Enabled" | "Disabled";

// @public
export type StorageAccountCredential = BaseModel & {
    cloudType: CloudType;
    endPoint: string;
    login: string;
    location?: string;
    enableSSL: SslStatus;
    accessKey?: AsymmetricEncryptedSecret;
};

// @public
export interface StorageAccountCredentialList {
    value: StorageAccountCredential[];
}

// @public
export interface StorageAccountCredentials {
    beginCreateOrUpdate(credentialName: string, resourceGroupName: string, managerName: string, storageAccount: StorageAccountCredential, options?: StorageAccountCredentialsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<StorageAccountCredentialsCreateOrUpdateResponse>, StorageAccountCredentialsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(credentialName: string, resourceGroupName: string, managerName: string, storageAccount: StorageAccountCredential, options?: StorageAccountCredentialsCreateOrUpdateOptionalParams): Promise<StorageAccountCredentialsCreateOrUpdateResponse>;
    beginDelete(credentialName: string, resourceGroupName: string, managerName: string, options?: StorageAccountCredentialsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(credentialName: string, resourceGroupName: string, managerName: string, options?: StorageAccountCredentialsDeleteOptionalParams): Promise<void>;
    get(credentialName: string, resourceGroupName: string, managerName: string, options?: StorageAccountCredentialsGetOptionalParams): Promise<StorageAccountCredentialsGetResponse>;
    listByManager(resourceGroupName: string, managerName: string, options?: StorageAccountCredentialsListByManagerOptionalParams): PagedAsyncIterableIterator<StorageAccountCredential>;
}

// @public
export interface StorageAccountCredentialsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAccountCredentialsCreateOrUpdateResponse = StorageAccountCredential;

// @public
export interface StorageAccountCredentialsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StorageAccountCredentialsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountCredentialsGetResponse = StorageAccountCredential;

// @public
export interface StorageAccountCredentialsListByManagerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountCredentialsListByManagerResponse = StorageAccountCredentialList;

// @public
export type StorageDomain = BaseModel & {
    storageAccountCredentialIds: string[];
    encryptionKey?: AsymmetricEncryptedSecret;
    encryptionStatus: EncryptionStatus;
};

// @public
export interface StorageDomainList {
    value: StorageDomain[];
}

// @public
export interface StorageDomains {
    beginCreateOrUpdate(storageDomainName: string, resourceGroupName: string, managerName: string, storageDomain: StorageDomain, options?: StorageDomainsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<StorageDomainsCreateOrUpdateResponse>, StorageDomainsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(storageDomainName: string, resourceGroupName: string, managerName: string, storageDomain: StorageDomain, options?: StorageDomainsCreateOrUpdateOptionalParams): Promise<StorageDomainsCreateOrUpdateResponse>;
    beginDelete(storageDomainName: string, resourceGroupName: string, managerName: string, options?: StorageDomainsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(storageDomainName: string, resourceGroupName: string, managerName: string, options?: StorageDomainsDeleteOptionalParams): Promise<void>;
    get(storageDomainName: string, resourceGroupName: string, managerName: string, options?: StorageDomainsGetOptionalParams): Promise<StorageDomainsGetResponse>;
    listByManager(resourceGroupName: string, managerName: string, options?: StorageDomainsListByManagerOptionalParams): PagedAsyncIterableIterator<StorageDomain>;
}

// @public
export interface StorageDomainsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageDomainsCreateOrUpdateResponse = StorageDomain;

// @public
export interface StorageDomainsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StorageDomainsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageDomainsGetResponse = StorageDomain;

// @public
export interface StorageDomainsListByManagerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageDomainsListByManagerResponse = StorageDomainList;

// @public (undocumented)
export class StorSimpleManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: StorSimpleManagementClientOptionalParams);
    // (undocumented)
    accessControlRecords: AccessControlRecords;
    // (undocumented)
    alerts: Alerts;
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    availableProviderOperationsOperations: AvailableProviderOperationsOperations;
    // (undocumented)
    backups: Backups;
    // (undocumented)
    backupScheduleGroups: BackupScheduleGroups;
    // (undocumented)
    chapSettingsOperations: ChapSettingsOperations;
    // (undocumented)
    devices: Devices;
    // (undocumented)
    fileServers: FileServers;
    // (undocumented)
    fileShares: FileShares;
    // (undocumented)
    iscsiDisks: IscsiDisks;
    // (undocumented)
    iscsiServers: IscsiServers;
    // (undocumented)
    jobs: Jobs;
    // (undocumented)
    managers: Managers;
    // (undocumented)
    storageAccountCredentials: StorageAccountCredentials;
    // (undocumented)
    storageDomains: StorageDomains;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface StorSimpleManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export type SupportedDeviceCapabilities = "Invalid" | "FileServer" | "IscsiServer";

// @public
export interface SymmetricEncryptedSecret {
    encryptionAlgorithm: EncryptionAlgorithm;
    value: string;
    valueCertificateThumbprint?: string;
}

// @public
export type TargetType = "FileServer" | "DiskServer";

// @public
export interface Time {
    hour: number;
    minute: number;
}

// @public
export type TimeSettings = BaseModel & {
    timeZone: string;
    primaryTimeServer: string;
    secondaryTimeServer?: string;
};

// @public
export interface UpdateDownloadProgress {
    downloadPhase?: DownloadPhase;
    numberOfUpdatesDownloaded?: number;
    numberOfUpdatesToDownload?: number;
    percentComplete?: number;
    totalBytesDownloaded?: number;
    totalBytesToDownload?: number;
}

// @public
export interface UpdateInstallProgress {
    numberOfUpdatesInstalled?: number;
    numberOfUpdatesToInstall?: number;
    percentComplete?: number;
}

// @public
export type UpdateOperation = "Idle" | "Scanning" | "Downloading" | "Installing";

// @public
export type Updates = BaseModel & {
    deviceVersion?: string;
    deviceLastScannedTime?: Date;
    regularUpdatesAvailable?: boolean;
    rebootRequiredForInstall?: boolean;
    totalItemsPendingForDownload?: number;
    totalItemsPendingForInstall?: number;
    status?: UpdateOperation;
    lastCompletedScanTime?: Date;
    lastCompletedDownloadJobTime?: Date;
    lastCompletedInstallJobTime?: Date;
    inProgressDownloadJobId?: string;
    inProgressInstallJobId?: string;
    inProgressScanStartedTime?: Date;
    inProgressDownloadJobStartedTime?: Date;
    inProgressInstallJobStartedTime?: Date;
};

// @public
export interface UploadCertificateRequest {
    authType?: AuthType;
    certificate: string;
    readonly contractVersion?: ContractVersions;
}

// @public
export type UploadCertificateResponse = BaseModel & {
    authType?: AuthType;
    certificate: string;
    resourceId: number;
    aadAuthority: string;
    aadTenantId: string;
    servicePrincipalClientId: string;
    servicePrincipalObjectId: string;
    azureManagementEndpointAudience: string;
    subject: string;
    validFrom: Date;
    validTo: Date;
    thumbprint: string;
    friendlyName: string;
    issuer: string;
};

// (No @packageDocumentation comment for this package)

```
