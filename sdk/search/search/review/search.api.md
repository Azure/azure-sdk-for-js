## API Report File for "@azure/search"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { OperationOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';
import { ServiceClientCredentials } from '@azure/core-http';
import { WebResource } from '@azure/core-http';

// @public
export interface AutocompleteItem {
    readonly queryPlusText: string;
    readonly text: string;
}

// @public
export type AutocompleteMode = 'oneTerm' | 'twoTerms' | 'oneTermWithContext';

// @public
export type AutocompleteOptions<Fields> = OperationOptions & AutocompleteRequest<Fields>;

// @public
export interface AutocompleteRequest<Fields> {
    autocompleteMode?: AutocompleteMode;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    searchFields?: Fields[];
    searchText: string;
    suggesterName: string;
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface AutocompleteResult {
    readonly coverage?: number;
    readonly results: AutocompleteItem[];
}

// @public
export type CountDocumentsOptions = OperationOptions;

// @public
export type DeleteDocumentsOptions = IndexDocuments;

// @public
export interface FacetResult {
    [property: string]: any;
    readonly count?: number;
}

// @public
export class GeographyPoint {
    constructor(latitude: number, longitude: number);
    latitude: number;
    longitude: number;
    toJSON(): object;
}

// @public
export interface GetDocumentOptions<Fields> extends OperationOptions {
    selectedFields?: Fields[];
}

// @public
export type IndexAction<T> = {
    actionType: IndexActionType;
} & Partial<T>;

// @public
export type IndexActionType = 'upload' | 'merge' | 'mergeOrUpload' | 'delete';

// @public
export interface IndexDocuments extends OperationOptions {
    throwOnAnyFailure?: boolean;
}

// @public
export interface IndexDocumentsResult {
    readonly results: IndexingResult[];
}

// @public
export interface IndexingResult {
    readonly errorMessage?: string;
    readonly key: string;
    readonly statusCode: number;
    readonly succeeded: boolean;
}

// @public
export interface ListSearchResultsPageSettings {
    nextLink?: string;
    nextPageParameters?: RawSearchRequest;
}

// @public
export interface MergeDocumentsOptions extends IndexDocuments {
    uploadIfNotExists?: boolean;
}

// @public
export function odata(strings: TemplateStringsArray, ...values: unknown[]): string;

// @public
export type QueryType = 'simple' | 'full';

// @public
export interface RawSearchRequest {
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalResultCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    searchFields?: string;
    searchMode?: SearchMode;
    searchText?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export class SearchApiKeyCredential implements ServiceClientCredentials {
    constructor(apiKey: string);
    signRequest(webResource: WebResource): Promise<WebResource>;
    updateKey(apiKey: string): void;
}

// @public (undocumented)
export interface SearchDocumentsPageResult<T> extends SearchDocumentsResultBase {
    readonly nextLink?: string;
    readonly nextPageParameters?: RawSearchRequest;
    readonly results: SearchResult<T>[];
}

// @public (undocumented)
export interface SearchDocumentsResult<T> extends SearchDocumentsResultBase {
    readonly results: SearchIterator<T>;
}

// @public
export interface SearchDocumentsResultBase {
    readonly count?: number;
    readonly coverage?: number;
    readonly facets?: {
        [propertyName: string]: FacetResult[];
    };
}

// @public
export class SearchIndexClient<T> {
    constructor(endpoint: string, indexName: string, credential: SearchApiKeyCredential, options?: SearchIndexClientOptions);
    readonly apiVersion: string;
    autocomplete<Fields extends keyof T>(options: AutocompleteOptions<Fields>): Promise<AutocompleteResult>;
    countDocuments(options?: CountDocumentsOptions): Promise<number>;
    deleteDocuments(keyName: keyof T, keyValues: string[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
    readonly endpoint: string;
    getDocument<Fields extends keyof T>(key: string, options?: GetDocumentOptions<Fields>): Promise<T>;
    indexDocuments(batch: IndexAction<T>[], options?: IndexDocuments): Promise<IndexDocumentsResult>;
    readonly indexName: string;
    mergeDocuments(documents: T[], options?: MergeDocumentsOptions): Promise<IndexDocumentsResult>;
    search<Fields extends keyof T>(options?: SearchOptions<Fields>): Promise<SearchDocumentsResult<Pick<T, Fields>>>;
    suggest<Fields extends keyof T = never>(options: SuggestOptions<Fields>): Promise<SuggestDocumentsResult<Pick<T, Fields>>>;
    uploadDocuments(documents: T[], options?: UploadDocumentsOptions): Promise<IndexDocumentsResult>;
}

// @public
export type SearchIndexClientOptions = PipelineOptions;

// @public
export type SearchIterator<Fields> = PagedAsyncIterableIterator<SearchResult<Fields>, SearchDocumentsPageResult<Fields>, ListSearchResultsPageSettings>;

// @public
export type SearchMode = 'any' | 'all';

// @public
export type SearchOptions<Fields> = OperationOptions & SearchRequest<Fields>;

// @public
export interface SearchRequest<Fields> {
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalResultCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string[];
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    searchFields?: Fields[];
    searchMode?: SearchMode;
    searchText?: string;
    select?: Fields[];
    skip?: number;
    top?: number;
}

// @public
export type SearchResult<T> = {
    readonly score: number;
    readonly highlights?: {
        [propertyName: string]: string[];
    };
} & T;

// @public
export interface SuggestDocumentsResult<T> {
    readonly coverage?: number;
    readonly results: SuggestResult<T>[];
}

// @public
export type SuggestOptions<Fields> = OperationOptions & SuggestRequest<Fields>;

// @public
export interface SuggestRequest<Fields> {
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    orderBy?: string[];
    searchFields?: Fields[];
    searchText: string;
    select?: Fields[];
    suggesterName: string;
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export type SuggestResult<T> = {
    readonly text: string;
} & T;

// @public
export interface UploadDocumentsOptions extends IndexDocuments {
    mergeIfExists?: boolean;
}


// (No @packageDocumentation comment for this package)

```
