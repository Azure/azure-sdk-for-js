/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";


export const AnalyzeRequest: coreHttp.CompositeMapper = {
  serializedName: "AnalyzeRequest",
  type: {
    name: "Composite",
    className: "AnalyzeRequest",
    modelProperties: {
      text: {
        required: true,
        serializedName: "text",
        type: {
          name: "String"
        }
      },
      analyzer: {
        serializedName: "analyzer",
        type: {
          name: "String"
        }
      },
      tokenizer: {
        serializedName: "tokenizer",
        type: {
          name: "String"
        }
      },
      tokenFilters: {
        serializedName: "tokenFilters",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      charFilters: {
        serializedName: "charFilters",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const TokenInfo: coreHttp.CompositeMapper = {
  serializedName: "TokenInfo",
  type: {
    name: "Composite",
    className: "TokenInfo",
    modelProperties: {
      token: {
        required: true,
        readOnly: true,
        serializedName: "token",
        type: {
          name: "String"
        }
      },
      startOffset: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "startOffset",
        type: {
          name: "Number"
        }
      },
      endOffset: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "endOffset",
        type: {
          name: "Number"
        }
      },
      position: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "position",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const AnalyzeResult: coreHttp.CompositeMapper = {
  serializedName: "AnalyzeResult",
  type: {
    name: "Composite",
    className: "AnalyzeResult",
    modelProperties: {
      tokens: {
        required: true,
        serializedName: "tokens",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TokenInfo"
            }
          }
        }
      }
    }
  }
};

export const Analyzer: coreHttp.CompositeMapper = {
  serializedName: "Analyzer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "@odata.type",
      clientName: "odatatype"
    },
    uberParent: "Analyzer",
    className: "Analyzer",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      odatatype: {
        required: true,
        serializedName: "@odata\\.type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const CustomAnalyzer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.CustomAnalyzer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Analyzer.type.polymorphicDiscriminator,
    uberParent: "Analyzer",
    className: "CustomAnalyzer",
    modelProperties: {
      ...Analyzer.type.modelProperties,
      tokenizer: {
        required: true,
        serializedName: "tokenizer",
        type: {
          name: "String"
        }
      },
      tokenFilters: {
        serializedName: "tokenFilters",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      charFilters: {
        serializedName: "charFilters",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const PatternAnalyzer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.PatternAnalyzer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Analyzer.type.polymorphicDiscriminator,
    uberParent: "Analyzer",
    className: "PatternAnalyzer",
    modelProperties: {
      ...Analyzer.type.modelProperties,
      lowerCaseTerms: {
        serializedName: "lowercase",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      },
      pattern: {
        serializedName: "pattern",
        defaultValue: '\W+',
        type: {
          name: "String"
        }
      },
      flags: {
        serializedName: "flags",
        type: {
          name: "String"
        }
      },
      stopwords: {
        serializedName: "stopwords",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const StandardAnalyzer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.StandardAnalyzer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Analyzer.type.polymorphicDiscriminator,
    uberParent: "Analyzer",
    className: "StandardAnalyzer",
    modelProperties: {
      ...Analyzer.type.modelProperties,
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 255,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      stopwords: {
        serializedName: "stopwords",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const StopAnalyzer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.StopAnalyzer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Analyzer.type.polymorphicDiscriminator,
    uberParent: "Analyzer",
    className: "StopAnalyzer",
    modelProperties: {
      ...Analyzer.type.modelProperties,
      stopwords: {
        serializedName: "stopwords",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const Tokenizer: coreHttp.CompositeMapper = {
  serializedName: "Tokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "@odata.type",
      clientName: "odatatype"
    },
    uberParent: "Tokenizer",
    className: "Tokenizer",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      odatatype: {
        required: true,
        serializedName: "@odata\\.type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const ClassicTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.ClassicTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "ClassicTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 255,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const EdgeNGramTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "EdgeNGramTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      minGram: {
        serializedName: "minGram",
        defaultValue: 1,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      maxGram: {
        serializedName: "maxGram",
        defaultValue: 2,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      tokenChars: {
        serializedName: "tokenChars",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Enum",
              allowedValues: [
                "letter",
                "digit",
                "whitespace",
                "punctuation",
                "symbol"
              ]
            }
          }
        }
      }
    }
  }
};

export const KeywordTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.KeywordTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "KeywordTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      bufferSize: {
        serializedName: "bufferSize",
        defaultValue: 256,
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const KeywordTokenizerV2: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.KeywordTokenizerV2",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "KeywordTokenizerV2",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 256,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const MicrosoftLanguageTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "MicrosoftLanguageTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 255,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      isSearchTokenizer: {
        serializedName: "isSearchTokenizer",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      language: {
        serializedName: "language",
        type: {
          name: "Enum",
          allowedValues: [
            "bangla",
            "bulgarian",
            "catalan",
            "chineseSimplified",
            "chineseTraditional",
            "croatian",
            "czech",
            "danish",
            "dutch",
            "english",
            "french",
            "german",
            "greek",
            "gujarati",
            "hindi",
            "icelandic",
            "indonesian",
            "italian",
            "japanese",
            "kannada",
            "korean",
            "malay",
            "malayalam",
            "marathi",
            "norwegianBokmaal",
            "polish",
            "portuguese",
            "portugueseBrazilian",
            "punjabi",
            "romanian",
            "russian",
            "serbianCyrillic",
            "serbianLatin",
            "slovenian",
            "spanish",
            "swedish",
            "tamil",
            "telugu",
            "thai",
            "ukrainian",
            "urdu",
            "vietnamese"
          ]
        }
      }
    }
  }
};

export const MicrosoftLanguageStemmingTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "MicrosoftLanguageStemmingTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 255,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      isSearchTokenizer: {
        serializedName: "isSearchTokenizer",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      language: {
        serializedName: "language",
        type: {
          name: "Enum",
          allowedValues: [
            "arabic",
            "bangla",
            "bulgarian",
            "catalan",
            "croatian",
            "czech",
            "danish",
            "dutch",
            "english",
            "estonian",
            "finnish",
            "french",
            "german",
            "greek",
            "gujarati",
            "hebrew",
            "hindi",
            "hungarian",
            "icelandic",
            "indonesian",
            "italian",
            "kannada",
            "latvian",
            "lithuanian",
            "malay",
            "malayalam",
            "marathi",
            "norwegianBokmaal",
            "polish",
            "portuguese",
            "portugueseBrazilian",
            "punjabi",
            "romanian",
            "russian",
            "serbianCyrillic",
            "serbianLatin",
            "slovak",
            "slovenian",
            "spanish",
            "swedish",
            "tamil",
            "telugu",
            "turkish",
            "ukrainian",
            "urdu"
          ]
        }
      }
    }
  }
};

export const NGramTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.NGramTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "NGramTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      minGram: {
        serializedName: "minGram",
        defaultValue: 1,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      maxGram: {
        serializedName: "maxGram",
        defaultValue: 2,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      tokenChars: {
        serializedName: "tokenChars",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Enum",
              allowedValues: [
                "letter",
                "digit",
                "whitespace",
                "punctuation",
                "symbol"
              ]
            }
          }
        }
      }
    }
  }
};

export const PathHierarchyTokenizerV2: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "PathHierarchyTokenizerV2",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      delimiter: {
        serializedName: "delimiter",
        defaultValue: '/',
        type: {
          name: "String"
        }
      },
      replacement: {
        serializedName: "replacement",
        defaultValue: '/',
        type: {
          name: "String"
        }
      },
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 300,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      reverseTokenOrder: {
        serializedName: "reverse",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      numberOfTokensToSkip: {
        serializedName: "skip",
        defaultValue: 0,
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const PatternTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.PatternTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "PatternTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      pattern: {
        serializedName: "pattern",
        defaultValue: '\W+',
        type: {
          name: "String"
        }
      },
      flags: {
        serializedName: "flags",
        type: {
          name: "String"
        }
      },
      group: {
        serializedName: "group",
        defaultValue: -1,
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const StandardTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.StandardTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "StandardTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 255,
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const StandardTokenizerV2: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.StandardTokenizerV2",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "StandardTokenizerV2",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 255,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const UaxUrlEmailTokenizer: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Tokenizer.type.polymorphicDiscriminator,
    uberParent: "Tokenizer",
    className: "UaxUrlEmailTokenizer",
    modelProperties: {
      ...Tokenizer.type.modelProperties,
      maxTokenLength: {
        serializedName: "maxTokenLength",
        defaultValue: 255,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const TokenFilter: coreHttp.CompositeMapper = {
  serializedName: "TokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "@odata.type",
      clientName: "odatatype"
    },
    uberParent: "TokenFilter",
    className: "TokenFilter",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      odatatype: {
        required: true,
        serializedName: "@odata\\.type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const AsciiFoldingTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "AsciiFoldingTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      preserveOriginal: {
        serializedName: "preserveOriginal",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const CjkBigramTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.CjkBigramTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "CjkBigramTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      ignoreScripts: {
        serializedName: "ignoreScripts",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Enum",
              allowedValues: [
                "han",
                "hiragana",
                "katakana",
                "hangul"
              ]
            }
          }
        }
      },
      outputUnigrams: {
        serializedName: "outputUnigrams",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const CommonGramTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.CommonGramTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "CommonGramTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      commonWords: {
        required: true,
        serializedName: "commonWords",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      ignoreCase: {
        serializedName: "ignoreCase",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      useQueryMode: {
        serializedName: "queryMode",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const DictionaryDecompounderTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "DictionaryDecompounderTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      wordList: {
        required: true,
        serializedName: "wordList",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      minWordSize: {
        serializedName: "minWordSize",
        defaultValue: 5,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      minSubwordSize: {
        serializedName: "minSubwordSize",
        defaultValue: 2,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      maxSubwordSize: {
        serializedName: "maxSubwordSize",
        defaultValue: 15,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      onlyLongestMatch: {
        serializedName: "onlyLongestMatch",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const EdgeNGramTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "EdgeNGramTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      minGram: {
        serializedName: "minGram",
        defaultValue: 1,
        type: {
          name: "Number"
        }
      },
      maxGram: {
        serializedName: "maxGram",
        defaultValue: 2,
        type: {
          name: "Number"
        }
      },
      side: {
        serializedName: "side",
        type: {
          name: "Enum",
          allowedValues: [
            "front",
            "back"
          ]
        }
      }
    }
  }
};

export const EdgeNGramTokenFilterV2: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "EdgeNGramTokenFilterV2",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      minGram: {
        serializedName: "minGram",
        defaultValue: 1,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      maxGram: {
        serializedName: "maxGram",
        defaultValue: 2,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      side: {
        serializedName: "side",
        type: {
          name: "Enum",
          allowedValues: [
            "front",
            "back"
          ]
        }
      }
    }
  }
};

export const ElisionTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.ElisionTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "ElisionTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      articles: {
        serializedName: "articles",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const KeepTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.KeepTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "KeepTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      keepWords: {
        required: true,
        serializedName: "keepWords",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      lowerCaseKeepWords: {
        serializedName: "keepWordsCase",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const KeywordMarkerTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "KeywordMarkerTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      keywords: {
        required: true,
        serializedName: "keywords",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      ignoreCase: {
        serializedName: "ignoreCase",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const LengthTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.LengthTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "LengthTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      min: {
        serializedName: "min",
        defaultValue: 0,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      max: {
        serializedName: "max",
        defaultValue: 300,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const LimitTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.LimitTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "LimitTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      maxTokenCount: {
        serializedName: "maxTokenCount",
        defaultValue: 1,
        type: {
          name: "Number"
        }
      },
      consumeAllTokens: {
        serializedName: "consumeAllTokens",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const NGramTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.NGramTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "NGramTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      minGram: {
        serializedName: "minGram",
        defaultValue: 1,
        type: {
          name: "Number"
        }
      },
      maxGram: {
        serializedName: "maxGram",
        defaultValue: 2,
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const NGramTokenFilterV2: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.NGramTokenFilterV2",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "NGramTokenFilterV2",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      minGram: {
        serializedName: "minGram",
        defaultValue: 1,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      },
      maxGram: {
        serializedName: "maxGram",
        defaultValue: 2,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const PatternCaptureTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.PatternCaptureTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "PatternCaptureTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      patterns: {
        required: true,
        serializedName: "patterns",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      preserveOriginal: {
        serializedName: "preserveOriginal",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const PatternReplaceTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.PatternReplaceTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "PatternReplaceTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      pattern: {
        required: true,
        serializedName: "pattern",
        type: {
          name: "String"
        }
      },
      replacement: {
        required: true,
        serializedName: "replacement",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const PhoneticTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.PhoneticTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "PhoneticTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      encoder: {
        serializedName: "encoder",
        type: {
          name: "Enum",
          allowedValues: [
            "metaphone",
            "doubleMetaphone",
            "soundex",
            "refinedSoundex",
            "caverphone1",
            "caverphone2",
            "cologne",
            "nysiis",
            "koelnerPhonetik",
            "haasePhonetik",
            "beiderMorse"
          ]
        }
      },
      replaceOriginalTokens: {
        serializedName: "replace",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const ShingleTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.ShingleTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "ShingleTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      maxShingleSize: {
        serializedName: "maxShingleSize",
        defaultValue: 2,
        constraints: {
          InclusiveMinimum: 2
        },
        type: {
          name: "Number"
        }
      },
      minShingleSize: {
        serializedName: "minShingleSize",
        defaultValue: 2,
        constraints: {
          InclusiveMinimum: 2
        },
        type: {
          name: "Number"
        }
      },
      outputUnigrams: {
        serializedName: "outputUnigrams",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      },
      outputUnigramsIfNoShingles: {
        serializedName: "outputUnigramsIfNoShingles",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      tokenSeparator: {
        serializedName: "tokenSeparator",
        defaultValue: '',
        type: {
          name: "String"
        }
      },
      filterToken: {
        serializedName: "filterToken",
        defaultValue: '_',
        type: {
          name: "String"
        }
      }
    }
  }
};

export const SnowballTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.SnowballTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "SnowballTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      language: {
        required: true,
        serializedName: "language",
        type: {
          name: "Enum",
          allowedValues: [
            "armenian",
            "basque",
            "catalan",
            "danish",
            "dutch",
            "english",
            "finnish",
            "french",
            "german",
            "german2",
            "hungarian",
            "italian",
            "kp",
            "lovins",
            "norwegian",
            "porter",
            "portuguese",
            "romanian",
            "russian",
            "spanish",
            "swedish",
            "turkish"
          ]
        }
      }
    }
  }
};

export const StemmerTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.StemmerTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "StemmerTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      language: {
        required: true,
        serializedName: "language",
        type: {
          name: "Enum",
          allowedValues: [
            "arabic",
            "armenian",
            "basque",
            "brazilian",
            "bulgarian",
            "catalan",
            "czech",
            "danish",
            "dutch",
            "dutchKp",
            "english",
            "lightEnglish",
            "minimalEnglish",
            "possessiveEnglish",
            "porter2",
            "lovins",
            "finnish",
            "lightFinnish",
            "french",
            "lightFrench",
            "minimalFrench",
            "galician",
            "minimalGalician",
            "german",
            "german2",
            "lightGerman",
            "minimalGerman",
            "greek",
            "hindi",
            "hungarian",
            "lightHungarian",
            "indonesian",
            "irish",
            "italian",
            "lightItalian",
            "sorani",
            "latvian",
            "norwegian",
            "lightNorwegian",
            "minimalNorwegian",
            "lightNynorsk",
            "minimalNynorsk",
            "portuguese",
            "lightPortuguese",
            "minimalPortuguese",
            "portugueseRslp",
            "romanian",
            "russian",
            "lightRussian",
            "spanish",
            "lightSpanish",
            "swedish",
            "lightSwedish",
            "turkish"
          ]
        }
      }
    }
  }
};

export const StemmerOverrideTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "StemmerOverrideTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      rules: {
        required: true,
        serializedName: "rules",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const StopwordsTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.StopwordsTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "StopwordsTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      stopwords: {
        serializedName: "stopwords",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      stopwordsList: {
        serializedName: "stopwordsList",
        type: {
          name: "Enum",
          allowedValues: [
            "arabic",
            "armenian",
            "basque",
            "brazilian",
            "bulgarian",
            "catalan",
            "czech",
            "danish",
            "dutch",
            "english",
            "finnish",
            "french",
            "galician",
            "german",
            "greek",
            "hindi",
            "hungarian",
            "indonesian",
            "irish",
            "italian",
            "latvian",
            "norwegian",
            "persian",
            "portuguese",
            "romanian",
            "russian",
            "sorani",
            "spanish",
            "swedish",
            "thai",
            "turkish"
          ]
        }
      },
      ignoreCase: {
        serializedName: "ignoreCase",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      removeTrailingStopWords: {
        serializedName: "removeTrailing",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const SynonymTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.SynonymTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "SynonymTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      synonyms: {
        required: true,
        serializedName: "synonyms",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      ignoreCase: {
        serializedName: "ignoreCase",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      expand: {
        serializedName: "expand",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const TruncateTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.TruncateTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "TruncateTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      length: {
        serializedName: "length",
        defaultValue: 300,
        constraints: {
          InclusiveMaximum: 300
        },
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const UniqueTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.UniqueTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "UniqueTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      onlyOnSamePosition: {
        serializedName: "onlyOnSamePosition",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const WordDelimiterTokenFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.WordDelimiterTokenFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: TokenFilter.type.polymorphicDiscriminator,
    uberParent: "TokenFilter",
    className: "WordDelimiterTokenFilter",
    modelProperties: {
      ...TokenFilter.type.modelProperties,
      generateWordParts: {
        serializedName: "generateWordParts",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      },
      generateNumberParts: {
        serializedName: "generateNumberParts",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      },
      catenateWords: {
        serializedName: "catenateWords",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      catenateNumbers: {
        serializedName: "catenateNumbers",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      catenateAll: {
        serializedName: "catenateAll",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      splitOnCaseChange: {
        serializedName: "splitOnCaseChange",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      },
      preserveOriginal: {
        serializedName: "preserveOriginal",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      splitOnNumerics: {
        serializedName: "splitOnNumerics",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      },
      stemEnglishPossessive: {
        serializedName: "stemEnglishPossessive",
        defaultValue: true,
        type: {
          name: "Boolean"
        }
      },
      protectedWords: {
        serializedName: "protectedWords",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const CharFilter: coreHttp.CompositeMapper = {
  serializedName: "CharFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "@odata.type",
      clientName: "odatatype"
    },
    uberParent: "CharFilter",
    className: "CharFilter",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      odatatype: {
        required: true,
        serializedName: "@odata\\.type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const MappingCharFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.MappingCharFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: CharFilter.type.polymorphicDiscriminator,
    uberParent: "CharFilter",
    className: "MappingCharFilter",
    modelProperties: {
      ...CharFilter.type.modelProperties,
      mappings: {
        required: true,
        serializedName: "mappings",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const PatternReplaceCharFilter: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.PatternReplaceCharFilter",
  type: {
    name: "Composite",
    polymorphicDiscriminator: CharFilter.type.polymorphicDiscriminator,
    uberParent: "CharFilter",
    className: "PatternReplaceCharFilter",
    modelProperties: {
      ...CharFilter.type.modelProperties,
      pattern: {
        required: true,
        serializedName: "pattern",
        type: {
          name: "String"
        }
      },
      replacement: {
        required: true,
        serializedName: "replacement",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const DataSourceCredentials: coreHttp.CompositeMapper = {
  serializedName: "DataSourceCredentials",
  type: {
    name: "Composite",
    className: "DataSourceCredentials",
    modelProperties: {
      connectionString: {
        serializedName: "connectionString",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const DataContainer: coreHttp.CompositeMapper = {
  serializedName: "DataContainer",
  type: {
    name: "Composite",
    className: "DataContainer",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const DataChangeDetectionPolicy: coreHttp.CompositeMapper = {
  serializedName: "DataChangeDetectionPolicy",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "@odata.type",
      clientName: "odatatype"
    },
    uberParent: "DataChangeDetectionPolicy",
    className: "DataChangeDetectionPolicy",
    modelProperties: {
      odatatype: {
        required: true,
        serializedName: "@odata\\.type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const HighWaterMarkChangeDetectionPolicy: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
  type: {
    name: "Composite",
    polymorphicDiscriminator: DataChangeDetectionPolicy.type.polymorphicDiscriminator,
    uberParent: "DataChangeDetectionPolicy",
    className: "HighWaterMarkChangeDetectionPolicy",
    modelProperties: {
      ...DataChangeDetectionPolicy.type.modelProperties,
      highWaterMarkColumnName: {
        required: true,
        serializedName: "highWaterMarkColumnName",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const SqlIntegratedChangeTrackingPolicy: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy",
  type: {
    name: "Composite",
    polymorphicDiscriminator: DataChangeDetectionPolicy.type.polymorphicDiscriminator,
    uberParent: "DataChangeDetectionPolicy",
    className: "SqlIntegratedChangeTrackingPolicy",
    modelProperties: {
      ...DataChangeDetectionPolicy.type.modelProperties
    }
  }
};

export const DataDeletionDetectionPolicy: coreHttp.CompositeMapper = {
  serializedName: "DataDeletionDetectionPolicy",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "@odata.type",
      clientName: "odatatype"
    },
    uberParent: "DataDeletionDetectionPolicy",
    className: "DataDeletionDetectionPolicy",
    modelProperties: {
      odatatype: {
        required: true,
        serializedName: "@odata\\.type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const SoftDeleteColumnDeletionDetectionPolicy: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
  type: {
    name: "Composite",
    polymorphicDiscriminator: DataDeletionDetectionPolicy.type.polymorphicDiscriminator,
    uberParent: "DataDeletionDetectionPolicy",
    className: "SoftDeleteColumnDeletionDetectionPolicy",
    modelProperties: {
      ...DataDeletionDetectionPolicy.type.modelProperties,
      softDeleteColumnName: {
        serializedName: "softDeleteColumnName",
        type: {
          name: "String"
        }
      },
      softDeleteMarkerValue: {
        serializedName: "softDeleteMarkerValue",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const DataSource: coreHttp.CompositeMapper = {
  serializedName: "DataSource",
  type: {
    name: "Composite",
    className: "DataSource",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      description: {
        serializedName: "description",
        type: {
          name: "String"
        }
      },
      type: {
        required: true,
        serializedName: "type",
        type: {
          name: "String"
        }
      },
      credentials: {
        required: true,
        serializedName: "credentials",
        type: {
          name: "Composite",
          className: "DataSourceCredentials"
        }
      },
      container: {
        required: true,
        serializedName: "container",
        type: {
          name: "Composite",
          className: "DataContainer"
        }
      },
      dataChangeDetectionPolicy: {
        serializedName: "dataChangeDetectionPolicy",
        type: {
          name: "Composite",
          className: "DataChangeDetectionPolicy"
        }
      },
      dataDeletionDetectionPolicy: {
        serializedName: "dataDeletionDetectionPolicy",
        type: {
          name: "Composite",
          className: "DataDeletionDetectionPolicy"
        }
      },
      etag: {
        serializedName: "@odata\\.etag",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const ListDataSourcesResult: coreHttp.CompositeMapper = {
  serializedName: "ListDataSourcesResult",
  type: {
    name: "Composite",
    className: "ListDataSourcesResult",
    modelProperties: {
      dataSources: {
        required: true,
        readOnly: true,
        serializedName: "value",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DataSource"
            }
          }
        }
      }
    }
  }
};

export const IndexingSchedule: coreHttp.CompositeMapper = {
  serializedName: "IndexingSchedule",
  type: {
    name: "Composite",
    className: "IndexingSchedule",
    modelProperties: {
      interval: {
        required: true,
        serializedName: "interval",
        type: {
          name: "TimeSpan"
        }
      },
      startTime: {
        serializedName: "startTime",
        type: {
          name: "DateTime"
        }
      }
    }
  }
};

export const IndexingParameters: coreHttp.CompositeMapper = {
  serializedName: "IndexingParameters",
  type: {
    name: "Composite",
    className: "IndexingParameters",
    modelProperties: {
      batchSize: {
        serializedName: "batchSize",
        type: {
          name: "Number"
        }
      },
      maxFailedItems: {
        serializedName: "maxFailedItems",
        defaultValue: 0,
        type: {
          name: "Number"
        }
      },
      maxFailedItemsPerBatch: {
        serializedName: "maxFailedItemsPerBatch",
        defaultValue: 0,
        type: {
          name: "Number"
        }
      },
      configuration: {
        serializedName: "configuration",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "Object"
            }
          }
        }
      }
    }
  }
};

export const FieldMappingFunction: coreHttp.CompositeMapper = {
  serializedName: "FieldMappingFunction",
  type: {
    name: "Composite",
    className: "FieldMappingFunction",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      parameters: {
        serializedName: "parameters",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "Object"
            }
          }
        }
      }
    }
  }
};

export const FieldMapping: coreHttp.CompositeMapper = {
  serializedName: "FieldMapping",
  type: {
    name: "Composite",
    className: "FieldMapping",
    modelProperties: {
      sourceFieldName: {
        required: true,
        serializedName: "sourceFieldName",
        type: {
          name: "String"
        }
      },
      targetFieldName: {
        serializedName: "targetFieldName",
        type: {
          name: "String"
        }
      },
      mappingFunction: {
        serializedName: "mappingFunction",
        type: {
          name: "Composite",
          className: "FieldMappingFunction"
        }
      }
    }
  }
};

export const Indexer: coreHttp.CompositeMapper = {
  serializedName: "Indexer",
  type: {
    name: "Composite",
    className: "Indexer",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      description: {
        serializedName: "description",
        type: {
          name: "String"
        }
      },
      dataSourceName: {
        required: true,
        serializedName: "dataSourceName",
        type: {
          name: "String"
        }
      },
      skillsetName: {
        serializedName: "skillsetName",
        type: {
          name: "String"
        }
      },
      targetIndexName: {
        required: true,
        serializedName: "targetIndexName",
        type: {
          name: "String"
        }
      },
      schedule: {
        serializedName: "schedule",
        type: {
          name: "Composite",
          className: "IndexingSchedule"
        }
      },
      parameters: {
        serializedName: "parameters",
        type: {
          name: "Composite",
          className: "IndexingParameters"
        }
      },
      fieldMappings: {
        serializedName: "fieldMappings",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "FieldMapping"
            }
          }
        }
      },
      outputFieldMappings: {
        serializedName: "outputFieldMappings",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "FieldMapping"
            }
          }
        }
      },
      isDisabled: {
        serializedName: "disabled",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      },
      etag: {
        serializedName: "@odata\\.etag",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const ListIndexersResult: coreHttp.CompositeMapper = {
  serializedName: "ListIndexersResult",
  type: {
    name: "Composite",
    className: "ListIndexersResult",
    modelProperties: {
      indexers: {
        required: true,
        readOnly: true,
        serializedName: "value",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Indexer"
            }
          }
        }
      }
    }
  }
};

export const ItemError: coreHttp.CompositeMapper = {
  serializedName: "ItemError",
  type: {
    name: "Composite",
    className: "ItemError",
    modelProperties: {
      key: {
        readOnly: true,
        serializedName: "key",
        type: {
          name: "String"
        }
      },
      errorMessage: {
        required: true,
        readOnly: true,
        serializedName: "errorMessage",
        type: {
          name: "String"
        }
      },
      statusCode: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "statusCode",
        type: {
          name: "Number"
        }
      },
      name: {
        readOnly: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      details: {
        readOnly: true,
        serializedName: "details",
        type: {
          name: "String"
        }
      },
      documentationLink: {
        readOnly: true,
        serializedName: "documentationLink",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const ItemWarning: coreHttp.CompositeMapper = {
  serializedName: "ItemWarning",
  type: {
    name: "Composite",
    className: "ItemWarning",
    modelProperties: {
      key: {
        readOnly: true,
        serializedName: "key",
        type: {
          name: "String"
        }
      },
      message: {
        required: true,
        readOnly: true,
        serializedName: "message",
        type: {
          name: "String"
        }
      },
      name: {
        readOnly: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      details: {
        readOnly: true,
        serializedName: "details",
        type: {
          name: "String"
        }
      },
      documentationLink: {
        readOnly: true,
        serializedName: "documentationLink",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const IndexerExecutionResult: coreHttp.CompositeMapper = {
  serializedName: "IndexerExecutionResult",
  type: {
    name: "Composite",
    className: "IndexerExecutionResult",
    modelProperties: {
      status: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "status",
        type: {
          name: "Enum",
          allowedValues: [
            "transientFailure",
            "success",
            "inProgress",
            "reset"
          ]
        }
      },
      errorMessage: {
        readOnly: true,
        serializedName: "errorMessage",
        type: {
          name: "String"
        }
      },
      startTime: {
        readOnly: true,
        serializedName: "startTime",
        type: {
          name: "DateTime"
        }
      },
      endTime: {
        readOnly: true,
        serializedName: "endTime",
        type: {
          name: "DateTime"
        }
      },
      errors: {
        required: true,
        readOnly: true,
        serializedName: "errors",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ItemError"
            }
          }
        }
      },
      warnings: {
        required: true,
        readOnly: true,
        serializedName: "warnings",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ItemWarning"
            }
          }
        }
      },
      itemCount: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "itemsProcessed",
        type: {
          name: "Number"
        }
      },
      failedItemCount: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "itemsFailed",
        type: {
          name: "Number"
        }
      },
      initialTrackingState: {
        readOnly: true,
        serializedName: "initialTrackingState",
        type: {
          name: "String"
        }
      },
      finalTrackingState: {
        readOnly: true,
        serializedName: "finalTrackingState",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const IndexerLimits: coreHttp.CompositeMapper = {
  serializedName: "IndexerLimits",
  type: {
    name: "Composite",
    className: "IndexerLimits",
    modelProperties: {
      maxRunTime: {
        readOnly: true,
        serializedName: "maxRunTime",
        type: {
          name: "TimeSpan"
        }
      },
      maxDocumentExtractionSize: {
        readOnly: true,
        serializedName: "maxDocumentExtractionSize",
        type: {
          name: "Number"
        }
      },
      maxDocumentContentCharactersToExtract: {
        readOnly: true,
        serializedName: "maxDocumentContentCharactersToExtract",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const IndexerExecutionInfo: coreHttp.CompositeMapper = {
  serializedName: "IndexerExecutionInfo",
  type: {
    name: "Composite",
    className: "IndexerExecutionInfo",
    modelProperties: {
      status: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "status",
        type: {
          name: "Enum",
          allowedValues: [
            "unknown",
            "error",
            "running"
          ]
        }
      },
      lastResult: {
        readOnly: true,
        serializedName: "lastResult",
        type: {
          name: "Composite",
          className: "IndexerExecutionResult"
        }
      },
      executionHistory: {
        required: true,
        readOnly: true,
        serializedName: "executionHistory",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "IndexerExecutionResult"
            }
          }
        }
      },
      limits: {
        required: true,
        readOnly: true,
        serializedName: "limits",
        type: {
          name: "Composite",
          className: "IndexerLimits"
        }
      }
    }
  }
};

export const Field: coreHttp.CompositeMapper = {
  serializedName: "Field",
  type: {
    name: "Composite",
    className: "Field",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      type: {
        required: true,
        serializedName: "type",
        type: {
          name: "String"
        }
      },
      key: {
        serializedName: "key",
        type: {
          name: "Boolean"
        }
      },
      retrievable: {
        serializedName: "retrievable",
        type: {
          name: "Boolean"
        }
      },
      searchable: {
        serializedName: "searchable",
        type: {
          name: "Boolean"
        }
      },
      filterable: {
        serializedName: "filterable",
        type: {
          name: "Boolean"
        }
      },
      sortable: {
        serializedName: "sortable",
        type: {
          name: "Boolean"
        }
      },
      facetable: {
        serializedName: "facetable",
        type: {
          name: "Boolean"
        }
      },
      analyzer: {
        serializedName: "analyzer",
        type: {
          name: "String"
        }
      },
      searchAnalyzer: {
        serializedName: "searchAnalyzer",
        type: {
          name: "String"
        }
      },
      indexAnalyzer: {
        serializedName: "indexAnalyzer",
        type: {
          name: "String"
        }
      },
      synonymMaps: {
        serializedName: "synonymMaps",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      fields: {
        serializedName: "fields",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Field"
            }
          }
        }
      }
    }
  }
};

export const TextWeights: coreHttp.CompositeMapper = {
  serializedName: "TextWeights",
  type: {
    name: "Composite",
    className: "TextWeights",
    modelProperties: {
      weights: {
        required: true,
        serializedName: "weights",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "Number"
            }
          }
        }
      }
    }
  }
};

export const ScoringFunction: coreHttp.CompositeMapper = {
  serializedName: "ScoringFunction",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "type",
      clientName: "type"
    },
    uberParent: "ScoringFunction",
    className: "ScoringFunction",
    modelProperties: {
      fieldName: {
        required: true,
        serializedName: "fieldName",
        type: {
          name: "String"
        }
      },
      boost: {
        required: true,
        serializedName: "boost",
        type: {
          name: "Number"
        }
      },
      interpolation: {
        serializedName: "interpolation",
        type: {
          name: "Enum",
          allowedValues: [
            "linear",
            "constant",
            "quadratic",
            "logarithmic"
          ]
        }
      },
      type: {
        required: true,
        serializedName: "type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const DistanceScoringParameters: coreHttp.CompositeMapper = {
  serializedName: "DistanceScoringParameters",
  type: {
    name: "Composite",
    className: "DistanceScoringParameters",
    modelProperties: {
      referencePointParameter: {
        required: true,
        serializedName: "referencePointParameter",
        type: {
          name: "String"
        }
      },
      boostingDistance: {
        required: true,
        serializedName: "boostingDistance",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const DistanceScoringFunction: coreHttp.CompositeMapper = {
  serializedName: "distance",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
    uberParent: "ScoringFunction",
    className: "DistanceScoringFunction",
    modelProperties: {
      ...ScoringFunction.type.modelProperties,
      parameters: {
        required: true,
        serializedName: "distance",
        type: {
          name: "Composite",
          className: "DistanceScoringParameters"
        }
      }
    }
  }
};

export const FreshnessScoringParameters: coreHttp.CompositeMapper = {
  serializedName: "FreshnessScoringParameters",
  type: {
    name: "Composite",
    className: "FreshnessScoringParameters",
    modelProperties: {
      boostingDuration: {
        required: true,
        serializedName: "boostingDuration",
        type: {
          name: "TimeSpan"
        }
      }
    }
  }
};

export const FreshnessScoringFunction: coreHttp.CompositeMapper = {
  serializedName: "freshness",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
    uberParent: "ScoringFunction",
    className: "FreshnessScoringFunction",
    modelProperties: {
      ...ScoringFunction.type.modelProperties,
      parameters: {
        required: true,
        serializedName: "freshness",
        type: {
          name: "Composite",
          className: "FreshnessScoringParameters"
        }
      }
    }
  }
};

export const MagnitudeScoringParameters: coreHttp.CompositeMapper = {
  serializedName: "MagnitudeScoringParameters",
  type: {
    name: "Composite",
    className: "MagnitudeScoringParameters",
    modelProperties: {
      boostingRangeStart: {
        required: true,
        serializedName: "boostingRangeStart",
        type: {
          name: "Number"
        }
      },
      boostingRangeEnd: {
        required: true,
        serializedName: "boostingRangeEnd",
        type: {
          name: "Number"
        }
      },
      shouldBoostBeyondRangeByConstant: {
        serializedName: "constantBoostBeyondRange",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const MagnitudeScoringFunction: coreHttp.CompositeMapper = {
  serializedName: "magnitude",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
    uberParent: "ScoringFunction",
    className: "MagnitudeScoringFunction",
    modelProperties: {
      ...ScoringFunction.type.modelProperties,
      parameters: {
        required: true,
        serializedName: "magnitude",
        type: {
          name: "Composite",
          className: "MagnitudeScoringParameters"
        }
      }
    }
  }
};

export const TagScoringParameters: coreHttp.CompositeMapper = {
  serializedName: "TagScoringParameters",
  type: {
    name: "Composite",
    className: "TagScoringParameters",
    modelProperties: {
      tagsParameter: {
        required: true,
        serializedName: "tagsParameter",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const TagScoringFunction: coreHttp.CompositeMapper = {
  serializedName: "tag",
  type: {
    name: "Composite",
    polymorphicDiscriminator: ScoringFunction.type.polymorphicDiscriminator,
    uberParent: "ScoringFunction",
    className: "TagScoringFunction",
    modelProperties: {
      ...ScoringFunction.type.modelProperties,
      parameters: {
        required: true,
        serializedName: "tag",
        type: {
          name: "Composite",
          className: "TagScoringParameters"
        }
      }
    }
  }
};

export const ScoringProfile: coreHttp.CompositeMapper = {
  serializedName: "ScoringProfile",
  type: {
    name: "Composite",
    className: "ScoringProfile",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      textWeights: {
        serializedName: "text",
        type: {
          name: "Composite",
          className: "TextWeights"
        }
      },
      functions: {
        serializedName: "functions",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ScoringFunction"
            }
          }
        }
      },
      functionAggregation: {
        serializedName: "functionAggregation",
        type: {
          name: "Enum",
          allowedValues: [
            "sum",
            "average",
            "minimum",
            "maximum",
            "firstMatching"
          ]
        }
      }
    }
  }
};

export const CorsOptions: coreHttp.CompositeMapper = {
  serializedName: "CorsOptions",
  type: {
    name: "Composite",
    className: "CorsOptions",
    modelProperties: {
      allowedOrigins: {
        required: true,
        serializedName: "allowedOrigins",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      maxAgeInSeconds: {
        serializedName: "maxAgeInSeconds",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const Suggester: coreHttp.CompositeMapper = {
  serializedName: "Suggester",
  type: {
    name: "Composite",
    className: "Suggester",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      searchMode: {
        required: true,
        isConstant: true,
        serializedName: "searchMode",
        defaultValue: 'analyzingInfixMatching',
        type: {
          name: "String"
        }
      },
      sourceFields: {
        required: true,
        serializedName: "sourceFields",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};

export const AzureActiveDirectoryApplicationCredentials: coreHttp.CompositeMapper = {
  serializedName: "AzureActiveDirectoryApplicationCredentials",
  type: {
    name: "Composite",
    className: "AzureActiveDirectoryApplicationCredentials",
    modelProperties: {
      applicationId: {
        required: true,
        serializedName: "applicationId",
        type: {
          name: "String"
        }
      },
      applicationSecret: {
        serializedName: "applicationSecret",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const EncryptionKey: coreHttp.CompositeMapper = {
  serializedName: "EncryptionKey",
  type: {
    name: "Composite",
    className: "EncryptionKey",
    modelProperties: {
      keyVaultKeyName: {
        required: true,
        serializedName: "keyVaultKeyName",
        type: {
          name: "String"
        }
      },
      keyVaultKeyVersion: {
        required: true,
        serializedName: "keyVaultKeyVersion",
        type: {
          name: "String"
        }
      },
      keyVaultUri: {
        required: true,
        serializedName: "keyVaultUri",
        type: {
          name: "String"
        }
      },
      accessCredentials: {
        serializedName: "accessCredentials",
        type: {
          name: "Composite",
          className: "AzureActiveDirectoryApplicationCredentials"
        }
      }
    }
  }
};

export const Index: coreHttp.CompositeMapper = {
  serializedName: "Index",
  type: {
    name: "Composite",
    className: "Index",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      fields: {
        required: true,
        serializedName: "fields",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Field"
            }
          }
        }
      },
      scoringProfiles: {
        serializedName: "scoringProfiles",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ScoringProfile"
            }
          }
        }
      },
      defaultScoringProfile: {
        serializedName: "defaultScoringProfile",
        type: {
          name: "String"
        }
      },
      corsOptions: {
        serializedName: "corsOptions",
        type: {
          name: "Composite",
          className: "CorsOptions"
        }
      },
      suggesters: {
        serializedName: "suggesters",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Suggester"
            }
          }
        }
      },
      analyzers: {
        serializedName: "analyzers",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Analyzer"
            }
          }
        }
      },
      tokenizers: {
        serializedName: "tokenizers",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Tokenizer"
            }
          }
        }
      },
      tokenFilters: {
        serializedName: "tokenFilters",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TokenFilter"
            }
          }
        }
      },
      charFilters: {
        serializedName: "charFilters",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CharFilter"
            }
          }
        }
      },
      encryptionKey: {
        serializedName: "encryptionKey",
        type: {
          name: "Composite",
          className: "EncryptionKey"
        }
      },
      etag: {
        serializedName: "@odata\\.etag",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const GetIndexStatisticsResult: coreHttp.CompositeMapper = {
  serializedName: "GetIndexStatisticsResult",
  type: {
    name: "Composite",
    className: "GetIndexStatisticsResult",
    modelProperties: {
      documentCount: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "documentCount",
        type: {
          name: "Number"
        }
      },
      storageSize: {
        required: true,
        nullable: false,
        readOnly: true,
        serializedName: "storageSize",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const ListIndexesResult: coreHttp.CompositeMapper = {
  serializedName: "ListIndexesResult",
  type: {
    name: "Composite",
    className: "ListIndexesResult",
    modelProperties: {
      indexes: {
        required: true,
        readOnly: true,
        serializedName: "value",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Index"
            }
          }
        }
      }
    }
  }
};

export const InputFieldMappingEntry: coreHttp.CompositeMapper = {
  serializedName: "InputFieldMappingEntry",
  type: {
    name: "Composite",
    className: "InputFieldMappingEntry",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      source: {
        serializedName: "source",
        type: {
          name: "String"
        }
      },
      sourceContext: {
        serializedName: "sourceContext",
        type: {
          name: "String"
        }
      },
      inputs: {
        serializedName: "inputs",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "InputFieldMappingEntry"
            }
          }
        }
      }
    }
  }
};

export const OutputFieldMappingEntry: coreHttp.CompositeMapper = {
  serializedName: "OutputFieldMappingEntry",
  type: {
    name: "Composite",
    className: "OutputFieldMappingEntry",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      targetName: {
        serializedName: "targetName",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const Skill: coreHttp.CompositeMapper = {
  serializedName: "Skill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "@odata.type",
      clientName: "odatatype"
    },
    uberParent: "Skill",
    className: "Skill",
    modelProperties: {
      name: {
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      description: {
        serializedName: "description",
        type: {
          name: "String"
        }
      },
      context: {
        serializedName: "context",
        type: {
          name: "String"
        }
      },
      inputs: {
        required: true,
        serializedName: "inputs",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "InputFieldMappingEntry"
            }
          }
        }
      },
      outputs: {
        required: true,
        serializedName: "outputs",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "OutputFieldMappingEntry"
            }
          }
        }
      },
      odatatype: {
        required: true,
        serializedName: "@odata\\.type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const CognitiveServicesAccount: coreHttp.CompositeMapper = {
  serializedName: "CognitiveServicesAccount",
  type: {
    name: "Composite",
    polymorphicDiscriminator: {
      serializedName: "@odata.type",
      clientName: "odatatype"
    },
    uberParent: "CognitiveServicesAccount",
    className: "CognitiveServicesAccount",
    modelProperties: {
      description: {
        serializedName: "description",
        type: {
          name: "String"
        }
      },
      odatatype: {
        required: true,
        serializedName: "@odata\\.type",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const Skillset: coreHttp.CompositeMapper = {
  serializedName: "Skillset",
  type: {
    name: "Composite",
    className: "Skillset",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      description: {
        required: true,
        serializedName: "description",
        type: {
          name: "String"
        }
      },
      skills: {
        required: true,
        serializedName: "skills",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Skill"
            }
          }
        }
      },
      cognitiveServicesAccount: {
        serializedName: "cognitiveServices",
        type: {
          name: "Composite",
          className: "CognitiveServicesAccount"
        }
      },
      etag: {
        serializedName: "@odata\\.etag",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const DefaultCognitiveServicesAccount: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.DefaultCognitiveServices",
  type: {
    name: "Composite",
    polymorphicDiscriminator: CognitiveServicesAccount.type.polymorphicDiscriminator,
    uberParent: "CognitiveServicesAccount",
    className: "DefaultCognitiveServicesAccount",
    modelProperties: {
      ...CognitiveServicesAccount.type.modelProperties
    }
  }
};

export const CognitiveServicesAccountKey: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Azure.Search.CognitiveServicesByKey",
  type: {
    name: "Composite",
    polymorphicDiscriminator: CognitiveServicesAccount.type.polymorphicDiscriminator,
    uberParent: "CognitiveServicesAccount",
    className: "CognitiveServicesAccountKey",
    modelProperties: {
      ...CognitiveServicesAccount.type.modelProperties,
      key: {
        required: true,
        serializedName: "key",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const ConditionalSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Util.ConditionalSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "ConditionalSkill",
    modelProperties: {
      ...Skill.type.modelProperties
    }
  }
};

export const KeyPhraseExtractionSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "KeyPhraseExtractionSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      defaultLanguageCode: {
        serializedName: "defaultLanguageCode",
        type: {
          name: "String"
        }
      },
      maxKeyPhraseCount: {
        nullable: true,
        serializedName: "maxKeyPhraseCount",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const OcrSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Vision.OcrSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "OcrSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      textExtractionAlgorithm: {
        serializedName: "textExtractionAlgorithm",
        type: {
          name: "Enum",
          allowedValues: [
            "printed",
            "handwritten"
          ]
        }
      },
      defaultLanguageCode: {
        serializedName: "defaultLanguageCode",
        type: {
          name: "String"
        }
      },
      shouldDetectOrientation: {
        serializedName: "detectOrientation",
        defaultValue: false,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};

export const ImageAnalysisSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Vision.ImageAnalysisSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "ImageAnalysisSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      defaultLanguageCode: {
        serializedName: "defaultLanguageCode",
        type: {
          name: "String"
        }
      },
      visualFeatures: {
        serializedName: "visualFeatures",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Enum",
              allowedValues: [
                "adult",
                "brands",
                "categories",
                "description",
                "faces",
                "objects",
                "tags"
              ]
            }
          }
        }
      },
      details: {
        serializedName: "details",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Enum",
              allowedValues: [
                "celebrities",
                "landmarks"
              ]
            }
          }
        }
      }
    }
  }
};

export const LanguageDetectionSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Text.LanguageDetectionSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "LanguageDetectionSkill",
    modelProperties: {
      ...Skill.type.modelProperties
    }
  }
};

export const ShaperSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Util.ShaperSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "ShaperSkill",
    modelProperties: {
      ...Skill.type.modelProperties
    }
  }
};

export const MergeSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Text.MergeSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "MergeSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      insertPreTag: {
        serializedName: "insertPreTag",
        defaultValue: '',
        type: {
          name: "String"
        }
      },
      insertPostTag: {
        serializedName: "insertPostTag",
        defaultValue: '',
        type: {
          name: "String"
        }
      }
    }
  }
};

export const EntityRecognitionSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Text.EntityRecognitionSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "EntityRecognitionSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      categories: {
        serializedName: "categories",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Enum",
              allowedValues: [
                "location",
                "organization",
                "person",
                "quantity",
                "datetime",
                "url",
                "email"
              ]
            }
          }
        }
      },
      defaultLanguageCode: {
        serializedName: "defaultLanguageCode",
        type: {
          name: "String"
        }
      },
      includeTypelessEntities: {
        nullable: true,
        serializedName: "includeTypelessEntities",
        type: {
          name: "Boolean"
        }
      },
      minimumPrecision: {
        nullable: true,
        serializedName: "minimumPrecision",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const SentimentSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Text.SentimentSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "SentimentSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      defaultLanguageCode: {
        serializedName: "defaultLanguageCode",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const SplitSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Text.SplitSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "SplitSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      defaultLanguageCode: {
        serializedName: "defaultLanguageCode",
        type: {
          name: "String"
        }
      },
      textSplitMode: {
        serializedName: "textSplitMode",
        type: {
          name: "Enum",
          allowedValues: [
            "pages",
            "sentences"
          ]
        }
      },
      maximumPageLength: {
        nullable: true,
        serializedName: "maximumPageLength",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const TextTranslationSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Text.TranslationSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "TextTranslationSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      defaultToLanguageCode: {
        required: true,
        serializedName: "defaultToLanguageCode",
        type: {
          name: "String"
        }
      },
      defaultFromLanguageCode: {
        serializedName: "defaultFromLanguageCode",
        type: {
          name: "String"
        }
      },
      suggestedFrom: {
        serializedName: "suggestedFrom",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const WebApiSkill: coreHttp.CompositeMapper = {
  serializedName: "#Microsoft.Skills.Custom.WebApiSkill",
  type: {
    name: "Composite",
    polymorphicDiscriminator: Skill.type.polymorphicDiscriminator,
    uberParent: "Skill",
    className: "WebApiSkill",
    modelProperties: {
      ...Skill.type.modelProperties,
      uri: {
        required: true,
        serializedName: "uri",
        type: {
          name: "String"
        }
      },
      httpHeaders: {
        serializedName: "httpHeaders",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "String"
            }
          }
        }
      },
      httpMethod: {
        serializedName: "httpMethod",
        type: {
          name: "String"
        }
      },
      timeout: {
        serializedName: "timeout",
        type: {
          name: "TimeSpan"
        }
      },
      batchSize: {
        nullable: true,
        serializedName: "batchSize",
        type: {
          name: "Number"
        }
      },
      degreeOfParallelism: {
        nullable: true,
        serializedName: "degreeOfParallelism",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const ListSkillsetsResult: coreHttp.CompositeMapper = {
  serializedName: "ListSkillsetsResult",
  type: {
    name: "Composite",
    className: "ListSkillsetsResult",
    modelProperties: {
      skillsets: {
        required: true,
        readOnly: true,
        serializedName: "value",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Skillset"
            }
          }
        }
      }
    }
  }
};

export const SynonymMap: coreHttp.CompositeMapper = {
  serializedName: "SynonymMap",
  type: {
    name: "Composite",
    className: "SynonymMap",
    modelProperties: {
      name: {
        required: true,
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      format: {
        required: true,
        isConstant: true,
        serializedName: "format",
        defaultValue: 'solr',
        type: {
          name: "String"
        }
      },
      synonyms: {
        required: true,
        serializedName: "synonyms",
        type: {
          name: "String"
        }
      },
      encryptionKey: {
        serializedName: "encryptionKey",
        type: {
          name: "Composite",
          className: "EncryptionKey"
        }
      },
      etag: {
        serializedName: "@odata\\.etag",
        type: {
          name: "String"
        }
      }
    }
  }
};

export const ListSynonymMapsResult: coreHttp.CompositeMapper = {
  serializedName: "ListSynonymMapsResult",
  type: {
    name: "Composite",
    className: "ListSynonymMapsResult",
    modelProperties: {
      synonymMaps: {
        required: true,
        readOnly: true,
        serializedName: "value",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SynonymMap"
            }
          }
        }
      }
    }
  }
};

export const ResourceCounter: coreHttp.CompositeMapper = {
  serializedName: "ResourceCounter",
  type: {
    name: "Composite",
    className: "ResourceCounter",
    modelProperties: {
      usage: {
        required: true,
        nullable: false,
        serializedName: "usage",
        type: {
          name: "Number"
        }
      },
      quota: {
        nullable: true,
        serializedName: "quota",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const ServiceCounters: coreHttp.CompositeMapper = {
  serializedName: "ServiceCounters",
  type: {
    name: "Composite",
    className: "ServiceCounters",
    modelProperties: {
      documentCounter: {
        required: true,
        serializedName: "documentCount",
        type: {
          name: "Composite",
          className: "ResourceCounter"
        }
      },
      indexCounter: {
        required: true,
        serializedName: "indexesCount",
        type: {
          name: "Composite",
          className: "ResourceCounter"
        }
      },
      indexerCounter: {
        required: true,
        serializedName: "indexersCount",
        type: {
          name: "Composite",
          className: "ResourceCounter"
        }
      },
      dataSourceCounter: {
        required: true,
        serializedName: "dataSourcesCount",
        type: {
          name: "Composite",
          className: "ResourceCounter"
        }
      },
      storageSizeCounter: {
        required: true,
        serializedName: "storageSize",
        type: {
          name: "Composite",
          className: "ResourceCounter"
        }
      },
      synonymMapCounter: {
        required: true,
        serializedName: "synonymMaps",
        type: {
          name: "Composite",
          className: "ResourceCounter"
        }
      },
      skillsetCounter: {
        required: true,
        serializedName: "skillsetCount",
        type: {
          name: "Composite",
          className: "ResourceCounter"
        }
      }
    }
  }
};

export const ServiceLimits: coreHttp.CompositeMapper = {
  serializedName: "ServiceLimits",
  type: {
    name: "Composite",
    className: "ServiceLimits",
    modelProperties: {
      maxFieldsPerIndex: {
        nullable: true,
        serializedName: "maxFieldsPerIndex",
        type: {
          name: "Number"
        }
      },
      maxFieldNestingDepthPerIndex: {
        nullable: true,
        serializedName: "maxFieldNestingDepthPerIndex",
        type: {
          name: "Number"
        }
      },
      maxComplexCollectionFieldsPerIndex: {
        nullable: true,
        serializedName: "maxComplexCollectionFieldsPerIndex",
        type: {
          name: "Number"
        }
      },
      maxComplexObjectsInCollectionsPerDocument: {
        nullable: true,
        serializedName: "maxComplexObjectsInCollectionsPerDocument",
        type: {
          name: "Number"
        }
      }
    }
  }
};

export const ServiceStatistics: coreHttp.CompositeMapper = {
  serializedName: "ServiceStatistics",
  type: {
    name: "Composite",
    className: "ServiceStatistics",
    modelProperties: {
      counters: {
        required: true,
        serializedName: "counters",
        type: {
          name: "Composite",
          className: "ServiceCounters"
        }
      },
      limits: {
        required: true,
        serializedName: "limits",
        type: {
          name: "Composite",
          className: "ServiceLimits"
        }
      }
    }
  }
};

export const SearchError: coreHttp.CompositeMapper = {
  serializedName: "SearchError",
  type: {
    name: "Composite",
    className: "SearchError",
    modelProperties: {
      code: {
        readOnly: true,
        serializedName: "code",
        type: {
          name: "String"
        }
      },
      message: {
        required: true,
        readOnly: true,
        serializedName: "message",
        type: {
          name: "String"
        }
      },
      details: {
        readOnly: true,
        serializedName: "details",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SearchError"
            }
          }
        }
      }
    }
  }
};

export const AccessCondition: coreHttp.CompositeMapper = {
  type: {
    name: "Composite",
    className: "AccessCondition",
    modelProperties: {
      ifMatch: {
        type: {
          name: "String"
        }
      },
      ifNoneMatch: {
        type: {
          name: "String"
        }
      }
    }
  }
};

export const discriminators = {
  'Analyzer' : Analyzer,
  'Analyzer.#Microsoft.Azure.Search.CustomAnalyzer' : CustomAnalyzer,
  'Analyzer.#Microsoft.Azure.Search.PatternAnalyzer' : PatternAnalyzer,
  'Analyzer.#Microsoft.Azure.Search.StandardAnalyzer' : StandardAnalyzer,
  'Analyzer.#Microsoft.Azure.Search.StopAnalyzer' : StopAnalyzer,
  'Tokenizer' : Tokenizer,
  'Tokenizer.#Microsoft.Azure.Search.ClassicTokenizer' : ClassicTokenizer,
  'Tokenizer.#Microsoft.Azure.Search.EdgeNGramTokenizer' : EdgeNGramTokenizer,
  'Tokenizer.#Microsoft.Azure.Search.KeywordTokenizer' : KeywordTokenizer,
  'Tokenizer.#Microsoft.Azure.Search.KeywordTokenizerV2' : KeywordTokenizerV2,
  'Tokenizer.#Microsoft.Azure.Search.MicrosoftLanguageTokenizer' : MicrosoftLanguageTokenizer,
  'Tokenizer.#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer' : MicrosoftLanguageStemmingTokenizer,
  'Tokenizer.#Microsoft.Azure.Search.NGramTokenizer' : NGramTokenizer,
  'Tokenizer.#Microsoft.Azure.Search.PathHierarchyTokenizerV2' : PathHierarchyTokenizerV2,
  'Tokenizer.#Microsoft.Azure.Search.PatternTokenizer' : PatternTokenizer,
  'Tokenizer.#Microsoft.Azure.Search.StandardTokenizer' : StandardTokenizer,
  'Tokenizer.#Microsoft.Azure.Search.StandardTokenizerV2' : StandardTokenizerV2,
  'Tokenizer.#Microsoft.Azure.Search.UaxUrlEmailTokenizer' : UaxUrlEmailTokenizer,
  'TokenFilter' : TokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.AsciiFoldingTokenFilter' : AsciiFoldingTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.CjkBigramTokenFilter' : CjkBigramTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.CommonGramTokenFilter' : CommonGramTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter' : DictionaryDecompounderTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.EdgeNGramTokenFilter' : EdgeNGramTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.EdgeNGramTokenFilterV2' : EdgeNGramTokenFilterV2,
  'TokenFilter.#Microsoft.Azure.Search.ElisionTokenFilter' : ElisionTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.KeepTokenFilter' : KeepTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.KeywordMarkerTokenFilter' : KeywordMarkerTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.LengthTokenFilter' : LengthTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.LimitTokenFilter' : LimitTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.NGramTokenFilter' : NGramTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.NGramTokenFilterV2' : NGramTokenFilterV2,
  'TokenFilter.#Microsoft.Azure.Search.PatternCaptureTokenFilter' : PatternCaptureTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.PatternReplaceTokenFilter' : PatternReplaceTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.PhoneticTokenFilter' : PhoneticTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.ShingleTokenFilter' : ShingleTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.SnowballTokenFilter' : SnowballTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.StemmerTokenFilter' : StemmerTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.StemmerOverrideTokenFilter' : StemmerOverrideTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.StopwordsTokenFilter' : StopwordsTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.SynonymTokenFilter' : SynonymTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.TruncateTokenFilter' : TruncateTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.UniqueTokenFilter' : UniqueTokenFilter,
  'TokenFilter.#Microsoft.Azure.Search.WordDelimiterTokenFilter' : WordDelimiterTokenFilter,
  'CharFilter' : CharFilter,
  'CharFilter.#Microsoft.Azure.Search.MappingCharFilter' : MappingCharFilter,
  'CharFilter.#Microsoft.Azure.Search.PatternReplaceCharFilter' : PatternReplaceCharFilter,
  'DataChangeDetectionPolicy' : DataChangeDetectionPolicy,
  'DataChangeDetectionPolicy.#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy' : HighWaterMarkChangeDetectionPolicy,
  'DataChangeDetectionPolicy.#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy' : SqlIntegratedChangeTrackingPolicy,
  'DataDeletionDetectionPolicy' : DataDeletionDetectionPolicy,
  'DataDeletionDetectionPolicy.#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy' : SoftDeleteColumnDeletionDetectionPolicy,
  'ScoringFunction' : ScoringFunction,
  'ScoringFunction.distance' : DistanceScoringFunction,
  'ScoringFunction.freshness' : FreshnessScoringFunction,
  'ScoringFunction.magnitude' : MagnitudeScoringFunction,
  'ScoringFunction.tag' : TagScoringFunction,
  'Skill' : Skill,
  'CognitiveServicesAccount' : CognitiveServicesAccount,
  'CognitiveServicesAccount.#Microsoft.Azure.Search.DefaultCognitiveServices' : DefaultCognitiveServicesAccount,
  'CognitiveServicesAccount.#Microsoft.Azure.Search.CognitiveServicesByKey' : CognitiveServicesAccountKey,
  'Skill.#Microsoft.Skills.Util.ConditionalSkill' : ConditionalSkill,
  'Skill.#Microsoft.Skills.Text.KeyPhraseExtractionSkill' : KeyPhraseExtractionSkill,
  'Skill.#Microsoft.Skills.Vision.OcrSkill' : OcrSkill,
  'Skill.#Microsoft.Skills.Vision.ImageAnalysisSkill' : ImageAnalysisSkill,
  'Skill.#Microsoft.Skills.Text.LanguageDetectionSkill' : LanguageDetectionSkill,
  'Skill.#Microsoft.Skills.Util.ShaperSkill' : ShaperSkill,
  'Skill.#Microsoft.Skills.Text.MergeSkill' : MergeSkill,
  'Skill.#Microsoft.Skills.Text.EntityRecognitionSkill' : EntityRecognitionSkill,
  'Skill.#Microsoft.Skills.Text.SentimentSkill' : SentimentSkill,
  'Skill.#Microsoft.Skills.Text.SplitSkill' : SplitSkill,
  'Skill.#Microsoft.Skills.Text.TranslationSkill' : TextTranslationSkill,
  'Skill.#Microsoft.Skills.Custom.WebApiSkill' : WebApiSkill

};
