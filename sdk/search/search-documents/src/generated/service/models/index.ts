/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";

export type DataChangeDetectionPolicyUnion =
  | DataChangeDetectionPolicy
  | HighWaterMarkChangeDetectionPolicy
  | SqlIntegratedChangeTrackingPolicy;
export type DataDeletionDetectionPolicyUnion =
  | DataDeletionDetectionPolicy
  | SoftDeleteColumnDeletionDetectionPolicy;
export type SearchIndexerSkillUnion =
  | SearchIndexerSkill
  | ConditionalSkill
  | KeyPhraseExtractionSkill
  | OcrSkill
  | ImageAnalysisSkill
  | LanguageDetectionSkill
  | ShaperSkill
  | MergeSkill
  | EntityRecognitionSkill
  | SentimentSkill
  | SplitSkill
  | CustomEntityLookupSkill
  | TextTranslationSkill
  | DocumentExtractionSkill
  | WebApiSkill;
export type CognitiveServicesAccountUnion =
  | CognitiveServicesAccount
  | DefaultCognitiveServicesAccount
  | CognitiveServicesAccountKey;
export type ScoringFunctionUnion =
  | ScoringFunction
  | DistanceScoringFunction
  | FreshnessScoringFunction
  | MagnitudeScoringFunction
  | TagScoringFunction;
export type LexicalAnalyzerUnion =
  | LexicalAnalyzer
  | CustomAnalyzer
  | PatternAnalyzer
  | LuceneStandardAnalyzer
  | StopAnalyzer;
export type LexicalTokenizerUnion =
  | LexicalTokenizer
  | ClassicTokenizer
  | EdgeNGramTokenizer
  | KeywordTokenizer
  | KeywordTokenizerV2
  | MicrosoftLanguageTokenizer
  | MicrosoftLanguageStemmingTokenizer
  | NGramTokenizer
  | PathHierarchyTokenizerV2
  | PatternTokenizer
  | LuceneStandardTokenizer
  | LuceneStandardTokenizerV2
  | UaxUrlEmailTokenizer;
export type TokenFilterUnion =
  | TokenFilter
  | AsciiFoldingTokenFilter
  | CjkBigramTokenFilter
  | CommonGramTokenFilter
  | DictionaryDecompounderTokenFilter
  | EdgeNGramTokenFilter
  | EdgeNGramTokenFilterV2
  | ElisionTokenFilter
  | KeepTokenFilter
  | KeywordMarkerTokenFilter
  | LengthTokenFilter
  | LimitTokenFilter
  | NGramTokenFilter
  | NGramTokenFilterV2
  | PatternCaptureTokenFilter
  | PatternReplaceTokenFilter
  | PhoneticTokenFilter
  | ShingleTokenFilter
  | SnowballTokenFilter
  | StemmerTokenFilter
  | StemmerOverrideTokenFilter
  | StopwordsTokenFilter
  | SynonymTokenFilter
  | TruncateTokenFilter
  | UniqueTokenFilter
  | WordDelimiterTokenFilter;
export type CharFilterUnion =
  | CharFilter
  | MappingCharFilter
  | PatternReplaceCharFilter;
export type SimilarityUnion = Similarity | ClassicSimilarity | BM25Similarity;

/** Represents a datasource definition, which can be used to configure an indexer. */
export interface SearchIndexerDataSource {
  /** The name of the datasource. */
  name: string;
  /** The description of the datasource. */
  description?: string;
  /** The type of the datasource. */
  type: SearchIndexerDataSourceType;
  /** Credentials for the datasource. */
  credentials: DataSourceCredentials;
  /** The data container for the datasource. */
  container: SearchIndexerDataContainer;
  /** The data change detection policy for the datasource. */
  dataChangeDetectionPolicy?: DataChangeDetectionPolicyUnion | null;
  /** The data deletion detection policy for the datasource. */
  dataDeletionDetectionPolicy?: DataDeletionDetectionPolicyUnion | null;
  /** The ETag of the data source. */
  etag?: string;
  /** A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your datasource definition when you want full assurance that no one, not even Microsoft, can decrypt your data source definition in Azure Cognitive Search. Once you have encrypted your data source definition, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your datasource definition will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. */
  encryptionKey?: SearchResourceEncryptionKey | null;
}

/** Represents credentials that can be used to connect to a datasource. */
export interface DataSourceCredentials {
  /** The connection string for the datasource. Set to '<unchanged>' if you do not want the connection string updated. */
  connectionString?: string;
}

/** Represents information about the entity (such as Azure SQL table or CosmosDB collection) that will be indexed. */
export interface SearchIndexerDataContainer {
  /** The name of the table or view (for Azure SQL data source) or collection (for CosmosDB data source) that will be indexed. */
  name: string;
  /** A query that is applied to this data container. The syntax and meaning of this parameter is datasource-specific. Not supported by Azure SQL datasources. */
  query?: string;
}

/** Base type for data change detection policies. */
export interface DataChangeDetectionPolicy {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype:
    | "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy"
    | "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
}

/** Base type for data deletion detection policies. */
export interface DataDeletionDetectionPolicy {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
}

/** A customer-managed encryption key in Azure Key Vault. Keys that you create and manage can be used to encrypt or decrypt data-at-rest in Azure Cognitive Search, such as indexes and synonym maps. */
export interface SearchResourceEncryptionKey {
  /** The name of your Azure Key Vault key to be used to encrypt your data at rest. */
  keyName: string;
  /** The version of your Azure Key Vault key to be used to encrypt your data at rest. */
  keyVersion: string;
  /** The URI of your Azure Key Vault, also referred to as DNS name, that contains the key to be used to encrypt your data at rest. An example URI might be https://my-keyvault-name.vault.azure.net. */
  vaultUri: string;
  /** Optional Azure Active Directory credentials used for accessing your Azure Key Vault. Not required if using managed identity instead. */
  accessCredentials?: AzureActiveDirectoryApplicationCredentials;
}

/** Credentials of a registered application created for your search service, used for authenticated access to the encryption keys stored in Azure Key Vault. */
export interface AzureActiveDirectoryApplicationCredentials {
  /** An AAD Application ID that was granted the required access permissions to the Azure Key Vault that is to be used when encrypting your data at rest. The Application ID should not be confused with the Object ID for your AAD Application. */
  applicationId: string;
  /** The authentication key of the specified AAD application. */
  applicationSecret?: string;
}

/** Describes an error condition for the Azure Cognitive Search API. */
export interface SearchError {
  /**
   * One of a server-defined set of error codes.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly code?: string;
  /**
   * A human-readable representation of the error.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message: string;
  /**
   * An array of details about specific errors that led to this reported error.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly details?: SearchError[];
}

/** Response from a List Datasources request. If successful, it includes the full definitions of all datasources. */
export interface ListDataSourcesResult {
  /**
   * The datasources in the Search service.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly dataSources: SearchIndexerDataSource[];
}

/** Represents an indexer. */
export interface SearchIndexer {
  /** The name of the indexer. */
  name: string;
  /** The description of the indexer. */
  description?: string;
  /** The name of the datasource from which this indexer reads data. */
  dataSourceName: string;
  /** The name of the skillset executing with this indexer. */
  skillsetName?: string;
  /** The name of the index to which this indexer writes data. */
  targetIndexName: string;
  /** The schedule for this indexer. */
  schedule?: IndexingSchedule | null;
  /** Parameters for indexer execution. */
  parameters?: IndexingParameters | null;
  /** Defines mappings between fields in the data source and corresponding target fields in the index. */
  fieldMappings?: FieldMapping[];
  /** Output field mappings are applied after enrichment and immediately before indexing. */
  outputFieldMappings?: FieldMapping[];
  /** A value indicating whether the indexer is disabled. Default is false. */
  isDisabled?: boolean | null;
  /** The ETag of the indexer. */
  etag?: string;
  /** A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your indexer definition (as well as indexer execution status) when you want full assurance that no one, not even Microsoft, can decrypt them in Azure Cognitive Search. Once you have encrypted your indexer definition, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your indexer definition (and indexer execution status) will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. */
  encryptionKey?: SearchResourceEncryptionKey | null;
}

/** Represents a schedule for indexer execution. */
export interface IndexingSchedule {
  /** The interval of time between indexer executions. */
  interval: string;
  /** The time when an indexer should start running. */
  startTime?: Date;
}

/** Represents parameters for indexer execution. */
export interface IndexingParameters {
  /** The number of items that are read from the data source and indexed as a single batch in order to improve performance. The default depends on the data source type. */
  batchSize?: number | null;
  /** The maximum number of items that can fail indexing for indexer execution to still be considered successful. -1 means no limit. Default is 0. */
  maxFailedItems?: number | null;
  /** The maximum number of items in a single batch that can fail indexing for the batch to still be considered successful. -1 means no limit. Default is 0. */
  maxFailedItemsPerBatch?: number | null;
  /** A dictionary of indexer-specific configuration properties. Each name is the name of a specific property. Each value must be of a primitive type. */
  configuration?: IndexingParametersConfiguration;
}

/** A dictionary of indexer-specific configuration properties. Each name is the name of a specific property. Each value must be of a primitive type. */
export interface IndexingParametersConfiguration {
  /** Describes unknown properties. The value of an unknown property can be of "any" type. */
  [property: string]: any;
  /** Represents the parsing mode for indexing from an Azure blob data source. */
  parsingMode?: BlobIndexerParsingMode;
  /** Comma-delimited list of filename extensions to ignore when processing from Azure blob storage.  For example, you could exclude ".png, .mp4" to skip over those files during indexing. */
  excludedFileNameExtensions?: string;
  /** Comma-delimited list of filename extensions to select when processing from Azure blob storage.  For example, you could focus indexing on specific application files ".docx, .pptx, .msg" to specifically include those file types. */
  indexedFileNameExtensions?: string;
  /** For Azure blobs, set to false if you want to continue indexing when an unsupported content type is encountered, and you don't know all the content types (file extensions) in advance. */
  failOnUnsupportedContentType?: boolean;
  /** For Azure blobs, set to false if you want to continue indexing if a document fails indexing. */
  failOnUnprocessableDocument?: boolean;
  /** For Azure blobs, set this property to true to still index storage metadata for blob content that is too large to process. Oversized blobs are treated as errors by default. For limits on blob size, see https://docs.microsoft.com/azure/search/search-limits-quotas-capacity. */
  indexStorageMetadataOnlyForOversizedDocuments?: boolean;
  /** For CSV blobs, specifies a comma-delimited list of column headers, useful for mapping source fields to destination fields in an index. */
  delimitedTextHeaders?: string;
  /** For CSV blobs, specifies the end-of-line single-character delimiter for CSV files where each line starts a new document (for example, "|"). */
  delimitedTextDelimiter?: string;
  /** For CSV blobs, indicates that the first (non-blank) line of each blob contains headers. */
  firstLineContainsHeaders?: boolean;
  /** For JSON arrays, given a structured or semi-structured document, you can specify a path to the array using this property. */
  documentRoot?: string;
  /** Specifies the data to extract from Azure blob storage and tells the indexer which data to extract from image content when "imageAction" is set to a value other than "none".  This applies to embedded image content in a .PDF or other application, or image files such as .jpg and .png, in Azure blobs. */
  dataToExtract?: BlobIndexerDataToExtract;
  /** Determines how to process embedded images and image files in Azure blob storage.  Setting the "imageAction" configuration to any value other than "none" requires that a skillset also be attached to that indexer. */
  imageAction?: BlobIndexerImageAction;
  /** If true, will create a path //document//file_data that is an object representing the original file data downloaded from your blob data source.  This allows you to pass the original file data to a custom skill for processing within the enrichment pipeline, or to the Document Extraction skill. */
  allowSkillsetToReadFileData?: boolean;
  /** Determines algorithm for text extraction from PDF files in Azure blob storage. */
  pdfTextRotationAlgorithm?: BlobIndexerPDFTextRotationAlgorithm;
  /** Specifies the environment in which the indexer should execute. */
  executionEnvironment?: IndexerExecutionEnvironment;
  /** Increases the timeout beyond the 5-minute default for Azure SQL database data sources, specified in the format "hh:mm:ss". */
  queryTimeout?: string;
}

/** Defines a mapping between a field in a data source and a target field in an index. */
export interface FieldMapping {
  /** The name of the field in the data source. */
  sourceFieldName: string;
  /** The name of the target field in the index. Same as the source field name by default. */
  targetFieldName?: string;
  /** A function to apply to each source field value before indexing. */
  mappingFunction?: FieldMappingFunction | null;
}

/** Represents a function that transforms a value from a data source before indexing. */
export interface FieldMappingFunction {
  /** The name of the field mapping function. */
  name: string;
  /** A dictionary of parameter name/value pairs to pass to the function. Each value must be of a primitive type. */
  parameters?: { [propertyName: string]: any };
}

/** Response from a List Indexers request. If successful, it includes the full definitions of all indexers. */
export interface ListIndexersResult {
  /**
   * The indexers in the Search service.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly indexers: SearchIndexer[];
}

/** Represents the current status and execution history of an indexer. */
export interface SearchIndexerStatus {
  /**
   * Overall indexer status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly status: IndexerStatus;
  /**
   * The result of the most recent or an in-progress indexer execution.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly lastResult?: IndexerExecutionResult;
  /**
   * History of the recent indexer executions, sorted in reverse chronological order.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly executionHistory: IndexerExecutionResult[];
  /**
   * The execution limits for the indexer.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly limits: SearchIndexerLimits;
}

/** Represents the result of an individual indexer execution. */
export interface IndexerExecutionResult {
  /**
   * The outcome of this indexer execution.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly status: IndexerExecutionStatus;
  /**
   * The error message indicating the top-level error, if any.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly errorMessage?: string;
  /**
   * The start time of this indexer execution.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly startTime?: Date;
  /**
   * The end time of this indexer execution, if the execution has already completed.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly endTime?: Date | null;
  /**
   * The item-level indexing errors.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly errors: SearchIndexerError[];
  /**
   * The item-level indexing warnings.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly warnings: SearchIndexerWarning[];
  /**
   * The number of items that were processed during this indexer execution. This includes both successfully processed items and items where indexing was attempted but failed.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly itemCount: number;
  /**
   * The number of items that failed to be indexed during this indexer execution.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly failedItemCount: number;
  /**
   * Change tracking state with which an indexer execution started.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly initialTrackingState?: string;
  /**
   * Change tracking state with which an indexer execution finished.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly finalTrackingState?: string;
}

/** Represents an item- or document-level indexing error. */
export interface SearchIndexerError {
  /**
   * The key of the item for which indexing failed.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly key?: string;
  /**
   * The message describing the error that occurred while processing the item.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly errorMessage: string;
  /**
   * The status code indicating why the indexing operation failed. Possible values include: 400 for a malformed input document, 404 for document not found, 409 for a version conflict, 422 when the index is temporarily unavailable, or 503 for when the service is too busy.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly statusCode: number;
  /**
   * The name of the source at which the error originated. For example, this could refer to a particular skill in the attached skillset. This may not be always available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * Additional, verbose details about the error to assist in debugging the indexer. This may not be always available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly details?: string;
  /**
   * A link to a troubleshooting guide for these classes of errors. This may not be always available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly documentationLink?: string;
}

/** Represents an item-level warning. */
export interface SearchIndexerWarning {
  /**
   * The key of the item which generated a warning.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly key?: string;
  /**
   * The message describing the warning that occurred while processing the item.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message: string;
  /**
   * The name of the source at which the warning originated. For example, this could refer to a particular skill in the attached skillset. This may not be always available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly name?: string;
  /**
   * Additional, verbose details about the warning to assist in debugging the indexer. This may not be always available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly details?: string;
  /**
   * A link to a troubleshooting guide for these classes of warnings. This may not be always available.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly documentationLink?: string;
}

export interface SearchIndexerLimits {
  /**
   * The maximum duration that the indexer is permitted to run for one execution.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly maxRunTime?: string;
  /**
   * The maximum size of a document, in bytes, which will be considered valid for indexing.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly maxDocumentExtractionSize?: number;
  /**
   * The maximum number of characters that will be extracted from a document picked up for indexing.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly maxDocumentContentCharactersToExtract?: number;
}

/** A list of skills. */
export interface SearchIndexerSkillset {
  /** The name of the skillset. */
  name: string;
  /** The description of the skillset. */
  description?: string;
  /** A list of skills in the skillset. */
  skills: SearchIndexerSkillUnion[];
  /** Details about cognitive services to be used when running skills. */
  cognitiveServicesAccount?: CognitiveServicesAccountUnion;
  /** Definition of additional projections to azure blob, table, or files, of enriched data. */
  knowledgeStore?: SearchIndexerKnowledgeStore;
  /** The ETag of the skillset. */
  etag?: string;
  /** A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your skillset definition when you want full assurance that no one, not even Microsoft, can decrypt your skillset definition in Azure Cognitive Search. Once you have encrypted your skillset definition, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your skillset definition will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. */
  encryptionKey?: SearchResourceEncryptionKey | null;
}

/** Base type for skills. */
export interface SearchIndexerSkill {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype:
    | "#Microsoft.Skills.Util.ConditionalSkill"
    | "#Microsoft.Skills.Text.KeyPhraseExtractionSkill"
    | "#Microsoft.Skills.Vision.OcrSkill"
    | "#Microsoft.Skills.Vision.ImageAnalysisSkill"
    | "#Microsoft.Skills.Text.LanguageDetectionSkill"
    | "#Microsoft.Skills.Util.ShaperSkill"
    | "#Microsoft.Skills.Text.MergeSkill"
    | "#Microsoft.Skills.Text.EntityRecognitionSkill"
    | "#Microsoft.Skills.Text.SentimentSkill"
    | "#Microsoft.Skills.Text.SplitSkill"
    | "#Microsoft.Skills.Text.CustomEntityLookupSkill"
    | "#Microsoft.Skills.Text.TranslationSkill"
    | "#Microsoft.Skills.Util.DocumentExtractionSkill"
    | "#Microsoft.Skills.Custom.WebApiSkill";
  /** The name of the skill which uniquely identifies it within the skillset. A skill with no name defined will be given a default name of its 1-based index in the skills array, prefixed with the character '#'. */
  name?: string;
  /** The description of the skill which describes the inputs, outputs, and usage of the skill. */
  description?: string;
  /** Represents the level at which operations take place, such as the document root or document content (for example, /document or /document/content). The default is /document. */
  context?: string;
  /** Inputs of the skills could be a column in the source data set, or the output of an upstream skill. */
  inputs: InputFieldMappingEntry[];
  /** The output of a skill is either a field in a search index, or a value that can be consumed as an input by another skill. */
  outputs: OutputFieldMappingEntry[];
}

/** Input field mapping for a skill. */
export interface InputFieldMappingEntry {
  /** The name of the input. */
  name: string;
  /** The source of the input. */
  source?: string;
  /** The source context used for selecting recursive inputs. */
  sourceContext?: string;
  /** The recursive inputs used when creating a complex type. */
  inputs?: InputFieldMappingEntry[];
}

/** Output field mapping for a skill. */
export interface OutputFieldMappingEntry {
  /** The name of the output defined by the skill. */
  name: string;
  /** The target name of the output. It is optional and default to name. */
  targetName?: string;
}

/** Base type for describing any cognitive service resource attached to a skillset. */
export interface CognitiveServicesAccount {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype:
    | "#Microsoft.Azure.Search.DefaultCognitiveServices"
    | "#Microsoft.Azure.Search.CognitiveServicesByKey";
  /** Description of the cognitive service resource attached to a skillset. */
  description?: string;
}

/** Definition of additional projections to azure blob, table, or files, of enriched data. */
export interface SearchIndexerKnowledgeStore {
  /** The connection string to the storage account projections will be stored in. */
  storageConnectionString: string;
  /** A list of additional projections to perform during indexing. */
  projections: SearchIndexerKnowledgeStoreProjection[];
}

/** Container object for various projection selectors. */
export interface SearchIndexerKnowledgeStoreProjection {
  /** Projections to Azure Table storage. */
  tables?: SearchIndexerKnowledgeStoreTableProjectionSelector[];
  /** Projections to Azure Blob storage. */
  objects?: SearchIndexerKnowledgeStoreObjectProjectionSelector[];
  /** Projections to Azure File storage. */
  files?: SearchIndexerKnowledgeStoreFileProjectionSelector[];
}

/** Abstract class to share properties between concrete selectors. */
export interface SearchIndexerKnowledgeStoreProjectionSelector {
  /** Name of reference key to different projection. */
  referenceKeyName?: string;
  /** Name of generated key to store projection under. */
  generatedKeyName?: string;
  /** Source data to project. */
  source?: string;
  /** Source context for complex projections. */
  sourceContext?: string;
  /** Nested inputs for complex projections. */
  inputs?: InputFieldMappingEntry[];
}

/** Response from a list skillset request. If successful, it includes the full definitions of all skillsets. */
export interface ListSkillsetsResult {
  /**
   * The skillsets defined in the Search service.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly skillsets: SearchIndexerSkillset[];
}

/** Represents a synonym map definition. */
export interface SynonymMap {
  /** The name of the synonym map. */
  name: string;
  /** The format of the synonym map. Only the 'solr' format is currently supported. */
  format: "solr";
  /** A series of synonym rules in the specified synonym map format. The rules must be separated by newlines. */
  synonyms: string;
  /** A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your data when you want full assurance that no one, not even Microsoft, can decrypt your data in Azure Cognitive Search. Once you have encrypted your data, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your data will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. */
  encryptionKey?: SearchResourceEncryptionKey | null;
  /** The ETag of the synonym map. */
  etag?: string;
}

/** Response from a List SynonymMaps request. If successful, it includes the full definitions of all synonym maps. */
export interface ListSynonymMapsResult {
  /**
   * The synonym maps in the Search service.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly synonymMaps: SynonymMap[];
}

/** Represents a search index definition, which describes the fields and search behavior of an index. */
export interface SearchIndex {
  /** The name of the index. */
  name: string;
  /** The fields of the index. */
  fields: SearchField[];
  /** The scoring profiles for the index. */
  scoringProfiles?: ScoringProfile[];
  /** The name of the scoring profile to use if none is specified in the query. If this property is not set and no scoring profile is specified in the query, then default scoring (tf-idf) will be used. */
  defaultScoringProfile?: string;
  /** Options to control Cross-Origin Resource Sharing (CORS) for the index. */
  corsOptions?: CorsOptions | null;
  /** The suggesters for the index. */
  suggesters?: Suggester[];
  /** The analyzers for the index. */
  analyzers?: LexicalAnalyzerUnion[];
  /** The tokenizers for the index. */
  tokenizers?: LexicalTokenizerUnion[];
  /** The token filters for the index. */
  tokenFilters?: TokenFilterUnion[];
  /** The character filters for the index. */
  charFilters?: CharFilterUnion[];
  /** A description of an encryption key that you create in Azure Key Vault. This key is used to provide an additional level of encryption-at-rest for your data when you want full assurance that no one, not even Microsoft, can decrypt your data in Azure Cognitive Search. Once you have encrypted your data, it will always remain encrypted. Azure Cognitive Search will ignore attempts to set this property to null. You can change this property as needed if you want to rotate your encryption key; Your data will be unaffected. Encryption with customer-managed keys is not available for free search services, and is only available for paid services created on or after January 1, 2019. */
  encryptionKey?: SearchResourceEncryptionKey | null;
  /** The type of similarity algorithm to be used when scoring and ranking the documents matching a search query. The similarity algorithm can only be defined at index creation time and cannot be modified on existing indexes. If null, the ClassicSimilarity algorithm is used. */
  similarity?: SimilarityUnion;
  /** The ETag of the index. */
  etag?: string;
}

/** Represents a field in an index definition, which describes the name, data type, and search behavior of a field. */
export interface SearchField {
  /** The name of the field, which must be unique within the fields collection of the index or parent field. */
  name: string;
  /** The data type of the field. */
  type: SearchFieldDataType;
  /** A value indicating whether the field uniquely identifies documents in the index. Exactly one top-level field in each index must be chosen as the key field and it must be of type Edm.String. Key fields can be used to look up documents directly and update or delete specific documents. Default is false for simple fields and null for complex fields. */
  key?: boolean;
  /** A value indicating whether the field can be returned in a search result. You can disable this option if you want to use a field (for example, margin) as a filter, sorting, or scoring mechanism but do not want the field to be visible to the end user. This property must be true for key fields, and it must be null for complex fields. This property can be changed on existing fields. Enabling this property does not cause any increase in index storage requirements. Default is true for simple fields and null for complex fields. */
  retrievable?: boolean;
  /** A value indicating whether the field is full-text searchable. This means it will undergo analysis such as word-breaking during indexing. If you set a searchable field to a value like "sunny day", internally it will be split into the individual tokens "sunny" and "day". This enables full-text searches for these terms. Fields of type Edm.String or Collection(Edm.String) are searchable by default. This property must be false for simple fields of other non-string data types, and it must be null for complex fields. Note: searchable fields consume extra space in your index since Azure Cognitive Search will store an additional tokenized version of the field value for full-text searches. If you want to save space in your index and you don't need a field to be included in searches, set searchable to false. */
  searchable?: boolean;
  /** A value indicating whether to enable the field to be referenced in $filter queries. filterable differs from searchable in how strings are handled. Fields of type Edm.String or Collection(Edm.String) that are filterable do not undergo word-breaking, so comparisons are for exact matches only. For example, if you set such a field f to "sunny day", $filter=f eq 'sunny' will find no matches, but $filter=f eq 'sunny day' will. This property must be null for complex fields. Default is true for simple fields and null for complex fields. */
  filterable?: boolean;
  /** A value indicating whether to enable the field to be referenced in $orderby expressions. By default Azure Cognitive Search sorts results by score, but in many experiences users will want to sort by fields in the documents. A simple field can be sortable only if it is single-valued (it has a single value in the scope of the parent document). Simple collection fields cannot be sortable, since they are multi-valued. Simple sub-fields of complex collections are also multi-valued, and therefore cannot be sortable. This is true whether it's an immediate parent field, or an ancestor field, that's the complex collection. Complex fields cannot be sortable and the sortable property must be null for such fields. The default for sortable is true for single-valued simple fields, false for multi-valued simple fields, and null for complex fields. */
  sortable?: boolean;
  /** A value indicating whether to enable the field to be referenced in facet queries. Typically used in a presentation of search results that includes hit count by category (for example, search for digital cameras and see hits by brand, by megapixels, by price, and so on). This property must be null for complex fields. Fields of type Edm.GeographyPoint or Collection(Edm.GeographyPoint) cannot be facetable. Default is true for all other simple fields. */
  facetable?: boolean;
  /** The name of the analyzer to use for the field. This option can be used only with searchable fields and it can't be set together with either searchAnalyzer or indexAnalyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields. */
  analyzer?: LexicalAnalyzerName | null;
  /** The name of the analyzer used at search time for the field. This option can be used only with searchable fields. It must be set together with indexAnalyzer and it cannot be set together with the analyzer option. This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. This analyzer can be updated on an existing field. Must be null for complex fields. */
  searchAnalyzer?: LexicalAnalyzerName | null;
  /** The name of the analyzer used at indexing time for the field. This option can be used only with searchable fields. It must be set together with searchAnalyzer and it cannot be set together with the analyzer option.  This property cannot be set to the name of a language analyzer; use the analyzer property instead if you need a language analyzer. Once the analyzer is chosen, it cannot be changed for the field. Must be null for complex fields. */
  indexAnalyzer?: LexicalAnalyzerName | null;
  /** A list of the names of synonym maps to associate with this field. This option can be used only with searchable fields. Currently only one synonym map per field is supported. Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using the rules in the synonym map. This attribute can be changed on existing fields. Must be null or an empty collection for complex fields. */
  synonymMaps?: string[];
  /** A list of sub-fields if this is a field of type Edm.ComplexType or Collection(Edm.ComplexType). Must be null or empty for simple fields. */
  fields?: SearchField[];
}

/** Defines parameters for a search index that influence scoring in search queries. */
export interface ScoringProfile {
  /** The name of the scoring profile. */
  name: string;
  /** Parameters that boost scoring based on text matches in certain index fields. */
  textWeights?: TextWeights | null;
  /** The collection of functions that influence the scoring of documents. */
  functions?: ScoringFunctionUnion[];
  /** A value indicating how the results of individual scoring functions should be combined. Defaults to "Sum". Ignored if there are no scoring functions. */
  functionAggregation?: ScoringFunctionAggregation;
}

/** Defines weights on index fields for which matches should boost scoring in search queries. */
export interface TextWeights {
  /** The dictionary of per-field weights to boost document scoring. The keys are field names and the values are the weights for each field. */
  weights: { [propertyName: string]: number };
}

/** Base type for functions that can modify document scores during ranking. */
export interface ScoringFunction {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  type: "distance" | "freshness" | "magnitude" | "tag";
  /** The name of the field used as input to the scoring function. */
  fieldName: string;
  /** A multiplier for the raw score. Must be a positive number not equal to 1.0. */
  boost: number;
  /** A value indicating how boosting will be interpolated across document scores; defaults to "Linear". */
  interpolation?: ScoringFunctionInterpolation;
}

/** Defines options to control Cross-Origin Resource Sharing (CORS) for an index. */
export interface CorsOptions {
  /** The list of origins from which JavaScript code will be granted access to your index. Can contain a list of hosts of the form {protocol}://{fully-qualified-domain-name}[:{port#}], or a single '*' to allow all origins (not recommended). */
  allowedOrigins: string[];
  /** The duration for which browsers should cache CORS preflight responses. Defaults to 5 minutes. */
  maxAgeInSeconds?: number | null;
}

/** Defines how the Suggest API should apply to a group of fields in the index. */
export interface Suggester {
  /** The name of the suggester. */
  name: string;
  /** A value indicating the capabilities of the suggester. */
  searchMode: "analyzingInfixMatching";
  /** The list of field names to which the suggester applies. Each field must be searchable. */
  sourceFields: string[];
}

/** Base type for analyzers. */
export interface LexicalAnalyzer {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype:
    | "#Microsoft.Azure.Search.CustomAnalyzer"
    | "#Microsoft.Azure.Search.PatternAnalyzer"
    | "#Microsoft.Azure.Search.StandardAnalyzer"
    | "#Microsoft.Azure.Search.StopAnalyzer";
  /** The name of the analyzer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. */
  name: string;
}

/** Base type for tokenizers. */
export interface LexicalTokenizer {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype:
    | "#Microsoft.Azure.Search.ClassicTokenizer"
    | "#Microsoft.Azure.Search.EdgeNGramTokenizer"
    | "#Microsoft.Azure.Search.KeywordTokenizer"
    | "#Microsoft.Azure.Search.KeywordTokenizerV2"
    | "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer"
    | "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer"
    | "#Microsoft.Azure.Search.NGramTokenizer"
    | "#Microsoft.Azure.Search.PathHierarchyTokenizerV2"
    | "#Microsoft.Azure.Search.PatternTokenizer"
    | "#Microsoft.Azure.Search.StandardTokenizer"
    | "#Microsoft.Azure.Search.StandardTokenizerV2"
    | "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
  /** The name of the tokenizer. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. */
  name: string;
}

/** Base type for token filters. */
export interface TokenFilter {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype:
    | "#Microsoft.Azure.Search.AsciiFoldingTokenFilter"
    | "#Microsoft.Azure.Search.CjkBigramTokenFilter"
    | "#Microsoft.Azure.Search.CommonGramTokenFilter"
    | "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter"
    | "#Microsoft.Azure.Search.EdgeNGramTokenFilter"
    | "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2"
    | "#Microsoft.Azure.Search.ElisionTokenFilter"
    | "#Microsoft.Azure.Search.KeepTokenFilter"
    | "#Microsoft.Azure.Search.KeywordMarkerTokenFilter"
    | "#Microsoft.Azure.Search.LengthTokenFilter"
    | "#Microsoft.Azure.Search.LimitTokenFilter"
    | "#Microsoft.Azure.Search.NGramTokenFilter"
    | "#Microsoft.Azure.Search.NGramTokenFilterV2"
    | "#Microsoft.Azure.Search.PatternCaptureTokenFilter"
    | "#Microsoft.Azure.Search.PatternReplaceTokenFilter"
    | "#Microsoft.Azure.Search.PhoneticTokenFilter"
    | "#Microsoft.Azure.Search.ShingleTokenFilter"
    | "#Microsoft.Azure.Search.SnowballTokenFilter"
    | "#Microsoft.Azure.Search.StemmerTokenFilter"
    | "#Microsoft.Azure.Search.StemmerOverrideTokenFilter"
    | "#Microsoft.Azure.Search.StopwordsTokenFilter"
    | "#Microsoft.Azure.Search.SynonymTokenFilter"
    | "#Microsoft.Azure.Search.TruncateTokenFilter"
    | "#Microsoft.Azure.Search.UniqueTokenFilter"
    | "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
  /** The name of the token filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. */
  name: string;
}

/** Base type for character filters. */
export interface CharFilter {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype:
    | "#Microsoft.Azure.Search.MappingCharFilter"
    | "#Microsoft.Azure.Search.PatternReplaceCharFilter";
  /** The name of the char filter. It must only contain letters, digits, spaces, dashes or underscores, can only start and end with alphanumeric characters, and is limited to 128 characters. */
  name: string;
}

/** Base type for similarity algorithms. Similarity algorithms are used to calculate scores that tie queries to documents. The higher the score, the more relevant the document is to that specific query. Those scores are used to rank the search results. */
export interface Similarity {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype:
    | "#Microsoft.Azure.Search.ClassicSimilarity"
    | "#Microsoft.Azure.Search.BM25Similarity";
}

/** Response from a List Indexes request. If successful, it includes the full definitions of all indexes. */
export interface ListIndexesResult {
  /**
   * The indexes in the Search service.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly indexes: SearchIndex[];
}

/** Statistics for a given index. Statistics are collected periodically and are not guaranteed to always be up-to-date. */
export interface GetIndexStatisticsResult {
  /**
   * The number of documents in the index.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly documentCount: number;
  /**
   * The amount of storage in bytes consumed by the index.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly storageSize: number;
}

/** Specifies some text and analysis components used to break that text into tokens. */
export interface AnalyzeRequest {
  /** The text to break into tokens. */
  text: string;
  /** The name of the analyzer to use to break the given text. If this parameter is not specified, you must specify a tokenizer instead. The tokenizer and analyzer parameters are mutually exclusive. KnownAnalyzerNames is an enum containing known values. */
  analyzer?: string;
  /** The name of the tokenizer to use to break the given text. If this parameter is not specified, you must specify an analyzer instead. The tokenizer and analyzer parameters are mutually exclusive. KnownTokenizerNames is an enum containing known values. */
  tokenizer?: string;
  /** An optional list of token filters to use when breaking the given text. This parameter can only be set when using the tokenizer parameter. */
  tokenFilters?: string[];
  /** An optional list of character filters to use when breaking the given text. This parameter can only be set when using the tokenizer parameter. */
  charFilters?: string[];
}

/** The result of testing an analyzer on text. */
export interface AnalyzeResult {
  /** The list of tokens returned by the analyzer specified in the request. */
  tokens: AnalyzedTokenInfo[];
}

/** Information about a token returned by an analyzer. */
export interface AnalyzedTokenInfo {
  /**
   * The token returned by the analyzer.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly token: string;
  /**
   * The index of the first character of the token in the input text.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly startOffset: number;
  /**
   * The index of the last character of the token in the input text.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly endOffset: number;
  /**
   * The position of the token in the input text relative to other tokens. The first token in the input text has position 0, the next has position 1, and so on. Depending on the analyzer used, some tokens might have the same position, for example if they are synonyms of each other.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly position: number;
}

/** Response from a get service statistics request. If successful, it includes service level counters and limits. */
export interface ServiceStatistics {
  /** Service level resource counters. */
  counters: ServiceCounters;
  /** Service level general limits. */
  limits: ServiceLimits;
}

/** Represents service-level resource counters and quotas. */
export interface ServiceCounters {
  /** Total number of documents across all indexes in the service. */
  documentCounter: ResourceCounter;
  /** Total number of indexes. */
  indexCounter: ResourceCounter;
  /** Total number of indexers. */
  indexerCounter: ResourceCounter;
  /** Total number of data sources. */
  dataSourceCounter: ResourceCounter;
  /** Total size of used storage in bytes. */
  storageSizeCounter: ResourceCounter;
  /** Total number of synonym maps. */
  synonymMapCounter: ResourceCounter;
  /** Total number of skillsets. */
  skillsetCounter?: ResourceCounter;
}

/** Represents a resource's usage and quota. */
export interface ResourceCounter {
  /** The resource usage amount. */
  usage: number;
  /** The resource amount quota. */
  quota?: number | null;
}

/** Represents various service level limits. */
export interface ServiceLimits {
  /** The maximum allowed fields per index. */
  maxFieldsPerIndex?: number | null;
  /** The maximum depth which you can nest sub-fields in an index, including the top-level complex field. For example, a/b/c has a nesting depth of 3. */
  maxFieldNestingDepthPerIndex?: number | null;
  /** The maximum number of fields of type Collection(Edm.ComplexType) allowed in an index. */
  maxComplexCollectionFieldsPerIndex?: number | null;
  /** The maximum number of objects in complex collections allowed per document. */
  maxComplexObjectsInCollectionsPerDocument?: number | null;
}

/** Provides parameter values to a distance scoring function. */
export interface DistanceScoringParameters {
  /** The name of the parameter passed in search queries to specify the reference location. */
  referencePointParameter: string;
  /** The distance in kilometers from the reference location where the boosting range ends. */
  boostingDistance: number;
}

/** Provides parameter values to a freshness scoring function. */
export interface FreshnessScoringParameters {
  /** The expiration period after which boosting will stop for a particular document. */
  boostingDuration: string;
}

/** Provides parameter values to a magnitude scoring function. */
export interface MagnitudeScoringParameters {
  /** The field value at which boosting starts. */
  boostingRangeStart: number;
  /** The field value at which boosting ends. */
  boostingRangeEnd: number;
  /** A value indicating whether to apply a constant boost for field values beyond the range end value; default is false. */
  shouldBoostBeyondRangeByConstant?: boolean;
}

/** Provides parameter values to a tag scoring function. */
export interface TagScoringParameters {
  /** The name of the parameter passed in search queries to specify the list of tags to compare against the target field. */
  tagsParameter: string;
}

/** An object that contains information about the matches that were found, and related metadata. */
export interface CustomEntity {
  /** The top-level entity descriptor. Matches in the skill output will be grouped by this name, and it should represent the "normalized" form of the text being found. */
  name: string;
  /** This field can be used as a passthrough for custom metadata about the matched text(s). The value of this field will appear with every match of its entity in the skill output. */
  description?: string | null;
  /** This field can be used as a passthrough for custom metadata about the matched text(s). The value of this field will appear with every match of its entity in the skill output. */
  type?: string | null;
  /** This field can be used as a passthrough for custom metadata about the matched text(s). The value of this field will appear with every match of its entity in the skill output. */
  subtype?: string | null;
  /** This field can be used as a passthrough for custom metadata about the matched text(s). The value of this field will appear with every match of its entity in the skill output. */
  id?: string | null;
  /** Defaults to false. Boolean value denoting whether comparisons with the entity name should be sensitive to character casing. Sample case insensitive matches of "Microsoft" could be: microsoft, microSoft, MICROSOFT. */
  caseSensitive?: boolean | null;
  /** Defaults to false. Boolean value denoting whether comparisons with the entity name should be sensitive to accent. */
  accentSensitive?: boolean | null;
  /** Defaults to 0. Maximum value of 5. Denotes the acceptable number of divergent characters that would still constitute a match with the entity name. The smallest possible fuzziness for any given match is returned. For instance, if the edit distance is set to 3, "Windows10" would still match "Windows", "Windows10" and "Windows 7". When case sensitivity is set to false, case differences do NOT count towards fuzziness tolerance, but otherwise do. */
  fuzzyEditDistance?: number | null;
  /** Changes the default case sensitivity value for this entity. It be used to change the default value of all aliases caseSensitive values. */
  defaultCaseSensitive?: boolean | null;
  /** Changes the default accent sensitivity value for this entity. It be used to change the default value of all aliases accentSensitive values. */
  defaultAccentSensitive?: boolean | null;
  /** Changes the default fuzzy edit distance value for this entity. It can be used to change the default value of all aliases fuzzyEditDistance values. */
  defaultFuzzyEditDistance?: number | null;
  /** An array of complex objects that can be used to specify alternative spellings or synonyms to the root entity name. */
  aliases?: CustomEntityAlias[] | null;
}

/** A complex object that can be used to specify alternative spellings or synonyms to the root entity name. */
export interface CustomEntityAlias {
  /** The text of the alias. */
  text: string;
  /** Determine if the alias is case sensitive. */
  caseSensitive?: boolean | null;
  /** Determine if the alias is accent sensitive. */
  accentSensitive?: boolean | null;
  /** Determine the fuzzy edit distance of the alias. */
  fuzzyEditDistance?: number | null;
}

/** Defines a data change detection policy that captures changes based on the value of a high water mark column. */
export type HighWaterMarkChangeDetectionPolicy = DataChangeDetectionPolicy & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy";
  /** The name of the high water mark column. */
  highWaterMarkColumnName: string;
};

/** Defines a data change detection policy that captures changes using the Integrated Change Tracking feature of Azure SQL Database. */
export type SqlIntegratedChangeTrackingPolicy = DataChangeDetectionPolicy & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
};

/** Defines a data deletion detection policy that implements a soft-deletion strategy. It determines whether an item should be deleted based on the value of a designated 'soft delete' column. */
export type SoftDeleteColumnDeletionDetectionPolicy = DataDeletionDetectionPolicy & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
  /** The name of the column to use for soft-deletion detection. */
  softDeleteColumnName?: string;
  /** The marker value that identifies an item as deleted. */
  softDeleteMarkerValue?: string;
};

/** A skill that enables scenarios that require a Boolean operation to determine the data to assign to an output. */
export type ConditionalSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Util.ConditionalSkill";
};

/** A skill that uses text analytics for key phrase extraction. */
export type KeyPhraseExtractionSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill";
  /** A value indicating which language code to use. Default is en. */
  defaultLanguageCode?: KeyPhraseExtractionSkillLanguage;
  /** A number indicating how many key phrases to return. If absent, all identified key phrases will be returned. */
  maxKeyPhraseCount?: number | null;
  /** The version of the model to use when calling the Text Analytics service. It will default to the latest available when not specified. We recommend you do not specify this value unless absolutely necessary. */
  modelVersion?: string | null;
};

/** A skill that extracts text from image files. */
export type OcrSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Vision.OcrSkill";
  /** A value indicating which language code to use. Default is en. */
  defaultLanguageCode?: OcrSkillLanguage;
  /** A value indicating to turn orientation detection on or not. Default is false. */
  shouldDetectOrientation?: boolean;
};

/** A skill that analyzes image files. It extracts a rich set of visual features based on the image content. */
export type ImageAnalysisSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
  /** A value indicating which language code to use. Default is en. */
  defaultLanguageCode?: ImageAnalysisSkillLanguage;
  /** A list of visual features. */
  visualFeatures?: VisualFeature[];
  /** A string indicating which domain-specific details to return. */
  details?: ImageDetail[];
};

/** A skill that detects the language of input text and reports a single language code for every document submitted on the request. The language code is paired with a score indicating the confidence of the analysis. */
export type LanguageDetectionSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Text.LanguageDetectionSkill";
  /** A country code to use as a hint to the language detection model if it cannot disambiguate the language. */
  defaultCountryHint?: string | null;
  /** The version of the model to use when calling the Text Analytics service. It will default to the latest available when not specified. We recommend you do not specify this value unless absolutely necessary. */
  modelVersion?: string | null;
};

/** A skill for reshaping the outputs. It creates a complex type to support composite fields (also known as multipart fields). */
export type ShaperSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Util.ShaperSkill";
};

/** A skill for merging two or more strings into a single unified string, with an optional user-defined delimiter separating each component part. */
export type MergeSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Text.MergeSkill";
  /** The tag indicates the start of the merged text. By default, the tag is an empty space. */
  insertPreTag?: string;
  /** The tag indicates the end of the merged text. By default, the tag is an empty space. */
  insertPostTag?: string;
};

/** Text analytics entity recognition. */
export type EntityRecognitionSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Text.EntityRecognitionSkill";
  /** A list of entity categories that should be extracted. */
  categories?: EntityCategory[];
  /** A value indicating which language code to use. Default is en. */
  defaultLanguageCode?: EntityRecognitionSkillLanguage;
  /** Determines whether or not to include entities which are well known but don't conform to a pre-defined type. If this configuration is not set (default), set to null or set to false, entities which don't conform to one of the pre-defined types will not be surfaced. */
  includeTypelessEntities?: boolean | null;
  /** A value between 0 and 1 that be used to only include entities whose confidence score is greater than the value specified. If not set (default), or if explicitly set to null, all entities will be included. */
  minimumPrecision?: number | null;
};

/** Text analytics positive-negative sentiment analysis, scored as a floating point value in a range of zero to 1. */
export type SentimentSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Text.SentimentSkill";
  /** A value indicating which language code to use. Default is en. */
  defaultLanguageCode?: SentimentSkillLanguage;
};

/** A skill to split a string into chunks of text. */
export type SplitSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Text.SplitSkill";
  /** A value indicating which language code to use. Default is en. */
  defaultLanguageCode?: SplitSkillLanguage;
  /** A value indicating which split mode to perform. */
  textSplitMode?: TextSplitMode;
  /** The desired maximum page length. Default is 10000. */
  maxPageLength?: number | null;
};

/** A skill looks for text from a custom, user-defined list of words and phrases. */
export type CustomEntityLookupSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Text.CustomEntityLookupSkill";
  /** A value indicating which language code to use. Default is en. */
  defaultLanguageCode?: CustomEntityLookupSkillLanguage | null;
  /** Path to a JSON or CSV file containing all the target text to match against. This entity definition is read at the beginning of an indexer run. Any updates to this file during an indexer run will not take effect until subsequent runs. This config must be accessible over HTTPS. */
  entitiesDefinitionUri?: string | null;
  /** The inline CustomEntity definition. */
  inlineEntitiesDefinition?: CustomEntity[] | null;
  /** A global flag for CaseSensitive. If CaseSensitive is not set in CustomEntity, this value will be the default value. */
  globalDefaultCaseSensitive?: boolean | null;
  /** A global flag for AccentSensitive. If AccentSensitive is not set in CustomEntity, this value will be the default value. */
  globalDefaultAccentSensitive?: boolean | null;
  /** A global flag for FuzzyEditDistance. If FuzzyEditDistance is not set in CustomEntity, this value will be the default value. */
  globalDefaultFuzzyEditDistance?: number | null;
};

/** A skill to translate text from one language to another. */
export type TextTranslationSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Text.TranslationSkill";
  /** The language code to translate documents into for documents that don't specify the to language explicitly. */
  defaultToLanguageCode: TextTranslationSkillLanguage;
  /** The language code to translate documents from for documents that don't specify the from language explicitly. */
  defaultFromLanguageCode?: TextTranslationSkillLanguage;
  /** The language code to translate documents from when neither the fromLanguageCode input nor the defaultFromLanguageCode parameter are provided, and the automatic language detection is unsuccessful. Default is en. */
  suggestedFrom?: TextTranslationSkillLanguage | null;
};

/** A skill that extracts content from a file within the enrichment pipeline. */
export type DocumentExtractionSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Util.DocumentExtractionSkill";
  /** The parsingMode for the skill. Will be set to 'default' if not defined. */
  parsingMode?: string | null;
  /** The type of data to be extracted for the skill. Will be set to 'contentAndMetadata' if not defined. */
  dataToExtract?: string | null;
  /** A dictionary of configurations for the skill. */
  configuration?: { [propertyName: string]: any } | null;
};

/** A skill that can call a Web API endpoint, allowing you to extend a skillset by having it call your custom code. */
export type WebApiSkill = SearchIndexerSkill & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Skills.Custom.WebApiSkill";
  /** The url for the Web API. */
  uri: string;
  /** The headers required to make the http request. */
  httpHeaders?: { [propertyName: string]: string };
  /** The method for the http request. */
  httpMethod?: string;
  /** The desired timeout for the request. Default is 30 seconds. */
  timeout?: string;
  /** The desired batch size which indicates number of documents. */
  batchSize?: number | null;
  /** If set, the number of parallel calls that can be made to the Web API. */
  degreeOfParallelism?: number | null;
};

/** An empty object that represents the default cognitive service resource for a skillset. */
export type DefaultCognitiveServicesAccount = CognitiveServicesAccount & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices";
};

/** A cognitive service resource provisioned with a key that is attached to a skillset. */
export type CognitiveServicesAccountKey = CognitiveServicesAccount & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.CognitiveServicesByKey";
  /** The key used to provision the cognitive service resource attached to a skillset. */
  key: string;
};

/** Description for what data to store in Azure Tables. */
export type SearchIndexerKnowledgeStoreTableProjectionSelector = SearchIndexerKnowledgeStoreProjectionSelector & {
  /** Name of the Azure table to store projected data in. */
  tableName: string;
};

/** Abstract class to share properties between concrete selectors. */
export type SearchIndexerKnowledgeStoreBlobProjectionSelector = SearchIndexerKnowledgeStoreProjectionSelector & {
  /** Blob container to store projections in. */
  storageContainer: string;
};

/** Defines a function that boosts scores based on distance from a geographic location. */
export type DistanceScoringFunction = ScoringFunction & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  type: "distance";
  /** Parameter values for the distance scoring function. */
  parameters: DistanceScoringParameters;
};

/** Defines a function that boosts scores based on the value of a date-time field. */
export type FreshnessScoringFunction = ScoringFunction & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  type: "freshness";
  /** Parameter values for the freshness scoring function. */
  parameters: FreshnessScoringParameters;
};

/** Defines a function that boosts scores based on the magnitude of a numeric field. */
export type MagnitudeScoringFunction = ScoringFunction & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  type: "magnitude";
  /** Parameter values for the magnitude scoring function. */
  parameters: MagnitudeScoringParameters;
};

/** Defines a function that boosts scores of documents with string values matching a given list of tags. */
export type TagScoringFunction = ScoringFunction & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  type: "tag";
  /** Parameter values for the tag scoring function. */
  parameters: TagScoringParameters;
};

/** Allows you to take control over the process of converting text into indexable/searchable tokens. It's a user-defined configuration consisting of a single predefined tokenizer and one or more filters. The tokenizer is responsible for breaking text into tokens, and the filters for modifying tokens emitted by the tokenizer. */
export type CustomAnalyzer = LexicalAnalyzer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.CustomAnalyzer";
  /** The name of the tokenizer to use to divide continuous text into a sequence of tokens, such as breaking a sentence into words. KnownTokenizerNames is an enum containing known values. */
  tokenizerName: string;
  /** A list of token filters used to filter out or modify the tokens generated by a tokenizer. For example, you can specify a lowercase filter that converts all characters to lowercase. The filters are run in the order in which they are listed. */
  tokenFilters?: string[];
  /** A list of character filters used to prepare input text before it is processed by the tokenizer. For instance, they can replace certain characters or symbols. The filters are run in the order in which they are listed. */
  charFilters?: string[];
};

/** Flexibly separates text into terms via a regular expression pattern. This analyzer is implemented using Apache Lucene. */
export type PatternAnalyzer = LexicalAnalyzer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.PatternAnalyzer";
  /** A value indicating whether terms should be lower-cased. Default is true. */
  lowerCaseTerms?: boolean;
  /** A regular expression pattern to match token separators. Default is an expression that matches one or more non-word characters. */
  pattern?: string;
  /** Regular expression flags. */
  flags?: string;
  /** A list of stopwords. */
  stopwords?: string[];
};

/** Standard Apache Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop filter. */
export type LuceneStandardAnalyzer = LexicalAnalyzer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.StandardAnalyzer";
  /** The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. */
  maxTokenLength?: number;
  /** A list of stopwords. */
  stopwords?: string[];
};

/** Divides text at non-letters; Applies the lowercase and stopword token filters. This analyzer is implemented using Apache Lucene. */
export type StopAnalyzer = LexicalAnalyzer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.StopAnalyzer";
  /** A list of stopwords. */
  stopwords?: string[];
};

/** Grammar-based tokenizer that is suitable for processing most European-language documents. This tokenizer is implemented using Apache Lucene. */
export type ClassicTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.ClassicTokenizer";
  /** The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. */
  maxTokenLength?: number;
};

/** Tokenizes the input from an edge into n-grams of the given size(s). This tokenizer is implemented using Apache Lucene. */
export type EdgeNGramTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenizer";
  /** The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. */
  minGram?: number;
  /** The maximum n-gram length. Default is 2. Maximum is 300. */
  maxGram?: number;
  /** Character classes to keep in the tokens. */
  tokenChars?: TokenCharacterKind[];
};

/** Emits the entire input as a single token. This tokenizer is implemented using Apache Lucene. */
export type KeywordTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.KeywordTokenizer";
  /** The read buffer size in bytes. Default is 256. */
  bufferSize?: number;
};

/** Emits the entire input as a single token. This tokenizer is implemented using Apache Lucene. */
export type KeywordTokenizerV2 = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.KeywordTokenizerV2";
  /** The maximum token length. Default is 256. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. */
  maxTokenLength?: number;
};

/** Divides text using language-specific rules. */
export type MicrosoftLanguageTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer";
  /** The maximum token length. Tokens longer than the maximum length are split. Maximum token length that can be used is 300 characters. Tokens longer than 300 characters are first split into tokens of length 300 and then each of those tokens is split based on the max token length set. Default is 255. */
  maxTokenLength?: number;
  /** A value indicating how the tokenizer is used. Set to true if used as the search tokenizer, set to false if used as the indexing tokenizer. Default is false. */
  isSearchTokenizer?: boolean;
  /** The language to use. The default is English. */
  language?: MicrosoftTokenizerLanguage;
};

/** Divides text using language-specific rules and reduces words to their base forms. */
export type MicrosoftLanguageStemmingTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer";
  /** The maximum token length. Tokens longer than the maximum length are split. Maximum token length that can be used is 300 characters. Tokens longer than 300 characters are first split into tokens of length 300 and then each of those tokens is split based on the max token length set. Default is 255. */
  maxTokenLength?: number;
  /** A value indicating how the tokenizer is used. Set to true if used as the search tokenizer, set to false if used as the indexing tokenizer. Default is false. */
  isSearchTokenizer?: boolean;
  /** The language to use. The default is English. */
  language?: MicrosoftStemmingTokenizerLanguage;
};

/** Tokenizes the input into n-grams of the given size(s). This tokenizer is implemented using Apache Lucene. */
export type NGramTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.NGramTokenizer";
  /** The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. */
  minGram?: number;
  /** The maximum n-gram length. Default is 2. Maximum is 300. */
  maxGram?: number;
  /** Character classes to keep in the tokens. */
  tokenChars?: TokenCharacterKind[];
};

/** Tokenizer for path-like hierarchies. This tokenizer is implemented using Apache Lucene. */
export type PathHierarchyTokenizerV2 = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2";
  /** The delimiter character to use. Default is "/". */
  delimiter?: string;
  /** A value that, if set, replaces the delimiter character. Default is "/". */
  replacement?: string;
  /** The maximum token length. Default and maximum is 300. */
  maxTokenLength?: number;
  /** A value indicating whether to generate tokens in reverse order. Default is false. */
  reverseTokenOrder?: boolean;
  /** The number of initial tokens to skip. Default is 0. */
  numberOfTokensToSkip?: number;
};

/** Tokenizer that uses regex pattern matching to construct distinct tokens. This tokenizer is implemented using Apache Lucene. */
export type PatternTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.PatternTokenizer";
  /** A regular expression pattern to match token separators. Default is an expression that matches one or more non-word characters. */
  pattern?: string;
  /** Regular expression flags. */
  flags?: string;
  /** The zero-based ordinal of the matching group in the regular expression pattern to extract into tokens. Use -1 if you want to use the entire pattern to split the input into tokens, irrespective of matching groups. Default is -1. */
  group?: number;
};

/** Breaks text following the Unicode Text Segmentation rules. This tokenizer is implemented using Apache Lucene. */
export type LuceneStandardTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.StandardTokenizer";
  /** The maximum token length. Default is 255. Tokens longer than the maximum length are split. */
  maxTokenLength?: number;
};

/** Breaks text following the Unicode Text Segmentation rules. This tokenizer is implemented using Apache Lucene. */
export type LuceneStandardTokenizerV2 = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.StandardTokenizerV2";
  /** The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. */
  maxTokenLength?: number;
};

/** Tokenizes urls and emails as one token. This tokenizer is implemented using Apache Lucene. */
export type UaxUrlEmailTokenizer = LexicalTokenizer & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
  /** The maximum token length. Default is 255. Tokens longer than the maximum length are split. The maximum token length that can be used is 300 characters. */
  maxTokenLength?: number;
};

/** Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127 ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such equivalents exist. This token filter is implemented using Apache Lucene. */
export type AsciiFoldingTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter";
  /** A value indicating whether the original token will be kept. Default is false. */
  preserveOriginal?: boolean;
};

/** Forms bigrams of CJK terms that are generated from the standard tokenizer. This token filter is implemented using Apache Lucene. */
export type CjkBigramTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.CjkBigramTokenFilter";
  /** The scripts to ignore. */
  ignoreScripts?: CjkBigramTokenFilterScripts[];
  /** A value indicating whether to output both unigrams and bigrams (if true), or just bigrams (if false). Default is false. */
  outputUnigrams?: boolean;
};

/** Construct bigrams for frequently occurring terms while indexing. Single terms are still indexed too, with bigrams overlaid. This token filter is implemented using Apache Lucene. */
export type CommonGramTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.CommonGramTokenFilter";
  /** The set of common words. */
  commonWords: string[];
  /** A value indicating whether common words matching will be case insensitive. Default is false. */
  ignoreCase?: boolean;
  /** A value that indicates whether the token filter is in query mode. When in query mode, the token filter generates bigrams and then removes common words and single terms followed by a common word. Default is false. */
  useQueryMode?: boolean;
};

/** Decomposes compound words found in many Germanic languages. This token filter is implemented using Apache Lucene. */
export type DictionaryDecompounderTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter";
  /** The list of words to match against. */
  wordList: string[];
  /** The minimum word size. Only words longer than this get processed. Default is 5. Maximum is 300. */
  minWordSize?: number;
  /** The minimum subword size. Only subwords longer than this are outputted. Default is 2. Maximum is 300. */
  minSubwordSize?: number;
  /** The maximum subword size. Only subwords shorter than this are outputted. Default is 15. Maximum is 300. */
  maxSubwordSize?: number;
  /** A value indicating whether to add only the longest matching subword to the output. Default is false. */
  onlyLongestMatch?: boolean;
};

/** Generates n-grams of the given size(s) starting from the front or the back of an input token. This token filter is implemented using Apache Lucene. */
export type EdgeNGramTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilter";
  /** The minimum n-gram length. Default is 1. Must be less than the value of maxGram. */
  minGram?: number;
  /** The maximum n-gram length. Default is 2. */
  maxGram?: number;
  /** Specifies which side of the input the n-gram should be generated from. Default is "front". */
  side?: EdgeNGramTokenFilterSide;
};

/** Generates n-grams of the given size(s) starting from the front or the back of an input token. This token filter is implemented using Apache Lucene. */
export type EdgeNGramTokenFilterV2 = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2";
  /** The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. */
  minGram?: number;
  /** The maximum n-gram length. Default is 2. Maximum is 300. */
  maxGram?: number;
  /** Specifies which side of the input the n-gram should be generated from. Default is "front". */
  side?: EdgeNGramTokenFilterSide;
};

/** Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). This token filter is implemented using Apache Lucene. */
export type ElisionTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.ElisionTokenFilter";
  /** The set of articles to remove. */
  articles?: string[];
};

/** A token filter that only keeps tokens with text contained in a specified list of words. This token filter is implemented using Apache Lucene. */
export type KeepTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.KeepTokenFilter";
  /** The list of words to keep. */
  keepWords: string[];
  /** A value indicating whether to lower case all words first. Default is false. */
  lowerCaseKeepWords?: boolean;
};

/** Marks terms as keywords. This token filter is implemented using Apache Lucene. */
export type KeywordMarkerTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter";
  /** A list of words to mark as keywords. */
  keywords: string[];
  /** A value indicating whether to ignore case. If true, all words are converted to lower case first. Default is false. */
  ignoreCase?: boolean;
};

/** Removes words that are too long or too short. This token filter is implemented using Apache Lucene. */
export type LengthTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.LengthTokenFilter";
  /** The minimum length in characters. Default is 0. Maximum is 300. Must be less than the value of max. */
  minLength?: number;
  /** The maximum length in characters. Default and maximum is 300. */
  maxLength?: number;
};

/** Limits the number of tokens while indexing. This token filter is implemented using Apache Lucene. */
export type LimitTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.LimitTokenFilter";
  /** The maximum number of tokens to produce. Default is 1. */
  maxTokenCount?: number;
  /** A value indicating whether all tokens from the input must be consumed even if maxTokenCount is reached. Default is false. */
  consumeAllTokens?: boolean;
};

/** Generates n-grams of the given size(s). This token filter is implemented using Apache Lucene. */
export type NGramTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.NGramTokenFilter";
  /** The minimum n-gram length. Default is 1. Must be less than the value of maxGram. */
  minGram?: number;
  /** The maximum n-gram length. Default is 2. */
  maxGram?: number;
};

/** Generates n-grams of the given size(s). This token filter is implemented using Apache Lucene. */
export type NGramTokenFilterV2 = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.NGramTokenFilterV2";
  /** The minimum n-gram length. Default is 1. Maximum is 300. Must be less than the value of maxGram. */
  minGram?: number;
  /** The maximum n-gram length. Default is 2. Maximum is 300. */
  maxGram?: number;
};

/** Uses Java regexes to emit multiple tokens - one for each capture group in one or more patterns. This token filter is implemented using Apache Lucene. */
export type PatternCaptureTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.PatternCaptureTokenFilter";
  /** A list of patterns to match against each token. */
  patterns: string[];
  /** A value indicating whether to return the original token even if one of the patterns matches. Default is true. */
  preserveOriginal?: boolean;
};

/** A character filter that replaces characters in the input string. It uses a regular expression to identify character sequences to preserve and a replacement pattern to identify characters to replace. For example, given the input text "aa bb aa bb", pattern "(aa)\s+(bb)", and replacement "$1#$2", the result would be "aa#bb aa#bb". This token filter is implemented using Apache Lucene. */
export type PatternReplaceTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.PatternReplaceTokenFilter";
  /** A regular expression pattern. */
  pattern: string;
  /** The replacement text. */
  replacement: string;
};

/** Create tokens for phonetic matches. This token filter is implemented using Apache Lucene. */
export type PhoneticTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.PhoneticTokenFilter";
  /** The phonetic encoder to use. Default is "metaphone". */
  encoder?: PhoneticEncoder;
  /** A value indicating whether encoded tokens should replace original tokens. If false, encoded tokens are added as synonyms. Default is true. */
  replaceOriginalTokens?: boolean;
};

/** Creates combinations of tokens as a single token. This token filter is implemented using Apache Lucene. */
export type ShingleTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.ShingleTokenFilter";
  /** The maximum shingle size. Default and minimum value is 2. */
  maxShingleSize?: number;
  /** The minimum shingle size. Default and minimum value is 2. Must be less than the value of maxShingleSize. */
  minShingleSize?: number;
  /** A value indicating whether the output stream will contain the input tokens (unigrams) as well as shingles. Default is true. */
  outputUnigrams?: boolean;
  /** A value indicating whether to output unigrams for those times when no shingles are available. This property takes precedence when outputUnigrams is set to false. Default is false. */
  outputUnigramsIfNoShingles?: boolean;
  /** The string to use when joining adjacent tokens to form a shingle. Default is a single space (" "). */
  tokenSeparator?: string;
  /** The string to insert for each position at which there is no token. Default is an underscore ("_"). */
  filterToken?: string;
};

/** A filter that stems words using a Snowball-generated stemmer. This token filter is implemented using Apache Lucene. */
export type SnowballTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.SnowballTokenFilter";
  /** The language to use. */
  language: SnowballTokenFilterLanguage;
};

/** Language specific stemming filter. This token filter is implemented using Apache Lucene. */
export type StemmerTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.StemmerTokenFilter";
  /** The language to use. */
  language: StemmerTokenFilterLanguage;
};

/** Provides the ability to override other stemming filters with custom dictionary-based stemming. Any dictionary-stemmed terms will be marked as keywords so that they will not be stemmed with stemmers down the chain. Must be placed before any stemming filters. This token filter is implemented using Apache Lucene. */
export type StemmerOverrideTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter";
  /** A list of stemming rules in the following format: "word => stem", for example: "ran => run". */
  rules: string[];
};

/** Removes stop words from a token stream. This token filter is implemented using Apache Lucene. */
export type StopwordsTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.StopwordsTokenFilter";
  /** The list of stopwords. This property and the stopwords list property cannot both be set. */
  stopwords?: string[];
  /** A predefined list of stopwords to use. This property and the stopwords property cannot both be set. Default is English. */
  stopwordsList?: StopwordsList;
  /** A value indicating whether to ignore case. If true, all words are converted to lower case first. Default is false. */
  ignoreCase?: boolean;
  /** A value indicating whether to ignore the last search term if it's a stop word. Default is true. */
  removeTrailingStopWords?: boolean;
};

/** Matches single or multi-word synonyms in a token stream. This token filter is implemented using Apache Lucene. */
export type SynonymTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.SynonymTokenFilter";
  /** A list of synonyms in following one of two formats: 1. incredible, unbelievable, fabulous => amazing - all terms on the left side of => symbol will be replaced with all terms on its right side; 2. incredible, unbelievable, fabulous, amazing - comma separated list of equivalent words. Set the expand option to change how this list is interpreted. */
  synonyms: string[];
  /** A value indicating whether to case-fold input for matching. Default is false. */
  ignoreCase?: boolean;
  /** A value indicating whether all words in the list of synonyms (if => notation is not used) will map to one another. If true, all words in the list of synonyms (if => notation is not used) will map to one another. The following list: incredible, unbelievable, fabulous, amazing is equivalent to: incredible, unbelievable, fabulous, amazing => incredible, unbelievable, fabulous, amazing. If false, the following list: incredible, unbelievable, fabulous, amazing will be equivalent to: incredible, unbelievable, fabulous, amazing => incredible. Default is true. */
  expand?: boolean;
};

/** Truncates the terms to a specific length. This token filter is implemented using Apache Lucene. */
export type TruncateTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.TruncateTokenFilter";
  /** The length at which terms will be truncated. Default and maximum is 300. */
  length?: number;
};

/** Filters out tokens with same text as the previous token. This token filter is implemented using Apache Lucene. */
export type UniqueTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.UniqueTokenFilter";
  /** A value indicating whether to remove duplicates only at the same position. Default is false. */
  onlyOnSamePosition?: boolean;
};

/** Splits words into subwords and performs optional transformations on subword groups. This token filter is implemented using Apache Lucene. */
export type WordDelimiterTokenFilter = TokenFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
  /** A value indicating whether to generate part words. If set, causes parts of words to be generated; for example "AzureSearch" becomes "Azure" "Search". Default is true. */
  generateWordParts?: boolean;
  /** A value indicating whether to generate number subwords. Default is true. */
  generateNumberParts?: boolean;
  /** A value indicating whether maximum runs of word parts will be catenated. For example, if this is set to true, "Azure-Search" becomes "AzureSearch". Default is false. */
  catenateWords?: boolean;
  /** A value indicating whether maximum runs of number parts will be catenated. For example, if this is set to true, "1-2" becomes "12". Default is false. */
  catenateNumbers?: boolean;
  /** A value indicating whether all subword parts will be catenated. For example, if this is set to true, "Azure-Search-1" becomes "AzureSearch1". Default is false. */
  catenateAll?: boolean;
  /** A value indicating whether to split words on caseChange. For example, if this is set to true, "AzureSearch" becomes "Azure" "Search". Default is true. */
  splitOnCaseChange?: boolean;
  /** A value indicating whether original words will be preserved and added to the subword list. Default is false. */
  preserveOriginal?: boolean;
  /** A value indicating whether to split on numbers. For example, if this is set to true, "Azure1Search" becomes "Azure" "1" "Search". Default is true. */
  splitOnNumerics?: boolean;
  /** A value indicating whether to remove trailing "'s" for each subword. Default is true. */
  stemEnglishPossessive?: boolean;
  /** A list of tokens to protect from being delimited. */
  protectedWords?: string[];
};

/** A character filter that applies mappings defined with the mappings option. Matching is greedy (longest pattern matching at a given point wins). Replacement is allowed to be the empty string. This character filter is implemented using Apache Lucene. */
export type MappingCharFilter = CharFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.MappingCharFilter";
  /** A list of mappings of the following format: "a=>b" (all occurrences of the character "a" will be replaced with character "b"). */
  mappings: string[];
};

/** A character filter that replaces characters in the input string. It uses a regular expression to identify character sequences to preserve and a replacement pattern to identify characters to replace. For example, given the input text "aa bb aa bb", pattern "(aa)\s+(bb)", and replacement "$1#$2", the result would be "aa#bb aa#bb". This character filter is implemented using Apache Lucene. */
export type PatternReplaceCharFilter = CharFilter & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.PatternReplaceCharFilter";
  /** A regular expression pattern. */
  pattern: string;
  /** The replacement text. */
  replacement: string;
};

/** Legacy similarity algorithm which uses the Lucene TFIDFSimilarity implementation of TF-IDF. This variation of TF-IDF introduces static document length normalization as well as coordinating factors that penalize documents that only partially match the searched queries. */
export type ClassicSimilarity = Similarity & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.ClassicSimilarity";
};

/** Ranking function based on the Okapi BM25 similarity algorithm. BM25 is a TF-IDF-like algorithm that includes length normalization (controlled by the 'b' parameter) as well as term frequency saturation (controlled by the 'k1' parameter). */
export type BM25Similarity = Similarity & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  odatatype: "#Microsoft.Azure.Search.BM25Similarity";
  /** This property controls the scaling function between the term frequency of each matching terms and the final relevance score of a document-query pair. By default, a value of 1.2 is used. A value of 0.0 means the score does not scale with an increase in term frequency. */
  k1?: number | null;
  /** This property controls how the length of a document affects the relevance score. By default, a value of 0.75 is used. A value of 0.0 means no length normalization is applied, while a value of 1.0 means the score is fully normalized by the length of the document. */
  b?: number | null;
};

/** Projection definition for what data to store in Azure Blob. */
export type SearchIndexerKnowledgeStoreObjectProjectionSelector = SearchIndexerKnowledgeStoreBlobProjectionSelector & {};

/** Projection definition for what data to store in Azure Files. */
export type SearchIndexerKnowledgeStoreFileProjectionSelector = SearchIndexerKnowledgeStoreBlobProjectionSelector & {};

/** Parameter group */
export interface RequestOptions {
  /** The tracking ID sent with the request to help with debugging. */
  xMsClientRequestId?: string;
}

/** Known values of {@link ApiVersion20200630} that the service accepts. */
export const enum KnownApiVersion20200630 {
  /** Api Version '2020-06-30' */
  TwoThousandTwenty0630 = "2020-06-30"
}

/**
 * Defines values for ApiVersion20200630. \
 * {@link KnownApiVersion20200630} can be used interchangeably with ApiVersion20200630,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **2020-06-30**: Api Version '2020-06-30'
 */
export type ApiVersion20200630 = string;

/** Known values of {@link SearchIndexerDataSourceType} that the service accepts. */
export const enum KnownSearchIndexerDataSourceType {
  /** Indicates an Azure SQL datasource. */
  AzureSql = "azuresql",
  /** Indicates a CosmosDB datasource. */
  CosmosDb = "cosmosdb",
  /** Indicates an Azure Blob datasource. */
  AzureBlob = "azureblob",
  /** Indicates an Azure Table datasource. */
  AzureTable = "azuretable",
  /** Indicates a MySql datasource. */
  MySql = "mysql",
  /** Indicates an ADLS Gen2 datasource. */
  AdlsGen2 = "adlsgen2"
}

/**
 * Defines values for SearchIndexerDataSourceType. \
 * {@link KnownSearchIndexerDataSourceType} can be used interchangeably with SearchIndexerDataSourceType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **azuresql**: Indicates an Azure SQL datasource. \
 * **cosmosdb**: Indicates a CosmosDB datasource. \
 * **azureblob**: Indicates an Azure Blob datasource. \
 * **azuretable**: Indicates an Azure Table datasource. \
 * **mysql**: Indicates a MySql datasource. \
 * **adlsgen2**: Indicates an ADLS Gen2 datasource.
 */
export type SearchIndexerDataSourceType = string;

/** Known values of {@link BlobIndexerParsingMode} that the service accepts. */
export const enum KnownBlobIndexerParsingMode {
  /** Set to default for normal file processing. */
  Default = "default",
  /** Set to text to improve indexing performance on plain text files in blob storage. */
  Text = "text",
  /** Set to delimitedText when blobs are plain CSV files. */
  DelimitedText = "delimitedText",
  /** Set to json to extract structured content from JSON files. */
  Json = "json",
  /** Set to jsonArray to extract individual elements of a JSON array as separate documents in Azure Cognitive Search. */
  JsonArray = "jsonArray",
  /** Set to jsonLines to extract individual JSON entities, separated by a new line, as separate documents in Azure Cognitive Search. */
  JsonLines = "jsonLines"
}

/**
 * Defines values for BlobIndexerParsingMode. \
 * {@link KnownBlobIndexerParsingMode} can be used interchangeably with BlobIndexerParsingMode,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **default**: Set to default for normal file processing. \
 * **text**: Set to text to improve indexing performance on plain text files in blob storage. \
 * **delimitedText**: Set to delimitedText when blobs are plain CSV files. \
 * **json**: Set to json to extract structured content from JSON files. \
 * **jsonArray**: Set to jsonArray to extract individual elements of a JSON array as separate documents in Azure Cognitive Search. \
 * **jsonLines**: Set to jsonLines to extract individual JSON entities, separated by a new line, as separate documents in Azure Cognitive Search.
 */
export type BlobIndexerParsingMode = string;

/** Known values of {@link BlobIndexerDataToExtract} that the service accepts. */
export const enum KnownBlobIndexerDataToExtract {
  /** Indexes just the standard blob properties and user-specified metadata. */
  StorageMetadata = "storageMetadata",
  /** Extracts metadata provided by the Azure blob storage subsystem and the content-type specific metadata (for example, metadata unique to just .png files are indexed). */
  AllMetadata = "allMetadata",
  /** Extracts all metadata and textual content from each blob. */
  ContentAndMetadata = "contentAndMetadata"
}

/**
 * Defines values for BlobIndexerDataToExtract. \
 * {@link KnownBlobIndexerDataToExtract} can be used interchangeably with BlobIndexerDataToExtract,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **storageMetadata**: Indexes just the standard blob properties and user-specified metadata. \
 * **allMetadata**: Extracts metadata provided by the Azure blob storage subsystem and the content-type specific metadata (for example, metadata unique to just .png files are indexed). \
 * **contentAndMetadata**: Extracts all metadata and textual content from each blob.
 */
export type BlobIndexerDataToExtract = string;

/** Known values of {@link BlobIndexerImageAction} that the service accepts. */
export const enum KnownBlobIndexerImageAction {
  /** Ignores embedded images or image files in the data set.  This is the default. */
  None = "none",
  /** Extracts text from images (for example, the word "STOP" from a traffic stop sign), and embeds it into the content field.  This action requires that "dataToExtract" is set to "contentAndMetadata".  A normalized image refers to additional processing resulting in uniform image output, sized and rotated to promote consistent rendering when you include images in visual search results. This information is generated for each image when you use this option. */
  GenerateNormalizedImages = "generateNormalizedImages",
  /** Extracts text from images (for example, the word "STOP" from a traffic stop sign), and embeds it into the content field, but treats PDF files differently in that each page will be rendered as an image and normalized accordingly, instead of extracting embedded images.  Non-PDF file types will be treated the same as if "generateNormalizedImages" was set. */
  GenerateNormalizedImagePerPage = "generateNormalizedImagePerPage"
}

/**
 * Defines values for BlobIndexerImageAction. \
 * {@link KnownBlobIndexerImageAction} can be used interchangeably with BlobIndexerImageAction,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **none**: Ignores embedded images or image files in the data set.  This is the default. \
 * **generateNormalizedImages**: Extracts text from images (for example, the word "STOP" from a traffic stop sign), and embeds it into the content field.  This action requires that "dataToExtract" is set to "contentAndMetadata".  A normalized image refers to additional processing resulting in uniform image output, sized and rotated to promote consistent rendering when you include images in visual search results. This information is generated for each image when you use this option. \
 * **generateNormalizedImagePerPage**: Extracts text from images (for example, the word "STOP" from a traffic stop sign), and embeds it into the content field, but treats PDF files differently in that each page will be rendered as an image and normalized accordingly, instead of extracting embedded images.  Non-PDF file types will be treated the same as if "generateNormalizedImages" was set.
 */
export type BlobIndexerImageAction = string;

/** Known values of {@link BlobIndexerPDFTextRotationAlgorithm} that the service accepts. */
export const enum KnownBlobIndexerPDFTextRotationAlgorithm {
  /** Leverages normal text extraction.  This is the default. */
  None = "none",
  /** May produce better and more readable text extraction from PDF files that have rotated text within them.  Note that there may be a small performance speed impact when this parameter is used.  This parameter only applies to PDF files, and only to PDFs with embedded text.  If the rotated text appears within an embedded image in the PDF, this parameter does not apply. */
  DetectAngles = "detectAngles"
}

/**
 * Defines values for BlobIndexerPDFTextRotationAlgorithm. \
 * {@link KnownBlobIndexerPDFTextRotationAlgorithm} can be used interchangeably with BlobIndexerPDFTextRotationAlgorithm,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **none**: Leverages normal text extraction.  This is the default. \
 * **detectAngles**: May produce better and more readable text extraction from PDF files that have rotated text within them.  Note that there may be a small performance speed impact when this parameter is used.  This parameter only applies to PDF files, and only to PDFs with embedded text.  If the rotated text appears within an embedded image in the PDF, this parameter does not apply.
 */
export type BlobIndexerPDFTextRotationAlgorithm = string;

/** Known values of {@link IndexerExecutionEnvironment} that the service accepts. */
export const enum KnownIndexerExecutionEnvironment {
  /** Indicates that Azure Cognitive Search can determine where the indexer should execute. This is the default environment when nothing is specified and is the recommended value. */
  Standard = "standard",
  /** Indicates that the indexer should run with the environment provisioned specifically for the search service. This should only be specified as the execution environment if the indexer needs to access resources securely over shared private link resources. */
  Private = "private"
}

/**
 * Defines values for IndexerExecutionEnvironment. \
 * {@link KnownIndexerExecutionEnvironment} can be used interchangeably with IndexerExecutionEnvironment,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **standard**: Indicates that Azure Cognitive Search can determine where the indexer should execute. This is the default environment when nothing is specified and is the recommended value. \
 * **private**: Indicates that the indexer should run with the environment provisioned specifically for the search service. This should only be specified as the execution environment if the indexer needs to access resources securely over shared private link resources.
 */
export type IndexerExecutionEnvironment = string;

/** Known values of {@link SearchFieldDataType} that the service accepts. */
export const enum KnownSearchFieldDataType {
  /** Indicates that a field contains a string. */
  String = "Edm.String",
  /** Indicates that a field contains a 32-bit signed integer. */
  Int32 = "Edm.Int32",
  /** Indicates that a field contains a 64-bit signed integer. */
  Int64 = "Edm.Int64",
  /** Indicates that a field contains an IEEE double-precision floating point number. */
  Double = "Edm.Double",
  /** Indicates that a field contains a Boolean value (true or false). */
  Boolean = "Edm.Boolean",
  /** Indicates that a field contains a date/time value, including timezone information. */
  DateTimeOffset = "Edm.DateTimeOffset",
  /** Indicates that a field contains a geo-location in terms of longitude and latitude. */
  GeographyPoint = "Edm.GeographyPoint",
  /** Indicates that a field contains one or more complex objects that in turn have sub-fields of other types. */
  Complex = "Edm.ComplexType",
  CollectionEdmString = "Collection(Edm.String)",
  CollectionEdmInt32 = "Collection(Edm.Int32)",
  CollectionEdmInt64 = "Collection(Edm.Int64)",
  CollectionEdmDouble = "Collection(Edm.Double)",
  CollectionEdmBoolean = "Collection(Edm.Boolean)",
  CollectionEdmDateTimeOffset = "Collection(Edm.DateTimeOffset)",
  CollectionEdmGeographyPoint = "Collection(Edm.GeographyPoint)",
  CollectionEdmComplexType = "Collection(Edm.ComplexType)"
}

/**
 * Defines values for SearchFieldDataType. \
 * {@link KnownSearchFieldDataType} can be used interchangeably with SearchFieldDataType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Edm.String**: Indicates that a field contains a string. \
 * **Edm.Int32**: Indicates that a field contains a 32-bit signed integer. \
 * **Edm.Int64**: Indicates that a field contains a 64-bit signed integer. \
 * **Edm.Double**: Indicates that a field contains an IEEE double-precision floating point number. \
 * **Edm.Boolean**: Indicates that a field contains a Boolean value (true or false). \
 * **Edm.DateTimeOffset**: Indicates that a field contains a date/time value, including timezone information. \
 * **Edm.GeographyPoint**: Indicates that a field contains a geo-location in terms of longitude and latitude. \
 * **Edm.ComplexType**: Indicates that a field contains one or more complex objects that in turn have sub-fields of other types. \
 * **Collection(Edm.String)** \
 * **Collection(Edm.Int32)** \
 * **Collection(Edm.Int64)** \
 * **Collection(Edm.Double)** \
 * **Collection(Edm.Boolean)** \
 * **Collection(Edm.DateTimeOffset)** \
 * **Collection(Edm.GeographyPoint)** \
 * **Collection(Edm.ComplexType)**
 */
export type SearchFieldDataType = string;

/** Known values of {@link LexicalAnalyzerName} that the service accepts. */
export const enum KnownLexicalAnalyzerName {
  /** Microsoft analyzer for Arabic. */
  ArMicrosoft = "ar.microsoft",
  /** Lucene analyzer for Arabic. */
  ArLucene = "ar.lucene",
  /** Lucene analyzer for Armenian. */
  HyLucene = "hy.lucene",
  /** Microsoft analyzer for Bangla. */
  BnMicrosoft = "bn.microsoft",
  /** Lucene analyzer for Basque. */
  EuLucene = "eu.lucene",
  /** Microsoft analyzer for Bulgarian. */
  BgMicrosoft = "bg.microsoft",
  /** Lucene analyzer for Bulgarian. */
  BgLucene = "bg.lucene",
  /** Microsoft analyzer for Catalan. */
  CaMicrosoft = "ca.microsoft",
  /** Lucene analyzer for Catalan. */
  CaLucene = "ca.lucene",
  /** Microsoft analyzer for Chinese (Simplified). */
  ZhHansMicrosoft = "zh-Hans.microsoft",
  /** Lucene analyzer for Chinese (Simplified). */
  ZhHansLucene = "zh-Hans.lucene",
  /** Microsoft analyzer for Chinese (Traditional). */
  ZhHantMicrosoft = "zh-Hant.microsoft",
  /** Lucene analyzer for Chinese (Traditional). */
  ZhHantLucene = "zh-Hant.lucene",
  /** Microsoft analyzer for Croatian. */
  HrMicrosoft = "hr.microsoft",
  /** Microsoft analyzer for Czech. */
  CsMicrosoft = "cs.microsoft",
  /** Lucene analyzer for Czech. */
  CsLucene = "cs.lucene",
  /** Microsoft analyzer for Danish. */
  DaMicrosoft = "da.microsoft",
  /** Lucene analyzer for Danish. */
  DaLucene = "da.lucene",
  /** Microsoft analyzer for Dutch. */
  NlMicrosoft = "nl.microsoft",
  /** Lucene analyzer for Dutch. */
  NlLucene = "nl.lucene",
  /** Microsoft analyzer for English. */
  EnMicrosoft = "en.microsoft",
  /** Lucene analyzer for English. */
  EnLucene = "en.lucene",
  /** Microsoft analyzer for Estonian. */
  EtMicrosoft = "et.microsoft",
  /** Microsoft analyzer for Finnish. */
  FiMicrosoft = "fi.microsoft",
  /** Lucene analyzer for Finnish. */
  FiLucene = "fi.lucene",
  /** Microsoft analyzer for French. */
  FrMicrosoft = "fr.microsoft",
  /** Lucene analyzer for French. */
  FrLucene = "fr.lucene",
  /** Lucene analyzer for Galician. */
  GlLucene = "gl.lucene",
  /** Microsoft analyzer for German. */
  DeMicrosoft = "de.microsoft",
  /** Lucene analyzer for German. */
  DeLucene = "de.lucene",
  /** Microsoft analyzer for Greek. */
  ElMicrosoft = "el.microsoft",
  /** Lucene analyzer for Greek. */
  ElLucene = "el.lucene",
  /** Microsoft analyzer for Gujarati. */
  GuMicrosoft = "gu.microsoft",
  /** Microsoft analyzer for Hebrew. */
  HeMicrosoft = "he.microsoft",
  /** Microsoft analyzer for Hindi. */
  HiMicrosoft = "hi.microsoft",
  /** Lucene analyzer for Hindi. */
  HiLucene = "hi.lucene",
  /** Microsoft analyzer for Hungarian. */
  HuMicrosoft = "hu.microsoft",
  /** Lucene analyzer for Hungarian. */
  HuLucene = "hu.lucene",
  /** Microsoft analyzer for Icelandic. */
  IsMicrosoft = "is.microsoft",
  /** Microsoft analyzer for Indonesian (Bahasa). */
  IdMicrosoft = "id.microsoft",
  /** Lucene analyzer for Indonesian. */
  IdLucene = "id.lucene",
  /** Lucene analyzer for Irish. */
  GaLucene = "ga.lucene",
  /** Microsoft analyzer for Italian. */
  ItMicrosoft = "it.microsoft",
  /** Lucene analyzer for Italian. */
  ItLucene = "it.lucene",
  /** Microsoft analyzer for Japanese. */
  JaMicrosoft = "ja.microsoft",
  /** Lucene analyzer for Japanese. */
  JaLucene = "ja.lucene",
  /** Microsoft analyzer for Kannada. */
  KnMicrosoft = "kn.microsoft",
  /** Microsoft analyzer for Korean. */
  KoMicrosoft = "ko.microsoft",
  /** Lucene analyzer for Korean. */
  KoLucene = "ko.lucene",
  /** Microsoft analyzer for Latvian. */
  LvMicrosoft = "lv.microsoft",
  /** Lucene analyzer for Latvian. */
  LvLucene = "lv.lucene",
  /** Microsoft analyzer for Lithuanian. */
  LtMicrosoft = "lt.microsoft",
  /** Microsoft analyzer for Malayalam. */
  MlMicrosoft = "ml.microsoft",
  /** Microsoft analyzer for Malay (Latin). */
  MsMicrosoft = "ms.microsoft",
  /** Microsoft analyzer for Marathi. */
  MrMicrosoft = "mr.microsoft",
  /** Microsoft analyzer for Norwegian (Bokmål). */
  NbMicrosoft = "nb.microsoft",
  /** Lucene analyzer for Norwegian. */
  NoLucene = "no.lucene",
  /** Lucene analyzer for Persian. */
  FaLucene = "fa.lucene",
  /** Microsoft analyzer for Polish. */
  PlMicrosoft = "pl.microsoft",
  /** Lucene analyzer for Polish. */
  PlLucene = "pl.lucene",
  /** Microsoft analyzer for Portuguese (Brazil). */
  PtBrMicrosoft = "pt-BR.microsoft",
  /** Lucene analyzer for Portuguese (Brazil). */
  PtBrLucene = "pt-BR.lucene",
  /** Microsoft analyzer for Portuguese (Portugal). */
  PtPtMicrosoft = "pt-PT.microsoft",
  /** Lucene analyzer for Portuguese (Portugal). */
  PtPtLucene = "pt-PT.lucene",
  /** Microsoft analyzer for Punjabi. */
  PaMicrosoft = "pa.microsoft",
  /** Microsoft analyzer for Romanian. */
  RoMicrosoft = "ro.microsoft",
  /** Lucene analyzer for Romanian. */
  RoLucene = "ro.lucene",
  /** Microsoft analyzer for Russian. */
  RuMicrosoft = "ru.microsoft",
  /** Lucene analyzer for Russian. */
  RuLucene = "ru.lucene",
  /** Microsoft analyzer for Serbian (Cyrillic). */
  SrCyrillicMicrosoft = "sr-cyrillic.microsoft",
  /** Microsoft analyzer for Serbian (Latin). */
  SrLatinMicrosoft = "sr-latin.microsoft",
  /** Microsoft analyzer for Slovak. */
  SkMicrosoft = "sk.microsoft",
  /** Microsoft analyzer for Slovenian. */
  SlMicrosoft = "sl.microsoft",
  /** Microsoft analyzer for Spanish. */
  EsMicrosoft = "es.microsoft",
  /** Lucene analyzer for Spanish. */
  EsLucene = "es.lucene",
  /** Microsoft analyzer for Swedish. */
  SvMicrosoft = "sv.microsoft",
  /** Lucene analyzer for Swedish. */
  SvLucene = "sv.lucene",
  /** Microsoft analyzer for Tamil. */
  TaMicrosoft = "ta.microsoft",
  /** Microsoft analyzer for Telugu. */
  TeMicrosoft = "te.microsoft",
  /** Microsoft analyzer for Thai. */
  ThMicrosoft = "th.microsoft",
  /** Lucene analyzer for Thai. */
  ThLucene = "th.lucene",
  /** Microsoft analyzer for Turkish. */
  TrMicrosoft = "tr.microsoft",
  /** Lucene analyzer for Turkish. */
  TrLucene = "tr.lucene",
  /** Microsoft analyzer for Ukrainian. */
  UkMicrosoft = "uk.microsoft",
  /** Microsoft analyzer for Urdu. */
  UrMicrosoft = "ur.microsoft",
  /** Microsoft analyzer for Vietnamese. */
  ViMicrosoft = "vi.microsoft",
  /** Standard Lucene analyzer. */
  StandardLucene = "standard.lucene",
  /** Standard ASCII Folding Lucene analyzer. See https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#Analyzers */
  StandardAsciiFoldingLucene = "standardasciifolding.lucene",
  /** Treats the entire content of a field as a single token. This is useful for data like zip codes, ids, and some product names. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordAnalyzer.html */
  Keyword = "keyword",
  /** Flexibly separates text into terms via a regular expression pattern. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/PatternAnalyzer.html */
  Pattern = "pattern",
  /** Divides text at non-letters and converts them to lower case. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/SimpleAnalyzer.html */
  Simple = "simple",
  /** Divides text at non-letters; Applies the lowercase and stopword token filters. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopAnalyzer.html */
  Stop = "stop",
  /** An analyzer that uses the whitespace tokenizer. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceAnalyzer.html */
  Whitespace = "whitespace"
}

/**
 * Defines values for LexicalAnalyzerName. \
 * {@link KnownLexicalAnalyzerName} can be used interchangeably with LexicalAnalyzerName,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **ar.microsoft**: Microsoft analyzer for Arabic. \
 * **ar.lucene**: Lucene analyzer for Arabic. \
 * **hy.lucene**: Lucene analyzer for Armenian. \
 * **bn.microsoft**: Microsoft analyzer for Bangla. \
 * **eu.lucene**: Lucene analyzer for Basque. \
 * **bg.microsoft**: Microsoft analyzer for Bulgarian. \
 * **bg.lucene**: Lucene analyzer for Bulgarian. \
 * **ca.microsoft**: Microsoft analyzer for Catalan. \
 * **ca.lucene**: Lucene analyzer for Catalan. \
 * **zh-Hans.microsoft**: Microsoft analyzer for Chinese (Simplified). \
 * **zh-Hans.lucene**: Lucene analyzer for Chinese (Simplified). \
 * **zh-Hant.microsoft**: Microsoft analyzer for Chinese (Traditional). \
 * **zh-Hant.lucene**: Lucene analyzer for Chinese (Traditional). \
 * **hr.microsoft**: Microsoft analyzer for Croatian. \
 * **cs.microsoft**: Microsoft analyzer for Czech. \
 * **cs.lucene**: Lucene analyzer for Czech. \
 * **da.microsoft**: Microsoft analyzer for Danish. \
 * **da.lucene**: Lucene analyzer for Danish. \
 * **nl.microsoft**: Microsoft analyzer for Dutch. \
 * **nl.lucene**: Lucene analyzer for Dutch. \
 * **en.microsoft**: Microsoft analyzer for English. \
 * **en.lucene**: Lucene analyzer for English. \
 * **et.microsoft**: Microsoft analyzer for Estonian. \
 * **fi.microsoft**: Microsoft analyzer for Finnish. \
 * **fi.lucene**: Lucene analyzer for Finnish. \
 * **fr.microsoft**: Microsoft analyzer for French. \
 * **fr.lucene**: Lucene analyzer for French. \
 * **gl.lucene**: Lucene analyzer for Galician. \
 * **de.microsoft**: Microsoft analyzer for German. \
 * **de.lucene**: Lucene analyzer for German. \
 * **el.microsoft**: Microsoft analyzer for Greek. \
 * **el.lucene**: Lucene analyzer for Greek. \
 * **gu.microsoft**: Microsoft analyzer for Gujarati. \
 * **he.microsoft**: Microsoft analyzer for Hebrew. \
 * **hi.microsoft**: Microsoft analyzer for Hindi. \
 * **hi.lucene**: Lucene analyzer for Hindi. \
 * **hu.microsoft**: Microsoft analyzer for Hungarian. \
 * **hu.lucene**: Lucene analyzer for Hungarian. \
 * **is.microsoft**: Microsoft analyzer for Icelandic. \
 * **id.microsoft**: Microsoft analyzer for Indonesian (Bahasa). \
 * **id.lucene**: Lucene analyzer for Indonesian. \
 * **ga.lucene**: Lucene analyzer for Irish. \
 * **it.microsoft**: Microsoft analyzer for Italian. \
 * **it.lucene**: Lucene analyzer for Italian. \
 * **ja.microsoft**: Microsoft analyzer for Japanese. \
 * **ja.lucene**: Lucene analyzer for Japanese. \
 * **kn.microsoft**: Microsoft analyzer for Kannada. \
 * **ko.microsoft**: Microsoft analyzer for Korean. \
 * **ko.lucene**: Lucene analyzer for Korean. \
 * **lv.microsoft**: Microsoft analyzer for Latvian. \
 * **lv.lucene**: Lucene analyzer for Latvian. \
 * **lt.microsoft**: Microsoft analyzer for Lithuanian. \
 * **ml.microsoft**: Microsoft analyzer for Malayalam. \
 * **ms.microsoft**: Microsoft analyzer for Malay (Latin). \
 * **mr.microsoft**: Microsoft analyzer for Marathi. \
 * **nb.microsoft**: Microsoft analyzer for Norwegian (Bokmål). \
 * **no.lucene**: Lucene analyzer for Norwegian. \
 * **fa.lucene**: Lucene analyzer for Persian. \
 * **pl.microsoft**: Microsoft analyzer for Polish. \
 * **pl.lucene**: Lucene analyzer for Polish. \
 * **pt-BR.microsoft**: Microsoft analyzer for Portuguese (Brazil). \
 * **pt-BR.lucene**: Lucene analyzer for Portuguese (Brazil). \
 * **pt-PT.microsoft**: Microsoft analyzer for Portuguese (Portugal). \
 * **pt-PT.lucene**: Lucene analyzer for Portuguese (Portugal). \
 * **pa.microsoft**: Microsoft analyzer for Punjabi. \
 * **ro.microsoft**: Microsoft analyzer for Romanian. \
 * **ro.lucene**: Lucene analyzer for Romanian. \
 * **ru.microsoft**: Microsoft analyzer for Russian. \
 * **ru.lucene**: Lucene analyzer for Russian. \
 * **sr-cyrillic.microsoft**: Microsoft analyzer for Serbian (Cyrillic). \
 * **sr-latin.microsoft**: Microsoft analyzer for Serbian (Latin). \
 * **sk.microsoft**: Microsoft analyzer for Slovak. \
 * **sl.microsoft**: Microsoft analyzer for Slovenian. \
 * **es.microsoft**: Microsoft analyzer for Spanish. \
 * **es.lucene**: Lucene analyzer for Spanish. \
 * **sv.microsoft**: Microsoft analyzer for Swedish. \
 * **sv.lucene**: Lucene analyzer for Swedish. \
 * **ta.microsoft**: Microsoft analyzer for Tamil. \
 * **te.microsoft**: Microsoft analyzer for Telugu. \
 * **th.microsoft**: Microsoft analyzer for Thai. \
 * **th.lucene**: Lucene analyzer for Thai. \
 * **tr.microsoft**: Microsoft analyzer for Turkish. \
 * **tr.lucene**: Lucene analyzer for Turkish. \
 * **uk.microsoft**: Microsoft analyzer for Ukrainian. \
 * **ur.microsoft**: Microsoft analyzer for Urdu. \
 * **vi.microsoft**: Microsoft analyzer for Vietnamese. \
 * **standard.lucene**: Standard Lucene analyzer. \
 * **standardasciifolding.lucene**: Standard ASCII Folding Lucene analyzer. See https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#Analyzers \
 * **keyword**: Treats the entire content of a field as a single token. This is useful for data like zip codes, ids, and some product names. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordAnalyzer.html \
 * **pattern**: Flexibly separates text into terms via a regular expression pattern. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/PatternAnalyzer.html \
 * **simple**: Divides text at non-letters and converts them to lower case. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/SimpleAnalyzer.html \
 * **stop**: Divides text at non-letters; Applies the lowercase and stopword token filters. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopAnalyzer.html \
 * **whitespace**: An analyzer that uses the whitespace tokenizer. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceAnalyzer.html
 */
export type LexicalAnalyzerName = string;

/** Known values of {@link KeyPhraseExtractionSkillLanguage} that the service accepts. */
export const enum KnownKeyPhraseExtractionSkillLanguage {
  /** Danish */
  Da = "da",
  /** Dutch */
  Nl = "nl",
  /** English */
  En = "en",
  /** Finnish */
  Fi = "fi",
  /** French */
  Fr = "fr",
  /** German */
  De = "de",
  /** Italian */
  It = "it",
  /** Japanese */
  Ja = "ja",
  /** Korean */
  Ko = "ko",
  /** Norwegian (Bokmaal) */
  No = "no",
  /** Polish */
  Pl = "pl",
  /** Portuguese (Portugal) */
  PtPT = "pt-PT",
  /** Portuguese (Brazil) */
  PtBR = "pt-BR",
  /** Russian */
  Ru = "ru",
  /** Spanish */
  Es = "es",
  /** Swedish */
  Sv = "sv"
}

/**
 * Defines values for KeyPhraseExtractionSkillLanguage. \
 * {@link KnownKeyPhraseExtractionSkillLanguage} can be used interchangeably with KeyPhraseExtractionSkillLanguage,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **da**: Danish \
 * **nl**: Dutch \
 * **en**: English \
 * **fi**: Finnish \
 * **fr**: French \
 * **de**: German \
 * **it**: Italian \
 * **ja**: Japanese \
 * **ko**: Korean \
 * **no**: Norwegian (Bokmaal) \
 * **pl**: Polish \
 * **pt-PT**: Portuguese (Portugal) \
 * **pt-BR**: Portuguese (Brazil) \
 * **ru**: Russian \
 * **es**: Spanish \
 * **sv**: Swedish
 */
export type KeyPhraseExtractionSkillLanguage = string;

/** Known values of {@link OcrSkillLanguage} that the service accepts. */
export const enum KnownOcrSkillLanguage {
  /** Chinese-Simplified */
  ZhHans = "zh-Hans",
  /** Chinese-Traditional */
  ZhHant = "zh-Hant",
  /** Czech */
  Cs = "cs",
  /** Danish */
  Da = "da",
  /** Dutch */
  Nl = "nl",
  /** English */
  En = "en",
  /** Finnish */
  Fi = "fi",
  /** French */
  Fr = "fr",
  /** German */
  De = "de",
  /** Greek */
  El = "el",
  /** Hungarian */
  Hu = "hu",
  /** Italian */
  It = "it",
  /** Japanese */
  Ja = "ja",
  /** Korean */
  Ko = "ko",
  /** Norwegian (Bokmaal) */
  Nb = "nb",
  /** Polish */
  Pl = "pl",
  /** Portuguese */
  Pt = "pt",
  /** Russian */
  Ru = "ru",
  /** Spanish */
  Es = "es",
  /** Swedish */
  Sv = "sv",
  /** Turkish */
  Tr = "tr",
  /** Arabic */
  Ar = "ar",
  /** Romanian */
  Ro = "ro",
  /** Serbian (Cyrillic, Serbia) */
  SrCyrl = "sr-Cyrl",
  /** Serbian (Latin, Serbia) */
  SrLatn = "sr-Latn",
  /** Slovak */
  Sk = "sk"
}

/**
 * Defines values for OcrSkillLanguage. \
 * {@link KnownOcrSkillLanguage} can be used interchangeably with OcrSkillLanguage,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **zh-Hans**: Chinese-Simplified \
 * **zh-Hant**: Chinese-Traditional \
 * **cs**: Czech \
 * **da**: Danish \
 * **nl**: Dutch \
 * **en**: English \
 * **fi**: Finnish \
 * **fr**: French \
 * **de**: German \
 * **el**: Greek \
 * **hu**: Hungarian \
 * **it**: Italian \
 * **ja**: Japanese \
 * **ko**: Korean \
 * **nb**: Norwegian (Bokmaal) \
 * **pl**: Polish \
 * **pt**: Portuguese \
 * **ru**: Russian \
 * **es**: Spanish \
 * **sv**: Swedish \
 * **tr**: Turkish \
 * **ar**: Arabic \
 * **ro**: Romanian \
 * **sr-Cyrl**: Serbian (Cyrillic, Serbia) \
 * **sr-Latn**: Serbian (Latin, Serbia) \
 * **sk**: Slovak
 */
export type OcrSkillLanguage = string;

/** Known values of {@link ImageAnalysisSkillLanguage} that the service accepts. */
export const enum KnownImageAnalysisSkillLanguage {
  /** English */
  En = "en",
  /** Spanish */
  Es = "es",
  /** Japanese */
  Ja = "ja",
  /** Portuguese */
  Pt = "pt",
  /** Chinese */
  Zh = "zh"
}

/**
 * Defines values for ImageAnalysisSkillLanguage. \
 * {@link KnownImageAnalysisSkillLanguage} can be used interchangeably with ImageAnalysisSkillLanguage,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **en**: English \
 * **es**: Spanish \
 * **ja**: Japanese \
 * **pt**: Portuguese \
 * **zh**: Chinese
 */
export type ImageAnalysisSkillLanguage = string;

/** Known values of {@link VisualFeature} that the service accepts. */
export const enum KnownVisualFeature {
  /** Visual features recognized as adult persons. */
  Adult = "adult",
  /** Visual features recognized as commercial brands. */
  Brands = "brands",
  /** Categories. */
  Categories = "categories",
  /** Description. */
  Description = "description",
  /** Visual features recognized as people faces. */
  Faces = "faces",
  /** Visual features recognized as objects. */
  Objects = "objects",
  /** Tags. */
  Tags = "tags"
}

/**
 * Defines values for VisualFeature. \
 * {@link KnownVisualFeature} can be used interchangeably with VisualFeature,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **adult**: Visual features recognized as adult persons. \
 * **brands**: Visual features recognized as commercial brands. \
 * **categories**: Categories. \
 * **description**: Description. \
 * **faces**: Visual features recognized as people faces. \
 * **objects**: Visual features recognized as objects. \
 * **tags**: Tags.
 */
export type VisualFeature = string;

/** Known values of {@link ImageDetail} that the service accepts. */
export const enum KnownImageDetail {
  /** Details recognized as celebrities. */
  Celebrities = "celebrities",
  /** Details recognized as landmarks. */
  Landmarks = "landmarks"
}

/**
 * Defines values for ImageDetail. \
 * {@link KnownImageDetail} can be used interchangeably with ImageDetail,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **celebrities**: Details recognized as celebrities. \
 * **landmarks**: Details recognized as landmarks.
 */
export type ImageDetail = string;

/** Known values of {@link EntityCategory} that the service accepts. */
export const enum KnownEntityCategory {
  /** Entities describing a physical location. */
  Location = "location",
  /** Entities describing an organization. */
  Organization = "organization",
  /** Entities describing a person. */
  Person = "person",
  /** Entities describing a quantity. */
  Quantity = "quantity",
  /** Entities describing a date and time. */
  Datetime = "datetime",
  /** Entities describing a URL. */
  Url = "url",
  /** Entities describing an email address. */
  Email = "email"
}

/**
 * Defines values for EntityCategory. \
 * {@link KnownEntityCategory} can be used interchangeably with EntityCategory,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **location**: Entities describing a physical location. \
 * **organization**: Entities describing an organization. \
 * **person**: Entities describing a person. \
 * **quantity**: Entities describing a quantity. \
 * **datetime**: Entities describing a date and time. \
 * **url**: Entities describing a URL. \
 * **email**: Entities describing an email address.
 */
export type EntityCategory = string;

/** Known values of {@link EntityRecognitionSkillLanguage} that the service accepts. */
export const enum KnownEntityRecognitionSkillLanguage {
  /** Arabic */
  Ar = "ar",
  /** Czech */
  Cs = "cs",
  /** Chinese-Simplified */
  ZhHans = "zh-Hans",
  /** Chinese-Traditional */
  ZhHant = "zh-Hant",
  /** Danish */
  Da = "da",
  /** Dutch */
  Nl = "nl",
  /** English */
  En = "en",
  /** Finnish */
  Fi = "fi",
  /** French */
  Fr = "fr",
  /** German */
  De = "de",
  /** Greek */
  El = "el",
  /** Hungarian */
  Hu = "hu",
  /** Italian */
  It = "it",
  /** Japanese */
  Ja = "ja",
  /** Korean */
  Ko = "ko",
  /** Norwegian (Bokmaal) */
  No = "no",
  /** Polish */
  Pl = "pl",
  /** Portuguese (Portugal) */
  PtPT = "pt-PT",
  /** Portuguese (Brazil) */
  PtBR = "pt-BR",
  /** Russian */
  Ru = "ru",
  /** Spanish */
  Es = "es",
  /** Swedish */
  Sv = "sv",
  /** Turkish */
  Tr = "tr"
}

/**
 * Defines values for EntityRecognitionSkillLanguage. \
 * {@link KnownEntityRecognitionSkillLanguage} can be used interchangeably with EntityRecognitionSkillLanguage,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **ar**: Arabic \
 * **cs**: Czech \
 * **zh-Hans**: Chinese-Simplified \
 * **zh-Hant**: Chinese-Traditional \
 * **da**: Danish \
 * **nl**: Dutch \
 * **en**: English \
 * **fi**: Finnish \
 * **fr**: French \
 * **de**: German \
 * **el**: Greek \
 * **hu**: Hungarian \
 * **it**: Italian \
 * **ja**: Japanese \
 * **ko**: Korean \
 * **no**: Norwegian (Bokmaal) \
 * **pl**: Polish \
 * **pt-PT**: Portuguese (Portugal) \
 * **pt-BR**: Portuguese (Brazil) \
 * **ru**: Russian \
 * **es**: Spanish \
 * **sv**: Swedish \
 * **tr**: Turkish
 */
export type EntityRecognitionSkillLanguage = string;

/** Known values of {@link SentimentSkillLanguage} that the service accepts. */
export const enum KnownSentimentSkillLanguage {
  /** Danish */
  Da = "da",
  /** Dutch */
  Nl = "nl",
  /** English */
  En = "en",
  /** Finnish */
  Fi = "fi",
  /** French */
  Fr = "fr",
  /** German */
  De = "de",
  /** Greek */
  El = "el",
  /** Italian */
  It = "it",
  /** Norwegian (Bokmaal) */
  No = "no",
  /** Polish */
  Pl = "pl",
  /** Portuguese (Portugal) */
  PtPT = "pt-PT",
  /** Russian */
  Ru = "ru",
  /** Spanish */
  Es = "es",
  /** Swedish */
  Sv = "sv",
  /** Turkish */
  Tr = "tr"
}

/**
 * Defines values for SentimentSkillLanguage. \
 * {@link KnownSentimentSkillLanguage} can be used interchangeably with SentimentSkillLanguage,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **da**: Danish \
 * **nl**: Dutch \
 * **en**: English \
 * **fi**: Finnish \
 * **fr**: French \
 * **de**: German \
 * **el**: Greek \
 * **it**: Italian \
 * **no**: Norwegian (Bokmaal) \
 * **pl**: Polish \
 * **pt-PT**: Portuguese (Portugal) \
 * **ru**: Russian \
 * **es**: Spanish \
 * **sv**: Swedish \
 * **tr**: Turkish
 */
export type SentimentSkillLanguage = string;

/** Known values of {@link SplitSkillLanguage} that the service accepts. */
export const enum KnownSplitSkillLanguage {
  /** Danish */
  Da = "da",
  /** German */
  De = "de",
  /** English */
  En = "en",
  /** Spanish */
  Es = "es",
  /** Finnish */
  Fi = "fi",
  /** French */
  Fr = "fr",
  /** Italian */
  It = "it",
  /** Korean */
  Ko = "ko",
  /** Portuguese */
  Pt = "pt"
}

/**
 * Defines values for SplitSkillLanguage. \
 * {@link KnownSplitSkillLanguage} can be used interchangeably with SplitSkillLanguage,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **da**: Danish \
 * **de**: German \
 * **en**: English \
 * **es**: Spanish \
 * **fi**: Finnish \
 * **fr**: French \
 * **it**: Italian \
 * **ko**: Korean \
 * **pt**: Portuguese
 */
export type SplitSkillLanguage = string;

/** Known values of {@link TextSplitMode} that the service accepts. */
export const enum KnownTextSplitMode {
  /** Split the text into individual pages. */
  Pages = "pages",
  /** Split the text into individual sentences. */
  Sentences = "sentences"
}

/**
 * Defines values for TextSplitMode. \
 * {@link KnownTextSplitMode} can be used interchangeably with TextSplitMode,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **pages**: Split the text into individual pages. \
 * **sentences**: Split the text into individual sentences.
 */
export type TextSplitMode = string;

/** Known values of {@link CustomEntityLookupSkillLanguage} that the service accepts. */
export const enum KnownCustomEntityLookupSkillLanguage {
  /** Danish */
  Da = "da",
  /** German */
  De = "de",
  /** English */
  En = "en",
  /** Spanish */
  Es = "es",
  /** Finnish */
  Fi = "fi",
  /** French */
  Fr = "fr",
  /** Italian */
  It = "it",
  /** Korean */
  Ko = "ko",
  /** Portuguese */
  Pt = "pt"
}

/**
 * Defines values for CustomEntityLookupSkillLanguage. \
 * {@link KnownCustomEntityLookupSkillLanguage} can be used interchangeably with CustomEntityLookupSkillLanguage,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **da**: Danish \
 * **de**: German \
 * **en**: English \
 * **es**: Spanish \
 * **fi**: Finnish \
 * **fr**: French \
 * **it**: Italian \
 * **ko**: Korean \
 * **pt**: Portuguese
 */
export type CustomEntityLookupSkillLanguage = string;

/** Known values of {@link TextTranslationSkillLanguage} that the service accepts. */
export const enum KnownTextTranslationSkillLanguage {
  /** Afrikaans */
  Af = "af",
  /** Arabic */
  Ar = "ar",
  /** Bangla */
  Bn = "bn",
  /** Bosnian (Latin) */
  Bs = "bs",
  /** Bulgarian */
  Bg = "bg",
  /** Cantonese (Traditional) */
  Yue = "yue",
  /** Catalan */
  Ca = "ca",
  /** Chinese Simplified */
  ZhHans = "zh-Hans",
  /** Chinese Traditional */
  ZhHant = "zh-Hant",
  /** Croatian */
  Hr = "hr",
  /** Czech */
  Cs = "cs",
  /** Danish */
  Da = "da",
  /** Dutch */
  Nl = "nl",
  /** English */
  En = "en",
  /** Estonian */
  Et = "et",
  /** Fijian */
  Fj = "fj",
  /** Filipino */
  Fil = "fil",
  /** Finnish */
  Fi = "fi",
  /** French */
  Fr = "fr",
  /** German */
  De = "de",
  /** Greek */
  El = "el",
  /** Haitian Creole */
  Ht = "ht",
  /** Hebrew */
  He = "he",
  /** Hindi */
  Hi = "hi",
  /** Hmong Daw */
  Mww = "mww",
  /** Hungarian */
  Hu = "hu",
  /** Icelandic */
  Is = "is",
  /** Indonesian */
  Id = "id",
  /** Italian */
  It = "it",
  /** Japanese */
  Ja = "ja",
  /** Kiswahili */
  Sw = "sw",
  /** Klingon */
  Tlh = "tlh",
  /** Korean */
  Ko = "ko",
  /** Latvian */
  Lv = "lv",
  /** Lithuanian */
  Lt = "lt",
  /** Malagasy */
  Mg = "mg",
  /** Malay */
  Ms = "ms",
  /** Maltese */
  Mt = "mt",
  /** Norwegian */
  Nb = "nb",
  /** Persian */
  Fa = "fa",
  /** Polish */
  Pl = "pl",
  /** Portuguese */
  Pt = "pt",
  /** Queretaro Otomi */
  Otq = "otq",
  /** Romanian */
  Ro = "ro",
  /** Russian */
  Ru = "ru",
  /** Samoan */
  Sm = "sm",
  /** Serbian (Cyrillic) */
  SrCyrl = "sr-Cyrl",
  /** Serbian (Latin) */
  SrLatn = "sr-Latn",
  /** Slovak */
  Sk = "sk",
  /** Slovenian */
  Sl = "sl",
  /** Spanish */
  Es = "es",
  /** Swedish */
  Sv = "sv",
  /** Tahitian */
  Ty = "ty",
  /** Tamil */
  Ta = "ta",
  /** Telugu */
  Te = "te",
  /** Thai */
  Th = "th",
  /** Tongan */
  To = "to",
  /** Turkish */
  Tr = "tr",
  /** Ukrainian */
  Uk = "uk",
  /** Urdu */
  Ur = "ur",
  /** Vietnamese */
  Vi = "vi",
  /** Welsh */
  Cy = "cy",
  /** Yucatec Maya */
  Yua = "yua"
}

/**
 * Defines values for TextTranslationSkillLanguage. \
 * {@link KnownTextTranslationSkillLanguage} can be used interchangeably with TextTranslationSkillLanguage,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **af**: Afrikaans \
 * **ar**: Arabic \
 * **bn**: Bangla \
 * **bs**: Bosnian (Latin) \
 * **bg**: Bulgarian \
 * **yue**: Cantonese (Traditional) \
 * **ca**: Catalan \
 * **zh-Hans**: Chinese Simplified \
 * **zh-Hant**: Chinese Traditional \
 * **hr**: Croatian \
 * **cs**: Czech \
 * **da**: Danish \
 * **nl**: Dutch \
 * **en**: English \
 * **et**: Estonian \
 * **fj**: Fijian \
 * **fil**: Filipino \
 * **fi**: Finnish \
 * **fr**: French \
 * **de**: German \
 * **el**: Greek \
 * **ht**: Haitian Creole \
 * **he**: Hebrew \
 * **hi**: Hindi \
 * **mww**: Hmong Daw \
 * **hu**: Hungarian \
 * **is**: Icelandic \
 * **id**: Indonesian \
 * **it**: Italian \
 * **ja**: Japanese \
 * **sw**: Kiswahili \
 * **tlh**: Klingon \
 * **ko**: Korean \
 * **lv**: Latvian \
 * **lt**: Lithuanian \
 * **mg**: Malagasy \
 * **ms**: Malay \
 * **mt**: Maltese \
 * **nb**: Norwegian \
 * **fa**: Persian \
 * **pl**: Polish \
 * **pt**: Portuguese \
 * **otq**: Queretaro Otomi \
 * **ro**: Romanian \
 * **ru**: Russian \
 * **sm**: Samoan \
 * **sr-Cyrl**: Serbian (Cyrillic) \
 * **sr-Latn**: Serbian (Latin) \
 * **sk**: Slovak \
 * **sl**: Slovenian \
 * **es**: Spanish \
 * **sv**: Swedish \
 * **ty**: Tahitian \
 * **ta**: Tamil \
 * **te**: Telugu \
 * **th**: Thai \
 * **to**: Tongan \
 * **tr**: Turkish \
 * **uk**: Ukrainian \
 * **ur**: Urdu \
 * **vi**: Vietnamese \
 * **cy**: Welsh \
 * **yua**: Yucatec Maya
 */
export type TextTranslationSkillLanguage = string;

/** Known values of {@link LexicalTokenizerName} that the service accepts. */
export const enum KnownLexicalTokenizerName {
  /** Grammar-based tokenizer that is suitable for processing most European-language documents. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicTokenizer.html */
  Classic = "classic",
  /** Tokenizes the input from an edge into n-grams of the given size(s). See https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.html */
  EdgeNGram = "edgeNGram",
  /** Emits the entire input as a single token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordTokenizer.html */
  Keyword = "keyword_v2",
  /** Divides text at non-letters. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LetterTokenizer.html */
  Letter = "letter",
  /** Divides text at non-letters and converts them to lower case. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseTokenizer.html */
  Lowercase = "lowercase",
  /** Divides text using language-specific rules. */
  MicrosoftLanguageTokenizer = "microsoft_language_tokenizer",
  /** Divides text using language-specific rules and reduces words to their base forms. */
  MicrosoftLanguageStemmingTokenizer = "microsoft_language_stemming_tokenizer",
  /** Tokenizes the input into n-grams of the given size(s). See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenizer.html */
  NGram = "nGram",
  /** Tokenizer for path-like hierarchies. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/path/PathHierarchyTokenizer.html */
  PathHierarchy = "path_hierarchy_v2",
  /** Tokenizer that uses regex pattern matching to construct distinct tokens. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/pattern/PatternTokenizer.html */
  Pattern = "pattern",
  /** Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop filter. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/StandardTokenizer.html */
  Standard = "standard_v2",
  /** Tokenizes urls and emails as one token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizer.html */
  UaxUrlEmail = "uax_url_email",
  /** Divides text at whitespace. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceTokenizer.html */
  Whitespace = "whitespace"
}

/**
 * Defines values for LexicalTokenizerName. \
 * {@link KnownLexicalTokenizerName} can be used interchangeably with LexicalTokenizerName,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **classic**: Grammar-based tokenizer that is suitable for processing most European-language documents. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicTokenizer.html \
 * **edgeNGram**: Tokenizes the input from an edge into n-grams of the given size(s). See https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenizer.html \
 * **keyword_v2**: Emits the entire input as a single token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/KeywordTokenizer.html \
 * **letter**: Divides text at non-letters. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LetterTokenizer.html \
 * **lowercase**: Divides text at non-letters and converts them to lower case. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseTokenizer.html \
 * **microsoft_language_tokenizer**: Divides text using language-specific rules. \
 * **microsoft_language_stemming_tokenizer**: Divides text using language-specific rules and reduces words to their base forms. \
 * **nGram**: Tokenizes the input into n-grams of the given size(s). See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenizer.html \
 * **path_hierarchy_v2**: Tokenizer for path-like hierarchies. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/path/PathHierarchyTokenizer.html \
 * **pattern**: Tokenizer that uses regex pattern matching to construct distinct tokens. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/pattern/PatternTokenizer.html \
 * **standard_v2**: Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop filter. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/StandardTokenizer.html \
 * **uax_url_email**: Tokenizes urls and emails as one token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/UAX29URLEmailTokenizer.html \
 * **whitespace**: Divides text at whitespace. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/WhitespaceTokenizer.html
 */
export type LexicalTokenizerName = string;

/** Known values of {@link TokenFilterName} that the service accepts. */
export const enum KnownTokenFilterName {
  /** A token filter that applies the Arabic normalizer to normalize the orthography. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ar/ArabicNormalizationFilter.html */
  ArabicNormalization = "arabic_normalization",
  /** Strips all characters after an apostrophe (including the apostrophe itself). See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/tr/ApostropheFilter.html */
  Apostrophe = "apostrophe",
  /** Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127 ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such equivalents exist. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html */
  AsciiFolding = "asciifolding",
  /** Forms bigrams of CJK terms that are generated from the standard tokenizer. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKBigramFilter.html */
  CjkBigram = "cjk_bigram",
  /** Normalizes CJK width differences. Folds fullwidth ASCII variants into the equivalent basic Latin, and half-width Katakana variants into the equivalent Kana. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKWidthFilter.html */
  CjkWidth = "cjk_width",
  /** Removes English possessives, and dots from acronyms. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicFilter.html */
  Classic = "classic",
  /** Construct bigrams for frequently occurring terms while indexing. Single terms are still indexed too, with bigrams overlaid. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/commongrams/CommonGramsFilter.html */
  CommonGram = "common_grams",
  /** Generates n-grams of the given size(s) starting from the front or the back of an input token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.html */
  EdgeNGram = "edgeNGram_v2",
  /** Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/util/ElisionFilter.html */
  Elision = "elision",
  /** Normalizes German characters according to the heuristics of the German2 snowball algorithm. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/de/GermanNormalizationFilter.html */
  GermanNormalization = "german_normalization",
  /** Normalizes text in Hindi to remove some differences in spelling variations. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/hi/HindiNormalizationFilter.html */
  HindiNormalization = "hindi_normalization",
  /** Normalizes the Unicode representation of text in Indian languages. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/in/IndicNormalizationFilter.html */
  IndicNormalization = "indic_normalization",
  /** Emits each incoming token twice, once as keyword and once as non-keyword. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/KeywordRepeatFilter.html */
  KeywordRepeat = "keyword_repeat",
  /** A high-performance kstem filter for English. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/en/KStemFilter.html */
  KStem = "kstem",
  /** Removes words that are too long or too short. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LengthFilter.html */
  Length = "length",
  /** Limits the number of tokens while indexing. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LimitTokenCountFilter.html */
  Limit = "limit",
  /** Normalizes token text to lower case. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseFilter.htm */
  Lowercase = "lowercase",
  /** Generates n-grams of the given size(s). See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenFilter.html */
  NGram = "nGram_v2",
  /** Applies normalization for Persian. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/fa/PersianNormalizationFilter.html */
  PersianNormalization = "persian_normalization",
  /** Create tokens for phonetic matches. See https://lucene.apache.org/core/4_10_3/analyzers-phonetic/org/apache/lucene/analysis/phonetic/package-tree.html */
  Phonetic = "phonetic",
  /** Uses the Porter stemming algorithm to transform the token stream. See http://tartarus.org/~martin/PorterStemmer */
  PorterStem = "porter_stem",
  /** Reverses the token string. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/reverse/ReverseStringFilter.html */
  Reverse = "reverse",
  /** Normalizes use of the interchangeable Scandinavian characters. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianNormalizationFilter.html */
  ScandinavianNormalization = "scandinavian_normalization",
  /** Folds Scandinavian characters åÅäæÄÆ-&gt;a and öÖøØ-&gt;o. It also discriminates against use of double vowels aa, ae, ao, oe and oo, leaving just the first one. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianFoldingFilter.html */
  ScandinavianFoldingNormalization = "scandinavian_folding",
  /** Creates combinations of tokens as a single token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/shingle/ShingleFilter.html */
  Shingle = "shingle",
  /** A filter that stems words using a Snowball-generated stemmer. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/snowball/SnowballFilter.html */
  Snowball = "snowball",
  /** Normalizes the Unicode representation of Sorani text. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ckb/SoraniNormalizationFilter.html */
  SoraniNormalization = "sorani_normalization",
  /** Language specific stemming filter. See https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#TokenFilters */
  Stemmer = "stemmer",
  /** Removes stop words from a token stream. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopFilter.html */
  Stopwords = "stopwords",
  /** Trims leading and trailing whitespace from tokens. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TrimFilter.html */
  Trim = "trim",
  /** Truncates the terms to a specific length. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TruncateTokenFilter.html */
  Truncate = "truncate",
  /** Filters out tokens with same text as the previous token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/RemoveDuplicatesTokenFilter.html */
  Unique = "unique",
  /** Normalizes token text to upper case. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/UpperCaseFilter.html */
  Uppercase = "uppercase",
  /** Splits words into subwords and performs optional transformations on subword groups. */
  WordDelimiter = "word_delimiter"
}

/**
 * Defines values for TokenFilterName. \
 * {@link KnownTokenFilterName} can be used interchangeably with TokenFilterName,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **arabic_normalization**: A token filter that applies the Arabic normalizer to normalize the orthography. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ar/ArabicNormalizationFilter.html \
 * **apostrophe**: Strips all characters after an apostrophe (including the apostrophe itself). See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/tr/ApostropheFilter.html \
 * **asciifolding**: Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127 ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such equivalents exist. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.html \
 * **cjk_bigram**: Forms bigrams of CJK terms that are generated from the standard tokenizer. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKBigramFilter.html \
 * **cjk_width**: Normalizes CJK width differences. Folds fullwidth ASCII variants into the equivalent basic Latin, and half-width Katakana variants into the equivalent Kana. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/cjk/CJKWidthFilter.html \
 * **classic**: Removes English possessives, and dots from acronyms. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/standard/ClassicFilter.html \
 * **common_grams**: Construct bigrams for frequently occurring terms while indexing. Single terms are still indexed too, with bigrams overlaid. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/commongrams/CommonGramsFilter.html \
 * **edgeNGram_v2**: Generates n-grams of the given size(s) starting from the front or the back of an input token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/EdgeNGramTokenFilter.html \
 * **elision**: Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/util/ElisionFilter.html \
 * **german_normalization**: Normalizes German characters according to the heuristics of the German2 snowball algorithm. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/de/GermanNormalizationFilter.html \
 * **hindi_normalization**: Normalizes text in Hindi to remove some differences in spelling variations. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/hi/HindiNormalizationFilter.html \
 * **indic_normalization**: Normalizes the Unicode representation of text in Indian languages. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/in/IndicNormalizationFilter.html \
 * **keyword_repeat**: Emits each incoming token twice, once as keyword and once as non-keyword. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/KeywordRepeatFilter.html \
 * **kstem**: A high-performance kstem filter for English. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/en/KStemFilter.html \
 * **length**: Removes words that are too long or too short. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LengthFilter.html \
 * **limit**: Limits the number of tokens while indexing. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/LimitTokenCountFilter.html \
 * **lowercase**: Normalizes token text to lower case. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/LowerCaseFilter.htm \
 * **nGram_v2**: Generates n-grams of the given size(s). See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ngram/NGramTokenFilter.html \
 * **persian_normalization**: Applies normalization for Persian. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/fa/PersianNormalizationFilter.html \
 * **phonetic**: Create tokens for phonetic matches. See https://lucene.apache.org/core/4_10_3/analyzers-phonetic/org/apache/lucene/analysis/phonetic/package-tree.html \
 * **porter_stem**: Uses the Porter stemming algorithm to transform the token stream. See http://tartarus.org/~martin/PorterStemmer \
 * **reverse**: Reverses the token string. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/reverse/ReverseStringFilter.html \
 * **scandinavian_normalization**: Normalizes use of the interchangeable Scandinavian characters. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianNormalizationFilter.html \
 * **scandinavian_folding**: Folds Scandinavian characters åÅäæÄÆ-&gt;a and öÖøØ-&gt;o. It also discriminates against use of double vowels aa, ae, ao, oe and oo, leaving just the first one. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/ScandinavianFoldingFilter.html \
 * **shingle**: Creates combinations of tokens as a single token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/shingle/ShingleFilter.html \
 * **snowball**: A filter that stems words using a Snowball-generated stemmer. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/snowball/SnowballFilter.html \
 * **sorani_normalization**: Normalizes the Unicode representation of Sorani text. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/ckb/SoraniNormalizationFilter.html \
 * **stemmer**: Language specific stemming filter. See https://docs.microsoft.com/rest/api/searchservice/Custom-analyzers-in-Azure-Search#TokenFilters \
 * **stopwords**: Removes stop words from a token stream. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/StopFilter.html \
 * **trim**: Trims leading and trailing whitespace from tokens. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TrimFilter.html \
 * **truncate**: Truncates the terms to a specific length. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/TruncateTokenFilter.html \
 * **unique**: Filters out tokens with same text as the previous token. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/miscellaneous/RemoveDuplicatesTokenFilter.html \
 * **uppercase**: Normalizes token text to upper case. See http://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/core/UpperCaseFilter.html \
 * **word_delimiter**: Splits words into subwords and performs optional transformations on subword groups.
 */
export type TokenFilterName = string;

/** Known values of {@link CharFilterName} that the service accepts. */
export const enum KnownCharFilterName {
  /** A character filter that attempts to strip out HTML constructs. See https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.html */
  HtmlStrip = "html_strip"
}

/**
 * Defines values for CharFilterName. \
 * {@link KnownCharFilterName} can be used interchangeably with CharFilterName,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **html_strip**: A character filter that attempts to strip out HTML constructs. See https://lucene.apache.org/core/4_10_3/analyzers-common/org/apache/lucene/analysis/charfilter/HTMLStripCharFilter.html
 */
export type CharFilterName = string;

/** Known values of {@link RegexFlags} that the service accepts. */
export const enum KnownRegexFlags {
  /** Enables canonical equivalence. */
  CanonEq = "CANON_EQ",
  /** Enables case-insensitive matching. */
  CaseInsensitive = "CASE_INSENSITIVE",
  /** Permits whitespace and comments in the pattern. */
  Comments = "COMMENTS",
  /** Enables dotall mode. */
  DotAll = "DOTALL",
  /** Enables literal parsing of the pattern. */
  Literal = "LITERAL",
  /** Enables multiline mode. */
  Multiline = "MULTILINE",
  /** Enables Unicode-aware case folding. */
  UnicodeCase = "UNICODE_CASE",
  /** Enables Unix lines mode. */
  UnixLines = "UNIX_LINES"
}

/**
 * Defines values for RegexFlags. \
 * {@link KnownRegexFlags} can be used interchangeably with RegexFlags,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **CANON_EQ**: Enables canonical equivalence. \
 * **CASE_INSENSITIVE**: Enables case-insensitive matching. \
 * **COMMENTS**: Permits whitespace and comments in the pattern. \
 * **DOTALL**: Enables dotall mode. \
 * **LITERAL**: Enables literal parsing of the pattern. \
 * **MULTILINE**: Enables multiline mode. \
 * **UNICODE_CASE**: Enables Unicode-aware case folding. \
 * **UNIX_LINES**: Enables Unix lines mode.
 */
export type RegexFlags = string;
/** Defines values for IndexerStatus. */
export type IndexerStatus = "unknown" | "error" | "running";
/** Defines values for IndexerExecutionStatus. */
export type IndexerExecutionStatus =
  | "transientFailure"
  | "success"
  | "inProgress"
  | "reset";
/** Defines values for ScoringFunctionInterpolation. */
export type ScoringFunctionInterpolation =
  | "linear"
  | "constant"
  | "quadratic"
  | "logarithmic";
/** Defines values for ScoringFunctionAggregation. */
export type ScoringFunctionAggregation =
  | "sum"
  | "average"
  | "minimum"
  | "maximum"
  | "firstMatching";
/** Defines values for TokenCharacterKind. */
export type TokenCharacterKind =
  | "letter"
  | "digit"
  | "whitespace"
  | "punctuation"
  | "symbol";
/** Defines values for MicrosoftTokenizerLanguage. */
export type MicrosoftTokenizerLanguage =
  | "bangla"
  | "bulgarian"
  | "catalan"
  | "chineseSimplified"
  | "chineseTraditional"
  | "croatian"
  | "czech"
  | "danish"
  | "dutch"
  | "english"
  | "french"
  | "german"
  | "greek"
  | "gujarati"
  | "hindi"
  | "icelandic"
  | "indonesian"
  | "italian"
  | "japanese"
  | "kannada"
  | "korean"
  | "malay"
  | "malayalam"
  | "marathi"
  | "norwegianBokmaal"
  | "polish"
  | "portuguese"
  | "portugueseBrazilian"
  | "punjabi"
  | "romanian"
  | "russian"
  | "serbianCyrillic"
  | "serbianLatin"
  | "slovenian"
  | "spanish"
  | "swedish"
  | "tamil"
  | "telugu"
  | "thai"
  | "ukrainian"
  | "urdu"
  | "vietnamese";
/** Defines values for MicrosoftStemmingTokenizerLanguage. */
export type MicrosoftStemmingTokenizerLanguage =
  | "arabic"
  | "bangla"
  | "bulgarian"
  | "catalan"
  | "croatian"
  | "czech"
  | "danish"
  | "dutch"
  | "english"
  | "estonian"
  | "finnish"
  | "french"
  | "german"
  | "greek"
  | "gujarati"
  | "hebrew"
  | "hindi"
  | "hungarian"
  | "icelandic"
  | "indonesian"
  | "italian"
  | "kannada"
  | "latvian"
  | "lithuanian"
  | "malay"
  | "malayalam"
  | "marathi"
  | "norwegianBokmaal"
  | "polish"
  | "portuguese"
  | "portugueseBrazilian"
  | "punjabi"
  | "romanian"
  | "russian"
  | "serbianCyrillic"
  | "serbianLatin"
  | "slovak"
  | "slovenian"
  | "spanish"
  | "swedish"
  | "tamil"
  | "telugu"
  | "turkish"
  | "ukrainian"
  | "urdu";
/** Defines values for CjkBigramTokenFilterScripts. */
export type CjkBigramTokenFilterScripts =
  | "han"
  | "hiragana"
  | "katakana"
  | "hangul";
/** Defines values for EdgeNGramTokenFilterSide. */
export type EdgeNGramTokenFilterSide = "front" | "back";
/** Defines values for PhoneticEncoder. */
export type PhoneticEncoder =
  | "metaphone"
  | "doubleMetaphone"
  | "soundex"
  | "refinedSoundex"
  | "caverphone1"
  | "caverphone2"
  | "cologne"
  | "nysiis"
  | "koelnerPhonetik"
  | "haasePhonetik"
  | "beiderMorse";
/** Defines values for SnowballTokenFilterLanguage. */
export type SnowballTokenFilterLanguage =
  | "armenian"
  | "basque"
  | "catalan"
  | "danish"
  | "dutch"
  | "english"
  | "finnish"
  | "french"
  | "german"
  | "german2"
  | "hungarian"
  | "italian"
  | "kp"
  | "lovins"
  | "norwegian"
  | "porter"
  | "portuguese"
  | "romanian"
  | "russian"
  | "spanish"
  | "swedish"
  | "turkish";
/** Defines values for StemmerTokenFilterLanguage. */
export type StemmerTokenFilterLanguage =
  | "arabic"
  | "armenian"
  | "basque"
  | "brazilian"
  | "bulgarian"
  | "catalan"
  | "czech"
  | "danish"
  | "dutch"
  | "dutchKp"
  | "english"
  | "lightEnglish"
  | "minimalEnglish"
  | "possessiveEnglish"
  | "porter2"
  | "lovins"
  | "finnish"
  | "lightFinnish"
  | "french"
  | "lightFrench"
  | "minimalFrench"
  | "galician"
  | "minimalGalician"
  | "german"
  | "german2"
  | "lightGerman"
  | "minimalGerman"
  | "greek"
  | "hindi"
  | "hungarian"
  | "lightHungarian"
  | "indonesian"
  | "irish"
  | "italian"
  | "lightItalian"
  | "sorani"
  | "latvian"
  | "norwegian"
  | "lightNorwegian"
  | "minimalNorwegian"
  | "lightNynorsk"
  | "minimalNynorsk"
  | "portuguese"
  | "lightPortuguese"
  | "minimalPortuguese"
  | "portugueseRslp"
  | "romanian"
  | "russian"
  | "lightRussian"
  | "spanish"
  | "lightSpanish"
  | "swedish"
  | "lightSwedish"
  | "turkish";
/** Defines values for StopwordsList. */
export type StopwordsList =
  | "arabic"
  | "armenian"
  | "basque"
  | "brazilian"
  | "bulgarian"
  | "catalan"
  | "czech"
  | "danish"
  | "dutch"
  | "english"
  | "finnish"
  | "french"
  | "galician"
  | "german"
  | "greek"
  | "hindi"
  | "hungarian"
  | "indonesian"
  | "irish"
  | "italian"
  | "latvian"
  | "norwegian"
  | "persian"
  | "portuguese"
  | "romanian"
  | "russian"
  | "sorani"
  | "spanish"
  | "swedish"
  | "thai"
  | "turkish";

/** Optional parameters. */
export interface DataSourcesCreateOrUpdateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type DataSourcesCreateOrUpdateResponse = SearchIndexerDataSource & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexerDataSource;
  };
};

/** Optional parameters. */
export interface DataSourcesDeleteOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Optional parameters. */
export interface DataSourcesGetOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the get operation. */
export type DataSourcesGetResponse = SearchIndexerDataSource & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexerDataSource;
  };
};

/** Optional parameters. */
export interface DataSourcesListOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Selects which top-level properties of the data sources to retrieve. Specified as a comma-separated list of JSON property names, or '*' for all properties. The default is all properties. */
  select?: string;
}

/** Contains response data for the list operation. */
export type DataSourcesListResponse = ListDataSourcesResult & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ListDataSourcesResult;
  };
};

/** Optional parameters. */
export interface DataSourcesCreateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the create operation. */
export type DataSourcesCreateResponse = SearchIndexerDataSource & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexerDataSource;
  };
};

/** Optional parameters. */
export interface IndexersResetOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Optional parameters. */
export interface IndexersRunOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Optional parameters. */
export interface IndexersCreateOrUpdateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type IndexersCreateOrUpdateResponse = SearchIndexer & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexer;
  };
};

/** Optional parameters. */
export interface IndexersDeleteOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Optional parameters. */
export interface IndexersGetOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the get operation. */
export type IndexersGetResponse = SearchIndexer & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexer;
  };
};

/** Optional parameters. */
export interface IndexersListOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Selects which top-level properties of the indexers to retrieve. Specified as a comma-separated list of JSON property names, or '*' for all properties. The default is all properties. */
  select?: string;
}

/** Contains response data for the list operation. */
export type IndexersListResponse = ListIndexersResult & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ListIndexersResult;
  };
};

/** Optional parameters. */
export interface IndexersCreateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the create operation. */
export type IndexersCreateResponse = SearchIndexer & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexer;
  };
};

/** Optional parameters. */
export interface IndexersGetStatusOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the getStatus operation. */
export type IndexersGetStatusResponse = SearchIndexerStatus & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexerStatus;
  };
};

/** Optional parameters. */
export interface SkillsetsCreateOrUpdateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type SkillsetsCreateOrUpdateResponse = SearchIndexerSkillset & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexerSkillset;
  };
};

/** Optional parameters. */
export interface SkillsetsDeleteOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Optional parameters. */
export interface SkillsetsGetOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the get operation. */
export type SkillsetsGetResponse = SearchIndexerSkillset & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexerSkillset;
  };
};

/** Optional parameters. */
export interface SkillsetsListOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Selects which top-level properties of the skillsets to retrieve. Specified as a comma-separated list of JSON property names, or '*' for all properties. The default is all properties. */
  select?: string;
}

/** Contains response data for the list operation. */
export type SkillsetsListResponse = ListSkillsetsResult & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ListSkillsetsResult;
  };
};

/** Optional parameters. */
export interface SkillsetsCreateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the create operation. */
export type SkillsetsCreateResponse = SearchIndexerSkillset & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndexerSkillset;
  };
};

/** Optional parameters. */
export interface SynonymMapsCreateOrUpdateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Contains response data for the createOrUpdate operation. */
export type SynonymMapsCreateOrUpdateResponse = SynonymMap & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SynonymMap;
  };
};

/** Optional parameters. */
export interface SynonymMapsDeleteOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Optional parameters. */
export interface SynonymMapsGetOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the get operation. */
export type SynonymMapsGetResponse = SynonymMap & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SynonymMap;
  };
};

/** Optional parameters. */
export interface SynonymMapsListOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Selects which top-level properties of the synonym maps to retrieve. Specified as a comma-separated list of JSON property names, or '*' for all properties. The default is all properties. */
  select?: string;
}

/** Contains response data for the list operation. */
export type SynonymMapsListResponse = ListSynonymMapsResult & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ListSynonymMapsResult;
  };
};

/** Optional parameters. */
export interface SynonymMapsCreateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the create operation. */
export type SynonymMapsCreateResponse = SynonymMap & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SynonymMap;
  };
};

/** Optional parameters. */
export interface IndexesCreateOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the create operation. */
export type IndexesCreateResponse = SearchIndex & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndex;
  };
};

/** Optional parameters. */
export interface IndexesListOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Selects which top-level properties of the index definitions to retrieve. Specified as a comma-separated list of JSON property names, or '*' for all properties. The default is all properties. */
  select?: string;
}

/** Contains response data for the list operation. */
export type IndexesListResponse = ListIndexesResult & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ListIndexesResult;
  };
};

/** Optional parameters. */
export interface IndexesCreateOrUpdateOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
  /** Allows new analyzers, tokenizers, token filters, or char filters to be added to an index by taking the index offline for at least a few seconds. This temporarily causes indexing and query requests to fail. Performance and write availability of the index can be impaired for several minutes after the index is updated, or longer for very large indexes. */
  allowIndexDowntime?: boolean;
}

/** Contains response data for the createOrUpdate operation. */
export type IndexesCreateOrUpdateResponse = SearchIndex & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndex;
  };
};

/** Optional parameters. */
export interface IndexesDeleteOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
  /** Defines the If-Match condition. The operation will be performed only if the ETag on the server matches this value. */
  ifMatch?: string;
  /** Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. */
  ifNoneMatch?: string;
}

/** Optional parameters. */
export interface IndexesGetOptionalParams extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the get operation. */
export type IndexesGetResponse = SearchIndex & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SearchIndex;
  };
};

/** Optional parameters. */
export interface IndexesGetStatisticsOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the getStatistics operation. */
export type IndexesGetStatisticsResponse = GetIndexStatisticsResult & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: GetIndexStatisticsResult;
  };
};

/** Optional parameters. */
export interface IndexesAnalyzeOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the analyze operation. */
export type IndexesAnalyzeResponse = AnalyzeResult & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnalyzeResult;
  };
};

/** Optional parameters. */
export interface SearchServiceClientGetServiceStatisticsOptionalParams
  extends coreHttp.OperationOptions {
  /** Parameter group */
  requestOptionsParam?: RequestOptions;
}

/** Contains response data for the getServiceStatistics operation. */
export type SearchServiceClientGetServiceStatisticsResponse = ServiceStatistics & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ServiceStatistics;
  };
};

/** Optional parameters. */
export interface SearchServiceClientOptionalParams
  extends coreHttp.ServiceClientOptions {
  /** Overrides client endpoint. */
  endpoint?: string;
}
