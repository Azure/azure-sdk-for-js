/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */


import * as coreHttp from "@azure/core-http";

/**
 * A result containing a document found by a suggestion query, plus associated metadata.
 */
export interface SuggestResult {
  /**
   * The text of the suggestion result.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly _text: string;
  /**
   * Describes unknown properties. The value of an unknown property can be of "any" type.
   */
  [property: string]: any;
}

/**
 * Response containing suggestion query results from an index.
 */
export interface SuggestDocumentsResult {
  /**
   * The sequence of results returned by the query.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly results: SuggestResult[];
  /**
   * A value indicating the percentage of the index that was included in the query, or null if
   * minimumCoverage was not set in the request.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly coverage?: number;
}

/**
 * A single bucket of a facet query result. Reports the number of documents with a field value
 * falling within a particular range or having a particular value or interval.
 */
export interface FacetResult {
  /**
   * The approximate count of documents falling within the bucket described by this facet.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly count?: number;
  /**
   * Describes unknown properties. The value of an unknown property can be of "any" type.
   */
  [property: string]: any;
}

/**
 * Parameters for filtering, sorting, faceting, paging, and other search query behaviors.
 */
export interface SearchRequest {
  /**
   * A value that specifies whether to fetch the total count of results. Default is false. Setting
   * this value to true may have a performance impact. Note that the count returned is an
   * approximation.
   */
  includeTotalResultCount?: boolean;
  /**
   * The list of facet expressions to apply to the search query. Each facet expression contains a
   * field name, optionally followed by a comma-separated list of name:value pairs.
   */
  facets?: string[];
  /**
   * The OData $filter expression to apply to the search query.
   */
  filter?: string;
  /**
   * The comma-separated list of field names to use for hit highlights. Only searchable fields can
   * be used for hit highlighting.
   */
  highlightFields?: string;
  /**
   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. Default is
   * &lt;/em&gt;.
   */
  highlightPostTag?: string;
  /**
   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. Default
   * is &lt;em&gt;.
   */
  highlightPreTag?: string;
  /**
   * A number between 0 and 100 indicating the percentage of the index that must be covered by a
   * search query in order for the query to be reported as a success. This parameter can be useful
   * for ensuring search availability even for services with only one replica. The default is 100.
   */
  minimumCoverage?: number;
  /**
   * The comma-separated list of OData $orderby expressions by which to sort the results. Each
   * expression can be either a field name or a call to either the geo.distance() or the
   * search.score() functions. Each expression can be followed by asc to indicate ascending, or
   * desc to indicate descending. The default is ascending order. Ties will be broken by the match
   * scores of documents. If no $orderby is specified, the default sort order is descending by
   * document match score. There can be at most 32 $orderby clauses.
   */
  orderBy?: string;
  /**
   * A value that specifies the syntax of the search query. The default is 'simple'. Use 'full' if
   * your query uses the Lucene query syntax. Possible values include: 'Simple', 'Full'
   */
  queryType?: QueryType;
  /**
   * The list of parameter values to be used in scoring functions (for example,
   * referencePointParameter) using the format name-values. For example, if the scoring profile
   * defines a function with a parameter called 'mylocation' the parameter string would be
   * "mylocation--122.2,44.8" (without the quotes).
   */
  scoringParameters?: string[];
  /**
   * The name of a scoring profile to evaluate match scores for matching documents in order to sort
   * the results.
   */
  scoringProfile?: string;
  /**
   * A full-text search query expression; Use "*" or omit this parameter to match all documents.
   */
  searchText?: string;
  /**
   * The comma-separated list of field names to which to scope the full-text search. When using
   * fielded search (fieldName:searchExpression) in a full Lucene query, the field names of each
   * fielded search expression take precedence over any field names listed in this parameter.
   */
  searchFields?: string;
  /**
   * A value that specifies whether any or all of the search terms must be matched in order to
   * count the document as a match. Possible values include: 'Any', 'All'
   */
  searchMode?: SearchMode;
  /**
   * The comma-separated list of fields to retrieve. If unspecified, all fields marked as
   * retrievable in the schema are included.
   */
  select?: string;
  /**
   * The number of search results to skip. This value cannot be greater than 100,000. If you need
   * to scan documents in sequence, but cannot use skip due to this limitation, consider using
   * orderby on a totally-ordered key and filter with a range query instead.
   */
  skip?: number;
  /**
   * The number of search results to retrieve. This can be used in conjunction with $skip to
   * implement client-side paging of search results. If results are truncated due to server-side
   * paging, the response will include a continuation token that can be used to issue another
   * Search request for the next page of results.
   */
  top?: number;
}

/**
 * Contains a document found by a search query, plus associated metadata.
 */
export interface SearchResult {
  /**
   * The relevance score of the document compared to other documents returned by the query.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly _score: number;
  /**
   * Text fragments from the document that indicate the matching search terms, organized by each
   * applicable field; null if hit highlighting was not enabled for the query.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly _highlights?: { [propertyName: string]: string[] };
  /**
   * Describes unknown properties. The value of an unknown property can be of "any" type.
   */
  [property: string]: any;
}

/**
 * Response containing search results from an index.
 */
export interface SearchDocumentsResult {
  /**
   * The total count of results found by the search operation, or null if the count was not
   * requested. If present, the count may be greater than the number of results in this response.
   * This can happen if you use the $top or $skip parameters, or if Azure Cognitive Search can't
   * return all the requested documents in a single Search response.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly count?: number;
  /**
   * A value indicating the percentage of the index that was included in the query, or null if
   * minimumCoverage was not specified in the request.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly coverage?: number;
  /**
   * The facet query results for the search operation, organized as a collection of buckets for
   * each faceted field; null if the query did not include any facet expressions.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly facets?: { [propertyName: string]: FacetResult[] };
  /**
   * Continuation JSON payload returned when Azure Cognitive Search can't return all the requested
   * results in a single Search response. You can use this JSON along with @odata.nextLink to
   * formulate another POST Search request to get the next part of the search response.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nextPageParameters?: SearchRequest;
  /**
   * The sequence of results returned by the query.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly results: SearchResult[];
  /**
   * Continuation URL returned when Azure Cognitive Search can't return all the requested results
   * in a single Search response. You can use this URL to formulate another GET or POST Search
   * request to get the next part of the search response. Make sure to use the same verb (GET or
   * POST) as the request that produced this response.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly nextLink?: string;
}

/**
 * Represents an index action that operates on a document.
 */
export interface IndexAction {
  /**
   * The operation to perform on a document in an indexing batch. Possible values include:
   * 'Upload', 'Merge', 'MergeOrUpload', 'Delete'
   */
  __actionType: IndexActionType;
  /**
   * Describes unknown properties. The value of an unknown property can be of "any" type.
   */
  [property: string]: any;
}

/**
 * Contains a batch of document write actions to send to the index.
 */
export interface IndexBatch {
  /**
   * The actions in the batch.
   */
  actions: IndexAction[];
}

/**
 * Status of an indexing operation for a single document.
 */
export interface IndexingResult {
  /**
   * The key of a document that was in the indexing request.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly key: string;
  /**
   * The error message explaining why the indexing operation failed for the document identified by
   * the key; null if indexing succeeded.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly errorMessage?: string;
  /**
   * A value indicating whether the indexing operation succeeded for the document identified by the
   * key.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly succeeded: boolean;
  /**
   * The status code of the indexing operation. Possible values include: 200 for a successful
   * update or delete, 201 for successful document creation, 400 for a malformed input document,
   * 404 for document not found, 409 for a version conflict, 422 when the index is temporarily
   * unavailable, or 503 for when the service is too busy.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly statusCode: number;
}

/**
 * Response containing the status of operations for all documents in the indexing request.
 */
export interface IndexDocumentsResult {
  /**
   * The list of status information for each document in the indexing request.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly results: IndexingResult[];
}

/**
 * Parameters for filtering, sorting, fuzzy matching, and other suggestions query behaviors.
 */
export interface SuggestRequest {
  /**
   * An OData expression that filters the documents considered for suggestions.
   */
  filter?: string;
  /**
   * A value indicating whether to use fuzzy matching for the suggestion query. Default is false.
   * When set to true, the query will find suggestions even if there's a substituted or missing
   * character in the search text. While this provides a better experience in some scenarios, it
   * comes at a performance cost as fuzzy suggestion searches are slower and consume more
   * resources.
   */
  useFuzzyMatching?: boolean;
  /**
   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. If omitted,
   * hit highlighting of suggestions is disabled.
   */
  highlightPostTag?: string;
  /**
   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If
   * omitted, hit highlighting of suggestions is disabled.
   */
  highlightPreTag?: string;
  /**
   * A number between 0 and 100 indicating the percentage of the index that must be covered by a
   * suggestion query in order for the query to be reported as a success. This parameter can be
   * useful for ensuring search availability even for services with only one replica. The default
   * is 80.
   */
  minimumCoverage?: number;
  /**
   * The comma-separated list of OData $orderby expressions by which to sort the results. Each
   * expression can be either a field name or a call to either the geo.distance() or the
   * search.score() functions. Each expression can be followed by asc to indicate ascending, or
   * desc to indicate descending. The default is ascending order. Ties will be broken by the match
   * scores of documents. If no $orderby is specified, the default sort order is descending by
   * document match score. There can be at most 32 $orderby clauses.
   */
  orderBy?: string;
  /**
   * The search text to use to suggest documents. Must be at least 1 character, and no more than
   * 100 characters.
   */
  searchText: string;
  /**
   * The comma-separated list of field names to search for the specified search text. Target fields
   * must be included in the specified suggester.
   */
  searchFields?: string;
  /**
   * The comma-separated list of fields to retrieve. If unspecified, only the key field will be
   * included in the results.
   */
  select?: string;
  /**
   * The name of the suggester as specified in the suggesters collection that's part of the index
   * definition.
   */
  suggesterName: string;
  /**
   * The number of suggestions to retrieve. This must be a value between 1 and 100. The default is
   * 5.
   */
  top?: number;
}

/**
 * Parameters for fuzzy matching, and other autocomplete query behaviors.
 */
export interface AutocompleteRequest {
  /**
   * The search text on which to base autocomplete results.
   */
  searchText: string;
  /**
   * Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms' to get shingles
   * and 'oneTermWithContext' to use the current context while producing auto-completed terms.
   * Possible values include: 'OneTerm', 'TwoTerms', 'OneTermWithContext'
   */
  autocompleteMode?: AutocompleteMode;
  /**
   * An OData expression that filters the documents used to produce completed terms for the
   * Autocomplete result.
   */
  filter?: string;
  /**
   * A value indicating whether to use fuzzy matching for the autocomplete query. Default is false.
   * When set to true, the query will autocomplete terms even if there's a substituted or missing
   * character in the search text. While this provides a better experience in some scenarios, it
   * comes at a performance cost as fuzzy autocomplete queries are slower and consume more
   * resources.
   */
  useFuzzyMatching?: boolean;
  /**
   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. If omitted,
   * hit highlighting is disabled.
   */
  highlightPostTag?: string;
  /**
   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If
   * omitted, hit highlighting is disabled.
   */
  highlightPreTag?: string;
  /**
   * A number between 0 and 100 indicating the percentage of the index that must be covered by an
   * autocomplete query in order for the query to be reported as a success. This parameter can be
   * useful for ensuring search availability even for services with only one replica. The default
   * is 80.
   */
  minimumCoverage?: number;
  /**
   * The comma-separated list of field names to consider when querying for auto-completed terms.
   * Target fields must be included in the specified suggester.
   */
  searchFields?: string;
  /**
   * The name of the suggester as specified in the suggesters collection that's part of the index
   * definition.
   */
  suggesterName: string;
  /**
   * The number of auto-completed terms to retrieve. This must be a value between 1 and 100. The
   * default is 5.
   */
  top?: number;
}

/**
 * The result of Autocomplete requests.
 */
export interface AutocompleteItem {
  /**
   * The completed term.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly text: string;
  /**
   * The query along with the completed term.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly queryPlusText: string;
}

/**
 * The result of Autocomplete query.
 */
export interface AutocompleteResult {
  /**
   * A value indicating the percentage of the index that was considered by the autocomplete
   * request, or null if minimumCoverage was not specified in the request.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly coverage?: number;
  /**
   * The list of returned Autocompleted items.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly results: AutocompleteItem[];
}

/**
 * Describes an error condition for the Azure Cognitive Search API.
 */
export interface SearchError {
  /**
   * One of a server-defined set of error codes.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly code?: string;
  /**
   * A human-readable representation of the error.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly message: string;
  /**
   * An array of details about specific errors that led to this reported error.
   * **NOTE: This property will not be serialized. It can only be populated by the server.**
   */
  readonly details?: SearchError[];
}

/**
 * Additional parameters for searchGet operation.
 */
export interface SearchOptions {
  /**
   * A value that specifies whether to fetch the total count of results. Default is false. Setting
   * this value to true may have a performance impact. Note that the count returned is an
   * approximation.
   */
  includeTotalResultCount?: boolean;
  /**
   * The list of facet expressions to apply to the search query. Each facet expression contains a
   * field name, optionally followed by a comma-separated list of name:value pairs.
   */
  facets?: string[];
  /**
   * The OData $filter expression to apply to the search query.
   */
  filter?: string;
  /**
   * The list of field names to use for hit highlights. Only searchable fields can be used for hit
   * highlighting.
   */
  highlightFields?: string[];
  /**
   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. Default is
   * &lt;/em&gt;.
   */
  highlightPostTag?: string;
  /**
   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. Default
   * is &lt;em&gt;.
   */
  highlightPreTag?: string;
  /**
   * A number between 0 and 100 indicating the percentage of the index that must be covered by a
   * search query in order for the query to be reported as a success. This parameter can be useful
   * for ensuring search availability even for services with only one replica. The default is 100.
   */
  minimumCoverage?: number;
  /**
   * The list of OData $orderby expressions by which to sort the results. Each expression can be
   * either a field name or a call to either the geo.distance() or the search.score() functions.
   * Each expression can be followed by asc to indicate ascending, and desc to indicate descending.
   * The default is ascending order. Ties will be broken by the match scores of documents. If no
   * OrderBy is specified, the default sort order is descending by document match score. There can
   * be at most 32 $orderby clauses.
   */
  orderBy?: string[];
  /**
   * A value that specifies the syntax of the search query. The default is 'simple'. Use 'full' if
   * your query uses the Lucene query syntax. Possible values include: 'Simple', 'Full'
   */
  queryType?: QueryType;
  /**
   * The list of parameter values to be used in scoring functions (for example,
   * referencePointParameter) using the format name-values. For example, if the scoring profile
   * defines a function with a parameter called 'mylocation' the parameter string would be
   * "mylocation--122.2,44.8" (without the quotes).
   */
  scoringParameters?: string[];
  /**
   * The name of a scoring profile to evaluate match scores for matching documents in order to sort
   * the results.
   */
  scoringProfile?: string;
  /**
   * The list of field names to which to scope the full-text search. When using fielded search
   * (fieldName:searchExpression) in a full Lucene query, the field names of each fielded search
   * expression take precedence over any field names listed in this parameter.
   */
  searchFields?: string[];
  /**
   * A value that specifies whether any or all of the search terms must be matched in order to
   * count the document as a match. Possible values include: 'Any', 'All'
   */
  searchMode?: SearchMode;
  /**
   * The list of fields to retrieve. If unspecified, all fields marked as retrievable in the schema
   * are included.
   */
  select?: string[];
  /**
   * The number of search results to skip. This value cannot be greater than 100,000. If you need
   * to scan documents in sequence, but cannot use $skip due to this limitation, consider using
   * $orderby on a totally-ordered key and $filter with a range query instead.
   */
  skip?: number;
  /**
   * The number of search results to retrieve. This can be used in conjunction with $skip to
   * implement client-side paging of search results. If results are truncated due to server-side
   * paging, the response will include a continuation token that can be used to issue another
   * Search request for the next page of results.
   */
  top?: number;
}

/**
 * Additional parameters for suggestGet operation.
 */
export interface SuggestOptions {
  /**
   * An OData expression that filters the documents considered for suggestions.
   */
  filter?: string;
  /**
   * A value indicating whether to use fuzzy matching for the suggestions query. Default is false.
   * When set to true, the query will find terms even if there's a substituted or missing character
   * in the search text. While this provides a better experience in some scenarios, it comes at a
   * performance cost as fuzzy suggestions queries are slower and consume more resources.
   */
  useFuzzyMatching?: boolean;
  /**
   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. If omitted,
   * hit highlighting of suggestions is disabled.
   */
  highlightPostTag?: string;
  /**
   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If
   * omitted, hit highlighting of suggestions is disabled.
   */
  highlightPreTag?: string;
  /**
   * A number between 0 and 100 indicating the percentage of the index that must be covered by a
   * suggestions query in order for the query to be reported as a success. This parameter can be
   * useful for ensuring search availability even for services with only one replica. The default
   * is 80.
   */
  minimumCoverage?: number;
  /**
   * The list of OData $orderby expressions by which to sort the results. Each expression can be
   * either a field name or a call to either the geo.distance() or the search.score() functions.
   * Each expression can be followed by asc to indicate ascending, or desc to indicate descending.
   * The default is ascending order. Ties will be broken by the match scores of documents. If no
   * $orderby is specified, the default sort order is descending by document match score. There can
   * be at most 32 $orderby clauses.
   */
  orderBy?: string[];
  /**
   * The list of field names to search for the specified search text. Target fields must be
   * included in the specified suggester.
   */
  searchFields?: string[];
  /**
   * The list of fields to retrieve. If unspecified, only the key field will be included in the
   * results.
   */
  select?: string[];
  /**
   * The number of suggestions to retrieve. The value must be a number between 1 and 100. The
   * default is 5.
   */
  top?: number;
}

/**
 * Additional parameters for autocompleteGet operation.
 */
export interface AutocompleteOptions {
  /**
   * Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms' to get shingles
   * and 'oneTermWithContext' to use the current context while producing auto-completed terms.
   * Possible values include: 'OneTerm', 'TwoTerms', 'OneTermWithContext'
   */
  autocompleteMode?: AutocompleteMode;
  /**
   * An OData expression that filters the documents used to produce completed terms for the
   * Autocomplete result.
   */
  filter?: string;
  /**
   * A value indicating whether to use fuzzy matching for the autocomplete query. Default is false.
   * When set to true, the query will find terms even if there's a substituted or missing character
   * in the search text. While this provides a better experience in some scenarios, it comes at a
   * performance cost as fuzzy autocomplete queries are slower and consume more resources.
   */
  useFuzzyMatching?: boolean;
  /**
   * A string tag that is appended to hit highlights. Must be set with highlightPreTag. If omitted,
   * hit highlighting is disabled.
   */
  highlightPostTag?: string;
  /**
   * A string tag that is prepended to hit highlights. Must be set with highlightPostTag. If
   * omitted, hit highlighting is disabled.
   */
  highlightPreTag?: string;
  /**
   * A number between 0 and 100 indicating the percentage of the index that must be covered by an
   * autocomplete query in order for the query to be reported as a success. This parameter can be
   * useful for ensuring search availability even for services with only one replica. The default
   * is 80.
   */
  minimumCoverage?: number;
  /**
   * The list of field names to consider when querying for auto-completed terms. Target fields must
   * be included in the specified suggester.
   */
  searchFields?: string[];
  /**
   * The number of auto-completed terms to retrieve. This must be a value between 1 and 100. The
   * default is 5.
   */
  top?: number;
}

/**
 * Optional Parameters.
 */
export interface DocumentsSearchGetOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * A full-text search query expression; Use "*" or omit this parameter to match all documents.
   */
  searchText?: string;
  /**
   * Additional parameters for the operation
   */
  searchOptions?: SearchOptions;
}

/**
 * Optional Parameters.
 */
export interface DocumentsGetOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * List of field names to retrieve for the document; Any field not retrieved will be missing from
   * the returned document.
   */
  selectedFields?: string[];
}

/**
 * Optional Parameters.
 */
export interface DocumentsSuggestGetOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * Additional parameters for the operation
   */
  suggestOptions?: SuggestOptions;
}

/**
 * Optional Parameters.
 */
export interface DocumentsAutocompleteGetOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * Additional parameters for the operation
   */
  autocompleteOptions?: AutocompleteOptions;
}

/**
 * Defines values for QueryType.
 * Possible values include: 'Simple', 'Full'
 * @readonly
 * @enum {string}
 */
export type QueryType = 'simple' | 'full';

/**
 * Defines values for SearchMode.
 * Possible values include: 'Any', 'All'
 * @readonly
 * @enum {string}
 */
export type SearchMode = 'any' | 'all';

/**
 * Defines values for IndexActionType.
 * Possible values include: 'Upload', 'Merge', 'MergeOrUpload', 'Delete'
 * @readonly
 * @enum {string}
 */
export type IndexActionType = 'upload' | 'merge' | 'mergeOrUpload' | 'delete';

/**
 * Defines values for AutocompleteMode.
 * Possible values include: 'OneTerm', 'TwoTerms', 'OneTermWithContext'
 * @readonly
 * @enum {string}
 */
export type AutocompleteMode = 'oneTerm' | 'twoTerms' | 'oneTermWithContext';

/**
 * Contains response data for the count operation.
 */
export type DocumentsCountResponse = {
  /**
   * The parsed response body.
   */
  body: number;

  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: number;
    };
};

/**
 * Contains response data for the searchGet operation.
 */
export type DocumentsSearchGetResponse = SearchDocumentsResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SearchDocumentsResult;
    };
};

/**
 * Contains response data for the searchPost operation.
 */
export type DocumentsSearchPostResponse = SearchDocumentsResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SearchDocumentsResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type DocumentsGetResponse = {
  /**
   * The parsed response body.
   */
  body: any;

  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: any;
    };
};

/**
 * Contains response data for the suggestGet operation.
 */
export type DocumentsSuggestGetResponse = SuggestDocumentsResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SuggestDocumentsResult;
    };
};

/**
 * Contains response data for the suggestPost operation.
 */
export type DocumentsSuggestPostResponse = SuggestDocumentsResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SuggestDocumentsResult;
    };
};

/**
 * Contains response data for the index operation.
 */
export type DocumentsIndexResponse = IndexDocumentsResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: IndexDocumentsResult;
    };
};

/**
 * Contains response data for the autocompleteGet operation.
 */
export type DocumentsAutocompleteGetResponse = AutocompleteResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AutocompleteResult;
    };
};

/**
 * Contains response data for the autocompletePost operation.
 */
export type DocumentsAutocompletePostResponse = AutocompleteResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AutocompleteResult;
    };
};
