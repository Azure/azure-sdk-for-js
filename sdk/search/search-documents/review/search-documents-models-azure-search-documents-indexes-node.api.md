## API Report File for "@azure/search-documents"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AIFoundryModelCatalogName = string;

// @public
export interface AIServicesAccountIdentity extends CognitiveServicesAccount {
    identity?: SearchIndexerDataIdentityUnion | null;
    odatatype: "#Microsoft.Azure.Search.AIServicesByIdentity";
    subdomainUrl: string;
}

// @public
export interface AIServicesAccountKey extends CognitiveServicesAccount {
    key: string;
    odatatype: "#Microsoft.Azure.Search.AIServicesByKey";
    subdomainUrl: string;
}

// @public
export interface AIServicesVisionParameters {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion | null;
    modelVersion: string | null;
    resourceUri: string;
}

// @public
export interface AIServicesVisionVectorizer extends VectorSearchVectorizer {
    aiServicesVisionParameters?: AIServicesVisionParameters;
    kind: "aiServicesVision";
}

// @public
export interface AnalyzedTokenInfo {
    readonly endOffset: number;
    readonly position: number;
    readonly startOffset: number;
    readonly token: string;
}

// @public
export interface AnalyzeResult {
    tokens: AnalyzedTokenInfo[];
}

// @public
export interface AnalyzeTextOptions {
    analyzerName?: LexicalAnalyzerName;
    charFilters?: CharFilterName[];
    normalizerName?: LexicalNormalizerName;
    text: string;
    tokenFilters?: TokenFilterName[];
    tokenizerName?: LexicalTokenizerName;
}

// @public
export interface AsciiFoldingTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter";
    preserveOriginal?: boolean;
}

// @public
export interface AzureActiveDirectoryApplicationCredentials {
    applicationId: string;
    applicationSecret?: string;
}

// @public
export interface AzureBlobKnowledgeSource extends KnowledgeSource {
    azureBlobParameters: AzureBlobKnowledgeSourceParameters;
    // (undocumented)
    kind: "azureBlob";
}

// @public
export interface AzureBlobKnowledgeSourceParameters {
    connectionString: string;
    containerName: string;
    readonly createdResources?: CreatedResources;
    folderPath?: string | null;
    ingestionParameters?: KnowledgeSourceIngestionParameters | null;
    isAdlsGen2?: boolean;
}

// @public
export interface AzureMachineLearningParameters {
    authenticationKey?: string | null;
    modelName?: AIFoundryModelCatalogName;
    region?: string | null;
    resourceId?: string | null;
    scoringUri: string | null;
    timeout?: string | null;
}

// @public
export interface AzureMachineLearningSkill extends SearchIndexerSkill {
    authenticationKey?: string | null;
    degreeOfParallelism?: number | null;
    odatatype: "#Microsoft.Skills.Custom.AmlSkill";
    region?: string | null;
    resourceId?: string | null;
    scoringUri?: string | null;
    timeout?: string | null;
}

// @public
export interface AzureMachineLearningVectorizer extends VectorSearchVectorizer {
    amlParameters?: AzureMachineLearningParameters;
    kind: "aml";
}

// @public
export interface AzureOpenAIEmbeddingSkill extends SearchIndexerSkill {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    deploymentId?: string;
    dimensions?: number | null;
    modelName?: AzureOpenAIModelName;
    odatatype: "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill";
    resourceUrl?: string;
}

// @public
export type AzureOpenAIModelName = string;

// @public
export interface AzureOpenAITokenizerParameters {
    allowedSpecialTokens?: string[];
    encoderModelName?: SplitSkillEncoderModelName | null;
}

// @public
export interface AzureOpenAIVectorizer extends VectorSearchVectorizer {
    kind: "azureOpenAI";
    parameters?: AzureOpenAIVectorizerParameters;
}

// @public
export interface AzureOpenAIVectorizerParameters {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    deploymentId?: string;
    modelName?: AzureOpenAIModelName;
    resourceUrl?: string;
}

// @public
export interface BinaryQuantizationCompression extends VectorSearchCompression {
    kind: "binaryQuantization";
}

// @public
export type BlobIndexerDataToExtract = string;

// @public
export type BlobIndexerImageAction = string;

// @public
export type BlobIndexerParsingMode = string;

// @public
export type BlobIndexerPDFTextRotationAlgorithm = string;

// @public
export interface BM25Similarity extends SimilarityAlgorithm {
    b?: number | null;
    k1?: number | null;
    odatatype: "#Microsoft.Azure.Search.BM25Similarity";
}

// @public
export interface CharFilter {
    name: string;
    odatatype: string;
}

// @public
export type CharFilterName = string;

// @public
export type CharFilterUnion = MappingCharFilter | PatternReplaceCharFilter | CharFilter;

// @public
export type ChatCompletionExtraParametersBehavior = string;

// @public
export interface ChatCompletionResponseFormat {
    chatCompletionSchemaProperties?: ChatCompletionSchemaProperties | null;
    type?: ChatCompletionResponseFormatType;
}

// @public
export type ChatCompletionResponseFormatType = string;

// @public
export interface ChatCompletionSchema {
    additionalProperties?: boolean;
    properties?: string;
    required?: string[];
    type?: string;
}

// @public
export interface ChatCompletionSchemaProperties {
    description?: string | null;
    name?: string | null;
    schema?: ChatCompletionSchema;
    strict?: boolean;
}

// @public
export interface ChatCompletionSkill extends SearchIndexerSkill {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion | null;
    authResourceId?: string | null;
    batchSize?: number | null;
    commonModelParameters?: CommonModelParameters;
    degreeOfParallelism?: number | null;
    extraParameters?: Record<string, any> | null;
    extraParametersBehavior?: ChatCompletionExtraParametersBehavior;
    httpHeaders?: WebApiHttpHeaders;
    httpMethod?: string;
    odataType: "#Microsoft.Skills.Custom.ChatCompletionSkill";
    responseFormat?: ChatCompletionResponseFormat;
    timeout?: string;
    uri: string;
}

// @public
export interface CjkBigramTokenFilter extends TokenFilter {
    ignoreScripts?: CjkBigramTokenFilterScripts[];
    odatatype: "#Microsoft.Azure.Search.CjkBigramTokenFilter";
    outputUnigrams?: boolean;
}

// @public
export type CjkBigramTokenFilterScripts = "han" | "hiragana" | "katakana" | "hangul";

// @public
export interface ClassicSimilarity extends SimilarityAlgorithm {
    odatatype: "#Microsoft.Azure.Search.ClassicSimilarity";
}

// @public
export interface ClassicTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.ClassicTokenizer";
}

// @public
export interface CognitiveServicesAccount {
    description?: string;
    odatatype: string;
}

// @public
export interface CognitiveServicesAccountKey extends CognitiveServicesAccount {
    key: string;
    odatatype: "#Microsoft.Azure.Search.CognitiveServicesByKey";
}

// @public
export type CognitiveServicesAccountUnion = DefaultCognitiveServicesAccount | CognitiveServicesAccountKey | AIServicesAccountKey | AIServicesAccountIdentity | CognitiveServicesAccount;

// @public
export interface CommonGramTokenFilter extends TokenFilter {
    commonWords: string[];
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.CommonGramTokenFilter";
    useQueryMode?: boolean;
}

// @public
export interface CommonModelParameters {
    frequencyPenalty?: number | null;
    maxTokens?: number | null;
    modelName?: string | null;
    presencePenalty?: number | null;
    seed?: number | null;
    stop?: string[] | null;
    temperature?: number | null;
}

// @public
export interface ConditionalSkill extends SearchIndexerSkill {
    odatatype: "#Microsoft.Skills.Util.ConditionalSkill";
}

// @public
export interface ContentUnderstandingSkill extends SearchIndexerSkill {
    chunkingProperties?: ContentUnderstandingSkillChunkingProperties | null;
    extractionOptions?: ContentUnderstandingSkillExtractionOptions[] | null;
    odataType: "#Microsoft.Skills.Util.ContentUnderstandingSkill";
}

// @public
export interface ContentUnderstandingSkillChunkingProperties {
    maximumLength?: number | null;
    overlapLength?: number | null;
    unit?: ContentUnderstandingSkillChunkingUnit | null;
}

// @public
export type ContentUnderstandingSkillChunkingUnit = string;

// @public
export type ContentUnderstandingSkillExtractionOptions = string;

// @public
export interface CorsOptions {
    allowedOrigins: string[];
    maxAgeInSeconds?: number | null;
}

// @public
export interface CreatedResources {
    additionalProperties?: Record<string, string>;
}

// @public
export interface CustomAnalyzer extends LexicalAnalyzer {
    charFilters?: CharFilterName[];
    odatatype: "#Microsoft.Azure.Search.CustomAnalyzer";
    tokenFilters?: TokenFilterName[];
    tokenizer: LexicalTokenizerName;
}

// @public
export interface CustomEntity {
    accentSensitive?: boolean | null;
    aliases?: CustomEntityAlias[] | null;
    caseSensitive?: boolean | null;
    defaultAccentSensitive?: boolean | null;
    defaultCaseSensitive?: boolean | null;
    defaultFuzzyEditDistance?: number | null;
    description?: string | null;
    fuzzyEditDistance?: number | null;
    id?: string | null;
    name: string;
    subtype?: string | null;
    type?: string | null;
}

// @public
export interface CustomEntityAlias {
    accentSensitive?: boolean | null;
    caseSensitive?: boolean | null;
    fuzzyEditDistance?: number | null;
    text: string;
}

// @public
export interface CustomEntityLookupSkill extends SearchIndexerSkill {
    defaultLanguageCode?: CustomEntityLookupSkillLanguage | null;
    entitiesDefinitionUri?: string | null;
    globalDefaultAccentSensitive?: boolean | null;
    globalDefaultCaseSensitive?: boolean | null;
    globalDefaultFuzzyEditDistance?: number | null;
    inlineEntitiesDefinition?: CustomEntity[] | null;
    odatatype: "#Microsoft.Skills.Text.CustomEntityLookupSkill";
}

// @public
export type CustomEntityLookupSkillLanguage = string;

// @public
export interface CustomNormalizer extends LexicalNormalizer {
    charFilters?: CharFilterName[];
    odatatype: "#Microsoft.Azure.Search.CustomNormalizer";
    tokenFilters?: TokenFilterName[];
}

// @public
export interface DataChangeDetectionPolicy {
    odatatype: string;
}

// @public
export type DataChangeDetectionPolicyUnion = HighWaterMarkChangeDetectionPolicy | SqlIntegratedChangeTrackingPolicy | DataChangeDetectionPolicy;

// @public
export interface DataDeletionDetectionPolicy {
    odatatype: string;
}

// @public
export type DataDeletionDetectionPolicyUnion = SoftDeleteColumnDeletionDetectionPolicy | NativeBlobSoftDeleteDeletionDetectionPolicy | DataDeletionDetectionPolicy;

// @public
export interface DataSourceCredentials {
    connectionString?: string;
}

// @public
export interface DefaultCognitiveServicesAccount extends CognitiveServicesAccount {
    odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices";
}

// @public
export interface DictionaryDecompounderTokenFilter extends TokenFilter {
    maxSubwordSize?: number;
    minSubwordSize?: number;
    minWordSize?: number;
    odatatype: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter";
    onlyLongestMatch?: boolean;
    wordList: string[];
}

// @public
export interface DistanceScoringFunction extends ScoringFunction {
    parameters: DistanceScoringParameters;
    type: "distance";
}

// @public
export interface DistanceScoringParameters {
    boostingDistance: number;
    referencePointParameter: string;
}

// @public
export interface DocumentExtractionSkill extends SearchIndexerSkill {
    configuration?: Record<string, any> | null;
    dataToExtract?: string | null;
    odatatype: "#Microsoft.Skills.Util.DocumentExtractionSkill";
    parsingMode?: string | null;
}

// @public
export interface DocumentIntelligenceLayoutSkill extends SearchIndexerSkill {
    chunkingProperties?: DocumentIntelligenceLayoutSkillChunkingProperties | null;
    extractionOptions?: DocumentIntelligenceLayoutSkillExtractionOptions[] | null;
    markdownHeaderDepth?: DocumentIntelligenceLayoutSkillMarkdownHeaderDepth | null;
    odatatype: "#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill";
    outputFormat?: DocumentIntelligenceLayoutSkillOutputFormat | null;
    outputMode?: DocumentIntelligenceLayoutSkillOutputMode | null;
}

// @public
export interface DocumentIntelligenceLayoutSkillChunkingProperties {
    maximumLength?: number | null;
    overlapLength?: number | null;
    unit?: DocumentIntelligenceLayoutSkillChunkingUnit | null;
}

// @public
export type DocumentIntelligenceLayoutSkillChunkingUnit = string;

// @public
export type DocumentIntelligenceLayoutSkillExtractionOptions = string;

// @public
export type DocumentIntelligenceLayoutSkillMarkdownHeaderDepth = string;

// @public
export type DocumentIntelligenceLayoutSkillOutputFormat = string;

// @public
export type DocumentIntelligenceLayoutSkillOutputMode = string;

// @public
export interface DocumentKeysOrIds {
    datasourceDocumentIds?: string[];
    documentKeys?: string[];
}

// @public
export interface EdgeNGramTokenFilter extends TokenFilter {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilter";
    side?: EdgeNGramTokenFilterSide;
}

// @public
export type EdgeNGramTokenFilterSide = "front" | "back";

// @public
export interface EdgeNGramTokenFilterV2 extends TokenFilter {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2";
    side?: EdgeNGramTokenFilterSide;
}

// @public
export interface EdgeNGramTokenizer extends LexicalTokenizer {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export interface ElisionTokenFilter extends TokenFilter {
    articles?: string[];
    odatatype: "#Microsoft.Azure.Search.ElisionTokenFilter";
}

// @public
export interface EntityLinkingSkill extends SearchIndexerSkill {
    defaultLanguageCode?: string | null;
    minimumPrecision?: number;
    modelVersion?: string | null;
    odatatype: "#Microsoft.Skills.Text.V3.EntityLinkingSkill";
}

// @public
export interface EntityRecognitionSkillV3 extends SearchIndexerSkill {
    categories?: string[];
    defaultLanguageCode?: string | null;
    minimumPrecision?: number;
    modelVersion?: string | null;
    odatatype: "#Microsoft.Skills.Text.V3.EntityRecognitionSkill";
}

// @public
export interface ExhaustiveKnnAlgorithmConfiguration extends VectorSearchAlgorithmConfiguration {
    kind: "exhaustiveKnn";
    parameters?: ExhaustiveKnnParameters;
}

// @public
export interface ExhaustiveKnnParameters {
    metric?: VectorSearchAlgorithmMetric | null;
}

// @public
export interface FieldMapping {
    mappingFunction?: FieldMappingFunction | null;
    sourceFieldName: string;
    targetFieldName?: string;
}

// @public
export interface FieldMappingFunction {
    name: string;
    parameters?: Record<string, any> | null;
}

// @public
export interface FreshnessScoringFunction extends ScoringFunction {
    parameters: FreshnessScoringParameters;
    type: "freshness";
}

// @public
export interface FreshnessScoringParameters {
    boostingDuration: string;
}

// @public
export interface GetIndexStatisticsResult {
    readonly documentCount: number;
    readonly storageSize: number;
    readonly vectorIndexSize: number;
}

// @public
export interface HighWaterMarkChangeDetectionPolicy extends DataChangeDetectionPolicy {
    highWaterMarkColumnName: string;
    odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy";
}

// @public
export interface HnswAlgorithmConfiguration extends VectorSearchAlgorithmConfiguration {
    kind: "hnsw";
    parameters?: HnswParameters;
}

// @public
export interface HnswParameters {
    efConstruction?: number;
    efSearch?: number;
    m?: number;
    metric?: VectorSearchAlgorithmMetric | null;
}

// @public
export interface ImageAnalysisSkill extends SearchIndexerSkill {
    defaultLanguageCode?: ImageAnalysisSkillLanguage;
    details?: ImageDetail[];
    odatatype: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
    visualFeatures?: VisualFeature[];
}

// @public
export type ImageAnalysisSkillLanguage = string;

// @public
export type ImageDetail = string;

// @public
export interface IndexedOneLakeKnowledgeSource extends KnowledgeSource {
    indexedOneLakeParameters: IndexedOneLakeKnowledgeSourceParameters;
    // (undocumented)
    kind: "indexedOneLake";
}

// @public
export interface IndexedOneLakeKnowledgeSourceParameters {
    readonly createdResources?: CreatedResources;
    fabricWorkspaceId: string;
    ingestionParameters?: KnowledgeSourceIngestionParameters;
    lakehouseId: string;
    targetPath?: string | null;
}

// @public
export type IndexedSharePointContainerName = string;

// @public
export interface IndexedSharePointKnowledgeSource extends KnowledgeSource {
    indexedSharePointParameters: IndexedSharePointKnowledgeSourceParameters;
    // (undocumented)
    kind: "indexedSharePoint";
}

// @public
export interface IndexedSharePointKnowledgeSourceParameters {
    connectionString: string;
    containerName: IndexedSharePointContainerName;
    readonly createdResources?: CreatedResources;
    ingestionParameters?: KnowledgeSourceIngestionParameters | null;
    query?: string | null;
}

// @public
export interface IndexerCurrentState {
    readonly allDocsFinalTrackingState?: string;
    readonly allDocsInitialTrackingState?: string;
    readonly mode?: IndexingMode;
    readonly resetDatasourceDocumentIds?: string[];
    readonly resetDocsFinalTrackingState?: string;
    readonly resetDocsInitialTrackingState?: string;
    readonly resetDocumentKeys?: string[];
    readonly resyncFinalTrackingState?: string;
    readonly resyncInitialTrackingState?: string;
}

// @public
export type IndexerExecutionEnvironment = string;

// @public
export interface IndexerExecutionResult {
    readonly endTime?: Date | null;
    readonly errorMessage?: string;
    readonly errors: SearchIndexerError[];
    readonly failedItemCount: number;
    readonly finalTrackingState?: string;
    readonly initialTrackingState?: string;
    readonly itemCount: number;
    readonly mode?: IndexingMode;
    readonly startTime?: Date;
    readonly status: IndexerExecutionStatus;
    readonly statusDetail?: IndexerExecutionStatusDetail;
    readonly warnings: SearchIndexerWarning[];
}

// @public
export type IndexerExecutionStatus = "transientFailure" | "success" | "inProgress" | "reset";

// @public
export type IndexerExecutionStatusDetail = string;

// @public
export type IndexerPermissionOption = string;

// @public
export interface IndexerResyncBody {
    options?: IndexerResyncOption[] | null;
}

// @public
export type IndexerResyncOption = string;

// @public
export interface IndexerRuntime {
    beginningTime: Date;
    endingTime: Date;
    remainingSeconds?: number | null;
    usedSeconds: number;
}

// @public
export type IndexerStatus = "unknown" | "error" | "running";

// @public
export type IndexingMode = string;

// @public
export interface IndexingParameters {
    batchSize?: number | null;
    configuration?: IndexingParametersConfiguration;
    maxFailedItems?: number | null;
    maxFailedItemsPerBatch?: number | null;
}

// @public
export interface IndexingParametersConfiguration {
    additionalProperties?: Record<string, any>;
    allowSkillsetToReadFileData?: boolean;
    dataToExtract?: BlobIndexerDataToExtract;
    delimitedTextDelimiter?: string;
    delimitedTextHeaders?: string;
    documentRoot?: string;
    excludedFileNameExtensions?: string;
    executionEnvironment?: IndexerExecutionEnvironment;
    failOnUnprocessableDocument?: boolean;
    failOnUnsupportedContentType?: boolean;
    firstLineContainsHeaders?: boolean;
    imageAction?: BlobIndexerImageAction;
    indexedFileNameExtensions?: string;
    indexStorageMetadataOnlyForOversizedDocuments?: boolean;
    markdownHeaderDepth?: MarkdownHeaderDepth | null;
    markdownParsingSubmode?: MarkdownParsingSubmode | null;
    parsingMode?: BlobIndexerParsingMode;
    pdfTextRotationAlgorithm?: BlobIndexerPDFTextRotationAlgorithm;
    queryTimeout?: string;
}

// @public
export interface IndexingSchedule {
    interval: string;
    startTime?: Date;
}

// @public
export type IndexProjectionMode = string;

// @public
export interface IndexStatisticsSummary {
    readonly documentCount: number;
    name: string;
    readonly storageSize: number;
    readonly vectorIndexSize: number;
}

// @public
export interface InputFieldMappingEntry {
    inputs?: InputFieldMappingEntry[];
    name: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface KeepTokenFilter extends TokenFilter {
    keepWords: string[];
    lowerCaseKeepWords?: boolean;
    odatatype: "#Microsoft.Azure.Search.KeepTokenFilter";
}

// @public
export interface KeyPhraseExtractionSkill extends SearchIndexerSkill {
    defaultLanguageCode?: KeyPhraseExtractionSkillLanguage;
    maxKeyPhraseCount?: number | null;
    modelVersion?: string | null;
    odatatype: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill";
}

// @public
export type KeyPhraseExtractionSkillLanguage = string;

// @public
export interface KeywordMarkerTokenFilter extends TokenFilter {
    ignoreCase?: boolean;
    keywords: string[];
    odatatype: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter";
}

// @public
export interface KeywordTokenizer extends LexicalTokenizer {
    bufferSize?: number;
    odatatype: "#Microsoft.Azure.Search.KeywordTokenizer";
}

// @public
export interface KeywordTokenizerV2 extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.KeywordTokenizerV2";
}

// @public
export interface KnowledgeBase {
    answerInstructions?: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey | null;
    eTag?: string;
    knowledgeSources: KnowledgeSourceReference[];
    models?: KnowledgeBaseModelUnion[];
    name: string;
    outputMode?: KnowledgeRetrievalOutputMode;
    retrievalInstructions?: string;
    retrievalReasoningEffort?: KnowledgeRetrievalReasoningEffortUnion;
}

// @public
export interface KnowledgeBaseAzureOpenAIModel extends KnowledgeBaseModel {
    azureOpenAIParameters: AzureOpenAIVectorizerParameters;
    // (undocumented)
    kind: "azureOpenAI";
}

// @public
export interface KnowledgeBaseModel {
    kind: KnowledgeBaseModelKind;
}

// @public
export type KnowledgeBaseModelKind = string;

// @public
export type KnowledgeBaseModelUnion = KnowledgeBaseAzureOpenAIModel | KnowledgeBaseModel;

// @public
export interface KnowledgeSource {
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey | null;
    eTag?: string;
    kind: KnowledgeSourceKind;
    name: string;
}

// @public
export type KnowledgeSourceContentExtractionMode = string;

// @public
export type KnowledgeSourceIngestionPermissionOption = string;

// @public
export type KnowledgeSourceKind = string;

// @public
export interface KnowledgeSourceReference {
    name: string;
}

// @public
export type KnowledgeSourceSynchronizationStatus = string;

// @public
export type KnowledgeSourceUnion = SearchIndexKnowledgeSource | AzureBlobKnowledgeSource | IndexedSharePointKnowledgeSource | IndexedOneLakeKnowledgeSource | WebKnowledgeSource | RemoteSharePointKnowledgeSource | KnowledgeSource;

// @public
export enum KnownAIFoundryModelCatalogName {
    CohereEmbedV3English = "Cohere-embed-v3-english",
    CohereEmbedV3Multilingual = "Cohere-embed-v3-multilingual",
    CohereEmbedV4 = "Cohere-embed-v4",
    FacebookDinoV2ImageEmbeddingsViTBase = "Facebook-DinoV2-Image-Embeddings-ViT-Base",
    FacebookDinoV2ImageEmbeddingsViTGiant = "Facebook-DinoV2-Image-Embeddings-ViT-Giant",
    OpenAIClipImageTextEmbeddingsVitBasePatch32 = "OpenAI-CLIP-Image-Text-Embeddings-vit-base-patch32",
    OpenAIClipImageTextEmbeddingsViTLargePatch14336 = "OpenAI-CLIP-Image-Text-Embeddings-ViT-Large-Patch14-336"
}

// @public
export enum KnownAzureOpenAIModelName {
    Gpt41 = "gpt-4.1",
    Gpt41Mini = "gpt-4.1-mini",
    Gpt41Nano = "gpt-4.1-nano",
    Gpt4O = "gpt-4o",
    Gpt4OMini = "gpt-4o-mini",
    Gpt5 = "gpt-5",
    Gpt5Mini = "gpt-5-mini",
    Gpt5Nano = "gpt-5-nano",
    TextEmbedding3Large = "text-embedding-3-large",
    TextEmbedding3Small = "text-embedding-3-small",
    TextEmbeddingAda002 = "text-embedding-ada-002"
}

// @public
export enum KnownBlobIndexerDataToExtract {
    AllMetadata = "allMetadata",
    ContentAndMetadata = "contentAndMetadata",
    StorageMetadata = "storageMetadata"
}

// @public
export enum KnownBlobIndexerImageAction {
    GenerateNormalizedImagePerPage = "generateNormalizedImagePerPage",
    GenerateNormalizedImages = "generateNormalizedImages",
    None = "none"
}

// @public
export enum KnownBlobIndexerParsingMode {
    Default = "default",
    DelimitedText = "delimitedText",
    Json = "json",
    JsonArray = "jsonArray",
    JsonLines = "jsonLines",
    Markdown = "markdown",
    Text = "text"
}

// @public
export enum KnownBlobIndexerPDFTextRotationAlgorithm {
    DetectAngles = "detectAngles",
    None = "none"
}

// @public
export enum KnownCharFilterName {
    HtmlStrip = "html_strip"
}

// @public
export enum KnownChatCompletionExtraParametersBehavior {
    Drop = "drop",
    Error = "error",
    PassThrough = "pass-through"
}

// @public
export enum KnownChatCompletionResponseFormatType {
    JsonObject = "jsonObject",
    JsonSchema = "jsonSchema",
    Text = "text"
}

// @public
export enum KnownContentUnderstandingSkillChunkingUnit {
    Characters = "characters"
}

// @public
export enum KnownContentUnderstandingSkillExtractionOptions {
    Images = "images",
    LocationMetadata = "locationMetadata"
}

// @public
export enum KnownCustomEntityLookupSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ko = "ko",
    Pt = "pt"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillChunkingUnit {
    Characters = "characters"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillExtractionOptions {
    Images = "images",
    LocationMetadata = "locationMetadata"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth {
    H1 = "h1",
    H2 = "h2",
    H3 = "h3",
    H4 = "h4",
    H5 = "h5",
    H6 = "h6"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillOutputFormat {
    Markdown = "markdown",
    Text = "text"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillOutputMode {
    OneToMany = "oneToMany"
}

// @public
export enum KnownImageAnalysisSkillLanguage {
    Ar = "ar",
    Az = "az",
    Bg = "bg",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Eu = "eu",
    Fi = "fi",
    Fr = "fr",
    Ga = "ga",
    Gl = "gl",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Hu = "hu",
    Id = "id",
    It = "it",
    Ja = "ja",
    Kk = "kk",
    Ko = "ko",
    Lt = "lt",
    Lv = "lv",
    Mk = "mk",
    Ms = "ms",
    Nb = "nb",
    Nl = "nl",
    Pl = "pl",
    Prs = "prs",
    Pt = "pt",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ro = "ro",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Sv = "sv",
    Th = "th",
    Tr = "tr",
    Uk = "uk",
    Vi = "vi",
    Zh = "zh",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export enum KnownImageDetail {
    Celebrities = "celebrities",
    Landmarks = "landmarks"
}

// @public
export enum KnownIndexedSharePointContainerName {
    AllSiteLibraries = "allSiteLibraries",
    DefaultSiteLibrary = "defaultSiteLibrary",
    UseQuery = "useQuery"
}

// @public
export enum KnownIndexerExecutionEnvironment {
    Private = "private",
    Standard = "standard"
}

// @public
export enum KnownIndexerExecutionStatusDetail {
    ResetDocs = "resetDocs",
    Resync = "resync"
}

// @public
export enum KnownIndexerPermissionOption {
    GroupIds = "groupIds",
    RbacScope = "rbacScope",
    UserIds = "userIds"
}

// @public
export enum KnownIndexerResyncOption {
    Permissions = "permissions"
}

// @public
export enum KnownIndexingMode {
    IndexingAllDocs = "indexingAllDocs",
    IndexingResetDocs = "indexingResetDocs",
    IndexingResync = "indexingResync"
}

// @public
export enum KnownIndexProjectionMode {
    IncludeIndexingParentDocuments = "includeIndexingParentDocuments",
    SkipIndexingParentDocuments = "skipIndexingParentDocuments"
}

// @public
export enum KnownKeyPhraseExtractionSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv"
}

// @public
export enum KnownKnowledgeBaseModelKind {
    AzureOpenAI = "azureOpenAI"
}

// @public
export enum KnownKnowledgeSourceContentExtractionMode {
    Minimal = "minimal",
    Standard = "standard"
}

// @public
export enum KnownKnowledgeSourceIngestionPermissionOption {
    GroupIds = "groupIds",
    RbacScope = "rbacScope",
    UserIds = "userIds"
}

// @public
export enum KnownKnowledgeSourceKind {
    AzureBlob = "azureBlob",
    IndexedOneLake = "indexedOneLake",
    IndexedSharePoint = "indexedSharePoint",
    RemoteSharePoint = "remoteSharePoint",
    SearchIndex = "searchIndex",
    Web = "web"
}

// @public
export enum KnownKnowledgeSourceSynchronizationStatus {
    Active = "active",
    Creating = "creating",
    Deleting = "deleting"
}

// @public
export enum KnownLexicalAnalyzerName {
    ArLucene = "ar.lucene",
    ArMicrosoft = "ar.microsoft",
    BgLucene = "bg.lucene",
    BgMicrosoft = "bg.microsoft",
    BnMicrosoft = "bn.microsoft",
    CaLucene = "ca.lucene",
    CaMicrosoft = "ca.microsoft",
    CsLucene = "cs.lucene",
    CsMicrosoft = "cs.microsoft",
    DaLucene = "da.lucene",
    DaMicrosoft = "da.microsoft",
    DeLucene = "de.lucene",
    DeMicrosoft = "de.microsoft",
    ElLucene = "el.lucene",
    ElMicrosoft = "el.microsoft",
    EnLucene = "en.lucene",
    EnMicrosoft = "en.microsoft",
    EsLucene = "es.lucene",
    EsMicrosoft = "es.microsoft",
    EtMicrosoft = "et.microsoft",
    EuLucene = "eu.lucene",
    FaLucene = "fa.lucene",
    FiLucene = "fi.lucene",
    FiMicrosoft = "fi.microsoft",
    FrLucene = "fr.lucene",
    FrMicrosoft = "fr.microsoft",
    GaLucene = "ga.lucene",
    GlLucene = "gl.lucene",
    GuMicrosoft = "gu.microsoft",
    HeMicrosoft = "he.microsoft",
    HiLucene = "hi.lucene",
    HiMicrosoft = "hi.microsoft",
    HrMicrosoft = "hr.microsoft",
    HuLucene = "hu.lucene",
    HuMicrosoft = "hu.microsoft",
    HyLucene = "hy.lucene",
    IdLucene = "id.lucene",
    IdMicrosoft = "id.microsoft",
    IsMicrosoft = "is.microsoft",
    ItLucene = "it.lucene",
    ItMicrosoft = "it.microsoft",
    JaLucene = "ja.lucene",
    JaMicrosoft = "ja.microsoft",
    Keyword = "keyword",
    KnMicrosoft = "kn.microsoft",
    KoLucene = "ko.lucene",
    KoMicrosoft = "ko.microsoft",
    LtMicrosoft = "lt.microsoft",
    LvLucene = "lv.lucene",
    LvMicrosoft = "lv.microsoft",
    MlMicrosoft = "ml.microsoft",
    MrMicrosoft = "mr.microsoft",
    MsMicrosoft = "ms.microsoft",
    NbMicrosoft = "nb.microsoft",
    NlLucene = "nl.lucene",
    NlMicrosoft = "nl.microsoft",
    NoLucene = "no.lucene",
    PaMicrosoft = "pa.microsoft",
    Pattern = "pattern",
    PlLucene = "pl.lucene",
    PlMicrosoft = "pl.microsoft",
    PtBrLucene = "pt-BR.lucene",
    PtBrMicrosoft = "pt-BR.microsoft",
    PtPtLucene = "pt-PT.lucene",
    PtPtMicrosoft = "pt-PT.microsoft",
    RoLucene = "ro.lucene",
    RoMicrosoft = "ro.microsoft",
    RuLucene = "ru.lucene",
    RuMicrosoft = "ru.microsoft",
    Simple = "simple",
    SkMicrosoft = "sk.microsoft",
    SlMicrosoft = "sl.microsoft",
    SrCyrillicMicrosoft = "sr-cyrillic.microsoft",
    SrLatinMicrosoft = "sr-latin.microsoft",
    StandardAsciiFoldingLucene = "standardasciifolding.lucene",
    StandardLucene = "standard.lucene",
    Stop = "stop",
    SvLucene = "sv.lucene",
    SvMicrosoft = "sv.microsoft",
    TaMicrosoft = "ta.microsoft",
    TeMicrosoft = "te.microsoft",
    ThLucene = "th.lucene",
    ThMicrosoft = "th.microsoft",
    TrLucene = "tr.lucene",
    TrMicrosoft = "tr.microsoft",
    UkMicrosoft = "uk.microsoft",
    UrMicrosoft = "ur.microsoft",
    ViMicrosoft = "vi.microsoft",
    Whitespace = "whitespace",
    ZhHansLucene = "zh-Hans.lucene",
    ZhHansMicrosoft = "zh-Hans.microsoft",
    ZhHantLucene = "zh-Hant.lucene",
    ZhHantMicrosoft = "zh-Hant.microsoft"
}

// @public
export enum KnownLexicalNormalizerName {
    AsciiFolding = "asciifolding",
    Elision = "elision",
    Lowercase = "lowercase",
    Standard = "standard",
    Uppercase = "uppercase"
}

// @public
export enum KnownLexicalTokenizerName {
    Classic = "classic",
    EdgeNGram = "edgeNGram",
    Keyword = "keyword_v2",
    Letter = "letter",
    Lowercase = "lowercase",
    MicrosoftLanguageStemmingTokenizer = "microsoft_language_stemming_tokenizer",
    MicrosoftLanguageTokenizer = "microsoft_language_tokenizer",
    NGram = "nGram",
    PathHierarchy = "path_hierarchy_v2",
    Pattern = "pattern",
    Standard = "standard_v2",
    UaxUrlEmail = "uax_url_email",
    Whitespace = "whitespace"
}

// @public
export enum KnownMarkdownHeaderDepth {
    H1 = "h1",
    H2 = "h2",
    H3 = "h3",
    H4 = "h4",
    H5 = "h5",
    H6 = "h6"
}

// @public
export enum KnownMarkdownParsingSubmode {
    OneToMany = "oneToMany",
    OneToOne = "oneToOne"
}

// @public
export enum KnownOcrLineEnding {
    CarriageReturn = "carriageReturn",
    CarriageReturnLineFeed = "carriageReturnLineFeed",
    LineFeed = "lineFeed",
    Space = "space"
}

// @public
export enum KnownOcrSkillLanguage {
    Af = "af",
    Anp = "anp",
    Ar = "ar",
    Ast = "ast",
    Awa = "awa",
    Az = "az",
    Be = "be",
    BeCyrl = "be-cyrl",
    BeLatn = "be-latn",
    Bfy = "bfy",
    Bfz = "bfz",
    Bg = "bg",
    Bgc = "bgc",
    Bho = "bho",
    Bi = "bi",
    Bns = "bns",
    Br = "br",
    Bra = "bra",
    Brx = "brx",
    Bs = "bs",
    Bua = "bua",
    Ca = "ca",
    Ceb = "ceb",
    Ch = "ch",
    CnrCyrl = "cnr-cyrl",
    CnrLatn = "cnr-latn",
    Co = "co",
    Crh = "crh",
    Cs = "cs",
    Csb = "csb",
    Cy = "cy",
    Da = "da",
    De = "de",
    Dhi = "dhi",
    Doi = "doi",
    Dsb = "dsb",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Eu = "eu",
    Fa = "fa",
    Fi = "fi",
    Fil = "fil",
    Fj = "fj",
    Fo = "fo",
    Fr = "fr",
    Fur = "fur",
    Fy = "fy",
    Ga = "ga",
    Gag = "gag",
    Gd = "gd",
    Gil = "gil",
    Gl = "gl",
    Gon = "gon",
    Gv = "gv",
    Gvr = "gvr",
    Haw = "haw",
    Hi = "hi",
    Hlb = "hlb",
    Hne = "hne",
    Hni = "hni",
    Hoc = "hoc",
    Hr = "hr",
    Hsb = "hsb",
    Ht = "ht",
    Hu = "hu",
    Ia = "ia",
    Id = "id",
    Is = "is",
    It = "it",
    Iu = "iu",
    Ja = "ja",
    Jns = "Jns",
    Jv = "jv",
    Kaa = "kaa",
    KaaCyrl = "kaa-cyrl",
    Kac = "kac",
    Kea = "kea",
    Kfq = "kfq",
    Kha = "kha",
    KkCyrl = "kk-cyrl",
    KkLatn = "kk-latn",
    Kl = "kl",
    Klr = "klr",
    Kmj = "kmj",
    Ko = "ko",
    Kos = "kos",
    Kpy = "kpy",
    Krc = "krc",
    Kru = "kru",
    Ksh = "ksh",
    KuArab = "ku-arab",
    KuLatn = "ku-latn",
    Kum = "kum",
    Kw = "kw",
    Ky = "ky",
    La = "la",
    Lb = "lb",
    Lkt = "lkt",
    Lt = "lt",
    Mi = "mi",
    Mn = "mn",
    Mr = "mr",
    Ms = "ms",
    Mt = "mt",
    Mww = "mww",
    Myv = "myv",
    Nap = "nap",
    Nb = "nb",
    Ne = "ne",
    Niu = "niu",
    Nl = "nl",
    No = "no",
    Nog = "nog",
    Oc = "oc",
    Os = "os",
    Pa = "pa",
    Pl = "pl",
    Prs = "prs",
    Ps = "ps",
    Pt = "pt",
    Quc = "quc",
    Rab = "rab",
    Rm = "rm",
    Ro = "ro",
    Ru = "ru",
    Sa = "sa",
    Sat = "sat",
    Sck = "sck",
    Sco = "sco",
    Sk = "sk",
    Sl = "sl",
    Sm = "sm",
    Sma = "sma",
    Sme = "sme",
    Smj = "smj",
    Smn = "smn",
    Sms = "sms",
    So = "so",
    Sq = "sq",
    Sr = "sr",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Srx = "srx",
    Sv = "sv",
    Sw = "sw",
    Tet = "tet",
    Tg = "tg",
    Thf = "thf",
    Tk = "tk",
    To = "to",
    Tr = "tr",
    Tt = "tt",
    Tyv = "tyv",
    Ug = "ug",
    Unk = "unk",
    Ur = "ur",
    Uz = "uz",
    UzArab = "uz-arab",
    UzCyrl = "uz-cyrl",
    Vo = "vo",
    Wae = "wae",
    Xnr = "xnr",
    Xsr = "xsr",
    Yua = "yua",
    Za = "za",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant",
    Zu = "zu"
}

// @public
export enum KnownPermissionFilter {
    GroupIds = "groupIds",
    RbacScope = "rbacScope",
    UserIds = "userIds"
}

// @public
export enum KnownPIIDetectionSkillMaskingMode {
    None = "none",
    Replace = "replace"
}

// @public
export enum KnownRankingOrder {
    BoostedRerankerScore = "BoostedRerankerScore",
    ReRankerScore = "RerankerScore"
}

// @public
export enum KnownRegexFlags {
    CanonEq = "CANON_EQ",
    CaseInsensitive = "CASE_INSENSITIVE",
    Comments = "COMMENTS",
    DotAll = "DOTALL",
    Literal = "LITERAL",
    Multiline = "MULTILINE",
    UnicodeCase = "UNICODE_CASE",
    UnixLines = "UNIX_LINES"
}

// @public
export enum KnownSearchFieldDataType {
    Boolean = "Edm.Boolean",
    Byte = "Edm.Byte",
    Complex = "Edm.ComplexType",
    DateTimeOffset = "Edm.DateTimeOffset",
    Double = "Edm.Double",
    GeographyPoint = "Edm.GeographyPoint",
    Half = "Edm.Half",
    Int16 = "Edm.Int16",
    Int32 = "Edm.Int32",
    Int64 = "Edm.Int64",
    SByte = "Edm.SByte",
    Single = "Edm.Single",
    String = "Edm.String"
}

// @public
export enum KnownSearchIndexerDataSourceType {
    AdlsGen2 = "adlsgen2",
    AzureBlob = "azureblob",
    AzureSql = "azuresql",
    AzureTable = "azuretable",
    CosmosDb = "cosmosdb",
    MySql = "mysql",
    OneLake = "onelake",
    SharePoint = "sharepoint"
}

// @public
export enum KnownSearchIndexPermissionFilterOption {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownSplitSkillEncoderModelName {
    CL100KBase = "cl100k_base",
    P50KBase = "p50k_base",
    P50KEdit = "p50k_edit",
    R50KBase = "r50k_base"
}

// @public
export enum KnownSplitSkillLanguage {
    Am = "am",
    Bs = "bs",
    Cs = "cs",
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Et = "et",
    Fi = "fi",
    Fr = "fr",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Lv = "lv",
    Nb = "nb",
    Nl = "nl",
    Pl = "pl",
    Pt = "pt",
    PtBr = "pt-br",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    Sr = "sr",
    Sv = "sv",
    Tr = "tr",
    Ur = "ur",
    Zh = "zh"
}

// @public
export enum KnownSplitSkillUnit {
    AzureOpenAITokens = "azureOpenAITokens",
    Characters = "characters"
}

// @public
export enum KnownTextSplitMode {
    Pages = "pages",
    Sentences = "sentences"
}

// @public
export enum KnownTextTranslationSkillLanguage {
    Af = "af",
    Ar = "ar",
    Bg = "bg",
    Bn = "bn",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Fa = "fa",
    Fi = "fi",
    Fil = "fil",
    Fj = "fj",
    Fr = "fr",
    Ga = "ga",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Ht = "ht",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Ja = "ja",
    Kn = "kn",
    Ko = "ko",
    Lt = "lt",
    Lv = "lv",
    Mg = "mg",
    Mi = "mi",
    Ml = "ml",
    Ms = "ms",
    Mt = "mt",
    Mww = "mww",
    Nb = "nb",
    Nl = "nl",
    Otq = "otq",
    Pa = "pa",
    Pl = "pl",
    Pt = "pt",
    PtBr = "pt-br",
    PtPT = "pt-PT",
    Ro = "ro",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    Sm = "sm",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Sv = "sv",
    Sw = "sw",
    Ta = "ta",
    Te = "te",
    Th = "th",
    Tlh = "tlh",
    TlhLatn = "tlh-Latn",
    TlhPiqd = "tlh-Piqd",
    To = "to",
    Tr = "tr",
    Ty = "ty",
    Uk = "uk",
    Ur = "ur",
    Vi = "vi",
    Yua = "yua",
    Yue = "yue",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export enum KnownTokenFilterName {
    Apostrophe = "apostrophe",
    ArabicNormalization = "arabic_normalization",
    AsciiFolding = "asciifolding",
    CjkBigram = "cjk_bigram",
    CjkWidth = "cjk_width",
    Classic = "classic",
    CommonGram = "common_grams",
    EdgeNGram = "edgeNGram_v2",
    Elision = "elision",
    GermanNormalization = "german_normalization",
    HindiNormalization = "hindi_normalization",
    IndicNormalization = "indic_normalization",
    KeywordRepeat = "keyword_repeat",
    KStem = "kstem",
    Length = "length",
    Limit = "limit",
    Lowercase = "lowercase",
    NGram = "nGram_v2",
    PersianNormalization = "persian_normalization",
    Phonetic = "phonetic",
    PorterStem = "porter_stem",
    Reverse = "reverse",
    ScandinavianFoldingNormalization = "scandinavian_folding",
    ScandinavianNormalization = "scandinavian_normalization",
    Shingle = "shingle",
    Snowball = "snowball",
    SoraniNormalization = "sorani_normalization",
    Stemmer = "stemmer",
    Stopwords = "stopwords",
    Trim = "trim",
    Truncate = "truncate",
    Unique = "unique",
    Uppercase = "uppercase",
    WordDelimiter = "word_delimiter"
}

// @public
export enum KnownVectorEncodingFormat {
    PackedBit = "packedBit"
}

// @public
export enum KnownVectorSearchAlgorithmKind {
    ExhaustiveKnn = "exhaustiveKnn",
    Hnsw = "hnsw"
}

// @public
export enum KnownVectorSearchAlgorithmMetric {
    Cosine = "cosine",
    DotProduct = "dotProduct",
    Euclidean = "euclidean",
    Hamming = "hamming"
}

// @public
export enum KnownVectorSearchCompressionKind {
    BinaryQuantization = "binaryQuantization",
    ScalarQuantization = "scalarQuantization"
}

// @public
export enum KnownVectorSearchCompressionRescoreStorageMethod {
    DiscardOriginals = "discardOriginals",
    PreserveOriginals = "preserveOriginals"
}

// @public
export enum KnownVectorSearchCompressionTarget {
    Int8 = "int8"
}

// @public
export enum KnownVectorSearchVectorizerKind {
    AIServicesVision = "aiServicesVision",
    AML = "aml",
    AzureOpenAI = "azureOpenAI",
    CustomWebApi = "customWebApi"
}

// @public
export enum KnownVisualFeature {
    Adult = "adult",
    Brands = "brands",
    Categories = "categories",
    Description = "description",
    Faces = "faces",
    Objects = "objects",
    Tags = "tags"
}

// @public
export interface LanguageDetectionSkill extends SearchIndexerSkill {
    defaultCountryHint?: string | null;
    modelVersion?: string | null;
    odatatype: "#Microsoft.Skills.Text.LanguageDetectionSkill";
}

// @public
export interface LengthTokenFilter extends TokenFilter {
    maxLength?: number;
    minLength?: number;
    odatatype: "#Microsoft.Azure.Search.LengthTokenFilter";
}

// @public
export interface LexicalAnalyzer {
    name: string;
    odatatype: string;
}

// @public
export type LexicalAnalyzerName = string;

// @public
export type LexicalAnalyzerUnion = CustomAnalyzer | PatternAnalyzer | LuceneStandardAnalyzer | StopAnalyzer | LexicalAnalyzer;

// @public
export interface LexicalNormalizer {
    name: string;
    odatatype: string;
}

// @public
export type LexicalNormalizerName = string;

// @public
export type LexicalNormalizerUnion = CustomNormalizer | LexicalNormalizer;

// @public
export interface LexicalTokenizer {
    name: string;
    odatatype: string;
}

// @public
export type LexicalTokenizerName = string;

// @public
export type LexicalTokenizerUnion = ClassicTokenizer | EdgeNGramTokenizer | KeywordTokenizer | KeywordTokenizerV2 | MicrosoftLanguageTokenizer | MicrosoftLanguageStemmingTokenizer | NGramTokenizer | PathHierarchyTokenizerV2 | PatternTokenizer | LuceneStandardTokenizer | LuceneStandardTokenizerV2 | UaxUrlEmailTokenizer | LexicalTokenizer;

// @public
export interface LimitTokenFilter extends TokenFilter {
    consumeAllTokens?: boolean;
    maxTokenCount?: number;
    odatatype: "#Microsoft.Azure.Search.LimitTokenFilter";
}

// @public
export interface ListDataSourcesResult {
    readonly dataSources: SearchIndexerDataSourceConnection[];
}

// @public
export interface ListIndexersResult {
    readonly indexers: SearchIndexer[];
}

// @public
export interface ListSkillsetsResult {
    readonly skillsets: SearchIndexerSkillset[];
}

// @public
export interface ListSynonymMapsResult {
    readonly synonymMaps: SynonymMap[];
}

// @public
export interface LuceneStandardAnalyzer extends LexicalAnalyzer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.StandardAnalyzer";
    stopwords?: string[];
}

// @public
export interface LuceneStandardTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.StandardTokenizer";
}

// @public
export interface LuceneStandardTokenizerV2 extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.StandardTokenizerV2";
}

// @public
export interface MagnitudeScoringFunction extends ScoringFunction {
    parameters: MagnitudeScoringParameters;
    type: "magnitude";
}

// @public
export interface MagnitudeScoringParameters {
    boostingRangeEnd: number;
    boostingRangeStart: number;
    shouldBoostBeyondRangeByConstant?: boolean;
}

// @public
export interface MappingCharFilter extends CharFilter {
    mappings: string[];
    odatatype: "#Microsoft.Azure.Search.MappingCharFilter";
}

// @public
export type MarkdownHeaderDepth = string;

// @public
export type MarkdownParsingSubmode = string;

// @public
export interface MergeSkill extends SearchIndexerSkill {
    insertPostTag?: string;
    insertPreTag?: string;
    odatatype: "#Microsoft.Skills.Text.MergeSkill";
}

// @public
export interface MicrosoftLanguageStemmingTokenizer extends LexicalTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftStemmingTokenizerLanguage;
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer";
}

// @public
export interface MicrosoftLanguageTokenizer extends LexicalTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftTokenizerLanguage;
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer";
}

// @public
export type MicrosoftStemmingTokenizerLanguage = "arabic" | "bangla" | "bulgarian" | "catalan" | "croatian" | "czech" | "danish" | "dutch" | "english" | "estonian" | "finnish" | "french" | "german" | "greek" | "gujarati" | "hebrew" | "hindi" | "hungarian" | "icelandic" | "indonesian" | "italian" | "kannada" | "latvian" | "lithuanian" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovak" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "turkish" | "ukrainian" | "urdu";

// @public
export type MicrosoftTokenizerLanguage = "bangla" | "bulgarian" | "catalan" | "chineseSimplified" | "chineseTraditional" | "croatian" | "czech" | "danish" | "dutch" | "english" | "french" | "german" | "greek" | "gujarati" | "hindi" | "icelandic" | "indonesian" | "italian" | "japanese" | "kannada" | "korean" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "thai" | "ukrainian" | "urdu" | "vietnamese";

// @public
export interface NativeBlobSoftDeleteDeletionDetectionPolicy extends DataDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy";
}

// @public
export interface NGramTokenFilter extends TokenFilter {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.NGramTokenFilter";
}

// @public
export interface NGramTokenFilterV2 extends TokenFilter {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.NGramTokenFilterV2";
}

// @public
export interface NGramTokenizer extends LexicalTokenizer {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.NGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export type OcrLineEnding = string;

// @public
export interface OcrSkill extends SearchIndexerSkill {
    defaultLanguageCode?: OcrSkillLanguage;
    lineEnding?: OcrLineEnding;
    odatatype: "#Microsoft.Skills.Vision.OcrSkill";
    shouldDetectOrientation?: boolean;
}

// @public
export type OcrSkillLanguage = string;

// @public
export interface OutputFieldMappingEntry {
    name: string;
    targetName?: string;
}

// @public
export interface PathHierarchyTokenizerV2 extends LexicalTokenizer {
    delimiter?: string;
    maxTokenLength?: number;
    numberOfTokensToSkip?: number;
    odatatype: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2";
    replacement?: string;
    reverseTokenOrder?: boolean;
}

// @public
export interface PatternAnalyzer extends LexicalAnalyzer {
    flags?: RegexFlags[];
    lowerCaseTerms?: boolean;
    odatatype: "#Microsoft.Azure.Search.PatternAnalyzer";
    pattern?: string;
    stopwords?: string[];
}

// @public
export interface PatternCaptureTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.PatternCaptureTokenFilter";
    patterns: string[];
    preserveOriginal?: boolean;
}

// @public
export interface PatternReplaceCharFilter extends CharFilter {
    odatatype: "#Microsoft.Azure.Search.PatternReplaceCharFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternReplaceTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.PatternReplaceTokenFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternTokenizer extends LexicalTokenizer {
    flags?: RegexFlags[];
    group?: number;
    odatatype: "#Microsoft.Azure.Search.PatternTokenizer";
    pattern?: string;
}

// @public
export type PermissionFilter = string;

// @public
export type PhoneticEncoder = "metaphone" | "doubleMetaphone" | "soundex" | "refinedSoundex" | "caverphone1" | "caverphone2" | "cologne" | "nysiis" | "koelnerPhonetik" | "haasePhonetik" | "beiderMorse";

// @public
export interface PhoneticTokenFilter extends TokenFilter {
    encoder?: PhoneticEncoder;
    odatatype: "#Microsoft.Azure.Search.PhoneticTokenFilter";
    replaceOriginalTokens?: boolean;
}

// @public
export interface PIIDetectionSkill extends SearchIndexerSkill {
    defaultLanguageCode?: string | null;
    domain?: string | null;
    mask?: string;
    maskingMode?: PIIDetectionSkillMaskingMode;
    minimumPrecision?: number;
    modelVersion?: string | null;
    odatatype: "#Microsoft.Skills.Text.PIIDetectionSkill";
    piiCategories?: string[];
}

// @public
export type PIIDetectionSkillMaskingMode = string;

// @public
export type RankingOrder = string;

// @public
export type RegexFlags = string;

// @public
export interface RemoteSharePointKnowledgeSource extends KnowledgeSource {
    // (undocumented)
    kind: "remoteSharePoint";
    remoteSharePointParameters?: RemoteSharePointKnowledgeSourceParameters;
}

// @public
export interface RemoteSharePointKnowledgeSourceParameters {
    containerTypeId?: string;
    filterExpression?: string;
    resourceMetadata?: string[];
}

// @public
export interface RescoringOptions {
    defaultOversampling?: number | null;
    enableRescoring?: boolean | null;
    rescoreStorageMethod?: VectorSearchCompressionRescoreStorageMethod | null;
}

// @public
export interface ResourceCounter {
    quota?: number | null;
    usage: number;
}

// @public
export interface ScalarQuantizationCompression extends VectorSearchCompression {
    kind: "scalarQuantization";
    parameters?: ScalarQuantizationParameters;
}

// @public
export interface ScalarQuantizationParameters {
    quantizedDataType?: VectorSearchCompressionTarget | null;
}

// @public
export interface ScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    type: string;
}

// @public
export type ScoringFunctionAggregation = "sum" | "average" | "minimum" | "maximum" | "firstMatching" | "product";

// @public
export type ScoringFunctionInterpolation = "linear" | "constant" | "quadratic" | "logarithmic";

// @public
export type ScoringFunctionUnion = DistanceScoringFunction | FreshnessScoringFunction | MagnitudeScoringFunction | TagScoringFunction | ScoringFunction;

// @public
export interface ScoringProfile {
    functionAggregation?: ScoringFunctionAggregation;
    functions?: ScoringFunctionUnion[];
    name: string;
    textWeights?: TextWeights | null;
}

// @public
export interface SearchAlias {
    etag?: string;
    indexes: string[];
    name: string;
}

// @public
export interface SearchField {
    analyzerName?: LexicalAnalyzerName | null;
    facetable?: boolean;
    fields?: SearchField[];
    filterable?: boolean;
    indexAnalyzerName?: LexicalAnalyzerName | null;
    key?: boolean;
    name: string;
    normalizerName?: LexicalNormalizerName | null;
    permissionFilter?: PermissionFilter | null;
    retrievable?: boolean;
    searchable?: boolean;
    searchAnalyzerName?: LexicalAnalyzerName | null;
    sensitivityLabel?: boolean | null;
    sortable?: boolean;
    stored?: boolean;
    synonymMapNames?: string[];
    type: SearchFieldDataType;
    vectorEncodingFormat?: VectorEncodingFormat | null;
    vectorSearchDimensions?: number;
    vectorSearchProfileName?: string | null;
}

// @public
export type SearchFieldDataType = string;

// @public
export interface SearchIndex {
    analyzers?: LexicalAnalyzerUnion[];
    charFilters?: CharFilterUnion[];
    corsOptions?: CorsOptions | null;
    defaultScoringProfile?: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey | null;
    eTag?: string;
    fields: SearchField[];
    name: string;
    normalizers?: LexicalNormalizerUnion[];
    permissionFilterOption?: SearchIndexPermissionFilterOption | null;
    purviewEnabled?: boolean | null;
    scoringProfiles?: ScoringProfile[];
    semanticSearch?: SemanticSearch | null;
    similarity?: SimilarityAlgorithmUnion;
    suggesters?: SearchSuggester[];
    tokenFilters?: TokenFilterUnion[];
    tokenizers?: LexicalTokenizerUnion[];
    vectorSearch?: VectorSearch | null;
}

// @public
export interface SearchIndexer {
    cache?: SearchIndexerCache | null;
    dataSourceName: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey | null;
    eTag?: string;
    fieldMappings?: FieldMapping[];
    isDisabled?: boolean | null;
    name: string;
    outputFieldMappings?: FieldMapping[];
    parameters?: IndexingParameters | null;
    schedule?: IndexingSchedule | null;
    skillsetName?: string;
    targetIndexName: string;
}

// @public
export interface SearchIndexerCache {
    enableReprocessing?: boolean | null;
    id?: string;
    identity?: SearchIndexerDataIdentityUnion | null;
    storageConnectionString?: string;
}

// @public
export interface SearchIndexerDataContainer {
    name: string;
    query?: string;
}

// @public
export interface SearchIndexerDataIdentity {
    odatatype: string;
}

// @public
export type SearchIndexerDataIdentityUnion = SearchIndexerDataNoneIdentity | SearchIndexerDataUserAssignedIdentity | SearchIndexerDataIdentity;

// @public
export interface SearchIndexerDataNoneIdentity extends SearchIndexerDataIdentity {
    odatatype: "#Microsoft.Azure.Search.DataNoneIdentity";
}

// @public
export interface SearchIndexerDataSourceConnection {
    connectionString?: string;
    container: SearchIndexerDataContainer;
    dataChangeDetectionPolicy?: DataChangeDetectionPolicyUnion | null;
    dataDeletionDetectionPolicy?: DataDeletionDetectionPolicyUnion | null;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey | null;
    eTag?: string;
    identity?: SearchIndexerDataIdentityUnion | null;
    indexerPermissionOptions?: IndexerPermissionOption[] | null;
    name: string;
    readonly subType?: string;
    type: SearchIndexerDataSourceType;
}

// @public
export type SearchIndexerDataSourceType = string;

// @public
export interface SearchIndexerDataUserAssignedIdentity extends SearchIndexerDataIdentity {
    odatatype: "#Microsoft.Azure.Search.DataUserAssignedIdentity";
    resourceId: string;
}

// @public
export interface SearchIndexerError {
    readonly details?: string;
    readonly documentationLink?: string;
    readonly errorMessage: string;
    readonly key?: string;
    readonly name?: string;
    readonly statusCode: number;
}

// @public
export interface SearchIndexerIndexProjection {
    parameters?: SearchIndexerIndexProjectionsParameters;
    selectors: SearchIndexerIndexProjectionSelector[];
}

// @public
export interface SearchIndexerIndexProjectionSelector {
    mappings: InputFieldMappingEntry[];
    parentKeyFieldName: string;
    sourceContext: string;
    targetIndexName: string;
}

// @public
export interface SearchIndexerIndexProjectionsParameters {
    additionalProperties?: Record<string, any>;
    projectionMode?: IndexProjectionMode;
}

// @public
export interface SearchIndexerKnowledgeStore {
    identity?: SearchIndexerDataIdentityUnion | null;
    parameters?: SearchIndexerKnowledgeStoreParameters;
    projections: SearchIndexerKnowledgeStoreProjection[];
    storageConnectionString: string;
}

// @public
export interface SearchIndexerKnowledgeStoreBlobProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
    storageContainer: string;
}

// @public
export interface SearchIndexerKnowledgeStoreFileProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector {
}

// @public
export interface SearchIndexerKnowledgeStoreObjectProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector {
}

// @public
export interface SearchIndexerKnowledgeStoreParameters {
    additionalProperties?: Record<string, any>;
    synthesizeGeneratedKeyName?: boolean;
}

// @public
export interface SearchIndexerKnowledgeStoreProjection {
    files?: SearchIndexerKnowledgeStoreFileProjectionSelector[];
    objects?: SearchIndexerKnowledgeStoreObjectProjectionSelector[];
    tables?: SearchIndexerKnowledgeStoreTableProjectionSelector[];
}

// @public
export interface SearchIndexerKnowledgeStoreProjectionSelector {
    generatedKeyName?: string;
    inputs?: InputFieldMappingEntry[];
    referenceKeyName?: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface SearchIndexerKnowledgeStoreTableProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
    generatedKeyName: string;
    tableName: string;
}

// @public
export interface SearchIndexerLimits {
    readonly maxDocumentContentCharactersToExtract?: number;
    readonly maxDocumentExtractionSize?: number;
    readonly maxRunTime?: string;
}

// @public
export interface SearchIndexerSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: string;
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface SearchIndexerSkillset {
    cognitiveServicesAccount?: CognitiveServicesAccountUnion;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey | null;
    eTag?: string;
    indexProjection?: SearchIndexerIndexProjection;
    knowledgeStore?: SearchIndexerKnowledgeStore;
    name: string;
    skills: SearchIndexerSkillUnion[];
}

// @public
export type SearchIndexerSkillUnion = ConditionalSkill | KeyPhraseExtractionSkill | OcrSkill | ImageAnalysisSkill | LanguageDetectionSkill | ShaperSkill | MergeSkill | SentimentSkillV3 | EntityLinkingSkill | EntityRecognitionSkillV3 | PIIDetectionSkill | SplitSkill | CustomEntityLookupSkill | TextTranslationSkill | DocumentExtractionSkill | DocumentIntelligenceLayoutSkill | WebApiSkill | AzureMachineLearningSkill | AzureOpenAIEmbeddingSkill | VisionVectorizeSkill | ContentUnderstandingSkill | ChatCompletionSkill | SearchIndexerSkill;

// @public
export interface SearchIndexerStatus {
    readonly currentState?: IndexerCurrentState;
    readonly executionHistory: IndexerExecutionResult[];
    readonly lastResult?: IndexerExecutionResult;
    readonly limits: SearchIndexerLimits;
    readonly name: string;
    readonly runtime: IndexerRuntime;
    readonly status: IndexerStatus;
}

// @public
export interface SearchIndexerWarning {
    readonly details?: string;
    readonly documentationLink?: string;
    readonly key?: string;
    readonly message: string;
    readonly name?: string;
}

// @public
export interface SearchIndexFieldReference {
    name: string;
}

// @public
export interface SearchIndexKnowledgeSource extends KnowledgeSource {
    // (undocumented)
    kind: "searchIndex";
    searchIndexParameters: SearchIndexKnowledgeSourceParameters;
}

// @public
export interface SearchIndexKnowledgeSourceParameters {
    searchFields?: SearchIndexFieldReference[];
    searchIndexName: string;
    semanticConfigurationName?: string;
    sourceDataFields?: SearchIndexFieldReference[];
}

// @public
export type SearchIndexPermissionFilterOption = string;

// @public
export interface SearchResourceEncryptionKey {
    applicationId?: string;
    applicationSecret?: string;
    identity?: SearchIndexerDataIdentityUnion | null;
    keyName: string;
    keyVersion?: string;
    vaultUri: string;
}

// @public
export interface SearchServiceStatistics {
    counters: ServiceCounters;
    indexersRuntime: ServiceIndexersRuntime;
    limits: ServiceLimits;
}

// @public
export interface SearchSuggester {
    name: string;
    searchMode: "analyzingInfixMatching";
    sourceFields: string[];
}

// @public
export interface SemanticConfiguration {
    flightingOptIn?: boolean;
    name: string;
    prioritizedFields: SemanticPrioritizedFields;
    rankingOrder?: RankingOrder | null;
}

// @public
export interface SemanticField {
    name: string;
}

// @public
export interface SemanticPrioritizedFields {
    contentFields?: SemanticField[];
    keywordsFields?: SemanticField[];
    titleField?: SemanticField;
}

// @public
export interface SemanticSearch {
    configurations?: SemanticConfiguration[];
    defaultConfigurationName?: string;
}

// @public
export interface SentimentSkillV3 extends SearchIndexerSkill {
    defaultLanguageCode?: string | null;
    includeOpinionMining?: boolean;
    modelVersion?: string | null;
    odatatype: "#Microsoft.Skills.Text.V3.SentimentSkill";
}

// @public
export interface ServiceCounters {
    aliasCounter: ResourceCounter;
    dataSourceCounter: ResourceCounter;
    documentCounter: ResourceCounter;
    indexCounter: ResourceCounter;
    indexerCounter: ResourceCounter;
    skillsetCounter: ResourceCounter;
    storageSizeCounter: ResourceCounter;
    synonymMapCounter: ResourceCounter;
    vectorIndexSizeCounter: ResourceCounter;
}

// @public
export interface ServiceIndexersRuntime {
    beginningTime: Date;
    endingTime: Date;
    remainingSeconds?: number | null;
    usedSeconds: number;
}

// @public
export interface ServiceLimits {
    maxComplexCollectionFieldsPerIndex?: number | null;
    maxComplexObjectsInCollectionsPerDocument?: number | null;
    maxCumulativeIndexerRuntimeSeconds?: number | null;
    maxFieldNestingDepthPerIndex?: number | null;
    maxFieldsPerIndex?: number | null;
    maxStoragePerIndexInBytes?: number | null;
}

// @public
export interface ShaperSkill extends SearchIndexerSkill {
    odatatype: "#Microsoft.Skills.Util.ShaperSkill";
}

// @public
export interface ShingleTokenFilter extends TokenFilter {
    filterToken?: string;
    maxShingleSize?: number;
    minShingleSize?: number;
    odatatype: "#Microsoft.Azure.Search.ShingleTokenFilter";
    outputUnigrams?: boolean;
    outputUnigramsIfNoShingles?: boolean;
    tokenSeparator?: string;
}

// @public
export interface SimilarityAlgorithm {
    odatatype: string;
}

// @public
export type SimilarityAlgorithmUnion = ClassicSimilarity | BM25Similarity | SimilarityAlgorithm;

// @public
export interface SkillNames {
    skillNames?: string[];
}

// @public
export interface SnowballTokenFilter extends TokenFilter {
    language: SnowballTokenFilterLanguage;
    odatatype: "#Microsoft.Azure.Search.SnowballTokenFilter";
}

// @public
export type SnowballTokenFilterLanguage = "armenian" | "basque" | "catalan" | "danish" | "dutch" | "english" | "finnish" | "french" | "german" | "german2" | "hungarian" | "italian" | "kp" | "lovins" | "norwegian" | "porter" | "portuguese" | "romanian" | "russian" | "spanish" | "swedish" | "turkish";

// @public
export interface SoftDeleteColumnDeletionDetectionPolicy extends DataDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
    softDeleteColumnName?: string;
    softDeleteMarkerValue?: string;
}

// @public
export interface SplitSkill extends SearchIndexerSkill {
    azureOpenAITokenizerParameters?: AzureOpenAITokenizerParameters | null;
    defaultLanguageCode?: SplitSkillLanguage;
    maximumPageLength?: number | null;
    maximumPagesToTake?: number | null;
    odatatype: "#Microsoft.Skills.Text.SplitSkill";
    pageOverlapLength?: number | null;
    textSplitMode?: TextSplitMode;
    unit?: SplitSkillUnit | null;
}

// @public
export type SplitSkillEncoderModelName = string;

// @public
export type SplitSkillLanguage = string;

// @public
export type SplitSkillUnit = string;

// @public
export interface SqlIntegratedChangeTrackingPolicy extends DataChangeDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
}

// @public
export interface StemmerOverrideTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter";
    rules: string[];
}

// @public
export interface StemmerTokenFilter extends TokenFilter {
    language: StemmerTokenFilterLanguage;
    odatatype: "#Microsoft.Azure.Search.StemmerTokenFilter";
}

// @public
export type StemmerTokenFilterLanguage = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "dutchKp" | "english" | "lightEnglish" | "minimalEnglish" | "possessiveEnglish" | "porter2" | "lovins" | "finnish" | "lightFinnish" | "french" | "lightFrench" | "minimalFrench" | "galician" | "minimalGalician" | "german" | "german2" | "lightGerman" | "minimalGerman" | "greek" | "hindi" | "hungarian" | "lightHungarian" | "indonesian" | "irish" | "italian" | "lightItalian" | "sorani" | "latvian" | "norwegian" | "lightNorwegian" | "minimalNorwegian" | "lightNynorsk" | "minimalNynorsk" | "portuguese" | "lightPortuguese" | "minimalPortuguese" | "portugueseRslp" | "romanian" | "russian" | "lightRussian" | "spanish" | "lightSpanish" | "swedish" | "lightSwedish" | "turkish";

// @public
export interface StopAnalyzer extends LexicalAnalyzer {
    odatatype: "#Microsoft.Azure.Search.StopAnalyzer";
    stopwords?: string[];
}

// @public
export type StopwordsList = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "english" | "finnish" | "french" | "galician" | "german" | "greek" | "hindi" | "hungarian" | "indonesian" | "irish" | "italian" | "latvian" | "norwegian" | "persian" | "portuguese" | "romanian" | "russian" | "sorani" | "spanish" | "swedish" | "thai" | "turkish";

// @public
export interface StopwordsTokenFilter extends TokenFilter {
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.StopwordsTokenFilter";
    removeTrailingStopWords?: boolean;
    stopwords?: string[];
    stopwordsList?: StopwordsList;
}

// @public
export interface SynonymMap {
    encryptionKey?: SearchResourceEncryptionKey | null;
    eTag?: string;
    format: "solr";
    name: string;
    synonyms: string[];
}

// @public
export interface SynonymTokenFilter extends TokenFilter {
    expand?: boolean;
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.SynonymTokenFilter";
    synonyms: string[];
}

// @public
export interface TagScoringFunction extends ScoringFunction {
    parameters: TagScoringParameters;
    type: "tag";
}

// @public
export interface TagScoringParameters {
    tagsParameter: string;
}

// @public
export type TextSplitMode = string;

// @public
export interface TextTranslationSkill extends SearchIndexerSkill {
    defaultFromLanguageCode?: TextTranslationSkillLanguage;
    defaultToLanguageCode: TextTranslationSkillLanguage;
    odatatype: "#Microsoft.Skills.Text.TranslationSkill";
    suggestedFrom?: TextTranslationSkillLanguage | null;
}

// @public
export type TextTranslationSkillLanguage = string;

// @public
export interface TextWeights {
    weights: Record<string, number>;
}

// @public
export type TokenCharacterKind = "letter" | "digit" | "whitespace" | "punctuation" | "symbol";

// @public
export interface TokenFilter {
    name: string;
    odatatype: string;
}

// @public
export type TokenFilterName = string;

// @public
export type TokenFilterUnion = AsciiFoldingTokenFilter | CjkBigramTokenFilter | CommonGramTokenFilter | DictionaryDecompounderTokenFilter | EdgeNGramTokenFilter | EdgeNGramTokenFilterV2 | ElisionTokenFilter | KeepTokenFilter | KeywordMarkerTokenFilter | LengthTokenFilter | LimitTokenFilter | NGramTokenFilter | NGramTokenFilterV2 | PatternCaptureTokenFilter | PatternReplaceTokenFilter | PhoneticTokenFilter | ShingleTokenFilter | SnowballTokenFilter | StemmerTokenFilter | StemmerOverrideTokenFilter | StopwordsTokenFilter | SynonymTokenFilter | TruncateTokenFilter | UniqueTokenFilter | WordDelimiterTokenFilter | TokenFilter;

// @public
export interface TruncateTokenFilter extends TokenFilter {
    length?: number;
    odatatype: "#Microsoft.Azure.Search.TruncateTokenFilter";
}

// @public
export interface UaxUrlEmailTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
}

// @public
export interface UniqueTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.UniqueTokenFilter";
    onlyOnSamePosition?: boolean;
}

// @public
export type VectorEncodingFormat = string;

// @public
export interface VectorSearch {
    algorithms?: VectorSearchAlgorithmConfigurationUnion[];
    compressions?: VectorSearchCompressionUnion[];
    profiles?: VectorSearchProfile[];
    vectorizers?: VectorSearchVectorizerUnion[];
}

// @public
export interface VectorSearchAlgorithmConfiguration {
    kind: VectorSearchAlgorithmKind;
    name: string;
}

// @public
export type VectorSearchAlgorithmConfigurationUnion = HnswAlgorithmConfiguration | ExhaustiveKnnAlgorithmConfiguration | VectorSearchAlgorithmConfiguration;

// @public
export type VectorSearchAlgorithmKind = string;

// @public
export type VectorSearchAlgorithmMetric = string;

// @public
export interface VectorSearchCompression {
    compressionName: string;
    kind: VectorSearchCompressionKind;
    rescoringOptions?: RescoringOptions | null;
    truncationDimension?: number | null;
}

// @public
export type VectorSearchCompressionKind = string;

// @public
export type VectorSearchCompressionRescoreStorageMethod = string;

// @public
export type VectorSearchCompressionTarget = string;

// @public
export type VectorSearchCompressionUnion = ScalarQuantizationCompression | BinaryQuantizationCompression | VectorSearchCompression;

// @public
export interface VectorSearchProfile {
    algorithmConfigurationName: string;
    compressionName?: string;
    name: string;
    vectorizerName?: string;
}

// @public
export interface VectorSearchVectorizer {
    kind: VectorSearchVectorizerKind;
    vectorizerName: string;
}

// @public
export type VectorSearchVectorizerKind = string;

// @public
export type VectorSearchVectorizerUnion = AzureOpenAIVectorizer | WebApiVectorizer | AIServicesVisionVectorizer | AzureMachineLearningVectorizer | VectorSearchVectorizer;

// @public
export interface VisionVectorizeSkill extends SearchIndexerSkill {
    modelVersion: string | null;
    odatatype: "#Microsoft.Skills.Vision.VectorizeSkill";
}

// @public
export type VisualFeature = string;

// @public
export interface WebApiHttpHeaders {
    additionalProperties?: Record<string, string>;
}

// @public
export interface WebApiSkill extends SearchIndexerSkill {
    authIdentity?: SearchIndexerDataIdentityUnion | null;
    authResourceId?: string | null;
    batchSize?: number | null;
    degreeOfParallelism?: number | null;
    httpHeaders?: WebApiHttpHeaders;
    httpMethod?: string;
    odatatype: "#Microsoft.Skills.Custom.WebApiSkill";
    timeout?: string;
    uri: string;
}

// @public
export interface WebApiVectorizer extends VectorSearchVectorizer {
    kind: "customWebApi";
    webApiParameters?: WebApiVectorizerParameters;
}

// @public
export interface WebApiVectorizerParameters {
    authIdentity?: SearchIndexerDataIdentityUnion | null;
    authResourceId?: string | null;
    httpHeaders?: Record<string, string>;
    httpMethod?: string;
    timeout?: string;
    uri?: string;
}

// @public
export interface WebKnowledgeSource extends KnowledgeSource {
    // (undocumented)
    kind: "web";
    webParameters?: WebKnowledgeSourceParameters;
}

// @public
export interface WebKnowledgeSourceDomain {
    address: string;
    includeSubpages?: boolean;
}

// @public
export interface WebKnowledgeSourceDomains {
    allowedDomains?: WebKnowledgeSourceDomain[];
    blockedDomains?: WebKnowledgeSourceDomain[];
}

// @public
export interface WebKnowledgeSourceParameters {
    domains?: WebKnowledgeSourceDomains;
}

// @public
export interface WordDelimiterTokenFilter extends TokenFilter {
    catenateAll?: boolean;
    catenateNumbers?: boolean;
    catenateWords?: boolean;
    generateNumberParts?: boolean;
    generateWordParts?: boolean;
    odatatype: "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
    preserveOriginal?: boolean;
    protectedWords?: string[];
    splitOnCaseChange?: boolean;
    splitOnNumerics?: boolean;
    stemEnglishPossessive?: boolean;
}

// (No @packageDocumentation comment for this package)

```
