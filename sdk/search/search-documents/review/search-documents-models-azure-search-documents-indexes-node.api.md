## API Report File for "@azure/search-documents"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AIFoundryModelCatalogName = string;

// @public
export interface AIServicesAccountIdentity extends CognitiveServicesAccount {
    identity?: SearchIndexerDataIdentityUnion;
    odatatype: "#Microsoft.Azure.Search.AIServicesByIdentity";
    subdomainUrl: string;
}

// @public
export interface AIServicesAccountKey extends CognitiveServicesAccount {
    key: string;
    odatatype: "#Microsoft.Azure.Search.AIServicesByKey";
    subdomainUrl: string;
}

// @public
export interface AIServicesVisionParameters {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    modelVersion: string;
    resourceUri: string;
}

// @public
export interface AIServicesVisionVectorizer extends VectorSearchVectorizer {
    aiServicesVisionParameters?: AIServicesVisionParameters;
    kind: "aiServicesVision";
}

// @public
export interface AnalyzedTokenInfo {
    endOffset: number;
    position: number;
    startOffset: number;
    token: string;
}

// @public
export interface AnalyzeResult {
    tokens: AnalyzedTokenInfo[];
}

// @public
export interface AnalyzeTextOptions {
    analyzerName?: LexicalAnalyzerName;
    charFilters?: CharFilterName[];
    normalizerName?: LexicalNormalizerName;
    text: string;
    tokenFilters?: TokenFilterName[];
    tokenizerName?: LexicalTokenizerName;
}

// @public
export interface AsciiFoldingTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter";
    preserveOriginal?: boolean;
}

// @public
export interface AzureActiveDirectoryApplicationCredentials {
    applicationId: string;
    applicationSecret?: string;
}

// @public
export interface AzureBlobKnowledgeSource extends KnowledgeSource {
    azureBlobParameters: AzureBlobKnowledgeSourceParameters;
    // (undocumented)
    kind: "azureBlob";
}

// @public
export interface AzureBlobKnowledgeSourceParameters {
    chatCompletionModel?: KnowledgeBaseModelUnion;
    connectionString: string;
    containerName: string;
    readonly createdResources?: CreatedResources;
    disableImageVerbalization?: boolean;
    embeddingModel?: VectorSearchVectorizerUnion;
    folderPath?: string;
    identity?: SearchIndexerDataIdentityUnion;
    ingestionSchedule?: IndexingSchedule;
}

// @public
export interface AzureMachineLearningParameters {
    authenticationKey?: string;
    modelName?: AIFoundryModelCatalogName;
    region?: string;
    resourceId?: string;
    scoringUri: string;
    timeout?: string;
}

// @public
export interface AzureMachineLearningSkill extends SearchIndexerSkill {
    authenticationKey?: string;
    degreeOfParallelism?: number;
    odatatype: "#Microsoft.Skills.Custom.AmlSkill";
    region?: string;
    resourceId?: string;
    scoringUri?: string;
    timeout?: string;
}

// @public
export interface AzureMachineLearningVectorizer extends VectorSearchVectorizer {
    amlParameters?: AzureMachineLearningParameters;
    kind: "aml";
}

// @public
export interface AzureOpenAIEmbeddingSkill extends SearchIndexerSkill {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    deploymentName?: string;
    dimensions?: number;
    modelName?: AzureOpenAIModelName;
    odatatype: "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill";
    resourceUrl?: string;
}

// @public
export type AzureOpenAIModelName = string;

// @public
export interface AzureOpenAiParameters {
    apiKey?: string;
    authenticationMethod?: string;
    authIdentity?: string;
    deploymentId: string;
    modelName?: AzureOpenAIModelName;
    resourceUri: string;
}

// @public
export interface AzureOpenAITokenizerParameters {
    allowedSpecialTokens?: string[];
    encoderModelName?: SplitSkillEncoderModelName;
}

// @public
export interface AzureOpenAIVectorizer extends VectorSearchVectorizer {
    kind: "azureOpenAI";
    parameters?: AzureOpenAIVectorizerParameters;
}

// @public
export interface AzureOpenAIVectorizerParameters {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    deploymentName?: string;
    modelName?: AzureOpenAIModelName;
    resourceUrl?: string;
}

// @public
export interface BinaryQuantizationCompression extends VectorSearchCompression {
    kind: "binaryQuantization";
}

// @public
export type BlobIndexerDataToExtract = string;

// @public
export type BlobIndexerImageAction = string;

// @public
export type BlobIndexerParsingMode = string;

// @public
export type BlobIndexerPDFTextRotationAlgorithm = string;

// @public
export interface BM25Similarity extends SimilarityAlgorithm {
    b?: number;
    k1?: number;
    odatatype: "#Microsoft.Azure.Search.BM25Similarity";
}

// @public
export interface CharFilter {
    name: string;
    odatatype: string;
}

// @public
export type CharFilterName = string;

// @public
export type CharFilterUnion = MappingCharFilter | PatternReplaceCharFilter | CharFilter;

// @public
export type ChatCompletionExtraParametersBehavior = string;

// @public
export interface ChatCompletionResponseFormat {
    jsonSchemaProperties?: ChatCompletionSchemaProperties;
    type?: ChatCompletionResponseFormatType;
}

// @public
export type ChatCompletionResponseFormatType = string;

// @public
export interface ChatCompletionSchema {
    additionalProperties?: boolean;
    properties?: string;
    required?: string[];
    type?: string;
}

// @public
export interface ChatCompletionSchemaProperties {
    description?: string;
    name?: string;
    schema?: ChatCompletionSchema;
    strict?: boolean;
}

// @public
export interface ChatCompletionSkill extends SearchIndexerSkill {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentityUnion;
    authResourceId?: string;
    batchSize?: number;
    commonModelParameters?: CommonModelParameters;
    degreeOfParallelism?: number;
    extraParameters?: Record<string, any>;
    extraParametersBehavior?: ChatCompletionExtraParametersBehavior;
    httpHeaders?: WebApiHttpHeaders;
    httpMethod?: string;
    odataType: "#Microsoft.Skills.Custom.ChatCompletionSkill";
    responseFormat?: ChatCompletionResponseFormat;
    timeout?: string;
    uri: string;
}

// @public
export interface CjkBigramTokenFilter extends TokenFilter {
    ignoreScripts?: CjkBigramTokenFilterScripts[];
    odatatype: "#Microsoft.Azure.Search.CjkBigramTokenFilter";
    outputUnigrams?: boolean;
}

// @public
export type CjkBigramTokenFilterScripts = string;

// @public
export interface ClassicSimilarity extends SimilarityAlgorithm {
    odatatype: "#Microsoft.Azure.Search.ClassicSimilarity";
}

// @public
export interface ClassicTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.ClassicTokenizer";
}

// @public
export interface CognitiveServicesAccount {
    description?: string;
    odatatype: string;
}

// @public
export interface CognitiveServicesAccountKey extends CognitiveServicesAccount {
    key: string;
    odatatype: "#Microsoft.Azure.Search.CognitiveServicesByKey";
}

// @public
export type CognitiveServicesAccountUnion = DefaultCognitiveServicesAccount | CognitiveServicesAccountKey | AIServicesAccountKey | AIServicesAccountIdentity | CognitiveServicesAccount;

// @public
export interface CommonGramTokenFilter extends TokenFilter {
    commonWords: string[];
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.CommonGramTokenFilter";
    useQueryMode?: boolean;
}

// @public
export interface CommonModelParameters {
    frequencyPenalty?: number;
    maxTokens?: number;
    modelName?: string;
    presencePenalty?: number;
    seed?: number;
    stop?: string[];
    temperature?: number;
}

// @public
export interface ConditionalSkill extends SearchIndexerSkill {
    odatatype: "#Microsoft.Skills.Util.ConditionalSkill";
}

// @public
export interface ContentUnderstandingSkill extends SearchIndexerSkill {
    chunkingProperties?: ContentUnderstandingSkillChunkingProperties;
    extractionOptions?: ContentUnderstandingSkillExtractionOptions[];
    odataType: "#Microsoft.Skills.Util.ContentUnderstandingSkill";
}

// @public
export interface ContentUnderstandingSkillChunkingProperties {
    maximumLength?: number;
    overlapLength?: number;
    unit?: ContentUnderstandingSkillChunkingUnit;
}

// @public
export type ContentUnderstandingSkillChunkingUnit = string;

// @public
export type ContentUnderstandingSkillExtractionOptions = string;

// @public
export interface CorsOptions {
    allowedOrigins: string[];
    maxAgeInSeconds?: number;
}

// @public
export interface CreatedResources {
    additionalProperties?: Record<string, string>;
}

// @public
export interface CustomAnalyzer extends LexicalAnalyzer {
    charFilters?: CharFilterName[];
    odatatype: "#Microsoft.Azure.Search.CustomAnalyzer";
    tokenFilters?: TokenFilterName[];
    tokenizer: LexicalTokenizerName;
}

// @public
export interface CustomEntity {
    accentSensitive?: boolean;
    aliases?: CustomEntityAlias[];
    caseSensitive?: boolean;
    defaultAccentSensitive?: boolean;
    defaultCaseSensitive?: boolean;
    defaultFuzzyEditDistance?: number;
    description?: string;
    fuzzyEditDistance?: number;
    id?: string;
    name: string;
    subtype?: string;
    type?: string;
}

// @public
export interface CustomEntityAlias {
    accentSensitive?: boolean;
    caseSensitive?: boolean;
    fuzzyEditDistance?: number;
    text: string;
}

// @public
export interface CustomEntityLookupSkill extends SearchIndexerSkill {
    defaultLanguageCode?: CustomEntityLookupSkillLanguage;
    entitiesDefinitionUri?: string;
    globalDefaultAccentSensitive?: boolean;
    globalDefaultCaseSensitive?: boolean;
    globalDefaultFuzzyEditDistance?: number;
    inlineEntitiesDefinition?: CustomEntity[];
    odatatype: "#Microsoft.Skills.Text.CustomEntityLookupSkill";
}

// @public
export type CustomEntityLookupSkillLanguage = string;

// @public
export interface CustomNormalizer extends LexicalNormalizer {
    charFilters?: CharFilterName[];
    odatatype: "#Microsoft.Azure.Search.CustomNormalizer";
    tokenFilters?: TokenFilterName[];
}

// @public
export interface DataChangeDetectionPolicy {
    odatatype: string;
}

// @public
export type DataChangeDetectionPolicyUnion = HighWaterMarkChangeDetectionPolicy | SqlIntegratedChangeTrackingPolicy | DataChangeDetectionPolicy;

// @public
export interface DataDeletionDetectionPolicy {
    odatatype: string;
}

// @public
export type DataDeletionDetectionPolicyUnion = SoftDeleteColumnDeletionDetectionPolicy | NativeBlobSoftDeleteDeletionDetectionPolicy | DataDeletionDetectionPolicy;

// @public
export interface DataSourceCredentials {
    connectionString?: string;
}

// @public
export interface DefaultCognitiveServicesAccount extends CognitiveServicesAccount {
    odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices";
}

// @public
export interface DictionaryDecompounderTokenFilter extends TokenFilter {
    maxSubwordSize?: number;
    minSubwordSize?: number;
    minWordSize?: number;
    odatatype: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter";
    onlyLongestMatch?: boolean;
    wordList: string[];
}

// @public
export interface DistanceScoringFunction extends ScoringFunction {
    parameters: DistanceScoringParameters;
    type: "distance";
}

// @public
export interface DistanceScoringParameters {
    boostingDistance: number;
    referencePointParameter: string;
}

// @public
export interface DocumentExtractionSkill extends SearchIndexerSkill {
    configuration?: Record<string, any>;
    dataToExtract?: string;
    odatatype: "#Microsoft.Skills.Util.DocumentExtractionSkill";
    parsingMode?: string;
}

// @public
export interface DocumentIntelligenceLayoutSkill extends SearchIndexerSkill {
    chunkingProperties?: DocumentIntelligenceLayoutSkillChunkingProperties;
    extractionOptions?: DocumentIntelligenceLayoutSkillExtractionOptions[];
    markdownHeaderDepth?: DocumentIntelligenceLayoutSkillMarkdownHeaderDepth;
    odatatype: "#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill";
    outputFormat?: DocumentIntelligenceLayoutSkillOutputFormat;
    outputMode?: DocumentIntelligenceLayoutSkillOutputMode;
}

// @public
export interface DocumentIntelligenceLayoutSkillChunkingProperties {
    maximumLength?: number;
    overlapLength?: number;
    unit?: DocumentIntelligenceLayoutSkillChunkingUnit;
}

// @public
export type DocumentIntelligenceLayoutSkillChunkingUnit = string;

// @public
export type DocumentIntelligenceLayoutSkillExtractionOptions = string;

// @public
export type DocumentIntelligenceLayoutSkillMarkdownHeaderDepth = string;

// @public
export type DocumentIntelligenceLayoutSkillOutputFormat = string;

// @public
export type DocumentIntelligenceLayoutSkillOutputMode = string;

// @public
export interface DocumentKeysOrIds {
    datasourceDocumentIds?: string[];
    documentKeys?: string[];
}

// @public
export interface EdgeNGramTokenFilter extends TokenFilter {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2";
    side?: EdgeNGramTokenFilterSide;
}

// @public
export type EdgeNGramTokenFilterSide = string;

// @public
export interface EdgeNGramTokenizer extends LexicalTokenizer {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export interface ElisionTokenFilter extends TokenFilter {
    articles?: string[];
    odatatype: "#Microsoft.Azure.Search.ElisionTokenFilter";
}

// @public
export type EntityCategory = string;

// @public
export interface EntityLinkingSkill extends SearchIndexerSkill {
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.V3.EntityLinkingSkill";
}

// @public
export interface EntityRecognitionSkill extends SearchIndexerSkill {
    categories?: EntityCategory[];
    defaultLanguageCode?: EntityRecognitionSkillLanguage;
    includeTypelessEntities?: boolean;
    minimumPrecision?: number;
    odatatype: "#Microsoft.Skills.Text.EntityRecognitionSkill";
}

// @public
export type EntityRecognitionSkillLanguage = string;

// @public
export interface EntityRecognitionSkillV3 extends SearchIndexerSkill {
    categories?: string[];
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.V3.EntityRecognitionSkill";
}

// @public
export interface ExhaustiveKnnAlgorithmConfiguration extends VectorSearchAlgorithmConfiguration {
    kind: "exhaustiveKnn";
    parameters?: ExhaustiveKnnParameters;
}

// @public
export interface ExhaustiveKnnParameters {
    metric?: VectorSearchAlgorithmMetric;
}

// @public
export interface FieldMapping {
    mappingFunction?: FieldMappingFunction;
    sourceFieldName: string;
    targetFieldName?: string;
}

// @public
export interface FieldMappingFunction {
    name: string;
    parameters?: Record<string, any>;
}

// @public
export interface FreshnessScoringFunction extends ScoringFunction {
    parameters: FreshnessScoringParameters;
    type: "freshness";
}

// @public
export interface FreshnessScoringParameters {
    boostingDuration: string;
}

// @public
export interface GetIndexStatisticsResult {
    documentCount: number;
    storageSize: number;
    vectorIndexSize: number;
}

// @public
export interface HighWaterMarkChangeDetectionPolicy extends DataChangeDetectionPolicy {
    highWaterMarkColumnName: string;
    odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy";
}

// @public
export interface HnswAlgorithmConfiguration extends VectorSearchAlgorithmConfiguration {
    kind: "hnsw";
    parameters?: HnswParameters;
}

// @public
export interface HnswParameters {
    efConstruction?: number;
    efSearch?: number;
    m?: number;
    metric?: VectorSearchAlgorithmMetric;
}

// @public
export interface ImageAnalysisSkill extends SearchIndexerSkill {
    defaultLanguageCode?: ImageAnalysisSkillLanguage;
    details?: ImageDetail[];
    odatatype: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
    visualFeatures?: VisualFeature[];
}

// @public
export type ImageAnalysisSkillLanguage = string;

// @public
export type ImageDetail = string;

// @public
export interface IndexerCurrentState {
    readonly allDocsFinalTrackingState?: string;
    readonly allDocsInitialTrackingState?: string;
    readonly mode?: IndexingMode;
    readonly resetDatasourceDocumentIds?: string[];
    readonly resetDocsFinalTrackingState?: string;
    readonly resetDocsInitialTrackingState?: string;
    readonly resetDocumentKeys?: string[];
    readonly resyncFinalTrackingState?: string;
    readonly resyncInitialTrackingState?: string;
}

// @public
export type IndexerExecutionEnvironment = string;

// @public
export interface IndexerExecutionResult {
    readonly currentState?: IndexerCurrentState;
    endTime?: Date;
    errorMessage?: string;
    errors: SearchIndexerError[];
    failedItemCount: number;
    finalTrackingState?: string;
    initialTrackingState?: string;
    itemCount: number;
    readonly mode?: IndexingMode;
    startTime?: Date;
    status: IndexerExecutionStatus;
    readonly statusDetail?: IndexerExecutionStatusDetail;
    warnings: SearchIndexerWarning[];
}

// @public
export type IndexerExecutionStatus = string;

// @public
export type IndexerExecutionStatusDetail = string;

// @public
export type IndexerPermissionOption = string;

// @public
export interface IndexerResyncBody {
    options?: IndexerResyncOption[];
}

// @public
export type IndexerResyncOption = string;

// @public
export type IndexerStatus = string;

// @public
export type IndexingMode = string;

// @public
export interface IndexingParameters {
    batchSize?: number;
    configuration?: IndexingParametersConfiguration;
    maxFailedItems?: number;
    maxFailedItemsPerBatch?: number;
}

// @public
export interface IndexingParametersConfiguration {
    additionalProperties?: Record<string, any>;
    allowSkillsetToReadFileData?: boolean;
    dataToExtract?: BlobIndexerDataToExtract;
    delimitedTextDelimiter?: string;
    delimitedTextHeaders?: string;
    documentRoot?: string;
    excludedFileNameExtensions?: string;
    executionEnvironment?: IndexerExecutionEnvironment;
    failOnUnprocessableDocument?: boolean;
    failOnUnsupportedContentType?: boolean;
    firstLineContainsHeaders?: boolean;
    imageAction?: BlobIndexerImageAction;
    indexedFileNameExtensions?: string;
    indexStorageMetadataOnlyForOversizedDocuments?: boolean;
    markdownHeaderDepth?: MarkdownHeaderDepth;
    markdownParsingSubmode?: MarkdownParsingSubmode;
    parsingMode?: BlobIndexerParsingMode;
    pdfTextRotationAlgorithm?: BlobIndexerPDFTextRotationAlgorithm;
    queryTimeout?: string;
}

// @public
export interface IndexingSchedule {
    interval: string;
    startTime?: Date;
}

// @public
export type IndexProjectionMode = string;

// @public
export interface IndexStatisticsSummary {
    readonly documentCount: number;
    readonly name: string;
    readonly storageSize: number;
    readonly vectorIndexSize?: number;
}

// @public
export interface InputFieldMappingEntry {
    inputs?: InputFieldMappingEntry[];
    name: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface KeepTokenFilter extends TokenFilter {
    keepWords: string[];
    lowerCaseKeepWords?: boolean;
    odatatype: "#Microsoft.Azure.Search.KeepTokenFilter";
}

// @public
export interface KeyPhraseExtractionSkill extends SearchIndexerSkill {
    defaultLanguageCode?: KeyPhraseExtractionSkillLanguage;
    maxKeyPhraseCount?: number;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill";
}

// @public
export type KeyPhraseExtractionSkillLanguage = string;

// @public
export interface KeywordMarkerTokenFilter extends TokenFilter {
    ignoreCase?: boolean;
    keywords: string[];
    odatatype: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter";
}

// @public
export interface KeywordTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.KeywordTokenizerV2";
}

// @public
export interface KnowledgeBase {
    answerInstructions?: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    knowledgeSources: KnowledgeSourceReference[];
    models?: KnowledgeBaseModelUnion[];
    readonly name: string;
    outputMode?: KnowledgeRetrievalOutputMode;
    retrievalInstructions?: string;
    retrievalReasoningEffort?: KnowledgeRetrievalReasoningEffortUnion;
}

// @public
export interface KnowledgeBaseAzureOpenAIModel extends KnowledgeBaseModel {
    azureOpenAIParameters: AzureOpenAiParameters;
    // (undocumented)
    kind: "azureOpenAI";
}

// @public
export interface KnowledgeBaseModel {
    kind: KnowledgeBaseModelKind;
}

// @public
export type KnowledgeBaseModelKind = string;

// @public
export type KnowledgeBaseModelUnion = KnowledgeBaseAzureOpenAIModel | KnowledgeBaseModel;

// @public
export interface KnowledgeSource {
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    kind: KnowledgeSourceKind;
    readonly name: string;
}

// @public
export type KnowledgeSourceKind = string;

// @public
export interface KnowledgeSourceReference {
    name: string;
}

// @public
export type KnowledgeSourceUnion = SearchIndexKnowledgeSource | AzureBlobKnowledgeSource | IndexedSharePointKnowledgeSource | IndexedOneLakeKnowledgeSource | WebKnowledgeSource | RemoteSharePointKnowledgeSource | KnowledgeSource;

// @public
export enum KnownAIFoundryModelCatalogName {
    CohereEmbedV3English = "Cohere-embed-v3-english",
    CohereEmbedV3Multilingual = "Cohere-embed-v3-multilingual",
    FacebookDinoV2ImageEmbeddingsViTBase = "Facebook-DinoV2-Image-Embeddings-ViT-Base",
    FacebookDinoV2ImageEmbeddingsViTGiant = "Facebook-DinoV2-Image-Embeddings-ViT-Giant",
    OpenAiclipImageTextEmbeddingsVitBasePatch32 = "OpenAI-CLIP-Image-Text-Embeddings-vit-base-patch32",
    OpenAiclipImageTextEmbeddingsViTLargePatch14336 = "OpenAI-CLIP-Image-Text-Embeddings-ViT-Large-Patch14-336"
}

// @public
export enum KnownAzureOpenAIModelName {
    TextEmbedding3Large = "text-embedding-3-large",
    TextEmbedding3Small = "text-embedding-3-small",
    TextEmbeddingAda002 = "text-embedding-ada-002"
}

// @public
export enum KnownBlobIndexerDataToExtract {
    AllMetadata = "allMetadata",
    ContentAndMetadata = "contentAndMetadata",
    StorageMetadata = "storageMetadata"
}

// @public
export enum KnownBlobIndexerImageAction {
    GenerateNormalizedImagePerPage = "generateNormalizedImagePerPage",
    GenerateNormalizedImages = "generateNormalizedImages",
    None = "none"
}

// @public
export enum KnownBlobIndexerParsingMode {
    Default = "default",
    DelimitedText = "delimitedText",
    Json = "json",
    JsonArray = "jsonArray",
    JsonLines = "jsonLines",
    Markdown = "markdown",
    Text = "text"
}

// @public
export enum KnownBlobIndexerPDFTextRotationAlgorithm {
    DetectAngles = "detectAngles",
    None = "none"
}

// @public
export enum KnownCharFilterName {
    HtmlStrip = "html_strip"
}

// @public
export enum KnownChatCompletionExtraParametersBehavior {
    Drop = "drop",
    Error = "error",
    PassThrough = "passThrough"
}

// @public
export enum KnownChatCompletionResponseFormatType {
    JsonObject = "jsonObject",
    JsonSchema = "jsonSchema",
    Text = "text"
}

// @public
export enum KnownCjkBigramTokenFilterScripts {
    Han = "han",
    Hangul = "hangul",
    Hiragana = "hiragana",
    Katakana = "katakana"
}

// @public
export enum KnownContentUnderstandingSkillChunkingUnit {
    Characters = "characters"
}

// @public
export enum KnownContentUnderstandingSkillExtractionOptions {
    Images = "images",
    LocationMetadata = "locationMetadata"
}

// @public
export enum KnownCustomEntityLookupSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ko = "ko",
    Pt = "pt"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillChunkingUnit {
    Characters = "characters"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillExtractionOptions {
    Images = "images",
    LocationMetadata = "locationMetadata"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth {
    H1 = "h1",
    H2 = "h2",
    H3 = "h3",
    H4 = "h4",
    H5 = "h5",
    H6 = "h6"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillOutputFormat {
    Markdown = "markdown",
    Text = "text"
}

// @public
export enum KnownDocumentIntelligenceLayoutSkillOutputMode {
    OneToMany = "oneToMany"
}

// @public
export enum KnownEdgeNGramTokenFilterSide {
    Back = "back",
    Front = "front"
}

// @public
export enum KnownEntityCategory {
    Datetime = "datetime",
    Email = "email",
    Location = "location",
    Organization = "organization",
    Person = "person",
    Quantity = "quantity",
    Url = "url"
}

// @public
export enum KnownEntityRecognitionSkillLanguage {
    Ar = "ar",
    Cs = "cs",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    Hu = "hu",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv",
    Tr = "tr",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export enum KnownImageAnalysisSkillLanguage {
    Ar = "ar",
    Az = "az",
    Bg = "bg",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Eu = "eu",
    Fi = "fi",
    Fr = "fr",
    Ga = "ga",
    Gl = "gl",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Hu = "hu",
    Id = "id",
    It = "it",
    Ja = "ja",
    Kk = "kk",
    Ko = "ko",
    Lt = "lt",
    Lv = "lv",
    Mk = "mk",
    Ms = "ms",
    Nb = "nb",
    Nl = "nl",
    Pl = "pl",
    Prs = "prs",
    Pt = "pt",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ro = "ro",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Sv = "sv",
    Th = "th",
    Tr = "tr",
    Uk = "uk",
    Vi = "vi",
    Zh = "zh",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export enum KnownImageDetail {
    Celebrities = "celebrities",
    Landmarks = "landmarks"
}

// @public
export enum KnownIndexerExecutionEnvironment {
    Private = "private",
    Standard = "standard"
}

// @public
export enum KnownIndexerExecutionStatus {
    InProgress = "inProgress",
    Reset = "reset",
    Success = "success",
    TransientFailure = "transientFailure"
}

// @public
export enum KnownIndexerExecutionStatusDetail {
    ResetDocs = "resetDocs",
    Resync = "resync"
}

// @public
export enum KnownIndexerPermissionOption {
    GroupIds = "groupIds",
    RbacScope = "rbacScope",
    UserIds = "userIds"
}

// @public
export enum KnownIndexerResyncOption {
    Permissions = "permissions"
}

// @public
export enum KnownIndexerStatus {
    Error = "error",
    Running = "running",
    Unknown = "unknown"
}

// @public
export enum KnownIndexingMode {
    IndexingAllDocs = "indexingAllDocs",
    IndexingResetDocs = "indexingResetDocs",
    IndexingResync = "indexingResync"
}

// @public
export enum KnownIndexProjectionMode {
    IncludeIndexingParentDocuments = "includeIndexingParentDocuments",
    SkipIndexingParentDocuments = "skipIndexingParentDocuments"
}

// @public
export enum KnownKeyPhraseExtractionSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv"
}

// @public
export enum KnownKnowledgeBaseModelKind {
    AzureOpenAI = "azureOpenAI"
}

// @public
export enum KnownKnowledgeSourceKind {
    AzureBlob = "azureBlob",
    IndexedOneLake = "indexedOneLake",
    IndexedSharePoint = "indexedSharePoint",
    RemoteSharePoint = "remoteSharePoint",
    SearchIndex = "searchIndex",
    Web = "web"
}

// @public
export enum KnownLexicalAnalyzerName {
    ArLucene = "ar.lucene",
    ArMicrosoft = "ar.microsoft",
    BgLucene = "bg.lucene",
    BgMicrosoft = "bg.microsoft",
    BnMicrosoft = "bn.microsoft",
    CaLucene = "ca.lucene",
    CaMicrosoft = "ca.microsoft",
    CsLucene = "cs.lucene",
    CsMicrosoft = "cs.microsoft",
    DaLucene = "da.lucene",
    DaMicrosoft = "da.microsoft",
    DeLucene = "de.lucene",
    DeMicrosoft = "de.microsoft",
    ElLucene = "el.lucene",
    ElMicrosoft = "el.microsoft",
    EnLucene = "en.lucene",
    EnMicrosoft = "en.microsoft",
    EsLucene = "es.lucene",
    EsMicrosoft = "es.microsoft",
    EtMicrosoft = "et.microsoft",
    EuLucene = "eu.lucene",
    FaLucene = "fa.lucene",
    FiLucene = "fi.lucene",
    FiMicrosoft = "fi.microsoft",
    FrLucene = "fr.lucene",
    FrMicrosoft = "fr.microsoft",
    GaLucene = "ga.lucene",
    GlLucene = "gl.lucene",
    GuMicrosoft = "gu.microsoft",
    HeMicrosoft = "he.microsoft",
    HiLucene = "hi.lucene",
    HiMicrosoft = "hi.microsoft",
    HrMicrosoft = "hr.microsoft",
    HuLucene = "hu.lucene",
    HuMicrosoft = "hu.microsoft",
    HyLucene = "hy.lucene",
    IdLucene = "id.lucene",
    IdMicrosoft = "id.microsoft",
    IsMicrosoft = "is.microsoft",
    ItLucene = "it.lucene",
    ItMicrosoft = "it.microsoft",
    JaLucene = "ja.lucene",
    JaMicrosoft = "ja.microsoft",
    Keyword = "keyword",
    KnMicrosoft = "kn.microsoft",
    KoLucene = "ko.lucene",
    KoMicrosoft = "ko.microsoft",
    LtMicrosoft = "lt.microsoft",
    LvLucene = "lv.lucene",
    LvMicrosoft = "lv.microsoft",
    MlMicrosoft = "ml.microsoft",
    MrMicrosoft = "mr.microsoft",
    MsMicrosoft = "ms.microsoft",
    NbMicrosoft = "nb.microsoft",
    NlLucene = "nl.lucene",
    NlMicrosoft = "nl.microsoft",
    NoLucene = "no.lucene",
    PaMicrosoft = "pa.microsoft",
    Pattern = "pattern",
    PlLucene = "pl.lucene",
    PlMicrosoft = "pl.microsoft",
    PtBrLucene = "pt-BR.lucene",
    PtBrMicrosoft = "pt-BR.microsoft",
    PtPtLucene = "pt-PT.lucene",
    PtPtMicrosoft = "pt-PT.microsoft",
    RoLucene = "ro.lucene",
    RoMicrosoft = "ro.microsoft",
    RuLucene = "ru.lucene",
    RuMicrosoft = "ru.microsoft",
    Simple = "simple",
    SkMicrosoft = "sk.microsoft",
    SlMicrosoft = "sl.microsoft",
    SrCyrillicMicrosoft = "sr-cyrillic.microsoft",
    SrLatinMicrosoft = "sr-latin.microsoft",
    StandardAsciiFoldingLucene = "standardasciifolding.lucene",
    StandardLucene = "standard.lucene",
    Stop = "stop",
    SvLucene = "sv.lucene",
    SvMicrosoft = "sv.microsoft",
    TaMicrosoft = "ta.microsoft",
    TeMicrosoft = "te.microsoft",
    ThLucene = "th.lucene",
    ThMicrosoft = "th.microsoft",
    TrLucene = "tr.lucene",
    TrMicrosoft = "tr.microsoft",
    UkMicrosoft = "uk.microsoft",
    UrMicrosoft = "ur.microsoft",
    ViMicrosoft = "vi.microsoft",
    Whitespace = "whitespace",
    ZhHansLucene = "zh-Hans.lucene",
    ZhHansMicrosoft = "zh-Hans.microsoft",
    ZhHantLucene = "zh-Hant.lucene",
    ZhHantMicrosoft = "zh-Hant.microsoft"
}

// @public
export enum KnownLexicalNormalizerName {
    AsciiFolding = "asciifolding",
    Elision = "elision",
    Lowercase = "lowercase",
    Standard = "standard",
    Uppercase = "uppercase"
}

// @public
export enum KnownLexicalTokenizerName {
    Classic = "classic",
    EdgeNGram = "edgeNGram",
    Keyword = "keyword_v2",
    Letter = "letter",
    Lowercase = "lowercase",
    MicrosoftLanguageStemmingTokenizer = "microsoft_language_stemming_tokenizer",
    MicrosoftLanguageTokenizer = "microsoft_language_tokenizer",
    NGram = "nGram",
    PathHierarchy = "path_hierarchy_v2",
    Pattern = "pattern",
    Standard = "standard_v2",
    UaxUrlEmail = "uax_url_email",
    Whitespace = "whitespace"
}

// @public
export enum KnownMarkdownHeaderDepth {
    H1 = "h1",
    H2 = "h2",
    H3 = "h3",
    H4 = "h4",
    H5 = "h5",
    H6 = "h6"
}

// @public
export enum KnownMarkdownParsingSubmode {
    OneToMany = "oneToMany",
    OneToOne = "oneToOne"
}

// @public
export enum KnownMicrosoftStemmingTokenizerLanguage {
    Arabic = "arabic",
    Bangla = "bangla",
    Bulgarian = "bulgarian",
    Catalan = "catalan",
    Croatian = "croatian",
    Czech = "czech",
    Danish = "danish",
    Dutch = "dutch",
    English = "english",
    Estonian = "estonian",
    Finnish = "finnish",
    French = "french",
    German = "german",
    Greek = "greek",
    Gujarati = "gujarati",
    Hebrew = "hebrew",
    Hindi = "hindi",
    Hungarian = "hungarian",
    Icelandic = "icelandic",
    Indonesian = "indonesian",
    Italian = "italian",
    Kannada = "kannada",
    Latvian = "latvian",
    Lithuanian = "lithuanian",
    Malay = "malay",
    Malayalam = "malayalam",
    Marathi = "marathi",
    NorwegianBokmaal = "norwegianBokmaal",
    Polish = "polish",
    Portuguese = "portuguese",
    PortugueseBrazilian = "portugueseBrazilian",
    Punjabi = "punjabi",
    Romanian = "romanian",
    Russian = "russian",
    SerbianCyrillic = "serbianCyrillic",
    SerbianLatin = "serbianLatin",
    Slovak = "slovak",
    Slovenian = "slovenian",
    Spanish = "spanish",
    Swedish = "swedish",
    Tamil = "tamil",
    Telugu = "telugu",
    Turkish = "turkish",
    Ukrainian = "ukrainian",
    Urdu = "urdu"
}

// @public
export enum KnownMicrosoftTokenizerLanguage {
    Bangla = "bangla",
    Bulgarian = "bulgarian",
    Catalan = "catalan",
    ChineseSimplified = "chineseSimplified",
    ChineseTraditional = "chineseTraditional",
    Croatian = "croatian",
    Czech = "czech",
    Danish = "danish",
    Dutch = "dutch",
    English = "english",
    French = "french",
    German = "german",
    Greek = "greek",
    Gujarati = "gujarati",
    Hindi = "hindi",
    Icelandic = "icelandic",
    Indonesian = "indonesian",
    Italian = "italian",
    Japanese = "japanese",
    Kannada = "kannada",
    Korean = "korean",
    Malay = "malay",
    Malayalam = "malayalam",
    Marathi = "marathi",
    NorwegianBokmaal = "norwegianBokmaal",
    Polish = "polish",
    Portuguese = "portuguese",
    PortugueseBrazilian = "portugueseBrazilian",
    Punjabi = "punjabi",
    Romanian = "romanian",
    Russian = "russian",
    SerbianCyrillic = "serbianCyrillic",
    SerbianLatin = "serbianLatin",
    Slovenian = "slovenian",
    Spanish = "spanish",
    Swedish = "swedish",
    Tamil = "tamil",
    Telugu = "telugu",
    Thai = "thai",
    Ukrainian = "ukrainian",
    Urdu = "urdu",
    Vietnamese = "vietnamese"
}

// @public
export enum KnownOcrLineEnding {
    CarriageReturn = "carriageReturn",
    CarriageReturnLineFeed = "carriageReturnLineFeed",
    LineFeed = "lineFeed",
    Space = "space"
}

// @public
export enum KnownOcrSkillLanguage {
    Af = "af",
    Anp = "anp",
    Ar = "ar",
    Ast = "ast",
    Awa = "awa",
    Az = "az",
    Be = "be",
    BeCyrl = "be-cyrl",
    BeLatn = "be-latn",
    Bfy = "bfy",
    Bfz = "bfz",
    Bg = "bg",
    Bgc = "bgc",
    Bho = "bho",
    Bi = "bi",
    Bns = "bns",
    Br = "br",
    Bra = "bra",
    Brx = "brx",
    Bs = "bs",
    Bua = "bua",
    Ca = "ca",
    Ceb = "ceb",
    Ch = "ch",
    CnrCyrl = "cnr-cyrl",
    CnrLatn = "cnr-latn",
    Co = "co",
    Crh = "crh",
    Cs = "cs",
    Csb = "csb",
    Cy = "cy",
    Da = "da",
    De = "de",
    Dhi = "dhi",
    Doi = "doi",
    Dsb = "dsb",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Eu = "eu",
    Fa = "fa",
    Fi = "fi",
    Fil = "fil",
    Fj = "fj",
    Fo = "fo",
    Fr = "fr",
    Fur = "fur",
    Fy = "fy",
    Ga = "ga",
    Gag = "gag",
    Gd = "gd",
    Gil = "gil",
    Gl = "gl",
    Gon = "gon",
    Gv = "gv",
    Gvr = "gvr",
    Haw = "haw",
    Hi = "hi",
    Hlb = "hlb",
    Hne = "hne",
    Hni = "hni",
    Hoc = "hoc",
    Hr = "hr",
    Hsb = "hsb",
    Ht = "ht",
    Hu = "hu",
    Ia = "ia",
    Id = "id",
    Is = "is",
    It = "it",
    Iu = "iu",
    Ja = "ja",
    Jns = "Jns",
    Jv = "jv",
    Kaa = "kaa",
    KaaCyrl = "kaa-cyrl",
    Kac = "kac",
    Kea = "kea",
    Kfq = "kfq",
    Kha = "kha",
    KkCyrl = "kk-cyrl",
    KkLatn = "kk-latn",
    Kl = "kl",
    Klr = "klr",
    Kmj = "kmj",
    Ko = "ko",
    Kos = "kos",
    Kpy = "kpy",
    Krc = "krc",
    Kru = "kru",
    Ksh = "ksh",
    KuArab = "ku-arab",
    KuLatn = "ku-latn",
    Kum = "kum",
    Kw = "kw",
    Ky = "ky",
    La = "la",
    Lb = "lb",
    Lkt = "lkt",
    Lt = "lt",
    Mi = "mi",
    Mn = "mn",
    Mr = "mr",
    Ms = "ms",
    Mt = "mt",
    Mww = "mww",
    Myv = "myv",
    Nap = "nap",
    Nb = "nb",
    Ne = "ne",
    Niu = "niu",
    Nl = "nl",
    No = "no",
    Nog = "nog",
    Oc = "oc",
    Os = "os",
    Pa = "pa",
    Pl = "pl",
    Prs = "prs",
    Ps = "ps",
    Pt = "pt",
    Quc = "quc",
    Rab = "rab",
    Rm = "rm",
    Ro = "ro",
    Ru = "ru",
    Sa = "sa",
    Sat = "sat",
    Sck = "sck",
    Sco = "sco",
    Sk = "sk",
    Sl = "sl",
    Sm = "sm",
    Sma = "sma",
    Sme = "sme",
    Smj = "smj",
    Smn = "smn",
    Sms = "sms",
    So = "so",
    Sq = "sq",
    Sr = "sr",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Srx = "srx",
    Sv = "sv",
    Sw = "sw",
    Tet = "tet",
    Tg = "tg",
    Thf = "thf",
    Tk = "tk",
    To = "to",
    Tr = "tr",
    Tt = "tt",
    Tyv = "tyv",
    Ug = "ug",
    Unk = "unk",
    Ur = "ur",
    Uz = "uz",
    UzArab = "uz-arab",
    UzCyrl = "uz-cyrl",
    Vo = "vo",
    Wae = "wae",
    Xnr = "xnr",
    Xsr = "xsr",
    Yua = "yua",
    Za = "za",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant",
    Zu = "zu"
}

// @public
export enum KnownPermissionFilter {
    GroupIds = "groupIds",
    RbacScope = "rbacScope",
    UserIds = "userIds"
}

// @public
export enum KnownPhoneticEncoder {
    BeiderMorse = "beiderMorse",
    Caverphone1 = "caverphone1",
    Caverphone2 = "caverphone2",
    Cologne = "cologne",
    DoubleMetaphone = "doubleMetaphone",
    HaasePhonetik = "haasePhonetik",
    KoelnerPhonetik = "koelnerPhonetik",
    Metaphone = "metaphone",
    Nysiis = "nysiis",
    RefinedSoundex = "refinedSoundex",
    Soundex = "soundex"
}

// @public
export enum KnownPIIDetectionSkillMaskingMode {
    None = "none",
    Replace = "replace"
}

// @public
export enum KnownRankingOrder {
    BoostedRerankerScore = "BoostedRerankerScore",
    RerankerScore = "RerankerScore"
}

// @public
export enum KnownRegexFlags {
    CanonEq = "CANON_EQ",
    CaseInsensitive = "CASE_INSENSITIVE",
    Comments = "COMMENTS",
    DotAll = "DOTALL",
    Literal = "LITERAL",
    Multiline = "MULTILINE",
    UnicodeCase = "UNICODE_CASE",
    UnixLines = "UNIX_LINES"
}

// @public
export enum KnownScoringFunctionAggregation {
    Average = "average",
    FirstMatching = "firstMatching",
    Maximum = "maximum",
    Minimum = "minimum",
    Sum = "sum"
}

// @public
export enum KnownScoringFunctionInterpolation {
    Constant = "constant",
    Linear = "linear",
    Logarithmic = "logarithmic",
    Quadratic = "quadratic"
}

// @public
export enum KnownSearchFieldDataType {
    Boolean = "Edm.Boolean",
    Byte = "Edm.Byte",
    Complex = "Edm.ComplexType",
    DateTimeOffset = "Edm.DateTimeOffset",
    Double = "Edm.Double",
    GeographyPoint = "Edm.GeographyPoint",
    Half = "Edm.Half",
    Int16 = "Edm.Int16",
    Int32 = "Edm.Int32",
    Int64 = "Edm.Int64",
    SByte = "Edm.SByte",
    Single = "Edm.Single",
    String = "Edm.String"
}

// @public
export enum KnownSearchIndexerDataSourceType {
    AdlsGen2 = "adlsgen2",
    AzureBlob = "azureblob",
    AzureSql = "azuresql",
    AzureTable = "azuretable",
    CosmosDb = "cosmosdb",
    MySql = "mysql",
    OneLake = "onelake"
}

// @public
export enum KnownSearchIndexPermissionFilterOption {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownSentimentSkillLanguage {
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv",
    Tr = "tr"
}

// @public
export enum KnownSnowballTokenFilterLanguage {
    Armenian = "armenian",
    Basque = "basque",
    Catalan = "catalan",
    Danish = "danish",
    Dutch = "dutch",
    English = "english",
    Finnish = "finnish",
    French = "french",
    German = "german",
    German2 = "german2",
    Hungarian = "hungarian",
    Italian = "italian",
    Kp = "kp",
    Lovins = "lovins",
    Norwegian = "norwegian",
    Porter = "porter",
    Portuguese = "portuguese",
    Romanian = "romanian",
    Russian = "russian",
    Spanish = "spanish",
    Swedish = "swedish",
    Turkish = "turkish"
}

// @public
export enum KnownSplitSkillEncoderModelName {
    CL100KBase = "cl100k_base",
    P50KBase = "p50k_base",
    P50KEdit = "p50k_edit",
    R50KBase = "r50k_base"
}

// @public
export enum KnownSplitSkillLanguage {
    Am = "am",
    Bs = "bs",
    Cs = "cs",
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Et = "et",
    Fi = "fi",
    Fr = "fr",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Lv = "lv",
    Nb = "nb",
    Nl = "nl",
    Pl = "pl",
    Pt = "pt",
    PtBr = "pt-br",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    Sr = "sr",
    Sv = "sv",
    Tr = "tr",
    Ur = "ur",
    Zh = "zh"
}

// @public
export enum KnownSplitSkillUnit {
    AzureOpenAITokens = "azureOpenAITokens",
    Characters = "characters"
}

// @public
export enum KnownStemmerTokenFilterLanguage {
    Arabic = "arabic",
    Armenian = "armenian",
    Basque = "basque",
    Brazilian = "brazilian",
    Bulgarian = "bulgarian",
    Catalan = "catalan",
    Czech = "czech",
    Danish = "danish",
    Dutch = "dutch",
    DutchKp = "dutchKp",
    English = "english",
    Finnish = "finnish",
    French = "french",
    Galician = "galician",
    German = "german",
    German2 = "german2",
    Greek = "greek",
    Hindi = "hindi",
    Hungarian = "hungarian",
    Indonesian = "indonesian",
    Irish = "irish",
    Italian = "italian",
    Latvian = "latvian",
    LightEnglish = "lightEnglish",
    LightFinnish = "lightFinnish",
    LightFrench = "lightFrench",
    LightGerman = "lightGerman",
    LightHungarian = "lightHungarian",
    LightItalian = "lightItalian",
    LightNorwegian = "lightNorwegian",
    LightNynorsk = "lightNynorsk",
    LightPortuguese = "lightPortuguese",
    LightRussian = "lightRussian",
    LightSpanish = "lightSpanish",
    LightSwedish = "lightSwedish",
    Lovins = "lovins",
    MinimalEnglish = "minimalEnglish",
    MinimalFrench = "minimalFrench",
    MinimalGalician = "minimalGalician",
    MinimalGerman = "minimalGerman",
    MinimalNorwegian = "minimalNorwegian",
    MinimalNynorsk = "minimalNynorsk",
    MinimalPortuguese = "minimalPortuguese",
    Norwegian = "norwegian",
    Porter2 = "porter2",
    Portuguese = "portuguese",
    PortugueseRslp = "portugueseRslp",
    PossessiveEnglish = "possessiveEnglish",
    Romanian = "romanian",
    Russian = "russian",
    Sorani = "sorani",
    Spanish = "spanish",
    Swedish = "swedish",
    Turkish = "turkish"
}

// @public
export enum KnownStopwordsList {
    Arabic = "arabic",
    Armenian = "armenian",
    Basque = "basque",
    Brazilian = "brazilian",
    Bulgarian = "bulgarian",
    Catalan = "catalan",
    Czech = "czech",
    Danish = "danish",
    Dutch = "dutch",
    English = "english",
    Finnish = "finnish",
    French = "french",
    Galician = "galician",
    German = "german",
    Greek = "greek",
    Hindi = "hindi",
    Hungarian = "hungarian",
    Indonesian = "indonesian",
    Irish = "irish",
    Italian = "italian",
    Latvian = "latvian",
    Norwegian = "norwegian",
    Persian = "persian",
    Portuguese = "portuguese",
    Romanian = "romanian",
    Russian = "russian",
    Sorani = "sorani",
    Spanish = "spanish",
    Swedish = "swedish",
    Thai = "thai",
    Turkish = "turkish"
}

// @public
export enum KnownTextSplitMode {
    Pages = "pages",
    Sentences = "sentences"
}

// @public
export enum KnownTextTranslationSkillLanguage {
    Af = "af",
    Ar = "ar",
    Bg = "bg",
    Bn = "bn",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Fa = "fa",
    Fi = "fi",
    Fil = "fil",
    Fj = "fj",
    Fr = "fr",
    Ga = "ga",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Ht = "ht",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Ja = "ja",
    Kn = "kn",
    Ko = "ko",
    Lt = "lt",
    Lv = "lv",
    Mg = "mg",
    Mi = "mi",
    Ml = "ml",
    Ms = "ms",
    Mt = "mt",
    Mww = "mww",
    Nb = "nb",
    Nl = "nl",
    Otq = "otq",
    Pa = "pa",
    Pl = "pl",
    Pt = "pt",
    PtBr = "pt-br",
    PtPT = "pt-PT",
    Ro = "ro",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    Sm = "sm",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Sv = "sv",
    Sw = "sw",
    Ta = "ta",
    Te = "te",
    Th = "th",
    Tlh = "tlh",
    TlhLatn = "tlh-Latn",
    TlhPiqd = "tlh-Piqd",
    To = "to",
    Tr = "tr",
    Ty = "ty",
    Uk = "uk",
    Ur = "ur",
    Vi = "vi",
    Yua = "yua",
    Yue = "yue",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export enum KnownTokenCharacterKind {
    Digit = "digit",
    Letter = "letter",
    Punctuation = "punctuation",
    Symbol = "symbol",
    Whitespace = "whitespace"
}

// @public
export enum KnownTokenFilterName {
    Apostrophe = "apostrophe",
    ArabicNormalization = "arabic_normalization",
    AsciiFolding = "asciifolding",
    CjkBigram = "cjk_bigram",
    CjkWidth = "cjk_width",
    Classic = "classic",
    CommonGram = "common_grams",
    EdgeNGram = "edgeNGram_v2",
    Elision = "elision",
    GermanNormalization = "german_normalization",
    HindiNormalization = "hindi_normalization",
    IndicNormalization = "indic_normalization",
    KeywordRepeat = "keyword_repeat",
    KStem = "kstem",
    Length = "length",
    Limit = "limit",
    Lowercase = "lowercase",
    NGram = "nGram_v2",
    PersianNormalization = "persian_normalization",
    Phonetic = "phonetic",
    PorterStem = "porter_stem",
    Reverse = "reverse",
    ScandinavianFoldingNormalization = "scandinavian_folding",
    ScandinavianNormalization = "scandinavian_normalization",
    Shingle = "shingle",
    Snowball = "snowball",
    SoraniNormalization = "sorani_normalization",
    Stemmer = "stemmer",
    Stopwords = "stopwords",
    Trim = "trim",
    Truncate = "truncate",
    Unique = "unique",
    Uppercase = "uppercase",
    WordDelimiter = "word_delimiter"
}

// @public
export enum KnownVectorEncodingFormat {
    PackedBit = "packedBit"
}

// @public
export enum KnownVectorSearchAlgorithmKind {
    ExhaustiveKnn = "exhaustiveKnn",
    Hnsw = "hnsw"
}

// @public
export enum KnownVectorSearchAlgorithmMetric {
    Cosine = "cosine",
    DotProduct = "dotProduct",
    Euclidean = "euclidean",
    Hamming = "hamming"
}

// @public
export enum KnownVectorSearchCompressionKind {
    BinaryQuantization = "binaryQuantization",
    ScalarQuantization = "scalarQuantization"
}

// @public
export enum KnownVectorSearchCompressionRescoreStorageMethod {
    DiscardOriginals = "discardOriginals",
    PreserveOriginals = "preserveOriginals"
}

// @public
export enum KnownVectorSearchCompressionTarget {
    Int8 = "int8"
}

// @public
export enum KnownVectorSearchVectorizerKind {
    AIServicesVision = "aiServicesVision",
    AML = "aml",
    AzureOpenAI = "azureOpenAI",
    CustomWebApi = "customWebApi"
}

// @public
export enum KnownVisualFeature {
    Adult = "adult",
    Brands = "brands",
    Categories = "categories",
    Description = "description",
    Faces = "faces",
    Objects = "objects",
    Tags = "tags"
}

// @public
export interface LanguageDetectionSkill extends SearchIndexerSkill {
    defaultCountryHint?: string;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.LanguageDetectionSkill";
}

// @public
export interface LengthTokenFilter extends TokenFilter {
    maxLength?: number;
    minLength?: number;
    odatatype: "#Microsoft.Azure.Search.LengthTokenFilter";
}

// @public
export interface LexicalAnalyzer {
    name: string;
    odatatype: string;
}

// @public
export type LexicalAnalyzerName = string;

// @public
export type LexicalAnalyzerUnion = CustomAnalyzer | PatternAnalyzer | LuceneStandardAnalyzer | StopAnalyzer | LexicalAnalyzer;

// @public
export interface LexicalNormalizer {
    name: string;
    odatatype: string;
}

// @public
export type LexicalNormalizerName = string;

// @public
export type LexicalNormalizerUnion = CustomNormalizer | LexicalNormalizer;

// @public
export interface LexicalTokenizer {
    name: string;
    odatatype: string;
}

// @public
export type LexicalTokenizerName = string;

// @public
export type LexicalTokenizerUnion = ClassicTokenizer | EdgeNGramTokenizer | KeywordTokenizer | MicrosoftLanguageTokenizer | MicrosoftLanguageStemmingTokenizer | NGramTokenizer | PathHierarchyTokenizer | PatternTokenizer | LuceneStandardTokenizer | UaxUrlEmailTokenizer | LexicalTokenizer;

// @public
export interface LimitTokenFilter extends TokenFilter {
    consumeAllTokens?: boolean;
    maxTokenCount?: number;
    odatatype: "#Microsoft.Azure.Search.LimitTokenFilter";
}

// @public
export interface ListDataSourcesResult {
    dataSources: SearchIndexerDataSourceConnection[];
}

// @public
export interface ListIndexersResult {
    indexers: SearchIndexer[];
}

// @public
export interface ListSkillsetsResult {
    skillsets: SearchIndexerSkillset[];
}

// @public
export interface ListSynonymMapsResult {
    synonymMaps: SynonymMap[];
}

// @public
export interface LuceneStandardAnalyzer extends LexicalAnalyzer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.StandardAnalyzer";
    stopwords?: string[];
}

// @public
export interface LuceneStandardTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.StandardTokenizerV2";
}

// @public
export interface MagnitudeScoringFunction extends ScoringFunction {
    parameters: MagnitudeScoringParameters;
    type: "magnitude";
}

// @public
export interface MagnitudeScoringParameters {
    boostingRangeEnd: number;
    boostingRangeStart: number;
    shouldBoostBeyondRangeByConstant?: boolean;
}

// @public
export interface MappingCharFilter extends CharFilter {
    mappings: string[];
    odatatype: "#Microsoft.Azure.Search.MappingCharFilter";
}

// @public
export type MarkdownHeaderDepth = string;

// @public
export type MarkdownParsingSubmode = string;

// @public
export interface MergeSkill extends SearchIndexerSkill {
    insertPostTag?: string;
    insertPreTag?: string;
    odatatype: "#Microsoft.Skills.Text.MergeSkill";
}

// @public
export interface MicrosoftLanguageStemmingTokenizer extends LexicalTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftStemmingTokenizerLanguage;
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer";
}

// @public
export interface MicrosoftLanguageTokenizer extends LexicalTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftTokenizerLanguage;
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer";
}

// @public
export type MicrosoftStemmingTokenizerLanguage = string;

// @public
export type MicrosoftTokenizerLanguage = string;

// @public
export interface NativeBlobSoftDeleteDeletionDetectionPolicy extends DataDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy";
}

// @public
export interface NGramTokenFilter extends TokenFilter {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.NGramTokenFilterV2";
}

// @public
export interface NGramTokenizer extends LexicalTokenizer {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.NGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export type OcrLineEnding = string;

// @public
export interface OcrSkill extends SearchIndexerSkill {
    defaultLanguageCode?: OcrSkillLanguage;
    lineEnding?: OcrLineEnding;
    odatatype: "#Microsoft.Skills.Vision.OcrSkill";
    shouldDetectOrientation?: boolean;
}

// @public
export type OcrSkillLanguage = string;

// @public
export interface OutputFieldMappingEntry {
    name: string;
    targetName?: string;
}

// @public
export interface PathHierarchyTokenizer extends LexicalTokenizer {
    delimiter?: string;
    maxTokenLength?: number;
    numberOfTokensToSkip?: number;
    odatatype: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2";
    replacement?: string;
    reverseTokenOrder?: boolean;
}

// @public
export interface PatternAnalyzer extends LexicalAnalyzer {
    flags?: RegexFlags;
    lowerCaseTerms?: boolean;
    odatatype: "#Microsoft.Azure.Search.PatternAnalyzer";
    pattern?: string;
    stopwords?: string[];
}

// @public
export interface PatternCaptureTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.PatternCaptureTokenFilter";
    patterns: string[];
    preserveOriginal?: boolean;
}

// @public
export interface PatternReplaceCharFilter extends CharFilter {
    odatatype: "#Microsoft.Azure.Search.PatternReplaceCharFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternReplaceTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.PatternReplaceTokenFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternTokenizer extends LexicalTokenizer {
    flags?: RegexFlags;
    group?: number;
    odatatype: "#Microsoft.Azure.Search.PatternTokenizer";
    pattern?: string;
}

// @public
export type PermissionFilter = string;

// @public
export type PhoneticEncoder = string;

// @public
export interface PhoneticTokenFilter extends TokenFilter {
    encoder?: PhoneticEncoder;
    odatatype: "#Microsoft.Azure.Search.PhoneticTokenFilter";
    replaceOriginalTokens?: boolean;
}

// @public
export interface PIIDetectionSkill extends SearchIndexerSkill {
    defaultLanguageCode?: string;
    domain?: string;
    mask?: string;
    maskingMode?: PIIDetectionSkillMaskingMode;
    minimumPrecision?: number;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.PIIDetectionSkill";
    piiCategories?: string[];
}

// @public
export type PIIDetectionSkillMaskingMode = string;

// @public
export type RankingOrder = string;

// @public
export type RegexFlags = string;

// @public
export interface RescoringOptions {
    defaultOversampling?: number;
    enableRescoring?: boolean;
    rescoreStorageMethod?: VectorSearchCompressionRescoreStorageMethod;
}

// @public
export interface ResourceCounter {
    quota?: number;
    usage: number;
}

// @public
export interface ScalarQuantizationCompression extends VectorSearchCompression {
    kind: "scalarQuantization";
    parameters?: ScalarQuantizationParameters;
}

// @public
export interface ScalarQuantizationParameters {
    quantizedDataType?: VectorSearchCompressionTarget;
}

// @public
export interface ScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    type: string;
}

// @public
export type ScoringFunctionAggregation = string;

// @public
export type ScoringFunctionInterpolation = string;

// @public
export type ScoringFunctionUnion = DistanceScoringFunction | FreshnessScoringFunction | MagnitudeScoringFunction | TagScoringFunction | ScoringFunction;

// @public
export interface ScoringProfile {
    functionAggregation?: ScoringFunctionAggregation;
    functions?: ScoringFunctionUnion[];
    name: string;
    textWeights?: TextWeights;
}

// @public
export interface SearchAlias {
    eTag?: string;
    indexes: string[];
    name: string;
}

// @public
export interface SearchField {
    analyzerName?: LexicalAnalyzerName;
    facetable?: boolean;
    fields?: SearchField[];
    filterable?: boolean;
    indexAnalyzerName?: LexicalAnalyzerName;
    key?: boolean;
    name: string;
    normalizerName?: LexicalNormalizerName;
    permissionFilter?: PermissionFilter;
    retrievable?: boolean;
    searchable?: boolean;
    searchAnalyzerName?: LexicalAnalyzerName;
    sensitivityLabel?: boolean;
    sortable?: boolean;
    stored?: boolean;
    synonymMapNames?: string[];
    type: SearchFieldDataType;
    vectorEncodingFormat?: VectorEncodingFormat;
    vectorSearchDimensions?: number;
    vectorSearchProfileName?: string;
}

// @public
export type SearchFieldDataType = string;

// @public
export interface SearchIndex {
    analyzers?: LexicalAnalyzerUnion[];
    charFilters?: CharFilterUnion[];
    corsOptions?: CorsOptions;
    defaultScoringProfile?: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    fields: SearchField[];
    name: string;
    normalizers?: LexicalNormalizerUnion[];
    permissionFilterOption?: SearchIndexPermissionFilterOption;
    purviewEnabled?: boolean;
    scoringProfiles?: ScoringProfile[];
    semanticSearch?: SemanticSearch;
    similarity?: SimilarityAlgorithmUnion;
    suggesters?: SearchSuggester[];
    tokenFilters?: TokenFilterUnion[];
    tokenizers?: LexicalTokenizerUnion[];
    vectorSearch?: VectorSearch;
}

// @public
export interface SearchIndexer {
    cache?: SearchIndexerCache;
    dataSourceName: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    fieldMappings?: FieldMapping[];
    isDisabled?: boolean;
    name: string;
    outputFieldMappings?: FieldMapping[];
    parameters?: IndexingParameters;
    schedule?: IndexingSchedule;
    skillsetName?: string;
    targetIndexName: string;
}

// @public
export interface SearchIndexerCache {
    enableReprocessing?: boolean;
    id?: string;
    identity?: SearchIndexerDataIdentityUnion;
    storageConnectionString?: string;
}

// @public
export interface SearchIndexerDataContainer {
    name: string;
    query?: string;
}

// @public
export interface SearchIndexerDataIdentity {
    odatatype: string;
}

// @public
export type SearchIndexerDataIdentityUnion = SearchIndexerDataNoneIdentity | SearchIndexerDataUserAssignedIdentity | SearchIndexerDataIdentity;

// @public
export interface SearchIndexerDataNoneIdentity extends SearchIndexerDataIdentity {
    odatatype: "#Microsoft.Azure.Search.DataNoneIdentity";
}

// @public
export interface SearchIndexerDataSourceConnection {
    container: SearchIndexerDataContainer;
    credentials: DataSourceCredentials;
    dataChangeDetectionPolicy?: DataChangeDetectionPolicyUnion;
    dataDeletionDetectionPolicy?: DataDeletionDetectionPolicyUnion;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    identity?: SearchIndexerDataIdentityUnion;
    indexerPermissionOptions?: IndexerPermissionOption[];
    name: string;
    subType?: string;
    type: SearchIndexerDataSourceType;
}

// @public
export type SearchIndexerDataSourceType = string;

// @public
export interface SearchIndexerDataUserAssignedIdentity extends SearchIndexerDataIdentity {
    odatatype: "#Microsoft.Azure.Search.DataUserAssignedIdentity";
    resourceId: string;
}

// @public
export interface SearchIndexerError {
    details?: string;
    documentationLink?: string;
    errorMessage: string;
    key?: string;
    name?: string;
    statusCode: number;
}

// @public
export interface SearchIndexerIndexProjection {
    parameters?: SearchIndexerIndexProjectionsParameters;
    selectors: SearchIndexerIndexProjectionSelector[];
}

// @public
export interface SearchIndexerIndexProjectionSelector {
    mappings: InputFieldMappingEntry[];
    parentKeyFieldName: string;
    sourceContext: string;
    targetIndexName: string;
}

// @public
export interface SearchIndexerIndexProjectionsParameters {
    additionalProperties?: Record<string, any>;
    projectionMode?: IndexProjectionMode;
}

// @public
export interface SearchIndexerKnowledgeStore {
    identity?: SearchIndexerDataIdentityUnion;
    parameters?: SearchIndexerKnowledgeStoreParameters;
    projections: SearchIndexerKnowledgeStoreProjection[];
    storageConnectionString: string;
}

// @public
export interface SearchIndexerKnowledgeStoreBlobProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
    storageContainer: string;
}

// @public
export interface SearchIndexerKnowledgeStoreFileProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector {
}

// @public
export interface SearchIndexerKnowledgeStoreObjectProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector {
}

// @public
export interface SearchIndexerKnowledgeStoreParameters {
    additionalProperties?: Record<string, any>;
    synthesizeGeneratedKeyName?: boolean;
}

// @public
export interface SearchIndexerKnowledgeStoreProjection {
    files?: SearchIndexerKnowledgeStoreFileProjectionSelector[];
    objects?: SearchIndexerKnowledgeStoreObjectProjectionSelector[];
    tables?: SearchIndexerKnowledgeStoreTableProjectionSelector[];
}

// @public
export interface SearchIndexerKnowledgeStoreProjectionSelector {
    generatedKeyName?: string;
    inputs?: InputFieldMappingEntry[];
    referenceKeyName?: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface SearchIndexerKnowledgeStoreTableProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
    tableName: string;
}

// @public
export interface SearchIndexerLimits {
    maxDocumentContentCharactersToExtract?: number;
    maxDocumentExtractionSize?: number;
    maxRunTime?: string;
}

// @public
export interface SearchIndexerSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: string;
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface SearchIndexerSkillset {
    cognitiveServicesAccount?: CognitiveServicesAccountUnion;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    indexProjection?: SearchIndexerIndexProjection;
    knowledgeStore?: SearchIndexerKnowledgeStore;
    name: string;
    skills: SearchIndexerSkillUnion[];
}

// @public
export type SearchIndexerSkillUnion = ConditionalSkill | KeyPhraseExtractionSkill | OcrSkill | ImageAnalysisSkill | LanguageDetectionSkill | ShaperSkill | MergeSkill | EntityRecognitionSkill | SentimentSkill | SentimentSkillV3 | EntityLinkingSkill | EntityRecognitionSkillV3 | PIIDetectionSkill | SplitSkill | CustomEntityLookupSkill | TextTranslationSkill | DocumentExtractionSkill | DocumentIntelligenceLayoutSkill | WebApiSkill | AzureMachineLearningSkill | AzureOpenAIEmbeddingSkill | VisionVectorizeSkill | ContentUnderstandingSkill | ChatCompletionSkill | SearchIndexerSkill;

// @public
export interface SearchIndexerStatus {
    currentState?: IndexerCurrentState;
    executionHistory: IndexerExecutionResult[];
    lastResult?: IndexerExecutionResult;
    limits: SearchIndexerLimits;
    name: string;
    runtime?: IndexerRuntime;
    status: IndexerStatus;
}

// @public
export interface SearchIndexerWarning {
    details?: string;
    documentationLink?: string;
    key?: string;
    message: string;
    name?: string;
}

// @public
export interface SearchIndexKnowledgeSource extends KnowledgeSource {
    // (undocumented)
    kind: "searchIndex";
    searchIndexParameters: SearchIndexKnowledgeSourceParameters;
}

// @public
export interface SearchIndexKnowledgeSourceParameters {
    searchIndexName: string;
    sourceDataSelect?: string;
}

// @public
export type SearchIndexPermissionFilterOption = string;

// @public
export interface SearchResourceEncryptionKey {
    accessCredentials?: AzureActiveDirectoryApplicationCredentials;
    identity?: SearchIndexerDataIdentityUnion;
    keyName: string;
    keyVersion?: string;
    vaultUri: string;
}

// @public
export interface SearchServiceStatistics {
    counters: ServiceCounters;
    indexersRuntime?: ServiceIndexersRuntime;
    limits: ServiceLimits;
}

// @public
export interface SearchSuggester {
    name: string;
    searchMode: "analyzingInfixMatching";
    sourceFields: string[];
}

// @public
export interface SemanticConfiguration {
    flightingOptIn?: boolean;
    name: string;
    prioritizedFields: SemanticPrioritizedFields;
    rankingOrder?: RankingOrder;
}

// @public
export interface SemanticField {
    fieldName: string;
}

// @public
export interface SemanticPrioritizedFields {
    contentFields?: SemanticField[];
    keywordsFields?: SemanticField[];
    titleField?: SemanticField;
}

// @public
export interface SemanticSearch {
    configurations?: SemanticConfiguration[];
    defaultConfigurationName?: string;
}

// @public
export interface SentimentSkill extends SearchIndexerSkill {
    defaultLanguageCode?: SentimentSkillLanguage;
    odatatype: "#Microsoft.Skills.Text.SentimentSkill";
}

// @public
export type SentimentSkillLanguage = string;

// @public
export interface SentimentSkillV3 extends SearchIndexerSkill {
    defaultLanguageCode?: string;
    includeOpinionMining?: boolean;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.V3.SentimentSkill";
}

// @public
export interface ServiceCounters {
    aliasCounter: ResourceCounter;
    dataSourceCounter: ResourceCounter;
    documentCounter: ResourceCounter;
    indexCounter: ResourceCounter;
    indexerCounter: ResourceCounter;
    skillsetCounter: ResourceCounter;
    storageSizeCounter: ResourceCounter;
    synonymMapCounter: ResourceCounter;
    vectorIndexSizeCounter: ResourceCounter;
}

// @public
export interface ServiceLimits {
    maxComplexCollectionFieldsPerIndex?: number;
    maxComplexObjectsInCollectionsPerDocument?: number;
    maxCumulativeIndexerRuntimeSeconds?: number;
    maxFieldNestingDepthPerIndex?: number;
    maxFieldsPerIndex?: number;
    maxStoragePerIndexInBytes?: number;
}

// @public
export interface ShaperSkill extends SearchIndexerSkill {
    odatatype: "#Microsoft.Skills.Util.ShaperSkill";
}

// @public
export interface ShingleTokenFilter extends TokenFilter {
    filterToken?: string;
    maxShingleSize?: number;
    minShingleSize?: number;
    odatatype: "#Microsoft.Azure.Search.ShingleTokenFilter";
    outputUnigrams?: boolean;
    outputUnigramsIfNoShingles?: boolean;
    tokenSeparator?: string;
}

// @public
export interface SimilarityAlgorithm {
    odatatype: string;
}

// @public
export type SimilarityAlgorithmUnion = ClassicSimilarity | BM25Similarity | SimilarityAlgorithm;

// @public
export interface SkillNames {
    skillNames?: string[];
}

// @public
export interface SnowballTokenFilter extends TokenFilter {
    language: SnowballTokenFilterLanguage;
    odatatype: "#Microsoft.Azure.Search.SnowballTokenFilter";
}

// @public
export type SnowballTokenFilterLanguage = string;

// @public
export interface SoftDeleteColumnDeletionDetectionPolicy extends DataDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
    softDeleteColumnName?: string;
    softDeleteMarkerValue?: string;
}

// @public
export interface SplitSkill extends SearchIndexerSkill {
    azureOpenAITokenizerParameters?: AzureOpenAITokenizerParameters;
    defaultLanguageCode?: SplitSkillLanguage;
    maximumPageLength?: number;
    maximumPagesToTake?: number;
    odatatype: "#Microsoft.Skills.Text.SplitSkill";
    pageOverlapLength?: number;
    textSplitMode?: TextSplitMode;
    unit?: SplitSkillUnit;
}

// @public
export type SplitSkillEncoderModelName = string;

// @public
export type SplitSkillLanguage = string;

// @public
export type SplitSkillUnit = string;

// @public
export interface SqlIntegratedChangeTrackingPolicy extends DataChangeDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
}

// @public
export interface StemmerOverrideTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter";
    rules: string[];
}

// @public
export interface StemmerTokenFilter extends TokenFilter {
    language: StemmerTokenFilterLanguage;
    odatatype: "#Microsoft.Azure.Search.StemmerTokenFilter";
}

// @public
export type StemmerTokenFilterLanguage = string;

// @public
export interface StopAnalyzer extends LexicalAnalyzer {
    odatatype: "#Microsoft.Azure.Search.StopAnalyzer";
    stopwords?: string[];
}

// @public
export type StopwordsList = string;

// @public
export interface StopwordsTokenFilter extends TokenFilter {
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.StopwordsTokenFilter";
    removeTrailingStopWords?: boolean;
    stopwords?: string[];
    stopwordsList?: StopwordsList;
}

// @public
export interface SynonymMap {
    encryptionKey?: SearchResourceEncryptionKey;
    eTag?: string;
    format: "solr";
    name: string;
    synonyms: string;
}

// @public
export interface SynonymTokenFilter extends TokenFilter {
    expand?: boolean;
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.SynonymTokenFilter";
    synonyms: string[];
}

// @public
export interface TagScoringFunction extends ScoringFunction {
    parameters: TagScoringParameters;
    type: "tag";
}

// @public
export interface TagScoringParameters {
    tagsParameter: string;
}

// @public
export type TextSplitMode = string;

// @public
export interface TextTranslationSkill extends SearchIndexerSkill {
    defaultFromLanguageCode?: TextTranslationSkillLanguage;
    defaultToLanguageCode: TextTranslationSkillLanguage;
    odatatype: "#Microsoft.Skills.Text.TranslationSkill";
    suggestedFrom?: TextTranslationSkillLanguage;
}

// @public
export type TextTranslationSkillLanguage = string;

// @public
export interface TextWeights {
    weights: Record<string, number>;
}

// @public
export type TokenCharacterKind = string;

// @public
export interface TokenFilter {
    name: string;
    odatatype: string;
}

// @public
export type TokenFilterName = string;

// @public
export type TokenFilterUnion = AsciiFoldingTokenFilter | CjkBigramTokenFilter | CommonGramTokenFilter | DictionaryDecompounderTokenFilter | EdgeNGramTokenFilter | ElisionTokenFilter | KeepTokenFilter | KeywordMarkerTokenFilter | LengthTokenFilter | LimitTokenFilter | NGramTokenFilter | PatternCaptureTokenFilter | PatternReplaceTokenFilter | PhoneticTokenFilter | ShingleTokenFilter | SnowballTokenFilter | StemmerTokenFilter | StemmerOverrideTokenFilter | StopwordsTokenFilter | SynonymTokenFilter | TruncateTokenFilter | UniqueTokenFilter | WordDelimiterTokenFilter | TokenFilter;

// @public
export interface TruncateTokenFilter extends TokenFilter {
    length?: number;
    odatatype: "#Microsoft.Azure.Search.TruncateTokenFilter";
}

// @public
export interface UaxUrlEmailTokenizer extends LexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
}

// @public
export interface UniqueTokenFilter extends TokenFilter {
    odatatype: "#Microsoft.Azure.Search.UniqueTokenFilter";
    onlyOnSamePosition?: boolean;
}

// @public
export type VectorEncodingFormat = string;

// @public
export interface VectorSearch {
    algorithms?: VectorSearchAlgorithmConfigurationUnion[];
    compressions?: VectorSearchCompressionUnion[];
    profiles?: VectorSearchProfile[];
    vectorizers?: VectorSearchVectorizerUnion[];
}

// @public
export interface VectorSearchAlgorithmConfiguration {
    kind: VectorSearchAlgorithmKind;
    name: string;
}

// @public
export type VectorSearchAlgorithmConfigurationUnion = HnswAlgorithmConfiguration | ExhaustiveKnnAlgorithmConfiguration | VectorSearchAlgorithmConfiguration;

// @public
export type VectorSearchAlgorithmKind = string;

// @public
export type VectorSearchAlgorithmMetric = string;

// @public
export interface VectorSearchCompression {
    compressionName: string;
    defaultOversampling?: number;
    kind: VectorSearchCompressionKind;
    rerankWithOriginalVectors?: boolean;
    rescoringOptions?: RescoringOptions;
    truncationDimension?: number;
}

// @public
export type VectorSearchCompressionKind = string;

// @public
export type VectorSearchCompressionRescoreStorageMethod = string;

// @public
export type VectorSearchCompressionTarget = string;

// @public
export type VectorSearchCompressionUnion = ScalarQuantizationCompression | BinaryQuantizationCompression | VectorSearchCompression;

// @public
export interface VectorSearchProfile {
    algorithmConfigurationName: string;
    compressionName?: string;
    name: string;
    vectorizerName?: string;
}

// @public
export interface VectorSearchVectorizer {
    kind: VectorSearchVectorizerKind;
    vectorizerName: string;
}

// @public
export type VectorSearchVectorizerKind = string;

// @public
export type VectorSearchVectorizerUnion = AzureOpenAIVectorizer | WebApiVectorizer | AIServicesVisionVectorizer | AzureMachineLearningVectorizer | VectorSearchVectorizer;

// @public
export interface VisionVectorizeSkill extends SearchIndexerSkill {
    modelVersion: string;
    odatatype: "#Microsoft.Skills.Vision.VectorizeSkill";
}

// @public
export type VisualFeature = string;

// @public
export interface WebApiHttpHeaders {
    additionalProperties?: Record<string, string>;
}

// @public
export interface WebApiSkill extends SearchIndexerSkill {
    authIdentity?: SearchIndexerDataIdentityUnion;
    authResourceId?: string;
    batchSize?: number;
    degreeOfParallelism?: number;
    httpHeaders?: Record<string, string>;
    httpMethod?: string;
    odatatype: "#Microsoft.Skills.Custom.WebApiSkill";
    timeout?: string;
    uri: string;
}

// @public
export interface WebApiVectorizer extends VectorSearchVectorizer {
    kind: "customWebApi";
    webApiParameters?: WebApiVectorizerParameters;
}

// @public
export interface WebApiVectorizerParameters {
    authIdentity?: SearchIndexerDataIdentityUnion;
    authResourceId?: string;
    httpHeaders?: Record<string, string>;
    httpMethod?: string;
    timeout?: string;
    url?: string;
}

// @public
export interface WordDelimiterTokenFilter extends TokenFilter {
    catenateAll?: boolean;
    catenateNumbers?: boolean;
    catenateWords?: boolean;
    generateNumberParts?: boolean;
    generateWordParts?: boolean;
    odatatype: "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
    preserveOriginal?: boolean;
    protectedWords?: string[];
    splitOnCaseChange?: boolean;
    splitOnNumerics?: boolean;
    stemEnglishPossessive?: boolean;
}

// (No @packageDocumentation comment for this package)

```
