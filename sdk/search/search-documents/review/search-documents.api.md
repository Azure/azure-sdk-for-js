## API Report File for "@azure/search-documents"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AzureKeyCredential } from '@azure/core-auth';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AnalyzedTokenInfo {
    readonly endOffset: number;
    readonly position: number;
    readonly startOffset: number;
    readonly token: string;
}

// @public
export interface AnalyzeRequest {
    analyzerName?: string;
    charFilters?: string[];
    normalizerName?: LexicalNormalizerName;
    text: string;
    tokenFilters?: string[];
    tokenizerName?: string;
}

// @public
export interface AnalyzeResult {
    tokens: AnalyzedTokenInfo[];
}

// @public
export type AnalyzeTextOptions = OperationOptions & AnalyzeRequest;

// @public
export interface AnswerResult {
    [property: string]: any;
    readonly highlights?: string;
    readonly key: string;
    readonly score: number;
    readonly text: string;
}

// @public
export type Answers = string;

// @public
export type AsciiFoldingTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter";
    preserveOriginal?: boolean;
};

// @public
export interface AutocompleteItem {
    readonly queryPlusText: string;
    readonly text: string;
}

// @public
export type AutocompleteMode = "oneTerm" | "twoTerms" | "oneTermWithContext";

// @public
export type AutocompleteOptions<Fields> = OperationOptions & AutocompleteRequest<Fields>;

// @public
export interface AutocompleteRequest<Fields> {
    autocompleteMode?: AutocompleteMode;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    searchFields?: Fields[];
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface AutocompleteResult {
    readonly coverage?: number;
    readonly results: AutocompleteItem[];
}

// @public
export interface AzureActiveDirectoryApplicationCredentials {
    applicationId: string;
    applicationSecret?: string;
}

export { AzureKeyCredential }

// @public
export interface BaseCharFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.MappingCharFilter" | "#Microsoft.Azure.Search.PatternReplaceCharFilter";
}

// @public
export interface BaseCognitiveServicesAccount {
    description?: string;
    odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices" | "#Microsoft.Azure.Search.CognitiveServicesByKey";
}

// @public
export interface BaseDataChangeDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy" | "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
}

// @public
export interface BaseDataDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
}

// @public
export interface BaseLexicalAnalyzer {
    name: string;
    odatatype: "#Microsoft.Azure.Search.CustomAnalyzer" | "#Microsoft.Azure.Search.PatternAnalyzer" | "#Microsoft.Azure.Search.StandardAnalyzer" | "#Microsoft.Azure.Search.StopAnalyzer";
}

// @public
export interface BaseLexicalNormalizer {
    name: string;
    odatatype: "#Microsoft.Azure.Search.CustomNormalizer";
}

// @public
export interface BaseLexicalTokenizer {
    name: string;
    odatatype: "#Microsoft.Azure.Search.ClassicTokenizer" | "#Microsoft.Azure.Search.EdgeNGramTokenizer" | "#Microsoft.Azure.Search.KeywordTokenizer" | "#Microsoft.Azure.Search.KeywordTokenizerV2" | "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer" | "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer" | "#Microsoft.Azure.Search.NGramTokenizer" | "#Microsoft.Azure.Search.PathHierarchyTokenizerV2" | "#Microsoft.Azure.Search.PatternTokenizer" | "#Microsoft.Azure.Search.StandardTokenizer" | "#Microsoft.Azure.Search.StandardTokenizerV2" | "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
}

// @public
export interface BaseScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    type: "distance" | "freshness" | "magnitude" | "tag";
}

// @public
export interface BaseSearchIndexerDataIdentity {
    odatatype: "#Microsoft.Azure.Search.SearchIndexerDataNoneIdentity" | "#Microsoft.Azure.Search.SearchIndexerDataUserAssignedIdentity";
}

// @public
export interface BaseSearchIndexerSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Util.ConditionalSkill" | "#Microsoft.Skills.Text.KeyPhraseExtractionSkill" | "#Microsoft.Skills.Vision.OcrSkill" | "#Microsoft.Skills.Vision.ImageAnalysisSkill" | "#Microsoft.Skills.Text.LanguageDetectionSkill" | "#Microsoft.Skills.Util.ShaperSkill" | "#Microsoft.Skills.Text.MergeSkill" | "#Microsoft.Skills.Text.EntityRecognitionSkill" | "#Microsoft.Skills.Text.SentimentSkill" | "#Microsoft.Skills.Text.V3.SentimentSkill" | "#Microsoft.Skills.Text.V3.EntityLinkingSkill" | "#Microsoft.Skills.Text.V3.EntityRecognitionSkill" | "#Microsoft.Skills.Text.PIIDetectionSkill" | "#Microsoft.Skills.Text.SplitSkill" | "#Microsoft.Skills.Text.CustomEntityLookupSkill" | "#Microsoft.Skills.Text.TranslationSkill" | "#Microsoft.Skills.Util.DocumentExtractionSkill" | "#Microsoft.Skills.Custom.WebApiSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface BaseTokenFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter" | "#Microsoft.Azure.Search.CjkBigramTokenFilter" | "#Microsoft.Azure.Search.CommonGramTokenFilter" | "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter" | "#Microsoft.Azure.Search.EdgeNGramTokenFilter" | "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2" | "#Microsoft.Azure.Search.ElisionTokenFilter" | "#Microsoft.Azure.Search.KeepTokenFilter" | "#Microsoft.Azure.Search.KeywordMarkerTokenFilter" | "#Microsoft.Azure.Search.LengthTokenFilter" | "#Microsoft.Azure.Search.LimitTokenFilter" | "#Microsoft.Azure.Search.NGramTokenFilter" | "#Microsoft.Azure.Search.NGramTokenFilterV2" | "#Microsoft.Azure.Search.PatternCaptureTokenFilter" | "#Microsoft.Azure.Search.PatternReplaceTokenFilter" | "#Microsoft.Azure.Search.PhoneticTokenFilter" | "#Microsoft.Azure.Search.ShingleTokenFilter" | "#Microsoft.Azure.Search.SnowballTokenFilter" | "#Microsoft.Azure.Search.StemmerTokenFilter" | "#Microsoft.Azure.Search.StemmerOverrideTokenFilter" | "#Microsoft.Azure.Search.StopwordsTokenFilter" | "#Microsoft.Azure.Search.SynonymTokenFilter" | "#Microsoft.Azure.Search.TruncateTokenFilter" | "#Microsoft.Azure.Search.UniqueTokenFilter" | "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
}

// @public
export type BlobIndexerDataToExtract = string;

// @public
export type BlobIndexerImageAction = string;

// @public
export type BlobIndexerParsingMode = string;

// @public
export type BlobIndexerPDFTextRotationAlgorithm = string;

// @public
export type BM25Similarity = Similarity & {
    odatatype: "#Microsoft.Azure.Search.BM25Similarity";
    k1?: number;
    b?: number;
};

// @public
export interface CaptionResult {
    [property: string]: any;
    readonly highlights?: string;
    readonly text?: string;
}

// @public
export type Captions = string;

// @public
export type CharFilter = MappingCharFilter | PatternReplaceCharFilter;

// @public
export type CharFilterName = string;

// @public
export type CjkBigramTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.CjkBigramTokenFilter";
    ignoreScripts?: CjkBigramTokenFilterScripts[];
    outputUnigrams?: boolean;
};

// @public
export type CjkBigramTokenFilterScripts = "han" | "hiragana" | "katakana" | "hangul";

// @public
export type ClassicSimilarity = Similarity & {
    odatatype: "#Microsoft.Azure.Search.ClassicSimilarity";
};

// @public
export type ClassicTokenizer = BaseLexicalTokenizer & {
    odatatype: "#Microsoft.Azure.Search.ClassicTokenizer";
    maxTokenLength?: number;
};

// @public
export type CognitiveServicesAccount = DefaultCognitiveServicesAccount | CognitiveServicesAccountKey;

// @public
export type CognitiveServicesAccountKey = BaseCognitiveServicesAccount & {
    odatatype: "#Microsoft.Azure.Search.CognitiveServicesByKey";
    key: string;
};

// @public
export type CommonGramTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.CommonGramTokenFilter";
    commonWords: string[];
    ignoreCase?: boolean;
    useQueryMode?: boolean;
};

// @public
export type ComplexDataType = "Edm.ComplexType" | "Collection(Edm.ComplexType)";

// @public
export interface ComplexField {
    fields: SearchField[];
    name: string;
    type: ComplexDataType;
}

// @public
export type ConditionalSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Util.ConditionalSkill";
};

// @public
export interface CorsOptions {
    allowedOrigins: string[];
    maxAgeInSeconds?: number;
}

// @public
export type CountDocumentsOptions = OperationOptions;

// @public
export type CreateDataSourceConnectionOptions = OperationOptions;

// @public
export type CreateIndexerOptions = OperationOptions;

// @public
export type CreateIndexOptions = OperationOptions;

// @public
export interface CreateorUpdateDataSourceConnectionOptions extends OperationOptions {
    ignoreResetRequirements?: boolean;
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateorUpdateIndexerOptions extends OperationOptions {
    disableCacheReprocessingChangeDetection?: boolean;
    ignoreResetRequirements?: boolean;
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateOrUpdateIndexOptions extends OperationOptions {
    allowIndexDowntime?: boolean;
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateOrUpdateSkillsetOptions extends OperationOptions {
    disableCacheReprocessingChangeDetection?: boolean;
    ignoreResetRequirements?: boolean;
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateOrUpdateSynonymMapOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export type CreateSkillsetOptions = OperationOptions;

// @public
export function createSynonymMapFromFile(name: string, filePath: string): Promise<SynonymMap>;

// @public
export type CreateSynonymMapOptions = OperationOptions;

// @public
export interface CustomAnalyzer {
    charFilters?: string[];
    name: string;
    odatatype: "#Microsoft.Azure.Search.CustomAnalyzer";
    tokenFilters?: string[];
    tokenizerName: string;
}

// @public
export interface CustomEntity {
    accentSensitive?: boolean;
    aliases?: CustomEntityAlias[];
    caseSensitive?: boolean;
    defaultAccentSensitive?: boolean;
    defaultCaseSensitive?: boolean;
    defaultFuzzyEditDistance?: number;
    description?: string;
    fuzzyEditDistance?: number;
    id?: string;
    name: string;
    subtype?: string;
    type?: string;
}

// @public
export interface CustomEntityAlias {
    accentSensitive?: boolean;
    caseSensitive?: boolean;
    fuzzyEditDistance?: number;
    text: string;
}

// @public
export type CustomEntityLookupSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.CustomEntityLookupSkill";
    defaultLanguageCode?: CustomEntityLookupSkillLanguage;
    entitiesDefinitionUri?: string;
    inlineEntitiesDefinition?: CustomEntity[];
    globalDefaultCaseSensitive?: boolean;
    globalDefaultAccentSensitive?: boolean;
    globalDefaultFuzzyEditDistance?: number;
};

// @public
export type CustomEntityLookupSkillLanguage = string;

// @public
export type CustomNormalizer = BaseLexicalNormalizer & {
    odatatype: "#Microsoft.Azure.Search.CustomNormalizer";
    tokenFilters?: TokenFilterName[];
    charFilters?: CharFilterName[];
};

// @public
export type DataChangeDetectionPolicy = HighWaterMarkChangeDetectionPolicy | SqlIntegratedChangeTrackingPolicy;

// @public
export type DataDeletionDetectionPolicy = SoftDeleteColumnDeletionDetectionPolicy;

// @public
export const DEFAULT_BATCH_SIZE: number;

// @public
export const DEFAULT_FLUSH_WINDOW: number;

// @public
export const DEFAULT_RETRY_COUNT: number;

// @public
export type DefaultCognitiveServicesAccount = BaseCognitiveServicesAccount & {
    odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices";
};

// @public
export interface DeleteDataSourceConnectionOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export type DeleteDocumentsOptions = IndexDocumentsOptions;

// @public
export interface DeleteIndexerOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteIndexOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteSkillsetOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteSynonymMapOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export type DictionaryDecompounderTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter";
    wordList: string[];
    minWordSize?: number;
    minSubwordSize?: number;
    maxSubwordSize?: number;
    onlyLongestMatch?: boolean;
};

// @public
export type DistanceScoringFunction = BaseScoringFunction & {
    type: "distance";
    parameters: DistanceScoringParameters;
};

// @public
export interface DistanceScoringParameters {
    boostingDistance: number;
    referencePointParameter: string;
}

// @public
export type DocumentExtractionSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Util.DocumentExtractionSkill";
    parsingMode?: string;
    dataToExtract?: string;
    configuration?: {
        [propertyName: string]: any;
    };
};

// @public
export interface EdgeNGramTokenFilter {
    maxGram?: number;
    minGram?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2" | "#Microsoft.Azure.Search.EdgeNGramTokenFilter";
    side?: EdgeNGramTokenFilterSide;
}

// @public
export type EdgeNGramTokenFilterSide = "front" | "back";

// @public
export type EdgeNGramTokenizer = BaseLexicalTokenizer & {
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenizer";
    minGram?: number;
    maxGram?: number;
    tokenChars?: TokenCharacterKind[];
};

// @public
export type ElisionTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.ElisionTokenFilter";
    articles?: string[];
};

// @public
export type EntityCategory = string;

// @public
export type EntityLinkingSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.V3.EntityLinkingSkill";
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    modelVersion?: string;
};

// @public
export type EntityRecognitionSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.EntityRecognitionSkill";
    categories?: EntityCategory[];
    defaultLanguageCode?: EntityRecognitionSkillLanguage;
    includeTypelessEntities?: boolean;
    minimumPrecision?: number;
};

// @public
export type EntityRecognitionSkillLanguage = string;

// @public
export type EntityRecognitionSkillV3 = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.V3.EntityRecognitionSkill";
    categories?: string[];
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    modelVersion?: string;
};

// @public
export interface FacetResult {
    [property: string]: any;
    readonly count?: number;
}

// @public
export interface FieldMapping {
    mappingFunction?: FieldMappingFunction;
    sourceFieldName: string;
    targetFieldName?: string;
}

// @public
export interface FieldMappingFunction {
    name: string;
    parameters?: {
        [propertyName: string]: any;
    };
}

// @public
export type FreshnessScoringFunction = BaseScoringFunction & {
    type: "freshness";
    parameters: FreshnessScoringParameters;
};

// @public
export interface FreshnessScoringParameters {
    boostingDuration: string;
}

// @public
export class GeographyPoint {
    constructor(geographyPoint: {
        longitude: number;
        latitude: number;
    });
    latitude: number;
    longitude: number;
    toJSON(): Record<string, unknown>;
}

// @public
export type GetDataSourceConnectionOptions = OperationOptions;

// @public
export interface GetDocumentOptions<Fields> extends OperationOptions {
    selectedFields?: Fields[];
}

// @public
export type GetIndexerOptions = OperationOptions;

// @public
export type GetIndexerStatusOptions = OperationOptions;

// @public
export type GetIndexOptions = OperationOptions;

// @public
export type GetIndexStatisticsOptions = OperationOptions;

// @public
export type GetServiceStatisticsOptions = OperationOptions;

// @public
export type GetSkillSetOptions = OperationOptions;

// @public
export type GetSynonymMapsOptions = OperationOptions;

// @public
export type HighWaterMarkChangeDetectionPolicy = BaseDataChangeDetectionPolicy & {
    odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy";
    highWaterMarkColumnName: string;
};

// @public
export type ImageAnalysisSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
    defaultLanguageCode?: ImageAnalysisSkillLanguage;
    visualFeatures?: VisualFeature[];
    details?: ImageDetail[];
};

// @public
export type ImageAnalysisSkillLanguage = string;

// @public
export type ImageDetail = string;

// @public
export type IndexActionType = "upload" | "merge" | "mergeOrUpload" | "delete";

// @public
export type IndexDocumentsAction<T> = {
    __actionType: IndexActionType;
} & Partial<T>;

// @public
export class IndexDocumentsBatch<T> {
    constructor(actions?: IndexDocumentsAction<T>[]);
    readonly actions: IndexDocumentsAction<T>[];
    delete(keyName: keyof T, keyValues: string[]): void;
    delete(documents: T[]): void;
    merge(documents: T[]): void;
    mergeOrUpload(documents: T[]): void;
    upload(documents: T[]): void;
}

// @public
export interface IndexDocumentsClient<T> {
    indexDocuments(batch: IndexDocumentsBatch<T>, options: IndexDocumentsOptions): Promise<IndexDocumentsResult>;
}

// @public
export interface IndexDocumentsOptions extends OperationOptions {
    throwOnAnyFailure?: boolean;
}

// @public
export interface IndexDocumentsResult {
    readonly results: IndexingResult[];
}

// @public
export type IndexerExecutionEnvironment = string;

// @public
export interface IndexerExecutionResult {
    readonly endTime?: Date;
    readonly errorMessage?: string;
    readonly errors: SearchIndexerError[];
    readonly failedItemCount: number;
    readonly finalTrackingState?: string;
    readonly initialTrackingState?: string;
    readonly itemCount: number;
    readonly startTime?: Date;
    readonly status: IndexerExecutionStatus;
    readonly warnings: SearchIndexerWarning[];
}

// @public
export type IndexerExecutionStatus = "transientFailure" | "success" | "inProgress" | "reset";

// @public
export type IndexerStatus = "unknown" | "error" | "running";

// @public
export interface IndexingParameters {
    batchSize?: number;
    configuration?: IndexingParametersConfiguration;
    maxFailedItems?: number;
    maxFailedItemsPerBatch?: number;
}

// @public
export interface IndexingParametersConfiguration {
    [property: string]: any;
    allowSkillsetToReadFileData?: boolean;
    dataToExtract?: BlobIndexerDataToExtract;
    delimitedTextDelimiter?: string;
    delimitedTextHeaders?: string;
    documentRoot?: string;
    excludedFileNameExtensions?: string;
    executionEnvironment?: IndexerExecutionEnvironment;
    failOnUnprocessableDocument?: boolean;
    failOnUnsupportedContentType?: boolean;
    firstLineContainsHeaders?: boolean;
    imageAction?: BlobIndexerImageAction;
    indexedFileNameExtensions?: string;
    indexStorageMetadataOnlyForOversizedDocuments?: boolean;
    parsingMode?: BlobIndexerParsingMode;
    pdfTextRotationAlgorithm?: BlobIndexerPDFTextRotationAlgorithm;
    queryTimeout?: string;
}

// @public
export interface IndexingResult {
    readonly errorMessage?: string;
    readonly key: string;
    readonly statusCode: number;
    readonly succeeded: boolean;
}

// @public
export interface IndexingSchedule {
    interval: string;
    startTime?: Date;
}

// @public
export type IndexIterator = PagedAsyncIterableIterator<SearchIndex, SearchIndex[], {}>;

// @public
export type IndexNameIterator = PagedAsyncIterableIterator<string, string[], {}>;

// @public
export interface InputFieldMappingEntry {
    inputs?: InputFieldMappingEntry[];
    name: string;
    source?: string;
    sourceContext?: string;
}

// @public
export type KeepTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.KeepTokenFilter";
    keepWords: string[];
    lowerCaseKeepWords?: boolean;
};

// @public
export type KeyPhraseExtractionSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill";
    defaultLanguageCode?: KeyPhraseExtractionSkillLanguage;
    maxKeyPhraseCount?: number;
    modelVersion?: string;
};

// @public
export type KeyPhraseExtractionSkillLanguage = string;

// @public
export type KeywordMarkerTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter";
    keywords: string[];
    ignoreCase?: boolean;
};

// @public
export interface KeywordTokenizer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.KeywordTokenizerV2" | "#Microsoft.Azure.Search.KeywordTokenizer";
}

// @public
export enum KnownAnalyzerNames {
    ArLucene = "ar.lucene",
    ArMicrosoft = "ar.microsoft",
    BgLucene = "bg.lucene",
    BgMicrosoft = "bg.microsoft",
    BnMicrosoft = "bn.microsoft",
    CaLucene = "ca.lucene",
    CaMicrosoft = "ca.microsoft",
    CsLucene = "cs.lucene",
    CsMicrosoft = "cs.microsoft",
    DaLucene = "da.lucene",
    DaMicrosoft = "da.microsoft",
    DeLucene = "de.lucene",
    DeMicrosoft = "de.microsoft",
    ElLucene = "el.lucene",
    ElMicrosoft = "el.microsoft",
    EnLucene = "en.lucene",
    EnMicrosoft = "en.microsoft",
    EsLucene = "es.lucene",
    EsMicrosoft = "es.microsoft",
    EtMicrosoft = "et.microsoft",
    EuLucene = "eu.lucene",
    FaLucene = "fa.lucene",
    FiLucene = "fi.lucene",
    FiMicrosoft = "fi.microsoft",
    FrLucene = "fr.lucene",
    FrMicrosoft = "fr.microsoft",
    GaLucene = "ga.lucene",
    GlLucene = "gl.lucene",
    GuMicrosoft = "gu.microsoft",
    HeMicrosoft = "he.microsoft",
    HiLucene = "hi.lucene",
    HiMicrosoft = "hi.microsoft",
    HrMicrosoft = "hr.microsoft",
    HuLucene = "hu.lucene",
    HuMicrosoft = "hu.microsoft",
    HyLucene = "hy.lucene",
    IdLucene = "id.lucene",
    IdMicrosoft = "id.microsoft",
    IsMicrosoft = "is.microsoft",
    ItLucene = "it.lucene",
    ItMicrosoft = "it.microsoft",
    JaLucene = "ja.lucene",
    JaMicrosoft = "ja.microsoft",
    Keyword = "keyword",
    KnMicrosoft = "kn.microsoft",
    KoLucene = "ko.lucene",
    KoMicrosoft = "ko.microsoft",
    LtMicrosoft = "lt.microsoft",
    LvLucene = "lv.lucene",
    LvMicrosoft = "lv.microsoft",
    MlMicrosoft = "ml.microsoft",
    MrMicrosoft = "mr.microsoft",
    MsMicrosoft = "ms.microsoft",
    NbMicrosoft = "nb.microsoft",
    NlLucene = "nl.lucene",
    NlMicrosoft = "nl.microsoft",
    NoLucene = "no.lucene",
    PaMicrosoft = "pa.microsoft",
    Pattern = "pattern",
    PlLucene = "pl.lucene",
    PlMicrosoft = "pl.microsoft",
    PtBRLucene = "pt-BR.lucene",
    PtBRMicrosoft = "pt-BR.microsoft",
    PtPTLucene = "pt-PT.lucene",
    PtPTMicrosoft = "pt-PT.microsoft",
    RoLucene = "ro.lucene",
    RoMicrosoft = "ro.microsoft",
    RuLucene = "ru.lucene",
    RuMicrosoft = "ru.microsoft",
    Simple = "simple",
    SkMicrosoft = "sk.microsoft",
    SlMicrosoft = "sl.microsoft",
    SrCyrillicMicrosoft = "sr-cyrillic.microsoft",
    SrLatinMicrosoft = "sr-latin.microsoft",
    StandardAsciiFoldingLucene = "standardasciifolding.lucene",
    StandardLucene = "standard.lucene",
    Stop = "stop",
    SvLucene = "sv.lucene",
    SvMicrosoft = "sv.microsoft",
    TaMicrosoft = "ta.microsoft",
    TeMicrosoft = "te.microsoft",
    ThLucene = "th.lucene",
    ThMicrosoft = "th.microsoft",
    TrLucene = "tr.lucene",
    TrMicrosoft = "tr.microsoft",
    UkMicrosoft = "uk.microsoft",
    UrMicrosoft = "ur.microsoft",
    ViMicrosoft = "vi.microsoft",
    Whitespace = "whitespace",
    ZhHansLucene = "zh-Hans.lucene",
    ZhHansMicrosoft = "zh-Hans.microsoft",
    ZhHantLucene = "zh-Hant.lucene",
    ZhHantMicrosoft = "zh-Hant.microsoft"
}

// @public
export const enum KnownAnswers {
    Extractive = "extractive",
    None = "none"
}

// @public
export const enum KnownBlobIndexerDataToExtract {
    AllMetadata = "allMetadata",
    ContentAndMetadata = "contentAndMetadata",
    StorageMetadata = "storageMetadata"
}

// @public
export const enum KnownBlobIndexerImageAction {
    GenerateNormalizedImagePerPage = "generateNormalizedImagePerPage",
    GenerateNormalizedImages = "generateNormalizedImages",
    None = "none"
}

// @public
export const enum KnownBlobIndexerParsingMode {
    Default = "default",
    DelimitedText = "delimitedText",
    Json = "json",
    JsonArray = "jsonArray",
    JsonLines = "jsonLines",
    Text = "text"
}

// @public
export const enum KnownBlobIndexerPDFTextRotationAlgorithm {
    DetectAngles = "detectAngles",
    None = "none"
}

// @public
export const enum KnownCharFilterName {
    HtmlStrip = "html_strip"
}

// @public
export enum KnownCharFilterNames {
    HtmlStrip = "html_strip"
}

// @public
export const enum KnownCustomEntityLookupSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ko = "ko",
    Pt = "pt"
}

// @public
export const enum KnownEntityCategory {
    Datetime = "datetime",
    Email = "email",
    Location = "location",
    Organization = "organization",
    Person = "person",
    Quantity = "quantity",
    Url = "url"
}

// @public
export const enum KnownEntityRecognitionSkillLanguage {
    Ar = "ar",
    Cs = "cs",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    Hu = "hu",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv",
    Tr = "tr",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export const enum KnownImageAnalysisSkillLanguage {
    En = "en",
    Es = "es",
    Ja = "ja",
    Pt = "pt",
    Zh = "zh"
}

// @public
export const enum KnownImageDetail {
    Celebrities = "celebrities",
    Landmarks = "landmarks"
}

// @public
export const enum KnownKeyPhraseExtractionSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv"
}

// @public
export const enum KnownLexicalAnalyzerName {
    ArLucene = "ar.lucene",
    ArMicrosoft = "ar.microsoft",
    BgLucene = "bg.lucene",
    BgMicrosoft = "bg.microsoft",
    BnMicrosoft = "bn.microsoft",
    CaLucene = "ca.lucene",
    CaMicrosoft = "ca.microsoft",
    CsLucene = "cs.lucene",
    CsMicrosoft = "cs.microsoft",
    DaLucene = "da.lucene",
    DaMicrosoft = "da.microsoft",
    DeLucene = "de.lucene",
    DeMicrosoft = "de.microsoft",
    ElLucene = "el.lucene",
    ElMicrosoft = "el.microsoft",
    EnLucene = "en.lucene",
    EnMicrosoft = "en.microsoft",
    EsLucene = "es.lucene",
    EsMicrosoft = "es.microsoft",
    EtMicrosoft = "et.microsoft",
    EuLucene = "eu.lucene",
    FaLucene = "fa.lucene",
    FiLucene = "fi.lucene",
    FiMicrosoft = "fi.microsoft",
    FrLucene = "fr.lucene",
    FrMicrosoft = "fr.microsoft",
    GaLucene = "ga.lucene",
    GlLucene = "gl.lucene",
    GuMicrosoft = "gu.microsoft",
    HeMicrosoft = "he.microsoft",
    HiLucene = "hi.lucene",
    HiMicrosoft = "hi.microsoft",
    HrMicrosoft = "hr.microsoft",
    HuLucene = "hu.lucene",
    HuMicrosoft = "hu.microsoft",
    HyLucene = "hy.lucene",
    IdLucene = "id.lucene",
    IdMicrosoft = "id.microsoft",
    IsMicrosoft = "is.microsoft",
    ItLucene = "it.lucene",
    ItMicrosoft = "it.microsoft",
    JaLucene = "ja.lucene",
    JaMicrosoft = "ja.microsoft",
    Keyword = "keyword",
    KnMicrosoft = "kn.microsoft",
    KoLucene = "ko.lucene",
    KoMicrosoft = "ko.microsoft",
    LtMicrosoft = "lt.microsoft",
    LvLucene = "lv.lucene",
    LvMicrosoft = "lv.microsoft",
    MlMicrosoft = "ml.microsoft",
    MrMicrosoft = "mr.microsoft",
    MsMicrosoft = "ms.microsoft",
    NbMicrosoft = "nb.microsoft",
    NlLucene = "nl.lucene",
    NlMicrosoft = "nl.microsoft",
    NoLucene = "no.lucene",
    PaMicrosoft = "pa.microsoft",
    Pattern = "pattern",
    PlLucene = "pl.lucene",
    PlMicrosoft = "pl.microsoft",
    PtBrLucene = "pt-BR.lucene",
    PtBrMicrosoft = "pt-BR.microsoft",
    PtPtLucene = "pt-PT.lucene",
    PtPtMicrosoft = "pt-PT.microsoft",
    RoLucene = "ro.lucene",
    RoMicrosoft = "ro.microsoft",
    RuLucene = "ru.lucene",
    RuMicrosoft = "ru.microsoft",
    Simple = "simple",
    SkMicrosoft = "sk.microsoft",
    SlMicrosoft = "sl.microsoft",
    SrCyrillicMicrosoft = "sr-cyrillic.microsoft",
    SrLatinMicrosoft = "sr-latin.microsoft",
    StandardAsciiFoldingLucene = "standardasciifolding.lucene",
    StandardLucene = "standard.lucene",
    Stop = "stop",
    SvLucene = "sv.lucene",
    SvMicrosoft = "sv.microsoft",
    TaMicrosoft = "ta.microsoft",
    TeMicrosoft = "te.microsoft",
    ThLucene = "th.lucene",
    ThMicrosoft = "th.microsoft",
    TrLucene = "tr.lucene",
    TrMicrosoft = "tr.microsoft",
    UkMicrosoft = "uk.microsoft",
    UrMicrosoft = "ur.microsoft",
    ViMicrosoft = "vi.microsoft",
    Whitespace = "whitespace",
    ZhHansLucene = "zh-Hans.lucene",
    ZhHansMicrosoft = "zh-Hans.microsoft",
    ZhHantLucene = "zh-Hant.lucene",
    ZhHantMicrosoft = "zh-Hant.microsoft"
}

// @public
export const enum KnownLexicalNormalizerName {
    AsciiFolding = "asciifolding",
    Elision = "elision",
    Lowercase = "lowercase",
    Standard = "standard",
    Uppercase = "uppercase"
}

// @public
export const enum KnownLineEnding {
    CarriageReturn = "carriageReturn",
    CarriageReturnLineFeed = "carriageReturnLineFeed",
    LineFeed = "lineFeed",
    Space = "space"
}

// @public
export const enum KnownOcrSkillLanguage {
    Ar = "ar",
    Cs = "cs",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    Hu = "hu",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Nb = "nb",
    Nl = "nl",
    Pl = "pl",
    Pt = "pt",
    Ro = "ro",
    Ru = "ru",
    Sk = "sk",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Sv = "sv",
    Tr = "tr",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export const enum KnownPIIDetectionSkillMaskingMode {
    None = "none",
    Replace = "replace"
}

// @public
export const enum KnownQueryLanguage {
    EnUs = "en-us",
    None = "none"
}

// @public
export const enum KnownRegexFlags {
    CanonEq = "CANON_EQ",
    CaseInsensitive = "CASE_INSENSITIVE",
    Comments = "COMMENTS",
    DotAll = "DOTALL",
    Literal = "LITERAL",
    Multiline = "MULTILINE",
    UnicodeCase = "UNICODE_CASE",
    UnixLines = "UNIX_LINES"
}

// @public
export const enum KnownSearchIndexerDataSourceType {
    AdlsGen2 = "adlsgen2",
    AzureBlob = "azureblob",
    AzureSql = "azuresql",
    AzureTable = "azuretable",
    CosmosDb = "cosmosdb",
    MySql = "mysql"
}

// @public
export const enum KnownSentimentSkillLanguage {
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv",
    Tr = "tr"
}

// @public
export const enum KnownSpeller {
    Lexicon = "lexicon",
    None = "none"
}

// @public
export const enum KnownSplitSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ko = "ko",
    Pt = "pt"
}

// @public
export const enum KnownTextSplitMode {
    Pages = "pages",
    Sentences = "sentences"
}

// @public
export const enum KnownTextTranslationSkillLanguage {
    Af = "af",
    Ar = "ar",
    Bg = "bg",
    Bn = "bn",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Fa = "fa",
    Fi = "fi",
    Fil = "fil",
    Fj = "fj",
    Fr = "fr",
    Ga = "ga",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Ht = "ht",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Ja = "ja",
    Kn = "kn",
    Ko = "ko",
    Lt = "lt",
    Lv = "lv",
    Mg = "mg",
    Mi = "mi",
    Ml = "ml",
    Ms = "ms",
    Mt = "mt",
    Mww = "mww",
    Nb = "nb",
    Nl = "nl",
    Otq = "otq",
    Pa = "pa",
    Pl = "pl",
    Pt = "pt",
    PtBr = "pt-br",
    PtPT = "pt-PT",
    Ro = "ro",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    Sm = "sm",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Sv = "sv",
    Sw = "sw",
    Ta = "ta",
    Te = "te",
    Th = "th",
    Tlh = "tlh",
    TlhLatn = "tlh-Latn",
    TlhPiqd = "tlh-Piqd",
    To = "to",
    Tr = "tr",
    Ty = "ty",
    Uk = "uk",
    Ur = "ur",
    Vi = "vi",
    Yua = "yua",
    Yue = "yue",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export const enum KnownTokenFilterName {
    Apostrophe = "apostrophe",
    ArabicNormalization = "arabic_normalization",
    AsciiFolding = "asciifolding",
    CjkBigram = "cjk_bigram",
    CjkWidth = "cjk_width",
    Classic = "classic",
    CommonGram = "common_grams",
    EdgeNGram = "edgeNGram_v2",
    Elision = "elision",
    GermanNormalization = "german_normalization",
    HindiNormalization = "hindi_normalization",
    IndicNormalization = "indic_normalization",
    KeywordRepeat = "keyword_repeat",
    KStem = "kstem",
    Length = "length",
    Limit = "limit",
    Lowercase = "lowercase",
    NGram = "nGram_v2",
    PersianNormalization = "persian_normalization",
    Phonetic = "phonetic",
    PorterStem = "porter_stem",
    Reverse = "reverse",
    ScandinavianFoldingNormalization = "scandinavian_folding",
    ScandinavianNormalization = "scandinavian_normalization",
    Shingle = "shingle",
    Snowball = "snowball",
    SoraniNormalization = "sorani_normalization",
    Stemmer = "stemmer",
    Stopwords = "stopwords",
    Trim = "trim",
    Truncate = "truncate",
    Unique = "unique",
    Uppercase = "uppercase",
    WordDelimiter = "word_delimiter"
}

// @public
export enum KnownTokenFilterNames {
    Apostrophe = "apostrophe",
    ArabicNormalization = "arabic_normalization",
    AsciiFolding = "asciifolding",
    CjkBigram = "cjk_bigram",
    CjkWidth = "cjk_width",
    Classic = "classic",
    CommonGram = "common_grams",
    EdgeNGram = "edgeNGram_v2",
    Elision = "elision",
    GermanNormalization = "german_normalization",
    HindiNormalization = "hindi_normalization",
    IndicNormalization = "indic_normalization",
    KeywordRepeat = "keyword_repeat",
    KStem = "kstem",
    Length = "length",
    Limit = "limit",
    Lowercase = "lowercase",
    NGram = "nGram_v2",
    PersianNormalization = "persian_normalization",
    Phonetic = "phonetic",
    PorterStem = "porter_stem",
    Reverse = "reverse",
    ScandinavianFoldingNormalization = "scandinavian_folding",
    ScandinavianNormalization = "scandinavian_normalization",
    Shingle = "shingle",
    Snowball = "snowball",
    SoraniNormalization = "sorani_normalization",
    Stemmer = "stemmer",
    Stopwords = "stopwords",
    Trim = "trim",
    Truncate = "truncate",
    Unique = "unique",
    Uppercase = "uppercase",
    WordDelimiter = "word_delimiter"
}

// @public
export enum KnownTokenizerNames {
    Classic = "classic",
    EdgeNGram = "edgeNGram",
    Keyword = "keyword_v2",
    Letter = "letter",
    Lowercase = "lowercase",
    MicrosoftLanguageStemmingTokenizer = "microsoft_language_stemming_tokenizer",
    MicrosoftLanguageTokenizer = "microsoft_language_tokenizer",
    NGram = "nGram",
    PathHierarchy = "path_hierarchy_v2",
    Pattern = "pattern",
    Standard = "standard_v2",
    UaxUrlEmail = "uax_url_email",
    Whitespace = "whitespace"
}

// @public
export const enum KnownVisualFeature {
    Adult = "adult",
    Brands = "brands",
    Categories = "categories",
    Description = "description",
    Faces = "faces",
    Objects = "objects",
    Tags = "tags"
}

// @public
export type LanguageDetectionSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.LanguageDetectionSkill";
    defaultCountryHint?: string;
    modelVersion?: string;
};

// @public
export type LengthTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.LengthTokenFilter";
    minLength?: number;
    maxLength?: number;
};

// @public
export type LexicalAnalyzer = CustomAnalyzer | PatternAnalyzer | LuceneStandardAnalyzer | StopAnalyzer;

// @public
export type LexicalAnalyzerName = string;

// @public
export type LexicalNormalizer = CustomNormalizer;

// @public
export type LexicalNormalizerName = string;

// @public
export type LexicalTokenizer = ClassicTokenizer | EdgeNGramTokenizer | KeywordTokenizer | MicrosoftLanguageTokenizer | MicrosoftLanguageStemmingTokenizer | NGramTokenizer | PathHierarchyTokenizer | PatternTokenizer | LuceneStandardTokenizer | UaxUrlEmailTokenizer;

// @public
export type LimitTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.LimitTokenFilter";
    maxTokenCount?: number;
    consumeAllTokens?: boolean;
};

// @public
export type LineEnding = string;

// @public
export type ListDataSourceConnectionsOptions = OperationOptions;

// @public
export type ListIndexersOptions = OperationOptions;

// @public
export type ListIndexesOptions = OperationOptions;

// @public
export interface ListSearchResultsPageSettings {
    continuationToken?: string;
}

// @public
export type ListSkillsetsOptions = OperationOptions;

// @public
export type ListSynonymMapsOptions = OperationOptions;

// @public
export type LuceneStandardAnalyzer = BaseLexicalAnalyzer & {
    odatatype: "#Microsoft.Azure.Search.StandardAnalyzer";
    maxTokenLength?: number;
    stopwords?: string[];
};

// @public
export interface LuceneStandardTokenizer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.StandardTokenizerV2" | "#Microsoft.Azure.Search.StandardTokenizer";
}

// @public
export type MagnitudeScoringFunction = BaseScoringFunction & {
    type: "magnitude";
    parameters: MagnitudeScoringParameters;
};

// @public
export interface MagnitudeScoringParameters {
    boostingRangeEnd: number;
    boostingRangeStart: number;
    shouldBoostBeyondRangeByConstant?: boolean;
}

// @public
export type MappingCharFilter = BaseCharFilter & {
    odatatype: "#Microsoft.Azure.Search.MappingCharFilter";
    mappings: string[];
};

// @public
export type MergeDocumentsOptions = IndexDocumentsOptions;

// @public
export type MergeOrUploadDocumentsOptions = IndexDocumentsOptions;

// @public
export type MergeSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.MergeSkill";
    insertPreTag?: string;
    insertPostTag?: string;
};

// @public
export type MicrosoftLanguageStemmingTokenizer = BaseLexicalTokenizer & {
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer";
    maxTokenLength?: number;
    isSearchTokenizer?: boolean;
    language?: MicrosoftStemmingTokenizerLanguage;
};

// @public
export type MicrosoftLanguageTokenizer = BaseLexicalTokenizer & {
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer";
    maxTokenLength?: number;
    isSearchTokenizer?: boolean;
    language?: MicrosoftTokenizerLanguage;
};

// @public
export type MicrosoftStemmingTokenizerLanguage = "arabic" | "bangla" | "bulgarian" | "catalan" | "croatian" | "czech" | "danish" | "dutch" | "english" | "estonian" | "finnish" | "french" | "german" | "greek" | "gujarati" | "hebrew" | "hindi" | "hungarian" | "icelandic" | "indonesian" | "italian" | "kannada" | "latvian" | "lithuanian" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovak" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "turkish" | "ukrainian" | "urdu";

// @public
export type MicrosoftTokenizerLanguage = "bangla" | "bulgarian" | "catalan" | "chineseSimplified" | "chineseTraditional" | "croatian" | "czech" | "danish" | "dutch" | "english" | "french" | "german" | "greek" | "gujarati" | "hindi" | "icelandic" | "indonesian" | "italian" | "japanese" | "kannada" | "korean" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "thai" | "ukrainian" | "urdu" | "vietnamese";

// @public
export interface NGramTokenFilter {
    maxGram?: number;
    minGram?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.NGramTokenFilterV2" | "#Microsoft.Azure.Search.NGramTokenFilter";
}

// @public
export type NGramTokenizer = BaseLexicalTokenizer & {
    odatatype: "#Microsoft.Azure.Search.NGramTokenizer";
    minGram?: number;
    maxGram?: number;
    tokenChars?: TokenCharacterKind[];
};

// @public
export type OcrSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Vision.OcrSkill";
    defaultLanguageCode?: OcrSkillLanguage;
    shouldDetectOrientation?: boolean;
    lineEnding?: LineEnding;
};

// @public
export type OcrSkillLanguage = string;

// @public
export function odata(strings: TemplateStringsArray, ...values: unknown[]): string;

// @public
export interface OutputFieldMappingEntry {
    name: string;
    targetName?: string;
}

// @public
export type PathHierarchyTokenizer = BaseLexicalTokenizer & {
    odatatype: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2";
    delimiter?: string;
    replacement?: string;
    maxTokenLength?: number;
    reverseTokenOrder?: boolean;
    numberOfTokensToSkip?: number;
};

// @public
export interface PatternAnalyzer {
    flags?: RegexFlags[];
    lowerCaseTerms?: boolean;
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternAnalyzer";
    pattern?: string;
    stopwords?: string[];
}

// @public
export type PatternCaptureTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.PatternCaptureTokenFilter";
    patterns: string[];
    preserveOriginal?: boolean;
};

// @public
export type PatternReplaceCharFilter = BaseCharFilter & {
    odatatype: "#Microsoft.Azure.Search.PatternReplaceCharFilter";
    pattern: string;
    replacement: string;
};

// @public
export type PatternReplaceTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.PatternReplaceTokenFilter";
    pattern: string;
    replacement: string;
};

// @public
export interface PatternTokenizer {
    flags?: RegexFlags[];
    group?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternTokenizer";
    pattern?: string;
}

// @public
export type PhoneticEncoder = "metaphone" | "doubleMetaphone" | "soundex" | "refinedSoundex" | "caverphone1" | "caverphone2" | "cologne" | "nysiis" | "koelnerPhonetik" | "haasePhonetik" | "beiderMorse";

// @public
export type PhoneticTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.PhoneticTokenFilter";
    encoder?: PhoneticEncoder;
    replaceOriginalTokens?: boolean;
};

// @public
export type PIIDetectionSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.PIIDetectionSkill";
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    maskingMode?: PIIDetectionSkillMaskingMode;
    maskingCharacter?: string;
    modelVersion?: string;
    piiCategories?: string[];
    domain?: string;
};

// @public
export type PIIDetectionSkillMaskingMode = string;

// @public
export type QueryLanguage = string;

// @public
export type QueryType = "simple" | "full" | "semantic";

// @public
export type RegexFlags = string;

// @public
export type ResetIndexerOptions = OperationOptions;

// @public
export interface ResourceCounter {
    quota?: number;
    usage: number;
}

// @public
export type RunIndexerOptions = OperationOptions;

// @public
export type ScoringFunction = DistanceScoringFunction | FreshnessScoringFunction | MagnitudeScoringFunction | TagScoringFunction;

// @public
export type ScoringFunctionAggregation = "sum" | "average" | "minimum" | "maximum" | "firstMatching";

// @public
export type ScoringFunctionInterpolation = "linear" | "constant" | "quadratic" | "logarithmic";

// @public
export interface ScoringProfile {
    functionAggregation?: ScoringFunctionAggregation;
    functions?: ScoringFunction[];
    name: string;
    textWeights?: TextWeights;
}

// @public
export type ScoringStatistics = "local" | "global";

// @public
export class SearchClient<T> implements IndexDocumentsClient<T> {
    constructor(endpoint: string, indexName: string, credential: KeyCredential | TokenCredential, options?: SearchClientOptions);
    readonly apiVersion: string;
    autocomplete<Fields extends keyof T>(searchText: string, suggesterName: string, options?: AutocompleteOptions<Fields>): Promise<AutocompleteResult>;
    deleteDocuments(documents: T[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
    deleteDocuments(keyName: keyof T, keyValues: string[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
    readonly endpoint: string;
    getDocument<Fields extends keyof T>(key: string, options?: GetDocumentOptions<Fields>): Promise<T>;
    getDocumentsCount(options?: CountDocumentsOptions): Promise<number>;
    indexDocuments(batch: IndexDocumentsBatch<T>, options?: IndexDocumentsOptions): Promise<IndexDocumentsResult>;
    readonly indexName: string;
    mergeDocuments(documents: T[], options?: MergeDocumentsOptions): Promise<IndexDocumentsResult>;
    mergeOrUploadDocuments(documents: T[], options?: MergeOrUploadDocumentsOptions): Promise<IndexDocumentsResult>;
    search<Fields extends keyof T>(searchText?: string, options?: SearchOptions<Fields>): Promise<SearchDocumentsResult<Pick<T, Fields>>>;
    suggest<Fields extends keyof T = never>(searchText: string, suggesterName: string, options?: SuggestOptions<Fields>): Promise<SuggestDocumentsResult<Pick<T, Fields>>>;
    uploadDocuments(documents: T[], options?: UploadDocumentsOptions): Promise<IndexDocumentsResult>;
}

// @public
export interface SearchClientOptions extends PipelineOptions {
    apiVersion?: string;
}

// @public
export interface SearchDocumentsPageResult<T> extends SearchDocumentsResultBase {
    continuationToken?: string;
    readonly results: SearchResult<T>[];
}

// @public
export interface SearchDocumentsResult<T> extends SearchDocumentsResultBase {
    readonly results: SearchIterator<T>;
}

// @public
export interface SearchDocumentsResultBase {
    readonly answers?: AnswerResult[];
    readonly count?: number;
    readonly coverage?: number;
    readonly facets?: {
        [propertyName: string]: FacetResult[];
    };
}

// @public
export type SearchField = SimpleField | ComplexField;

// @public
export type SearchFieldDataType = "Edm.String" | "Edm.Int32" | "Edm.Int64" | "Edm.Double" | "Edm.Boolean" | "Edm.DateTimeOffset" | "Edm.GeographyPoint" | "Collection(Edm.String)" | "Collection(Edm.Int32)" | "Collection(Edm.Int64)" | "Collection(Edm.Double)" | "Collection(Edm.Boolean)" | "Collection(Edm.DateTimeOffset)" | "Collection(Edm.GeographyPoint)";

// @public
export interface SearchIndex {
    analyzers?: LexicalAnalyzer[];
    charFilters?: CharFilter[];
    corsOptions?: CorsOptions;
    defaultScoringProfile?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    fields: SearchField[];
    name: string;
    normalizers?: LexicalNormalizer[];
    scoringProfiles?: ScoringProfile[];
    similarity?: SimilarityAlgorithm;
    suggesters?: SearchSuggester[];
    tokenFilters?: TokenFilter[];
    tokenizers?: LexicalTokenizer[];
}

// @public
export class SearchIndexClient {
    constructor(endpoint: string, credential: KeyCredential | TokenCredential, options?: SearchIndexClientOptions);
    analyzeText(indexName: string, options: AnalyzeTextOptions): Promise<AnalyzeResult>;
    readonly apiVersion: string;
    createIndex(index: SearchIndex, options?: CreateIndexOptions): Promise<SearchIndex>;
    createOrUpdateIndex(index: SearchIndex, options?: CreateOrUpdateIndexOptions): Promise<SearchIndex>;
    createOrUpdateSynonymMap(synonymMap: SynonymMap, options?: CreateOrUpdateSynonymMapOptions): Promise<SynonymMap>;
    createSynonymMap(synonymMap: SynonymMap, options?: CreateSynonymMapOptions): Promise<SynonymMap>;
    deleteIndex(index: string | SearchIndex, options?: DeleteIndexOptions): Promise<void>;
    deleteSynonymMap(synonymMap: string | SynonymMap, options?: DeleteSynonymMapOptions): Promise<void>;
    readonly endpoint: string;
    getIndex(indexName: string, options?: GetIndexOptions): Promise<SearchIndex>;
    getIndexStatistics(indexName: string, options?: GetIndexStatisticsOptions): Promise<SearchIndexStatistics>;
    getSearchClient<T>(indexName: string, options?: SearchClientOptions): SearchClient<T>;
    getServiceStatistics(options?: GetServiceStatisticsOptions): Promise<SearchServiceStatistics>;
    getSynonymMap(synonymMapName: string, options?: GetSynonymMapsOptions): Promise<SynonymMap>;
    listIndexes(options?: ListIndexesOptions): IndexIterator;
    listIndexesNames(options?: ListIndexesOptions): IndexNameIterator;
    listSynonymMaps(options?: ListSynonymMapsOptions): Promise<Array<SynonymMap>>;
    listSynonymMapsNames(options?: ListSynonymMapsOptions): Promise<Array<string>>;
    }

// @public
export interface SearchIndexClientOptions extends PipelineOptions {
    apiVersion?: string;
}

// @public
export interface SearchIndexer {
    cache?: SearchIndexerCache;
    dataSourceName: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    fieldMappings?: FieldMapping[];
    isDisabled?: boolean;
    name: string;
    outputFieldMappings?: FieldMapping[];
    parameters?: IndexingParameters;
    schedule?: IndexingSchedule;
    skillsetName?: string;
    targetIndexName: string;
}

// @public (undocumented)
export interface SearchIndexerCache {
    enableReprocessing?: boolean;
    storageConnectionString?: string;
}

// @public
export class SearchIndexerClient {
    constructor(endpoint: string, credential: KeyCredential | TokenCredential, options?: SearchIndexerClientOptions);
    readonly apiVersion: string;
    createDataSourceConnection(dataSourceConnection: SearchIndexerDataSourceConnection, options?: CreateDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    createIndexer(indexer: SearchIndexer, options?: CreateIndexerOptions): Promise<SearchIndexer>;
    createOrUpdateDataSourceConnection(dataSourceConnection: SearchIndexerDataSourceConnection, options?: CreateorUpdateDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    createOrUpdateIndexer(indexer: SearchIndexer, options?: CreateorUpdateIndexerOptions): Promise<SearchIndexer>;
    createOrUpdateSkillset(skillset: SearchIndexerSkillset, options?: CreateOrUpdateSkillsetOptions): Promise<SearchIndexerSkillset>;
    createSkillset(skillset: SearchIndexerSkillset, options?: CreateSkillsetOptions): Promise<SearchIndexerSkillset>;
    deleteDataSourceConnection(dataSourceConnection: string | SearchIndexerDataSourceConnection, options?: DeleteDataSourceConnectionOptions): Promise<void>;
    deleteIndexer(indexer: string | SearchIndexer, options?: DeleteIndexerOptions): Promise<void>;
    deleteSkillset(skillset: string | SearchIndexerSkillset, options?: DeleteSkillsetOptions): Promise<void>;
    readonly endpoint: string;
    getDataSourceConnection(dataSourceConnectionName: string, options?: GetDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    getIndexer(indexerName: string, options?: GetIndexerOptions): Promise<SearchIndexer>;
    getIndexerStatus(indexerName: string, options?: GetIndexerStatusOptions): Promise<SearchIndexerStatus>;
    getSkillset(skillsetName: string, options?: GetSkillSetOptions): Promise<SearchIndexerSkillset>;
    listDataSourceConnections(options?: ListDataSourceConnectionsOptions): Promise<Array<SearchIndexerDataSourceConnection>>;
    listDataSourceConnectionsNames(options?: ListDataSourceConnectionsOptions): Promise<Array<string>>;
    listIndexers(options?: ListIndexersOptions): Promise<Array<SearchIndexer>>;
    listIndexersNames(options?: ListIndexersOptions): Promise<Array<string>>;
    listSkillsets(options?: ListSkillsetsOptions): Promise<Array<SearchIndexerSkillset>>;
    listSkillsetsNames(options?: ListSkillsetsOptions): Promise<Array<string>>;
    resetIndexer(indexerName: string, options?: ResetIndexerOptions): Promise<void>;
    runIndexer(indexerName: string, options?: RunIndexerOptions): Promise<void>;
}

// @public
export interface SearchIndexerClientOptions extends PipelineOptions {
    apiVersion?: string;
}

// @public
export interface SearchIndexerDataContainer {
    name: string;
    query?: string;
}

// @public
export type SearchIndexerDataIdentity = SearchIndexerDataNoneIdentity | SearchIndexerDataUserAssignedIdentity;

// @public
export type SearchIndexerDataNoneIdentity = BaseSearchIndexerDataIdentity & {
    odatatype: "#Microsoft.Azure.Search.SearchIndexerDataNoneIdentity";
};

// @public
export interface SearchIndexerDataSourceConnection {
    connectionString?: string;
    container: SearchIndexerDataContainer;
    dataChangeDetectionPolicy?: DataChangeDetectionPolicy;
    dataDeletionDetectionPolicy?: DataDeletionDetectionPolicy;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    identity?: SearchIndexerDataIdentity;
    name: string;
    type: SearchIndexerDataSourceType;
}

// @public
export type SearchIndexerDataSourceType = string;

// @public
export type SearchIndexerDataUserAssignedIdentity = BaseSearchIndexerDataIdentity & {
    odatatype: "#Microsoft.Azure.Search.SearchIndexerDataUserAssignedIdentity";
    userAssignedIdentity: string;
};

// @public
export interface SearchIndexerError {
    readonly details?: string;
    readonly documentationLink?: string;
    readonly errorMessage: string;
    readonly key?: string;
    readonly name?: string;
    readonly statusCode: number;
}

// @public
export interface SearchIndexerKnowledgeStore {
    projections: SearchIndexerKnowledgeStoreProjection[];
    storageConnectionString: string;
}

// @public
export type SearchIndexerKnowledgeStoreBlobProjectionSelector = SearchIndexerKnowledgeStoreProjectionSelector & {
    storageContainer: string;
};

// @public
export type SearchIndexerKnowledgeStoreFileProjectionSelector = SearchIndexerKnowledgeStoreBlobProjectionSelector & {};

// @public
export type SearchIndexerKnowledgeStoreObjectProjectionSelector = SearchIndexerKnowledgeStoreBlobProjectionSelector & {};

// @public
export interface SearchIndexerKnowledgeStoreProjection {
    files?: SearchIndexerKnowledgeStoreFileProjectionSelector[];
    objects?: SearchIndexerKnowledgeStoreObjectProjectionSelector[];
    tables?: SearchIndexerKnowledgeStoreTableProjectionSelector[];
}

// @public
export interface SearchIndexerKnowledgeStoreProjectionSelector {
    generatedKeyName?: string;
    inputs?: InputFieldMappingEntry[];
    referenceKeyName?: string;
    source?: string;
    sourceContext?: string;
}

// @public
export type SearchIndexerKnowledgeStoreTableProjectionSelector = SearchIndexerKnowledgeStoreProjectionSelector & {
    tableName: string;
};

// @public (undocumented)
export interface SearchIndexerLimits {
    readonly maxDocumentContentCharactersToExtract?: number;
    readonly maxDocumentExtractionSize?: number;
    readonly maxRunTime?: string;
}

// @public
export type SearchIndexerSkill = ConditionalSkill | KeyPhraseExtractionSkill | OcrSkill | ImageAnalysisSkill | LanguageDetectionSkill | ShaperSkill | MergeSkill | EntityRecognitionSkill | SentimentSkill | SplitSkill | PIIDetectionSkill | EntityRecognitionSkillV3 | EntityLinkingSkill | SentimentSkillV3 | CustomEntityLookupSkill | TextTranslationSkill | DocumentExtractionSkill | WebApiSkill;

// @public
export interface SearchIndexerSkillset {
    cognitiveServicesAccount?: CognitiveServicesAccount;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    knowledgeStore?: SearchIndexerKnowledgeStore;
    name: string;
    skills: SearchIndexerSkill[];
}

// @public
export interface SearchIndexerStatus {
    readonly executionHistory: IndexerExecutionResult[];
    readonly lastResult?: IndexerExecutionResult;
    readonly limits: SearchIndexerLimits;
    readonly status: IndexerStatus;
}

// @public
export interface SearchIndexerWarning {
    readonly details?: string;
    readonly documentationLink?: string;
    readonly key?: string;
    readonly message: string;
    readonly name?: string;
}

// @public
export class SearchIndexingBufferedSender<T> {
    constructor(client: IndexDocumentsClient<T>, documentKeyRetriever: (document: T) => string, options?: SearchIndexingBufferedSenderOptions);
    deleteDocuments(documents: T[], options?: SearchIndexingBufferedSenderDeleteDocumentsOptions): Promise<void>;
    dispose(): Promise<void>;
    flush(options?: SearchIndexingBufferedSenderFlushDocumentsOptions): Promise<void>;
    mergeDocuments(documents: T[], options?: SearchIndexingBufferedSenderMergeDocumentsOptions): Promise<void>;
    mergeOrUploadDocuments(documents: T[], options?: SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions): Promise<void>;
    off(event: "batchAdded", listener: (e: {
        action: string;
        documents: T[];
    }) => void): void;
    off(event: "beforeDocumentSent", listener: (e: IndexDocumentsAction<T>) => void): void;
    off(event: "batchSucceeded", listener: (e: IndexDocumentsResult) => void): void;
    off(event: "batchFailed", listener: (e: RestError) => void): void;
    on(event: "batchAdded", listener: (e: {
        action: string;
        documents: T[];
    }) => void): void;
    on(event: "beforeDocumentSent", listener: (e: IndexDocumentsAction<T>) => void): void;
    on(event: "batchSucceeded", listener: (e: IndexDocumentsResult) => void): void;
    on(event: "batchFailed", listener: (e: RestError) => void): void;
    uploadDocuments(documents: T[], options?: SearchIndexingBufferedSenderUploadDocumentsOptions): Promise<void>;
}

// @public
export type SearchIndexingBufferedSenderDeleteDocumentsOptions = OperationOptions;

// @public
export type SearchIndexingBufferedSenderFlushDocumentsOptions = OperationOptions;

// @public
export type SearchIndexingBufferedSenderMergeDocumentsOptions = OperationOptions;

// @public
export type SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions = OperationOptions;

// @public
export interface SearchIndexingBufferedSenderOptions {
    autoFlush?: boolean;
    flushWindowInMs?: number;
    initialBatchActionCount?: number;
    maxRetriesPerAction?: number;
    maxThrottlingDelayInMs?: number;
    throttlingDelayInMs?: number;
}

// @public
export type SearchIndexingBufferedSenderUploadDocumentsOptions = OperationOptions;

// @public
export interface SearchIndexStatistics {
    readonly documentCount: number;
    readonly storageSize: number;
}

// @public
export type SearchIterator<Fields> = PagedAsyncIterableIterator<SearchResult<Fields>, SearchDocumentsPageResult<Fields>, ListSearchResultsPageSettings>;

// @public
export type SearchMode = "any" | "all";

// @public
export type SearchOptions<Fields> = OperationOptions & SearchRequestOptions<Fields>;

// @public
export interface SearchRequest {
    answers?: Answers;
    captions?: Captions;
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string;
    queryLanguage?: QueryLanguage;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    scoringStatistics?: ScoringStatistics;
    searchFields?: string;
    searchMode?: SearchMode;
    searchText?: string;
    select?: string;
    semanticFields?: string;
    sessionId?: string;
    skip?: number;
    speller?: Speller;
    top?: number;
}

// @public
export interface SearchRequestOptions<Fields> {
    answers?: Answers;
    captions?: Captions;
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string[];
    queryLanguage?: QueryLanguage;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    scoringStatistics?: ScoringStatistics;
    searchFields?: Fields[];
    searchMode?: SearchMode;
    select?: Fields[];
    semanticFields?: string[];
    sessionId?: string;
    skip?: number;
    speller?: Speller;
    top?: number;
}

// @public
export interface SearchResourceEncryptionKey {
    applicationId?: string;
    applicationSecret?: string;
    identity?: SearchIndexerDataIdentity;
    keyName: string;
    keyVersion: string;
    vaultUrl: string;
}

// @public
export type SearchResult<T> = {
    readonly score: number;
    readonly rerankerScore?: number;
    readonly highlights?: {
        [k in keyof T]?: string[];
    };
    readonly captions?: CaptionResult[];
    document: T;
};

// @public
export interface SearchServiceStatistics {
    counters: ServiceCounters;
    limits: ServiceLimits;
}

// @public
export interface SearchSuggester {
    name: string;
    searchMode: "analyzingInfixMatching";
    sourceFields: string[];
}

// @public
export type SentimentSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.SentimentSkill";
    defaultLanguageCode?: SentimentSkillLanguage;
};

// @public
export type SentimentSkillLanguage = string;

// @public
export type SentimentSkillV3 = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.V3.SentimentSkill";
    defaultLanguageCode?: string;
    includeOpinionMining?: boolean;
    modelVersion?: string;
};

// @public
export interface ServiceCounters {
    dataSourceCounter: ResourceCounter;
    documentCounter: ResourceCounter;
    indexCounter: ResourceCounter;
    indexerCounter: ResourceCounter;
    skillsetCounter?: ResourceCounter;
    storageSizeCounter: ResourceCounter;
    synonymMapCounter: ResourceCounter;
}

// @public
export interface ServiceLimits {
    maxComplexCollectionFieldsPerIndex?: number;
    maxComplexObjectsInCollectionsPerDocument?: number;
    maxFieldNestingDepthPerIndex?: number;
    maxFieldsPerIndex?: number;
}

// @public
export type ShaperSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Util.ShaperSkill";
};

// @public
export type ShingleTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.ShingleTokenFilter";
    maxShingleSize?: number;
    minShingleSize?: number;
    outputUnigrams?: boolean;
    outputUnigramsIfNoShingles?: boolean;
    tokenSeparator?: string;
    filterToken?: string;
};

// @public
export interface Similarity {
    odatatype: "#Microsoft.Azure.Search.ClassicSimilarity" | "#Microsoft.Azure.Search.BM25Similarity";
}

// @public
export type SimilarityAlgorithm = ClassicSimilarity | BM25Similarity;

// @public
export interface SimpleField {
    analyzerName?: LexicalAnalyzerName;
    facetable?: boolean;
    filterable?: boolean;
    hidden?: boolean;
    indexAnalyzerName?: LexicalAnalyzerName;
    key?: boolean;
    name: string;
    normalizerName?: LexicalNormalizerName;
    searchable?: boolean;
    searchAnalyzerName?: LexicalAnalyzerName;
    sortable?: boolean;
    synonymMapNames?: string[];
    type: SearchFieldDataType;
}

// @public
export type SnowballTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.SnowballTokenFilter";
    language: SnowballTokenFilterLanguage;
};

// @public
export type SnowballTokenFilterLanguage = "armenian" | "basque" | "catalan" | "danish" | "dutch" | "english" | "finnish" | "french" | "german" | "german2" | "hungarian" | "italian" | "kp" | "lovins" | "norwegian" | "porter" | "portuguese" | "romanian" | "russian" | "spanish" | "swedish" | "turkish";

// @public
export type SoftDeleteColumnDeletionDetectionPolicy = BaseDataDeletionDetectionPolicy & {
    odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
    softDeleteColumnName?: string;
    softDeleteMarkerValue?: string;
};

// @public
export type Speller = string;

// @public
export type SplitSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.SplitSkill";
    defaultLanguageCode?: SplitSkillLanguage;
    textSplitMode?: TextSplitMode;
    maxPageLength?: number;
};

// @public
export type SplitSkillLanguage = string;

// @public
export type SqlIntegratedChangeTrackingPolicy = BaseDataChangeDetectionPolicy & {
    odatatype: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
};

// @public
export type StemmerOverrideTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter";
    rules: string[];
};

// @public
export type StemmerTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.StemmerTokenFilter";
    language: StemmerTokenFilterLanguage;
};

// @public
export type StemmerTokenFilterLanguage = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "dutchKp" | "english" | "lightEnglish" | "minimalEnglish" | "possessiveEnglish" | "porter2" | "lovins" | "finnish" | "lightFinnish" | "french" | "lightFrench" | "minimalFrench" | "galician" | "minimalGalician" | "german" | "german2" | "lightGerman" | "minimalGerman" | "greek" | "hindi" | "hungarian" | "lightHungarian" | "indonesian" | "irish" | "italian" | "lightItalian" | "sorani" | "latvian" | "norwegian" | "lightNorwegian" | "minimalNorwegian" | "lightNynorsk" | "minimalNynorsk" | "portuguese" | "lightPortuguese" | "minimalPortuguese" | "portugueseRslp" | "romanian" | "russian" | "lightRussian" | "spanish" | "lightSpanish" | "swedish" | "lightSwedish" | "turkish";

// @public
export type StopAnalyzer = BaseLexicalAnalyzer & {
    odatatype: "#Microsoft.Azure.Search.StopAnalyzer";
    stopwords?: string[];
};

// @public
export type StopwordsList = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "english" | "finnish" | "french" | "galician" | "german" | "greek" | "hindi" | "hungarian" | "indonesian" | "irish" | "italian" | "latvian" | "norwegian" | "persian" | "portuguese" | "romanian" | "russian" | "sorani" | "spanish" | "swedish" | "thai" | "turkish";

// @public
export type StopwordsTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.StopwordsTokenFilter";
    stopwords?: string[];
    stopwordsList?: StopwordsList;
    ignoreCase?: boolean;
    removeTrailingStopWords?: boolean;
};

// @public
export interface SuggestDocumentsResult<T> {
    readonly coverage?: number;
    readonly results: SuggestResult<T>[];
}

// @public
export type SuggestOptions<Fields> = OperationOptions & SuggestRequest<Fields>;

// @public
export interface SuggestRequest<Fields> {
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    orderBy?: string[];
    searchFields?: Fields[];
    select?: Fields[];
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export type SuggestResult<T> = {
    readonly text: string;
    document: T;
};

// @public
export interface SynonymMap {
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    name: string;
    synonyms: string[];
}

// @public
export type SynonymTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.SynonymTokenFilter";
    synonyms: string[];
    ignoreCase?: boolean;
    expand?: boolean;
};

// @public
export type TagScoringFunction = BaseScoringFunction & {
    type: "tag";
    parameters: TagScoringParameters;
};

// @public
export interface TagScoringParameters {
    tagsParameter: string;
}

// @public
export type TextSplitMode = string;

// @public
export type TextTranslationSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Text.TranslationSkill";
    defaultToLanguageCode: TextTranslationSkillLanguage;
    defaultFromLanguageCode?: TextTranslationSkillLanguage;
    suggestedFrom?: TextTranslationSkillLanguage;
};

// @public
export type TextTranslationSkillLanguage = string;

// @public
export interface TextWeights {
    weights: {
        [propertyName: string]: number;
    };
}

// @public
export type TokenCharacterKind = "letter" | "digit" | "whitespace" | "punctuation" | "symbol";

// @public
export type TokenFilter = AsciiFoldingTokenFilter | CjkBigramTokenFilter | CommonGramTokenFilter | DictionaryDecompounderTokenFilter | EdgeNGramTokenFilter | ElisionTokenFilter | KeepTokenFilter | KeywordMarkerTokenFilter | LengthTokenFilter | LimitTokenFilter | NGramTokenFilter | PatternCaptureTokenFilter | PatternReplaceTokenFilter | PhoneticTokenFilter | ShingleTokenFilter | SnowballTokenFilter | StemmerTokenFilter | StemmerOverrideTokenFilter | StopwordsTokenFilter | SynonymTokenFilter | TruncateTokenFilter | UniqueTokenFilter | WordDelimiterTokenFilter;

// @public
export type TokenFilterName = string;

// @public
export type TruncateTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.TruncateTokenFilter";
    length?: number;
};

// @public
export type UaxUrlEmailTokenizer = BaseLexicalTokenizer & {
    odatatype: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
    maxTokenLength?: number;
};

// @public
export type UniqueTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.UniqueTokenFilter";
    onlyOnSamePosition?: boolean;
};

// @public
export type UploadDocumentsOptions = IndexDocumentsOptions;

// @public
export type VisualFeature = string;

// @public
export type WebApiSkill = BaseSearchIndexerSkill & {
    odatatype: "#Microsoft.Skills.Custom.WebApiSkill";
    uri: string;
    httpHeaders?: {
        [propertyName: string]: string;
    };
    httpMethod?: string;
    timeout?: string;
    batchSize?: number;
    degreeOfParallelism?: number;
};

// @public
export type WordDelimiterTokenFilter = BaseTokenFilter & {
    odatatype: "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
    generateWordParts?: boolean;
    generateNumberParts?: boolean;
    catenateWords?: boolean;
    catenateNumbers?: boolean;
    catenateAll?: boolean;
    splitOnCaseChange?: boolean;
    preserveOriginal?: boolean;
    splitOnNumerics?: boolean;
    stemEnglishPossessive?: boolean;
    protectedWords?: string[];
};


// (No @packageDocumentation comment for this package)

```
