## API Report File for "@azure/search-documents"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AzureKeyCredential } from '@azure/core-auth';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';

// @public
export interface AnalyzedTokenInfo {
    readonly endOffset: number;
    readonly position: number;
    readonly startOffset: number;
    readonly token: string;
}

// @public
export interface AnalyzeRequest {
    analyzerName?: string;
    charFilters?: string[];
    text: string;
    tokenFilters?: string[];
    tokenizerName?: string;
}

// @public
export interface AnalyzeResult {
    tokens: AnalyzedTokenInfo[];
}

// @public
export type AnalyzeTextOptions = OperationOptions & AnalyzeRequest;

// @public
export interface AsciiFoldingTokenFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter";
    preserveOriginal?: boolean;
}

// @public
export interface AutocompleteItem {
    readonly queryPlusText: string;
    readonly text: string;
}

// @public
export type AutocompleteMode = 'oneTerm' | 'twoTerms' | 'oneTermWithContext';

// @public
export type AutocompleteOptions<Fields> = OperationOptions & AutocompleteRequest<Fields>;

// @public
export interface AutocompleteRequest<Fields> {
    autocompleteMode?: AutocompleteMode;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    searchFields?: Fields[];
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface AutocompleteResult {
    readonly coverage?: number;
    readonly results: AutocompleteItem[];
}

// @public
export interface AzureActiveDirectoryApplicationCredentials {
    applicationId: string;
    applicationSecret?: string;
}

export { AzureKeyCredential }

// @public
export interface BM25Similarity {
    b?: number;
    k1?: number;
    odatatype: "#Microsoft.Azure.Search.BM25Similarity";
}

// @public
export type CharFilter = MappingCharFilter | PatternReplaceCharFilter;

// @public
export interface CjkBigramTokenFilter {
    ignoreScripts?: CjkBigramTokenFilterScripts[];
    name: string;
    odatatype: "#Microsoft.Azure.Search.CjkBigramTokenFilter";
    outputUnigrams?: boolean;
}

// @public
export type CjkBigramTokenFilterScripts = 'han' | 'hiragana' | 'katakana' | 'hangul';

// @public
export interface ClassicSimilarity {
    odatatype: "#Microsoft.Azure.Search.ClassicSimilarity";
}

// @public
export interface ClassicTokenizer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.ClassicTokenizer";
}

// @public
export type CognitiveServicesAccount = DefaultCognitiveServicesAccount | CognitiveServicesAccountKey;

// @public
export interface CognitiveServicesAccountKey {
    description?: string;
    key: string;
    odatatype: "#Microsoft.Azure.Search.CognitiveServicesByKey";
}

// @public
export interface CommonGramTokenFilter {
    commonWords: string[];
    ignoreCase?: boolean;
    name: string;
    odatatype: "#Microsoft.Azure.Search.CommonGramTokenFilter";
    useQueryMode?: boolean;
}

// @public
export type ComplexDataType = "Edm.ComplexType" | "Collection(Edm.ComplexType)";

// @public
export interface ComplexField {
    fields: SearchField[];
    name: string;
    type: ComplexDataType;
}

// @public
export interface ConditionalSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Util.ConditionalSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface CorsOptions {
    allowedOrigins: string[];
    maxAgeInSeconds?: number;
}

// @public
export type CountDocumentsOptions = OperationOptions;

// @public
export type CreateDataSourceConnectionOptions = OperationOptions;

// @public
export type CreateIndexerOptions = OperationOptions;

// @public
export type CreateIndexOptions = OperationOptions;

// @public
export interface CreateorUpdateDataSourceConnectionOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateorUpdateIndexerOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateOrUpdateIndexOptions extends OperationOptions {
    allowIndexDowntime?: boolean;
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateOrUpdateSkillsetOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateOrUpdateSynonymMapOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export type CreateSkillsetOptions = OperationOptions;

// @public
export type CreateSynonymMapOptions = OperationOptions;

// @public
export interface CustomAnalyzer {
    charFilters?: string[];
    name: string;
    odatatype: "#Microsoft.Azure.Search.CustomAnalyzer";
    tokenFilters?: string[];
    tokenizerName: string;
}

// @public
export type DataChangeDetectionPolicy = HighWaterMarkChangeDetectionPolicy | SqlIntegratedChangeTrackingPolicy;

// @public
export type DataDeletionDetectionPolicy = SoftDeleteColumnDeletionDetectionPolicy;

// @public
export interface DefaultCognitiveServicesAccount {
    description?: string;
    odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices";
}

// @public
export interface DeleteDataSourceConnectionOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export type DeleteDocumentsOptions = IndexDocumentsOptions;

// @public
export interface DeleteIndexerOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteIndexOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteSkillsetOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteSynonymMapOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DictionaryDecompounderTokenFilter {
    maxSubwordSize?: number;
    minSubwordSize?: number;
    minWordSize?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter";
    onlyLongestMatch?: boolean;
    wordList: string[];
}

// @public
export interface DistanceScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    parameters: DistanceScoringParameters;
    type: "distance";
}

// @public
export interface DistanceScoringParameters {
    boostingDistance: number;
    referencePointParameter: string;
}

// @public
export interface EdgeNGramTokenFilter {
    maxGram?: number;
    minGram?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2" | "#Microsoft.Azure.Search.EdgeNGramTokenFilter";
    side?: EdgeNGramTokenFilterSide;
}

// @public
export type EdgeNGramTokenFilterSide = 'front' | 'back';

// @public
export interface EdgeNGramTokenizer {
    maxGram?: number;
    minGram?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export interface ElisionTokenFilter {
    articles?: string[];
    name: string;
    odatatype: "#Microsoft.Azure.Search.ElisionTokenFilter";
}

// @public
export type EntityCategory = 'location' | 'organization' | 'person' | 'quantity' | 'datetime' | 'url' | 'email';

// @public
export interface EntityRecognitionSkill {
    categories?: EntityCategory[];
    context?: string;
    defaultLanguageCode?: EntityRecognitionSkillLanguage;
    description?: string;
    includeTypelessEntities?: boolean;
    inputs: InputFieldMappingEntry[];
    minimumPrecision?: number;
    name?: string;
    odatatype: "#Microsoft.Skills.Text.EntityRecognitionSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export type EntityRecognitionSkillLanguage = 'ar' | 'cs' | 'zh-Hans' | 'zh-Hant' | 'da' | 'nl' | 'en' | 'fi' | 'fr' | 'de' | 'el' | 'hu' | 'it' | 'ja' | 'ko' | 'no' | 'pl' | 'pt-PT' | 'pt-BR' | 'ru' | 'es' | 'sv' | 'tr';

// @public
export interface FacetResult {
    [property: string]: any;
    readonly count?: number;
}

// @public
export interface FieldMapping {
    mappingFunction?: FieldMappingFunction;
    sourceFieldName: string;
    targetFieldName?: string;
}

// @public
export interface FieldMappingFunction {
    name: string;
    parameters?: {
        [propertyName: string]: any;
    };
}

// @public
export interface FreshnessScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    parameters: FreshnessScoringParameters;
    type: "freshness";
}

// @public
export interface FreshnessScoringParameters {
    boostingDuration: string;
}

// @public
export class GeographyPoint {
    constructor(latitude: number, longitude: number);
    latitude: number;
    longitude: number;
    toJSON(): object;
}

// @public
export type GetDataSourceConnectionOptions = OperationOptions;

// @public
export interface GetDocumentOptions<Fields> extends OperationOptions {
    selectedFields?: Fields[];
}

// @public
export type GetIndexerOptions = OperationOptions;

// @public
export type GetIndexerStatusOptions = OperationOptions;

// @public
export type GetIndexOptions = OperationOptions;

// @public
export type GetIndexStatisticsOptions = OperationOptions;

// @public
export type GetServiceStatisticsOptions = OperationOptions;

// @public
export type GetSkillSetOptions = OperationOptions;

// @public
export type GetSynonymMapsOptions = OperationOptions;

// @public
export interface HighWaterMarkChangeDetectionPolicy {
    highWaterMarkColumnName: string;
    odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy";
}

// @public
export interface ImageAnalysisSkill {
    context?: string;
    defaultLanguageCode?: ImageAnalysisSkillLanguage;
    description?: string;
    details?: ImageDetail[];
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
    outputs: OutputFieldMappingEntry[];
    visualFeatures?: VisualFeature[];
}

// @public
export type ImageAnalysisSkillLanguage = 'en' | 'es' | 'ja' | 'pt' | 'zh';

// @public
export type ImageDetail = 'celebrities' | 'landmarks';

// @public
export type IndexActionType = 'upload' | 'merge' | 'mergeOrUpload' | 'delete';

// @public
export type IndexDocumentsAction<T> = {
    __actionType: IndexActionType;
} & Partial<T>;

// @public
export class IndexDocumentsBatch<T> {
    constructor(actions?: IndexDocumentsAction<T>[]);
    readonly actions: IndexDocumentsAction<T>[];
    delete(keyName: keyof T, keyValues: string[]): void;
    delete(documents: T[]): void;
    merge(documents: T[]): void;
    mergeOrUpload(documents: T[]): void;
    upload(documents: T[]): void;
}

// @public
export interface IndexDocumentsOptions extends OperationOptions {
    throwOnAnyFailure?: boolean;
}

// @public
export interface IndexDocumentsResult {
    readonly results: IndexingResult[];
}

// @public
export interface IndexerExecutionResult {
    readonly endTime?: Date;
    readonly errorMessage?: string;
    readonly errors: SearchIndexerError[];
    readonly failedItemCount: number;
    readonly finalTrackingState?: string;
    readonly initialTrackingState?: string;
    readonly itemCount: number;
    readonly startTime?: Date;
    readonly status: IndexerExecutionStatus;
    readonly warnings: SearchIndexerWarning[];
}

// @public
export type IndexerExecutionStatus = 'transientFailure' | 'success' | 'inProgress' | 'reset';

// @public
export type IndexerStatus = 'unknown' | 'error' | 'running';

// @public
export interface IndexingParameters {
    batchSize?: number;
    configuration?: {
        [propertyName: string]: any;
    };
    maxFailedItems?: number;
    maxFailedItemsPerBatch?: number;
}

// @public
export interface IndexingResult {
    readonly errorMessage?: string;
    readonly key: string;
    readonly statusCode: number;
    readonly succeeded: boolean;
}

// @public
export interface IndexingSchedule {
    interval: string;
    startTime?: Date;
}

// @public
export type IndexIterator = PagedAsyncIterableIterator<SearchIndex, SearchIndex[], {}>;

// @public
export type IndexNameIterator = PagedAsyncIterableIterator<string, string[], {}>;

// @public
export interface InputFieldMappingEntry {
    inputs?: InputFieldMappingEntry[];
    name: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface KeepTokenFilter {
    keepWords: string[];
    lowerCaseKeepWords?: boolean;
    name: string;
    odatatype: "#Microsoft.Azure.Search.KeepTokenFilter";
}

// @public
export interface KeyPhraseExtractionSkill {
    context?: string;
    defaultLanguageCode?: KeyPhraseExtractionSkillLanguage;
    description?: string;
    inputs: InputFieldMappingEntry[];
    maxKeyPhraseCount?: number;
    name?: string;
    odatatype: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export type KeyPhraseExtractionSkillLanguage = 'da' | 'nl' | 'en' | 'fi' | 'fr' | 'de' | 'it' | 'ja' | 'ko' | 'no' | 'pl' | 'pt-PT' | 'pt-BR' | 'ru' | 'es' | 'sv';

// @public
export interface KeywordMarkerTokenFilter {
    ignoreCase?: boolean;
    keywords: string[];
    name: string;
    odatatype: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter";
}

// @public
export interface KeywordTokenizer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.KeywordTokenizerV2" | "#Microsoft.Azure.Search.KeywordTokenizer";
}

// @public
export enum KnownAnalyzerNames {
    ArLucene = "ar.lucene",
    ArMicrosoft = "ar.microsoft",
    BgLucene = "bg.lucene",
    BgMicrosoft = "bg.microsoft",
    BnMicrosoft = "bn.microsoft",
    CaLucene = "ca.lucene",
    CaMicrosoft = "ca.microsoft",
    CsLucene = "cs.lucene",
    CsMicrosoft = "cs.microsoft",
    DaLucene = "da.lucene",
    DaMicrosoft = "da.microsoft",
    DeLucene = "de.lucene",
    DeMicrosoft = "de.microsoft",
    ElLucene = "el.lucene",
    ElMicrosoft = "el.microsoft",
    EnLucene = "en.lucene",
    EnMicrosoft = "en.microsoft",
    EsLucene = "es.lucene",
    EsMicrosoft = "es.microsoft",
    EtMicrosoft = "et.microsoft",
    EuLucene = "eu.lucene",
    FaLucene = "fa.lucene",
    FiLucene = "fi.lucene",
    FiMicrosoft = "fi.microsoft",
    FrLucene = "fr.lucene",
    FrMicrosoft = "fr.microsoft",
    GaLucene = "ga.lucene",
    GlLucene = "gl.lucene",
    GuMicrosoft = "gu.microsoft",
    HeMicrosoft = "he.microsoft",
    HiLucene = "hi.lucene",
    HiMicrosoft = "hi.microsoft",
    HrMicrosoft = "hr.microsoft",
    HuLucene = "hu.lucene",
    HuMicrosoft = "hu.microsoft",
    HyLucene = "hy.lucene",
    IdLucene = "id.lucene",
    IdMicrosoft = "id.microsoft",
    IsMicrosoft = "is.microsoft",
    ItLucene = "it.lucene",
    ItMicrosoft = "it.microsoft",
    JaLucene = "ja.lucene",
    JaMicrosoft = "ja.microsoft",
    Keyword = "keyword",
    KnMicrosoft = "kn.microsoft",
    KoLucene = "ko.lucene",
    KoMicrosoft = "ko.microsoft",
    LtMicrosoft = "lt.microsoft",
    LvLucene = "lv.lucene",
    LvMicrosoft = "lv.microsoft",
    MlMicrosoft = "ml.microsoft",
    MrMicrosoft = "mr.microsoft",
    MsMicrosoft = "ms.microsoft",
    NbMicrosoft = "nb.microsoft",
    NlLucene = "nl.lucene",
    NlMicrosoft = "nl.microsoft",
    NoLucene = "no.lucene",
    PaMicrosoft = "pa.microsoft",
    Pattern = "pattern",
    PlLucene = "pl.lucene",
    PlMicrosoft = "pl.microsoft",
    PtBRLucene = "pt-BR.lucene",
    PtBRMicrosoft = "pt-BR.microsoft",
    PtPTLucene = "pt-PT.lucene",
    PtPTMicrosoft = "pt-PT.microsoft",
    RoLucene = "ro.lucene",
    RoMicrosoft = "ro.microsoft",
    RuLucene = "ru.lucene",
    RuMicrosoft = "ru.microsoft",
    Simple = "simple",
    SkMicrosoft = "sk.microsoft",
    SlMicrosoft = "sl.microsoft",
    SrCyrillicMicrosoft = "sr-cyrillic.microsoft",
    SrLatinMicrosoft = "sr-latin.microsoft",
    StandardAsciiFoldingLucene = "standardasciifolding.lucene",
    StandardLucene = "standard.lucene",
    Stop = "stop",
    SvLucene = "sv.lucene",
    SvMicrosoft = "sv.microsoft",
    TaMicrosoft = "ta.microsoft",
    TeMicrosoft = "te.microsoft",
    ThLucene = "th.lucene",
    ThMicrosoft = "th.microsoft",
    TrLucene = "tr.lucene",
    TrMicrosoft = "tr.microsoft",
    UkMicrosoft = "uk.microsoft",
    UrMicrosoft = "ur.microsoft",
    ViMicrosoft = "vi.microsoft",
    Whitespace = "whitespace",
    ZhHansLucene = "zh-Hans.lucene",
    ZhHansMicrosoft = "zh-Hans.microsoft",
    ZhHantLucene = "zh-Hant.lucene",
    ZhHantMicrosoft = "zh-Hant.microsoft"
}

// @public
export enum KnownCharFilterNames {
    HtmlStrip = "html_strip"
}

// @public
export enum KnownTokenFilterNames {
    Apostrophe = "apostrophe",
    ArabicNormalization = "arabic_normalization",
    AsciiFolding = "asciifolding",
    CjkBigram = "cjk_bigram",
    CjkWidth = "cjk_width",
    Classic = "classic",
    CommonGram = "common_grams",
    EdgeNGram = "edgeNGram_v2",
    Elision = "elision",
    GermanNormalization = "german_normalization",
    HindiNormalization = "hindi_normalization",
    IndicNormalization = "indic_normalization",
    KeywordRepeat = "keyword_repeat",
    KStem = "kstem",
    Length = "length",
    Limit = "limit",
    Lowercase = "lowercase",
    NGram = "nGram_v2",
    PersianNormalization = "persian_normalization",
    Phonetic = "phonetic",
    PorterStem = "porter_stem",
    Reverse = "reverse",
    ScandinavianFoldingNormalization = "scandinavian_folding",
    ScandinavianNormalization = "scandinavian_normalization",
    Shingle = "shingle",
    Snowball = "snowball",
    SoraniNormalization = "sorani_normalization",
    Stemmer = "stemmer",
    Stopwords = "stopwords",
    Trim = "trim",
    Truncate = "truncate",
    Unique = "unique",
    Uppercase = "uppercase",
    WordDelimiter = "word_delimiter"
}

// @public
export enum KnownTokenizerNames {
    Classic = "classic",
    EdgeNGram = "edgeNGram",
    Keyword = "keyword_v2",
    Letter = "letter",
    Lowercase = "lowercase",
    MicrosoftLanguageStemmingTokenizer = "microsoft_language_stemming_tokenizer",
    MicrosoftLanguageTokenizer = "microsoft_language_tokenizer",
    NGram = "nGram",
    PathHierarchy = "path_hierarchy_v2",
    Pattern = "pattern",
    Standard = "standard_v2",
    UaxUrlEmail = "uax_url_email",
    Whitespace = "whitespace"
}

// @public
export interface LanguageDetectionSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Text.LanguageDetectionSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface LengthTokenFilter {
    maxLength?: number;
    minLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.LengthTokenFilter";
}

// @public
export type LexicalAnalyzer = CustomAnalyzer | PatternAnalyzer | LuceneStandardAnalyzer | StopAnalyzer;

// @public
export type LexicalAnalyzerName = 'ar.microsoft' | 'ar.lucene' | 'hy.lucene' | 'bn.microsoft' | 'eu.lucene' | 'bg.microsoft' | 'bg.lucene' | 'ca.microsoft' | 'ca.lucene' | 'zh-Hans.microsoft' | 'zh-Hans.lucene' | 'zh-Hant.microsoft' | 'zh-Hant.lucene' | 'hr.microsoft' | 'cs.microsoft' | 'cs.lucene' | 'da.microsoft' | 'da.lucene' | 'nl.microsoft' | 'nl.lucene' | 'en.microsoft' | 'en.lucene' | 'et.microsoft' | 'fi.microsoft' | 'fi.lucene' | 'fr.microsoft' | 'fr.lucene' | 'gl.lucene' | 'de.microsoft' | 'de.lucene' | 'el.microsoft' | 'el.lucene' | 'gu.microsoft' | 'he.microsoft' | 'hi.microsoft' | 'hi.lucene' | 'hu.microsoft' | 'hu.lucene' | 'is.microsoft' | 'id.microsoft' | 'id.lucene' | 'ga.lucene' | 'it.microsoft' | 'it.lucene' | 'ja.microsoft' | 'ja.lucene' | 'kn.microsoft' | 'ko.microsoft' | 'ko.lucene' | 'lv.microsoft' | 'lv.lucene' | 'lt.microsoft' | 'ml.microsoft' | 'ms.microsoft' | 'mr.microsoft' | 'nb.microsoft' | 'no.lucene' | 'fa.lucene' | 'pl.microsoft' | 'pl.lucene' | 'pt-BR.microsoft' | 'pt-BR.lucene' | 'pt-PT.microsoft' | 'pt-PT.lucene' | 'pa.microsoft' | 'ro.microsoft' | 'ro.lucene' | 'ru.microsoft' | 'ru.lucene' | 'sr-cyrillic.microsoft' | 'sr-latin.microsoft' | 'sk.microsoft' | 'sl.microsoft' | 'es.microsoft' | 'es.lucene' | 'sv.microsoft' | 'sv.lucene' | 'ta.microsoft' | 'te.microsoft' | 'th.microsoft' | 'th.lucene' | 'tr.microsoft' | 'tr.lucene' | 'uk.microsoft' | 'ur.microsoft' | 'vi.microsoft' | 'standard.lucene' | 'standardasciifolding.lucene' | 'keyword' | 'pattern' | 'simple' | 'stop' | 'whitespace';

// @public
export type LexicalTokenizer = ClassicTokenizer | EdgeNGramTokenizer | KeywordTokenizer | MicrosoftLanguageTokenizer | MicrosoftLanguageStemmingTokenizer | NGramTokenizer | PathHierarchyTokenizer | PatternTokenizer | LuceneStandardTokenizer | UaxUrlEmailTokenizer;

// @public
export interface LimitTokenFilter {
    consumeAllTokens?: boolean;
    maxTokenCount?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.LimitTokenFilter";
}

// @public
export type ListDataSourceConnectionsOptions = OperationOptions;

// @public
export type ListIndexersOptions = OperationOptions;

// @public
export type ListIndexesOptions = OperationOptions;

// @public
export interface ListSearchResultsPageSettings {
    continuationToken?: string;
}

// @public
export type ListSkillsetsOptions = OperationOptions;

// @public
export type ListSynonymMapsOptions = OperationOptions;

// @public
export interface LuceneStandardAnalyzer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.StandardAnalyzer";
    stopwords?: string[];
}

// @public
export interface LuceneStandardTokenizer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.StandardTokenizerV2" | "#Microsoft.Azure.Search.StandardTokenizer";
}

// @public
export interface MagnitudeScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    parameters: MagnitudeScoringParameters;
    type: "magnitude";
}

// @public
export interface MagnitudeScoringParameters {
    boostingRangeEnd: number;
    boostingRangeStart: number;
    shouldBoostBeyondRangeByConstant?: boolean;
}

// @public
export interface MappingCharFilter {
    mappings: string[];
    name: string;
    odatatype: "#Microsoft.Azure.Search.MappingCharFilter";
}

// @public
export type MergeDocumentsOptions = IndexDocumentsOptions;

// @public
export type MergeOrUploadDocumentsOptions = IndexDocumentsOptions;

// @public
export interface MergeSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    insertPostTag?: string;
    insertPreTag?: string;
    name?: string;
    odatatype: "#Microsoft.Skills.Text.MergeSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface MicrosoftLanguageStemmingTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftStemmingTokenizerLanguage;
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer";
}

// @public
export interface MicrosoftLanguageTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftTokenizerLanguage;
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer";
}

// @public
export type MicrosoftStemmingTokenizerLanguage = 'arabic' | 'bangla' | 'bulgarian' | 'catalan' | 'croatian' | 'czech' | 'danish' | 'dutch' | 'english' | 'estonian' | 'finnish' | 'french' | 'german' | 'greek' | 'gujarati' | 'hebrew' | 'hindi' | 'hungarian' | 'icelandic' | 'indonesian' | 'italian' | 'kannada' | 'latvian' | 'lithuanian' | 'malay' | 'malayalam' | 'marathi' | 'norwegianBokmaal' | 'polish' | 'portuguese' | 'portugueseBrazilian' | 'punjabi' | 'romanian' | 'russian' | 'serbianCyrillic' | 'serbianLatin' | 'slovak' | 'slovenian' | 'spanish' | 'swedish' | 'tamil' | 'telugu' | 'turkish' | 'ukrainian' | 'urdu';

// @public
export type MicrosoftTokenizerLanguage = 'bangla' | 'bulgarian' | 'catalan' | 'chineseSimplified' | 'chineseTraditional' | 'croatian' | 'czech' | 'danish' | 'dutch' | 'english' | 'french' | 'german' | 'greek' | 'gujarati' | 'hindi' | 'icelandic' | 'indonesian' | 'italian' | 'japanese' | 'kannada' | 'korean' | 'malay' | 'malayalam' | 'marathi' | 'norwegianBokmaal' | 'polish' | 'portuguese' | 'portugueseBrazilian' | 'punjabi' | 'romanian' | 'russian' | 'serbianCyrillic' | 'serbianLatin' | 'slovenian' | 'spanish' | 'swedish' | 'tamil' | 'telugu' | 'thai' | 'ukrainian' | 'urdu' | 'vietnamese';

// @public
export interface NGramTokenFilter {
    maxGram?: number;
    minGram?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.NGramTokenFilterV2" | "#Microsoft.Azure.Search.NGramTokenFilter";
}

// @public
export interface NGramTokenizer {
    maxGram?: number;
    minGram?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.NGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export interface OcrSkill {
    context?: string;
    defaultLanguageCode?: OcrSkillLanguage;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Vision.OcrSkill";
    outputs: OutputFieldMappingEntry[];
    shouldDetectOrientation?: boolean;
}

// @public
export type OcrSkillLanguage = 'zh-Hans' | 'zh-Hant' | 'cs' | 'da' | 'nl' | 'en' | 'fi' | 'fr' | 'de' | 'el' | 'hu' | 'it' | 'ja' | 'ko' | 'nb' | 'pl' | 'pt' | 'ru' | 'es' | 'sv' | 'tr' | 'ar' | 'ro' | 'sr-Cyrl' | 'sr-Latn' | 'sk';

// @public
export function odata(strings: TemplateStringsArray, ...values: unknown[]): string;

// @public
export interface OutputFieldMappingEntry {
    name: string;
    targetName?: string;
}

// @public
export interface PathHierarchyTokenizer {
    delimiter?: string;
    maxTokenLength?: number;
    name: string;
    numberOfTokensToSkip?: number;
    odatatype: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2";
    replacement?: string;
    reverseTokenOrder?: boolean;
}

// @public
export interface PatternAnalyzer {
    flags?: RegexFlags[];
    lowerCaseTerms?: boolean;
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternAnalyzer";
    pattern?: string;
    stopwords?: string[];
}

// @public
export interface PatternCaptureTokenFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternCaptureTokenFilter";
    patterns: string[];
    preserveOriginal?: boolean;
}

// @public
export interface PatternReplaceCharFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternReplaceCharFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternReplaceTokenFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternReplaceTokenFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternTokenizer {
    flags?: RegexFlags[];
    group?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternTokenizer";
    pattern?: string;
}

// @public
export type PhoneticEncoder = 'metaphone' | 'doubleMetaphone' | 'soundex' | 'refinedSoundex' | 'caverphone1' | 'caverphone2' | 'cologne' | 'nysiis' | 'koelnerPhonetik' | 'haasePhonetik' | 'beiderMorse';

// @public
export interface PhoneticTokenFilter {
    encoder?: PhoneticEncoder;
    name: string;
    odatatype: "#Microsoft.Azure.Search.PhoneticTokenFilter";
    replaceOriginalTokens?: boolean;
}

// @public
export type QueryType = 'simple' | 'full';

// @public
export type RegexFlags = 'CANON_EQ' | 'CASE_INSENSITIVE' | 'COMMENTS' | 'DOTALL' | 'LITERAL' | 'MULTILINE' | 'UNICODE_CASE' | 'UNIX_LINES';

// @public
export type ResetIndexerOptions = OperationOptions;

// @public
export interface ResourceCounter {
    quota?: number;
    usage: number;
}

// @public
export type RunIndexerOptions = OperationOptions;

// @public
export type ScoringFunction = DistanceScoringFunction | FreshnessScoringFunction | MagnitudeScoringFunction | TagScoringFunction;

// @public
export type ScoringFunctionAggregation = 'sum' | 'average' | 'minimum' | 'maximum' | 'firstMatching';

// @public
export type ScoringFunctionInterpolation = 'linear' | 'constant' | 'quadratic' | 'logarithmic';

// @public
export interface ScoringProfile {
    functionAggregation?: ScoringFunctionAggregation;
    functions?: ScoringFunction[];
    name: string;
    textWeights?: TextWeights;
}

// @public
export class SearchClient<T> {
    constructor(endpoint: string, indexName: string, credential: KeyCredential, options?: SearchClientOptions);
    readonly apiVersion: string;
    autocomplete<Fields extends keyof T>(searchText: string, suggesterName: string, options?: AutocompleteOptions<Fields>): Promise<AutocompleteResult>;
    deleteDocuments(documents: T[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
    deleteDocuments(keyName: keyof T, keyValues: string[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
    readonly endpoint: string;
    getDocument<Fields extends keyof T>(key: string, options?: GetDocumentOptions<Fields>): Promise<T>;
    getDocumentsCount(options?: CountDocumentsOptions): Promise<number>;
    indexDocuments(batch: IndexDocumentsBatch<T>, options?: IndexDocumentsOptions): Promise<IndexDocumentsResult>;
    readonly indexName: string;
    mergeDocuments(documents: T[], options?: MergeDocumentsOptions): Promise<IndexDocumentsResult>;
    mergeOrUploadDocuments(documents: T[], options?: MergeOrUploadDocumentsOptions): Promise<IndexDocumentsResult>;
    search<Fields extends keyof T>(searchText?: string, options?: SearchOptions<Fields>): Promise<SearchDocumentsResult<Pick<T, Fields>>>;
    suggest<Fields extends keyof T = never>(searchText: string, suggesterName: string, options?: SuggestOptions<Fields>): Promise<SuggestDocumentsResult<Pick<T, Fields>>>;
    uploadDocuments(documents: T[], options?: UploadDocumentsOptions): Promise<IndexDocumentsResult>;
}

// @public
export type SearchClientOptions = PipelineOptions;

// @public
export interface SearchDocumentsPageResult<T> extends SearchDocumentsResultBase {
    continuationToken?: string;
    readonly results: SearchResult<T>[];
}

// @public
export interface SearchDocumentsResult<T> extends SearchDocumentsResultBase {
    readonly results: SearchIterator<T>;
}

// @public
export interface SearchDocumentsResultBase {
    readonly count?: number;
    readonly coverage?: number;
    readonly facets?: {
        [propertyName: string]: FacetResult[];
    };
}

// @public
export type SearchField = SimpleField | ComplexField;

// @public
export type SearchFieldDataType = "Edm.String" | "Edm.Int32" | "Edm.Int64" | "Edm.Double" | "Edm.Boolean" | "Edm.DateTimeOffset" | "Edm.GeographyPoint" | "Collection(Edm.String)" | "Collection(Edm.Int32)" | "Collection(Edm.Int64)" | "Collection(Edm.Double)" | "Collection(Edm.Boolean)" | "Collection(Edm.DateTimeOffset)" | "Collection(Edm.GeographyPoint)";

// @public
export interface SearchIndex {
    analyzers?: LexicalAnalyzer[];
    charFilters?: CharFilter[];
    corsOptions?: CorsOptions;
    defaultScoringProfile?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    fields: SearchField[];
    name: string;
    scoringProfiles?: ScoringProfile[];
    similarity?: SimilarityAlgorithm;
    suggesters?: SearchSuggester[];
    tokenFilters?: TokenFilter[];
    tokenizers?: LexicalTokenizer[];
}

// @public
export class SearchIndexClient {
    constructor(endpoint: string, credential: KeyCredential, options?: SearchIndexClientOptions);
    analyzeText(indexName: string, options: AnalyzeTextOptions): Promise<AnalyzeResult>;
    readonly apiVersion: string;
    createIndex(index: SearchIndex, options?: CreateIndexOptions): Promise<SearchIndex>;
    createOrUpdateIndex(index: SearchIndex, options?: CreateOrUpdateIndexOptions): Promise<SearchIndex>;
    createOrUpdateSynonymMap(synonymMap: SynonymMap, options?: CreateOrUpdateSynonymMapOptions): Promise<SynonymMap>;
    createSynonymMap(synonymMap: SynonymMap, options?: CreateSynonymMapOptions): Promise<SynonymMap>;
    deleteIndex(index: string | SearchIndex, options?: DeleteIndexOptions): Promise<void>;
    deleteSynonymMap(synonymMap: string | SynonymMap, options?: DeleteSynonymMapOptions): Promise<void>;
    readonly endpoint: string;
    getIndex(indexName: string, options?: GetIndexOptions): Promise<SearchIndex>;
    getIndexStatistics(indexName: string, options?: GetIndexStatisticsOptions): Promise<SearchIndexStatistics>;
    getSearchClient<T>(indexName: string, options?: SearchClientOptions): SearchClient<T>;
    getServiceStatistics(options?: GetServiceStatisticsOptions): Promise<SearchServiceStatistics>;
    getSynonymMap(synonymMapName: string, options?: GetSynonymMapsOptions): Promise<SynonymMap>;
    listIndexes(options?: ListIndexesOptions): IndexIterator;
    listIndexesNames(options?: ListIndexesOptions): IndexNameIterator;
    listSynonymMaps(options?: ListSynonymMapsOptions): Promise<Array<SynonymMap>>;
    listSynonymMapsNames(options?: ListSynonymMapsOptions): Promise<Array<string>>;
    }

// @public
export type SearchIndexClientOptions = PipelineOptions;

// @public
export interface SearchIndexer {
    dataSourceName: string;
    description?: string;
    etag?: string;
    fieldMappings?: FieldMapping[];
    isDisabled?: boolean;
    name: string;
    outputFieldMappings?: FieldMapping[];
    parameters?: IndexingParameters;
    schedule?: IndexingSchedule;
    skillsetName?: string;
    targetIndexName: string;
}

// @public
export class SearchIndexerClient {
    constructor(endpoint: string, credential: KeyCredential, options?: SearchIndexerClientOptions);
    readonly apiVersion: string;
    createDataSourceConnection(dataSourceConnection: SearchIndexerDataSourceConnection, options?: CreateDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    createIndexer(indexer: SearchIndexer, options?: CreateIndexerOptions): Promise<SearchIndexer>;
    createOrUpdateDataSourceConnection(dataSourceConnection: SearchIndexerDataSourceConnection, options?: CreateorUpdateDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    createOrUpdateIndexer(indexer: SearchIndexer, options?: CreateorUpdateIndexerOptions): Promise<SearchIndexer>;
    createOrUpdateSkillset(skillset: SearchIndexerSkillset, options?: CreateOrUpdateSkillsetOptions): Promise<SearchIndexerSkillset>;
    createSkillset(skillset: SearchIndexerSkillset, options?: CreateSkillsetOptions): Promise<SearchIndexerSkillset>;
    deleteDataSourceConnection(dataSourceConnection: string | SearchIndexerDataSourceConnection, options?: DeleteDataSourceConnectionOptions): Promise<void>;
    deleteIndexer(indexer: string | SearchIndexer, options?: DeleteIndexerOptions): Promise<void>;
    deleteSkillset(skillset: string | SearchIndexerSkillset, options?: DeleteSkillsetOptions): Promise<void>;
    readonly endpoint: string;
    getDataSourceConnection(dataSourceConnectionName: string, options?: GetDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    getIndexer(indexerName: string, options?: GetIndexerOptions): Promise<SearchIndexer>;
    getIndexerStatus(indexerName: string, options?: GetIndexerStatusOptions): Promise<SearchIndexerStatus>;
    getSkillset(skillsetName: string, options?: GetSkillSetOptions): Promise<SearchIndexerSkillset>;
    listDataSourceConnections(options?: ListDataSourceConnectionsOptions): Promise<Array<SearchIndexerDataSourceConnection>>;
    listDataSourceConnectionsNames(options?: ListDataSourceConnectionsOptions): Promise<Array<string>>;
    listIndexers(options?: ListIndexersOptions): Promise<Array<SearchIndexer>>;
    listIndexersNames(options?: ListIndexersOptions): Promise<Array<string>>;
    listSkillsets(options?: ListSkillsetsOptions): Promise<Array<SearchIndexerSkillset>>;
    listSkillsetsNames(options?: ListSkillsetsOptions): Promise<Array<string>>;
    resetIndexer(indexerName: string, options?: ResetIndexerOptions): Promise<void>;
    runIndexer(indexerName: string, options?: RunIndexerOptions): Promise<void>;
}

// @public
export type SearchIndexerClientOptions = PipelineOptions;

// @public
export interface SearchIndexerDataContainer {
    name: string;
    query?: string;
}

// @public
export interface SearchIndexerDataSourceConnection {
    connectionString?: string;
    container: SearchIndexerDataContainer;
    dataChangeDetectionPolicy?: DataChangeDetectionPolicy;
    dataDeletionDetectionPolicy?: DataDeletionDetectionPolicy;
    description?: string;
    etag?: string;
    name: string;
    type: SearchIndexerDataSourceType;
}

// @public
export type SearchIndexerDataSourceType = 'azuresql' | 'cosmosdb' | 'azureblob' | 'azuretable' | 'mysql';

// @public
export interface SearchIndexerError {
    readonly details?: string;
    readonly documentationLink?: string;
    readonly errorMessage: string;
    readonly key?: string;
    readonly name?: string;
    readonly statusCode: number;
}

// @public
export interface SearchIndexerLimits {
    readonly maxDocumentContentCharactersToExtract?: number;
    readonly maxDocumentExtractionSize?: number;
    readonly maxRunTime?: string;
}

// @public
export type SearchIndexerSkill = ConditionalSkill | KeyPhraseExtractionSkill | OcrSkill | ImageAnalysisSkill | LanguageDetectionSkill | ShaperSkill | MergeSkill | EntityRecognitionSkill | SentimentSkill | SplitSkill | TextTranslationSkill | WebApiSkill;

// @public
export interface SearchIndexerSkillset {
    cognitiveServicesAccount?: CognitiveServicesAccount;
    description?: string;
    etag?: string;
    name: string;
    skills: SearchIndexerSkill[];
}

// @public
export interface SearchIndexerStatus {
    readonly executionHistory: IndexerExecutionResult[];
    readonly lastResult?: IndexerExecutionResult;
    readonly limits: SearchIndexerLimits;
    readonly status: IndexerStatus;
}

// @public
export interface SearchIndexerWarning {
    readonly details?: string;
    readonly documentationLink?: string;
    readonly key?: string;
    readonly message: string;
    readonly name?: string;
}

// @public
export interface SearchIndexStatistics {
    readonly documentCount: number;
    readonly storageSize: number;
}

// @public
export type SearchIterator<Fields> = PagedAsyncIterableIterator<SearchResult<Fields>, SearchDocumentsPageResult<Fields>, ListSearchResultsPageSettings>;

// @public
export type SearchMode = 'any' | 'all';

// @public
export type SearchOptions<Fields> = OperationOptions & SearchRequestOptions<Fields>;

// @public
export interface SearchRequest {
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    searchFields?: string;
    searchMode?: SearchMode;
    searchText?: string;
    select?: string;
    skip?: number;
    top?: number;
}

// @public
export interface SearchRequestOptions<Fields> {
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string[];
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    searchFields?: Fields[];
    searchMode?: SearchMode;
    select?: Fields[];
    skip?: number;
    top?: number;
}

// @public
export interface SearchResourceEncryptionKey {
    applicationId?: string;
    applicationSecret?: string;
    keyName: string;
    keyVersion: string;
    vaultUrl: string;
}

// @public
export type SearchResult<T> = {
    readonly score: number;
    readonly highlights?: {
        [propertyName: string]: string[];
    };
    document: T;
};

// @public
export interface SearchServiceStatistics {
    counters: ServiceCounters;
    limits: ServiceLimits;
}

// @public
export interface SearchSuggester {
    name: string;
    sourceFields: string[];
}

// @public
export interface SentimentSkill {
    context?: string;
    defaultLanguageCode?: SentimentSkillLanguage;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Text.SentimentSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export type SentimentSkillLanguage = 'da' | 'nl' | 'en' | 'fi' | 'fr' | 'de' | 'el' | 'it' | 'no' | 'pl' | 'pt-PT' | 'ru' | 'es' | 'sv' | 'tr';

// @public
export interface ServiceCounters {
    dataSourceCounter: ResourceCounter;
    documentCounter: ResourceCounter;
    indexCounter: ResourceCounter;
    indexerCounter: ResourceCounter;
    storageSizeCounter: ResourceCounter;
    synonymMapCounter: ResourceCounter;
}

// @public
export interface ServiceLimits {
    maxComplexCollectionFieldsPerIndex?: number;
    maxComplexObjectsInCollectionsPerDocument?: number;
    maxFieldNestingDepthPerIndex?: number;
    maxFieldsPerIndex?: number;
}

// @public
export interface ShaperSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Util.ShaperSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface ShingleTokenFilter {
    filterToken?: string;
    maxShingleSize?: number;
    minShingleSize?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.ShingleTokenFilter";
    outputUnigrams?: boolean;
    outputUnigramsIfNoShingles?: boolean;
    tokenSeparator?: string;
}

// @public
export type SimilarityAlgorithm = ClassicSimilarity | BM25Similarity;

// @public
export interface SimpleField {
    analyzerName?: LexicalAnalyzerName;
    facetable?: boolean;
    filterable?: boolean;
    hidden?: boolean;
    indexAnalyzerName?: LexicalAnalyzerName;
    key?: boolean;
    name: string;
    searchable?: boolean;
    searchAnalyzerName?: LexicalAnalyzerName;
    sortable?: boolean;
    synonymMapNames?: string[];
    type: SearchFieldDataType;
}

// @public
export interface SnowballTokenFilter {
    language: SnowballTokenFilterLanguage;
    name: string;
    odatatype: "#Microsoft.Azure.Search.SnowballTokenFilter";
}

// @public
export type SnowballTokenFilterLanguage = 'armenian' | 'basque' | 'catalan' | 'danish' | 'dutch' | 'english' | 'finnish' | 'french' | 'german' | 'german2' | 'hungarian' | 'italian' | 'kp' | 'lovins' | 'norwegian' | 'porter' | 'portuguese' | 'romanian' | 'russian' | 'spanish' | 'swedish' | 'turkish';

// @public
export interface SoftDeleteColumnDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
    softDeleteColumnName?: string;
    softDeleteMarkerValue?: string;
}

// @public
export interface SplitSkill {
    context?: string;
    defaultLanguageCode?: SplitSkillLanguage;
    description?: string;
    inputs: InputFieldMappingEntry[];
    maxPageLength?: number;
    name?: string;
    odatatype: "#Microsoft.Skills.Text.SplitSkill";
    outputs: OutputFieldMappingEntry[];
    textSplitMode?: TextSplitMode;
}

// @public
export type SplitSkillLanguage = 'da' | 'de' | 'en' | 'es' | 'fi' | 'fr' | 'it' | 'ko' | 'pt';

// @public
export interface SqlIntegratedChangeTrackingPolicy {
    odatatype: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
}

// @public
export interface StemmerOverrideTokenFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter";
    rules: string[];
}

// @public
export interface StemmerTokenFilter {
    language: StemmerTokenFilterLanguage;
    name: string;
    odatatype: "#Microsoft.Azure.Search.StemmerTokenFilter";
}

// @public
export type StemmerTokenFilterLanguage = 'arabic' | 'armenian' | 'basque' | 'brazilian' | 'bulgarian' | 'catalan' | 'czech' | 'danish' | 'dutch' | 'dutchKp' | 'english' | 'lightEnglish' | 'minimalEnglish' | 'possessiveEnglish' | 'porter2' | 'lovins' | 'finnish' | 'lightFinnish' | 'french' | 'lightFrench' | 'minimalFrench' | 'galician' | 'minimalGalician' | 'german' | 'german2' | 'lightGerman' | 'minimalGerman' | 'greek' | 'hindi' | 'hungarian' | 'lightHungarian' | 'indonesian' | 'irish' | 'italian' | 'lightItalian' | 'sorani' | 'latvian' | 'norwegian' | 'lightNorwegian' | 'minimalNorwegian' | 'lightNynorsk' | 'minimalNynorsk' | 'portuguese' | 'lightPortuguese' | 'minimalPortuguese' | 'portugueseRslp' | 'romanian' | 'russian' | 'lightRussian' | 'spanish' | 'lightSpanish' | 'swedish' | 'lightSwedish' | 'turkish';

// @public
export interface StopAnalyzer {
    name: string;
    odatatype: "#Microsoft.Azure.Search.StopAnalyzer";
    stopwords?: string[];
}

// @public
export type StopwordsList = 'arabic' | 'armenian' | 'basque' | 'brazilian' | 'bulgarian' | 'catalan' | 'czech' | 'danish' | 'dutch' | 'english' | 'finnish' | 'french' | 'galician' | 'german' | 'greek' | 'hindi' | 'hungarian' | 'indonesian' | 'irish' | 'italian' | 'latvian' | 'norwegian' | 'persian' | 'portuguese' | 'romanian' | 'russian' | 'sorani' | 'spanish' | 'swedish' | 'thai' | 'turkish';

// @public
export interface StopwordsTokenFilter {
    ignoreCase?: boolean;
    name: string;
    odatatype: "#Microsoft.Azure.Search.StopwordsTokenFilter";
    removeTrailingStopWords?: boolean;
    stopwords?: string[];
    stopwordsList?: StopwordsList;
}

// @public
export interface SuggestDocumentsResult<T> {
    readonly coverage?: number;
    readonly results: SuggestResult<T>[];
}

// @public
export type SuggestOptions<Fields> = OperationOptions & SuggestRequest<Fields>;

// @public
export interface SuggestRequest<Fields> {
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    orderBy?: string[];
    searchFields?: Fields[];
    select?: Fields[];
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export type SuggestResult<T> = {
    readonly text: string;
    document: T;
};

// @public
export interface SynonymMap {
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    name: string;
    synonyms: string[];
}

// @public
export interface SynonymTokenFilter {
    expand?: boolean;
    ignoreCase?: boolean;
    name: string;
    odatatype: "#Microsoft.Azure.Search.SynonymTokenFilter";
    synonyms: string[];
}

// @public
export interface TagScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    parameters: TagScoringParameters;
    type: "tag";
}

// @public
export interface TagScoringParameters {
    tagsParameter: string;
}

// @public
export type TextSplitMode = 'pages' | 'sentences';

// @public
export interface TextTranslationSkill {
    context?: string;
    defaultFromLanguageCode?: TextTranslationSkillLanguage;
    defaultToLanguageCode: TextTranslationSkillLanguage;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Text.TranslationSkill";
    outputs: OutputFieldMappingEntry[];
    suggestedFrom?: TextTranslationSkillLanguage;
}

// @public
export type TextTranslationSkillLanguage = 'af' | 'ar' | 'bn' | 'bs' | 'bg' | 'yue' | 'ca' | 'zh-Hans' | 'zh-Hant' | 'hr' | 'cs' | 'da' | 'nl' | 'en' | 'et' | 'fj' | 'fil' | 'fi' | 'fr' | 'de' | 'el' | 'ht' | 'he' | 'hi' | 'mww' | 'hu' | 'is' | 'id' | 'it' | 'ja' | 'sw' | 'tlh' | 'ko' | 'lv' | 'lt' | 'mg' | 'ms' | 'mt' | 'nb' | 'fa' | 'pl' | 'pt' | 'otq' | 'ro' | 'ru' | 'sm' | 'sr-Cyrl' | 'sr-Latn' | 'sk' | 'sl' | 'es' | 'sv' | 'ty' | 'ta' | 'te' | 'th' | 'to' | 'tr' | 'uk' | 'ur' | 'vi' | 'cy' | 'yua';

// @public
export interface TextWeights {
    weights: {
        [propertyName: string]: number;
    };
}

// @public
export type TokenCharacterKind = 'letter' | 'digit' | 'whitespace' | 'punctuation' | 'symbol';

// @public
export type TokenFilter = AsciiFoldingTokenFilter | CjkBigramTokenFilter | CommonGramTokenFilter | DictionaryDecompounderTokenFilter | EdgeNGramTokenFilter | ElisionTokenFilter | KeepTokenFilter | KeywordMarkerTokenFilter | LengthTokenFilter | LimitTokenFilter | NGramTokenFilter | PatternCaptureTokenFilter | PatternReplaceTokenFilter | PhoneticTokenFilter | ShingleTokenFilter | SnowballTokenFilter | StemmerTokenFilter | StemmerOverrideTokenFilter | StopwordsTokenFilter | SynonymTokenFilter | TruncateTokenFilter | UniqueTokenFilter | WordDelimiterTokenFilter;

// @public
export interface TruncateTokenFilter {
    length?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.TruncateTokenFilter";
}

// @public
export interface UaxUrlEmailTokenizer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
}

// @public
export interface UniqueTokenFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.UniqueTokenFilter";
    onlyOnSamePosition?: boolean;
}

// @public
export type UploadDocumentsOptions = IndexDocumentsOptions;

// @public
export type VisualFeature = 'adult' | 'brands' | 'categories' | 'description' | 'faces' | 'objects' | 'tags';

// @public
export interface WebApiSkill {
    batchSize?: number;
    context?: string;
    degreeOfParallelism?: number;
    description?: string;
    httpHeaders?: {
        [propertyName: string]: string;
    };
    httpMethod?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Custom.WebApiSkill";
    outputs: OutputFieldMappingEntry[];
    timeout?: string;
    uri: string;
}

// @public
export interface WordDelimiterTokenFilter {
    catenateAll?: boolean;
    catenateNumbers?: boolean;
    catenateWords?: boolean;
    generateNumberParts?: boolean;
    generateWordParts?: boolean;
    name: string;
    odatatype: "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
    preserveOriginal?: boolean;
    protectedWords?: string[];
    splitOnCaseChange?: boolean;
    splitOnNumerics?: boolean;
    stemEnglishPossessive?: boolean;
}


// (No @packageDocumentation comment for this package)

```
