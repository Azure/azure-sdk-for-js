## API Report File for "@azure/search-documents"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference lib="esnext.asynciterable" />

import { AzureKeyCredential } from '@azure/core-auth';
import { ExtendedCommonClientOptions } from '@azure/core-http-compat';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { Pipeline } from '@azure/core-rest-pipeline';
import { RestError } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public
export type AliasIterator = PagedAsyncIterableIterator<SearchIndexAlias, SearchIndexAlias[], {}>;

// @public
export interface AnalyzedTokenInfo {
    readonly endOffset: number;
    readonly position: number;
    readonly startOffset: number;
    readonly token: string;
}

// @public
export interface AnalyzeRequest {
    analyzerName?: LexicalAnalyzerName;
    charFilters?: CharFilterName[];
    normalizerName?: LexicalNormalizerName;
    text: string;
    tokenFilters?: TokenFilterName[];
    tokenizerName?: LexicalTokenizerName;
}

// @public
export interface AnalyzeResult {
    tokens: AnalyzedTokenInfo[];
}

// @public
export type AnalyzeTextOptions = OperationOptions & AnalyzeRequest;

// @public
export interface AsciiFoldingTokenFilter extends BaseTokenFilter {
    odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter";
    preserveOriginal?: boolean;
}

// @public
export interface AutocompleteItem {
    readonly queryPlusText: string;
    readonly text: string;
}

// @public
export type AutocompleteMode = "oneTerm" | "twoTerms" | "oneTermWithContext";

// @public
export type AutocompleteOptions<TModel extends object> = OperationOptions & AutocompleteRequest<TModel>;

// @public
export interface AutocompleteRequest<TModel extends object> {
    autocompleteMode?: AutocompleteMode;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    searchFields?: SearchFieldArray<TModel>;
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface AutocompleteResult {
    readonly coverage?: number;
    readonly results: AutocompleteItem[];
}

// @public
export interface AzureActiveDirectoryApplicationCredentials {
    applicationId: string;
    applicationSecret?: string;
}

export { AzureKeyCredential }

// @public
export interface AzureMachineLearningSkill extends BaseSearchIndexerSkill {
    authenticationKey?: string;
    degreeOfParallelism?: number;
    odatatype: "#Microsoft.Skills.Custom.AmlSkill";
    region?: string;
    resourceId?: string;
    scoringUri?: string;
    timeout?: string;
}

// @public
export interface AzureOpenAIEmbeddingSkill extends BaseSearchIndexerSkill {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentity;
    deploymentId?: string;
    odatatype: "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill";
    resourceUri?: string;
}

// @public
export interface AzureOpenAIParameters {
    apiKey?: string;
    authIdentity?: SearchIndexerDataIdentity;
    deploymentId?: string;
    resourceUri?: string;
}

// @public
export type AzureOpenAIVectorizer = BaseVectorSearchVectorizer & {
    kind: "azureOpenAI";
    azureOpenAIParameters?: AzureOpenAIParameters;
};

// @public
export interface BaseCharFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.MappingCharFilter" | "#Microsoft.Azure.Search.PatternReplaceCharFilter";
}

// @public
export interface BaseCognitiveServicesAccount {
    description?: string;
    odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices" | "#Microsoft.Azure.Search.CognitiveServicesByKey";
}

// @public
export interface BaseDataChangeDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy" | "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
}

// @public
export interface BaseDataDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy" | "#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy";
}

// @public
export interface BaseLexicalAnalyzer {
    name: string;
    odatatype: "#Microsoft.Azure.Search.CustomAnalyzer" | "#Microsoft.Azure.Search.PatternAnalyzer" | "#Microsoft.Azure.Search.StandardAnalyzer" | "#Microsoft.Azure.Search.StopAnalyzer";
}

// @public
export interface BaseLexicalNormalizer {
    name: string;
    odatatype: "#Microsoft.Azure.Search.CustomNormalizer";
}

// @public
export interface BaseLexicalTokenizer {
    name: string;
    odatatype: "#Microsoft.Azure.Search.ClassicTokenizer" | "#Microsoft.Azure.Search.EdgeNGramTokenizer" | "#Microsoft.Azure.Search.KeywordTokenizer" | "#Microsoft.Azure.Search.KeywordTokenizerV2" | "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer" | "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer" | "#Microsoft.Azure.Search.NGramTokenizer" | "#Microsoft.Azure.Search.PathHierarchyTokenizerV2" | "#Microsoft.Azure.Search.PatternTokenizer" | "#Microsoft.Azure.Search.StandardTokenizer" | "#Microsoft.Azure.Search.StandardTokenizerV2" | "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
}

// @public
export interface BaseScoringFunction {
    boost: number;
    fieldName: string;
    interpolation?: ScoringFunctionInterpolation;
    type: "distance" | "freshness" | "magnitude" | "tag";
}

// @public
export interface BaseSearchIndexerDataIdentity {
    odatatype: "#Microsoft.Azure.Search.DataNoneIdentity" | "#Microsoft.Azure.Search.DataUserAssignedIdentity";
}

// @public
export interface BaseSearchIndexerSkill {
    context?: string;
    description?: string;
    inputs: InputFieldMappingEntry[];
    name?: string;
    odatatype: "#Microsoft.Skills.Util.ConditionalSkill" | "#Microsoft.Skills.Text.KeyPhraseExtractionSkill" | "#Microsoft.Skills.Vision.OcrSkill" | "#Microsoft.Skills.Vision.ImageAnalysisSkill" | "#Microsoft.Skills.Text.LanguageDetectionSkill" | "#Microsoft.Skills.Util.ShaperSkill" | "#Microsoft.Skills.Text.MergeSkill" | "#Microsoft.Skills.Text.EntityRecognitionSkill" | "#Microsoft.Skills.Text.SentimentSkill" | "#Microsoft.Skills.Text.V3.SentimentSkill" | "#Microsoft.Skills.Text.V3.EntityLinkingSkill" | "#Microsoft.Skills.Text.V3.EntityRecognitionSkill" | "#Microsoft.Skills.Text.PIIDetectionSkill" | "#Microsoft.Skills.Text.SplitSkill" | "#Microsoft.Skills.Text.CustomEntityLookupSkill" | "#Microsoft.Skills.Text.TranslationSkill" | "#Microsoft.Skills.Util.DocumentExtractionSkill" | "#Microsoft.Skills.Custom.WebApiSkill" | "#Microsoft.Skills.Custom.AmlSkill" | "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill";
    outputs: OutputFieldMappingEntry[];
}

// @public
export interface BaseSearchRequestOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> {
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string[];
    queryLanguage?: QueryLanguage;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    scoringStatistics?: ScoringStatistics;
    searchFields?: SearchFieldArray<TModel>;
    searchMode?: SearchMode;
    select?: SelectArray<TFields>;
    sessionId?: string;
    skip?: number;
    speller?: Speller;
    top?: number;
    vectorSearchOptions?: VectorSearchOptions<TModel>;
}

// @public
export interface BaseTokenFilter {
    name: string;
    odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter" | "#Microsoft.Azure.Search.CjkBigramTokenFilter" | "#Microsoft.Azure.Search.CommonGramTokenFilter" | "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter" | "#Microsoft.Azure.Search.EdgeNGramTokenFilter" | "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2" | "#Microsoft.Azure.Search.ElisionTokenFilter" | "#Microsoft.Azure.Search.KeepTokenFilter" | "#Microsoft.Azure.Search.KeywordMarkerTokenFilter" | "#Microsoft.Azure.Search.LengthTokenFilter" | "#Microsoft.Azure.Search.LimitTokenFilter" | "#Microsoft.Azure.Search.NGramTokenFilter" | "#Microsoft.Azure.Search.NGramTokenFilterV2" | "#Microsoft.Azure.Search.PatternCaptureTokenFilter" | "#Microsoft.Azure.Search.PatternReplaceTokenFilter" | "#Microsoft.Azure.Search.PhoneticTokenFilter" | "#Microsoft.Azure.Search.ShingleTokenFilter" | "#Microsoft.Azure.Search.SnowballTokenFilter" | "#Microsoft.Azure.Search.StemmerTokenFilter" | "#Microsoft.Azure.Search.StemmerOverrideTokenFilter" | "#Microsoft.Azure.Search.StopwordsTokenFilter" | "#Microsoft.Azure.Search.SynonymTokenFilter" | "#Microsoft.Azure.Search.TruncateTokenFilter" | "#Microsoft.Azure.Search.UniqueTokenFilter" | "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
}

// @public
export interface BaseVectorQuery<TModel extends object> {
    exhaustive?: boolean;
    fields?: SearchFieldArray<TModel>;
    kind: VectorQueryKind;
    kNearestNeighborsCount?: number;
    oversampling?: number;
}

// @public
export interface BaseVectorSearchAlgorithmConfiguration {
    kind: VectorSearchAlgorithmKind;
    name: string;
}

// @public
export interface BaseVectorSearchCompressionConfiguration {
    defaultOversampling?: number;
    kind: "scalarQuantization";
    name: string;
    rerankWithOriginalVectors?: boolean;
}

// @public
export interface BaseVectorSearchVectorizer {
    kind: VectorSearchVectorizerKind;
    name: string;
}

// @public (undocumented)
export type BlobIndexerDataToExtract = "storageMetadata" | "allMetadata" | "contentAndMetadata";

// @public (undocumented)
export type BlobIndexerImageAction = "none" | "generateNormalizedImages" | "generateNormalizedImagePerPage";

// @public (undocumented)
export type BlobIndexerParsingMode = "default" | "text" | "delimitedText" | "json" | "jsonArray" | "jsonLines";

// @public (undocumented)
export type BlobIndexerPDFTextRotationAlgorithm = "none" | "detectAngles";

// @public
export interface BM25Similarity extends Similarity {
    b?: number;
    k1?: number;
    odatatype: "#Microsoft.Azure.Search.BM25Similarity";
}

// @public
export type CharFilter = MappingCharFilter | PatternReplaceCharFilter;

// @public
export type CharFilterName = string;

// @public
export interface CjkBigramTokenFilter extends BaseTokenFilter {
    ignoreScripts?: CjkBigramTokenFilterScripts[];
    odatatype: "#Microsoft.Azure.Search.CjkBigramTokenFilter";
    outputUnigrams?: boolean;
}

// @public
export type CjkBigramTokenFilterScripts = "han" | "hiragana" | "katakana" | "hangul";

// @public
export interface ClassicSimilarity extends Similarity {
    odatatype: "#Microsoft.Azure.Search.ClassicSimilarity";
}

// @public
export interface ClassicTokenizer extends BaseLexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.ClassicTokenizer";
}

// @public
export type CognitiveServicesAccount = DefaultCognitiveServicesAccount | CognitiveServicesAccountKey;

// @public
export interface CognitiveServicesAccountKey extends BaseCognitiveServicesAccount {
    key: string;
    odatatype: "#Microsoft.Azure.Search.CognitiveServicesByKey";
}

// @public
export interface CommonGramTokenFilter extends BaseTokenFilter {
    commonWords: string[];
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.CommonGramTokenFilter";
    useQueryMode?: boolean;
}

// @public
export type ComplexDataType = "Edm.ComplexType" | "Collection(Edm.ComplexType)";

// @public
export interface ComplexField {
    fields: SearchField[];
    name: string;
    type: ComplexDataType;
}

// @public
export interface ConditionalSkill extends BaseSearchIndexerSkill {
    odatatype: "#Microsoft.Skills.Util.ConditionalSkill";
}

// @public
export interface CorsOptions {
    allowedOrigins: string[];
    maxAgeInSeconds?: number;
}

// @public
export type CountDocumentsOptions = OperationOptions;

// @public
export type CreateAliasOptions = OperationOptions;

// @public
export type CreateDataSourceConnectionOptions = OperationOptions;

// @public
export type CreateIndexerOptions = OperationOptions;

// @public
export type CreateIndexOptions = OperationOptions;

// @public
export interface CreateOrUpdateAliasOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateorUpdateDataSourceConnectionOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
    skipIndexerResetRequirementForCache?: boolean;
}

// @public
export interface CreateorUpdateIndexerOptions extends OperationOptions {
    disableCacheReprocessingChangeDetection?: boolean;
    onlyIfUnchanged?: boolean;
    skipIndexerResetRequirementForCache?: boolean;
}

// @public
export interface CreateOrUpdateIndexOptions extends OperationOptions {
    allowIndexDowntime?: boolean;
    onlyIfUnchanged?: boolean;
}

// @public
export interface CreateOrUpdateSkillsetOptions extends OperationOptions {
    disableCacheReprocessingChangeDetection?: boolean;
    onlyIfUnchanged?: boolean;
    skipIndexerResetRequirementForCache?: boolean;
}

// @public
export interface CreateOrUpdateSynonymMapOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export type CreateSkillsetOptions = OperationOptions;

// @public
export function createSynonymMapFromFile(name: string, filePath: string): Promise<SynonymMap>;

// @public
export type CreateSynonymMapOptions = OperationOptions;

// @public
export interface CustomAnalyzer {
    charFilters?: CharFilterName[];
    name: string;
    odatatype: "#Microsoft.Azure.Search.CustomAnalyzer";
    tokenFilters?: TokenFilterName[];
    tokenizerName: LexicalTokenizerName;
}

// @public
export interface CustomEntity {
    accentSensitive?: boolean;
    aliases?: CustomEntityAlias[];
    caseSensitive?: boolean;
    defaultAccentSensitive?: boolean;
    defaultCaseSensitive?: boolean;
    defaultFuzzyEditDistance?: number;
    description?: string;
    fuzzyEditDistance?: number;
    id?: string;
    name: string;
    subtype?: string;
    type?: string;
}

// @public
export interface CustomEntityAlias {
    accentSensitive?: boolean;
    caseSensitive?: boolean;
    fuzzyEditDistance?: number;
    text: string;
}

// @public
export interface CustomEntityLookupSkill extends BaseSearchIndexerSkill {
    defaultLanguageCode?: CustomEntityLookupSkillLanguage;
    entitiesDefinitionUri?: string;
    globalDefaultAccentSensitive?: boolean;
    globalDefaultCaseSensitive?: boolean;
    globalDefaultFuzzyEditDistance?: number;
    inlineEntitiesDefinition?: CustomEntity[];
    odatatype: "#Microsoft.Skills.Text.CustomEntityLookupSkill";
}

// @public (undocumented)
export type CustomEntityLookupSkillLanguage = "da" | "de" | "en" | "es" | "fi" | "fr" | "it" | "ko" | "pt";

// @public
export interface CustomNormalizer extends BaseLexicalNormalizer {
    charFilters?: CharFilterName[];
    odatatype: "#Microsoft.Azure.Search.CustomNormalizer";
    tokenFilters?: TokenFilterName[];
}

// @public
export type CustomVectorizer = BaseVectorSearchVectorizer & {
    kind: "customWebApi";
    customVectorizerParameters?: CustomVectorizerParameters;
};

// @public
export interface CustomVectorizerParameters {
    authIdentity?: SearchIndexerDataIdentity;
    authResourceId?: string;
    httpHeaders?: Record<string, string>;
    httpMethod?: string;
    timeout?: string;
    uri?: string;
}

// @public
export type DataChangeDetectionPolicy = HighWaterMarkChangeDetectionPolicy | SqlIntegratedChangeTrackingPolicy;

// @public
export type DataDeletionDetectionPolicy = SoftDeleteColumnDeletionDetectionPolicy | NativeBlobSoftDeleteDeletionDetectionPolicy;

// @public
export const DEFAULT_BATCH_SIZE: number;

// @public
export const DEFAULT_FLUSH_WINDOW: number;

// @public
export const DEFAULT_RETRY_COUNT: number;

// @public
export interface DefaultCognitiveServicesAccount extends BaseCognitiveServicesAccount {
    odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices";
}

// @public
export interface DeleteAliasOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteDataSourceConnectionOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export type DeleteDocumentsOptions = IndexDocumentsOptions;

// @public
export interface DeleteIndexerOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteIndexOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteSkillsetOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DeleteSynonymMapOptions extends OperationOptions {
    onlyIfUnchanged?: boolean;
}

// @public
export interface DictionaryDecompounderTokenFilter extends BaseTokenFilter {
    maxSubwordSize?: number;
    minSubwordSize?: number;
    minWordSize?: number;
    odatatype: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter";
    onlyLongestMatch?: boolean;
    wordList: string[];
}

// @public
export interface DistanceScoringFunction extends BaseScoringFunction {
    parameters: DistanceScoringParameters;
    type: "distance";
}

// @public
export interface DistanceScoringParameters {
    boostingDistance: number;
    referencePointParameter: string;
}

// @public
export interface DocumentDebugInfo {
    readonly semantic?: SemanticDebugInfo;
}

// @public
export interface DocumentExtractionSkill extends BaseSearchIndexerSkill {
    configuration?: {
        [propertyName: string]: any;
    };
    dataToExtract?: string;
    odatatype: "#Microsoft.Skills.Util.DocumentExtractionSkill";
    parsingMode?: string;
}

// @public
export interface EdgeNGramTokenFilter {
    maxGram?: number;
    minGram?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2" | "#Microsoft.Azure.Search.EdgeNGramTokenFilter";
    side?: EdgeNGramTokenFilterSide;
}

// @public
export type EdgeNGramTokenFilterSide = "front" | "back";

// @public
export interface EdgeNGramTokenizer extends BaseLexicalTokenizer {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export interface ElisionTokenFilter extends BaseTokenFilter {
    articles?: string[];
    odatatype: "#Microsoft.Azure.Search.ElisionTokenFilter";
}

// @public (undocumented)
export type EntityCategory = "location" | "organization" | "person" | "quantity" | "datetime" | "url" | "email";

// @public
export interface EntityLinkingSkill extends BaseSearchIndexerSkill {
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.V3.EntityLinkingSkill";
}

// @public @deprecated
export interface EntityRecognitionSkill extends BaseSearchIndexerSkill {
    categories?: EntityCategory[];
    defaultLanguageCode?: EntityRecognitionSkillLanguage;
    includeTypelessEntities?: boolean;
    minimumPrecision?: number;
    odatatype: "#Microsoft.Skills.Text.EntityRecognitionSkill";
}

// @public (undocumented)
export type EntityRecognitionSkillLanguage = "ar" | "cs" | "zh-Hans" | "zh-Hant" | "da" | "nl" | "en" | "fi" | "fr" | "de" | "el" | "hu" | "it" | "ja" | "ko" | "no" | "pl" | "pt-PT" | "pt-BR" | "ru" | "es" | "sv" | "tr";

// @public
export interface EntityRecognitionSkillV3 extends BaseSearchIndexerSkill {
    categories?: string[];
    defaultLanguageCode?: string;
    minimumPrecision?: number;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.V3.EntityRecognitionSkill";
}

// @public (undocumented)
export type ExcludedODataTypes = Date | GeographyPoint;

// @public
export type ExhaustiveKnnAlgorithmConfiguration = BaseVectorSearchAlgorithmConfiguration & {
    kind: "exhaustiveKnn";
    parameters?: ExhaustiveKnnParameters;
};

// @public
export interface ExhaustiveKnnParameters {
    metric?: VectorSearchAlgorithmMetric;
}

// @public (undocumented)
export type ExtractDocumentKey<TModel> = {
    [K in keyof TModel as TModel[K] extends string | undefined ? K : never]: TModel[K];
};

// @public
export interface ExtractiveQueryAnswer {
    // (undocumented)
    answerType: "extractive";
    count?: number;
    threshold?: number;
}

// @public
export interface ExtractiveQueryCaption {
    // (undocumented)
    captionType: "extractive";
    // (undocumented)
    highlight?: boolean;
}

// @public
export interface FacetResult {
    [property: string]: any;
    readonly count?: number;
}

// @public
export interface FieldMapping {
    mappingFunction?: FieldMappingFunction;
    sourceFieldName: string;
    targetFieldName?: string;
}

// @public
export interface FieldMappingFunction {
    name: string;
    parameters?: {
        [propertyName: string]: any;
    };
}

// @public
export interface FreshnessScoringFunction extends BaseScoringFunction {
    parameters: FreshnessScoringParameters;
    type: "freshness";
}

// @public
export interface FreshnessScoringParameters {
    boostingDuration: string;
}

// @public
export class GeographyPoint {
    constructor(geographyPoint: {
        longitude: number;
        latitude: number;
    });
    latitude: number;
    longitude: number;
    toJSON(): Record<string, unknown>;
}

// @public
export type GetAliasOptions = OperationOptions;

// @public
export type GetDataSourceConnectionOptions = OperationOptions;

// @public
export interface GetDocumentOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> extends OperationOptions {
    selectedFields?: SelectArray<TFields>;
}

// @public
export type GetIndexerOptions = OperationOptions;

// @public
export type GetIndexerStatusOptions = OperationOptions;

// @public
export type GetIndexOptions = OperationOptions;

// @public
export type GetIndexStatisticsOptions = OperationOptions;

// @public
export type GetServiceStatisticsOptions = OperationOptions;

// @public
export type GetSkillSetOptions = OperationOptions;

// @public
export type GetSynonymMapsOptions = OperationOptions;

// @public
export interface HighWaterMarkChangeDetectionPolicy extends BaseDataChangeDetectionPolicy {
    highWaterMarkColumnName: string;
    odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy";
}

// @public
export type HnswAlgorithmConfiguration = BaseVectorSearchAlgorithmConfiguration & {
    kind: "hnsw";
    parameters?: HnswParameters;
};

// @public
export interface HnswParameters {
    efConstruction?: number;
    efSearch?: number;
    m?: number;
    metric?: VectorSearchAlgorithmMetric;
}

// @public
export interface ImageAnalysisSkill extends BaseSearchIndexerSkill {
    defaultLanguageCode?: ImageAnalysisSkillLanguage;
    details?: ImageDetail[];
    odatatype: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
    visualFeatures?: VisualFeature[];
}

// @public
export interface ImageAnalysisSkill extends BaseSearchIndexerSkill {
    defaultLanguageCode?: ImageAnalysisSkillLanguage;
    details?: ImageDetail[];
    odatatype: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
    visualFeatures?: VisualFeature[];
}

// @public (undocumented)
export type ImageAnalysisSkillLanguage = "ar" | "az" | "bg" | "bs" | "ca" | "cs" | "cy" | "da" | "de" | "el" | "en" | "es" | "et" | "eu" | "fi" | "fr" | "ga" | "gl" | "he" | "hi" | "hr" | "hu" | "id" | "it" | "ja" | "kk" | "ko" | "lt" | "lv" | "mk" | "ms" | "nb" | "nl" | "pl" | "prs" | "pt-BR" | "pt" | "pt-PT" | "ro" | "ru" | "sk" | "sl" | "sr-Cyrl" | "sr-Latn" | "sv" | "th" | "tr" | "uk" | "vi" | "zh" | "zh-Hans" | "zh-Hant";

// @public (undocumented)
export type ImageDetail = "celebrities" | "landmarks";

// @public
export type IndexActionType = "upload" | "merge" | "mergeOrUpload" | "delete";

// @public
export type IndexDocumentsAction<TModel> = {
    __actionType: IndexActionType;
} & Partial<TModel>;

// @public
export class IndexDocumentsBatch<TModel> {
    constructor(actions?: IndexDocumentsAction<TModel>[]);
    readonly actions: IndexDocumentsAction<TModel>[];
    delete(keyName: keyof TModel, keyValues: string[]): void;
    delete(documents: TModel[]): void;
    merge(documents: TModel[]): void;
    mergeOrUpload(documents: TModel[]): void;
    upload(documents: TModel[]): void;
}

// @public
export interface IndexDocumentsClient<TModel extends object> {
    indexDocuments(batch: IndexDocumentsBatch<TModel>, options: IndexDocumentsOptions): Promise<IndexDocumentsResult>;
}

// @public
export interface IndexDocumentsOptions extends OperationOptions {
    throwOnAnyFailure?: boolean;
}

// @public
export interface IndexDocumentsResult {
    readonly results: IndexingResult[];
}

// @public (undocumented)
export type IndexerExecutionEnvironment = "standard" | "private";

// @public
export interface IndexerExecutionResult {
    readonly currentState?: IndexerState;
    readonly endTime?: Date;
    readonly errorMessage?: string;
    readonly errors: SearchIndexerError[];
    readonly failedItemCount: number;
    readonly finalTrackingState?: string;
    readonly initialTrackingState?: string;
    readonly itemCount: number;
    readonly startTime?: Date;
    readonly status: IndexerExecutionStatus;
    readonly statusDetail?: IndexerExecutionStatusDetail;
    readonly warnings: SearchIndexerWarning[];
}

// @public
export type IndexerExecutionStatus = "transientFailure" | "success" | "inProgress" | "reset";

// @public
export type IndexerExecutionStatusDetail = string;

// @public
export interface IndexerState {
    readonly allDocumentsFinalChangeTrackingState?: string;
    readonly allDocumentsInitialChangeTrackingState?: string;
    readonly mode?: IndexingMode;
    readonly resetDatasourceDocumentIds?: string[];
    readonly resetDocumentKeys?: string[];
    readonly resetDocumentsFinalChangeTrackingState?: string;
    readonly resetDocumentsInitialChangeTrackingState?: string;
}

// @public
export type IndexerStatus = "unknown" | "error" | "running";

// @public
export type IndexingMode = string;

// @public
export interface IndexingParameters {
    batchSize?: number;
    configuration?: IndexingParametersConfiguration;
    maxFailedItems?: number;
    maxFailedItemsPerBatch?: number;
}

// @public
export interface IndexingParametersConfiguration {
    [property: string]: any;
    allowSkillsetToReadFileData?: boolean;
    dataToExtract?: BlobIndexerDataToExtract;
    delimitedTextDelimiter?: string;
    delimitedTextHeaders?: string;
    documentRoot?: string;
    excludedFileNameExtensions?: string;
    executionEnvironment?: IndexerExecutionEnvironment;
    failOnUnprocessableDocument?: boolean;
    failOnUnsupportedContentType?: boolean;
    firstLineContainsHeaders?: boolean;
    imageAction?: BlobIndexerImageAction;
    indexedFileNameExtensions?: string;
    indexStorageMetadataOnlyForOversizedDocuments?: boolean;
    parsingMode?: BlobIndexerParsingMode;
    pdfTextRotationAlgorithm?: BlobIndexerPDFTextRotationAlgorithm;
    queryTimeout?: string;
}

// @public
export interface IndexingResult {
    readonly errorMessage?: string;
    readonly key: string;
    readonly statusCode: number;
    readonly succeeded: boolean;
}

// @public
export interface IndexingSchedule {
    interval: string;
    startTime?: Date;
}

// @public
export type IndexIterator = PagedAsyncIterableIterator<SearchIndex, SearchIndex[], {}>;

// @public
export type IndexNameIterator = PagedAsyncIterableIterator<string, string[], {}>;

// @public
export type IndexProjectionMode = string;

// @public
export interface InputFieldMappingEntry {
    inputs?: InputFieldMappingEntry[];
    name: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface KeepTokenFilter extends BaseTokenFilter {
    keepWords: string[];
    lowerCaseKeepWords?: boolean;
    odatatype: "#Microsoft.Azure.Search.KeepTokenFilter";
}

// @public
export interface KeyPhraseExtractionSkill extends BaseSearchIndexerSkill {
    defaultLanguageCode?: KeyPhraseExtractionSkillLanguage;
    maxKeyPhraseCount?: number;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill";
}

// @public (undocumented)
export type KeyPhraseExtractionSkillLanguage = "da" | "nl" | "en" | "fi" | "fr" | "de" | "it" | "ja" | "ko" | "no" | "pl" | "pt-PT" | "pt-BR" | "ru" | "es" | "sv";

// @public
export interface KeywordMarkerTokenFilter extends BaseTokenFilter {
    ignoreCase?: boolean;
    keywords: string[];
    odatatype: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter";
}

// @public
export interface KeywordTokenizer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.KeywordTokenizerV2" | "#Microsoft.Azure.Search.KeywordTokenizer";
}

// @public
export enum KnownAnalyzerNames {
    ArLucene = "ar.lucene",
    ArMicrosoft = "ar.microsoft",
    BgLucene = "bg.lucene",
    BgMicrosoft = "bg.microsoft",
    BnMicrosoft = "bn.microsoft",
    CaLucene = "ca.lucene",
    CaMicrosoft = "ca.microsoft",
    CsLucene = "cs.lucene",
    CsMicrosoft = "cs.microsoft",
    DaLucene = "da.lucene",
    DaMicrosoft = "da.microsoft",
    DeLucene = "de.lucene",
    DeMicrosoft = "de.microsoft",
    ElLucene = "el.lucene",
    ElMicrosoft = "el.microsoft",
    EnLucene = "en.lucene",
    EnMicrosoft = "en.microsoft",
    EsLucene = "es.lucene",
    EsMicrosoft = "es.microsoft",
    EtMicrosoft = "et.microsoft",
    EuLucene = "eu.lucene",
    FaLucene = "fa.lucene",
    FiLucene = "fi.lucene",
    FiMicrosoft = "fi.microsoft",
    FrLucene = "fr.lucene",
    FrMicrosoft = "fr.microsoft",
    GaLucene = "ga.lucene",
    GlLucene = "gl.lucene",
    GuMicrosoft = "gu.microsoft",
    HeMicrosoft = "he.microsoft",
    HiLucene = "hi.lucene",
    HiMicrosoft = "hi.microsoft",
    HrMicrosoft = "hr.microsoft",
    HuLucene = "hu.lucene",
    HuMicrosoft = "hu.microsoft",
    HyLucene = "hy.lucene",
    IdLucene = "id.lucene",
    IdMicrosoft = "id.microsoft",
    IsMicrosoft = "is.microsoft",
    ItLucene = "it.lucene",
    ItMicrosoft = "it.microsoft",
    JaLucene = "ja.lucene",
    JaMicrosoft = "ja.microsoft",
    Keyword = "keyword",
    KnMicrosoft = "kn.microsoft",
    KoLucene = "ko.lucene",
    KoMicrosoft = "ko.microsoft",
    LtMicrosoft = "lt.microsoft",
    LvLucene = "lv.lucene",
    LvMicrosoft = "lv.microsoft",
    MlMicrosoft = "ml.microsoft",
    MrMicrosoft = "mr.microsoft",
    MsMicrosoft = "ms.microsoft",
    NbMicrosoft = "nb.microsoft",
    NlLucene = "nl.lucene",
    NlMicrosoft = "nl.microsoft",
    NoLucene = "no.lucene",
    PaMicrosoft = "pa.microsoft",
    Pattern = "pattern",
    PlLucene = "pl.lucene",
    PlMicrosoft = "pl.microsoft",
    PtBRLucene = "pt-BR.lucene",
    PtBRMicrosoft = "pt-BR.microsoft",
    PtPTLucene = "pt-PT.lucene",
    PtPTMicrosoft = "pt-PT.microsoft",
    RoLucene = "ro.lucene",
    RoMicrosoft = "ro.microsoft",
    RuLucene = "ru.lucene",
    RuMicrosoft = "ru.microsoft",
    Simple = "simple",
    SkMicrosoft = "sk.microsoft",
    SlMicrosoft = "sl.microsoft",
    SrCyrillicMicrosoft = "sr-cyrillic.microsoft",
    SrLatinMicrosoft = "sr-latin.microsoft",
    StandardAsciiFoldingLucene = "standardasciifolding.lucene",
    StandardLucene = "standard.lucene",
    Stop = "stop",
    SvLucene = "sv.lucene",
    SvMicrosoft = "sv.microsoft",
    TaMicrosoft = "ta.microsoft",
    TeMicrosoft = "te.microsoft",
    ThLucene = "th.lucene",
    ThMicrosoft = "th.microsoft",
    TrLucene = "tr.lucene",
    TrMicrosoft = "tr.microsoft",
    UkMicrosoft = "uk.microsoft",
    UrMicrosoft = "ur.microsoft",
    ViMicrosoft = "vi.microsoft",
    Whitespace = "whitespace",
    ZhHansLucene = "zh-Hans.lucene",
    ZhHansMicrosoft = "zh-Hans.microsoft",
    ZhHantLucene = "zh-Hant.lucene",
    ZhHantMicrosoft = "zh-Hant.microsoft"
}

// @public
export enum KnownBlobIndexerDataToExtract {
    AllMetadata = "allMetadata",
    ContentAndMetadata = "contentAndMetadata",
    StorageMetadata = "storageMetadata"
}

// @public
export enum KnownBlobIndexerImageAction {
    GenerateNormalizedImagePerPage = "generateNormalizedImagePerPage",
    GenerateNormalizedImages = "generateNormalizedImages",
    None = "none"
}

// @public
export enum KnownBlobIndexerParsingMode {
    Default = "default",
    DelimitedText = "delimitedText",
    Json = "json",
    JsonArray = "jsonArray",
    JsonLines = "jsonLines",
    Text = "text"
}

// @public
export enum KnownBlobIndexerPDFTextRotationAlgorithm {
    DetectAngles = "detectAngles",
    None = "none"
}

// @public
export enum KnownCharFilterName {
    HtmlStrip = "html_strip"
}

// @public
export enum KnownCharFilterNames {
    HtmlStrip = "html_strip"
}

// @public
export enum KnownCustomEntityLookupSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ko = "ko",
    Pt = "pt"
}

// @public
export enum KnownEntityCategory {
    Datetime = "datetime",
    Email = "email",
    Location = "location",
    Organization = "organization",
    Person = "person",
    Quantity = "quantity",
    Url = "url"
}

// @public
export enum KnownEntityRecognitionSkillLanguage {
    Ar = "ar",
    Cs = "cs",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    Hu = "hu",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv",
    Tr = "tr",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export enum KnownImageAnalysisSkillLanguage {
    Ar = "ar",
    Az = "az",
    Bg = "bg",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Eu = "eu",
    Fi = "fi",
    Fr = "fr",
    Ga = "ga",
    Gl = "gl",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Hu = "hu",
    Id = "id",
    It = "it",
    Ja = "ja",
    Kk = "kk",
    Ko = "ko",
    Lt = "lt",
    Lv = "lv",
    Mk = "mk",
    Ms = "ms",
    Nb = "nb",
    Nl = "nl",
    Pl = "pl",
    Prs = "prs",
    Pt = "pt",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ro = "ro",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Sv = "sv",
    Th = "th",
    Tr = "tr",
    Uk = "uk",
    Vi = "vi",
    Zh = "zh",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export enum KnownImageDetail {
    Celebrities = "celebrities",
    Landmarks = "landmarks"
}

// @public
export enum KnownIndexerExecutionEnvironment {
    Private = "private",
    Standard = "standard"
}

// @public
export enum KnownIndexerExecutionStatusDetail {
    ResetDocs = "resetDocs"
}

// @public
export enum KnownIndexingMode {
    IndexingAllDocs = "indexingAllDocs",
    IndexingResetDocs = "indexingResetDocs"
}

// @public
export enum KnownIndexProjectionMode {
    IncludeIndexingParentDocuments = "includeIndexingParentDocuments",
    SkipIndexingParentDocuments = "skipIndexingParentDocuments"
}

// @public
export enum KnownKeyPhraseExtractionSkillLanguage {
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtBR = "pt-BR",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv"
}

// @public
export enum KnownLexicalAnalyzerName {
    ArLucene = "ar.lucene",
    ArMicrosoft = "ar.microsoft",
    BgLucene = "bg.lucene",
    BgMicrosoft = "bg.microsoft",
    BnMicrosoft = "bn.microsoft",
    CaLucene = "ca.lucene",
    CaMicrosoft = "ca.microsoft",
    CsLucene = "cs.lucene",
    CsMicrosoft = "cs.microsoft",
    DaLucene = "da.lucene",
    DaMicrosoft = "da.microsoft",
    DeLucene = "de.lucene",
    DeMicrosoft = "de.microsoft",
    ElLucene = "el.lucene",
    ElMicrosoft = "el.microsoft",
    EnLucene = "en.lucene",
    EnMicrosoft = "en.microsoft",
    EsLucene = "es.lucene",
    EsMicrosoft = "es.microsoft",
    EtMicrosoft = "et.microsoft",
    EuLucene = "eu.lucene",
    FaLucene = "fa.lucene",
    FiLucene = "fi.lucene",
    FiMicrosoft = "fi.microsoft",
    FrLucene = "fr.lucene",
    FrMicrosoft = "fr.microsoft",
    GaLucene = "ga.lucene",
    GlLucene = "gl.lucene",
    GuMicrosoft = "gu.microsoft",
    HeMicrosoft = "he.microsoft",
    HiLucene = "hi.lucene",
    HiMicrosoft = "hi.microsoft",
    HrMicrosoft = "hr.microsoft",
    HuLucene = "hu.lucene",
    HuMicrosoft = "hu.microsoft",
    HyLucene = "hy.lucene",
    IdLucene = "id.lucene",
    IdMicrosoft = "id.microsoft",
    IsMicrosoft = "is.microsoft",
    ItLucene = "it.lucene",
    ItMicrosoft = "it.microsoft",
    JaLucene = "ja.lucene",
    JaMicrosoft = "ja.microsoft",
    Keyword = "keyword",
    KnMicrosoft = "kn.microsoft",
    KoLucene = "ko.lucene",
    KoMicrosoft = "ko.microsoft",
    LtMicrosoft = "lt.microsoft",
    LvLucene = "lv.lucene",
    LvMicrosoft = "lv.microsoft",
    MlMicrosoft = "ml.microsoft",
    MrMicrosoft = "mr.microsoft",
    MsMicrosoft = "ms.microsoft",
    NbMicrosoft = "nb.microsoft",
    NlLucene = "nl.lucene",
    NlMicrosoft = "nl.microsoft",
    NoLucene = "no.lucene",
    PaMicrosoft = "pa.microsoft",
    Pattern = "pattern",
    PlLucene = "pl.lucene",
    PlMicrosoft = "pl.microsoft",
    PtBrLucene = "pt-BR.lucene",
    PtBrMicrosoft = "pt-BR.microsoft",
    PtPtLucene = "pt-PT.lucene",
    PtPtMicrosoft = "pt-PT.microsoft",
    RoLucene = "ro.lucene",
    RoMicrosoft = "ro.microsoft",
    RuLucene = "ru.lucene",
    RuMicrosoft = "ru.microsoft",
    Simple = "simple",
    SkMicrosoft = "sk.microsoft",
    SlMicrosoft = "sl.microsoft",
    SrCyrillicMicrosoft = "sr-cyrillic.microsoft",
    SrLatinMicrosoft = "sr-latin.microsoft",
    StandardAsciiFoldingLucene = "standardasciifolding.lucene",
    StandardLucene = "standard.lucene",
    Stop = "stop",
    SvLucene = "sv.lucene",
    SvMicrosoft = "sv.microsoft",
    TaMicrosoft = "ta.microsoft",
    TeMicrosoft = "te.microsoft",
    ThLucene = "th.lucene",
    ThMicrosoft = "th.microsoft",
    TrLucene = "tr.lucene",
    TrMicrosoft = "tr.microsoft",
    UkMicrosoft = "uk.microsoft",
    UrMicrosoft = "ur.microsoft",
    ViMicrosoft = "vi.microsoft",
    Whitespace = "whitespace",
    ZhHansLucene = "zh-Hans.lucene",
    ZhHansMicrosoft = "zh-Hans.microsoft",
    ZhHantLucene = "zh-Hant.lucene",
    ZhHantMicrosoft = "zh-Hant.microsoft"
}

// @public
enum KnownLexicalNormalizerName {
    AsciiFolding = "asciifolding",
    Elision = "elision",
    Lowercase = "lowercase",
    Standard = "standard",
    Uppercase = "uppercase"
}
export { KnownLexicalNormalizerName }
export { KnownLexicalNormalizerName as KnownNormalizerNames }

// @public
export enum KnownLexicalTokenizerName {
    Classic = "classic",
    EdgeNGram = "edgeNGram",
    Keyword = "keyword_v2",
    Letter = "letter",
    Lowercase = "lowercase",
    MicrosoftLanguageStemmingTokenizer = "microsoft_language_stemming_tokenizer",
    MicrosoftLanguageTokenizer = "microsoft_language_tokenizer",
    NGram = "nGram",
    PathHierarchy = "path_hierarchy_v2",
    Pattern = "pattern",
    Standard = "standard_v2",
    UaxUrlEmail = "uax_url_email",
    Whitespace = "whitespace"
}

// @public
export enum KnownLineEnding {
    CarriageReturn = "carriageReturn",
    CarriageReturnLineFeed = "carriageReturnLineFeed",
    LineFeed = "lineFeed",
    Space = "space"
}

// @public
export enum KnownOcrSkillLanguage {
    Af = "af",
    Anp = "anp",
    Ar = "ar",
    Ast = "ast",
    Awa = "awa",
    Az = "az",
    Be = "be",
    BeCyrl = "be-cyrl",
    BeLatn = "be-latn",
    Bfy = "bfy",
    Bfz = "bfz",
    Bg = "bg",
    Bgc = "bgc",
    Bho = "bho",
    Bi = "bi",
    Bns = "bns",
    Br = "br",
    Bra = "bra",
    Brx = "brx",
    Bs = "bs",
    Bua = "bua",
    Ca = "ca",
    Ceb = "ceb",
    Ch = "ch",
    CnrCyrl = "cnr-cyrl",
    CnrLatn = "cnr-latn",
    Co = "co",
    Crh = "crh",
    Cs = "cs",
    Csb = "csb",
    Cy = "cy",
    Da = "da",
    De = "de",
    Dhi = "dhi",
    Doi = "doi",
    Dsb = "dsb",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Eu = "eu",
    Fa = "fa",
    Fi = "fi",
    Fil = "fil",
    Fj = "fj",
    Fo = "fo",
    Fr = "fr",
    Fur = "fur",
    Fy = "fy",
    Ga = "ga",
    Gag = "gag",
    Gd = "gd",
    Gil = "gil",
    Gl = "gl",
    Gon = "gon",
    Gv = "gv",
    Gvr = "gvr",
    Haw = "haw",
    Hi = "hi",
    Hlb = "hlb",
    Hne = "hne",
    Hni = "hni",
    Hoc = "hoc",
    Hr = "hr",
    Hsb = "hsb",
    Ht = "ht",
    Hu = "hu",
    Ia = "ia",
    Id = "id",
    Is = "is",
    It = "it",
    Iu = "iu",
    Ja = "ja",
    Jns = "Jns",
    Jv = "jv",
    Kaa = "kaa",
    KaaCyrl = "kaa-cyrl",
    Kac = "kac",
    Kea = "kea",
    Kfq = "kfq",
    Kha = "kha",
    KkCyrl = "kk-cyrl",
    KkLatn = "kk-latn",
    Kl = "kl",
    Klr = "klr",
    Kmj = "kmj",
    Ko = "ko",
    Kos = "kos",
    Kpy = "kpy",
    Krc = "krc",
    Kru = "kru",
    Ksh = "ksh",
    KuArab = "ku-arab",
    KuLatn = "ku-latn",
    Kum = "kum",
    Kw = "kw",
    Ky = "ky",
    La = "la",
    Lb = "lb",
    Lkt = "lkt",
    Lt = "lt",
    Mi = "mi",
    Mn = "mn",
    Mr = "mr",
    Ms = "ms",
    Mt = "mt",
    Mww = "mww",
    Myv = "myv",
    Nap = "nap",
    Nb = "nb",
    Ne = "ne",
    Niu = "niu",
    Nl = "nl",
    No = "no",
    Nog = "nog",
    Oc = "oc",
    Os = "os",
    Pa = "pa",
    Pl = "pl",
    Prs = "prs",
    Ps = "ps",
    Pt = "pt",
    Quc = "quc",
    Rab = "rab",
    Rm = "rm",
    Ro = "ro",
    Ru = "ru",
    Sa = "sa",
    Sat = "sat",
    Sck = "sck",
    Sco = "sco",
    Sk = "sk",
    Sl = "sl",
    Sm = "sm",
    Sma = "sma",
    Sme = "sme",
    Smj = "smj",
    Smn = "smn",
    Sms = "sms",
    So = "so",
    Sq = "sq",
    Sr = "sr",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Srx = "srx",
    Sv = "sv",
    Sw = "sw",
    Tet = "tet",
    Tg = "tg",
    Thf = "thf",
    Tk = "tk",
    To = "to",
    Tr = "tr",
    Tt = "tt",
    Tyv = "tyv",
    Ug = "ug",
    Unk = "unk",
    Ur = "ur",
    Uz = "uz",
    UzArab = "uz-arab",
    UzCyrl = "uz-cyrl",
    Vo = "vo",
    Wae = "wae",
    Xnr = "xnr",
    Xsr = "xsr",
    Yua = "yua",
    Za = "za",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant",
    Zu = "zu"
}

// @public
export enum KnownPIIDetectionSkillMaskingMode {
    None = "none",
    Replace = "replace"
}

// @public
export enum KnownQueryDebugMode {
    Disabled = "disabled",
    Semantic = "semantic"
}

// @public
export enum KnownQueryLanguage {
    ArEg = "ar-eg",
    ArJo = "ar-jo",
    ArKw = "ar-kw",
    ArMa = "ar-ma",
    ArSa = "ar-sa",
    BgBg = "bg-bg",
    BnIn = "bn-in",
    CaEs = "ca-es",
    CsCz = "cs-cz",
    DaDk = "da-dk",
    DeDe = "de-de",
    ElGr = "el-gr",
    EnAu = "en-au",
    EnCa = "en-ca",
    EnGb = "en-gb",
    EnIn = "en-in",
    EnUs = "en-us",
    EsEs = "es-es",
    EsMx = "es-mx",
    EtEe = "et-ee",
    EuEs = "eu-es",
    FaAe = "fa-ae",
    FiFi = "fi-fi",
    FrCa = "fr-ca",
    FrFr = "fr-fr",
    GaIe = "ga-ie",
    GlEs = "gl-es",
    GuIn = "gu-in",
    HeIl = "he-il",
    HiIn = "hi-in",
    HrBa = "hr-ba",
    HrHr = "hr-hr",
    HuHu = "hu-hu",
    HyAm = "hy-am",
    IdId = "id-id",
    IsIs = "is-is",
    ItIt = "it-it",
    JaJp = "ja-jp",
    KnIn = "kn-in",
    KoKr = "ko-kr",
    LtLt = "lt-lt",
    LvLv = "lv-lv",
    MlIn = "ml-in",
    MrIn = "mr-in",
    MsBn = "ms-bn",
    MsMy = "ms-my",
    NbNo = "nb-no",
    NlBe = "nl-be",
    NlNl = "nl-nl",
    None = "none",
    NoNo = "no-no",
    PaIn = "pa-in",
    PlPl = "pl-pl",
    PtBr = "pt-br",
    PtPt = "pt-pt",
    RoRo = "ro-ro",
    RuRu = "ru-ru",
    SkSk = "sk-sk",
    SlSl = "sl-sl",
    SrBa = "sr-ba",
    SrMe = "sr-me",
    SrRs = "sr-rs",
    SvSe = "sv-se",
    TaIn = "ta-in",
    TeIn = "te-in",
    ThTh = "th-th",
    TrTr = "tr-tr",
    UkUa = "uk-ua",
    UrPk = "ur-pk",
    ViVn = "vi-vn",
    ZhCn = "zh-cn",
    ZhTw = "zh-tw"
}

// @public
export enum KnownQuerySpellerType {
    Lexicon = "lexicon",
    None = "none"
}

// @public
export enum KnownRegexFlags {
    CanonEq = "CANON_EQ",
    CaseInsensitive = "CASE_INSENSITIVE",
    Comments = "COMMENTS",
    DotAll = "DOTALL",
    Literal = "LITERAL",
    Multiline = "MULTILINE",
    UnicodeCase = "UNICODE_CASE",
    UnixLines = "UNIX_LINES"
}

// @public
export enum KnownSearchAudience {
    AzureChina = "https://search.azure.cn",
    AzureGovernment = "https://search.azure.us",
    AzurePublicCloud = "https://search.azure.com"
}

// @public
export enum KnownSearchIndexerDataSourceType {
    AdlsGen2 = "adlsgen2",
    AzureBlob = "azureblob",
    AzureSql = "azuresql",
    AzureTable = "azuretable",
    CosmosDb = "cosmosdb",
    MySql = "mysql"
}

// @public
export enum KnownSemanticErrorMode {
    Fail = "fail",
    Partial = "partial"
}

// @public
export enum KnownSemanticErrorReason {
    CapacityOverloaded = "capacityOverloaded",
    MaxWaitExceeded = "maxWaitExceeded",
    Transient = "transient"
}

// @public
export enum KnownSemanticFieldState {
    Partial = "partial",
    Unused = "unused",
    Used = "used"
}

// @public
export enum KnownSemanticSearchResultsType {
    BaseResults = "baseResults",
    RerankedResults = "rerankedResults"
}

// @public
export enum KnownSentimentSkillLanguage {
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Fi = "fi",
    Fr = "fr",
    It = "it",
    Nl = "nl",
    No = "no",
    Pl = "pl",
    PtPT = "pt-PT",
    Ru = "ru",
    Sv = "sv",
    Tr = "tr"
}

// @public
export enum KnownSpeller {
    Lexicon = "lexicon",
    None = "none"
}

// @public
export enum KnownSplitSkillLanguage {
    Am = "am",
    Bs = "bs",
    Cs = "cs",
    Da = "da",
    De = "de",
    En = "en",
    Es = "es",
    Et = "et",
    Fi = "fi",
    Fr = "fr",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Ja = "ja",
    Ko = "ko",
    Lv = "lv",
    Nb = "nb",
    Nl = "nl",
    Pl = "pl",
    Pt = "pt",
    PtBr = "pt-br",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    Sr = "sr",
    Sv = "sv",
    Tr = "tr",
    Ur = "ur",
    Zh = "zh"
}

// @public
export enum KnownTextSplitMode {
    Pages = "pages",
    Sentences = "sentences"
}

// @public
export enum KnownTextTranslationSkillLanguage {
    Af = "af",
    Ar = "ar",
    Bg = "bg",
    Bn = "bn",
    Bs = "bs",
    Ca = "ca",
    Cs = "cs",
    Cy = "cy",
    Da = "da",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Et = "et",
    Fa = "fa",
    Fi = "fi",
    Fil = "fil",
    Fj = "fj",
    Fr = "fr",
    Ga = "ga",
    He = "he",
    Hi = "hi",
    Hr = "hr",
    Ht = "ht",
    Hu = "hu",
    Id = "id",
    Is = "is",
    It = "it",
    Ja = "ja",
    Kn = "kn",
    Ko = "ko",
    Lt = "lt",
    Lv = "lv",
    Mg = "mg",
    Mi = "mi",
    Ml = "ml",
    Ms = "ms",
    Mt = "mt",
    Mww = "mww",
    Nb = "nb",
    Nl = "nl",
    Otq = "otq",
    Pa = "pa",
    Pl = "pl",
    Pt = "pt",
    PtBr = "pt-br",
    PtPT = "pt-PT",
    Ro = "ro",
    Ru = "ru",
    Sk = "sk",
    Sl = "sl",
    Sm = "sm",
    SrCyrl = "sr-Cyrl",
    SrLatn = "sr-Latn",
    Sv = "sv",
    Sw = "sw",
    Ta = "ta",
    Te = "te",
    Th = "th",
    Tlh = "tlh",
    TlhLatn = "tlh-Latn",
    TlhPiqd = "tlh-Piqd",
    To = "to",
    Tr = "tr",
    Ty = "ty",
    Uk = "uk",
    Ur = "ur",
    Vi = "vi",
    Yua = "yua",
    Yue = "yue",
    ZhHans = "zh-Hans",
    ZhHant = "zh-Hant"
}

// @public
export enum KnownTokenFilterName {
    Apostrophe = "apostrophe",
    ArabicNormalization = "arabic_normalization",
    AsciiFolding = "asciifolding",
    CjkBigram = "cjk_bigram",
    CjkWidth = "cjk_width",
    Classic = "classic",
    CommonGram = "common_grams",
    EdgeNGram = "edgeNGram_v2",
    Elision = "elision",
    GermanNormalization = "german_normalization",
    HindiNormalization = "hindi_normalization",
    IndicNormalization = "indic_normalization",
    KeywordRepeat = "keyword_repeat",
    KStem = "kstem",
    Length = "length",
    Limit = "limit",
    Lowercase = "lowercase",
    NGram = "nGram_v2",
    PersianNormalization = "persian_normalization",
    Phonetic = "phonetic",
    PorterStem = "porter_stem",
    Reverse = "reverse",
    ScandinavianFoldingNormalization = "scandinavian_folding",
    ScandinavianNormalization = "scandinavian_normalization",
    Shingle = "shingle",
    Snowball = "snowball",
    SoraniNormalization = "sorani_normalization",
    Stemmer = "stemmer",
    Stopwords = "stopwords",
    Trim = "trim",
    Truncate = "truncate",
    Unique = "unique",
    Uppercase = "uppercase",
    WordDelimiter = "word_delimiter"
}

// @public
export enum KnownTokenFilterNames {
    Apostrophe = "apostrophe",
    ArabicNormalization = "arabic_normalization",
    AsciiFolding = "asciifolding",
    CjkBigram = "cjk_bigram",
    CjkWidth = "cjk_width",
    Classic = "classic",
    CommonGram = "common_grams",
    EdgeNGram = "edgeNGram_v2",
    Elision = "elision",
    GermanNormalization = "german_normalization",
    HindiNormalization = "hindi_normalization",
    IndicNormalization = "indic_normalization",
    KeywordRepeat = "keyword_repeat",
    KStem = "kstem",
    Length = "length",
    Limit = "limit",
    Lowercase = "lowercase",
    NGram = "nGram_v2",
    PersianNormalization = "persian_normalization",
    Phonetic = "phonetic",
    PorterStem = "porter_stem",
    Reverse = "reverse",
    ScandinavianFoldingNormalization = "scandinavian_folding",
    ScandinavianNormalization = "scandinavian_normalization",
    Shingle = "shingle",
    Snowball = "snowball",
    SoraniNormalization = "sorani_normalization",
    Stemmer = "stemmer",
    Stopwords = "stopwords",
    Trim = "trim",
    Truncate = "truncate",
    Unique = "unique",
    Uppercase = "uppercase",
    WordDelimiter = "word_delimiter"
}

// @public
export enum KnownTokenizerNames {
    Classic = "classic",
    EdgeNGram = "edgeNGram",
    Keyword = "keyword_v2",
    Letter = "letter",
    Lowercase = "lowercase",
    MicrosoftLanguageStemmingTokenizer = "microsoft_language_stemming_tokenizer",
    MicrosoftLanguageTokenizer = "microsoft_language_tokenizer",
    NGram = "nGram",
    PathHierarchy = "path_hierarchy_v2",
    Pattern = "pattern",
    Standard = "standard_v2",
    UaxUrlEmail = "uax_url_email",
    Whitespace = "whitespace"
}

// @public
export enum KnownVectorQueryKind {
    Text = "text",
    Vector = "vector"
}

// @public
export enum KnownVectorSearchCompressionKind {
    ScalarQuantization = "scalarQuantization"
}

// @public
export enum KnownVectorSearchCompressionTargetDataType {
    Int8 = "int8"
}

// @public
export enum KnownVectorSearchVectorizerKind {
    AzureOpenAI = "azureOpenAI",
    CustomWebApi = "customWebApi"
}

// @public
export enum KnownVisualFeature {
    Adult = "adult",
    Brands = "brands",
    Categories = "categories",
    Description = "description",
    Faces = "faces",
    Objects = "objects",
    Tags = "tags"
}

// @public
export interface LanguageDetectionSkill extends BaseSearchIndexerSkill {
    defaultCountryHint?: string;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.LanguageDetectionSkill";
}

// @public
export interface LengthTokenFilter extends BaseTokenFilter {
    maxLength?: number;
    minLength?: number;
    odatatype: "#Microsoft.Azure.Search.LengthTokenFilter";
}

// @public
export type LexicalAnalyzer = CustomAnalyzer | PatternAnalyzer | LuceneStandardAnalyzer | StopAnalyzer;

// @public
export type LexicalAnalyzerName = string;

// @public
export type LexicalNormalizer = CustomNormalizer;

// @public
export type LexicalNormalizerName = string;

// @public
export type LexicalTokenizer = ClassicTokenizer | EdgeNGramTokenizer | KeywordTokenizer | MicrosoftLanguageTokenizer | MicrosoftLanguageStemmingTokenizer | NGramTokenizer | PathHierarchyTokenizer | PatternTokenizer | LuceneStandardTokenizer | UaxUrlEmailTokenizer;

// @public
export type LexicalTokenizerName = string;

// @public
export interface LimitTokenFilter extends BaseTokenFilter {
    consumeAllTokens?: boolean;
    maxTokenCount?: number;
    odatatype: "#Microsoft.Azure.Search.LimitTokenFilter";
}

// @public
export type LineEnding = string;

// @public
export type ListAliasesOptions = OperationOptions;

// @public
export type ListDataSourceConnectionsOptions = OperationOptions;

// @public
export type ListIndexersOptions = OperationOptions;

// @public
export type ListIndexesOptions = OperationOptions;

// @public
export interface ListSearchResultsPageSettings {
    continuationToken?: string;
}

// @public
export type ListSkillsetsOptions = OperationOptions;

// @public
export type ListSynonymMapsOptions = OperationOptions;

// @public
export interface LuceneStandardAnalyzer extends BaseLexicalAnalyzer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.StandardAnalyzer";
    stopwords?: string[];
}

// @public
export interface LuceneStandardTokenizer {
    maxTokenLength?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.StandardTokenizerV2" | "#Microsoft.Azure.Search.StandardTokenizer";
}

// @public
export interface MagnitudeScoringFunction extends BaseScoringFunction {
    parameters: MagnitudeScoringParameters;
    type: "magnitude";
}

// @public
export interface MagnitudeScoringParameters {
    boostingRangeEnd: number;
    boostingRangeStart: number;
    shouldBoostBeyondRangeByConstant?: boolean;
}

// @public
export interface MappingCharFilter extends BaseCharFilter {
    mappings: string[];
    odatatype: "#Microsoft.Azure.Search.MappingCharFilter";
}

// @public
export type MergeDocumentsOptions = IndexDocumentsOptions;

// @public
export type MergeOrUploadDocumentsOptions = IndexDocumentsOptions;

// @public
export interface MergeSkill extends BaseSearchIndexerSkill {
    insertPostTag?: string;
    insertPreTag?: string;
    odatatype: "#Microsoft.Skills.Text.MergeSkill";
}

// @public
export interface MicrosoftLanguageStemmingTokenizer extends BaseLexicalTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftStemmingTokenizerLanguage;
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer";
}

// @public
export interface MicrosoftLanguageTokenizer extends BaseLexicalTokenizer {
    isSearchTokenizer?: boolean;
    language?: MicrosoftTokenizerLanguage;
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer";
}

// @public
export type MicrosoftStemmingTokenizerLanguage = "arabic" | "bangla" | "bulgarian" | "catalan" | "croatian" | "czech" | "danish" | "dutch" | "english" | "estonian" | "finnish" | "french" | "german" | "greek" | "gujarati" | "hebrew" | "hindi" | "hungarian" | "icelandic" | "indonesian" | "italian" | "kannada" | "latvian" | "lithuanian" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovak" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "turkish" | "ukrainian" | "urdu";

// @public
export type MicrosoftTokenizerLanguage = "bangla" | "bulgarian" | "catalan" | "chineseSimplified" | "chineseTraditional" | "croatian" | "czech" | "danish" | "dutch" | "english" | "french" | "german" | "greek" | "gujarati" | "hindi" | "icelandic" | "indonesian" | "italian" | "japanese" | "kannada" | "korean" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "thai" | "ukrainian" | "urdu" | "vietnamese";

// @public
export type NarrowedModel<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends never ? true : false ? TModel : (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? TModel : (<T>() => T extends TModel ? true : false) extends <T>() => T extends any ? true : false ? TModel : (<T>() => T extends TModel ? true : false) extends <T>() => T extends unknown ? true : false ? TModel : (<T>() => T extends TFields ? true : false) extends <T>() => T extends never ? true : false ? never : (<T>() => T extends TFields ? true : false) extends <T>() => T extends SelectFields<TModel> ? true : false ? TModel : SearchPick<TModel, TFields>;

// @public
export interface NativeBlobSoftDeleteDeletionDetectionPolicy extends BaseDataDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy";
}

// @public
export interface NGramTokenFilter {
    maxGram?: number;
    minGram?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.NGramTokenFilterV2" | "#Microsoft.Azure.Search.NGramTokenFilter";
}

// @public
export interface NGramTokenizer extends BaseLexicalTokenizer {
    maxGram?: number;
    minGram?: number;
    odatatype: "#Microsoft.Azure.Search.NGramTokenizer";
    tokenChars?: TokenCharacterKind[];
}

// @public
export interface OcrSkill extends BaseSearchIndexerSkill {
    defaultLanguageCode?: OcrSkillLanguage;
    odatatype: "#Microsoft.Skills.Vision.OcrSkill";
    shouldDetectOrientation?: boolean;
}

// @public (undocumented)
export type OcrSkillLanguage = "af" | "sq" | "anp" | "ar" | "ast" | "awa" | "az" | "bfy" | "eu" | "be" | "be-cyrl" | "be-latn" | "bho" | "bi" | "brx" | "bs" | "bra" | "br" | "bg" | "bns" | "bua" | "ca" | "ceb" | "rab" | "ch" | "hne" | "zh-Hans" | "zh-Hant" | "kw" | "co" | "crh" | "hr" | "cs" | "da" | "prs" | "dhi" | "doi" | "nl" | "en" | "myv" | "et" | "fo" | "fj" | "fil" | "fi" | "fr" | "fur" | "gag" | "gl" | "de" | "gil" | "gon" | "el" | "kl" | "gvr" | "ht" | "hlb" | "hni" | "bgc" | "haw" | "hi" | "mww" | "hoc" | "hu" | "is" | "smn" | "id" | "ia" | "iu" | "ga" | "it" | "ja" | "Jns" | "jv" | "kea" | "kac" | "xnr" | "krc" | "kaa-cyrl" | "kaa" | "csb" | "kk-cyrl" | "kk-latn" | "klr" | "kha" | "quc" | "ko" | "kfq" | "kpy" | "kos" | "kum" | "ku-arab" | "ku-latn" | "kru" | "ky" | "lkt" | "la" | "lt" | "dsb" | "smj" | "lb" | "bfz" | "ms" | "mt" | "kmj" | "gv" | "mi" | "mr" | "mn" | "cnr-cyrl" | "cnr-latn" | "nap" | "ne" | "niu" | "nog" | "sme" | "nb" | "no" | "oc" | "os" | "ps" | "fa" | "pl" | "pt" | "pa" | "ksh" | "ro" | "rm" | "ru" | "sck" | "sm" | "sa" | "sat" | "sco" | "gd" | "sr" | "sr-Cyrl" | "sr-Latn" | "xsr" | "srx" | "sms" | "sk" | "sl" | "so" | "sma" | "es" | "sw" | "sv" | "tg" | "tt" | "tet" | "thf" | "to" | "tr" | "tk" | "tyv" | "hsb" | "ur" | "ug" | "uz-arab" | "uz-cyrl" | "uz" | "vo" | "wae" | "cy" | "fy" | "yua" | "za" | "zu" | "unk";

// @public
export function odata(strings: TemplateStringsArray, ...values: unknown[]): string;

// @public
export interface OutputFieldMappingEntry {
    name: string;
    targetName?: string;
}

// @public
export interface PathHierarchyTokenizer extends BaseLexicalTokenizer {
    delimiter?: string;
    maxTokenLength?: number;
    numberOfTokensToSkip?: number;
    odatatype: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2";
    replacement?: string;
    reverseTokenOrder?: boolean;
}

// @public
export interface PatternAnalyzer {
    flags?: RegexFlags[];
    lowerCaseTerms?: boolean;
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternAnalyzer";
    pattern?: string;
    stopwords?: string[];
}

// @public
export interface PatternCaptureTokenFilter extends BaseTokenFilter {
    odatatype: "#Microsoft.Azure.Search.PatternCaptureTokenFilter";
    patterns: string[];
    preserveOriginal?: boolean;
}

// @public
export interface PatternReplaceCharFilter extends BaseCharFilter {
    odatatype: "#Microsoft.Azure.Search.PatternReplaceCharFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternReplaceTokenFilter extends BaseTokenFilter {
    odatatype: "#Microsoft.Azure.Search.PatternReplaceTokenFilter";
    pattern: string;
    replacement: string;
}

// @public
export interface PatternTokenizer {
    flags?: RegexFlags[];
    group?: number;
    name: string;
    odatatype: "#Microsoft.Azure.Search.PatternTokenizer";
    pattern?: string;
}

// @public
export type PhoneticEncoder = "metaphone" | "doubleMetaphone" | "soundex" | "refinedSoundex" | "caverphone1" | "caverphone2" | "cologne" | "nysiis" | "koelnerPhonetik" | "haasePhonetik" | "beiderMorse";

// @public
export interface PhoneticTokenFilter extends BaseTokenFilter {
    encoder?: PhoneticEncoder;
    odatatype: "#Microsoft.Azure.Search.PhoneticTokenFilter";
    replaceOriginalTokens?: boolean;
}

// @public
export interface PIIDetectionSkill extends BaseSearchIndexerSkill {
    categories?: string[];
    defaultLanguageCode?: string;
    domain?: string;
    maskingCharacter?: string;
    maskingMode?: PIIDetectionSkillMaskingMode;
    minimumPrecision?: number;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.PIIDetectionSkill";
}

// @public (undocumented)
export type PIIDetectionSkillMaskingMode = "none" | "replace";

// @public
export type QueryAnswer = ExtractiveQueryAnswer;

// @public
export interface QueryAnswerResult {
    [property: string]: any;
    readonly highlights?: string;
    readonly key: string;
    readonly score: number;
    readonly text: string;
}

// @public
export type QueryCaption = ExtractiveQueryCaption;

// @public
export interface QueryCaptionResult {
    [property: string]: any;
    readonly highlights?: string;
    readonly text?: string;
}

// @public
export type QueryDebugMode = string;

// @public
export type QueryLanguage = string;

// @public
export interface QueryResultDocumentRerankerInput {
    readonly content?: string;
    readonly keywords?: string;
    readonly title?: string;
}

// @public
export interface QueryResultDocumentSemanticField {
    readonly name?: string;
    readonly state?: SemanticFieldState;
}

// @public
export type QuerySpellerType = string;

// @public
export type QueryType = "simple" | "full" | "semantic";

// @public (undocumented)
export type RegexFlags = "CANON_EQ" | "CASE_INSENSITIVE" | "COMMENTS" | "DOTALL" | "LITERAL" | "MULTILINE" | "UNICODE_CASE" | "UNIX_LINES";

// @public
export interface ResetDocumentsOptions extends OperationOptions {
    datasourceDocumentIds?: string[];
    documentKeys?: string[];
    overwrite?: boolean;
}

// @public
export type ResetIndexerOptions = OperationOptions;

// @public
export interface ResetSkillsOptions extends OperationOptions {
    skillNames?: string[];
}

// @public
export interface ResourceCounter {
    quota?: number;
    usage: number;
}

// @public
export type RunIndexerOptions = OperationOptions;

// @public
export interface ScalarQuantizationCompressionConfiguration extends BaseVectorSearchCompressionConfiguration {
    kind: "scalarQuantization";
    parameters?: ScalarQuantizationParameters;
}

// @public
export interface ScalarQuantizationParameters {
    quantizedDataType?: VectorSearchCompressionTargetDataType;
}

// @public
export type ScoringFunction = DistanceScoringFunction | FreshnessScoringFunction | MagnitudeScoringFunction | TagScoringFunction;

// @public
export type ScoringFunctionAggregation = "sum" | "average" | "minimum" | "maximum" | "firstMatching";

// @public
export type ScoringFunctionInterpolation = "linear" | "constant" | "quadratic" | "logarithmic";

// @public
export interface ScoringProfile {
    functionAggregation?: ScoringFunctionAggregation;
    functions?: ScoringFunction[];
    name: string;
    textWeights?: TextWeights;
}

// @public
export type ScoringStatistics = "local" | "global";

// @public
export interface SearchAlias {
    etag?: string;
    indexes: string[];
    name: string;
}

// @public
export class SearchClient<TModel extends object> implements IndexDocumentsClient<TModel> {
    constructor(endpoint: string, indexName: string, credential: KeyCredential | TokenCredential, options?: SearchClientOptions);
    // @deprecated
    readonly apiVersion: string;
    autocomplete(searchText: string, suggesterName: string, options?: AutocompleteOptions<TModel>): Promise<AutocompleteResult>;
    deleteDocuments(documents: TModel[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
    deleteDocuments(keyName: keyof TModel, keyValues: string[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
    readonly endpoint: string;
    getDocument<TFields extends SelectFields<TModel>>(key: string, options?: GetDocumentOptions<TModel, TFields>): Promise<NarrowedModel<TModel, TFields>>;
    getDocumentsCount(options?: CountDocumentsOptions): Promise<number>;
    indexDocuments(batch: IndexDocumentsBatch<TModel>, options?: IndexDocumentsOptions): Promise<IndexDocumentsResult>;
    readonly indexName: string;
    mergeDocuments(documents: TModel[], options?: MergeDocumentsOptions): Promise<IndexDocumentsResult>;
    mergeOrUploadDocuments(documents: TModel[], options?: MergeOrUploadDocumentsOptions): Promise<IndexDocumentsResult>;
    readonly pipeline: Pipeline;
    search<TFields extends SelectFields<TModel>>(searchText?: string, options?: SearchOptions<TModel, TFields>): Promise<SearchDocumentsResult<TModel, TFields>>;
    readonly serviceVersion: string;
    suggest<TFields extends SelectFields<TModel> = never>(searchText: string, suggesterName: string, options?: SuggestOptions<TModel, TFields>): Promise<SuggestDocumentsResult<TModel, TFields>>;
    uploadDocuments(documents: TModel[], options?: UploadDocumentsOptions): Promise<IndexDocumentsResult>;
}

// @public
export interface SearchClientOptions extends ExtendedCommonClientOptions {
    // @deprecated
    apiVersion?: string;
    audience?: string;
    serviceVersion?: string;
}

// @public
export interface SearchDocumentsPageResult<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> extends SearchDocumentsResultBase {
    continuationToken?: string;
    readonly results: SearchResult<TModel, TFields>[];
}

// @public
export interface SearchDocumentsResult<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> extends SearchDocumentsResultBase {
    readonly results: SearchIterator<TModel, TFields>;
}

// @public
export interface SearchDocumentsResultBase {
    readonly answers?: QueryAnswerResult[];
    readonly count?: number;
    readonly coverage?: number;
    readonly facets?: {
        [propertyName: string]: FacetResult[];
    };
    readonly semanticErrorReason?: SemanticErrorReason;
    readonly semanticSearchResultsType?: SemanticSearchResultsType;
}

// @public
export type SearchField = SimpleField | ComplexField;

// @public
export type SearchFieldArray<TModel extends object = object> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? readonly string[] : readonly SelectFields<TModel>[];

// @public
export type SearchFieldDataType = "Edm.String" | "Edm.Int32" | "Edm.Int64" | "Edm.Double" | "Edm.Boolean" | "Edm.DateTimeOffset" | "Edm.GeographyPoint" | "Collection(Edm.String)" | "Collection(Edm.Int32)" | "Collection(Edm.Int64)" | "Collection(Edm.Double)" | "Collection(Edm.Boolean)" | "Collection(Edm.DateTimeOffset)" | "Collection(Edm.GeographyPoint)" | "Collection(Edm.Single)" | "Collection(Edm.Half)" | "Collection(Edm.Int16)" | "Collection(Edm.SByte)";

// @public
export interface SearchIndex {
    analyzers?: LexicalAnalyzer[];
    charFilters?: CharFilter[];
    corsOptions?: CorsOptions;
    defaultScoringProfile?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    fields: SearchField[];
    name: string;
    normalizers?: LexicalNormalizer[];
    scoringProfiles?: ScoringProfile[];
    semanticSearch?: SemanticSearch;
    similarity?: SimilarityAlgorithm;
    suggesters?: SearchSuggester[];
    tokenFilters?: TokenFilter[];
    tokenizers?: LexicalTokenizer[];
    vectorSearch?: VectorSearch;
}

// @public
export type SearchIndexAlias = SearchAlias;

// @public
export class SearchIndexClient {
    constructor(endpoint: string, credential: KeyCredential | TokenCredential, options?: SearchIndexClientOptions);
    analyzeText(indexName: string, options: AnalyzeTextOptions): Promise<AnalyzeResult>;
    // @deprecated
    readonly apiVersion: string;
    createAlias(alias: SearchIndexAlias, options?: CreateAliasOptions): Promise<SearchIndexAlias>;
    createIndex(index: SearchIndex, options?: CreateIndexOptions): Promise<SearchIndex>;
    createOrUpdateAlias(alias: SearchIndexAlias, options?: CreateOrUpdateAliasOptions): Promise<SearchIndexAlias>;
    createOrUpdateIndex(index: SearchIndex, options?: CreateOrUpdateIndexOptions): Promise<SearchIndex>;
    createOrUpdateSynonymMap(synonymMap: SynonymMap, options?: CreateOrUpdateSynonymMapOptions): Promise<SynonymMap>;
    createSynonymMap(synonymMap: SynonymMap, options?: CreateSynonymMapOptions): Promise<SynonymMap>;
    deleteAlias(alias: string | SearchIndexAlias, options?: DeleteAliasOptions): Promise<void>;
    deleteIndex(index: string | SearchIndex, options?: DeleteIndexOptions): Promise<void>;
    deleteSynonymMap(synonymMap: string | SynonymMap, options?: DeleteSynonymMapOptions): Promise<void>;
    readonly endpoint: string;
    getAlias(aliasName: string, options?: GetAliasOptions): Promise<SearchIndexAlias>;
    getIndex(indexName: string, options?: GetIndexOptions): Promise<SearchIndex>;
    getIndexStatistics(indexName: string, options?: GetIndexStatisticsOptions): Promise<SearchIndexStatistics>;
    getSearchClient<TModel extends object>(indexName: string, options?: SearchClientOptions): SearchClient<TModel>;
    getServiceStatistics(options?: GetServiceStatisticsOptions): Promise<SearchServiceStatistics>;
    getSynonymMap(synonymMapName: string, options?: GetSynonymMapsOptions): Promise<SynonymMap>;
    listAliases(options?: ListAliasesOptions): AliasIterator;
    listIndexes(options?: ListIndexesOptions): IndexIterator;
    listIndexesNames(options?: ListIndexesOptions): IndexNameIterator;
    listSynonymMaps(options?: ListSynonymMapsOptions): Promise<Array<SynonymMap>>;
    listSynonymMapsNames(options?: ListSynonymMapsOptions): Promise<Array<string>>;
    readonly pipeline: Pipeline;
    readonly serviceVersion: string;
}

// @public
export interface SearchIndexClientOptions extends ExtendedCommonClientOptions {
    // @deprecated
    apiVersion?: string;
    audience?: string;
    serviceVersion?: string;
}

// @public
export interface SearchIndexer {
    cache?: SearchIndexerCache;
    dataSourceName: string;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    fieldMappings?: FieldMapping[];
    isDisabled?: boolean;
    name: string;
    outputFieldMappings?: FieldMapping[];
    parameters?: IndexingParameters;
    schedule?: IndexingSchedule;
    skillsetName?: string;
    targetIndexName: string;
}

// @public (undocumented)
export interface SearchIndexerCache {
    enableReprocessing?: boolean;
    identity?: SearchIndexerDataIdentity;
    storageConnectionString?: string;
}

// @public
export class SearchIndexerClient {
    constructor(endpoint: string, credential: KeyCredential | TokenCredential, options?: SearchIndexerClientOptions);
    // @deprecated
    readonly apiVersion: string;
    createDataSourceConnection(dataSourceConnection: SearchIndexerDataSourceConnection, options?: CreateDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    createIndexer(indexer: SearchIndexer, options?: CreateIndexerOptions): Promise<SearchIndexer>;
    createOrUpdateDataSourceConnection(dataSourceConnection: SearchIndexerDataSourceConnection, options?: CreateorUpdateDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    createOrUpdateIndexer(indexer: SearchIndexer, options?: CreateorUpdateIndexerOptions): Promise<SearchIndexer>;
    createOrUpdateSkillset(skillset: SearchIndexerSkillset, options?: CreateOrUpdateSkillsetOptions): Promise<SearchIndexerSkillset>;
    createSkillset(skillset: SearchIndexerSkillset, options?: CreateSkillsetOptions): Promise<SearchIndexerSkillset>;
    deleteDataSourceConnection(dataSourceConnection: string | SearchIndexerDataSourceConnection, options?: DeleteDataSourceConnectionOptions): Promise<void>;
    deleteIndexer(indexer: string | SearchIndexer, options?: DeleteIndexerOptions): Promise<void>;
    deleteSkillset(skillset: string | SearchIndexerSkillset, options?: DeleteSkillsetOptions): Promise<void>;
    readonly endpoint: string;
    getDataSourceConnection(dataSourceConnectionName: string, options?: GetDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
    getIndexer(indexerName: string, options?: GetIndexerOptions): Promise<SearchIndexer>;
    getIndexerStatus(indexerName: string, options?: GetIndexerStatusOptions): Promise<SearchIndexerStatus>;
    getSkillset(skillsetName: string, options?: GetSkillSetOptions): Promise<SearchIndexerSkillset>;
    listDataSourceConnections(options?: ListDataSourceConnectionsOptions): Promise<Array<SearchIndexerDataSourceConnection>>;
    listDataSourceConnectionsNames(options?: ListDataSourceConnectionsOptions): Promise<Array<string>>;
    listIndexers(options?: ListIndexersOptions): Promise<Array<SearchIndexer>>;
    listIndexersNames(options?: ListIndexersOptions): Promise<Array<string>>;
    listSkillsets(options?: ListSkillsetsOptions): Promise<Array<SearchIndexerSkillset>>;
    listSkillsetsNames(options?: ListSkillsetsOptions): Promise<Array<string>>;
    readonly pipeline: Pipeline;
    resetDocuments(indexerName: string, options?: ResetDocumentsOptions): Promise<void>;
    resetIndexer(indexerName: string, options?: ResetIndexerOptions): Promise<void>;
    resetSkills(skillsetName: string, options?: ResetSkillsOptions): Promise<void>;
    runIndexer(indexerName: string, options?: RunIndexerOptions): Promise<void>;
    readonly serviceVersion: string;
}

// @public
export interface SearchIndexerClientOptions extends ExtendedCommonClientOptions {
    // @deprecated
    apiVersion?: string;
    audience?: string;
    serviceVersion?: string;
}

// @public
export interface SearchIndexerDataContainer {
    name: string;
    query?: string;
}

// @public
export type SearchIndexerDataIdentity = SearchIndexerDataNoneIdentity | SearchIndexerDataUserAssignedIdentity;

// @public
export interface SearchIndexerDataNoneIdentity extends BaseSearchIndexerDataIdentity {
    odatatype: "#Microsoft.Azure.Search.DataNoneIdentity";
}

// @public
export interface SearchIndexerDataSourceConnection {
    connectionString?: string;
    container: SearchIndexerDataContainer;
    dataChangeDetectionPolicy?: DataChangeDetectionPolicy;
    dataDeletionDetectionPolicy?: DataDeletionDetectionPolicy;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    identity?: SearchIndexerDataIdentity;
    name: string;
    type: SearchIndexerDataSourceType;
}

// @public (undocumented)
export type SearchIndexerDataSourceType = "azuresql" | "cosmosdb" | "azureblob" | "azuretable" | "mysql" | "adlsgen2";

// @public
export interface SearchIndexerDataUserAssignedIdentity extends BaseSearchIndexerDataIdentity {
    odatatype: "#Microsoft.Azure.Search.DataUserAssignedIdentity";
    userAssignedIdentity: string;
}

// @public
export interface SearchIndexerError {
    readonly details?: string;
    readonly documentationLink?: string;
    readonly errorMessage: string;
    readonly key?: string;
    readonly name?: string;
    readonly statusCode: number;
}

// @public
export interface SearchIndexerIndexProjections {
    parameters?: SearchIndexerIndexProjectionsParameters;
    selectors: SearchIndexerIndexProjectionSelector[];
}

// @public
export interface SearchIndexerIndexProjectionSelector {
    mappings: InputFieldMappingEntry[];
    parentKeyFieldName: string;
    sourceContext: string;
    targetIndexName: string;
}

// @public
export interface SearchIndexerIndexProjectionsParameters {
    [property: string]: unknown;
    projectionMode?: IndexProjectionMode;
}

// @public
export interface SearchIndexerKnowledgeStore {
    identity?: SearchIndexerDataIdentity;
    projections: SearchIndexerKnowledgeStoreProjection[];
    storageConnectionString: string;
}

// @public
export interface SearchIndexerKnowledgeStoreBlobProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
    storageContainer: string;
}

// @public
export interface SearchIndexerKnowledgeStoreFileProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector {
}

// @public
export interface SearchIndexerKnowledgeStoreObjectProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector {
}

// @public
export interface SearchIndexerKnowledgeStoreParameters {
    [property: string]: unknown;
    synthesizeGeneratedKeyName?: boolean;
}

// @public
export interface SearchIndexerKnowledgeStoreProjection {
    files?: SearchIndexerKnowledgeStoreFileProjectionSelector[];
    objects?: SearchIndexerKnowledgeStoreObjectProjectionSelector[];
    tables?: SearchIndexerKnowledgeStoreTableProjectionSelector[];
}

// @public
export interface SearchIndexerKnowledgeStoreProjectionSelector {
    generatedKeyName?: string;
    inputs?: InputFieldMappingEntry[];
    referenceKeyName?: string;
    source?: string;
    sourceContext?: string;
}

// @public
export interface SearchIndexerKnowledgeStoreTableProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
    tableName: string;
}

// @public (undocumented)
export interface SearchIndexerLimits {
    readonly maxDocumentContentCharactersToExtract?: number;
    readonly maxDocumentExtractionSize?: number;
    readonly maxRunTime?: string;
}

// @public
export type SearchIndexerSkill = AzureMachineLearningSkill | AzureOpenAIEmbeddingSkill | ConditionalSkill | CustomEntityLookupSkill | DocumentExtractionSkill | EntityLinkingSkill | EntityRecognitionSkill | EntityRecognitionSkillV3 | ImageAnalysisSkill | KeyPhraseExtractionSkill | LanguageDetectionSkill | MergeSkill | OcrSkill | PIIDetectionSkill | SentimentSkill | SentimentSkillV3 | ShaperSkill | SplitSkill | TextTranslationSkill | WebApiSkill;

// @public
export interface SearchIndexerSkillset {
    cognitiveServicesAccount?: CognitiveServicesAccount;
    description?: string;
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    indexProjections?: SearchIndexerIndexProjections;
    knowledgeStore?: SearchIndexerKnowledgeStore;
    name: string;
    skills: SearchIndexerSkill[];
}

// @public
export interface SearchIndexerStatus {
    readonly executionHistory: IndexerExecutionResult[];
    readonly lastResult?: IndexerExecutionResult;
    readonly limits: SearchIndexerLimits;
    readonly status: IndexerStatus;
}

// @public
export interface SearchIndexerWarning {
    readonly details?: string;
    readonly documentationLink?: string;
    readonly key?: string;
    readonly message: string;
    readonly name?: string;
}

// @public
export class SearchIndexingBufferedSender<TModel extends object> {
    constructor(client: IndexDocumentsClient<TModel>, documentKeyRetriever: (document: TModel) => string, options?: SearchIndexingBufferedSenderOptions);
    deleteDocuments(documents: TModel[], options?: SearchIndexingBufferedSenderDeleteDocumentsOptions): Promise<void>;
    dispose(): Promise<void>;
    flush(options?: SearchIndexingBufferedSenderFlushDocumentsOptions): Promise<void>;
    mergeDocuments(documents: TModel[], options?: SearchIndexingBufferedSenderMergeDocumentsOptions): Promise<void>;
    mergeOrUploadDocuments(documents: TModel[], options?: SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions): Promise<void>;
    off(event: "batchAdded", listener: (e: {
        action: string;
        documents: TModel[];
    }) => void): void;
    off(event: "beforeDocumentSent", listener: (e: IndexDocumentsAction<TModel>) => void): void;
    off(event: "batchSucceeded", listener: (e: IndexDocumentsResult) => void): void;
    off(event: "batchFailed", listener: (e: RestError) => void): void;
    on(event: "batchAdded", listener: (e: {
        action: string;
        documents: TModel[];
    }) => void): void;
    on(event: "beforeDocumentSent", listener: (e: IndexDocumentsAction<TModel>) => void): void;
    on(event: "batchSucceeded", listener: (e: IndexDocumentsResult) => void): void;
    on(event: "batchFailed", listener: (e: RestError) => void): void;
    uploadDocuments(documents: TModel[], options?: SearchIndexingBufferedSenderUploadDocumentsOptions): Promise<void>;
}

// @public
export type SearchIndexingBufferedSenderDeleteDocumentsOptions = OperationOptions;

// @public
export type SearchIndexingBufferedSenderFlushDocumentsOptions = OperationOptions;

// @public
export type SearchIndexingBufferedSenderMergeDocumentsOptions = OperationOptions;

// @public
export type SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions = OperationOptions;

// @public
export interface SearchIndexingBufferedSenderOptions {
    autoFlush?: boolean;
    flushWindowInMs?: number;
    initialBatchActionCount?: number;
    maxRetriesPerAction?: number;
    maxThrottlingDelayInMs?: number;
    throttlingDelayInMs?: number;
}

// @public
export type SearchIndexingBufferedSenderUploadDocumentsOptions = OperationOptions;

// @public
export interface SearchIndexStatistics {
    readonly documentCount: number;
    readonly storageSize: number;
    readonly vectorIndexSize: number;
}

// @public
export type SearchIterator<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = PagedAsyncIterableIterator<SearchResult<TModel, TFields>, SearchDocumentsPageResult<TModel, TFields>, ListSearchResultsPageSettings>;

// @public
export type SearchMode = "any" | "all";

// @public
export type SearchOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = OperationOptions & SearchRequestOptions<TModel, TFields>;

// @public
export type SearchPick<TModel extends object, TFields extends SelectFields<TModel>> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? TModel : (<T>() => T extends TFields ? true : false) extends <T>() => T extends any ? true : false ? TModel : (<T>() => T extends TFields ? true : false) extends <T>() => T extends never ? true : false ? TModel : // We're going to get a union of individual interfaces for each field in T that's selected, so convert that to an intersection.
UnionToIntersection<TFields extends `${infer FieldName}/${infer RestPaths}` ? FieldName extends keyof TModel & string ? NonNullable<TModel[FieldName]> extends Array<infer Elem> ? Elem extends object ? RestPaths extends SelectFields<Elem> ? {
    [Key in keyof TModel as Key & FieldName]: Array<SearchPick<Elem, RestPaths>>;
} : never : never : NonNullable<TModel[FieldName]> extends object ? {
    [Key in keyof TModel as Key & FieldName]: RestPaths extends SelectFields<TModel[Key] & {}> ? SearchPick<TModel[Key] & {}, RestPaths> | Extract<TModel[Key], null> : never;
} : never : never : TFields extends keyof TModel ? Pick<TModel, TFields> | Extract<TModel, null> : never> & {};

// @public
export type SearchRequestOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = BaseSearchRequestOptions<TModel, TFields> & SearchRequestQueryTypeOptions;

// @public (undocumented)
export type SearchRequestQueryTypeOptions = {
    queryType: "semantic";
    semanticSearchOptions: SemanticSearchOptions;
} | {
    queryType?: "simple" | "full";
};

// @public
export interface SearchResourceEncryptionKey {
    applicationId?: string;
    applicationSecret?: string;
    identity?: SearchIndexerDataIdentity;
    keyName: string;
    keyVersion: string;
    vaultUrl: string;
}

// @public
export type SearchResult<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = {
    readonly score: number;
    readonly rerankerScore?: number;
    readonly highlights?: {
        [k in SelectFields<TModel>]?: string[];
    };
    readonly captions?: QueryCaptionResult[];
    document: NarrowedModel<TModel, TFields>;
    readonly documentDebugInfo?: DocumentDebugInfo[];
};

// @public
export interface SearchServiceStatistics {
    counters: ServiceCounters;
    limits: ServiceLimits;
}

// @public
export interface SearchSuggester {
    name: string;
    searchMode: "analyzingInfixMatching";
    sourceFields: string[];
}

// @public
export type SelectArray<TFields = never> = [string] extends [TFields] ? readonly TFields[] : (<T>() => T extends TFields ? true : false) extends <T>() => T extends never ? true : false ? readonly string[] : readonly TFields[];

// @public
export type SelectFields<TModel extends object> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends never ? true : false ? string : (<T>() => T extends TModel ? true : false) extends <T>() => T extends any ? true : false ? string : (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? string : TModel extends Array<infer Elem> ? Elem extends object ? SelectFields<Elem> : never : {
    [Key in keyof TModel]: Key extends string ? NonNullable<TModel[Key]> extends object ? NonNullable<TModel[Key]> extends ExcludedODataTypes ? Key : SelectFields<NonNullable<TModel[Key]>> extends infer NextPaths ? (<T>() => T extends NextPaths ? true : false) extends <T>() => T extends never ? true : false ? Key : NextPaths extends string ? Key | `${Key}/${NextPaths}` : Key : never : Key : never;
}[keyof TModel & string] & string;

// @public
export interface SemanticConfiguration {
    name: string;
    prioritizedFields: SemanticPrioritizedFields;
}

// @public
export interface SemanticDebugInfo {
    readonly contentFields?: QueryResultDocumentSemanticField[];
    readonly keywordFields?: QueryResultDocumentSemanticField[];
    readonly rerankerInput?: QueryResultDocumentRerankerInput;
    readonly titleField?: QueryResultDocumentSemanticField;
}

// @public (undocumented)
export type SemanticErrorMode = "partial" | "fail";

// @public (undocumented)
export type SemanticErrorReason = "maxWaitExceeded" | "capacityOverloaded" | "transient";

// @public
export interface SemanticField {
    // (undocumented)
    name: string;
}

// @public
export type SemanticFieldState = string;

// @public
export interface SemanticPrioritizedFields {
    contentFields?: SemanticField[];
    keywordsFields?: SemanticField[];
    titleField?: SemanticField;
}

// @public
export interface SemanticSearch {
    configurations?: SemanticConfiguration[];
    defaultConfigurationName?: string;
}

// @public
export interface SemanticSearchOptions {
    answers?: QueryAnswer;
    captions?: QueryCaption;
    configurationName?: string;
    debugMode?: QueryDebugMode;
    errorMode?: SemanticErrorMode;
    maxWaitInMilliseconds?: number;
    semanticFields?: string[];
    semanticQuery?: string;
}

// @public (undocumented)
export type SemanticSearchResultsType = "baseResults" | "rerankedResults";

// @public @deprecated
export interface SentimentSkill extends BaseSearchIndexerSkill {
    defaultLanguageCode?: SentimentSkillLanguage;
    odatatype: "#Microsoft.Skills.Text.SentimentSkill";
}

// @public (undocumented)
export type SentimentSkillLanguage = "da" | "nl" | "en" | "fi" | "fr" | "de" | "el" | "it" | "no" | "pl" | "pt-PT" | "ru" | "es" | "sv" | "tr";

// @public
export interface SentimentSkillV3 extends BaseSearchIndexerSkill {
    defaultLanguageCode?: string;
    includeOpinionMining?: boolean;
    modelVersion?: string;
    odatatype: "#Microsoft.Skills.Text.V3.SentimentSkill";
}

// @public
export interface ServiceCounters {
    aliasCounter: ResourceCounter;
    dataSourceCounter: ResourceCounter;
    documentCounter: ResourceCounter;
    indexCounter: ResourceCounter;
    indexerCounter: ResourceCounter;
    skillsetCounter: ResourceCounter;
    storageSizeCounter: ResourceCounter;
    synonymMapCounter: ResourceCounter;
    vectorIndexSizeCounter: ResourceCounter;
}

// @public
export interface ServiceLimits {
    maxComplexCollectionFieldsPerIndex?: number;
    maxComplexObjectsInCollectionsPerDocument?: number;
    maxFieldNestingDepthPerIndex?: number;
    maxFieldsPerIndex?: number;
}

// @public
export interface ShaperSkill extends BaseSearchIndexerSkill {
    odatatype: "#Microsoft.Skills.Util.ShaperSkill";
}

// @public
export interface ShingleTokenFilter extends BaseTokenFilter {
    filterToken?: string;
    maxShingleSize?: number;
    minShingleSize?: number;
    odatatype: "#Microsoft.Azure.Search.ShingleTokenFilter";
    outputUnigrams?: boolean;
    outputUnigramsIfNoShingles?: boolean;
    tokenSeparator?: string;
}

// @public
export interface Similarity {
    odatatype: "#Microsoft.Azure.Search.ClassicSimilarity" | "#Microsoft.Azure.Search.BM25Similarity";
}

// @public
export type SimilarityAlgorithm = ClassicSimilarity | BM25Similarity;

// @public
export interface SimpleField {
    analyzerName?: LexicalAnalyzerName;
    facetable?: boolean;
    filterable?: boolean;
    hidden?: boolean;
    indexAnalyzerName?: LexicalAnalyzerName;
    key?: boolean;
    name: string;
    normalizerName?: LexicalNormalizerName;
    searchable?: boolean;
    searchAnalyzerName?: LexicalAnalyzerName;
    sortable?: boolean;
    stored?: boolean;
    synonymMapNames?: string[];
    type: SearchFieldDataType;
    vectorSearchDimensions?: number;
    vectorSearchProfileName?: string;
}

// @public
export interface SnowballTokenFilter extends BaseTokenFilter {
    language: SnowballTokenFilterLanguage;
    odatatype: "#Microsoft.Azure.Search.SnowballTokenFilter";
}

// @public
export type SnowballTokenFilterLanguage = "armenian" | "basque" | "catalan" | "danish" | "dutch" | "english" | "finnish" | "french" | "german" | "german2" | "hungarian" | "italian" | "kp" | "lovins" | "norwegian" | "porter" | "portuguese" | "romanian" | "russian" | "spanish" | "swedish" | "turkish";

// @public
export interface SoftDeleteColumnDeletionDetectionPolicy extends BaseDataDeletionDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
    softDeleteColumnName?: string;
    softDeleteMarkerValue?: string;
}

// @public
export type Speller = string;

// @public
export interface SplitSkill extends BaseSearchIndexerSkill {
    defaultLanguageCode?: SplitSkillLanguage;
    maxPageLength?: number;
    odatatype: "#Microsoft.Skills.Text.SplitSkill";
    textSplitMode?: TextSplitMode;
}

// @public (undocumented)
export type SplitSkillLanguage = "am" | "bs" | "cs" | "da" | "de" | "en" | "es" | "et" | "fi" | "fr" | "he" | "hi" | "hr" | "hu" | "id" | "is" | "it" | "ja" | "ko" | "lv" | "nb" | "nl" | "pl" | "pt" | "pt-br" | "ru" | "sk" | "sl" | "sr" | "sv" | "tr" | "ur" | "zh";

// @public
export interface SqlIntegratedChangeTrackingPolicy extends BaseDataChangeDetectionPolicy {
    odatatype: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
}

// @public
export interface StemmerOverrideTokenFilter extends BaseTokenFilter {
    odatatype: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter";
    rules: string[];
}

// @public
export interface StemmerTokenFilter extends BaseTokenFilter {
    language: StemmerTokenFilterLanguage;
    odatatype: "#Microsoft.Azure.Search.StemmerTokenFilter";
}

// @public
export type StemmerTokenFilterLanguage = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "dutchKp" | "english" | "lightEnglish" | "minimalEnglish" | "possessiveEnglish" | "porter2" | "lovins" | "finnish" | "lightFinnish" | "french" | "lightFrench" | "minimalFrench" | "galician" | "minimalGalician" | "german" | "german2" | "lightGerman" | "minimalGerman" | "greek" | "hindi" | "hungarian" | "lightHungarian" | "indonesian" | "irish" | "italian" | "lightItalian" | "sorani" | "latvian" | "norwegian" | "lightNorwegian" | "minimalNorwegian" | "lightNynorsk" | "minimalNynorsk" | "portuguese" | "lightPortuguese" | "minimalPortuguese" | "portugueseRslp" | "romanian" | "russian" | "lightRussian" | "spanish" | "lightSpanish" | "swedish" | "lightSwedish" | "turkish";

// @public
export interface StopAnalyzer extends BaseLexicalAnalyzer {
    odatatype: "#Microsoft.Azure.Search.StopAnalyzer";
    stopwords?: string[];
}

// @public
export type StopwordsList = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "english" | "finnish" | "french" | "galician" | "german" | "greek" | "hindi" | "hungarian" | "indonesian" | "irish" | "italian" | "latvian" | "norwegian" | "persian" | "portuguese" | "romanian" | "russian" | "sorani" | "spanish" | "swedish" | "thai" | "turkish";

// @public
export interface StopwordsTokenFilter extends BaseTokenFilter {
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.StopwordsTokenFilter";
    removeTrailingStopWords?: boolean;
    stopwords?: string[];
    stopwordsList?: StopwordsList;
}

// @public
export interface SuggestDocumentsResult<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> {
    readonly coverage?: number;
    readonly results: SuggestResult<TModel, TFields>[];
}

// @public (undocumented)
export type SuggestNarrowedModel<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends never ? true : false ? TModel : (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? TModel : (<T>() => T extends TFields ? true : false) extends <T>() => T extends never ? true : false ? keyof ExtractDocumentKey<TModel> extends never ? TModel : ExtractDocumentKey<TModel> : TFields extends SelectFields<TModel> ? NarrowedModel<TModel, TFields> : never;

// @public
export type SuggestOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = OperationOptions & SuggestRequest<TModel, TFields>;

// @public
export interface SuggestRequest<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> {
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    orderBy?: string[];
    searchFields?: SearchFieldArray<TModel>;
    select?: SelectArray<TFields>;
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export type SuggestResult<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = {
    readonly text: string;
    document: SuggestNarrowedModel<TModel, TFields>;
};

// @public
export interface SynonymMap {
    encryptionKey?: SearchResourceEncryptionKey;
    etag?: string;
    name: string;
    synonyms: string[];
}

// @public
export interface SynonymTokenFilter extends BaseTokenFilter {
    expand?: boolean;
    ignoreCase?: boolean;
    odatatype: "#Microsoft.Azure.Search.SynonymTokenFilter";
    synonyms: string[];
}

// @public
export interface TagScoringFunction extends BaseScoringFunction {
    parameters: TagScoringParameters;
    type: "tag";
}

// @public
export interface TagScoringParameters {
    tagsParameter: string;
}

// @public (undocumented)
export type TextSplitMode = "pages" | "sentences";

// @public
export interface TextTranslationSkill extends BaseSearchIndexerSkill {
    defaultFromLanguageCode?: TextTranslationSkillLanguage;
    defaultToLanguageCode: TextTranslationSkillLanguage;
    odatatype: "#Microsoft.Skills.Text.TranslationSkill";
    suggestedFrom?: TextTranslationSkillLanguage;
}

// @public (undocumented)
export type TextTranslationSkillLanguage = "af" | "ar" | "bn" | "bs" | "bg" | "yue" | "ca" | "zh-Hans" | "zh-Hant" | "hr" | "cs" | "da" | "nl" | "en" | "et" | "fj" | "fil" | "fi" | "fr" | "de" | "el" | "ht" | "he" | "hi" | "mww" | "hu" | "is" | "id" | "it" | "ja" | "sw" | "tlh" | "tlh-Latn" | "tlh-Piqd" | "ko" | "lv" | "lt" | "mg" | "ms" | "mt" | "nb" | "fa" | "pl" | "pt" | "pt-br" | "pt-PT" | "otq" | "ro" | "ru" | "sm" | "sr-Cyrl" | "sr-Latn" | "sk" | "sl" | "es" | "sv" | "ty" | "ta" | "te" | "th" | "to" | "tr" | "uk" | "ur" | "vi" | "cy" | "yua" | "ga" | "kn" | "mi" | "ml" | "pa";

// @public
export interface TextWeights {
    weights: {
        [propertyName: string]: number;
    };
}

// @public
export type TokenCharacterKind = "letter" | "digit" | "whitespace" | "punctuation" | "symbol";

// @public
export type TokenFilter = AsciiFoldingTokenFilter | CjkBigramTokenFilter | CommonGramTokenFilter | DictionaryDecompounderTokenFilter | EdgeNGramTokenFilter | ElisionTokenFilter | KeepTokenFilter | KeywordMarkerTokenFilter | LengthTokenFilter | LimitTokenFilter | NGramTokenFilter | PatternCaptureTokenFilter | PatternReplaceTokenFilter | PhoneticTokenFilter | ShingleTokenFilter | SnowballTokenFilter | StemmerTokenFilter | StemmerOverrideTokenFilter | StopwordsTokenFilter | SynonymTokenFilter | TruncateTokenFilter | UniqueTokenFilter | WordDelimiterTokenFilter;

// @public
export type TokenFilterName = string;

// @public
export interface TruncateTokenFilter extends BaseTokenFilter {
    length?: number;
    odatatype: "#Microsoft.Azure.Search.TruncateTokenFilter";
}

// @public
export interface UaxUrlEmailTokenizer extends BaseLexicalTokenizer {
    maxTokenLength?: number;
    odatatype: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
}

// @public (undocumented)
export type UnionToIntersection<Union> = (Union extends unknown ? (_: Union) => unknown : never) extends (_: infer I) => unknown ? I : never;

// @public
export interface UniqueTokenFilter extends BaseTokenFilter {
    odatatype: "#Microsoft.Azure.Search.UniqueTokenFilter";
    onlyOnSamePosition?: boolean;
}

// @public
export type UploadDocumentsOptions = IndexDocumentsOptions;

// @public (undocumented)
export type VectorFilterMode = "postFilter" | "preFilter";

// @public
export interface VectorizableTextQuery<TModel extends object> extends BaseVectorQuery<TModel> {
    kind: "text";
    text?: string;
}

// @public
export interface VectorizedQuery<TModel extends object> extends BaseVectorQuery<TModel> {
    kind: "vector";
    vector: number[];
}

// @public
export type VectorQuery<TModel extends object> = VectorizedQuery<TModel> | VectorizableTextQuery<TModel>;

// @public (undocumented)
export type VectorQueryKind = "vector" | "text";

// @public
export interface VectorSearch {
    algorithms?: VectorSearchAlgorithmConfiguration[];
    compressions?: VectorSearchCompressionConfiguration[];
    profiles?: VectorSearchProfile[];
    vectorizers?: VectorSearchVectorizer[];
}

// @public
export type VectorSearchAlgorithmConfiguration = HnswAlgorithmConfiguration | ExhaustiveKnnAlgorithmConfiguration;

// @public (undocumented)
export type VectorSearchAlgorithmKind = "hnsw" | "exhaustiveKnn";

// @public (undocumented)
export type VectorSearchAlgorithmMetric = "cosine" | "euclidean" | "dotProduct";

// @public
export type VectorSearchCompressionConfiguration = ScalarQuantizationCompressionConfiguration;

// @public
export type VectorSearchCompressionKind = string;

// @public
export type VectorSearchCompressionTargetDataType = string;

// @public
export interface VectorSearchOptions<TModel extends object> {
    filterMode?: VectorFilterMode;
    queries: VectorQuery<TModel>[];
}

// @public
export interface VectorSearchProfile {
    algorithmConfigurationName: string;
    compressionConfigurationName?: string;
    name: string;
    vectorizer?: string;
}

// @public
export type VectorSearchVectorizer = AzureOpenAIVectorizer | CustomVectorizer;

// @public (undocumented)
export type VectorSearchVectorizerKind = "azureOpenAI" | "customWebApi";

// @public (undocumented)
export type VisualFeature = "adult" | "brands" | "categories" | "description" | "faces" | "objects" | "tags";

// @public
export interface WebApiSkill extends BaseSearchIndexerSkill {
    authIdentity?: SearchIndexerDataIdentity;
    authResourceId?: string;
    batchSize?: number;
    degreeOfParallelism?: number;
    httpHeaders?: {
        [propertyName: string]: string;
    };
    httpMethod?: string;
    odatatype: "#Microsoft.Skills.Custom.WebApiSkill";
    timeout?: string;
    uri: string;
}

// @public
export interface WordDelimiterTokenFilter extends BaseTokenFilter {
    catenateAll?: boolean;
    catenateNumbers?: boolean;
    catenateWords?: boolean;
    generateNumberParts?: boolean;
    generateWordParts?: boolean;
    odatatype: "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
    preserveOriginal?: boolean;
    protectedWords?: string[];
    splitOnCaseChange?: boolean;
    splitOnNumerics?: boolean;
    stemEnglishPossessive?: boolean;
}

// (No @packageDocumentation comment for this package)

```
