## API Report File for "@azure/search-documents"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Client } from '@azure-rest/core-client';
import { ClientOptions } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AutocompleteGetOptionalParams extends OperationOptions {
    autocompleteMode?: AutocompleteMode;
    clientRequestId?: string;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    querySourceAuthorization?: string;
    searchFields?: string[];
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface AutocompletePostOptionalParams extends OperationOptions {
    autocompleteMode?: AutocompleteMode;
    clientRequestId?: string;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    querySourceAuthorization?: string;
    searchFields?: string;
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface GetDocumentCountOptionalParams extends OperationOptions {
    clientRequestId?: string;
    querySourceAuthorization?: string;
}

// @public
export interface GetDocumentOptionalParams extends OperationOptions {
    clientRequestId?: string;
    querySourceAuthorization?: string;
    selectedFields?: string[];
}

// @public
export interface IndexOptionalParams extends OperationOptions {
    clientRequestId?: string;
    querySourceAuthorization?: string;
}

// @public (undocumented)
export class SearchClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, indexName: string, options?: SearchClientOptionalParams);
    autocompleteGet(searchText: string, suggesterName: string, options?: AutocompleteGetOptionalParams): Promise<AutocompleteResult>;
    autocompletePost(searchText: string, suggesterName: string, options?: AutocompletePostOptionalParams): Promise<AutocompleteResult>;
    getDocument(key: string, options?: GetDocumentOptionalParams): Promise<LookupDocument>;
    getDocumentCount(options?: GetDocumentCountOptionalParams): Promise<number>;
    index(batch: IndexDocumentsBatch, options?: IndexOptionalParams): Promise<IndexDocumentsResult>;
    readonly pipeline: Pipeline;
    searchGet(options?: SearchGetOptionalParams): Promise<SearchDocumentsResult>;
    searchPost(options?: SearchPostOptionalParams): Promise<SearchDocumentsResult>;
    suggestGet(searchText: string, suggesterName: string, options?: SuggestGetOptionalParams): Promise<SuggestDocumentsResult>;
    suggestPost(searchText: string, suggesterName: string, options?: SuggestPostOptionalParams): Promise<SuggestDocumentsResult>;
}

// @public
export interface SearchClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public (undocumented)
export interface SearchContext extends Client {
    apiVersion: string;
    indexName: string;
}

// @public
export interface SearchGetOptionalParams extends OperationOptions {
    answers?: QueryAnswerType;
    captions?: QueryCaptionType;
    clientRequestId?: string;
    debug?: QueryDebugMode;
    facets?: string[];
    filter?: string;
    highlightFields?: string[];
    highlightPostTag?: string;
    highlightPreTag?: string;
    includeTotalResultCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string[];
    queryLanguage?: QueryLanguage;
    queryRewrites?: QueryRewritesType;
    querySourceAuthorization?: string;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    scoringStatistics?: ScoringStatistics;
    searchFields?: string[];
    searchMode?: SearchMode;
    searchText?: string;
    select?: string[];
    semanticConfiguration?: string;
    semanticErrorHandling?: SemanticErrorMode;
    semanticFields?: string[];
    semanticMaxWaitInMilliseconds?: number;
    semanticQuery?: string;
    sessionId?: string;
    skip?: number;
    speller?: QuerySpellerType;
    top?: number;
}

// @public
export interface SearchPostOptionalParams extends OperationOptions {
    answers?: QueryAnswerType;
    captions?: QueryCaptionType;
    clientRequestId?: string;
    debug?: QueryDebugMode;
    facets?: string[];
    filter?: string;
    highlightFields?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    hybridSearch?: HybridSearch;
    includeTotalCount?: boolean;
    minimumCoverage?: number;
    orderBy?: string;
    queryLanguage?: QueryLanguage;
    queryRewrites?: QueryRewritesType;
    querySourceAuthorization?: string;
    querySpeller?: QuerySpellerType;
    queryType?: QueryType;
    scoringParameters?: string[];
    scoringProfile?: string;
    scoringStatistics?: ScoringStatistics;
    searchFields?: string;
    searchMode?: SearchMode;
    searchText?: string;
    select?: string;
    semanticConfigurationName?: string;
    semanticErrorHandling?: SemanticErrorMode;
    semanticFields?: string;
    semanticMaxWaitInMilliseconds?: number;
    semanticQuery?: string;
    sessionId?: string;
    skip?: number;
    top?: number;
    vectorFilterMode?: VectorFilterMode;
    vectorQueries?: VectorQueryUnion[];
}

// @public
export interface SuggestGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    orderBy?: string[];
    querySourceAuthorization?: string;
    searchFields?: string[];
    select?: string[];
    top?: number;
    useFuzzyMatching?: boolean;
}

// @public
export interface SuggestPostOptionalParams extends OperationOptions {
    clientRequestId?: string;
    filter?: string;
    highlightPostTag?: string;
    highlightPreTag?: string;
    minimumCoverage?: number;
    orderBy?: string;
    querySourceAuthorization?: string;
    searchFields?: string;
    select?: string;
    top?: number;
    useFuzzyMatching?: boolean;
}

// (No @packageDocumentation comment for this package)

```
