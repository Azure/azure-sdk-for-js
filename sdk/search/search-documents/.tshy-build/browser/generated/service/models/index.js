/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ApiVersion20241101Preview} that the service accepts. */
export var KnownApiVersion20241101Preview;
(function (KnownApiVersion20241101Preview) {
    /** Api Version '2024-11-01-preview' */
    KnownApiVersion20241101Preview["TwoThousandTwentyFour1101Preview"] = "2024-11-01-preview";
})(KnownApiVersion20241101Preview || (KnownApiVersion20241101Preview = {}));
/** Known values of {@link SearchIndexerDataSourceType} that the service accepts. */
export var KnownSearchIndexerDataSourceType;
(function (KnownSearchIndexerDataSourceType) {
    /** Indicates an Azure SQL datasource. */
    KnownSearchIndexerDataSourceType["AzureSql"] = "azuresql";
    /** Indicates a CosmosDB datasource. */
    KnownSearchIndexerDataSourceType["CosmosDb"] = "cosmosdb";
    /** Indicates an Azure Blob datasource. */
    KnownSearchIndexerDataSourceType["AzureBlob"] = "azureblob";
    /** Indicates an Azure Table datasource. */
    KnownSearchIndexerDataSourceType["AzureTable"] = "azuretable";
    /** Indicates a MySql datasource. */
    KnownSearchIndexerDataSourceType["MySql"] = "mysql";
    /** Indicates an ADLS Gen2 datasource. */
    KnownSearchIndexerDataSourceType["AdlsGen2"] = "adlsgen2";
    /** Indicates a Microsoft Fabric OneLake datasource. */
    KnownSearchIndexerDataSourceType["OneLake"] = "onelake";
})(KnownSearchIndexerDataSourceType || (KnownSearchIndexerDataSourceType = {}));
/** Known values of {@link BlobIndexerParsingMode} that the service accepts. */
export var KnownBlobIndexerParsingMode;
(function (KnownBlobIndexerParsingMode) {
    /** Set to default for normal file processing. */
    KnownBlobIndexerParsingMode["Default"] = "default";
    /** Set to text to improve indexing performance on plain text files in blob storage. */
    KnownBlobIndexerParsingMode["Text"] = "text";
    /** Set to delimitedText when blobs are plain CSV files. */
    KnownBlobIndexerParsingMode["DelimitedText"] = "delimitedText";
    /** Set to json to extract structured content from JSON files. */
    KnownBlobIndexerParsingMode["Json"] = "json";
    /** Set to jsonArray to extract individual elements of a JSON array as separate documents. */
    KnownBlobIndexerParsingMode["JsonArray"] = "jsonArray";
    /** Set to jsonLines to extract individual JSON entities, separated by a new line, as separate documents. */
    KnownBlobIndexerParsingMode["JsonLines"] = "jsonLines";
    /** Set to markdown to extract content from markdown files. */
    KnownBlobIndexerParsingMode["Markdown"] = "markdown";
})(KnownBlobIndexerParsingMode || (KnownBlobIndexerParsingMode = {}));
/** Known values of {@link MarkdownParsingSubmode} that the service accepts. */
export var KnownMarkdownParsingSubmode;
(function (KnownMarkdownParsingSubmode) {
    /** Indicates that each section of the markdown file (up to a specified depth) will be parsed into individual search documents. This can result in a single markdown file producing multiple search documents. This is the default sub-mode. */
    KnownMarkdownParsingSubmode["OneToMany"] = "oneToMany";
    /** Indicates that each markdown file will be parsed into a single search document. */
    KnownMarkdownParsingSubmode["OneToOne"] = "oneToOne";
})(KnownMarkdownParsingSubmode || (KnownMarkdownParsingSubmode = {}));
/** Known values of {@link MarkdownHeaderDepth} that the service accepts. */
export var KnownMarkdownHeaderDepth;
(function (KnownMarkdownHeaderDepth) {
    /** Indicates that headers up to a level of h1 will be considered while grouping markdown content. */
    KnownMarkdownHeaderDepth["H1"] = "h1";
    /** Indicates that headers up to a level of h2 will be considered while grouping markdown content. */
    KnownMarkdownHeaderDepth["H2"] = "h2";
    /** Indicates that headers up to a level of h3 will be considered while grouping markdown content. */
    KnownMarkdownHeaderDepth["H3"] = "h3";
    /** Indicates that headers up to a level of h4 will be considered while grouping markdown content. */
    KnownMarkdownHeaderDepth["H4"] = "h4";
    /** Indicates that headers up to a level of h5 will be considered while grouping markdown content. */
    KnownMarkdownHeaderDepth["H5"] = "h5";
    /** Indicates that headers up to a level of h6 will be considered while grouping markdown content. This is the default. */
    KnownMarkdownHeaderDepth["H6"] = "h6";
})(KnownMarkdownHeaderDepth || (KnownMarkdownHeaderDepth = {}));
/** Known values of {@link BlobIndexerDataToExtract} that the service accepts. */
export var KnownBlobIndexerDataToExtract;
(function (KnownBlobIndexerDataToExtract) {
    /** Indexes just the standard blob properties and user-specified metadata. */
    KnownBlobIndexerDataToExtract["StorageMetadata"] = "storageMetadata";
    /** Extracts metadata provided by the Azure blob storage subsystem and the content-type specific metadata (for example, metadata unique to just .png files are indexed). */
    KnownBlobIndexerDataToExtract["AllMetadata"] = "allMetadata";
    /** Extracts all metadata and textual content from each blob. */
    KnownBlobIndexerDataToExtract["ContentAndMetadata"] = "contentAndMetadata";
})(KnownBlobIndexerDataToExtract || (KnownBlobIndexerDataToExtract = {}));
/** Known values of {@link BlobIndexerImageAction} that the service accepts. */
export var KnownBlobIndexerImageAction;
(function (KnownBlobIndexerImageAction) {
    /** Ignores embedded images or image files in the data set.  This is the default. */
    KnownBlobIndexerImageAction["None"] = "none";
    /** Extracts text from images (for example, the word "STOP" from a traffic stop sign), and embeds it into the content field.  This action requires that "dataToExtract" is set to "contentAndMetadata".  A normalized image refers to additional processing resulting in uniform image output, sized and rotated to promote consistent rendering when you include images in visual search results. This information is generated for each image when you use this option. */
    KnownBlobIndexerImageAction["GenerateNormalizedImages"] = "generateNormalizedImages";
    /** Extracts text from images (for example, the word "STOP" from a traffic stop sign), and embeds it into the content field, but treats PDF files differently in that each page will be rendered as an image and normalized accordingly, instead of extracting embedded images.  Non-PDF file types will be treated the same as if "generateNormalizedImages" was set. */
    KnownBlobIndexerImageAction["GenerateNormalizedImagePerPage"] = "generateNormalizedImagePerPage";
})(KnownBlobIndexerImageAction || (KnownBlobIndexerImageAction = {}));
/** Known values of {@link BlobIndexerPDFTextRotationAlgorithm} that the service accepts. */
export var KnownBlobIndexerPDFTextRotationAlgorithm;
(function (KnownBlobIndexerPDFTextRotationAlgorithm) {
    /** Leverages normal text extraction.  This is the default. */
    KnownBlobIndexerPDFTextRotationAlgorithm["None"] = "none";
    /** May produce better and more readable text extraction from PDF files that have rotated text within them.  Note that there may be a small performance speed impact when this parameter is used.  This parameter only applies to PDF files, and only to PDFs with embedded text.  If the rotated text appears within an embedded image in the PDF, this parameter does not apply. */
    KnownBlobIndexerPDFTextRotationAlgorithm["DetectAngles"] = "detectAngles";
})(KnownBlobIndexerPDFTextRotationAlgorithm || (KnownBlobIndexerPDFTextRotationAlgorithm = {}));
/** Known values of {@link IndexerExecutionEnvironment} that the service accepts. */
export var KnownIndexerExecutionEnvironment;
(function (KnownIndexerExecutionEnvironment) {
    /** Indicates that the search service can determine where the indexer should execute. This is the default environment when nothing is specified and is the recommended value. */
    KnownIndexerExecutionEnvironment["Standard"] = "standard";
    /** Indicates that the indexer should run with the environment provisioned specifically for the search service. This should only be specified as the execution environment if the indexer needs to access resources securely over shared private link resources. */
    KnownIndexerExecutionEnvironment["Private"] = "private";
})(KnownIndexerExecutionEnvironment || (KnownIndexerExecutionEnvironment = {}));
/** Known values of {@link IndexerExecutionStatusDetail} that the service accepts. */
export var KnownIndexerExecutionStatusDetail;
(function (KnownIndexerExecutionStatusDetail) {
    /** Indicates that the reset that occurred was for a call to ResetDocs. */
    KnownIndexerExecutionStatusDetail["ResetDocs"] = "resetDocs";
})(KnownIndexerExecutionStatusDetail || (KnownIndexerExecutionStatusDetail = {}));
/** Known values of {@link IndexingMode} that the service accepts. */
export var KnownIndexingMode;
(function (KnownIndexingMode) {
    /** The indexer is indexing all documents in the datasource. */
    KnownIndexingMode["IndexingAllDocs"] = "indexingAllDocs";
    /** The indexer is indexing selective, reset documents in the datasource. The documents being indexed are defined on indexer status. */
    KnownIndexingMode["IndexingResetDocs"] = "indexingResetDocs";
})(KnownIndexingMode || (KnownIndexingMode = {}));
/** Known values of {@link IndexProjectionMode} that the service accepts. */
export var KnownIndexProjectionMode;
(function (KnownIndexProjectionMode) {
    /** The source document will be skipped from writing into the indexer's target index. */
    KnownIndexProjectionMode["SkipIndexingParentDocuments"] = "skipIndexingParentDocuments";
    /** The source document will be written into the indexer's target index. This is the default pattern. */
    KnownIndexProjectionMode["IncludeIndexingParentDocuments"] = "includeIndexingParentDocuments";
})(KnownIndexProjectionMode || (KnownIndexProjectionMode = {}));
/** Known values of {@link SearchFieldDataType} that the service accepts. */
export var KnownSearchFieldDataType;
(function (KnownSearchFieldDataType) {
    /** Indicates that a field contains a string. */
    KnownSearchFieldDataType["String"] = "Edm.String";
    /** Indicates that a field contains a 32-bit signed integer. */
    KnownSearchFieldDataType["Int32"] = "Edm.Int32";
    /** Indicates that a field contains a 64-bit signed integer. */
    KnownSearchFieldDataType["Int64"] = "Edm.Int64";
    /** Indicates that a field contains an IEEE double-precision floating point number. */
    KnownSearchFieldDataType["Double"] = "Edm.Double";
    /** Indicates that a field contains a Boolean value (true or false). */
    KnownSearchFieldDataType["Boolean"] = "Edm.Boolean";
    /** Indicates that a field contains a date\/time value, including timezone information. */
    KnownSearchFieldDataType["DateTimeOffset"] = "Edm.DateTimeOffset";
    /** Indicates that a field contains a geo-location in terms of longitude and latitude. */
    KnownSearchFieldDataType["GeographyPoint"] = "Edm.GeographyPoint";
    /** Indicates that a field contains one or more complex objects that in turn have sub-fields of other types. */
    KnownSearchFieldDataType["Complex"] = "Edm.ComplexType";
    /** Indicates that a field contains a single-precision floating point number. This is only valid when used with Collection(Edm.Single). */
    KnownSearchFieldDataType["Single"] = "Edm.Single";
    /** Indicates that a field contains a half-precision floating point number. This is only valid when used with Collection(Edm.Half). */
    KnownSearchFieldDataType["Half"] = "Edm.Half";
    /** Indicates that a field contains a 16-bit signed integer. This is only valid when used with Collection(Edm.Int16). */
    KnownSearchFieldDataType["Int16"] = "Edm.Int16";
    /** Indicates that a field contains a 8-bit signed integer. This is only valid when used with Collection(Edm.SByte). */
    KnownSearchFieldDataType["SByte"] = "Edm.SByte";
    /** Indicates that a field contains a 8-bit unsigned integer. This is only valid when used with Collection(Edm.Byte). */
    KnownSearchFieldDataType["Byte"] = "Edm.Byte";
})(KnownSearchFieldDataType || (KnownSearchFieldDataType = {}));
/** Known values of {@link LexicalAnalyzerName} that the service accepts. */
export var KnownLexicalAnalyzerName;
(function (KnownLexicalAnalyzerName) {
    /** Microsoft analyzer for Arabic. */
    KnownLexicalAnalyzerName["ArMicrosoft"] = "ar.microsoft";
    /** Lucene analyzer for Arabic. */
    KnownLexicalAnalyzerName["ArLucene"] = "ar.lucene";
    /** Lucene analyzer for Armenian. */
    KnownLexicalAnalyzerName["HyLucene"] = "hy.lucene";
    /** Microsoft analyzer for Bangla. */
    KnownLexicalAnalyzerName["BnMicrosoft"] = "bn.microsoft";
    /** Lucene analyzer for Basque. */
    KnownLexicalAnalyzerName["EuLucene"] = "eu.lucene";
    /** Microsoft analyzer for Bulgarian. */
    KnownLexicalAnalyzerName["BgMicrosoft"] = "bg.microsoft";
    /** Lucene analyzer for Bulgarian. */
    KnownLexicalAnalyzerName["BgLucene"] = "bg.lucene";
    /** Microsoft analyzer for Catalan. */
    KnownLexicalAnalyzerName["CaMicrosoft"] = "ca.microsoft";
    /** Lucene analyzer for Catalan. */
    KnownLexicalAnalyzerName["CaLucene"] = "ca.lucene";
    /** Microsoft analyzer for Chinese (Simplified). */
    KnownLexicalAnalyzerName["ZhHansMicrosoft"] = "zh-Hans.microsoft";
    /** Lucene analyzer for Chinese (Simplified). */
    KnownLexicalAnalyzerName["ZhHansLucene"] = "zh-Hans.lucene";
    /** Microsoft analyzer for Chinese (Traditional). */
    KnownLexicalAnalyzerName["ZhHantMicrosoft"] = "zh-Hant.microsoft";
    /** Lucene analyzer for Chinese (Traditional). */
    KnownLexicalAnalyzerName["ZhHantLucene"] = "zh-Hant.lucene";
    /** Microsoft analyzer for Croatian. */
    KnownLexicalAnalyzerName["HrMicrosoft"] = "hr.microsoft";
    /** Microsoft analyzer for Czech. */
    KnownLexicalAnalyzerName["CsMicrosoft"] = "cs.microsoft";
    /** Lucene analyzer for Czech. */
    KnownLexicalAnalyzerName["CsLucene"] = "cs.lucene";
    /** Microsoft analyzer for Danish. */
    KnownLexicalAnalyzerName["DaMicrosoft"] = "da.microsoft";
    /** Lucene analyzer for Danish. */
    KnownLexicalAnalyzerName["DaLucene"] = "da.lucene";
    /** Microsoft analyzer for Dutch. */
    KnownLexicalAnalyzerName["NlMicrosoft"] = "nl.microsoft";
    /** Lucene analyzer for Dutch. */
    KnownLexicalAnalyzerName["NlLucene"] = "nl.lucene";
    /** Microsoft analyzer for English. */
    KnownLexicalAnalyzerName["EnMicrosoft"] = "en.microsoft";
    /** Lucene analyzer for English. */
    KnownLexicalAnalyzerName["EnLucene"] = "en.lucene";
    /** Microsoft analyzer for Estonian. */
    KnownLexicalAnalyzerName["EtMicrosoft"] = "et.microsoft";
    /** Microsoft analyzer for Finnish. */
    KnownLexicalAnalyzerName["FiMicrosoft"] = "fi.microsoft";
    /** Lucene analyzer for Finnish. */
    KnownLexicalAnalyzerName["FiLucene"] = "fi.lucene";
    /** Microsoft analyzer for French. */
    KnownLexicalAnalyzerName["FrMicrosoft"] = "fr.microsoft";
    /** Lucene analyzer for French. */
    KnownLexicalAnalyzerName["FrLucene"] = "fr.lucene";
    /** Lucene analyzer for Galician. */
    KnownLexicalAnalyzerName["GlLucene"] = "gl.lucene";
    /** Microsoft analyzer for German. */
    KnownLexicalAnalyzerName["DeMicrosoft"] = "de.microsoft";
    /** Lucene analyzer for German. */
    KnownLexicalAnalyzerName["DeLucene"] = "de.lucene";
    /** Microsoft analyzer for Greek. */
    KnownLexicalAnalyzerName["ElMicrosoft"] = "el.microsoft";
    /** Lucene analyzer for Greek. */
    KnownLexicalAnalyzerName["ElLucene"] = "el.lucene";
    /** Microsoft analyzer for Gujarati. */
    KnownLexicalAnalyzerName["GuMicrosoft"] = "gu.microsoft";
    /** Microsoft analyzer for Hebrew. */
    KnownLexicalAnalyzerName["HeMicrosoft"] = "he.microsoft";
    /** Microsoft analyzer for Hindi. */
    KnownLexicalAnalyzerName["HiMicrosoft"] = "hi.microsoft";
    /** Lucene analyzer for Hindi. */
    KnownLexicalAnalyzerName["HiLucene"] = "hi.lucene";
    /** Microsoft analyzer for Hungarian. */
    KnownLexicalAnalyzerName["HuMicrosoft"] = "hu.microsoft";
    /** Lucene analyzer for Hungarian. */
    KnownLexicalAnalyzerName["HuLucene"] = "hu.lucene";
    /** Microsoft analyzer for Icelandic. */
    KnownLexicalAnalyzerName["IsMicrosoft"] = "is.microsoft";
    /** Microsoft analyzer for Indonesian (Bahasa). */
    KnownLexicalAnalyzerName["IdMicrosoft"] = "id.microsoft";
    /** Lucene analyzer for Indonesian. */
    KnownLexicalAnalyzerName["IdLucene"] = "id.lucene";
    /** Lucene analyzer for Irish. */
    KnownLexicalAnalyzerName["GaLucene"] = "ga.lucene";
    /** Microsoft analyzer for Italian. */
    KnownLexicalAnalyzerName["ItMicrosoft"] = "it.microsoft";
    /** Lucene analyzer for Italian. */
    KnownLexicalAnalyzerName["ItLucene"] = "it.lucene";
    /** Microsoft analyzer for Japanese. */
    KnownLexicalAnalyzerName["JaMicrosoft"] = "ja.microsoft";
    /** Lucene analyzer for Japanese. */
    KnownLexicalAnalyzerName["JaLucene"] = "ja.lucene";
    /** Microsoft analyzer for Kannada. */
    KnownLexicalAnalyzerName["KnMicrosoft"] = "kn.microsoft";
    /** Microsoft analyzer for Korean. */
    KnownLexicalAnalyzerName["KoMicrosoft"] = "ko.microsoft";
    /** Lucene analyzer for Korean. */
    KnownLexicalAnalyzerName["KoLucene"] = "ko.lucene";
    /** Microsoft analyzer for Latvian. */
    KnownLexicalAnalyzerName["LvMicrosoft"] = "lv.microsoft";
    /** Lucene analyzer for Latvian. */
    KnownLexicalAnalyzerName["LvLucene"] = "lv.lucene";
    /** Microsoft analyzer for Lithuanian. */
    KnownLexicalAnalyzerName["LtMicrosoft"] = "lt.microsoft";
    /** Microsoft analyzer for Malayalam. */
    KnownLexicalAnalyzerName["MlMicrosoft"] = "ml.microsoft";
    /** Microsoft analyzer for Malay (Latin). */
    KnownLexicalAnalyzerName["MsMicrosoft"] = "ms.microsoft";
    /** Microsoft analyzer for Marathi. */
    KnownLexicalAnalyzerName["MrMicrosoft"] = "mr.microsoft";
    /** Microsoft analyzer for Norwegian (Bokmål). */
    KnownLexicalAnalyzerName["NbMicrosoft"] = "nb.microsoft";
    /** Lucene analyzer for Norwegian. */
    KnownLexicalAnalyzerName["NoLucene"] = "no.lucene";
    /** Lucene analyzer for Persian. */
    KnownLexicalAnalyzerName["FaLucene"] = "fa.lucene";
    /** Microsoft analyzer for Polish. */
    KnownLexicalAnalyzerName["PlMicrosoft"] = "pl.microsoft";
    /** Lucene analyzer for Polish. */
    KnownLexicalAnalyzerName["PlLucene"] = "pl.lucene";
    /** Microsoft analyzer for Portuguese (Brazil). */
    KnownLexicalAnalyzerName["PtBrMicrosoft"] = "pt-BR.microsoft";
    /** Lucene analyzer for Portuguese (Brazil). */
    KnownLexicalAnalyzerName["PtBrLucene"] = "pt-BR.lucene";
    /** Microsoft analyzer for Portuguese (Portugal). */
    KnownLexicalAnalyzerName["PtPtMicrosoft"] = "pt-PT.microsoft";
    /** Lucene analyzer for Portuguese (Portugal). */
    KnownLexicalAnalyzerName["PtPtLucene"] = "pt-PT.lucene";
    /** Microsoft analyzer for Punjabi. */
    KnownLexicalAnalyzerName["PaMicrosoft"] = "pa.microsoft";
    /** Microsoft analyzer for Romanian. */
    KnownLexicalAnalyzerName["RoMicrosoft"] = "ro.microsoft";
    /** Lucene analyzer for Romanian. */
    KnownLexicalAnalyzerName["RoLucene"] = "ro.lucene";
    /** Microsoft analyzer for Russian. */
    KnownLexicalAnalyzerName["RuMicrosoft"] = "ru.microsoft";
    /** Lucene analyzer for Russian. */
    KnownLexicalAnalyzerName["RuLucene"] = "ru.lucene";
    /** Microsoft analyzer for Serbian (Cyrillic). */
    KnownLexicalAnalyzerName["SrCyrillicMicrosoft"] = "sr-cyrillic.microsoft";
    /** Microsoft analyzer for Serbian (Latin). */
    KnownLexicalAnalyzerName["SrLatinMicrosoft"] = "sr-latin.microsoft";
    /** Microsoft analyzer for Slovak. */
    KnownLexicalAnalyzerName["SkMicrosoft"] = "sk.microsoft";
    /** Microsoft analyzer for Slovenian. */
    KnownLexicalAnalyzerName["SlMicrosoft"] = "sl.microsoft";
    /** Microsoft analyzer for Spanish. */
    KnownLexicalAnalyzerName["EsMicrosoft"] = "es.microsoft";
    /** Lucene analyzer for Spanish. */
    KnownLexicalAnalyzerName["EsLucene"] = "es.lucene";
    /** Microsoft analyzer for Swedish. */
    KnownLexicalAnalyzerName["SvMicrosoft"] = "sv.microsoft";
    /** Lucene analyzer for Swedish. */
    KnownLexicalAnalyzerName["SvLucene"] = "sv.lucene";
    /** Microsoft analyzer for Tamil. */
    KnownLexicalAnalyzerName["TaMicrosoft"] = "ta.microsoft";
    /** Microsoft analyzer for Telugu. */
    KnownLexicalAnalyzerName["TeMicrosoft"] = "te.microsoft";
    /** Microsoft analyzer for Thai. */
    KnownLexicalAnalyzerName["ThMicrosoft"] = "th.microsoft";
    /** Lucene analyzer for Thai. */
    KnownLexicalAnalyzerName["ThLucene"] = "th.lucene";
    /** Microsoft analyzer for Turkish. */
    KnownLexicalAnalyzerName["TrMicrosoft"] = "tr.microsoft";
    /** Lucene analyzer for Turkish. */
    KnownLexicalAnalyzerName["TrLucene"] = "tr.lucene";
    /** Microsoft analyzer for Ukrainian. */
    KnownLexicalAnalyzerName["UkMicrosoft"] = "uk.microsoft";
    /** Microsoft analyzer for Urdu. */
    KnownLexicalAnalyzerName["UrMicrosoft"] = "ur.microsoft";
    /** Microsoft analyzer for Vietnamese. */
    KnownLexicalAnalyzerName["ViMicrosoft"] = "vi.microsoft";
    /** Standard Lucene analyzer. */
    KnownLexicalAnalyzerName["StandardLucene"] = "standard.lucene";
    /** Standard ASCII Folding Lucene analyzer. See https:\//learn.microsoft.com\/rest\/api\/searchservice\/Custom-analyzers-in-Azure-Search#Analyzers */
    KnownLexicalAnalyzerName["StandardAsciiFoldingLucene"] = "standardasciifolding.lucene";
    /** Treats the entire content of a field as a single token. This is useful for data like zip codes, ids, and some product names. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/KeywordAnalyzer.html */
    KnownLexicalAnalyzerName["Keyword"] = "keyword";
    /** Flexibly separates text into terms via a regular expression pattern. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/PatternAnalyzer.html */
    KnownLexicalAnalyzerName["Pattern"] = "pattern";
    /** Divides text at non-letters and converts them to lower case. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/SimpleAnalyzer.html */
    KnownLexicalAnalyzerName["Simple"] = "simple";
    /** Divides text at non-letters; Applies the lowercase and stopword token filters. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/StopAnalyzer.html */
    KnownLexicalAnalyzerName["Stop"] = "stop";
    /** An analyzer that uses the whitespace tokenizer. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/WhitespaceAnalyzer.html */
    KnownLexicalAnalyzerName["Whitespace"] = "whitespace";
})(KnownLexicalAnalyzerName || (KnownLexicalAnalyzerName = {}));
/** Known values of {@link LexicalNormalizerName} that the service accepts. */
export var KnownLexicalNormalizerName;
(function (KnownLexicalNormalizerName) {
    /** Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127 ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such equivalents exist. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/ASCIIFoldingFilter.html */
    KnownLexicalNormalizerName["AsciiFolding"] = "asciifolding";
    /** Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/util\/ElisionFilter.html */
    KnownLexicalNormalizerName["Elision"] = "elision";
    /** Normalizes token text to lowercase. See https:\//lucene.apache.org\/core\/6_6_1\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/LowerCaseFilter.html */
    KnownLexicalNormalizerName["Lowercase"] = "lowercase";
    /** Standard normalizer, which consists of lowercase and asciifolding. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/reverse\/ReverseStringFilter.html */
    KnownLexicalNormalizerName["Standard"] = "standard";
    /** Normalizes token text to uppercase. See https:\//lucene.apache.org\/core\/6_6_1\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/UpperCaseFilter.html */
    KnownLexicalNormalizerName["Uppercase"] = "uppercase";
})(KnownLexicalNormalizerName || (KnownLexicalNormalizerName = {}));
/** Known values of {@link VectorEncodingFormat} that the service accepts. */
export var KnownVectorEncodingFormat;
(function (KnownVectorEncodingFormat) {
    /** Encoding format representing bits packed into a wider data type. */
    KnownVectorEncodingFormat["PackedBit"] = "packedBit";
})(KnownVectorEncodingFormat || (KnownVectorEncodingFormat = {}));
/** Known values of {@link VectorSearchAlgorithmKind} that the service accepts. */
export var KnownVectorSearchAlgorithmKind;
(function (KnownVectorSearchAlgorithmKind) {
    /** HNSW (Hierarchical Navigable Small World), a type of approximate nearest neighbors algorithm. */
    KnownVectorSearchAlgorithmKind["Hnsw"] = "hnsw";
    /** Exhaustive KNN algorithm which will perform brute-force search. */
    KnownVectorSearchAlgorithmKind["ExhaustiveKnn"] = "exhaustiveKnn";
})(KnownVectorSearchAlgorithmKind || (KnownVectorSearchAlgorithmKind = {}));
/** Known values of {@link VectorSearchVectorizerKind} that the service accepts. */
export var KnownVectorSearchVectorizerKind;
(function (KnownVectorSearchVectorizerKind) {
    /** Generate embeddings using an Azure OpenAI resource at query time. */
    KnownVectorSearchVectorizerKind["AzureOpenAI"] = "azureOpenAI";
    /** Generate embeddings using a custom web endpoint at query time. */
    KnownVectorSearchVectorizerKind["CustomWebApi"] = "customWebApi";
    /** Generate embeddings for an image or text input at query time using the Azure AI Services Vision Vectorize API. */
    KnownVectorSearchVectorizerKind["AIServicesVision"] = "aiServicesVision";
    /** Generate embeddings using an Azure Machine Learning endpoint deployed via the Azure AI Foundry Model Catalog at query time. */
    KnownVectorSearchVectorizerKind["AML"] = "aml";
})(KnownVectorSearchVectorizerKind || (KnownVectorSearchVectorizerKind = {}));
/** Known values of {@link VectorSearchCompressionKind} that the service accepts. */
export var KnownVectorSearchCompressionKind;
(function (KnownVectorSearchCompressionKind) {
    /** Scalar Quantization, a type of compression method. In scalar quantization, the original vectors values are compressed to a narrower type by discretizing and representing each component of a vector using a reduced set of quantized values, thereby reducing the overall data size. */
    KnownVectorSearchCompressionKind["ScalarQuantization"] = "scalarQuantization";
    /** Binary Quantization, a type of compression method. In binary quantization, the original vectors values are compressed to the narrower binary type by discretizing and representing each component of a vector using binary values, thereby reducing the overall data size. */
    KnownVectorSearchCompressionKind["BinaryQuantization"] = "binaryQuantization";
})(KnownVectorSearchCompressionKind || (KnownVectorSearchCompressionKind = {}));
/** Known values of {@link VectorSearchCompressionRescoreStorageMethod} that the service accepts. */
export var KnownVectorSearchCompressionRescoreStorageMethod;
(function (KnownVectorSearchCompressionRescoreStorageMethod) {
    /** This option preserves the original full-precision vectors. Choose this option for maximum flexibility and highest quality of compressed search results. This consumes more storage but allows for rescoring and oversampling. */
    KnownVectorSearchCompressionRescoreStorageMethod["PreserveOriginals"] = "preserveOriginals";
    /** This option discards the original full-precision vectors. Choose this option for maximum storage savings. Since this option does not allow for rescoring and oversampling, it will often cause slight to moderate reductions in quality. */
    KnownVectorSearchCompressionRescoreStorageMethod["DiscardOriginals"] = "discardOriginals";
})(KnownVectorSearchCompressionRescoreStorageMethod || (KnownVectorSearchCompressionRescoreStorageMethod = {}));
/** Known values of {@link TokenFilterName} that the service accepts. */
export var KnownTokenFilterName;
(function (KnownTokenFilterName) {
    /** A token filter that applies the Arabic normalizer to normalize the orthography. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ar\/ArabicNormalizationFilter.html */
    KnownTokenFilterName["ArabicNormalization"] = "arabic_normalization";
    /** Strips all characters after an apostrophe (including the apostrophe itself). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/tr\/ApostropheFilter.html */
    KnownTokenFilterName["Apostrophe"] = "apostrophe";
    /** Converts alphabetic, numeric, and symbolic Unicode characters which are not in the first 127 ASCII characters (the "Basic Latin" Unicode block) into their ASCII equivalents, if such equivalents exist. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/ASCIIFoldingFilter.html */
    KnownTokenFilterName["AsciiFolding"] = "asciifolding";
    /** Forms bigrams of CJK terms that are generated from the standard tokenizer. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/cjk\/CJKBigramFilter.html */
    KnownTokenFilterName["CjkBigram"] = "cjk_bigram";
    /** Normalizes CJK width differences. Folds fullwidth ASCII variants into the equivalent basic Latin, and half-width Katakana variants into the equivalent Kana. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/cjk\/CJKWidthFilter.html */
    KnownTokenFilterName["CjkWidth"] = "cjk_width";
    /** Removes English possessives, and dots from acronyms. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/standard\/ClassicFilter.html */
    KnownTokenFilterName["Classic"] = "classic";
    /** Construct bigrams for frequently occurring terms while indexing. Single terms are still indexed too, with bigrams overlaid. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/commongrams\/CommonGramsFilter.html */
    KnownTokenFilterName["CommonGram"] = "common_grams";
    /** Generates n-grams of the given size(s) starting from the front or the back of an input token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ngram\/EdgeNGramTokenFilter.html */
    KnownTokenFilterName["EdgeNGram"] = "edgeNGram_v2";
    /** Removes elisions. For example, "l'avion" (the plane) will be converted to "avion" (plane). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/util\/ElisionFilter.html */
    KnownTokenFilterName["Elision"] = "elision";
    /** Normalizes German characters according to the heuristics of the German2 snowball algorithm. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/de\/GermanNormalizationFilter.html */
    KnownTokenFilterName["GermanNormalization"] = "german_normalization";
    /** Normalizes text in Hindi to remove some differences in spelling variations. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/hi\/HindiNormalizationFilter.html */
    KnownTokenFilterName["HindiNormalization"] = "hindi_normalization";
    /** Normalizes the Unicode representation of text in Indian languages. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/in\/IndicNormalizationFilter.html */
    KnownTokenFilterName["IndicNormalization"] = "indic_normalization";
    /** Emits each incoming token twice, once as keyword and once as non-keyword. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/KeywordRepeatFilter.html */
    KnownTokenFilterName["KeywordRepeat"] = "keyword_repeat";
    /** A high-performance kstem filter for English. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/en\/KStemFilter.html */
    KnownTokenFilterName["KStem"] = "kstem";
    /** Removes words that are too long or too short. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/LengthFilter.html */
    KnownTokenFilterName["Length"] = "length";
    /** Limits the number of tokens while indexing. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/LimitTokenCountFilter.html */
    KnownTokenFilterName["Limit"] = "limit";
    /** Normalizes token text to lower case. See https:\//lucene.apache.org\/core\/6_6_1\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/LowerCaseFilter.html */
    KnownTokenFilterName["Lowercase"] = "lowercase";
    /** Generates n-grams of the given size(s). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ngram\/NGramTokenFilter.html */
    KnownTokenFilterName["NGram"] = "nGram_v2";
    /** Applies normalization for Persian. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/fa\/PersianNormalizationFilter.html */
    KnownTokenFilterName["PersianNormalization"] = "persian_normalization";
    /** Create tokens for phonetic matches. See https:\//lucene.apache.org\/core\/4_10_3\/analyzers-phonetic\/org\/apache\/lucene\/analysis\/phonetic\/package-tree.html */
    KnownTokenFilterName["Phonetic"] = "phonetic";
    /** Uses the Porter stemming algorithm to transform the token stream. See http:\//tartarus.org\/~martin\/PorterStemmer */
    KnownTokenFilterName["PorterStem"] = "porter_stem";
    /** Reverses the token string. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/reverse\/ReverseStringFilter.html */
    KnownTokenFilterName["Reverse"] = "reverse";
    /** Normalizes use of the interchangeable Scandinavian characters. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/ScandinavianNormalizationFilter.html */
    KnownTokenFilterName["ScandinavianNormalization"] = "scandinavian_normalization";
    /** Folds Scandinavian characters åÅäæÄÆ-&gt;a and öÖøØ-&gt;o. It also discriminates against use of double vowels aa, ae, ao, oe and oo, leaving just the first one. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/ScandinavianFoldingFilter.html */
    KnownTokenFilterName["ScandinavianFoldingNormalization"] = "scandinavian_folding";
    /** Creates combinations of tokens as a single token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/shingle\/ShingleFilter.html */
    KnownTokenFilterName["Shingle"] = "shingle";
    /** A filter that stems words using a Snowball-generated stemmer. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/snowball\/SnowballFilter.html */
    KnownTokenFilterName["Snowball"] = "snowball";
    /** Normalizes the Unicode representation of Sorani text. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ckb\/SoraniNormalizationFilter.html */
    KnownTokenFilterName["SoraniNormalization"] = "sorani_normalization";
    /** Language specific stemming filter. See https:\//learn.microsoft.com\/rest\/api\/searchservice\/Custom-analyzers-in-Azure-Search#TokenFilters */
    KnownTokenFilterName["Stemmer"] = "stemmer";
    /** Removes stop words from a token stream. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/StopFilter.html */
    KnownTokenFilterName["Stopwords"] = "stopwords";
    /** Trims leading and trailing whitespace from tokens. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/TrimFilter.html */
    KnownTokenFilterName["Trim"] = "trim";
    /** Truncates the terms to a specific length. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/TruncateTokenFilter.html */
    KnownTokenFilterName["Truncate"] = "truncate";
    /** Filters out tokens with same text as the previous token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/miscellaneous\/RemoveDuplicatesTokenFilter.html */
    KnownTokenFilterName["Unique"] = "unique";
    /** Normalizes token text to upper case. See https:\//lucene.apache.org\/core\/6_6_1\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/UpperCaseFilter.html */
    KnownTokenFilterName["Uppercase"] = "uppercase";
    /** Splits words into subwords and performs optional transformations on subword groups. */
    KnownTokenFilterName["WordDelimiter"] = "word_delimiter";
})(KnownTokenFilterName || (KnownTokenFilterName = {}));
/** Known values of {@link CharFilterName} that the service accepts. */
export var KnownCharFilterName;
(function (KnownCharFilterName) {
    /** A character filter that attempts to strip out HTML constructs. See https:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/charfilter\/HTMLStripCharFilter.html */
    KnownCharFilterName["HtmlStrip"] = "html_strip";
})(KnownCharFilterName || (KnownCharFilterName = {}));
/** Known values of {@link VectorSearchAlgorithmMetric} that the service accepts. */
export var KnownVectorSearchAlgorithmMetric;
(function (KnownVectorSearchAlgorithmMetric) {
    /** Measures the angle between vectors to quantify their similarity, disregarding magnitude. The smaller the angle, the closer the similarity. */
    KnownVectorSearchAlgorithmMetric["Cosine"] = "cosine";
    /** Computes the straight-line distance between vectors in a multi-dimensional space. The smaller the distance, the closer the similarity. */
    KnownVectorSearchAlgorithmMetric["Euclidean"] = "euclidean";
    /** Calculates the sum of element-wise products to gauge alignment and magnitude similarity. The larger and more positive, the closer the similarity. */
    KnownVectorSearchAlgorithmMetric["DotProduct"] = "dotProduct";
    /** Only applicable to bit-packed binary data types. Determines dissimilarity by counting differing positions in binary vectors. The fewer differences, the closer the similarity. */
    KnownVectorSearchAlgorithmMetric["Hamming"] = "hamming";
})(KnownVectorSearchAlgorithmMetric || (KnownVectorSearchAlgorithmMetric = {}));
/** Known values of {@link VectorSearchCompressionTarget} that the service accepts. */
export var KnownVectorSearchCompressionTarget;
(function (KnownVectorSearchCompressionTarget) {
    /** Int8 */
    KnownVectorSearchCompressionTarget["Int8"] = "int8";
})(KnownVectorSearchCompressionTarget || (KnownVectorSearchCompressionTarget = {}));
/** Known values of {@link AzureOpenAIModelName} that the service accepts. */
export var KnownAzureOpenAIModelName;
(function (KnownAzureOpenAIModelName) {
    /** TextEmbeddingAda002 */
    KnownAzureOpenAIModelName["TextEmbeddingAda002"] = "text-embedding-ada-002";
    /** TextEmbedding3Large */
    KnownAzureOpenAIModelName["TextEmbedding3Large"] = "text-embedding-3-large";
    /** TextEmbedding3Small */
    KnownAzureOpenAIModelName["TextEmbedding3Small"] = "text-embedding-3-small";
})(KnownAzureOpenAIModelName || (KnownAzureOpenAIModelName = {}));
/** Known values of {@link AIStudioModelCatalogName} that the service accepts. */
export var KnownAIStudioModelCatalogName;
(function (KnownAIStudioModelCatalogName) {
    /** OpenAIClipImageTextEmbeddingsVitBasePatch32 */
    KnownAIStudioModelCatalogName["OpenAIClipImageTextEmbeddingsVitBasePatch32"] = "OpenAI-CLIP-Image-Text-Embeddings-vit-base-patch32";
    /** OpenAIClipImageTextEmbeddingsViTLargePatch14336 */
    KnownAIStudioModelCatalogName["OpenAIClipImageTextEmbeddingsViTLargePatch14336"] = "OpenAI-CLIP-Image-Text-Embeddings-ViT-Large-Patch14-336";
    /** FacebookDinoV2ImageEmbeddingsViTBase */
    KnownAIStudioModelCatalogName["FacebookDinoV2ImageEmbeddingsViTBase"] = "Facebook-DinoV2-Image-Embeddings-ViT-Base";
    /** FacebookDinoV2ImageEmbeddingsViTGiant */
    KnownAIStudioModelCatalogName["FacebookDinoV2ImageEmbeddingsViTGiant"] = "Facebook-DinoV2-Image-Embeddings-ViT-Giant";
    /** CohereEmbedV3English */
    KnownAIStudioModelCatalogName["CohereEmbedV3English"] = "Cohere-embed-v3-english";
    /** CohereEmbedV3Multilingual */
    KnownAIStudioModelCatalogName["CohereEmbedV3Multilingual"] = "Cohere-embed-v3-multilingual";
})(KnownAIStudioModelCatalogName || (KnownAIStudioModelCatalogName = {}));
/** Known values of {@link KeyPhraseExtractionSkillLanguage} that the service accepts. */
export var KnownKeyPhraseExtractionSkillLanguage;
(function (KnownKeyPhraseExtractionSkillLanguage) {
    /** Danish */
    KnownKeyPhraseExtractionSkillLanguage["Da"] = "da";
    /** Dutch */
    KnownKeyPhraseExtractionSkillLanguage["Nl"] = "nl";
    /** English */
    KnownKeyPhraseExtractionSkillLanguage["En"] = "en";
    /** Finnish */
    KnownKeyPhraseExtractionSkillLanguage["Fi"] = "fi";
    /** French */
    KnownKeyPhraseExtractionSkillLanguage["Fr"] = "fr";
    /** German */
    KnownKeyPhraseExtractionSkillLanguage["De"] = "de";
    /** Italian */
    KnownKeyPhraseExtractionSkillLanguage["It"] = "it";
    /** Japanese */
    KnownKeyPhraseExtractionSkillLanguage["Ja"] = "ja";
    /** Korean */
    KnownKeyPhraseExtractionSkillLanguage["Ko"] = "ko";
    /** Norwegian (Bokmaal) */
    KnownKeyPhraseExtractionSkillLanguage["No"] = "no";
    /** Polish */
    KnownKeyPhraseExtractionSkillLanguage["Pl"] = "pl";
    /** Portuguese (Portugal) */
    KnownKeyPhraseExtractionSkillLanguage["PtPT"] = "pt-PT";
    /** Portuguese (Brazil) */
    KnownKeyPhraseExtractionSkillLanguage["PtBR"] = "pt-BR";
    /** Russian */
    KnownKeyPhraseExtractionSkillLanguage["Ru"] = "ru";
    /** Spanish */
    KnownKeyPhraseExtractionSkillLanguage["Es"] = "es";
    /** Swedish */
    KnownKeyPhraseExtractionSkillLanguage["Sv"] = "sv";
})(KnownKeyPhraseExtractionSkillLanguage || (KnownKeyPhraseExtractionSkillLanguage = {}));
/** Known values of {@link OcrSkillLanguage} that the service accepts. */
export var KnownOcrSkillLanguage;
(function (KnownOcrSkillLanguage) {
    /** Afrikaans */
    KnownOcrSkillLanguage["Af"] = "af";
    /** Albanian */
    KnownOcrSkillLanguage["Sq"] = "sq";
    /** Angika (Devanagiri) */
    KnownOcrSkillLanguage["Anp"] = "anp";
    /** Arabic */
    KnownOcrSkillLanguage["Ar"] = "ar";
    /** Asturian */
    KnownOcrSkillLanguage["Ast"] = "ast";
    /** Awadhi-Hindi (Devanagiri) */
    KnownOcrSkillLanguage["Awa"] = "awa";
    /** Azerbaijani (Latin) */
    KnownOcrSkillLanguage["Az"] = "az";
    /** Bagheli */
    KnownOcrSkillLanguage["Bfy"] = "bfy";
    /** Basque */
    KnownOcrSkillLanguage["Eu"] = "eu";
    /** Belarusian (Cyrillic and Latin) */
    KnownOcrSkillLanguage["Be"] = "be";
    /** Belarusian (Cyrillic) */
    KnownOcrSkillLanguage["BeCyrl"] = "be-cyrl";
    /** Belarusian (Latin) */
    KnownOcrSkillLanguage["BeLatn"] = "be-latn";
    /** Bhojpuri-Hindi (Devanagiri) */
    KnownOcrSkillLanguage["Bho"] = "bho";
    /** Bislama */
    KnownOcrSkillLanguage["Bi"] = "bi";
    /** Bodo (Devanagiri) */
    KnownOcrSkillLanguage["Brx"] = "brx";
    /** Bosnian Latin */
    KnownOcrSkillLanguage["Bs"] = "bs";
    /** Brajbha */
    KnownOcrSkillLanguage["Bra"] = "bra";
    /** Breton */
    KnownOcrSkillLanguage["Br"] = "br";
    /** Bulgarian */
    KnownOcrSkillLanguage["Bg"] = "bg";
    /** Bundeli */
    KnownOcrSkillLanguage["Bns"] = "bns";
    /** Buryat (Cyrillic) */
    KnownOcrSkillLanguage["Bua"] = "bua";
    /** Catalan */
    KnownOcrSkillLanguage["Ca"] = "ca";
    /** Cebuano */
    KnownOcrSkillLanguage["Ceb"] = "ceb";
    /** Chamling */
    KnownOcrSkillLanguage["Rab"] = "rab";
    /** Chamorro */
    KnownOcrSkillLanguage["Ch"] = "ch";
    /** Chhattisgarhi (Devanagiri) */
    KnownOcrSkillLanguage["Hne"] = "hne";
    /** Chinese Simplified */
    KnownOcrSkillLanguage["ZhHans"] = "zh-Hans";
    /** Chinese Traditional */
    KnownOcrSkillLanguage["ZhHant"] = "zh-Hant";
    /** Cornish */
    KnownOcrSkillLanguage["Kw"] = "kw";
    /** Corsican */
    KnownOcrSkillLanguage["Co"] = "co";
    /** Crimean Tatar (Latin) */
    KnownOcrSkillLanguage["Crh"] = "crh";
    /** Croatian */
    KnownOcrSkillLanguage["Hr"] = "hr";
    /** Czech */
    KnownOcrSkillLanguage["Cs"] = "cs";
    /** Danish */
    KnownOcrSkillLanguage["Da"] = "da";
    /** Dari */
    KnownOcrSkillLanguage["Prs"] = "prs";
    /** Dhimal (Devanagiri) */
    KnownOcrSkillLanguage["Dhi"] = "dhi";
    /** Dogri (Devanagiri) */
    KnownOcrSkillLanguage["Doi"] = "doi";
    /** Dutch */
    KnownOcrSkillLanguage["Nl"] = "nl";
    /** English */
    KnownOcrSkillLanguage["En"] = "en";
    /** Erzya (Cyrillic) */
    KnownOcrSkillLanguage["Myv"] = "myv";
    /** Estonian */
    KnownOcrSkillLanguage["Et"] = "et";
    /** Faroese */
    KnownOcrSkillLanguage["Fo"] = "fo";
    /** Fijian */
    KnownOcrSkillLanguage["Fj"] = "fj";
    /** Filipino */
    KnownOcrSkillLanguage["Fil"] = "fil";
    /** Finnish */
    KnownOcrSkillLanguage["Fi"] = "fi";
    /** French */
    KnownOcrSkillLanguage["Fr"] = "fr";
    /** Frulian */
    KnownOcrSkillLanguage["Fur"] = "fur";
    /** Gagauz (Latin) */
    KnownOcrSkillLanguage["Gag"] = "gag";
    /** Galician */
    KnownOcrSkillLanguage["Gl"] = "gl";
    /** German */
    KnownOcrSkillLanguage["De"] = "de";
    /** Gilbertese */
    KnownOcrSkillLanguage["Gil"] = "gil";
    /** Gondi (Devanagiri) */
    KnownOcrSkillLanguage["Gon"] = "gon";
    /** Greek */
    KnownOcrSkillLanguage["El"] = "el";
    /** Greenlandic */
    KnownOcrSkillLanguage["Kl"] = "kl";
    /** Gurung (Devanagiri) */
    KnownOcrSkillLanguage["Gvr"] = "gvr";
    /** Haitian Creole */
    KnownOcrSkillLanguage["Ht"] = "ht";
    /** Halbi (Devanagiri) */
    KnownOcrSkillLanguage["Hlb"] = "hlb";
    /** Hani */
    KnownOcrSkillLanguage["Hni"] = "hni";
    /** Haryanvi */
    KnownOcrSkillLanguage["Bgc"] = "bgc";
    /** Hawaiian */
    KnownOcrSkillLanguage["Haw"] = "haw";
    /** Hindi */
    KnownOcrSkillLanguage["Hi"] = "hi";
    /** Hmong Daw (Latin) */
    KnownOcrSkillLanguage["Mww"] = "mww";
    /** Ho (Devanagiri) */
    KnownOcrSkillLanguage["Hoc"] = "hoc";
    /** Hungarian */
    KnownOcrSkillLanguage["Hu"] = "hu";
    /** Icelandic */
    KnownOcrSkillLanguage["Is"] = "is";
    /** Inari Sami */
    KnownOcrSkillLanguage["Smn"] = "smn";
    /** Indonesian */
    KnownOcrSkillLanguage["Id"] = "id";
    /** Interlingua */
    KnownOcrSkillLanguage["Ia"] = "ia";
    /** Inuktitut (Latin) */
    KnownOcrSkillLanguage["Iu"] = "iu";
    /** Irish */
    KnownOcrSkillLanguage["Ga"] = "ga";
    /** Italian */
    KnownOcrSkillLanguage["It"] = "it";
    /** Japanese */
    KnownOcrSkillLanguage["Ja"] = "ja";
    /** Jaunsari (Devanagiri) */
    KnownOcrSkillLanguage["Jns"] = "Jns";
    /** Javanese */
    KnownOcrSkillLanguage["Jv"] = "jv";
    /** Kabuverdianu */
    KnownOcrSkillLanguage["Kea"] = "kea";
    /** Kachin (Latin) */
    KnownOcrSkillLanguage["Kac"] = "kac";
    /** Kangri (Devanagiri) */
    KnownOcrSkillLanguage["Xnr"] = "xnr";
    /** Karachay-Balkar */
    KnownOcrSkillLanguage["Krc"] = "krc";
    /** Kara-Kalpak (Cyrillic) */
    KnownOcrSkillLanguage["KaaCyrl"] = "kaa-cyrl";
    /** Kara-Kalpak (Latin) */
    KnownOcrSkillLanguage["Kaa"] = "kaa";
    /** Kashubian */
    KnownOcrSkillLanguage["Csb"] = "csb";
    /** Kazakh (Cyrillic) */
    KnownOcrSkillLanguage["KkCyrl"] = "kk-cyrl";
    /** Kazakh (Latin) */
    KnownOcrSkillLanguage["KkLatn"] = "kk-latn";
    /** Khaling */
    KnownOcrSkillLanguage["Klr"] = "klr";
    /** Khasi */
    KnownOcrSkillLanguage["Kha"] = "kha";
    /** K'iche' */
    KnownOcrSkillLanguage["Quc"] = "quc";
    /** Korean */
    KnownOcrSkillLanguage["Ko"] = "ko";
    /** Korku */
    KnownOcrSkillLanguage["Kfq"] = "kfq";
    /** Koryak */
    KnownOcrSkillLanguage["Kpy"] = "kpy";
    /** Kosraean */
    KnownOcrSkillLanguage["Kos"] = "kos";
    /** Kumyk (Cyrillic) */
    KnownOcrSkillLanguage["Kum"] = "kum";
    /** Kurdish (Arabic) */
    KnownOcrSkillLanguage["KuArab"] = "ku-arab";
    /** Kurdish (Latin) */
    KnownOcrSkillLanguage["KuLatn"] = "ku-latn";
    /** Kurukh (Devanagiri) */
    KnownOcrSkillLanguage["Kru"] = "kru";
    /** Kyrgyz (Cyrillic) */
    KnownOcrSkillLanguage["Ky"] = "ky";
    /** Lakota */
    KnownOcrSkillLanguage["Lkt"] = "lkt";
    /** Latin */
    KnownOcrSkillLanguage["La"] = "la";
    /** Lithuanian */
    KnownOcrSkillLanguage["Lt"] = "lt";
    /** Lower Sorbian */
    KnownOcrSkillLanguage["Dsb"] = "dsb";
    /** Lule Sami */
    KnownOcrSkillLanguage["Smj"] = "smj";
    /** Luxembourgish */
    KnownOcrSkillLanguage["Lb"] = "lb";
    /** Mahasu Pahari (Devanagiri) */
    KnownOcrSkillLanguage["Bfz"] = "bfz";
    /** Malay (Latin) */
    KnownOcrSkillLanguage["Ms"] = "ms";
    /** Maltese */
    KnownOcrSkillLanguage["Mt"] = "mt";
    /** Malto (Devanagiri) */
    KnownOcrSkillLanguage["Kmj"] = "kmj";
    /** Manx */
    KnownOcrSkillLanguage["Gv"] = "gv";
    /** Maori */
    KnownOcrSkillLanguage["Mi"] = "mi";
    /** Marathi */
    KnownOcrSkillLanguage["Mr"] = "mr";
    /** Mongolian (Cyrillic) */
    KnownOcrSkillLanguage["Mn"] = "mn";
    /** Montenegrin (Cyrillic) */
    KnownOcrSkillLanguage["CnrCyrl"] = "cnr-cyrl";
    /** Montenegrin (Latin) */
    KnownOcrSkillLanguage["CnrLatn"] = "cnr-latn";
    /** Neapolitan */
    KnownOcrSkillLanguage["Nap"] = "nap";
    /** Nepali */
    KnownOcrSkillLanguage["Ne"] = "ne";
    /** Niuean */
    KnownOcrSkillLanguage["Niu"] = "niu";
    /** Nogay */
    KnownOcrSkillLanguage["Nog"] = "nog";
    /** Northern Sami (Latin) */
    KnownOcrSkillLanguage["Sme"] = "sme";
    /** Norwegian */
    KnownOcrSkillLanguage["Nb"] = "nb";
    /** Norwegian */
    KnownOcrSkillLanguage["No"] = "no";
    /** Occitan */
    KnownOcrSkillLanguage["Oc"] = "oc";
    /** Ossetic */
    KnownOcrSkillLanguage["Os"] = "os";
    /** Pashto */
    KnownOcrSkillLanguage["Ps"] = "ps";
    /** Persian */
    KnownOcrSkillLanguage["Fa"] = "fa";
    /** Polish */
    KnownOcrSkillLanguage["Pl"] = "pl";
    /** Portuguese */
    KnownOcrSkillLanguage["Pt"] = "pt";
    /** Punjabi (Arabic) */
    KnownOcrSkillLanguage["Pa"] = "pa";
    /** Ripuarian */
    KnownOcrSkillLanguage["Ksh"] = "ksh";
    /** Romanian */
    KnownOcrSkillLanguage["Ro"] = "ro";
    /** Romansh */
    KnownOcrSkillLanguage["Rm"] = "rm";
    /** Russian */
    KnownOcrSkillLanguage["Ru"] = "ru";
    /** Sadri (Devanagiri) */
    KnownOcrSkillLanguage["Sck"] = "sck";
    /** Samoan (Latin) */
    KnownOcrSkillLanguage["Sm"] = "sm";
    /** Sanskrit (Devanagiri) */
    KnownOcrSkillLanguage["Sa"] = "sa";
    /** Santali (Devanagiri) */
    KnownOcrSkillLanguage["Sat"] = "sat";
    /** Scots */
    KnownOcrSkillLanguage["Sco"] = "sco";
    /** Scottish Gaelic */
    KnownOcrSkillLanguage["Gd"] = "gd";
    /** Serbian (Latin) */
    KnownOcrSkillLanguage["Sr"] = "sr";
    /** Serbian (Cyrillic) */
    KnownOcrSkillLanguage["SrCyrl"] = "sr-Cyrl";
    /** Serbian (Latin) */
    KnownOcrSkillLanguage["SrLatn"] = "sr-Latn";
    /** Sherpa (Devanagiri) */
    KnownOcrSkillLanguage["Xsr"] = "xsr";
    /** Sirmauri (Devanagiri) */
    KnownOcrSkillLanguage["Srx"] = "srx";
    /** Skolt Sami */
    KnownOcrSkillLanguage["Sms"] = "sms";
    /** Slovak */
    KnownOcrSkillLanguage["Sk"] = "sk";
    /** Slovenian */
    KnownOcrSkillLanguage["Sl"] = "sl";
    /** Somali (Arabic) */
    KnownOcrSkillLanguage["So"] = "so";
    /** Southern Sami */
    KnownOcrSkillLanguage["Sma"] = "sma";
    /** Spanish */
    KnownOcrSkillLanguage["Es"] = "es";
    /** Swahili (Latin) */
    KnownOcrSkillLanguage["Sw"] = "sw";
    /** Swedish */
    KnownOcrSkillLanguage["Sv"] = "sv";
    /** Tajik (Cyrillic) */
    KnownOcrSkillLanguage["Tg"] = "tg";
    /** Tatar (Latin) */
    KnownOcrSkillLanguage["Tt"] = "tt";
    /** Tetum */
    KnownOcrSkillLanguage["Tet"] = "tet";
    /** Thangmi */
    KnownOcrSkillLanguage["Thf"] = "thf";
    /** Tongan */
    KnownOcrSkillLanguage["To"] = "to";
    /** Turkish */
    KnownOcrSkillLanguage["Tr"] = "tr";
    /** Turkmen (Latin) */
    KnownOcrSkillLanguage["Tk"] = "tk";
    /** Tuvan */
    KnownOcrSkillLanguage["Tyv"] = "tyv";
    /** Upper Sorbian */
    KnownOcrSkillLanguage["Hsb"] = "hsb";
    /** Urdu */
    KnownOcrSkillLanguage["Ur"] = "ur";
    /** Uyghur (Arabic) */
    KnownOcrSkillLanguage["Ug"] = "ug";
    /** Uzbek (Arabic) */
    KnownOcrSkillLanguage["UzArab"] = "uz-arab";
    /** Uzbek (Cyrillic) */
    KnownOcrSkillLanguage["UzCyrl"] = "uz-cyrl";
    /** Uzbek (Latin) */
    KnownOcrSkillLanguage["Uz"] = "uz";
    /** Volapük */
    KnownOcrSkillLanguage["Vo"] = "vo";
    /** Walser */
    KnownOcrSkillLanguage["Wae"] = "wae";
    /** Welsh */
    KnownOcrSkillLanguage["Cy"] = "cy";
    /** Western Frisian */
    KnownOcrSkillLanguage["Fy"] = "fy";
    /** Yucatec Maya */
    KnownOcrSkillLanguage["Yua"] = "yua";
    /** Zhuang */
    KnownOcrSkillLanguage["Za"] = "za";
    /** Zulu */
    KnownOcrSkillLanguage["Zu"] = "zu";
    /** Unknown (All) */
    KnownOcrSkillLanguage["Unk"] = "unk";
})(KnownOcrSkillLanguage || (KnownOcrSkillLanguage = {}));
/** Known values of {@link OcrLineEnding} that the service accepts. */
export var KnownOcrLineEnding;
(function (KnownOcrLineEnding) {
    /** Lines are separated by a single space character. */
    KnownOcrLineEnding["Space"] = "space";
    /** Lines are separated by a carriage return ('\r') character. */
    KnownOcrLineEnding["CarriageReturn"] = "carriageReturn";
    /** Lines are separated by a single line feed ('\n') character. */
    KnownOcrLineEnding["LineFeed"] = "lineFeed";
    /** Lines are separated by a carriage return and a line feed ('\r\n') character. */
    KnownOcrLineEnding["CarriageReturnLineFeed"] = "carriageReturnLineFeed";
})(KnownOcrLineEnding || (KnownOcrLineEnding = {}));
/** Known values of {@link ImageAnalysisSkillLanguage} that the service accepts. */
export var KnownImageAnalysisSkillLanguage;
(function (KnownImageAnalysisSkillLanguage) {
    /** Arabic */
    KnownImageAnalysisSkillLanguage["Ar"] = "ar";
    /** Azerbaijani */
    KnownImageAnalysisSkillLanguage["Az"] = "az";
    /** Bulgarian */
    KnownImageAnalysisSkillLanguage["Bg"] = "bg";
    /** Bosnian Latin */
    KnownImageAnalysisSkillLanguage["Bs"] = "bs";
    /** Catalan */
    KnownImageAnalysisSkillLanguage["Ca"] = "ca";
    /** Czech */
    KnownImageAnalysisSkillLanguage["Cs"] = "cs";
    /** Welsh */
    KnownImageAnalysisSkillLanguage["Cy"] = "cy";
    /** Danish */
    KnownImageAnalysisSkillLanguage["Da"] = "da";
    /** German */
    KnownImageAnalysisSkillLanguage["De"] = "de";
    /** Greek */
    KnownImageAnalysisSkillLanguage["El"] = "el";
    /** English */
    KnownImageAnalysisSkillLanguage["En"] = "en";
    /** Spanish */
    KnownImageAnalysisSkillLanguage["Es"] = "es";
    /** Estonian */
    KnownImageAnalysisSkillLanguage["Et"] = "et";
    /** Basque */
    KnownImageAnalysisSkillLanguage["Eu"] = "eu";
    /** Finnish */
    KnownImageAnalysisSkillLanguage["Fi"] = "fi";
    /** French */
    KnownImageAnalysisSkillLanguage["Fr"] = "fr";
    /** Irish */
    KnownImageAnalysisSkillLanguage["Ga"] = "ga";
    /** Galician */
    KnownImageAnalysisSkillLanguage["Gl"] = "gl";
    /** Hebrew */
    KnownImageAnalysisSkillLanguage["He"] = "he";
    /** Hindi */
    KnownImageAnalysisSkillLanguage["Hi"] = "hi";
    /** Croatian */
    KnownImageAnalysisSkillLanguage["Hr"] = "hr";
    /** Hungarian */
    KnownImageAnalysisSkillLanguage["Hu"] = "hu";
    /** Indonesian */
    KnownImageAnalysisSkillLanguage["Id"] = "id";
    /** Italian */
    KnownImageAnalysisSkillLanguage["It"] = "it";
    /** Japanese */
    KnownImageAnalysisSkillLanguage["Ja"] = "ja";
    /** Kazakh */
    KnownImageAnalysisSkillLanguage["Kk"] = "kk";
    /** Korean */
    KnownImageAnalysisSkillLanguage["Ko"] = "ko";
    /** Lithuanian */
    KnownImageAnalysisSkillLanguage["Lt"] = "lt";
    /** Latvian */
    KnownImageAnalysisSkillLanguage["Lv"] = "lv";
    /** Macedonian */
    KnownImageAnalysisSkillLanguage["Mk"] = "mk";
    /** Malay Malaysia */
    KnownImageAnalysisSkillLanguage["Ms"] = "ms";
    /** Norwegian (Bokmal) */
    KnownImageAnalysisSkillLanguage["Nb"] = "nb";
    /** Dutch */
    KnownImageAnalysisSkillLanguage["Nl"] = "nl";
    /** Polish */
    KnownImageAnalysisSkillLanguage["Pl"] = "pl";
    /** Dari */
    KnownImageAnalysisSkillLanguage["Prs"] = "prs";
    /** Portuguese-Brazil */
    KnownImageAnalysisSkillLanguage["PtBR"] = "pt-BR";
    /** Portuguese-Portugal */
    KnownImageAnalysisSkillLanguage["Pt"] = "pt";
    /** Portuguese-Portugal */
    KnownImageAnalysisSkillLanguage["PtPT"] = "pt-PT";
    /** Romanian */
    KnownImageAnalysisSkillLanguage["Ro"] = "ro";
    /** Russian */
    KnownImageAnalysisSkillLanguage["Ru"] = "ru";
    /** Slovak */
    KnownImageAnalysisSkillLanguage["Sk"] = "sk";
    /** Slovenian */
    KnownImageAnalysisSkillLanguage["Sl"] = "sl";
    /** Serbian - Cyrillic RS */
    KnownImageAnalysisSkillLanguage["SrCyrl"] = "sr-Cyrl";
    /** Serbian - Latin RS */
    KnownImageAnalysisSkillLanguage["SrLatn"] = "sr-Latn";
    /** Swedish */
    KnownImageAnalysisSkillLanguage["Sv"] = "sv";
    /** Thai */
    KnownImageAnalysisSkillLanguage["Th"] = "th";
    /** Turkish */
    KnownImageAnalysisSkillLanguage["Tr"] = "tr";
    /** Ukrainian */
    KnownImageAnalysisSkillLanguage["Uk"] = "uk";
    /** Vietnamese */
    KnownImageAnalysisSkillLanguage["Vi"] = "vi";
    /** Chinese Simplified */
    KnownImageAnalysisSkillLanguage["Zh"] = "zh";
    /** Chinese Simplified */
    KnownImageAnalysisSkillLanguage["ZhHans"] = "zh-Hans";
    /** Chinese Traditional */
    KnownImageAnalysisSkillLanguage["ZhHant"] = "zh-Hant";
})(KnownImageAnalysisSkillLanguage || (KnownImageAnalysisSkillLanguage = {}));
/** Known values of {@link VisualFeature} that the service accepts. */
export var KnownVisualFeature;
(function (KnownVisualFeature) {
    /** Visual features recognized as adult persons. */
    KnownVisualFeature["Adult"] = "adult";
    /** Visual features recognized as commercial brands. */
    KnownVisualFeature["Brands"] = "brands";
    /** Categories. */
    KnownVisualFeature["Categories"] = "categories";
    /** Description. */
    KnownVisualFeature["Description"] = "description";
    /** Visual features recognized as people faces. */
    KnownVisualFeature["Faces"] = "faces";
    /** Visual features recognized as objects. */
    KnownVisualFeature["Objects"] = "objects";
    /** Tags. */
    KnownVisualFeature["Tags"] = "tags";
})(KnownVisualFeature || (KnownVisualFeature = {}));
/** Known values of {@link ImageDetail} that the service accepts. */
export var KnownImageDetail;
(function (KnownImageDetail) {
    /** Details recognized as celebrities. */
    KnownImageDetail["Celebrities"] = "celebrities";
    /** Details recognized as landmarks. */
    KnownImageDetail["Landmarks"] = "landmarks";
})(KnownImageDetail || (KnownImageDetail = {}));
/** Known values of {@link EntityCategory} that the service accepts. */
export var KnownEntityCategory;
(function (KnownEntityCategory) {
    /** Entities describing a physical location. */
    KnownEntityCategory["Location"] = "location";
    /** Entities describing an organization. */
    KnownEntityCategory["Organization"] = "organization";
    /** Entities describing a person. */
    KnownEntityCategory["Person"] = "person";
    /** Entities describing a quantity. */
    KnownEntityCategory["Quantity"] = "quantity";
    /** Entities describing a date and time. */
    KnownEntityCategory["Datetime"] = "datetime";
    /** Entities describing a URL. */
    KnownEntityCategory["Url"] = "url";
    /** Entities describing an email address. */
    KnownEntityCategory["Email"] = "email";
})(KnownEntityCategory || (KnownEntityCategory = {}));
/** Known values of {@link EntityRecognitionSkillLanguage} that the service accepts. */
export var KnownEntityRecognitionSkillLanguage;
(function (KnownEntityRecognitionSkillLanguage) {
    /** Arabic */
    KnownEntityRecognitionSkillLanguage["Ar"] = "ar";
    /** Czech */
    KnownEntityRecognitionSkillLanguage["Cs"] = "cs";
    /** Chinese-Simplified */
    KnownEntityRecognitionSkillLanguage["ZhHans"] = "zh-Hans";
    /** Chinese-Traditional */
    KnownEntityRecognitionSkillLanguage["ZhHant"] = "zh-Hant";
    /** Danish */
    KnownEntityRecognitionSkillLanguage["Da"] = "da";
    /** Dutch */
    KnownEntityRecognitionSkillLanguage["Nl"] = "nl";
    /** English */
    KnownEntityRecognitionSkillLanguage["En"] = "en";
    /** Finnish */
    KnownEntityRecognitionSkillLanguage["Fi"] = "fi";
    /** French */
    KnownEntityRecognitionSkillLanguage["Fr"] = "fr";
    /** German */
    KnownEntityRecognitionSkillLanguage["De"] = "de";
    /** Greek */
    KnownEntityRecognitionSkillLanguage["El"] = "el";
    /** Hungarian */
    KnownEntityRecognitionSkillLanguage["Hu"] = "hu";
    /** Italian */
    KnownEntityRecognitionSkillLanguage["It"] = "it";
    /** Japanese */
    KnownEntityRecognitionSkillLanguage["Ja"] = "ja";
    /** Korean */
    KnownEntityRecognitionSkillLanguage["Ko"] = "ko";
    /** Norwegian (Bokmaal) */
    KnownEntityRecognitionSkillLanguage["No"] = "no";
    /** Polish */
    KnownEntityRecognitionSkillLanguage["Pl"] = "pl";
    /** Portuguese (Portugal) */
    KnownEntityRecognitionSkillLanguage["PtPT"] = "pt-PT";
    /** Portuguese (Brazil) */
    KnownEntityRecognitionSkillLanguage["PtBR"] = "pt-BR";
    /** Russian */
    KnownEntityRecognitionSkillLanguage["Ru"] = "ru";
    /** Spanish */
    KnownEntityRecognitionSkillLanguage["Es"] = "es";
    /** Swedish */
    KnownEntityRecognitionSkillLanguage["Sv"] = "sv";
    /** Turkish */
    KnownEntityRecognitionSkillLanguage["Tr"] = "tr";
})(KnownEntityRecognitionSkillLanguage || (KnownEntityRecognitionSkillLanguage = {}));
/** Known values of {@link SentimentSkillLanguage} that the service accepts. */
export var KnownSentimentSkillLanguage;
(function (KnownSentimentSkillLanguage) {
    /** Danish */
    KnownSentimentSkillLanguage["Da"] = "da";
    /** Dutch */
    KnownSentimentSkillLanguage["Nl"] = "nl";
    /** English */
    KnownSentimentSkillLanguage["En"] = "en";
    /** Finnish */
    KnownSentimentSkillLanguage["Fi"] = "fi";
    /** French */
    KnownSentimentSkillLanguage["Fr"] = "fr";
    /** German */
    KnownSentimentSkillLanguage["De"] = "de";
    /** Greek */
    KnownSentimentSkillLanguage["El"] = "el";
    /** Italian */
    KnownSentimentSkillLanguage["It"] = "it";
    /** Norwegian (Bokmaal) */
    KnownSentimentSkillLanguage["No"] = "no";
    /** Polish */
    KnownSentimentSkillLanguage["Pl"] = "pl";
    /** Portuguese (Portugal) */
    KnownSentimentSkillLanguage["PtPT"] = "pt-PT";
    /** Russian */
    KnownSentimentSkillLanguage["Ru"] = "ru";
    /** Spanish */
    KnownSentimentSkillLanguage["Es"] = "es";
    /** Swedish */
    KnownSentimentSkillLanguage["Sv"] = "sv";
    /** Turkish */
    KnownSentimentSkillLanguage["Tr"] = "tr";
})(KnownSentimentSkillLanguage || (KnownSentimentSkillLanguage = {}));
/** Known values of {@link PIIDetectionSkillMaskingMode} that the service accepts. */
export var KnownPIIDetectionSkillMaskingMode;
(function (KnownPIIDetectionSkillMaskingMode) {
    /** No masking occurs and the maskedText output will not be returned. */
    KnownPIIDetectionSkillMaskingMode["None"] = "none";
    /** Replaces the detected entities with the character given in the maskingCharacter parameter. The character will be repeated to the length of the detected entity so that the offsets will correctly correspond to both the input text as well as the output maskedText. */
    KnownPIIDetectionSkillMaskingMode["Replace"] = "replace";
})(KnownPIIDetectionSkillMaskingMode || (KnownPIIDetectionSkillMaskingMode = {}));
/** Known values of {@link SplitSkillLanguage} that the service accepts. */
export var KnownSplitSkillLanguage;
(function (KnownSplitSkillLanguage) {
    /** Amharic */
    KnownSplitSkillLanguage["Am"] = "am";
    /** Bosnian */
    KnownSplitSkillLanguage["Bs"] = "bs";
    /** Czech */
    KnownSplitSkillLanguage["Cs"] = "cs";
    /** Danish */
    KnownSplitSkillLanguage["Da"] = "da";
    /** German */
    KnownSplitSkillLanguage["De"] = "de";
    /** English */
    KnownSplitSkillLanguage["En"] = "en";
    /** Spanish */
    KnownSplitSkillLanguage["Es"] = "es";
    /** Estonian */
    KnownSplitSkillLanguage["Et"] = "et";
    /** Finnish */
    KnownSplitSkillLanguage["Fi"] = "fi";
    /** French */
    KnownSplitSkillLanguage["Fr"] = "fr";
    /** Hebrew */
    KnownSplitSkillLanguage["He"] = "he";
    /** Hindi */
    KnownSplitSkillLanguage["Hi"] = "hi";
    /** Croatian */
    KnownSplitSkillLanguage["Hr"] = "hr";
    /** Hungarian */
    KnownSplitSkillLanguage["Hu"] = "hu";
    /** Indonesian */
    KnownSplitSkillLanguage["Id"] = "id";
    /** Icelandic */
    KnownSplitSkillLanguage["Is"] = "is";
    /** Italian */
    KnownSplitSkillLanguage["It"] = "it";
    /** Japanese */
    KnownSplitSkillLanguage["Ja"] = "ja";
    /** Korean */
    KnownSplitSkillLanguage["Ko"] = "ko";
    /** Latvian */
    KnownSplitSkillLanguage["Lv"] = "lv";
    /** Norwegian */
    KnownSplitSkillLanguage["Nb"] = "nb";
    /** Dutch */
    KnownSplitSkillLanguage["Nl"] = "nl";
    /** Polish */
    KnownSplitSkillLanguage["Pl"] = "pl";
    /** Portuguese (Portugal) */
    KnownSplitSkillLanguage["Pt"] = "pt";
    /** Portuguese (Brazil) */
    KnownSplitSkillLanguage["PtBr"] = "pt-br";
    /** Russian */
    KnownSplitSkillLanguage["Ru"] = "ru";
    /** Slovak */
    KnownSplitSkillLanguage["Sk"] = "sk";
    /** Slovenian */
    KnownSplitSkillLanguage["Sl"] = "sl";
    /** Serbian */
    KnownSplitSkillLanguage["Sr"] = "sr";
    /** Swedish */
    KnownSplitSkillLanguage["Sv"] = "sv";
    /** Turkish */
    KnownSplitSkillLanguage["Tr"] = "tr";
    /** Urdu */
    KnownSplitSkillLanguage["Ur"] = "ur";
    /** Chinese (Simplified) */
    KnownSplitSkillLanguage["Zh"] = "zh";
})(KnownSplitSkillLanguage || (KnownSplitSkillLanguage = {}));
/** Known values of {@link TextSplitMode} that the service accepts. */
export var KnownTextSplitMode;
(function (KnownTextSplitMode) {
    /** Split the text into individual pages. */
    KnownTextSplitMode["Pages"] = "pages";
    /** Split the text into individual sentences. */
    KnownTextSplitMode["Sentences"] = "sentences";
})(KnownTextSplitMode || (KnownTextSplitMode = {}));
/** Known values of {@link SplitSkillUnit} that the service accepts. */
export var KnownSplitSkillUnit;
(function (KnownSplitSkillUnit) {
    /** The length will be measured by character. */
    KnownSplitSkillUnit["Characters"] = "characters";
    /** The length will be measured by an AzureOpenAI tokenizer from the tiktoken library. */
    KnownSplitSkillUnit["AzureOpenAITokens"] = "azureOpenAITokens";
})(KnownSplitSkillUnit || (KnownSplitSkillUnit = {}));
/** Known values of {@link SplitSkillEncoderModelName} that the service accepts. */
export var KnownSplitSkillEncoderModelName;
(function (KnownSplitSkillEncoderModelName) {
    /** Refers to a base model trained with a 50,000 token vocabulary, often used in general natural language processing tasks. */
    KnownSplitSkillEncoderModelName["R50KBase"] = "r50k_base";
    /** A base model with a 50,000 token vocabulary, optimized for prompt-based tasks. */
    KnownSplitSkillEncoderModelName["P50KBase"] = "p50k_base";
    /** Similar to p50k_base but fine-tuned for editing or rephrasing tasks with a 50,000 token vocabulary. */
    KnownSplitSkillEncoderModelName["P50KEdit"] = "p50k_edit";
    /** A base model with a 100,000 token vocabulary. */
    KnownSplitSkillEncoderModelName["CL100KBase"] = "cl100k_base";
})(KnownSplitSkillEncoderModelName || (KnownSplitSkillEncoderModelName = {}));
/** Known values of {@link CustomEntityLookupSkillLanguage} that the service accepts. */
export var KnownCustomEntityLookupSkillLanguage;
(function (KnownCustomEntityLookupSkillLanguage) {
    /** Danish */
    KnownCustomEntityLookupSkillLanguage["Da"] = "da";
    /** German */
    KnownCustomEntityLookupSkillLanguage["De"] = "de";
    /** English */
    KnownCustomEntityLookupSkillLanguage["En"] = "en";
    /** Spanish */
    KnownCustomEntityLookupSkillLanguage["Es"] = "es";
    /** Finnish */
    KnownCustomEntityLookupSkillLanguage["Fi"] = "fi";
    /** French */
    KnownCustomEntityLookupSkillLanguage["Fr"] = "fr";
    /** Italian */
    KnownCustomEntityLookupSkillLanguage["It"] = "it";
    /** Korean */
    KnownCustomEntityLookupSkillLanguage["Ko"] = "ko";
    /** Portuguese */
    KnownCustomEntityLookupSkillLanguage["Pt"] = "pt";
})(KnownCustomEntityLookupSkillLanguage || (KnownCustomEntityLookupSkillLanguage = {}));
/** Known values of {@link TextTranslationSkillLanguage} that the service accepts. */
export var KnownTextTranslationSkillLanguage;
(function (KnownTextTranslationSkillLanguage) {
    /** Afrikaans */
    KnownTextTranslationSkillLanguage["Af"] = "af";
    /** Arabic */
    KnownTextTranslationSkillLanguage["Ar"] = "ar";
    /** Bangla */
    KnownTextTranslationSkillLanguage["Bn"] = "bn";
    /** Bosnian (Latin) */
    KnownTextTranslationSkillLanguage["Bs"] = "bs";
    /** Bulgarian */
    KnownTextTranslationSkillLanguage["Bg"] = "bg";
    /** Cantonese (Traditional) */
    KnownTextTranslationSkillLanguage["Yue"] = "yue";
    /** Catalan */
    KnownTextTranslationSkillLanguage["Ca"] = "ca";
    /** Chinese Simplified */
    KnownTextTranslationSkillLanguage["ZhHans"] = "zh-Hans";
    /** Chinese Traditional */
    KnownTextTranslationSkillLanguage["ZhHant"] = "zh-Hant";
    /** Croatian */
    KnownTextTranslationSkillLanguage["Hr"] = "hr";
    /** Czech */
    KnownTextTranslationSkillLanguage["Cs"] = "cs";
    /** Danish */
    KnownTextTranslationSkillLanguage["Da"] = "da";
    /** Dutch */
    KnownTextTranslationSkillLanguage["Nl"] = "nl";
    /** English */
    KnownTextTranslationSkillLanguage["En"] = "en";
    /** Estonian */
    KnownTextTranslationSkillLanguage["Et"] = "et";
    /** Fijian */
    KnownTextTranslationSkillLanguage["Fj"] = "fj";
    /** Filipino */
    KnownTextTranslationSkillLanguage["Fil"] = "fil";
    /** Finnish */
    KnownTextTranslationSkillLanguage["Fi"] = "fi";
    /** French */
    KnownTextTranslationSkillLanguage["Fr"] = "fr";
    /** German */
    KnownTextTranslationSkillLanguage["De"] = "de";
    /** Greek */
    KnownTextTranslationSkillLanguage["El"] = "el";
    /** Haitian Creole */
    KnownTextTranslationSkillLanguage["Ht"] = "ht";
    /** Hebrew */
    KnownTextTranslationSkillLanguage["He"] = "he";
    /** Hindi */
    KnownTextTranslationSkillLanguage["Hi"] = "hi";
    /** Hmong Daw */
    KnownTextTranslationSkillLanguage["Mww"] = "mww";
    /** Hungarian */
    KnownTextTranslationSkillLanguage["Hu"] = "hu";
    /** Icelandic */
    KnownTextTranslationSkillLanguage["Is"] = "is";
    /** Indonesian */
    KnownTextTranslationSkillLanguage["Id"] = "id";
    /** Italian */
    KnownTextTranslationSkillLanguage["It"] = "it";
    /** Japanese */
    KnownTextTranslationSkillLanguage["Ja"] = "ja";
    /** Kiswahili */
    KnownTextTranslationSkillLanguage["Sw"] = "sw";
    /** Klingon */
    KnownTextTranslationSkillLanguage["Tlh"] = "tlh";
    /** Klingon (Latin script) */
    KnownTextTranslationSkillLanguage["TlhLatn"] = "tlh-Latn";
    /** Klingon (Klingon script) */
    KnownTextTranslationSkillLanguage["TlhPiqd"] = "tlh-Piqd";
    /** Korean */
    KnownTextTranslationSkillLanguage["Ko"] = "ko";
    /** Latvian */
    KnownTextTranslationSkillLanguage["Lv"] = "lv";
    /** Lithuanian */
    KnownTextTranslationSkillLanguage["Lt"] = "lt";
    /** Malagasy */
    KnownTextTranslationSkillLanguage["Mg"] = "mg";
    /** Malay */
    KnownTextTranslationSkillLanguage["Ms"] = "ms";
    /** Maltese */
    KnownTextTranslationSkillLanguage["Mt"] = "mt";
    /** Norwegian */
    KnownTextTranslationSkillLanguage["Nb"] = "nb";
    /** Persian */
    KnownTextTranslationSkillLanguage["Fa"] = "fa";
    /** Polish */
    KnownTextTranslationSkillLanguage["Pl"] = "pl";
    /** Portuguese */
    KnownTextTranslationSkillLanguage["Pt"] = "pt";
    /** Portuguese (Brazil) */
    KnownTextTranslationSkillLanguage["PtBr"] = "pt-br";
    /** Portuguese (Portugal) */
    KnownTextTranslationSkillLanguage["PtPT"] = "pt-PT";
    /** Queretaro Otomi */
    KnownTextTranslationSkillLanguage["Otq"] = "otq";
    /** Romanian */
    KnownTextTranslationSkillLanguage["Ro"] = "ro";
    /** Russian */
    KnownTextTranslationSkillLanguage["Ru"] = "ru";
    /** Samoan */
    KnownTextTranslationSkillLanguage["Sm"] = "sm";
    /** Serbian (Cyrillic) */
    KnownTextTranslationSkillLanguage["SrCyrl"] = "sr-Cyrl";
    /** Serbian (Latin) */
    KnownTextTranslationSkillLanguage["SrLatn"] = "sr-Latn";
    /** Slovak */
    KnownTextTranslationSkillLanguage["Sk"] = "sk";
    /** Slovenian */
    KnownTextTranslationSkillLanguage["Sl"] = "sl";
    /** Spanish */
    KnownTextTranslationSkillLanguage["Es"] = "es";
    /** Swedish */
    KnownTextTranslationSkillLanguage["Sv"] = "sv";
    /** Tahitian */
    KnownTextTranslationSkillLanguage["Ty"] = "ty";
    /** Tamil */
    KnownTextTranslationSkillLanguage["Ta"] = "ta";
    /** Telugu */
    KnownTextTranslationSkillLanguage["Te"] = "te";
    /** Thai */
    KnownTextTranslationSkillLanguage["Th"] = "th";
    /** Tongan */
    KnownTextTranslationSkillLanguage["To"] = "to";
    /** Turkish */
    KnownTextTranslationSkillLanguage["Tr"] = "tr";
    /** Ukrainian */
    KnownTextTranslationSkillLanguage["Uk"] = "uk";
    /** Urdu */
    KnownTextTranslationSkillLanguage["Ur"] = "ur";
    /** Vietnamese */
    KnownTextTranslationSkillLanguage["Vi"] = "vi";
    /** Welsh */
    KnownTextTranslationSkillLanguage["Cy"] = "cy";
    /** Yucatec Maya */
    KnownTextTranslationSkillLanguage["Yua"] = "yua";
    /** Irish */
    KnownTextTranslationSkillLanguage["Ga"] = "ga";
    /** Kannada */
    KnownTextTranslationSkillLanguage["Kn"] = "kn";
    /** Maori */
    KnownTextTranslationSkillLanguage["Mi"] = "mi";
    /** Malayalam */
    KnownTextTranslationSkillLanguage["Ml"] = "ml";
    /** Punjabi */
    KnownTextTranslationSkillLanguage["Pa"] = "pa";
})(KnownTextTranslationSkillLanguage || (KnownTextTranslationSkillLanguage = {}));
/** Known values of {@link DocumentIntelligenceLayoutSkillOutputMode} that the service accepts. */
export var KnownDocumentIntelligenceLayoutSkillOutputMode;
(function (KnownDocumentIntelligenceLayoutSkillOutputMode) {
    /** Specify the deepest markdown header section to parse. */
    KnownDocumentIntelligenceLayoutSkillOutputMode["OneToMany"] = "oneToMany";
})(KnownDocumentIntelligenceLayoutSkillOutputMode || (KnownDocumentIntelligenceLayoutSkillOutputMode = {}));
/** Known values of {@link DocumentIntelligenceLayoutSkillMarkdownHeaderDepth} that the service accepts. */
export var KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth;
(function (KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth) {
    /** Header level 1. */
    KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth["H1"] = "h1";
    /** Header level 2. */
    KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth["H2"] = "h2";
    /** Header level 3. */
    KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth["H3"] = "h3";
    /** Header level 4. */
    KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth["H4"] = "h4";
    /** Header level 5. */
    KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth["H5"] = "h5";
    /** Header level 6. */
    KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth["H6"] = "h6";
})(KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth || (KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth = {}));
/** Known values of {@link LexicalTokenizerName} that the service accepts. */
export var KnownLexicalTokenizerName;
(function (KnownLexicalTokenizerName) {
    /** Grammar-based tokenizer that is suitable for processing most European-language documents. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/standard\/ClassicTokenizer.html */
    KnownLexicalTokenizerName["Classic"] = "classic";
    /** Tokenizes the input from an edge into n-grams of the given size(s). See https:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ngram\/EdgeNGramTokenizer.html */
    KnownLexicalTokenizerName["EdgeNGram"] = "edgeNGram";
    /** Emits the entire input as a single token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/KeywordTokenizer.html */
    KnownLexicalTokenizerName["Keyword"] = "keyword_v2";
    /** Divides text at non-letters. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/LetterTokenizer.html */
    KnownLexicalTokenizerName["Letter"] = "letter";
    /** Divides text at non-letters and converts them to lower case. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/LowerCaseTokenizer.html */
    KnownLexicalTokenizerName["Lowercase"] = "lowercase";
    /** Divides text using language-specific rules. */
    KnownLexicalTokenizerName["MicrosoftLanguageTokenizer"] = "microsoft_language_tokenizer";
    /** Divides text using language-specific rules and reduces words to their base forms. */
    KnownLexicalTokenizerName["MicrosoftLanguageStemmingTokenizer"] = "microsoft_language_stemming_tokenizer";
    /** Tokenizes the input into n-grams of the given size(s). See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/ngram\/NGramTokenizer.html */
    KnownLexicalTokenizerName["NGram"] = "nGram";
    /** Tokenizer for path-like hierarchies. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/path\/PathHierarchyTokenizer.html */
    KnownLexicalTokenizerName["PathHierarchy"] = "path_hierarchy_v2";
    /** Tokenizer that uses regex pattern matching to construct distinct tokens. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/pattern\/PatternTokenizer.html */
    KnownLexicalTokenizerName["Pattern"] = "pattern";
    /** Standard Lucene analyzer; Composed of the standard tokenizer, lowercase filter and stop filter. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/standard\/StandardTokenizer.html */
    KnownLexicalTokenizerName["Standard"] = "standard_v2";
    /** Tokenizes urls and emails as one token. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/standard\/UAX29URLEmailTokenizer.html */
    KnownLexicalTokenizerName["UaxUrlEmail"] = "uax_url_email";
    /** Divides text at whitespace. See http:\//lucene.apache.org\/core\/4_10_3\/analyzers-common\/org\/apache\/lucene\/analysis\/core\/WhitespaceTokenizer.html */
    KnownLexicalTokenizerName["Whitespace"] = "whitespace";
})(KnownLexicalTokenizerName || (KnownLexicalTokenizerName = {}));
/** Known values of {@link RegexFlags} that the service accepts. */
export var KnownRegexFlags;
(function (KnownRegexFlags) {
    /** Enables canonical equivalence. */
    KnownRegexFlags["CanonEq"] = "CANON_EQ";
    /** Enables case-insensitive matching. */
    KnownRegexFlags["CaseInsensitive"] = "CASE_INSENSITIVE";
    /** Permits whitespace and comments in the pattern. */
    KnownRegexFlags["Comments"] = "COMMENTS";
    /** Enables dotall mode. */
    KnownRegexFlags["DotAll"] = "DOTALL";
    /** Enables literal parsing of the pattern. */
    KnownRegexFlags["Literal"] = "LITERAL";
    /** Enables multiline mode. */
    KnownRegexFlags["Multiline"] = "MULTILINE";
    /** Enables Unicode-aware case folding. */
    KnownRegexFlags["UnicodeCase"] = "UNICODE_CASE";
    /** Enables Unix lines mode. */
    KnownRegexFlags["UnixLines"] = "UNIX_LINES";
})(KnownRegexFlags || (KnownRegexFlags = {}));
//# sourceMappingURL=index.js.map