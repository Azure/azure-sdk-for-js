{"version":3,"file":"searchIndexingBufferedSender.js","sourceRoot":"","sources":["../../src/searchIndexingBufferedSender.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;;;AAIlC,gDAAyC;AACzC,sEAAuC;AAEvC,qEAA+D;AAW/D,uDAA8D;AAC9D,6CAA0C;AAmB1C;;GAEG;AACU,QAAA,kBAAkB,GAAW,GAAG,CAAC;AAC9C;;GAEG;AACU,QAAA,oBAAoB,GAAW,KAAK,CAAC;AAClD;;GAEG;AACU,QAAA,mBAAmB,GAAW,CAAC,CAAC;AAC7C;;GAEG;AACH,MAAM,uBAAuB,GAAW,KAAK,CAAC;AAE9C;;;GAGG;AACH,MAAa,4BAA4B;IA8CvC;;;;;;OAMG;IACH,YACE,MAAoC,EACpC,oBAAkD,EAClD,UAA+C,EAAE;;QAnBnD;;WAEG;QACc,YAAO,GAAG,IAAI,qBAAY,EAAE,CAAC;QAkB5C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;QACjD,mCAAmC;QACnC,IAAI,CAAC,SAAS,GAAG,MAAA,OAAO,CAAC,SAAS,mCAAI,IAAI,CAAC;QAC3C,IAAI,CAAC,uBAAuB,GAAG,MAAA,OAAO,CAAC,uBAAuB,mCAAI,0BAAkB,CAAC;QACrF,IAAI,CAAC,eAAe,GAAG,MAAA,OAAO,CAAC,eAAe,mCAAI,4BAAoB,CAAC;QACvE,0CAA0C;QAC1C,IAAI,CAAC,mBAAmB,GAAG,MAAA,OAAO,CAAC,mBAAmB,mCAAI,4BAAoB,CAAC;QAC/E,IAAI,CAAC,mBAAmB,GAAG,MAAA,OAAO,CAAC,mBAAmB,mCAAI,2BAAmB,CAAC;QAC9E,IAAI,CAAC,sBAAsB,GAAG,MAAA,OAAO,CAAC,sBAAsB,mCAAI,uBAAuB,CAAC;QAExF,IAAI,CAAC,WAAW,GAAG,IAAI,4CAAmB,EAAU,CAAC;QACrD,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnB,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;YACvE,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,KAAK,EAAE,CAAC;YAClB,IAAI,CAAC,YAAY,GAAG,GAAG,EAAE;gBACvB,aAAa,CAAC,QAAQ,CAAC,CAAC;YAC1B,CAAC,CAAC;QACJ,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,eAAe,CAC1B,SAAmB,EACnB,UAA8D,EAAE;QAEhE,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,IAAA,uBAAU,EACzC,8CAA8C,EAC9C,OAAO,CACR,CAAC;QACF,IAAI,CAAC;YACH,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACnC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE;gBAC9B,MAAM,EAAE,QAAQ;gBAChB,SAAS;aACV,CAAC,CAAC;YACH,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;QACnD,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC;gBACb,MAAM,EAAE,OAAO;gBACf,KAAK,EAAE,CAAC,CAAC,OAAO;aACjB,CAAC,CAAC;YACH,MAAM,CAAC,CAAC;QACV,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,cAAc,CACzB,SAAmB,EACnB,UAA6D,EAAE;QAE/D,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,IAAA,uBAAU,EACzC,6CAA6C,EAC7C,OAAO,CACR,CAAC;QACF,IAAI,CAAC;YACH,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAClC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE;gBAC9B,MAAM,EAAE,OAAO;gBACf,SAAS;aACV,CAAC,CAAC;YACH,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;QACnD,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC;gBACb,MAAM,EAAE,OAAO;gBACf,KAAK,EAAE,CAAC,CAAC,OAAO;aACjB,CAAC,CAAC;YACH,MAAM,CAAC,CAAC;QACV,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,sBAAsB,CACjC,SAAmB,EACnB,UAAqE,EAAE;QAEvE,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,IAAA,uBAAU,EACzC,qDAAqD,EACrD,OAAO,CACR,CAAC;QACF,IAAI,CAAC;YACH,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;YAC1C,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE;gBAC9B,MAAM,EAAE,eAAe;gBACvB,SAAS;aACV,CAAC,CAAC;YACH,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;QACnD,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC;gBACb,MAAM,EAAE,OAAO;gBACf,KAAK,EAAE,CAAC,CAAC,OAAO;aACjB,CAAC,CAAC;YACH,MAAM,CAAC,CAAC;QACV,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,eAAe,CAC1B,SAAmB,EACnB,UAA8D,EAAE;QAEhE,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,IAAA,uBAAU,EACzC,8CAA8C,EAC9C,OAAO,CACR,CAAC;QACF,IAAI,CAAC;YACH,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACnC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,YAAY,EAAE;gBAC9B,MAAM,EAAE,QAAQ;gBAChB,SAAS;aACV,CAAC,CAAC;YACH,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;QACnD,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC;gBACb,MAAM,EAAE,OAAO;gBACf,KAAK,EAAE,CAAC,CAAC,OAAO;aACjB,CAAC,CAAC;YACH,MAAM,CAAC,CAAC;QACV,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAED;;;;OAIG;IACI,KAAK,CAAC,KAAK,CAChB,UAA6D,EAAE;QAE/D,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,GAAG,IAAA,uBAAU,EAAC,oCAAoC,EAAE,OAAO,CAAC,CAAC;QAC3F,IAAI,CAAC;YACH,IAAI,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACxC,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;YAClD,CAAC;QACH,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,SAAS,CAAC;gBACb,MAAM,EAAE,OAAO;gBACf,KAAK,EAAE,CAAC,CAAC,OAAO;aACjB,CAAC,CAAC;YACH,MAAM,CAAC,CAAC;QACV,CAAC;gBAAS,CAAC;YACT,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;IACH,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,OAAO;QAClB,IAAI,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACxC,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QACjC,CAAC;QACD,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACtB,IAAI,CAAC,YAAY,EAAE,CAAC;QACtB,CAAC;IACH,CAAC;IAiCM,EAAE,CACP,KAA+F,EAC/F,QAA0B;QAE1B,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACnC,CAAC;IAoCM,GAAG,CACR,KAA6E,EAC7E,QAA0B;QAE1B,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAC/C,CAAC;IAEO,YAAY;QAClB,OAAO,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,uBAAuB,CAAC;IACzE,CAAC;IAEO,KAAK,CAAC,aAAa,CAAC,KAAc,EAAE,UAA4B,EAAE;QACxE,IAAI,KAAK,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC,EAAE,CAAC;YACrD,WAAW;YACX,MAAM,OAAO,GAAmC,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC;YACzE,IAAI,CAAC,WAAW,GAAG,IAAI,4CAAmB,EAAU,CAAC;YACrD,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC1B,MAAM,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAC;gBACtE,MAAM,EAAE,aAAa,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC;gBACxE,OAAO,CAAC,OAAO,CAAC,GAAG,WAAW,CAAC,CAAC;gBAChC,MAAM,IAAI,CAAC,eAAe,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;YACrD,CAAC;QACH,CAAC;IACH,CAAC;IAEO,YAAY,CAAC,KAAqC;QAIxD,MAAM,OAAO,GAAgB,IAAI,GAAG,EAAU,CAAC;QAC/C,MAAM,WAAW,GAAmC,EAAE,CAAC;QACvD,MAAM,MAAM,GAAmC,EAAE,CAAC;QAElD,KAAK,MAAM,QAAQ,IAAI,KAAK,EAAE,CAAC;YAC7B,MAAM,GAAG,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAA6B,CAAC,CAAC;YACrE,IAAI,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;gBACrB,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACxB,CAAC;iBAAM,CAAC;gBACN,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACjB,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC7B,CAAC;QACH,CAAC;QACD,OAAO,EAAE,aAAa,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,EAAE,CAAC;IAC7D,CAAC;IAEO,KAAK,CAAC,eAAe,CAC3B,aAA6C,EAC7C,OAAyB,EACzB,eAAuB,CAAC;QAExB,IAAI,CAAC;YACH,KAAK,MAAM,MAAM,IAAI,aAAa,EAAE,CAAC;gBACnC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,oBAAoB,EAAE,MAAM,CAAC,CAAC;YAClD,CAAC;YACD,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,CAC7C,IAAI,4CAAmB,CAAS,aAAa,CAAC,EAC9C,OAAO,CACR,CAAC;YACF,sBAAsB;YACtB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;QAC9C,CAAC;QAAC,OAAO,CAAM,EAAE,CAAC;YAChB,IAAI,CAAC,CAAC,UAAU,IAAI,CAAC,CAAC,UAAU,KAAK,GAAG,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACrE,+BAA+B;gBAC/B,MAAM,iBAAiB,GAAG;oBACxB,aAAa,CAAC,KAAK,CAAC,CAAC,EAAE,aAAa,CAAC,MAAM,GAAG,CAAC,CAAC;oBAChD,aAAa,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,aAAa,CAAC,MAAM,CAAC;iBACpE,CAAC;gBACF,IAAI,CAAC,uBAAuB,GAAG,iBAAiB,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,mDAAmD;gBAC/G,KAAK,MAAM,OAAO,IAAI,iBAAiB,EAAE,CAAC;oBACxC,MAAM,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;gBAC/C,CAAC;YACH,CAAC;iBAAM,IAAI,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,IAAI,YAAY,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAChF,6CAA6C;gBAC7C,MAAM,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC;gBAC9E,yCAAyC;gBACzC,MAAM,uBAAuB,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,sBAAsB,EAAE,gBAAgB,CAAC,CAAC;gBACxF,gFAAgF;gBAChF,mEAAmE;gBACnE,MAAM,eAAe,GACnB,uBAAuB,GAAG,CAAC,GAAG,IAAA,2CAAyB,EAAC,CAAC,EAAE,uBAAuB,GAAG,CAAC,CAAC,CAAC;gBAC1F,MAAM,IAAA,iBAAK,EAAC,eAAe,CAAC,CAAC;gBAC7B,MAAM,IAAI,CAAC,eAAe,CAAC,aAAa,EAAE,OAAO,EAAE,YAAY,GAAG,CAAC,CAAC,CAAC;YACvE,CAAC;iBAAM,CAAC;gBACN,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;gBACpC,MAAM,CAAC,CAAC;YACV,CAAC;QACH,CAAC;IACH,CAAC;IAEO,gBAAgB,CAAC,CAAM;QAC7B,OAAO,CAAC,CAAC,UAAU,IAAI,CAAC,CAAC,CAAC,UAAU,KAAK,GAAG,IAAI,CAAC,CAAC,UAAU,KAAK,GAAG,IAAI,CAAC,CAAC,UAAU,KAAK,GAAG,CAAC,CAAC;IAChG,CAAC;CACF;AAvZD,oEAuZC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { OperationOptions } from \"@azure/core-client\";\nimport type { RestError } from \"@azure/core-rest-pipeline\";\nimport { delay } from \"@azure/core-util\";\nimport EventEmitter from \"node:events\";\nimport type { IndexDocumentsResult } from \"./generated/data/models/index.js\";\nimport { IndexDocumentsBatch } from \"./indexDocumentsBatch.js\";\nimport type {\n  IndexDocumentsAction,\n  IndexDocumentsOptions,\n  SearchIndexingBufferedSenderDeleteDocumentsOptions,\n  SearchIndexingBufferedSenderFlushDocumentsOptions,\n  SearchIndexingBufferedSenderMergeDocumentsOptions,\n  SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions,\n  SearchIndexingBufferedSenderOptions,\n  SearchIndexingBufferedSenderUploadDocumentsOptions,\n} from \"./indexModels.js\";\nimport { getRandomIntegerInclusive } from \"./serviceUtils.js\";\nimport { createSpan } from \"./tracing.js\";\n\n/**\n * Index Documents Client\n */\nexport interface IndexDocumentsClient<TModel extends object> {\n  /**\n   * Perform a set of index modifications (upload, merge, mergeOrUpload, delete)\n   * for the given set of documents.\n   *\n   * @param batch - An array of actions to perform on the index.\n   * @param options - Additional options.\n   */\n  indexDocuments(\n    batch: IndexDocumentsBatch<TModel>,\n    options: IndexDocumentsOptions,\n  ): Promise<IndexDocumentsResult>;\n}\n\n/**\n * Default Batch Size\n */\nexport const DEFAULT_BATCH_SIZE: number = 512;\n/**\n * Default window flush interval\n */\nexport const DEFAULT_FLUSH_WINDOW: number = 60000;\n/**\n * Default number of times to retry.\n */\nexport const DEFAULT_RETRY_COUNT: number = 3;\n/**\n * Default Max Delay between retries.\n */\nconst DEFAULT_MAX_RETRY_DELAY: number = 60000;\n\n/**\n * Class used to perform buffered operations against a search index,\n * including adding, updating, and removing them.\n */\nexport class SearchIndexingBufferedSender<TModel extends object> {\n  /**\n   * Search Client used to call the underlying IndexBatch operations.\n   */\n  private client: IndexDocumentsClient<TModel>;\n  /**\n   * Indicates if autoFlush is enabled.\n   */\n  private autoFlush: boolean;\n  /**\n   * Interval between flushes (in milliseconds).\n   */\n  private flushWindowInMs: number;\n  /**\n   * Delay between retries\n   */\n  private throttlingDelayInMs: number;\n  /**\n   * Maximum number of Retries\n   */\n  private maxRetriesPerAction: number;\n  /**\n   * Max Delay between retries\n   */\n  private maxThrottlingDelayInMs: number;\n  /**\n   * Size of the batch.\n   */\n  private initialBatchActionCount: number;\n  /**\n   * Batch object used to complete the service call.\n   */\n  private batchObject: IndexDocumentsBatch<TModel>;\n  /**\n   * Clean up for the timer\n   */\n  private cleanupTimer?: () => void;\n  /**\n   * Event emitter/publisher used in the Buffered Sender\n   */\n  private readonly emitter = new EventEmitter();\n  /**\n   * Method to retrieve the document key\n   */\n  private documentKeyRetriever: (document: TModel) => string;\n\n  /**\n   * Creates a new instance of SearchIndexingBufferedSender.\n   *\n   * @param client - Search Client used to call the underlying IndexBatch operations.\n   * @param options - Options to modify auto flush.\n   *\n   */\n  constructor(\n    client: IndexDocumentsClient<TModel>,\n    documentKeyRetriever: (document: TModel) => string,\n    options: SearchIndexingBufferedSenderOptions = {},\n  ) {\n    this.client = client;\n    this.documentKeyRetriever = documentKeyRetriever;\n    // General Configuration properties\n    this.autoFlush = options.autoFlush ?? true;\n    this.initialBatchActionCount = options.initialBatchActionCount ?? DEFAULT_BATCH_SIZE;\n    this.flushWindowInMs = options.flushWindowInMs ?? DEFAULT_FLUSH_WINDOW;\n    // Retry specific configuration properties\n    this.throttlingDelayInMs = options.throttlingDelayInMs ?? DEFAULT_FLUSH_WINDOW;\n    this.maxRetriesPerAction = options.maxRetriesPerAction ?? DEFAULT_RETRY_COUNT;\n    this.maxThrottlingDelayInMs = options.maxThrottlingDelayInMs ?? DEFAULT_MAX_RETRY_DELAY;\n\n    this.batchObject = new IndexDocumentsBatch<TModel>();\n    if (this.autoFlush) {\n      const interval = setInterval(() => this.flush(), this.flushWindowInMs);\n      interval?.unref();\n      this.cleanupTimer = () => {\n        clearInterval(interval);\n      };\n    }\n  }\n\n  /**\n   * Uploads the documents/Adds the documents to the upload queue.\n   *\n   * @param documents - Documents to be uploaded.\n   * @param options - Upload options.\n   */\n  public async uploadDocuments(\n    documents: TModel[],\n    options: SearchIndexingBufferedSenderUploadDocumentsOptions = {},\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-uploadDocuments\",\n      options,\n    );\n    try {\n      this.batchObject.upload(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"upload\",\n        documents,\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Merges the documents/Adds the documents to the merge queue.\n   *\n   * @param documents - Documents to be merged.\n   * @param options - Upload options.\n   */\n  public async mergeDocuments(\n    documents: TModel[],\n    options: SearchIndexingBufferedSenderMergeDocumentsOptions = {},\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-mergeDocuments\",\n      options,\n    );\n    try {\n      this.batchObject.merge(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"merge\",\n        documents,\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Merges/Uploads the documents/Adds the documents to the merge/upload queue.\n   *\n   * @param documents - Documents to be merged/uploaded.\n   * @param options - Upload options.\n   */\n  public async mergeOrUploadDocuments(\n    documents: TModel[],\n    options: SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions = {},\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-mergeOrUploadDocuments\",\n      options,\n    );\n    try {\n      this.batchObject.mergeOrUpload(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"mergeOrUpload\",\n        documents,\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes the documents/Adds the documents to the delete queue.\n   *\n   * @param documents - Documents to be deleted.\n   * @param options - Upload options.\n   */\n  public async deleteDocuments(\n    documents: TModel[],\n    options: SearchIndexingBufferedSenderDeleteDocumentsOptions = {},\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\n      \"SearchIndexingBufferedSender-deleteDocuments\",\n      options,\n    );\n    try {\n      this.batchObject.delete(documents);\n      this.emitter.emit(\"batchAdded\", {\n        action: \"delete\",\n        documents,\n      });\n      return this.internalFlush(false, updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Flushes the queue manually.\n   *\n   * @param options - Flush options.\n   */\n  public async flush(\n    options: SearchIndexingBufferedSenderFlushDocumentsOptions = {},\n  ): Promise<void> {\n    const { span, updatedOptions } = createSpan(\"SearchIndexingBufferedSender-flush\", options);\n    try {\n      if (this.batchObject.actions.length > 0) {\n        return this.internalFlush(true, updatedOptions);\n      }\n    } catch (e: any) {\n      span.setStatus({\n        status: \"error\",\n        error: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * If using autoFlush: true, call this to cleanup the autoflush timer.\n   */\n  public async dispose(): Promise<void> {\n    if (this.batchObject.actions.length > 0) {\n      await this.internalFlush(true);\n    }\n    if (this.cleanupTimer) {\n      this.cleanupTimer();\n    }\n  }\n\n  /**\n   * Attach Batch Added Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(\n    event: \"batchAdded\",\n    listener: (e: { action: string; documents: TModel[] }) => void,\n  ): void;\n  /**\n   * Attach Batch Sent Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"beforeDocumentSent\", listener: (e: IndexDocumentsAction<TModel>) => void): void;\n  /**\n   * Attach Batch Succeeded Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"batchSucceeded\", listener: (e: IndexDocumentsResult) => void): void;\n  /**\n   * Attach Batch Failed Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public on(event: \"batchFailed\", listener: (e: RestError) => void): void;\n  public on(\n    event: \"batchAdded\" | \"beforeDocumentSent\" | \"batchSucceeded\" | \"batchFailed\" | \"batchResizing\",\n    listener: (e: any) => void,\n  ): void {\n    this.emitter.on(event, listener);\n  }\n\n  /**\n   * Detach Batch Added Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(\n    event: \"batchAdded\",\n    listener: (e: { action: string; documents: TModel[] }) => void,\n  ): void;\n  /**\n   * Detach Batch Sent Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(\n    event: \"beforeDocumentSent\",\n    listener: (e: IndexDocumentsAction<TModel>) => void,\n  ): void;\n  /**\n   * Detach Batch Succeeded Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(event: \"batchSucceeded\", listener: (e: IndexDocumentsResult) => void): void;\n  /**\n   * Detach Batch Failed Event\n   *\n   * @param event - Event to be emitted\n   * @param listener - Event Listener\n   */\n  public off(event: \"batchFailed\", listener: (e: RestError) => void): void;\n  public off(\n    event: \"batchAdded\" | \"beforeDocumentSent\" | \"batchSucceeded\" | \"batchFailed\",\n    listener: (e: any) => void,\n  ): void {\n    this.emitter.removeListener(event, listener);\n  }\n\n  private isBatchReady(): boolean {\n    return this.batchObject.actions.length >= this.initialBatchActionCount;\n  }\n\n  private async internalFlush(force: boolean, options: OperationOptions = {}): Promise<void> {\n    if (force || (this.autoFlush && this.isBatchReady())) {\n      // Split it\n      const actions: IndexDocumentsAction<TModel>[] = this.batchObject.actions;\n      this.batchObject = new IndexDocumentsBatch<TModel>();\n      while (actions.length > 0) {\n        const actionsToSend = actions.splice(0, this.initialBatchActionCount);\n        const { batchToSubmit, submitLater } = this.pruneActions(actionsToSend);\n        actions.unshift(...submitLater);\n        await this.submitDocuments(batchToSubmit, options);\n      }\n    }\n  }\n\n  private pruneActions(batch: IndexDocumentsAction<TModel>[]): {\n    batchToSubmit: IndexDocumentsAction<TModel>[];\n    submitLater: IndexDocumentsAction<TModel>[];\n  } {\n    const hashSet: Set<string> = new Set<string>();\n    const resultBatch: IndexDocumentsAction<TModel>[] = [];\n    const pruned: IndexDocumentsAction<TModel>[] = [];\n\n    for (const document of batch) {\n      const key = this.documentKeyRetriever(document as unknown as TModel);\n      if (hashSet.has(key)) {\n        pruned.push(document);\n      } else {\n        hashSet.add(key);\n        resultBatch.push(document);\n      }\n    }\n    return { batchToSubmit: resultBatch, submitLater: pruned };\n  }\n\n  private async submitDocuments(\n    actionsToSend: IndexDocumentsAction<TModel>[],\n    options: OperationOptions,\n    retryAttempt: number = 1,\n  ): Promise<void> {\n    try {\n      for (const action of actionsToSend) {\n        this.emitter.emit(\"beforeDocumentSent\", action);\n      }\n      const result = await this.client.indexDocuments(\n        new IndexDocumentsBatch<TModel>(actionsToSend),\n        options,\n      );\n      // raise success event\n      this.emitter.emit(\"batchSucceeded\", result);\n    } catch (e: any) {\n      if (e.statusCode && e.statusCode === 413 && actionsToSend.length > 1) {\n        // Cut the payload size to half\n        const splitActionsArray = [\n          actionsToSend.slice(0, actionsToSend.length / 2),\n          actionsToSend.slice(actionsToSend.length / 2, actionsToSend.length),\n        ];\n        this.initialBatchActionCount = splitActionsArray[0].length; // So, we do not want 413 happening again and again\n        for (const actions of splitActionsArray) {\n          await this.submitDocuments(actions, options);\n        }\n      } else if (this.isRetryAbleError(e) && retryAttempt <= this.maxRetriesPerAction) {\n        // Exponentially increase the delay each time\n        const exponentialDelay = this.throttlingDelayInMs * Math.pow(2, retryAttempt);\n        // Don't let the delay exceed the maximum\n        const clampedExponentialDelay = Math.min(this.maxThrottlingDelayInMs, exponentialDelay);\n        // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n        // that retries across multiple clients don't occur simultaneously.\n        const delayWithJitter =\n          clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);\n        await delay(delayWithJitter);\n        await this.submitDocuments(actionsToSend, options, retryAttempt + 1);\n      } else {\n        this.emitter.emit(\"batchFailed\", e);\n        throw e;\n      }\n    }\n  }\n\n  private isRetryAbleError(e: any): boolean {\n    return e.statusCode && (e.statusCode === 422 || e.statusCode === 409 || e.statusCode === 503);\n  }\n}\n"]}