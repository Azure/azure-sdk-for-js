## API Report File for "@azure/arm-virtualenclaves"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type ActionPerformed = string;

// @public
export type ActionType = string;

// @public
export interface ApprovalActionRequest {
    approvalStatus: string;
}

// @public
export interface ApprovalActionResponse {
    message: string;
}

// @public
export interface ApprovalCallbackRequest {
    approvalCallbackPayload?: string;
    approvalStatus: string;
    resourceRequestAction: string;
}

// @public
export interface ApprovalDeletionCallbackRequest {
    resourceRequestAction: string;
}

// @public
export interface ApprovalPatchModel {
    properties?: ApprovalPatchProperties;
}

// @public
export interface ApprovalPatchProperties {
    approvers?: Approver[];
    createdAt?: Date;
    grandparentResourceId?: string;
    parentResourceId?: string;
    requestMetadata: RequestMetadataUpdatableProperties;
    stateChangedAt?: Date;
    ticketId?: string;
}

// @public
export type ApprovalPolicy = string;

// @public
export interface ApprovalProperties {
    approvers?: Approver[];
    createdAt?: Date;
    grandparentResourceId?: string;
    parentResourceId?: string;
    readonly provisioningState?: ProvisioningState;
    requestMetadata: RequestMetadata;
    stateChangedAt?: Date;
    ticketId?: string;
}

// @public
export interface ApprovalResource extends ExtensionResource {
    properties?: ApprovalProperties;
}

// @public
export interface ApprovalSettings {
    connectionCreation?: ApprovalPolicy;
    connectionDeletion?: ApprovalPolicy;
    connectionUpdate?: ApprovalPolicy;
    enclaveCreation?: ApprovalPolicy;
    enclaveDeletion?: ApprovalPolicy;
    endpointCreation?: ApprovalPolicy;
    endpointDeletion?: ApprovalPolicy;
    endpointUpdate?: ApprovalPolicy;
    maintenanceMode?: ApprovalPolicy;
    mandatoryApprovers?: MandatoryApprover[];
    minimumApproversRequired?: number;
    notificationOnApprovalAction?: ApprovalPolicy;
    notificationOnApprovalCreation?: ApprovalPolicy;
    notificationOnApprovalDeletion?: ApprovalPolicy;
    serviceCatalogDeployment?: ApprovalPolicy;
}

// @public
export interface ApprovalSettingsPatchProperties {
    mandatoryApprovers?: MandatoryApprover[];
}

// @public
export type ApprovalStatus = string;

// @public
export interface Approver {
    actionPerformed?: ActionPerformed;
    approverEntraId: string;
    lastUpdatedAt: Date;
}

// @public
export interface CheckAddressSpaceAvailabilityRequest {
    communityResourceId: string;
    enclaveVirtualNetwork: EnclaveVirtualNetworkModel;
}

// @public
export interface CheckAddressSpaceAvailabilityResponse {
    value: boolean;
}

// @public
export interface CommunityEndpointDestinationRule {
    destination?: string;
    destinationType?: DestinationType;
    endpointRuleName?: string;
    ports?: string;
    protocols?: CommunityEndpointProtocol[];
    transitHubResourceId?: string;
}

// @public
export interface CommunityEndpointPatchModel {
    properties?: CommunityEndpointPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface CommunityEndpointPatchProperties {
    ruleCollection: CommunityEndpointDestinationRule[];
}

// @public
export interface CommunityEndpointProperties {
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    ruleCollection: CommunityEndpointDestinationRule[];
}

// @public
export type CommunityEndpointProtocol = string;

// @public
export interface CommunityEndpointResource extends TrackedResource {
    properties?: CommunityEndpointProperties;
}

// @public
export interface CommunityPatchModel {
    identity?: ManagedServiceIdentity;
    properties?: CommunityPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface CommunityPatchProperties {
    approvalSettings?: ApprovalSettingsPatchProperties;
    communityRoleAssignments?: RoleAssignmentItem[];
    dnsServers?: string[];
    firewallSku?: FirewallSKU;
    governedServiceList?: GovernedServiceItem[];
    maintenanceModeConfiguration?: MaintenanceModeConfigurationPatchModel;
    policyOverride?: string;
}

// @public
export interface CommunityProperties {
    addressSpace?: string;
    approvalSettings?: ApprovalSettings;
    communityRoleAssignments?: RoleAssignmentItem[];
    dnsServers?: string[];
    firewallSku?: FirewallSKU;
    governedServiceList?: GovernedServiceItem[];
    maintenanceModeConfiguration?: MaintenanceModeConfigurationModel;
    readonly managedOnBehalfOfConfiguration?: ManagedOnBehalfOfConfiguration;
    readonly managedResourceGroupName?: string;
    policyOverride?: string;
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
}

// @public
export interface CommunityResource extends TrackedResource {
    identity?: ManagedServiceIdentity;
    properties?: CommunityProperties;
}

// @public
export type CreatedByType = string;

// @public
export type DestinationType = string;

// @public
export type DiagnosticDestination = string;

// @public
export interface EnclaveAddressSpacesModel {
    enclaveAddressSpace?: string;
    managedAddressSpace?: string;
}

// @public
export interface EnclaveConnectionPatchModel {
    properties?: EnclaveConnectionPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface EnclaveConnectionPatchProperties {
    sourceCidr?: string;
}

// @public
export interface EnclaveConnectionProperties {
    communityResourceId: string;
    destinationEndpointId: string;
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    sourceCidr?: string;
    sourceResourceId: string;
    readonly state?: EnclaveConnectionState;
}

// @public
export interface EnclaveConnectionResource extends TrackedResource {
    properties?: EnclaveConnectionProperties;
}

// @public
export type EnclaveConnectionState = string;

// @public
export interface EnclaveDefaultSettingsModel {
    diagnosticDestination?: DiagnosticDestination;
    readonly keyVaultResourceId?: string;
    readonly logAnalyticsResourceIdCollection?: string[];
    readonly storageAccountResourceId?: string;
}

// @public
export interface EnclaveDefaultSettingsPatchModel {
    diagnosticDestination?: DiagnosticDestination;
}

// @public
export interface EnclaveEndpointDestinationRule {
    destination?: string;
    endpointRuleName?: string;
    ports?: string;
    protocols?: EnclaveEndpointProtocol[];
}

// @public
export interface EnclaveEndpointPatchModel {
    properties?: EnclaveEndpointPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface EnclaveEndpointPatchProperties {
    ruleCollection: EnclaveEndpointDestinationRule[];
}

// @public
export interface EnclaveEndpointProperties {
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    ruleCollection: EnclaveEndpointDestinationRule[];
}

// @public
export type EnclaveEndpointProtocol = string;

// @public
export interface EnclaveEndpointResource extends TrackedResource {
    properties?: EnclaveEndpointProperties;
}

// @public
export interface EnclaveResource extends TrackedResource {
    identity?: ManagedServiceIdentity;
    properties?: VirtualEnclaveProperties;
}

// @public
export interface EnclaveVirtualNetworkModel {
    allowSubnetCommunication?: boolean;
    customCidrRange?: string;
    networkName?: string;
    networkSize?: string;
    subnetConfigurations?: SubnetConfiguration[];
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: any;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface ExtensionResource extends Resource {
}

// @public
export type FirewallSKU = string;

// @public
export interface GovernedServiceItem {
    enforcement?: string;
    readonly initiatives?: string[];
    option?: string;
    policyAction?: string;
    serviceId: ServiceIdentifier;
    readonly serviceName?: string;
}

// @public
export enum KnownActionPerformed {
    Approved = "Approved",
    Rejected = "Rejected"
}

// @public
export enum KnownActionType {
    Internal = "Internal"
}

// @public
export enum KnownApprovalPolicy {
    NotRequired = "NotRequired",
    Required = "Required"
}

// @public
export enum KnownApprovalStatus {
    Approved = "Approved",
    Deleted = "Deleted",
    Expired = "Expired",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownCommunityEndpointProtocol {
    AH = "AH",
    ANY = "ANY",
    ESP = "ESP",
    Http = "HTTP",
    Https = "HTTPS",
    Icmp = "ICMP",
    TCP = "TCP",
    UDP = "UDP"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDestinationType {
    Fqdn = "FQDN",
    FqdnTag = "FQDNTag",
    IPAddress = "IPAddress",
    PrivateNetwork = "PrivateNetwork"
}

// @public
export enum KnownDiagnosticDestination {
    Both = "Both",
    CommunityOnly = "CommunityOnly",
    EnclaveOnly = "EnclaveOnly"
}

// @public
export enum KnownEnclaveConnectionState {
    Active = "Active",
    Approved = "Approved",
    Connected = "Connected",
    Disconnected = "Disconnected",
    Failed = "Failed",
    PendingApproval = "PendingApproval",
    PendingUpdate = "PendingUpdate"
}

// @public
export enum KnownEnclaveEndpointProtocol {
    AH = "AH",
    ANY = "ANY",
    ESP = "ESP",
    Icmp = "ICMP",
    TCP = "TCP",
    UDP = "UDP"
}

// @public
export enum KnownFirewallSKU {
    Basic = "Basic",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownOrigin {
    System = "system",
    User = "user",
    UserSystem = "user,system"
}

// @public
export enum KnownProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    NotSpecified = "NotSpecified",
    Running = "Running",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownServiceIdentifier {
    AKS = "AKS",
    AppService = "AppService",
    AzureFirewalls = "AzureFirewalls",
    ContainerRegistry = "ContainerRegistry",
    CosmosDB = "CosmosDB",
    DataConnectors = "DataConnectors",
    Insights = "Insights",
    KeyVault = "KeyVault",
    Logic = "Logic",
    MicrosoftSql = "MicrosoftSQL",
    Monitoring = "Monitoring",
    PostgreSql = "PostgreSQL",
    PrivateDNSZones = "PrivateDNSZones",
    ServiceBus = "ServiceBus",
    Storage = "Storage"
}

// @public
export enum KnownTransitHubState {
    Active = "Active",
    Approved = "Approved",
    Failed = "Failed",
    PendingApproval = "PendingApproval",
    PendingUpdate = "PendingUpdate"
}

// @public
export enum KnownTransitOptionType {
    ExpressRoute = "ExpressRoute",
    Gateway = "Gateway",
    Peering = "Peering"
}

// @public
export enum KnownVersions {
    V20240601Preview = "2024-06-01-preview",
    V20241201Preview = "2024-12-01-preview",
    V20250501Preview = "2025-05-01-preview"
}

// @public
export interface MaintenanceModeConfigurationModel {
    justification?: string;
    mode: string;
    principals?: Principal[];
}

// @public
export interface MaintenanceModeConfigurationPatchModel {
    justification?: string;
    mode: string;
    principals?: Principal[];
}

// @public
export interface ManagedOnBehalfOfConfiguration {
    readonly moboBrokerResources?: MoboBrokerResource[];
}

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentity | null>;
}

// @public
export type ManagedServiceIdentityType = string;

// @public
export interface MandatoryApprover {
    approverEntraId: string;
}

// @public
export interface MoboBrokerResource {
    id?: string;
}

// @public
export interface Operation {
    readonly actionType?: ActionType;
    display?: OperationDisplay;
    readonly isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: Origin;
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export type Origin = string;

// @public
export interface Principal {
    id: string;
    type: string;
}

// @public
export type ProvisioningState = string;

// @public
export interface RequestMetadata {
    approvalCallbackPayload?: string;
    approvalCallbackRoute?: string;
    approvalStatus?: ApprovalStatus;
    resourceAction: string;
}

// @public
export interface RequestMetadataUpdatableProperties {
    approvalCallbackPayload?: string;
    approvalCallbackRoute?: string;
    approvalStatus?: ApprovalStatus;
    resourceAction: string;
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface RoleAssignmentItem {
    principals?: Principal[];
    roleDefinitionId: string;
}

// @public
export type ServiceIdentifier = string;

// @public
export interface SubnetConfiguration {
    readonly addressPrefix?: string;
    networkPrefixSize: number;
    readonly networkSecurityGroupResourceId?: string;
    subnetDelegation?: string;
    subnetName: string;
    readonly subnetResourceId?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export interface TransitHubPatchModel {
    properties?: TransitHubPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface TransitHubPatchProperties {
    state?: TransitHubState;
    transitOption?: TransitOption;
}

// @public
export interface TransitHubProperties {
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    state?: TransitHubState;
    transitOption?: TransitOption;
}

// @public
export interface TransitHubResource extends TrackedResource {
    properties?: TransitHubProperties;
}

// @public
export type TransitHubState = string;

// @public
export interface TransitOption {
    params?: TransitOptionParams;
    type?: TransitOptionType;
}

// @public
export interface TransitOptionParams {
    remoteVirtualNetworkId?: string;
    scaleUnits?: number;
}

// @public
export type TransitOptionType = string;

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface VirtualEnclavePatchModel {
    identity?: ManagedServiceIdentity;
    properties?: VirtualEnclavePatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface VirtualEnclavePatchProperties {
    bastionEnabled?: boolean;
    enclaveDefaultSettings?: EnclaveDefaultSettingsPatchModel;
    enclaveRoleAssignments?: RoleAssignmentItem[];
    enclaveVirtualNetwork: EnclaveVirtualNetworkModel;
    governedServiceList?: GovernedServiceItem[];
    maintenanceModeConfiguration?: MaintenanceModeConfigurationPatchModel;
    workloadRoleAssignments?: RoleAssignmentItem[];
}

// @public
export interface VirtualEnclaveProperties {
    bastionEnabled?: boolean;
    communityResourceId: string;
    readonly enclaveAddressSpaces?: EnclaveAddressSpacesModel;
    enclaveDefaultSettings?: EnclaveDefaultSettingsModel;
    enclaveRoleAssignments?: RoleAssignmentItem[];
    enclaveVirtualNetwork: EnclaveVirtualNetworkModel;
    governedServiceList?: GovernedServiceItem[];
    maintenanceModeConfiguration?: MaintenanceModeConfigurationModel;
    readonly managedOnBehalfOfConfiguration?: ManagedOnBehalfOfConfiguration;
    readonly managedResourceGroupName?: string;
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    workloadRoleAssignments?: RoleAssignmentItem[];
}

// @public
export interface WorkloadPatchModel {
    properties?: WorkloadPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface WorkloadPatchProperties {
    resourceGroupCollection?: string[];
}

// @public
export interface WorkloadProperties {
    readonly managedOnBehalfOfConfiguration?: ManagedOnBehalfOfConfiguration;
    readonly provisioningState?: ProvisioningState;
    resourceGroupCollection?: string[];
}

// @public
export interface WorkloadResource extends TrackedResource {
    properties?: WorkloadProperties;
}

// (No @packageDocumentation comment for this package)

```
