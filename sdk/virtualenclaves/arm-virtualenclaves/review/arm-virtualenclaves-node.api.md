## API Report File for "@azure/arm-virtualenclaves"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import type { ClientOptions } from '@azure-rest/core-client';
import type { OperationOptions } from '@azure-rest/core-client';
import type { OperationState } from '@azure/core-lro';
import type { PathUncheckedResponse } from '@azure-rest/core-client';
import type { Pipeline } from '@azure/core-rest-pipeline';
import type { PollerLike } from '@azure/core-lro';
import type { TokenCredential } from '@azure/core-auth';

// @public
export type ActionPerformed = string;

// @public
export type ActionType = string;

// @public
export interface ApprovalActionRequest {
    approvalStatus: string;
}

// @public
export interface ApprovalActionResponse {
    message: string;
}

// @public
export interface ApprovalCallbackRequest {
    approvalCallbackPayload?: string;
    approvalStatus: string;
    resourceRequestAction: string;
}

// @public
export interface ApprovalCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApprovalDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApprovalDeletionCallbackRequest {
    resourceRequestAction: string;
}

// @public
export interface ApprovalGetOptionalParams extends OperationOptions {
}

// @public
export interface ApprovalListByParentOptionalParams extends OperationOptions {
}

// @public
export interface ApprovalNotifyInitiatorOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ApprovalOperations {
    createOrUpdate: (resourceUri: string, approvalName: string, resource: ApprovalResource, options?: ApprovalCreateOrUpdateOptionalParams) => PollerLike<OperationState<ApprovalResource>, ApprovalResource>;
    delete: (resourceUri: string, approvalName: string, options?: ApprovalDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceUri: string, approvalName: string, options?: ApprovalGetOptionalParams) => Promise<ApprovalResource>;
    listByParent: (resourceUri: string, options?: ApprovalListByParentOptionalParams) => PagedAsyncIterableIterator<ApprovalResource>;
    notifyInitiator: (resourceUri: string, approvalName: string, body: ApprovalActionRequest, options?: ApprovalNotifyInitiatorOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    update: (resourceUri: string, approvalName: string, properties: ApprovalPatchModel, options?: ApprovalUpdateOptionalParams) => PollerLike<OperationState<ApprovalResource>, ApprovalResource>;
}

// @public
export interface ApprovalPatchModel {
    properties?: ApprovalPatchProperties;
}

// @public
export interface ApprovalPatchProperties {
    approvers?: Approver[];
    createdAt?: Date;
    grandparentResourceId?: string;
    parentResourceId?: string;
    requestMetadata: RequestMetadataUpdatableProperties;
    stateChangedAt?: Date;
    ticketId?: string;
}

// @public
export type ApprovalPolicy = string;

// @public
export interface ApprovalProperties {
    approvers?: Approver[];
    createdAt?: Date;
    grandparentResourceId?: string;
    parentResourceId?: string;
    readonly provisioningState?: ProvisioningState;
    requestMetadata: RequestMetadata;
    stateChangedAt?: Date;
    ticketId?: string;
}

// @public
export interface ApprovalResource extends ExtensionResource {
    properties?: ApprovalProperties;
}

// @public
export interface ApprovalSettings {
    connectionCreation?: ApprovalPolicy;
    connectionDeletion?: ApprovalPolicy;
    connectionUpdate?: ApprovalPolicy;
    enclaveCreation?: ApprovalPolicy;
    enclaveDeletion?: ApprovalPolicy;
    endpointCreation?: ApprovalPolicy;
    endpointDeletion?: ApprovalPolicy;
    endpointUpdate?: ApprovalPolicy;
    maintenanceMode?: ApprovalPolicy;
    mandatoryApprovers?: MandatoryApprover[];
    minimumApproversRequired?: number;
    notificationOnApprovalAction?: ApprovalPolicy;
    notificationOnApprovalCreation?: ApprovalPolicy;
    notificationOnApprovalDeletion?: ApprovalPolicy;
    serviceCatalogDeployment?: ApprovalPolicy;
}

// @public
export interface ApprovalSettingsPatchProperties {
    mandatoryApprovers?: MandatoryApprover[];
}

// @public
export type ApprovalStatus = string;

// @public
export interface ApprovalUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface Approver {
    actionPerformed?: ActionPerformed;
    approverEntraId: string;
    lastUpdatedAt: Date;
}

// @public
export enum AzureClouds {
    AZURE_CHINA_CLOUD = "AZURE_CHINA_CLOUD",
    AZURE_PUBLIC_CLOUD = "AZURE_PUBLIC_CLOUD",
    AZURE_US_GOVERNMENT = "AZURE_US_GOVERNMENT"
}

// @public
export type AzureSupportedClouds = `${AzureClouds}`;

// @public
export interface CheckAddressSpaceAvailabilityRequest {
    communityResourceId: string;
    enclaveVirtualNetwork: EnclaveVirtualNetworkModel;
}

// @public
export interface CheckAddressSpaceAvailabilityResponse {
    value: boolean;
}

// @public
export interface CommunityCheckAddressSpaceAvailabilityOptionalParams extends OperationOptions {
}

// @public
export interface CommunityCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CommunityDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CommunityEndpointDestinationRule {
    destination?: string;
    destinationType?: DestinationType;
    endpointRuleName?: string;
    ports?: string;
    protocols?: CommunityEndpointProtocol[];
    transitHubResourceId?: string;
}

// @public
export interface CommunityEndpointPatchModel {
    properties?: CommunityEndpointPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface CommunityEndpointPatchProperties {
    ruleCollection: CommunityEndpointDestinationRule[];
}

// @public
export interface CommunityEndpointProperties {
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    ruleCollection: CommunityEndpointDestinationRule[];
}

// @public
export type CommunityEndpointProtocol = string;

// @public
export interface CommunityEndpointResource extends TrackedResource {
    properties?: CommunityEndpointProperties;
}

// @public
export interface CommunityEndpointsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CommunityEndpointsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CommunityEndpointsGetOptionalParams extends OperationOptions {
}

// @public
export interface CommunityEndpointsHandleApprovalCreationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CommunityEndpointsHandleApprovalDeletionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CommunityEndpointsListByCommunityResourceOptionalParams extends OperationOptions {
}

// @public
export interface CommunityEndpointsListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface CommunityEndpointsOperations {
    createOrUpdate: (resourceGroupName: string, communityName: string, communityEndpointName: string, resource: CommunityEndpointResource, options?: CommunityEndpointsCreateOrUpdateOptionalParams) => PollerLike<OperationState<CommunityEndpointResource>, CommunityEndpointResource>;
    delete: (resourceGroupName: string, communityName: string, communityEndpointName: string, options?: CommunityEndpointsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, communityName: string, communityEndpointName: string, options?: CommunityEndpointsGetOptionalParams) => Promise<CommunityEndpointResource>;
    handleApprovalCreation: (resourceGroupName: string, communityName: string, communityEndpointName: string, body: ApprovalCallbackRequest, options?: CommunityEndpointsHandleApprovalCreationOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    handleApprovalDeletion: (resourceGroupName: string, communityName: string, communityEndpointName: string, body: ApprovalDeletionCallbackRequest, options?: CommunityEndpointsHandleApprovalDeletionOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    listByCommunityResource: (resourceGroupName: string, communityName: string, options?: CommunityEndpointsListByCommunityResourceOptionalParams) => PagedAsyncIterableIterator<CommunityEndpointResource>;
    listBySubscription: (communityName: string, options?: CommunityEndpointsListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<CommunityEndpointResource>;
    update: (resourceGroupName: string, communityName: string, communityEndpointName: string, properties: CommunityEndpointPatchModel, options?: CommunityEndpointsUpdateOptionalParams) => PollerLike<OperationState<CommunityEndpointResource>, CommunityEndpointResource>;
}

// @public
export interface CommunityEndpointsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CommunityGetOptionalParams extends OperationOptions {
}

// @public
export interface CommunityListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface CommunityListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface CommunityOperations {
    checkAddressSpaceAvailability: (resourceGroupName: string, communityName: string, checkAddressSpaceAvailabilityRequest: CheckAddressSpaceAvailabilityRequest, options?: CommunityCheckAddressSpaceAvailabilityOptionalParams) => Promise<CheckAddressSpaceAvailabilityResponse>;
    createOrUpdate: (resourceGroupName: string, communityName: string, resource: CommunityResource, options?: CommunityCreateOrUpdateOptionalParams) => PollerLike<OperationState<CommunityResource>, CommunityResource>;
    delete: (resourceGroupName: string, communityName: string, options?: CommunityDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, communityName: string, options?: CommunityGetOptionalParams) => Promise<CommunityResource>;
    listByResourceGroup: (resourceGroupName: string, options?: CommunityListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<CommunityResource>;
    listBySubscription: (options?: CommunityListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<CommunityResource>;
    update: (resourceGroupName: string, communityName: string, properties: CommunityPatchModel, options?: CommunityUpdateOptionalParams) => PollerLike<OperationState<CommunityResource>, CommunityResource>;
}

// @public
export interface CommunityPatchModel {
    identity?: ManagedServiceIdentity;
    properties?: CommunityPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface CommunityPatchProperties {
    approvalSettings?: ApprovalSettingsPatchProperties;
    communityRoleAssignments?: RoleAssignmentItem[];
    dnsServers?: string[];
    firewallSku?: FirewallSKU;
    governedServiceList?: GovernedServiceItem[];
    maintenanceModeConfiguration?: MaintenanceModeConfigurationPatchModel;
    policyOverride?: string;
}

// @public
export interface CommunityProperties {
    addressSpace?: string;
    approvalSettings?: ApprovalSettings;
    communityRoleAssignments?: RoleAssignmentItem[];
    dnsServers?: string[];
    firewallSku?: FirewallSKU;
    governedServiceList?: GovernedServiceItem[];
    maintenanceModeConfiguration?: MaintenanceModeConfigurationModel;
    readonly managedOnBehalfOfConfiguration?: ManagedOnBehalfOfConfiguration;
    readonly managedResourceGroupName?: string;
    policyOverride?: string;
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
}

// @public
export interface CommunityResource extends TrackedResource {
    identity?: ManagedServiceIdentity;
    properties?: CommunityProperties;
}

// @public
export interface CommunityUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export type CreatedByType = string;

// @public
export type DestinationType = string;

// @public
export type DiagnosticDestination = string;

// @public
export interface EnclaveAddressSpacesModel {
    enclaveAddressSpace?: string;
    managedAddressSpace?: string;
}

// @public
export interface EnclaveConnectionCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveConnectionDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveConnectionGetOptionalParams extends OperationOptions {
}

// @public
export interface EnclaveConnectionHandleApprovalCreationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveConnectionHandleApprovalDeletionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveConnectionListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface EnclaveConnectionListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface EnclaveConnectionOperations {
    createOrUpdate: (resourceGroupName: string, enclaveConnectionName: string, resource: EnclaveConnectionResource, options?: EnclaveConnectionCreateOrUpdateOptionalParams) => PollerLike<OperationState<EnclaveConnectionResource>, EnclaveConnectionResource>;
    delete: (resourceGroupName: string, enclaveConnectionName: string, options?: EnclaveConnectionDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, enclaveConnectionName: string, options?: EnclaveConnectionGetOptionalParams) => Promise<EnclaveConnectionResource>;
    handleApprovalCreation: (resourceGroupName: string, enclaveConnectionName: string, body: ApprovalCallbackRequest, options?: EnclaveConnectionHandleApprovalCreationOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    handleApprovalDeletion: (resourceGroupName: string, enclaveConnectionName: string, body: ApprovalDeletionCallbackRequest, options?: EnclaveConnectionHandleApprovalDeletionOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    listByResourceGroup: (resourceGroupName: string, options?: EnclaveConnectionListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<EnclaveConnectionResource>;
    listBySubscription: (options?: EnclaveConnectionListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<EnclaveConnectionResource>;
    update: (resourceGroupName: string, enclaveConnectionName: string, properties: EnclaveConnectionPatchModel, options?: EnclaveConnectionUpdateOptionalParams) => PollerLike<OperationState<EnclaveConnectionResource>, EnclaveConnectionResource>;
}

// @public
export interface EnclaveConnectionPatchModel {
    properties?: EnclaveConnectionPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface EnclaveConnectionPatchProperties {
    sourceCidr?: string;
}

// @public
export interface EnclaveConnectionProperties {
    communityResourceId: string;
    destinationEndpointId: string;
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    sourceCidr?: string;
    sourceResourceId: string;
    readonly state?: EnclaveConnectionState;
}

// @public
export interface EnclaveConnectionResource extends TrackedResource {
    properties?: EnclaveConnectionProperties;
}

// @public
export type EnclaveConnectionState = string;

// @public
export interface EnclaveConnectionUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveDefaultSettingsModel {
    diagnosticDestination?: DiagnosticDestination;
    readonly keyVaultResourceId?: string;
    readonly logAnalyticsResourceIdCollection?: string[];
    readonly storageAccountResourceId?: string;
}

// @public
export interface EnclaveDefaultSettingsPatchModel {
    diagnosticDestination?: DiagnosticDestination;
}

// @public
export interface EnclaveEndpointDestinationRule {
    destination?: string;
    endpointRuleName?: string;
    ports?: string;
    protocols?: EnclaveEndpointProtocol[];
}

// @public
export interface EnclaveEndpointPatchModel {
    properties?: EnclaveEndpointPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface EnclaveEndpointPatchProperties {
    ruleCollection: EnclaveEndpointDestinationRule[];
}

// @public
export interface EnclaveEndpointProperties {
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    ruleCollection: EnclaveEndpointDestinationRule[];
}

// @public
export type EnclaveEndpointProtocol = string;

// @public
export interface EnclaveEndpointResource extends TrackedResource {
    properties?: EnclaveEndpointProperties;
}

// @public
export interface EnclaveEndpointsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveEndpointsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveEndpointsGetOptionalParams extends OperationOptions {
}

// @public
export interface EnclaveEndpointsHandleApprovalCreationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveEndpointsHandleApprovalDeletionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveEndpointsListByEnclaveResourceOptionalParams extends OperationOptions {
}

// @public
export interface EnclaveEndpointsListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface EnclaveEndpointsOperations {
    createOrUpdate: (resourceGroupName: string, virtualEnclaveName: string, enclaveEndpointName: string, resource: EnclaveEndpointResource, options?: EnclaveEndpointsCreateOrUpdateOptionalParams) => PollerLike<OperationState<EnclaveEndpointResource>, EnclaveEndpointResource>;
    delete: (resourceGroupName: string, virtualEnclaveName: string, enclaveEndpointName: string, options?: EnclaveEndpointsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, virtualEnclaveName: string, enclaveEndpointName: string, options?: EnclaveEndpointsGetOptionalParams) => Promise<EnclaveEndpointResource>;
    handleApprovalCreation: (resourceGroupName: string, virtualEnclaveName: string, enclaveEndpointName: string, body: ApprovalCallbackRequest, options?: EnclaveEndpointsHandleApprovalCreationOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    handleApprovalDeletion: (resourceGroupName: string, virtualEnclaveName: string, enclaveEndpointName: string, body: ApprovalDeletionCallbackRequest, options?: EnclaveEndpointsHandleApprovalDeletionOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    listByEnclaveResource: (resourceGroupName: string, virtualEnclaveName: string, options?: EnclaveEndpointsListByEnclaveResourceOptionalParams) => PagedAsyncIterableIterator<EnclaveEndpointResource>;
    listBySubscription: (virtualEnclaveName: string, options?: EnclaveEndpointsListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<EnclaveEndpointResource>;
    update: (resourceGroupName: string, virtualEnclaveName: string, enclaveEndpointName: string, properties: EnclaveEndpointPatchModel, options?: EnclaveEndpointsUpdateOptionalParams) => PollerLike<OperationState<EnclaveEndpointResource>, EnclaveEndpointResource>;
}

// @public
export interface EnclaveEndpointsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnclaveResource extends TrackedResource {
    identity?: ManagedServiceIdentity;
    properties?: VirtualEnclaveProperties;
}

// @public
export interface EnclaveVirtualNetworkModel {
    allowSubnetCommunication?: boolean;
    customCidrRange?: string;
    networkName?: string;
    networkSize?: string;
    subnetConfigurations?: SubnetConfiguration[];
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: any;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface ExtensionResource extends Resource {
}

// @public
export type FirewallSKU = string;

// @public
export interface GovernedServiceItem {
    enforcement?: string;
    readonly initiatives?: string[];
    option?: string;
    policyAction?: string;
    serviceId: ServiceIdentifier;
    readonly serviceName?: string;
}

// @public
export enum KnownActionPerformed {
    Approved = "Approved",
    Rejected = "Rejected"
}

// @public
export enum KnownActionType {
    Internal = "Internal"
}

// @public
export enum KnownApprovalPolicy {
    NotRequired = "NotRequired",
    Required = "Required"
}

// @public
export enum KnownApprovalStatus {
    Approved = "Approved",
    Deleted = "Deleted",
    Expired = "Expired",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownCommunityEndpointProtocol {
    AH = "AH",
    ANY = "ANY",
    ESP = "ESP",
    Http = "HTTP",
    Https = "HTTPS",
    Icmp = "ICMP",
    TCP = "TCP",
    UDP = "UDP"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDestinationType {
    Fqdn = "FQDN",
    FqdnTag = "FQDNTag",
    IPAddress = "IPAddress",
    PrivateNetwork = "PrivateNetwork"
}

// @public
export enum KnownDiagnosticDestination {
    Both = "Both",
    CommunityOnly = "CommunityOnly",
    EnclaveOnly = "EnclaveOnly"
}

// @public
export enum KnownEnclaveConnectionState {
    Active = "Active",
    Approved = "Approved",
    Connected = "Connected",
    Disconnected = "Disconnected",
    Failed = "Failed",
    PendingApproval = "PendingApproval",
    PendingUpdate = "PendingUpdate"
}

// @public
export enum KnownEnclaveEndpointProtocol {
    AH = "AH",
    ANY = "ANY",
    ESP = "ESP",
    Icmp = "ICMP",
    TCP = "TCP",
    UDP = "UDP"
}

// @public
export enum KnownFirewallSKU {
    Basic = "Basic",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownManagedServiceIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned,UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownOrigin {
    System = "system",
    User = "user",
    UserSystem = "user,system"
}

// @public
export enum KnownProvisioningState {
    Accepted = "Accepted",
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    NotSpecified = "NotSpecified",
    Running = "Running",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownServiceIdentifier {
    AKS = "AKS",
    AppService = "AppService",
    AzureFirewalls = "AzureFirewalls",
    ContainerRegistry = "ContainerRegistry",
    CosmosDB = "CosmosDB",
    DataConnectors = "DataConnectors",
    Insights = "Insights",
    KeyVault = "KeyVault",
    Logic = "Logic",
    MicrosoftSql = "MicrosoftSQL",
    Monitoring = "Monitoring",
    PostgreSql = "PostgreSQL",
    PrivateDNSZones = "PrivateDNSZones",
    ServiceBus = "ServiceBus",
    Storage = "Storage"
}

// @public
export enum KnownTransitHubState {
    Active = "Active",
    Approved = "Approved",
    Failed = "Failed",
    PendingApproval = "PendingApproval",
    PendingUpdate = "PendingUpdate"
}

// @public
export enum KnownTransitOptionType {
    ExpressRoute = "ExpressRoute",
    Gateway = "Gateway",
    Peering = "Peering"
}

// @public
export enum KnownVersions {
    V20240601Preview = "2024-06-01-preview",
    V20241201Preview = "2024-12-01-preview",
    V20250501Preview = "2025-05-01-preview"
}

// @public
export interface MaintenanceModeConfigurationModel {
    justification?: string;
    mode: string;
    principals?: Principal[];
}

// @public
export interface MaintenanceModeConfigurationPatchModel {
    justification?: string;
    mode: string;
    principals?: Principal[];
}

// @public
export interface ManagedOnBehalfOfConfiguration {
    readonly moboBrokerResources?: MoboBrokerResource[];
}

// @public
export interface ManagedServiceIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type: ManagedServiceIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentity | null>;
}

// @public
export type ManagedServiceIdentityType = string;

// @public
export interface MandatoryApprover {
    approverEntraId: string;
}

// @public (undocumented)
export class MissionClient {
    constructor(credential: TokenCredential, subscriptionId: string, options?: MissionClientOptionalParams);
    readonly approval: ApprovalOperations;
    readonly community: CommunityOperations;
    readonly communityEndpoints: CommunityEndpointsOperations;
    readonly enclaveConnection: EnclaveConnectionOperations;
    readonly enclaveEndpoints: EnclaveEndpointsOperations;
    readonly operations: OperationsOperations;
    readonly pipeline: Pipeline;
    readonly transitHub: TransitHubOperations;
    readonly virtualEnclave: VirtualEnclaveOperations;
    readonly workload: WorkloadOperations;
}

// @public
export interface MissionClientOptionalParams extends ClientOptions {
    apiVersion?: string;
    cloudSetting?: AzureSupportedClouds;
}

// @public
export interface MoboBrokerResource {
    id?: string;
}

// @public
export interface Operation {
    readonly actionType?: ActionType;
    display?: OperationDisplay;
    readonly isDataAction?: boolean;
    readonly name?: string;
    readonly origin?: Origin;
}

// @public
export interface OperationDisplay {
    readonly description?: string;
    readonly operation?: string;
    readonly provider?: string;
    readonly resource?: string;
}

// @public
export interface OperationsListOptionalParams extends OperationOptions {
}

// @public
export interface OperationsOperations {
    list: (options?: OperationsListOptionalParams) => PagedAsyncIterableIterator<Operation>;
}

// @public
export type Origin = string;

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface Principal {
    id: string;
    type: string;
}

// @public
export type ProvisioningState = string;

// @public
export interface RequestMetadata {
    approvalCallbackPayload?: string;
    approvalCallbackRoute?: string;
    approvalStatus?: ApprovalStatus;
    resourceAction: string;
}

// @public
export interface RequestMetadataUpdatableProperties {
    approvalCallbackPayload?: string;
    approvalCallbackRoute?: string;
    approvalStatus?: ApprovalStatus;
    resourceAction: string;
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: MissionClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export interface RoleAssignmentItem {
    principals?: Principal[];
    roleDefinitionId: string;
}

// @public
export type ServiceIdentifier = string;

// @public
export interface SubnetConfiguration {
    readonly addressPrefix?: string;
    networkPrefixSize: number;
    readonly networkSecurityGroupResourceId?: string;
    subnetDelegation?: string;
    subnetName: string;
    readonly subnetResourceId?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export interface TransitHubCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TransitHubDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TransitHubGetOptionalParams extends OperationOptions {
}

// @public
export interface TransitHubListByCommunityResourceOptionalParams extends OperationOptions {
}

// @public
export interface TransitHubListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface TransitHubOperations {
    createOrUpdate: (resourceGroupName: string, communityName: string, transitHubName: string, resource: TransitHubResource, options?: TransitHubCreateOrUpdateOptionalParams) => PollerLike<OperationState<TransitHubResource>, TransitHubResource>;
    delete: (resourceGroupName: string, communityName: string, transitHubName: string, options?: TransitHubDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, communityName: string, transitHubName: string, options?: TransitHubGetOptionalParams) => Promise<TransitHubResource>;
    listByCommunityResource: (resourceGroupName: string, communityName: string, options?: TransitHubListByCommunityResourceOptionalParams) => PagedAsyncIterableIterator<TransitHubResource>;
    listBySubscription: (communityName: string, options?: TransitHubListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<TransitHubResource>;
    update: (resourceGroupName: string, communityName: string, transitHubName: string, properties: TransitHubPatchModel, options?: TransitHubUpdateOptionalParams) => PollerLike<OperationState<TransitHubResource>, TransitHubResource>;
}

// @public
export interface TransitHubPatchModel {
    properties?: TransitHubPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface TransitHubPatchProperties {
    state?: TransitHubState;
    transitOption?: TransitOption;
}

// @public
export interface TransitHubProperties {
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    state?: TransitHubState;
    transitOption?: TransitOption;
}

// @public
export interface TransitHubResource extends TrackedResource {
    properties?: TransitHubProperties;
}

// @public
export type TransitHubState = string;

// @public
export interface TransitHubUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TransitOption {
    params?: TransitOptionParams;
    type?: TransitOptionType;
}

// @public
export interface TransitOptionParams {
    remoteVirtualNetworkId?: string;
    scaleUnits?: number;
}

// @public
export type TransitOptionType = string;

// @public
export interface UserAssignedIdentity {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface VirtualEnclaveCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VirtualEnclaveDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VirtualEnclaveGetOptionalParams extends OperationOptions {
}

// @public
export interface VirtualEnclaveHandleApprovalCreationOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VirtualEnclaveHandleApprovalDeletionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface VirtualEnclaveListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface VirtualEnclaveListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface VirtualEnclaveOperations {
    createOrUpdate: (resourceGroupName: string, virtualEnclaveName: string, resource: EnclaveResource, options?: VirtualEnclaveCreateOrUpdateOptionalParams) => PollerLike<OperationState<EnclaveResource>, EnclaveResource>;
    delete: (resourceGroupName: string, virtualEnclaveName: string, options?: VirtualEnclaveDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, virtualEnclaveName: string, options?: VirtualEnclaveGetOptionalParams) => Promise<EnclaveResource>;
    handleApprovalCreation: (resourceGroupName: string, virtualEnclaveName: string, body: ApprovalCallbackRequest, options?: VirtualEnclaveHandleApprovalCreationOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    handleApprovalDeletion: (resourceGroupName: string, virtualEnclaveName: string, body: ApprovalDeletionCallbackRequest, options?: VirtualEnclaveHandleApprovalDeletionOptionalParams) => PollerLike<OperationState<ApprovalActionResponse>, ApprovalActionResponse>;
    listByResourceGroup: (resourceGroupName: string, options?: VirtualEnclaveListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<EnclaveResource>;
    listBySubscription: (options?: VirtualEnclaveListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<EnclaveResource>;
    update: (resourceGroupName: string, virtualEnclaveName: string, properties: VirtualEnclavePatchModel, options?: VirtualEnclaveUpdateOptionalParams) => PollerLike<OperationState<EnclaveResource>, EnclaveResource>;
}

// @public
export interface VirtualEnclavePatchModel {
    identity?: ManagedServiceIdentity;
    properties?: VirtualEnclavePatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface VirtualEnclavePatchProperties {
    bastionEnabled?: boolean;
    enclaveDefaultSettings?: EnclaveDefaultSettingsPatchModel;
    enclaveRoleAssignments?: RoleAssignmentItem[];
    enclaveVirtualNetwork: EnclaveVirtualNetworkModel;
    governedServiceList?: GovernedServiceItem[];
    maintenanceModeConfiguration?: MaintenanceModeConfigurationPatchModel;
    workloadRoleAssignments?: RoleAssignmentItem[];
}

// @public
export interface VirtualEnclaveProperties {
    bastionEnabled?: boolean;
    communityResourceId: string;
    readonly enclaveAddressSpaces?: EnclaveAddressSpacesModel;
    enclaveDefaultSettings?: EnclaveDefaultSettingsModel;
    enclaveRoleAssignments?: RoleAssignmentItem[];
    enclaveVirtualNetwork: EnclaveVirtualNetworkModel;
    governedServiceList?: GovernedServiceItem[];
    maintenanceModeConfiguration?: MaintenanceModeConfigurationModel;
    readonly managedOnBehalfOfConfiguration?: ManagedOnBehalfOfConfiguration;
    readonly managedResourceGroupName?: string;
    readonly provisioningState?: ProvisioningState;
    readonly resourceCollection?: string[];
    workloadRoleAssignments?: RoleAssignmentItem[];
}

// @public
export interface VirtualEnclaveUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface WorkloadCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface WorkloadDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface WorkloadGetOptionalParams extends OperationOptions {
}

// @public
export interface WorkloadListByEnclaveResourceOptionalParams extends OperationOptions {
}

// @public
export interface WorkloadListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface WorkloadOperations {
    createOrUpdate: (resourceGroupName: string, virtualEnclaveName: string, workloadName: string, resource: WorkloadResource, options?: WorkloadCreateOrUpdateOptionalParams) => PollerLike<OperationState<WorkloadResource>, WorkloadResource>;
    delete: (resourceGroupName: string, virtualEnclaveName: string, workloadName: string, options?: WorkloadDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, virtualEnclaveName: string, workloadName: string, options?: WorkloadGetOptionalParams) => Promise<WorkloadResource>;
    listByEnclaveResource: (resourceGroupName: string, virtualEnclaveName: string, options?: WorkloadListByEnclaveResourceOptionalParams) => PagedAsyncIterableIterator<WorkloadResource>;
    listBySubscription: (virtualEnclaveName: string, options?: WorkloadListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<WorkloadResource>;
    update: (resourceGroupName: string, virtualEnclaveName: string, workloadName: string, properties: WorkloadPatchModel, options?: WorkloadUpdateOptionalParams) => PollerLike<OperationState<WorkloadResource>, WorkloadResource>;
}

// @public
export interface WorkloadPatchModel {
    properties?: WorkloadPatchProperties;
    tags?: Record<string, string>;
}

// @public
export interface WorkloadPatchProperties {
    resourceGroupCollection?: string[];
}

// @public
export interface WorkloadProperties {
    readonly managedOnBehalfOfConfiguration?: ManagedOnBehalfOfConfiguration;
    readonly provisioningState?: ProvisioningState;
    resourceGroupCollection?: string[];
}

// @public
export interface WorkloadResource extends TrackedResource {
    properties?: WorkloadProperties;
}

// @public
export interface WorkloadUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// (No @packageDocumentation comment for this package)

```
