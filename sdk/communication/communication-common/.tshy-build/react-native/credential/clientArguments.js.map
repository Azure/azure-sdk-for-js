{"version":3,"file":"clientArguments.js","sourceRoot":"","sources":["../../../src/credential/clientArguments.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAA4C,iBAAiB,EAAE,MAAM,kBAAkB,CAAC;AAC/F,OAAO,EAAE,qBAAqB,EAAE,MAAM,uBAAuB,CAAC;AAE9D,MAAM,eAAe,GAAG,CAAC,IAAY,EAAW,EAAE;;IAChD,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;IAE1B,OAAO,CACL,CAAC,CAAC,CAAA,MAAA,GAAG,CAAC,QAAQ,0CAAE,KAAK,CAAC,WAAW,CAAC,CAAA;QAClC,GAAG,CAAC,IAAI,KAAK,SAAS;QACtB,GAAG,CAAC,IAAI,KAAK,EAAE;QACf,CAAC,GAAG,CAAC,QAAQ,KAAK,SAAS,IAAI,GAAG,CAAC,QAAQ,KAAK,EAAE,IAAI,GAAG,CAAC,QAAQ,KAAK,GAAG,CAAC,CAC5E,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,mBAAmB,GAAG,CAAC,IAAY,EAAQ,EAAE;IACjD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC;QAC3B,MAAM,IAAI,KAAK,CAAC,wBAAwB,IAAI,EAAE,CAAC,CAAC;IAClD,CAAC;AACH,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,UAAmB,EAA+B,EAAE;IAClF,MAAM,cAAc,GAAG,UAGtB,CAAC;IACF,OAAO,CACL,cAAc;QACd,OAAO,cAAc,CAAC,GAAG,KAAK,QAAQ;QACtC,cAAc,CAAC,QAAQ,KAAK,SAAS,CACtC,CAAC;AACJ,CAAC,CAAC;AAWF;;;GAGG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAClC,qBAA6B,EAC7B,mBAA6B,EACV,EAAE;IACrB,IAAI,eAAe,CAAC,mBAAmB,CAAC,IAAI,iBAAiB,CAAC,mBAAmB,CAAC,EAAE,CAAC;QACnF,mBAAmB,CAAC,qBAAqB,CAAC,CAAC;QAC3C,OAAO,EAAE,GAAG,EAAE,qBAAqB,EAAE,UAAU,EAAE,mBAAmB,EAAE,CAAC;IACzE,CAAC;SAAM,CAAC;QACN,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,UAAU,EAAE,GAAG,qBAAqB,CAAC,qBAAqB,CAAC,CAAC;QACpF,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAC1B,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC;IACnC,CAAC;AACH,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { type KeyCredential, type TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { parseConnectionString } from \"./connectionString.js\";\n\nconst isValidEndpoint = (host: string): boolean => {\n  const url = new URL(host);\n\n  return (\n    !!url.protocol?.match(/^http[s]?/) &&\n    url.host !== undefined &&\n    url.host !== \"\" &&\n    (url.pathname === undefined || url.pathname === \"\" || url.pathname === \"/\")\n  );\n};\n\nconst assertValidEndpoint = (host: string): void => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\nexport const isKeyCredential = (credential: unknown): credential is KeyCredential => {\n  const castCredential = credential as {\n    key: unknown;\n    getToken: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.key === \"string\" &&\n    castCredential.getToken === undefined\n  );\n};\n\n/**\n * The URL and credential from parsing the arguments of a communication client.\n * @hidden\n */\nexport type UrlWithCredential = {\n  url: string;\n  credential: TokenCredential | KeyCredential;\n};\n\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\nexport const parseClientArguments = (\n  connectionStringOrUrl: string,\n  credentialOrOptions?: unknown,\n): UrlWithCredential => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return { url: connectionStringOrUrl, credential: credentialOrOptions };\n  } else {\n    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return { url: host, credential };\n  }\n};\n"]}