/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";

export type QueueSelectorUnion =
  | QueueSelector
  | NearestQueueLabelSelector
  | QueueIdSelector
  | QueueLabelSelector;
export type RouterRuleUnion =
  | RouterRule
  | AzureFunctionRule
  | DirectMapRule
  | ExpressionRule
  | StaticRule;
export type LabelSelectorAttachmentUnion =
  | LabelSelectorAttachment
  | ConditionalLabelSelector
  | PassThroughLabelSelector
  | RuleLabelSelector
  | StaticLabelSelector
  | WeightedAllocationLabelSelector;
export type DistributionModeUnion =
  | DistributionMode
  | BestWorkerMode
  | LongestIdleMode
  | RoundRobinMode;
export type JobExceptionTriggerUnion =
  | JobExceptionTrigger
  | QueueLengthExceptionTrigger
  | WaitTimeExceptionTrigger;
export type ExceptionActionUnion =
  | ExceptionAction
  | CancelExceptionAction
  | ManualReclassifyExceptionAction
  | ReclassifyExceptionAction;

/** Request payload for creating or updating a channel */
export interface UpsertChannelRequest {
  /** The id of the Channel, for non AcsManaged channels this is specified by the resource owner. */
  id: string;
  /** The friendly name of the channel. */
  name?: string;
}

/** Response payload for creating or updating a channel */
export interface UpsertChannelResponse {
  /** Id of the channel created. */
  id: string;
  /** Friendly name of the channel created. */
  name?: string;
  /** Indicates that the Channel was created and is maintained by ACS. */
  acsManaged: boolean;
}

export interface CommunicationErrorResponse {
  communicationError: CommunicationError;
}

export interface CommunicationError {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly code?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly message?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly target?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly innerErrors?: CommunicationError[];
}

/** A paged collection of channels. */
export interface ChannelCollection {
  value: RouterChannel[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

export interface RouterChannel {
  /** The Id of the channel. */
  id: string;
  /** (Optional) The friendly name of the channel. */
  name?: string;
  /** Indicates that the Channel was created and is maintained by ACS. */
  acsManaged: boolean;
}

/** Request payload for creating or updating a Classification Policy */
export interface UpsertClassificationPolicyRequest {
  /** Unique identifier of this policy. Required upon policy creation or updating a classification policy. */
  id: string;
  /** Friendly name of this policy. */
  name?: string;
  /** The fallback queue to select if the queue selector doesn't find a match. */
  fallbackQueueId?: string;
  /** The queue selector to select a queue for a given job. */
  queueSelector?: QueueSelectorUnion;
  /** The rule to determine a priority score for a given job. */
  prioritizationRule?: RouterRuleUnion;
  /** The worker label selectors to attach to a given job. */
  workerSelectors?: LabelSelectorAttachmentUnion[];
}

export interface QueueSelector {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "nearest-queue-label" | "queue-id" | "queue-label";
}

export interface RouterRule {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind:
    | "azure-function-rule"
    | "direct-map-rule"
    | "expression-rule"
    | "static-rule";
}

export interface LabelSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind:
    | "conditional"
    | "pass-through"
    | "rule"
    | "static"
    | "weighted-allocation";
}

/** Response payload for creating or updating a classification policy */
export interface UpsertClassificationPolicyResponse {
  /** Unique identifier of this policy. */
  id: string;
  /** Friendly name of this policy. */
  name?: string;
  /** The fallback queue to select if the queue selector doesn't find a match. */
  fallbackQueueId?: string;
  /** The queue selector to select a queue for a given job. */
  queueSelector?: QueueSelectorUnion;
  /** The rule to determine a priority score for a given job. */
  prioritizationRule?: RouterRuleUnion;
  /** The worker label selectors to attach to a given job. */
  workerSelectors?: LabelSelectorAttachmentUnion[];
}

/** A paged collection of classification policies. */
export interface ClassificationPolicyCollection {
  value: ClassificationPolicy[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** A container for the rules that govern how jobs are classified. */
export interface ClassificationPolicy {
  /** Unique identifier of this policy. */
  id: string;
  /** Friendly name of this policy. */
  name?: string;
  /** The fallback queue to select if the queue selector doesn't find a match. */
  fallbackQueueId?: string;
  /** The queue selector to select a queue for a given job. */
  queueSelector?: QueueSelectorUnion;
  /** The rule to determine a priority score for a given job. */
  prioritizationRule?: RouterRuleUnion;
  /** The worker label selectors to attach to a given job. */
  workerSelectors?: LabelSelectorAttachmentUnion[];
}

/** Request payload for creating or updating a distribution policy */
export interface UpsertDistributionPolicyRequest {
  /** Unique identifier of this policy. Required upon policy creation or updating a distribution policy. */
  id: string;
  /** The human readable name of the policy. */
  name?: string;
  /** The expiry time of any offers created under this policy will be governed by the offer time to live. */
  offerTTL: string;
  /** The policy governing the specific distribution method. */
  mode: DistributionModeUnion;
}

/** Abstract base class for defining a distribution mode */
export interface DistributionMode {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "best-worker" | "longest-idle" | "round-robin";
  /** Governs the minimum desired number of active concurrent offers a job can have. */
  minConcurrentOffers: number;
  /** Governs the maximum number of active concurrent offers a job can have. */
  maxConcurrentOffers: number;
  /**
   * (Optional)
   * If set to true, then router will match workers to jobs even if they don't match label selectors.
   * Warning: You may get workers that are not qualified for the job they are matched with if you set this
   * variable to true. This flag is intended more for temporary usage.
   * By default, set to false.
   */
  bypassSelectors?: boolean;
}

/** Response payload for creating or updating a distribution policy */
export interface UpsertDistributionPolicyResponse {
  /** Unique identifier of this policy. */
  id: string;
  /** The human readable name of the policy. */
  name?: string;
  /** The expiry time of any offers created under this policy will be governed by the offer time to live. */
  offerTTL: string;
  /** The policy governing the specific distribution method. */
  mode: DistributionModeUnion;
}

/** A paged collection of distribution policies. */
export interface DistributionPolicyCollection {
  value: DistributionPolicy[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** Policy governing how jobs are distributed to workers */
export interface DistributionPolicy {
  /** The unique identifier of the policy. */
  id: string;
  /** The human readable name of the policy. */
  name?: string;
  /** The expiry time of any offers created under this policy will be governed by the offer time to live. */
  offerTTL: string;
  /** The policy governing the specific distribution method. */
  mode: DistributionModeUnion;
}

/** Request payload for creating or updating a exception policy */
export interface UpsertExceptionPolicyRequest {
  /** Unique identifier of this policy. Required upon policy creation or updating a exception policy. */
  id: string;
  /** (Optional) The name of the exception policy. */
  name?: string;
  /** (Optional) A collection of exception rules on the exception policy. */
  exceptionRules?: ExceptionRule[];
}

/** A single exception rule */
export interface ExceptionRule {
  /** Unique Id of the rule */
  id: string;
  /** The exception trigger for this exception rule */
  trigger: JobExceptionTriggerUnion;
  /** The actions to perform once the exception is triggered */
  actions: ExceptionActionUnion[];
}

/** The trigger for this exception rule */
export interface JobExceptionTrigger {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "queue-length" | "wait-time";
}

/** The action to take when the exception is triggered */
export interface ExceptionAction {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "cancel" | "manual-reclassify" | "reclassify";
  /** Unique Id of the action within the exception rule */
  id: string;
}

/** Response payload for creating or updating a exception policy. */
export interface UpsertExceptionPolicyResponse {
  /** Unique identifier of this policy. */
  id: string;
  /** The name of the exception policy created. */
  name?: string;
  /** A collection of exception rules on the exception policy. */
  exceptionRules?: ExceptionRule[];
}

/** A paged collection of exception policies. */
export interface ExceptionPolicyCollection {
  value: ExceptionPolicy[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** A single exception policy */
export interface ExceptionPolicy {
  /** The Id of the exception policy */
  id: string;
  /** (Optional) The name of the exception policy. */
  name?: string;
  /** (Optional) A collection of exception rules on the exception policy. */
  exceptionRules?: ExceptionRule[];
}

/** Request payload for creating new jobs */
export interface CreateJobRequest {
  /** Reference to an external parent context, eg. call ID */
  channelReference?: string;
  /** The channel or modality upon which this job will be executed. */
  channelId: string;
  /**
   * (optional) The classification policy that will determine queue, priority and worker label selectors.
   * If this is omitted, then QueueID and Priority become required.
   */
  classificationPolicyId?: string;
  /** (optional) If not classification policy is specified, then you must manually specify a queue. */
  queueId?: string;
  /** (optional) If no priority is set, then default to 1. */
  priority?: number;
  /** A collection of label selectors a worker must satisfy in order to process this job. */
  workerSelectors?: LabelSelector[];
  /** A set of key/value pairs used by the classification process to determine queue, priority and attach label selectors. */
  labels?: { [propertyName: string]: any };
  /** (optional) Customer supplied note. */
  note?: string;
}

/** Describes a condition that must be met against a set of labels */
export interface LabelSelector {
  /** The label key to query against */
  key: string;
  /** Describes how the value of the label is compared to the value defined on the label selector */
  operator: LabelOperator;
  /** The value to compare against the actual label value with the given operator */
  value?: any;
  /** Describes how long this label selector is valid */
  ttl?: string;
}

export interface CreateJobResponse {
  /** Id of the newly created job. */
  id: string;
}

/** A paged collection of jobs. */
export interface JobCollection {
  value: RouterJob[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

export interface RouterJob {
  /** The id of the Job. */
  id: string;
  /** Reference to an external parent context, eg. call ID. */
  channelReference?: string;
  /** The state of the Job. */
  jobStatus: JobStatus;
  /** The time a job was queued. */
  enqueueTimeUtc?: Date;
  /** The channel or modality upon which this job will be executed. */
  channelId: string;
  /** The Id of the Classification policy used for classifying a job. */
  classificationPolicyId?: string;
  /** The Id of the Queue that a job is queued to. */
  queueId?: string;
  /** The priority of this job. */
  priority?: number;
  /** Reason code for cancelled or closed jobs. */
  dispositionCode?: string;
  /** A collection of label selectors a worker must satisfy in order to process this job. */
  workerSelectors?: LabelSelector[];
  /** A set of key/value pairs used by the classification process to determine queue, priority and attach label selectors. */
  labels?: { [propertyName: string]: any };
  /**
   * A collection of the assignments of the job.
   * Key is AssignmentId.
   */
  assignments?: { [propertyName: string]: JobAssignment };
  /** Generic text notes attached to a job, sorted by timestamp */
  notes?: { [propertyName: string]: string };
}

export interface JobAssignment {
  /** The Id of the job assignment. */
  id: string;
  /** The Id of the Worker assigned to the job. */
  workerId?: string;
  /** The Assignment time of the job. */
  assignTime: Date;
  /** The time the job was marked as completed after being assigned. */
  completeTime?: Date;
  /** The time the job was marked as closed after being completed. */
  closeTime?: Date;
}

/** Request payload for updating existing jobs */
export interface UpdateJobLabelsRequest {
  /** A set of key/value pairs used as metadata for a job. */
  labels: { [propertyName: string]: any };
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Request payload to update existing job and submit for classification */
export interface ReclassifyJobRequest {
  /** (optional) The classification policy that will determine queue, priority and required abilities. */
  classificationPolicyId?: string;
  /** (optional) A set of key/value pairs used by the classification policy to determine queue, priority and required abilities. */
  labelsToUpsert?: { [propertyName: string]: any };
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Request payload to update existing job's classification */
export interface UpdateJobClassificationRequest {
  /** Updated QueueId. */
  queueId?: string;
  /** Updated Priority. */
  priority?: number;
  /** Updated WorkerSelectors. */
  workerSelectors?: LabelSelector[];
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Request payload for deleting a job */
export interface CancelJobRequest {
  /** (Optional) Customer supplied note, e.g., cancellation reason. */
  note?: string;
  /**
   * (Optional) Customer supplied disposition code for specifying any short label
   * If not provided, default value of "CancelledByUser" is set.
   */
  dispositionCode?: string;
}

/** Request payload for completing jobs */
export interface CompleteJobRequest {
  /** The assignment within the job to complete. */
  assignmentId: string;
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Request payload for completing jobs */
export interface CloseJobRequest {
  /** The assignment within which the job is to be closed. */
  assignmentId: string;
  /** Indicates the outcome of the job, populate this field with your own custom values. */
  dispositionCode?: string;
  /**
   * If not provided, capacity will be released immediately.
   * If provided, the future time at which to release the capacity.
   */
  releaseTime?: Date;
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Dto for JobPositionDetails. */
export interface JobPositionDetails {
  /** Id of the job these details are about. */
  jobId: string;
  /** Position of the job in question within that queue. */
  position: number;
  /** Id of the queue this job is enqueued in. */
  queueId: string;
  /** Length of the queue: total number of enqueued jobs. */
  queueLength: number;
}

export interface AcceptJobOfferResponse {
  /** The assignment Id that assigns a worker that has accepted an offer to a job. */
  assignmentId: string;
  /** The Id of the job assigned. */
  jobId: string;
  /** The Id of the worker that has been assigned this job. */
  workerId: string;
}

/** Request payload for creating or updating a queue */
export interface UpsertQueueRequest {
  /** Unique identifier of this Queue. Required upon Queue creation or updating a queue. */
  id: string;
  /** The name of this queue. */
  name?: string;
  /** The ID of the distribution policy that will determine how a job is distributed to workers. */
  distributionPolicyId: string;
  /** (Optional) A set of key/value pairs used by the classification policy to determine queue to assign a job. */
  labels?: { [propertyName: string]: any };
  /** (Optional) The ID of the exception policy that determines various job escalation rules. */
  exceptionPolicyId?: string;
}

/** Response payload for creating or updating a queue */
export interface UpsertQueueResponse {
  /** Unique identifier of this Queue. */
  id: string;
  /** The name of this queue. */
  name?: string;
  /** The ID of the distribution policy that will determine how a job is distributed to workers. */
  distributionPolicyId: string;
  /** (Optional) A set of key/value pairs used by the classification process to determine queue to assign a job. */
  labels?: { [propertyName: string]: any };
  /** The ID of the exception policy that determines various job escalation rules. */
  exceptionPolicyId?: string;
}

/** A paged collection of queues. */
export interface QueueCollection {
  value: JobQueue[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** A queue that can contain jobs to be routed. */
export interface JobQueue {
  /** The Id of this queue */
  id: string;
  /** The name of this queue. */
  name?: string;
  /** The ID of the distribution policy that will determine how a job is distributed to workers. */
  distributionPolicyId: string;
  /** (Optional) A set of key/value pairs used by the classification process to determine queue to assign a job. */
  labels?: { [propertyName: string]: any };
  /** (Optional) The ID of the exception policy that determines various job escalation rules. */
  exceptionPolicyId?: string;
}

/** Request payload for registering workers. */
export interface RegisterWorkerRequest {
  /** Unique key that identifies this worker. */
  id: string;
  /** The queues assignments for this worker. */
  queueAssignments?: QueueAssignment[];
  /** Total score that can be consumed by offers and assignments under this worker. */
  totalCapacity: number;
  /** A set of properties of this worker that are used to determine if it matches a set on label selectors. */
  labels?: { [propertyName: string]: any };
  /** A collection of channel configurations that define how the worker can do concurrent work per channel. */
  channelConfigurations?: ChannelConfiguration[];
}

/** An assignment of a worker to a queue */
export interface QueueAssignment {
  /** The ID of the queue associated with this assignment. */
  queueId: string;
}

export interface ChannelConfiguration {
  /** Unique key of the Channel. */
  channelId: string;
  /** The amount of capacity that an instance of a job of this channel will consume of the total worker capacity. */
  capacityCostPerJob: number;
}

export interface RouterWorker {
  id: string;
  state: WorkerState;
  queueAssignments?: QueueAssignment[];
  totalCapacity: number;
  /** Dictionary of <any> */
  labels?: { [propertyName: string]: any };
  channelConfigurations?: ChannelConfiguration[];
  offers?: JobOffer[];
  assignedJobs?: WorkerAssignment[];
  loadRatio: number;
}

export interface JobOffer {
  /** The Id of the offer. */
  id: string;
  /** The Id of the job assigned. */
  jobId: string;
  /** The capacity cost consumed by the job offer. */
  capacityCost: number;
  /** The time the offer was created. */
  offerTimeUtc?: Date;
  /** The time that indicates when the offer will expire. */
  expiryTimeUtc?: Date;
}

export interface WorkerAssignment {
  /** The Id of the assignment. */
  id: string;
  /** The Id of the Job assigned. */
  jobId: string;
  /** The amount of capacity this assignment has consumed for a worker. */
  capacityCost: number;
  /** The Assignment time of the job. */
  assignTime: Date;
}

/** A paged collection of workers. */
export interface WorkerCollection {
  value: RouterWorker[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

export interface ReleaseAssignmentRequest {
  /**
   * If not provided, capacity will be released immediately.
   * If provided, the future time at which to release the capacity.
   */
  releaseTime?: Date;
}

/** Credentials used to access Azure function rule */
export interface AzureFunctionRuleCredential {
  /** (Optional) Access key scoped to a particular function */
  functionKey?: string;
  /**
   * (Optional) Access key scoped to a Azure Function app.
   * This key grants access to all functions under the app.
   */
  appKey?: string;
  /**
   * (Optional) Client id, when AppKey is provided
   * In context of Azure function, this is usually the name of the key
   */
  clientId?: string;
}

/** Encapsulates all options that can be passed as parameters for scoring rule with Microsoft.AzureCommunicationService.Router.Contracts.V2021_04_07_preview1.Models.DistributionModes.BestWorkerModeDto */
export interface ScoringRuleOptions {
  /** (Optional) Set batch size when Microsoft.AzureCommunicationService.Router.Contracts.V2021_04_07_preview1.Models.DistributionModes.ScoringRuleOptionsDto.AllowScoringBatchOfWorkers is set to true */
  batchSize?: number;
  /**
   * (Optional) List of parameters that will be sent as part of the payload to scoring rule.
   * If not provided, job labels, label selectors and worker labels are sent as part of the payload
   */
  scoringParameters?: ScoringRuleParameterSelector[];
  /**
   * (Optional)
   * If true, will try to obtain scores for a batch of workers.
   * By default, set to false. Use Microsoft.AzureCommunicationService.Router.Contracts.V2021_04_07_preview1.Models.DistributionModes.ScoringRuleOptionsDto.BatchSize to set batch size
   */
  allowScoringBatchOfWorkers?: boolean;
  /**
   * (Optional)
   * If false, will sort scores by ascending order. By default, set to true.
   */
  descendingOrder?: boolean;
}

/** A percentage based allocation. */
export interface WeightedAllocation {
  /** The percentage of this weight, expressed as a fraction of 1. */
  weight: number;
  /** A collection of label selectors that will be applied if this allocation is selected. */
  labelSelectors: LabelSelector[];
}

export type NearestQueueLabelSelector = QueueSelector & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "nearest-queue-label";
  /** The rule that resolves the matching labels */
  rule: RouterRuleUnion;
};

/** Selects a queue by Id */
export type QueueIdSelector = QueueSelector & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "queue-id";
  /** The rule that resolves the queueId */
  rule: RouterRuleUnion;
};

/** Selects a queue by label selectors evaluated against it's labels */
export type QueueLabelSelector = QueueSelector & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "queue-label";
  /** The label selectors to evaluate against the queue labels */
  labelSelectors: LabelSelectorAttachmentUnion[];
};

/** A rule providing a binding to an HTTP Triggered Azure Function. */
export type AzureFunctionRule = RouterRule & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "azure-function-rule";
  /** URL for custom azure function */
  functionAppUrl: string;
  /** User-friendly name for function */
  functionName: string;
  /** Credentials used to access Azure function rule */
  credential?: AzureFunctionRuleCredential;
};

/** A rule that return the same labels as the input labels. */
export type DirectMapRule = RouterRule & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "direct-map-rule";
};

/** A rule providing inline expression rules. */
export type ExpressionRule = RouterRule & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "expression-rule";
  /** The expression language to compile to and execute */
  language: "powerFx";
  /** The string containing the expression to evaluate. Should contain return statement with calculated values. */
  expression: string;
};

/** A rule providing static rules that always return the same result, regardless of input. */
export type StaticRule = RouterRule & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "static-rule";
  /** The static value this rule always returns. */
  value?: any;
};

/** Describes a set of label selectors that will be attached if the given condition resolves to true */
export type ConditionalLabelSelector = LabelSelectorAttachment & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "conditional";
  /** The condition that must be true for the label selectors to be attached */
  condition: RouterRuleUnion;
  /** The label selectors to attach */
  labelSelectors: LabelSelector[];
};

/** Attaches a label selector where the value is pass through from the job label with the same key */
export type PassThroughLabelSelector = LabelSelectorAttachment & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "pass-through";
  /** The label key to query against */
  key: string;
  /** Describes how the value of the label is compared to the value pass through */
  operator: LabelOperator;
  /** Describes how long the attached label selector is valid */
  ttl?: string;
};

export type RuleLabelSelector = LabelSelectorAttachment & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "rule";
  /** A rule that resolves the label selectors to attach */
  rule: RouterRuleUnion;
};

/** Describes a label selector that will always be attached */
export type StaticLabelSelector = LabelSelectorAttachment & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "static";
  /** Describes a condition that must be met against a set of labels */
  labelSelector: LabelSelector;
};

/** Describes multiple sets of label selectors, of which one will be selected and attached according to a weighting */
export type WeightedAllocationLabelSelector = LabelSelectorAttachment & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "weighted-allocation";
  /** A collection of percentage based weighted allocations. */
  allocations: WeightedAllocation[];
};

/** Jobs are distributed to the worker with the strongest abilities available. */
export type BestWorkerMode = DistributionMode & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "best-worker";
  /**
   * (Optional)
   * Define a scoring rule to use, when calculating a score to determine the best worker.
   * If not set, will use a default scoring formula that uses the number of job labels that the worker
   * labels match, as well as the number of label selectors the worker labels match and/or exceed
   * using a logistic function (https://en.wikipedia.org/wiki/Logistic_function).
   */
  scoringRule?: RouterRuleUnion;
  /** Encapsulates all options that can be passed as parameters for scoring rule with Microsoft.AzureCommunicationService.Router.Contracts.V2021_04_07_preview1.Models.DistributionModes.BestWorkerModeDto */
  scoringRuleOptions?: ScoringRuleOptions;
};

/** Jobs are directed to the worker who has been idle longest. */
export type LongestIdleMode = DistributionMode & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "longest-idle";
};

/** Jobs are distributed in order to workers, starting with the worker that is after the last worker to receive a job. */
export type RoundRobinMode = DistributionMode & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "round-robin";
};

/** Trigger for an exception action on exceeding queue length */
export type QueueLengthExceptionTrigger = JobExceptionTrigger & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "queue-length";
  /** Threshold of number of jobs queued to for this trigger */
  threshold: number;
};

/** Trigger for an exception action on exceeding wait time */
export type WaitTimeExceptionTrigger = JobExceptionTrigger & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "wait-time";
  /** Threshold for wait time for this trigger */
  threshold: string;
};

/** An action that modifies labels on a job and then reclassifies it */
export type CancelExceptionAction = ExceptionAction & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "cancel";
  /** (Optional) Customer supplied note, e.g., cancellation reason. */
  note?: string;
  /** (Optional) Customer supplied disposition code for specifying any short label */
  dispositionCode?: string;
};

/** An action that manually reclassifies a job by providing the queue, priority and worker selectors. */
export type ManualReclassifyExceptionAction = ExceptionAction & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "manual-reclassify";
  /** Updated QueueId. */
  queueId?: string;
  /** Updated Priority. */
  priority?: number;
  /** Updated WorkerSelectors. */
  workerSelectors?: LabelSelector[];
};

/** An action that modifies labels on a job and then reclassifies it */
export type ReclassifyExceptionAction = ExceptionAction & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "reclassify";
  /** (optional) The new classification policy that will determine queue, priority and worker selectors. */
  classificationPolicyId?: string;
  /** (optional) Dictionary containing the labels to update (or add if not existing) in key-value pairs */
  labelsToUpsert?: { [propertyName: string]: any };
};
/** Defines values for LabelOperator. */
export type LabelOperator =
  | "equal"
  | "notEqual"
  | "lessThan"
  | "lessThanEqual"
  | "greaterThan"
  | "greaterThanEqual";
/** Defines values for JobStateSelector. */
export type JobStateSelector =
  | "all"
  | "pendingClassification"
  | "queued"
  | "assigned"
  | "completed"
  | "closed"
  | "cancelled"
  | "classificationFailed"
  | "active";
/** Defines values for JobStatus. */
export type JobStatus =
  | "pendingClassification"
  | "queued"
  | "assigned"
  | "completed"
  | "closed"
  | "cancelled"
  | "classificationFailed";
/** Defines values for WorkerState. */
export type WorkerState = "active" | "draining" | "inactive";
/** Defines values for WorkerStateSelector. */
export type WorkerStateSelector = "active" | "draining" | "inactive" | "all";
/** Defines values for ScoringRuleParameterSelector. */
export type ScoringRuleParameterSelector =
  | "jobLabels"
  | "labelSelectors"
  | "workerLabelsCollection";

/** Optional parameters. */
export interface JobRouterCreateOrUpdateChannelOptionalParams
  extends coreHttp.OperationOptions {
  ifMatch?: string;
}

/** Contains response data for the createOrUpdateChannel operation. */
export type JobRouterCreateOrUpdateChannelResponse = UpsertChannelResponse & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: UpsertChannelResponse;
  };
};

/** Optional parameters. */
export interface JobRouterListChannelsOptionalParams
  extends coreHttp.OperationOptions {
  /** Specifies Managed Channels or Custom Channels, left blank returns all channels. */
  typeParam?: string;
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listChannels operation. */
export type JobRouterListChannelsResponse = ChannelCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ChannelCollection;
  };
};

/** Optional parameters. */
export interface JobRouterGetChannelOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the getChannel operation. */
export type JobRouterGetChannelResponse = RouterChannel & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RouterChannel;
  };
};

/** Optional parameters. */
export interface JobRouterDeleteChannelOptionalParams
  extends coreHttp.OperationOptions {
  /** Concurrency token for CosmosDB */
  ifMatch?: string;
}

/** Optional parameters. */
export interface JobRouterCreateOrUpdateClassificationPolicyOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the createOrUpdateClassificationPolicy operation. */
export type JobRouterCreateOrUpdateClassificationPolicyResponse = UpsertClassificationPolicyResponse & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: UpsertClassificationPolicyResponse;
  };
};

/** Optional parameters. */
export interface JobRouterListClassificationPoliciesOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listClassificationPolicies operation. */
export type JobRouterListClassificationPoliciesResponse = ClassificationPolicyCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ClassificationPolicyCollection;
  };
};

/** Optional parameters. */
export interface JobRouterGetClassificationPolicyOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the getClassificationPolicy operation. */
export type JobRouterGetClassificationPolicyResponse = ClassificationPolicy & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ClassificationPolicy;
  };
};

/** Optional parameters. */
export interface JobRouterDeleteClassificationPolicyOptionalParams
  extends coreHttp.OperationOptions {
  ifMatch?: string;
}

/** Optional parameters. */
export interface JobRouterCreateOrUpdateDistributionPolicyOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the createOrUpdateDistributionPolicy operation. */
export type JobRouterCreateOrUpdateDistributionPolicyResponse = UpsertDistributionPolicyResponse & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: UpsertDistributionPolicyResponse;
  };
};

/** Optional parameters. */
export interface JobRouterListDistributionPoliciesOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listDistributionPolicies operation. */
export type JobRouterListDistributionPoliciesResponse = DistributionPolicyCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: DistributionPolicyCollection;
  };
};

/** Optional parameters. */
export interface JobRouterGetDistributionPolicyOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the getDistributionPolicy operation. */
export type JobRouterGetDistributionPolicyResponse = DistributionPolicy & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: DistributionPolicy;
  };
};

/** Optional parameters. */
export interface JobRouterDeleteDistributionPolicyOptionalParams
  extends coreHttp.OperationOptions {
  ifMatch?: string;
}

/** Optional parameters. */
export interface JobRouterCreateOrUpdateExceptionPolicyOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the createOrUpdateExceptionPolicy operation. */
export type JobRouterCreateOrUpdateExceptionPolicyResponse = UpsertExceptionPolicyResponse & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: UpsertExceptionPolicyResponse;
  };
};

/** Optional parameters. */
export interface JobRouterListExceptionPoliciesOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listExceptionPolicies operation. */
export type JobRouterListExceptionPoliciesResponse = ExceptionPolicyCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ExceptionPolicyCollection;
  };
};

/** Optional parameters. */
export interface JobRouterGetExceptionPolicyOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the getExceptionPolicy operation. */
export type JobRouterGetExceptionPolicyResponse = ExceptionPolicy & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ExceptionPolicy;
  };
};

/** Optional parameters. */
export interface JobRouterDeleteExceptionPolicyOptionalParams
  extends coreHttp.OperationOptions {
  /** Concurrency token for CosmosDB */
  ifMatch?: string;
}

/** Optional parameters. */
export interface JobRouterCreateJobOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the createJob operation. */
export type JobRouterCreateJobResponse = CreateJobResponse & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: CreateJobResponse;
  };
};

/** Optional parameters. */
export interface JobRouterListJobsOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
  /** (Optional) If specified, filter jobs by status. */
  status?: JobStateSelector;
}

/** Contains response data for the listJobs operation. */
export type JobRouterListJobsResponse = JobCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: JobCollection;
  };
};

/** Optional parameters. */
export interface JobRouterGetJobOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the getJob operation. */
export type JobRouterGetJobResponse = RouterJob & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RouterJob;
  };
};

/** Optional parameters. */
export interface JobRouterListEnqueuedJobsOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listEnqueuedJobs operation. */
export type JobRouterListEnqueuedJobsResponse = JobCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: JobCollection;
  };
};

/** Optional parameters. */
export interface JobRouterUpdateJobLabelsOptionalParams
  extends coreHttp.OperationOptions {
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Contains response data for the updateJobLabels operation. */
export type JobRouterUpdateJobLabelsResponse = RouterJob & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RouterJob;
  };
};

/** Optional parameters. */
export interface JobRouterReclassifyJobOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the reclassifyJob operation. */
export type JobRouterReclassifyJobResponse = RouterJob & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RouterJob;
  };
};

/** Optional parameters. */
export interface JobRouterUpdateJobClassificationOptionalParams
  extends coreHttp.OperationOptions {
  /** Updated QueueId. */
  queueId?: string;
  /** Updated Priority. */
  priority?: number;
  /** Updated WorkerSelectors. */
  workerSelectors?: LabelSelector[];
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Contains response data for the updateJobClassification operation. */
export type JobRouterUpdateJobClassificationResponse = RouterJob & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RouterJob;
  };
};

/** Optional parameters. */
export interface JobRouterCancelJobOptionalParams
  extends coreHttp.OperationOptions {
  /** (Optional) Customer supplied note, e.g., cancellation reason. */
  note?: string;
  /**
   * (Optional) Customer supplied disposition code for specifying any short label
   * If not provided, default value of "CancelledByUser" is set.
   */
  dispositionCode?: string;
}

/** Optional parameters. */
export interface JobRouterCompleteJobOptionalParams
  extends coreHttp.OperationOptions {
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Optional parameters. */
export interface JobRouterCloseJobOptionalParams
  extends coreHttp.OperationOptions {
  /** Indicates the outcome of the job, populate this field with your own custom values. */
  dispositionCode?: string;
  /**
   * If not provided, capacity will be released immediately.
   * If provided, the future time at which to release the capacity.
   */
  releaseTime?: Date;
  /** (Optional) Customer supplied note. */
  note?: string;
}

/** Optional parameters. */
export interface JobRouterGetInQueuePositionOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the getInQueuePosition operation. */
export type JobRouterGetInQueuePositionResponse = JobPositionDetails & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: JobPositionDetails;
  };
};

/** Optional parameters. */
export interface JobRouterAcceptJobOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the acceptJob operation. */
export type JobRouterAcceptJobResponse = AcceptJobOfferResponse & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AcceptJobOfferResponse;
  };
};

/** Optional parameters. */
export interface JobRouterDeclineJobOptionalParams
  extends coreHttp.OperationOptions {}

/** Optional parameters. */
export interface JobRouterCreateOrUpdateQueueOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the createOrUpdateQueue operation. */
export type JobRouterCreateOrUpdateQueueResponse = UpsertQueueResponse & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: UpsertQueueResponse;
  };
};

/** Optional parameters. */
export interface JobRouterListQueuesOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listQueues operation. */
export type JobRouterListQueuesResponse = QueueCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: QueueCollection;
  };
};

/** Optional parameters. */
export interface JobRouterGetQueueOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the getQueue operation. */
export type JobRouterGetQueueResponse = JobQueue & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: JobQueue;
  };
};

/** Optional parameters. */
export interface JobRouterDeleteQueueOptionalParams
  extends coreHttp.OperationOptions {
  /** Concurrency token for CosmosDB */
  ifMatch?: string;
}

/** Optional parameters. */
export interface JobRouterRegisterWorkerOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the registerWorker operation. */
export type JobRouterRegisterWorkerResponse = RouterWorker & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RouterWorker;
  };
};

/** Optional parameters. */
export interface JobRouterListWorkersOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
  /** (Optional) If specified, select workers by worker status. */
  status?: WorkerStateSelector;
  /** (Optional) If specified, select workers who have a channel configuration with this channel */
  channelId?: string;
  /** (Optional) If specified, select workers who are assigned to this queue */
  queueId?: string;
  /**
   * (Optional) If set to true, select only workers who have capacity for the channel specified by `channelId` or for any channel
   *             if `channelId` not specified. If set to false, then will return all workers including workers without any capacity for jobs. Defaults to false.
   */
  hasCapacity?: boolean;
}

/** Contains response data for the listWorkers operation. */
export type JobRouterListWorkersResponse = WorkerCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: WorkerCollection;
  };
};

/** Optional parameters. */
export interface JobRouterDeregisterWorkerOptionalParams
  extends coreHttp.OperationOptions {}

/** Optional parameters. */
export interface JobRouterGetWorkerOptionalParams
  extends coreHttp.OperationOptions {}

/** Contains response data for the getWorker operation. */
export type JobRouterGetWorkerResponse = RouterWorker & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RouterWorker;
  };
};

/** Optional parameters. */
export interface JobRouterReleaseAssignmentOptionalParams
  extends coreHttp.OperationOptions {
  body?: ReleaseAssignmentRequest;
}

/** Optional parameters. */
export interface JobRouterListChannelsNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Specifies Managed Channels or Custom Channels, left blank returns all channels. */
  typeParam?: string;
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listChannelsNext operation. */
export type JobRouterListChannelsNextResponse = ChannelCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ChannelCollection;
  };
};

/** Optional parameters. */
export interface JobRouterListClassificationPoliciesNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listClassificationPoliciesNext operation. */
export type JobRouterListClassificationPoliciesNextResponse = ClassificationPolicyCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ClassificationPolicyCollection;
  };
};

/** Optional parameters. */
export interface JobRouterListDistributionPoliciesNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listDistributionPoliciesNext operation. */
export type JobRouterListDistributionPoliciesNextResponse = DistributionPolicyCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: DistributionPolicyCollection;
  };
};

/** Optional parameters. */
export interface JobRouterListExceptionPoliciesNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listExceptionPoliciesNext operation. */
export type JobRouterListExceptionPoliciesNextResponse = ExceptionPolicyCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ExceptionPolicyCollection;
  };
};

/** Optional parameters. */
export interface JobRouterListJobsNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
  /** (Optional) If specified, filter jobs by status. */
  status?: JobStateSelector;
}

/** Contains response data for the listJobsNext operation. */
export type JobRouterListJobsNextResponse = JobCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: JobCollection;
  };
};

/** Optional parameters. */
export interface JobRouterListEnqueuedJobsNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listEnqueuedJobsNext operation. */
export type JobRouterListEnqueuedJobsNextResponse = JobCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: JobCollection;
  };
};

/** Optional parameters. */
export interface JobRouterListQueuesNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
}

/** Contains response data for the listQueuesNext operation. */
export type JobRouterListQueuesNextResponse = QueueCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: QueueCollection;
  };
};

/** Optional parameters. */
export interface JobRouterListWorkersNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Number of objects to return per page */
  maxPageSize?: number;
  /** Token for pagination */
  continuationToken?: string;
  /** (Optional) If specified, select workers by worker status. */
  status?: WorkerStateSelector;
  /** (Optional) If specified, select workers who have a channel configuration with this channel */
  channelId?: string;
  /** (Optional) If specified, select workers who are assigned to this queue */
  queueId?: string;
  /**
   * (Optional) If set to true, select only workers who have capacity for the channel specified by `channelId` or for any channel
   *             if `channelId` not specified. If set to false, then will return all workers including workers without any capacity for jobs. Defaults to false.
   */
  hasCapacity?: boolean;
}

/** Contains response data for the listWorkersNext operation. */
export type JobRouterListWorkersNextResponse = WorkerCollection & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: WorkerCollection;
  };
};

/** Optional parameters. */
export interface JobRouterApiClientOptionalParams
  extends coreHttp.ServiceClientOptions {
  /** Api Version */
  apiVersion?: string;
  /** Overrides client endpoint. */
  endpoint?: string;
}
