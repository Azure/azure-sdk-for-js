/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";

export type QueueSelectorAttachmentUnion =
  | QueueSelectorAttachment
  | ConditionalQueueSelectorAttachment
  | PassThroughQueueSelectorAttachment
  | RuleEngineQueueSelectorAttachment
  | StaticQueueSelectorAttachment
  | WeightedAllocationQueueSelectorAttachment;
export type RouterRuleUnion =
  | RouterRule
  | DirectMapRouterRule
  | ExpressionRouterRule
  | FunctionRouterRule
  | StaticRouterRule
  | WebhookRouterRule;
export type WorkerSelectorAttachmentUnion =
  | WorkerSelectorAttachment
  | ConditionalWorkerSelectorAttachment
  | PassThroughWorkerSelectorAttachment
  | RuleEngineWorkerSelectorAttachment
  | StaticWorkerSelectorAttachment
  | WeightedAllocationWorkerSelectorAttachment;
export type DistributionModeUnion =
  | DistributionMode
  | BestWorkerMode
  | LongestIdleMode
  | RoundRobinMode;
export type ExceptionTriggerUnion =
  | ExceptionTrigger
  | QueueLengthExceptionTrigger
  | WaitTimeExceptionTrigger;
export type ExceptionActionUnion =
  | ExceptionAction
  | CancelExceptionAction
  | ManualReclassifyExceptionAction
  | ReclassifyExceptionAction;

/** A container for the rules that govern how jobs are classified. */
export interface ClassificationPolicy {
  /**
   * Unique identifier of this policy.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** Friendly name of this policy. */
  name?: string;
  /** The fallback queue to select if the queue selector doesn't find a match. */
  fallbackQueueId?: string;
  /** The queue selectors to resolve a queue for a given job. */
  queueSelectors?: QueueSelectorAttachmentUnion[];
  /**
   * A rule of one of the following types:
   *
   * StaticRule:  A rule providing static rules that always return the same result, regardless of input.
   * DirectMapRule:  A rule that return the same labels as the input labels.
   * ExpressionRule: A rule providing inline expression rules.
   * AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
   * WebhookRule: A rule providing a binding to a webserver following OAuth2.0 authentication protocol.
   */
  prioritizationRule?: RouterRuleUnion;
  /** The worker label selectors to attach to a given job. */
  workerSelectors?: WorkerSelectorAttachmentUnion[];
}

/** An attachment of queue selectors to resolve a queue to a job from a classification policy */
export interface QueueSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind:
    | "conditional"
    | "pass-through"
    | "rule-engine"
    | "static"
    | "weighted-allocation-queue-selector";
}

/**
 * A rule of one of the following types:
 *
 * StaticRule:  A rule providing static rules that always return the same result, regardless of input.
 * DirectMapRule:  A rule that return the same labels as the input labels.
 * ExpressionRule: A rule providing inline expression rules.
 * AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
 * WebhookRule: A rule providing a binding to a webserver following OAuth2.0 authentication protocol.
 */
export interface RouterRule {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind:
    | "direct-map-rule"
    | "expression-rule"
    | "azure-function-rule"
    | "static-rule"
    | "webhook-rule";
}

/** An attachment which attaches worker selectors to a job */
export interface WorkerSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind:
    | "conditional"
    | "pass-through"
    | "rule-engine"
    | "static"
    | "weighted-allocation-worker-selector";
}

/** The Communication Services error. */
export interface CommunicationErrorResponse {
  /** The Communication Services error. */
  error: CommunicationError;
}

/** The Communication Services error. */
export interface CommunicationError {
  /** The error code. */
  code: string;
  /** The error message. */
  message: string;
  /**
   * The error target.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly target?: string;
  /**
   * Further details about specific errors that led to this error.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly details?: CommunicationError[];
  /**
   * The inner error if any.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly innerError?: CommunicationError;
}

/** A paged collection of classification policies. */
export interface ClassificationPolicyCollection {
  value: ClassificationPolicyItem[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** Paged instance of ClassificationPolicy */
export interface ClassificationPolicyItem {
  /** A container for the rules that govern how jobs are classified. */
  classificationPolicy?: ClassificationPolicy;
  /** (Optional) The Concurrency Token. */
  etag?: string;
}

/** Policy governing how jobs are distributed to workers */
export interface DistributionPolicy {
  /**
   * The unique identifier of the policy.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** The human readable name of the policy. */
  name?: string;
  /** The number of seconds after which any offers created under this policy will be expired. */
  offerExpiresAfterSeconds?: number;
  /** Abstract base class for defining a distribution mode */
  mode?: DistributionModeUnion;
}

/** Abstract base class for defining a distribution mode */
export interface DistributionMode {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "best-worker" | "longest-idle" | "round-robin";
  /** Governs the minimum desired number of active concurrent offers a job can have. */
  minConcurrentOffers?: number;
  /** Governs the maximum number of active concurrent offers a job can have. */
  maxConcurrentOffers?: number;
  /**
   * (Optional)
   * If set to true, then router will match workers to jobs even if they don't match label selectors.
   * Warning: You may get workers that are not qualified for the job they are matched with if you set this
   * variable to true. This flag is intended more for temporary usage.
   * By default, set to false.
   */
  bypassSelectors?: boolean;
}

/** A paged collection of distribution policies. */
export interface DistributionPolicyCollection {
  value: DistributionPolicyItem[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** Paged instance of DistributionPolicy */
export interface DistributionPolicyItem {
  /** Policy governing how jobs are distributed to workers */
  distributionPolicy?: DistributionPolicy;
  /** (Optional) The Concurrency Token. */
  etag?: string;
}

/** A policy that defines actions to execute when exception are triggered. */
export interface ExceptionPolicy {
  /**
   * The Id of the exception policy
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** (Optional) The name of the exception policy. */
  name?: string;
  /** (Optional) A dictionary collection of exception rules on the exception policy. Key is the Id of each exception rule. */
  exceptionRules?: { [propertyName: string]: ExceptionRule };
}

/** A rule that defines actions to execute upon a specific trigger. */
export interface ExceptionRule {
  /** The trigger for this exception rule */
  trigger: ExceptionTriggerUnion;
  /** A dictionary collection of actions to perform once the exception is triggered. Key is the Id of each exception action. */
  actions: { [propertyName: string]: ExceptionActionUnion };
}

/** The trigger for this exception rule */
export interface ExceptionTrigger {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "queue-length" | "wait-time";
}

/** The action to take when the exception is triggered */
export interface ExceptionAction {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "cancel" | "manual-reclassify" | "reclassify";
}

/** A paged collection of exception policies. */
export interface ExceptionPolicyCollection {
  value: ExceptionPolicyItem[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** Paged instance of ExceptionPolicy */
export interface ExceptionPolicyItem {
  /** A policy that defines actions to execute when exception are triggered. */
  exceptionPolicy?: ExceptionPolicy;
  /** (Optional) The Concurrency Token. */
  etag?: string;
}

/** A unit of work to be routed */
export interface RouterJob {
  /**
   * The id of the job.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** Reference to an external parent context, eg. call ID. */
  channelReference?: string;
  /**
   * The status of the Job.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly status?: RouterJobStatus;
  /**
   * The time a job was queued in UTC.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly enqueuedAt?: Date;
  /** The channel identifier. eg. voice, chat, etc. */
  channelId?: string;
  /** The Id of the Classification policy used for classifying a job. */
  classificationPolicyId?: string;
  /** The Id of the Queue that this job is queued to. */
  queueId?: string;
  /** The priority of this job. */
  priority?: number;
  /** Reason code for cancelled or closed jobs. */
  dispositionCode?: string;
  /** A collection of manually specified label selectors, which a worker must satisfy in order to process this job. */
  requestedWorkerSelectors?: RouterWorkerSelector[];
  /**
   * A collection of label selectors attached by a classification policy, which a worker must satisfy in order to process this job.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly attachedWorkerSelectors?: RouterWorkerSelector[];
  /** A set of key/value pairs that are identifying attributes used by the rules engines to make decisions. */
  labels?: { [propertyName: string]: any };
  /**
   * A collection of the assignments of the job.
   * Key is AssignmentId.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly assignments?: { [propertyName: string]: RouterJobAssignment };
  /** A set of non-identifying attributes attached to this job */
  tags?: { [propertyName: string]: any };
  /** Notes attached to a job, sorted by timestamp */
  notes?: { [propertyName: string]: string };
  /**
   * If set, job will be scheduled to be enqueued at a given time
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly scheduledAt?: Date;
  matchingMode?: JobMatchingMode;
}

/** Describes a condition that must be met against a set of labels for worker selection */
export interface RouterWorkerSelector {
  /** The label key to query against */
  key: string;
  /** Describes how the value of the label is compared to the value defined on the label selector */
  labelOperator: LabelOperator;
  /** The value to compare against the actual label value with the given operator */
  value?: any;
  /** Describes how long this label selector is valid in seconds. */
  expiresAfterSeconds?: number;
  /** Pushes the job to the front of the queue as long as this selector is active. */
  expedite?: boolean;
  /**
   * The status of the worker selector.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly status?: RouterWorkerSelectorStatus;
  /**
   * The time at which this worker selector expires in UTC
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly expiresAt?: Date;
}

/** Assignment details of a job to a worker */
export interface RouterJobAssignment {
  /** The Id of the job assignment. */
  assignmentId: string;
  /** The Id of the Worker assigned to the job. */
  workerId?: string;
  /** The assignment time of the job in UTC. */
  assignedAt: Date;
  /** The time the job was marked as completed after being assigned in UTC. */
  completedAt?: Date;
  /** The time the job was marked as closed after being completed in UTC. */
  closedAt?: Date;
}

export interface JobMatchingMode {
  modeType?: JobMatchModeType;
  /** Anything */
  queueAndMatchMode?: any;
  scheduleAndSuspendMode?: ScheduleAndSuspendMode;
  /** Anything */
  suspendMode?: any;
}

export interface ScheduleAndSuspendMode {
  scheduleAt?: Date;
}

/** Request payload for deleting a job */
export interface CancelJobRequest {
  /** (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp. */
  note?: string;
  /**
   * Indicates the outcome of the job, populate this field with your own custom values.
   * If not provided, default value of "Cancelled" is set.
   */
  dispositionCode?: string;
}

/** Request payload for completing jobs */
export interface CompleteJobRequest {
  /** The assignment within the job to complete. */
  assignmentId: string;
  /** (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp. */
  note?: string;
}

/** Request payload for closing jobs */
export interface CloseJobRequest {
  /** The assignment within which the job is to be closed. */
  assignmentId: string;
  /** Indicates the outcome of the job, populate this field with your own custom values. */
  dispositionCode?: string;
  /**
   * If not provided, worker capacity is released immediately along with a JobClosedEvent notification.
   * If provided, worker capacity is released along with a JobClosedEvent notification at a future time in UTC.
   */
  closeAt?: Date;
  /** (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp. */
  note?: string;
}

/** A paged collection of jobs. */
export interface RouterJobCollection {
  value: RouterJobItem[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** Paged instance of RouterJob */
export interface RouterJobItem {
  /** A unit of work to be routed */
  job?: RouterJob;
  /** (Optional) The Concurrency Token. */
  etag?: string;
}

/** Position and estimated wait time for a job. */
export interface RouterJobPositionDetails {
  /** Id of the job these details are about. */
  jobId: string;
  /** Position of the job in question within that queue. */
  position: number;
  /** Id of the queue this job is enqueued in. */
  queueId: string;
  /** Length of the queue: total number of enqueued jobs. */
  queueLength: number;
  /** Estimated wait time of the job rounded up to the nearest minute */
  estimatedWaitTimeMinutes: number;
}

/** Request payload for unassigning a job. */
export interface UnassignJobRequest {
  /** If WaitForActivation is true, then the job is not queued for re-matching with a worker. */
  suspendMatching?: boolean;
}

/** Response payload after a job has been successfully unassigned. */
export interface UnassignJobResult {
  /** The Id of the job unassigned. */
  jobId: string;
  /** The number of times a job is unassigned. At a maximum 3. */
  unassignmentCount: number;
}

/** Response containing Id's for the worker, job, and assignment from an accepted offer */
export interface AcceptJobOfferResult {
  /** The assignment Id that assigns a worker that has accepted an offer to a job. */
  assignmentId: string;
  /** The Id of the job assigned. */
  jobId: string;
  /** The Id of the worker that has been assigned this job. */
  workerId: string;
}

/** Request payload for declining offers */
export interface DeclineJobOfferRequest {
  /**
   * If the RetryOfferAt is not provided, then this job will not be offered again to the worker who declined this job unless
   * the worker is de-registered and re-registered.  If a RetryOfferAt time is provided, then the job will be re-matched to
   * eligible workers at the retry time in UTC.  The worker that declined the job will also be eligible for the job at that time.
   */
  retryOfferAt?: Date;
}

/** A queue that can contain jobs to be routed. */
export interface RouterQueue {
  /**
   * The Id of this queue
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** The name of this queue. */
  name?: string;
  /** The ID of the distribution policy that will determine how a job is distributed to workers. */
  distributionPolicyId?: string;
  /** A set of key/value pairs that are identifying attributes used by the rules engines to make decisions. */
  labels?: { [propertyName: string]: any };
  /** (Optional) The ID of the exception policy that determines various job escalation rules. */
  exceptionPolicyId?: string;
}

/** A paged collection of queues. */
export interface RouterQueueCollection {
  value: RouterQueueItem[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** Paged instance of RouterQueue */
export interface RouterQueueItem {
  /** A queue that can contain jobs to be routed. */
  queue?: RouterQueue;
  /** (Optional) The Concurrency Token. */
  etag?: string;
}

/** Statistics for the queue */
export interface RouterQueueStatistics {
  /** Id of the queue these details are about. */
  queueId: string;
  /** Length of the queue: total number of enqueued jobs. */
  length: number;
  /** The estimated wait time of this queue rounded up to the nearest minute, grouped by job priority */
  estimatedWaitTimeMinutes?: { [propertyName: string]: number };
  /** The wait time of the job that has been enqueued in this queue for the longest. */
  longestJobWaitTimeMinutes?: number;
}

/** An entity for jobs to be routed to */
export interface RouterWorker {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly id?: string;
  /**
   * The current state of the worker.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly state?: RouterWorkerState;
  /** The queue(s) that this worker can receive work from. */
  queueAssignments?: { [propertyName: string]: any };
  /** The total capacity score this worker has to manage multiple concurrent jobs. */
  totalCapacity?: number;
  /** A set of key/value pairs that are identifying attributes used by the rules engines to make decisions. */
  labels?: { [propertyName: string]: any };
  /** A set of non-identifying attributes attached to this worker. */
  tags?: { [propertyName: string]: any };
  /** The channel(s) this worker can handle and their impact on the workers capacity. */
  channelConfigurations?: { [propertyName: string]: ChannelConfiguration };
  /**
   * A list of active offers issued to this worker.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly offers?: RouterJobOffer[];
  /**
   * A list of assigned jobs attached to this worker.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly assignedJobs?: RouterWorkerAssignment[];
  /**
   * A value indicating the workers capacity. A value of '1' means all capacity is consumed. A value of '0' means no capacity is currently consumed.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly loadRatio?: number;
  /** A flag indicating this worker is open to receive offers or not. */
  availableForOffers?: boolean;
}

/** Represents the capacity a job in this channel will consume from a worker */
export interface ChannelConfiguration {
  /** The amount of capacity that an instance of a job of this channel will consume of the total worker capacity. */
  capacityCostPerJob: number;
  /** The maximum number of jobs that can be supported concurrently for this channel. */
  maxNumberOfJobs?: number;
}

/** An offer of a job to a worker */
export interface RouterJobOffer {
  /** The Id of the offer. */
  offerId: string;
  /** The Id of the job. */
  jobId: string;
  /** The capacity cost consumed by the job offer. */
  capacityCost: number;
  /** The time the offer was created in UTC. */
  offeredAt?: Date;
  /** The time that the offer will expire in UTC. */
  expiresAt?: Date;
}

/** The assignment for a worker to a job */
export interface RouterWorkerAssignment {
  /** The Id of the assignment. */
  assignmentId: string;
  /** The Id of the Job assigned. */
  jobId: string;
  /** The amount of capacity this assignment has consumed on the worker. */
  capacityCost: number;
  /** The assignment time of the job in UTC. */
  assignedAt: Date;
}

/** A paged collection of workers. */
export interface RouterWorkerCollection {
  value: RouterWorkerItem[];
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
}

/** Paged instance of RouterWorker */
export interface RouterWorkerItem {
  /** An entity for jobs to be routed to */
  worker?: RouterWorker;
  /** (Optional) The Concurrency Token. */
  etag?: string;
}

/** Encapsulates all options that can be passed as parameters for scoring rule with BestWorkerMode */
export interface ScoringRuleOptions {
  /** (Optional) Set batch size when AllowScoringBatchOfWorkers is set to true. Defaults to 20 if not configured. */
  batchSize?: number;
  /**
   * (Optional) List of extra parameters from the job that will be sent as part of the payload to scoring rule.
   * If not set, the job's labels (sent in the payload as `job`) and the job's worker selectors (sent in the payload as `selectors`)
   * are added to the payload of the scoring rule by default.
   * Note: Worker labels are always sent with scoring payload.
   */
  scoringParameters?: ScoringRuleParameterSelector[];
  /**
   * (Optional)
   * If set to true, will score workers in batches, and the parameter name of the worker labels will be sent as `workers`.
   * By default, set to false and the parameter name for the worker labels will be sent as `worker`.
   * Note: If enabled, use BatchSize to set batch size.
   */
  allowScoringBatchOfWorkers?: boolean;
  /**
   * (Optional)
   * If false, will sort scores by ascending order. By default, set to true.
   */
  descendingOrder?: boolean;
}

/** Describes a condition that must be met against a set of labels for queue selection */
export interface RouterQueueSelector {
  /** The label key to query against */
  key: string;
  /** Describes how the value of the label is compared to the value defined on the label selector */
  labelOperator: LabelOperator;
  /** The value to compare against the actual label value with the given operator */
  value?: any;
}

/** Credentials used to access Azure function rule */
export interface FunctionRouterRuleCredential {
  /** (Optional) Access key scoped to a particular function */
  functionKey?: string;
  /**
   * (Optional) Access key scoped to a Azure Function app.
   * This key grants access to all functions under the app.
   */
  appKey?: string;
  /**
   * (Optional) Client id, when AppKey is provided
   * In context of Azure function, this is usually the name of the key
   */
  clientId?: string;
}

/**
 * OAuth2.0 Credentials used to Contoso's Authorization server.
 * Reference: https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/
 */
export interface Oauth2ClientCredential {
  /** ClientId for Contoso Authorization server. */
  clientId?: string;
  /** Client secret for Contoso Authorization server. */
  clientSecret?: string;
}

/** Contains the weight percentage and queue selectors to be applied if selected for weighted distributions. */
export interface QueueWeightedAllocation {
  /** The percentage of this weight, expressed as a fraction of 1. */
  weight: number;
  /** A collection of queue selectors that will be applied if this allocation is selected. */
  queueSelectors: RouterQueueSelector[];
}

/** Contains the weight percentage and worker selectors to be applied if selected for weighted distributions. */
export interface WorkerWeightedAllocation {
  /** The percentage of this weight, expressed as a fraction of 1. */
  weight: number;
  /** A collection of worker selectors that will be applied if this allocation is selected. */
  workerSelectors: RouterWorkerSelector[];
}

/** Describes a set of queue selectors that will be attached if the given condition resolves to true */
export interface ConditionalQueueSelectorAttachment
  extends QueueSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "conditional";
  /**
   * A rule of one of the following types:
   *
   * StaticRule:  A rule providing static rules that always return the same result, regardless of input.
   * DirectMapRule:  A rule that return the same labels as the input labels.
   * ExpressionRule: A rule providing inline expression rules.
   * AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
   * WebhookRule: A rule providing a binding to a webserver following OAuth2.0 authentication protocol.
   */
  condition: RouterRuleUnion;
  /** The queue selectors to attach */
  queueSelectors: RouterQueueSelector[];
}

/** Attaches a queue selector where the value is passed through from the job label with the same key */
export interface PassThroughQueueSelectorAttachment
  extends QueueSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "pass-through";
  /** The label key to query against */
  key: string;
  /** Describes how the value of the label is compared to the value pass through */
  labelOperator: LabelOperator;
}

/** Attaches queue selectors to a job when the RouterRule is resolved */
export interface RuleEngineQueueSelectorAttachment
  extends QueueSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "rule-engine";
  /**
   * A rule of one of the following types:
   *
   * StaticRule:  A rule providing static rules that always return the same result, regardless of input.
   * DirectMapRule:  A rule that return the same labels as the input labels.
   * ExpressionRule: A rule providing inline expression rules.
   * AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
   * WebhookRule: A rule providing a binding to a webserver following OAuth2.0 authentication protocol.
   */
  rule: RouterRuleUnion;
}

/** Describes a queue selector that will be attached to the job */
export interface StaticQueueSelectorAttachment extends QueueSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "static";
  /** Describes a condition that must be met against a set of labels for queue selection */
  queueSelector: RouterQueueSelector;
}

/** Describes multiple sets of queue selectors, of which one will be selected and attached according to a weighting */
export interface WeightedAllocationQueueSelectorAttachment
  extends QueueSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "weighted-allocation-queue-selector";
  /** A collection of percentage based weighted allocations. */
  allocations: QueueWeightedAllocation[];
}

/** A rule that return the same labels as the input labels. */
export interface DirectMapRouterRule extends RouterRule {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "direct-map-rule";
}

/** A rule providing inline expression rules. */
export interface ExpressionRouterRule extends RouterRule {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "expression-rule";
  /** The expression language to compile to and execute */
  language?: ExpressionRouterRuleLanguage;
  /** The string containing the expression to evaluate. Should contain return statement with calculated values. */
  expression: string;
}

/** A rule providing a binding to an HTTP Triggered Azure Function. */
export interface FunctionRouterRule extends RouterRule {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "azure-function-rule";
  /** URL for Azure Function */
  functionUri: string;
  /** Credentials used to access Azure function rule */
  credential?: FunctionRouterRuleCredential;
}

/** A rule providing static rules that always return the same result, regardless of input. */
export interface StaticRouterRule extends RouterRule {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "static-rule";
  /** The static value this rule always returns. */
  value?: any;
}

/** A rule providing a binding to an external web server. */
export interface WebhookRouterRule extends RouterRule {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "webhook-rule";
  /** Uri for Authorization Server. */
  authorizationServerUri?: string;
  /**
   * OAuth2.0 Credentials used to Contoso's Authorization server.
   * Reference: https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/
   */
  clientCredential?: Oauth2ClientCredential;
  /** Uri for Contoso's Web Server. */
  webhookUri?: string;
}

/** Describes a set of worker selectors that will be attached if the given condition resolves to true */
export interface ConditionalWorkerSelectorAttachment
  extends WorkerSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "conditional";
  /**
   * A rule of one of the following types:
   *
   * StaticRule:  A rule providing static rules that always return the same result, regardless of input.
   * DirectMapRule:  A rule that return the same labels as the input labels.
   * ExpressionRule: A rule providing inline expression rules.
   * AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
   * WebhookRule: A rule providing a binding to a webserver following OAuth2.0 authentication protocol.
   */
  condition: RouterRuleUnion;
  /** The worker selectors to attach */
  workerSelectors: RouterWorkerSelector[];
}

/** Attaches a worker selector where the value is passed through from the job label with the same key */
export interface PassThroughWorkerSelectorAttachment
  extends WorkerSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "pass-through";
  /** The label key to query against */
  key: string;
  /** Describes how the value of the label is compared to the value pass through */
  labelOperator: LabelOperator;
  /** Describes how long the attached label selector is valid in seconds. */
  expiresAfterSeconds?: number;
}

/** Attaches worker selectors to a job when a RouterRule is resolved */
export interface RuleEngineWorkerSelectorAttachment
  extends WorkerSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "rule-engine";
  /**
   * A rule of one of the following types:
   *
   * StaticRule:  A rule providing static rules that always return the same result, regardless of input.
   * DirectMapRule:  A rule that return the same labels as the input labels.
   * ExpressionRule: A rule providing inline expression rules.
   * AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
   * WebhookRule: A rule providing a binding to a webserver following OAuth2.0 authentication protocol.
   */
  rule: RouterRuleUnion;
}

/** Describes a worker selector that will be attached to the job */
export interface StaticWorkerSelectorAttachment
  extends WorkerSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "static";
  /** Describes a condition that must be met against a set of labels for worker selection */
  workerSelector: RouterWorkerSelector;
}

/** Describes multiple sets of worker selectors, of which one will be selected and attached according to a weighting */
export interface WeightedAllocationWorkerSelectorAttachment
  extends WorkerSelectorAttachment {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "weighted-allocation-worker-selector";
  /** A collection of percentage based weighted allocations. */
  allocations: WorkerWeightedAllocation[];
}

/** Jobs are distributed to the worker with the strongest abilities available. */
export interface BestWorkerMode extends DistributionMode {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "best-worker";
  /**
   * A rule of one of the following types:
   *
   * StaticRule:  A rule providing static rules that always return the same result, regardless of input.
   * DirectMapRule:  A rule that return the same labels as the input labels.
   * ExpressionRule: A rule providing inline expression rules.
   * AzureFunctionRule: A rule providing a binding to an HTTP Triggered Azure Function.
   * WebhookRule: A rule providing a binding to a webserver following OAuth2.0 authentication protocol.
   */
  scoringRule?: RouterRuleUnion;
  /** Encapsulates all options that can be passed as parameters for scoring rule with BestWorkerMode */
  scoringRuleOptions?: ScoringRuleOptions;
}

/** Jobs are directed to the worker who has been idle longest. */
export interface LongestIdleMode extends DistributionMode {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "longest-idle";
}

/** Jobs are distributed in order to workers, starting with the worker that is after the last worker to receive a job. */
export interface RoundRobinMode extends DistributionMode {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "round-robin";
}

/** Trigger for an exception action on exceeding queue length */
export interface QueueLengthExceptionTrigger extends ExceptionTrigger {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "queue-length";
  /** Threshold of number of jobs ahead in the queue to for this trigger to fire. */
  threshold: number;
}

/** Trigger for an exception action on exceeding wait time */
export interface WaitTimeExceptionTrigger extends ExceptionTrigger {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "wait-time";
  /** Threshold for wait time for this trigger. */
  thresholdSeconds: number;
}

/** An action that marks a job as cancelled */
export interface CancelExceptionAction extends ExceptionAction {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "cancel";
  /** (Optional) A note that will be appended to the jobs' Notes collection with th current timestamp. */
  note?: string;
  /** (Optional) Indicates the outcome of the job, populate this field with your own custom values. */
  dispositionCode?: string;
}

/** An action that manually reclassifies a job by providing the queue, priority and worker selectors. */
export interface ManualReclassifyExceptionAction extends ExceptionAction {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "manual-reclassify";
  /** Updated QueueId. */
  queueId?: string;
  /** Updated Priority. */
  priority?: number;
  /** Updated WorkerSelectors. */
  workerSelectors?: RouterWorkerSelector[];
}

/** An action that modifies labels on a job and then reclassifies it */
export interface ReclassifyExceptionAction extends ExceptionAction {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "reclassify";
  /** (optional) The new classification policy that will determine queue, priority and worker selectors. */
  classificationPolicyId?: string;
  /** (optional) Dictionary containing the labels to update (or add if not existing) in key-value pairs */
  labelsToUpsert?: { [propertyName: string]: any };
}

/** Known values of {@link RouterJobStatus} that the service accepts. */
export enum KnownRouterJobStatus {
  /** PendingClassification */
  PendingClassification = "pendingClassification",
  /** Queued */
  Queued = "queued",
  /** Assigned */
  Assigned = "assigned",
  /** Completed */
  Completed = "completed",
  /** Closed */
  Closed = "closed",
  /** Cancelled */
  Cancelled = "cancelled",
  /** ClassificationFailed */
  ClassificationFailed = "classificationFailed",
  /** Created */
  Created = "created",
  /** PendingSchedule */
  PendingSchedule = "pendingSchedule",
  /** Scheduled */
  Scheduled = "scheduled",
  /** ScheduleFailed */
  ScheduleFailed = "scheduleFailed",
  /** WaitingForActivation */
  WaitingForActivation = "waitingForActivation"
}

/**
 * Defines values for RouterJobStatus. \
 * {@link KnownRouterJobStatus} can be used interchangeably with RouterJobStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **pendingClassification** \
 * **queued** \
 * **assigned** \
 * **completed** \
 * **closed** \
 * **cancelled** \
 * **classificationFailed** \
 * **created** \
 * **pendingSchedule** \
 * **scheduled** \
 * **scheduleFailed** \
 * **waitingForActivation**
 */
export type RouterJobStatus = string;

/** Known values of {@link LabelOperator} that the service accepts. */
export enum KnownLabelOperator {
  /** Equal */
  Equal = "equal",
  /** NotEqual */
  NotEqual = "notEqual",
  /** LessThan */
  LessThan = "lessThan",
  /** LessThanEqual */
  LessThanEqual = "lessThanEqual",
  /** GreaterThan */
  GreaterThan = "greaterThan",
  /** GreaterThanEqual */
  GreaterThanEqual = "greaterThanEqual"
}

/**
 * Defines values for LabelOperator. \
 * {@link KnownLabelOperator} can be used interchangeably with LabelOperator,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **equal** \
 * **notEqual** \
 * **lessThan** \
 * **lessThanEqual** \
 * **greaterThan** \
 * **greaterThanEqual**
 */
export type LabelOperator = string;

/** Known values of {@link RouterWorkerSelectorStatus} that the service accepts. */
export enum KnownRouterWorkerSelectorStatus {
  /** Active */
  Active = "active",
  /** Expired */
  Expired = "expired"
}

/**
 * Defines values for RouterWorkerSelectorStatus. \
 * {@link KnownRouterWorkerSelectorStatus} can be used interchangeably with RouterWorkerSelectorStatus,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **active** \
 * **expired**
 */
export type RouterWorkerSelectorStatus = string;

/** Known values of {@link JobMatchModeType} that the service accepts. */
export enum KnownJobMatchModeType {
  /** QueueAndMatchMode */
  QueueAndMatchMode = "queueAndMatchMode",
  /** ScheduleAndSuspendMode */
  ScheduleAndSuspendMode = "scheduleAndSuspendMode",
  /** SuspendMode */
  SuspendMode = "suspendMode"
}

/**
 * Defines values for JobMatchModeType. \
 * {@link KnownJobMatchModeType} can be used interchangeably with JobMatchModeType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **queueAndMatchMode** \
 * **scheduleAndSuspendMode** \
 * **suspendMode**
 */
export type JobMatchModeType = string;

/** Known values of {@link RouterJobStatusSelector} that the service accepts. */
export enum KnownRouterJobStatusSelector {
  /** All */
  All = "all",
  /** PendingClassification */
  PendingClassification = "pendingClassification",
  /** Queued */
  Queued = "queued",
  /** Assigned */
  Assigned = "assigned",
  /** Completed */
  Completed = "completed",
  /** Closed */
  Closed = "closed",
  /** Cancelled */
  Cancelled = "cancelled",
  /** ClassificationFailed */
  ClassificationFailed = "classificationFailed",
  /** Created */
  Created = "created",
  /** PendingSchedule */
  PendingSchedule = "pendingSchedule",
  /** Scheduled */
  Scheduled = "scheduled",
  /** ScheduleFailed */
  ScheduleFailed = "scheduleFailed",
  /** WaitingForActivation */
  WaitingForActivation = "waitingForActivation",
  /** Active */
  Active = "active"
}

/**
 * Defines values for RouterJobStatusSelector. \
 * {@link KnownRouterJobStatusSelector} can be used interchangeably with RouterJobStatusSelector,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **all** \
 * **pendingClassification** \
 * **queued** \
 * **assigned** \
 * **completed** \
 * **closed** \
 * **cancelled** \
 * **classificationFailed** \
 * **created** \
 * **pendingSchedule** \
 * **scheduled** \
 * **scheduleFailed** \
 * **waitingForActivation** \
 * **active**
 */
export type RouterJobStatusSelector = string;

/** Known values of {@link RouterWorkerState} that the service accepts. */
export enum KnownRouterWorkerState {
  /** Active */
  Active = "active",
  /** Draining */
  Draining = "draining",
  /** Inactive */
  Inactive = "inactive"
}

/**
 * Defines values for RouterWorkerState. \
 * {@link KnownRouterWorkerState} can be used interchangeably with RouterWorkerState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **active** \
 * **draining** \
 * **inactive**
 */
export type RouterWorkerState = string;

/** Known values of {@link RouterWorkerStateSelector} that the service accepts. */
export enum KnownRouterWorkerStateSelector {
  /** Active */
  Active = "active",
  /** Draining */
  Draining = "draining",
  /** Inactive */
  Inactive = "inactive",
  /** All */
  All = "all"
}

/**
 * Defines values for RouterWorkerStateSelector. \
 * {@link KnownRouterWorkerStateSelector} can be used interchangeably with RouterWorkerStateSelector,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **active** \
 * **draining** \
 * **inactive** \
 * **all**
 */
export type RouterWorkerStateSelector = string;

/** Known values of {@link ScoringRuleParameterSelector} that the service accepts. */
export enum KnownScoringRuleParameterSelector {
  /** JobLabels */
  JobLabels = "jobLabels",
  /** WorkerSelectors */
  WorkerSelectors = "workerSelectors"
}

/**
 * Defines values for ScoringRuleParameterSelector. \
 * {@link KnownScoringRuleParameterSelector} can be used interchangeably with ScoringRuleParameterSelector,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **jobLabels** \
 * **workerSelectors**
 */
export type ScoringRuleParameterSelector = string;

/** Known values of {@link ExpressionRouterRuleLanguage} that the service accepts. */
export enum KnownExpressionRouterRuleLanguage {
  /** PowerFx */
  PowerFx = "powerFx"
}

/**
 * Defines values for ExpressionRouterRuleLanguage. \
 * {@link KnownExpressionRouterRuleLanguage} can be used interchangeably with ExpressionRouterRuleLanguage,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **powerFx**
 */
export type ExpressionRouterRuleLanguage = string;

/** Optional parameters. */
export interface JobRouterAdministrationUpsertClassificationPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the upsertClassificationPolicy operation. */
export type JobRouterAdministrationUpsertClassificationPolicyResponse = ClassificationPolicy;

/** Optional parameters. */
export interface JobRouterAdministrationGetClassificationPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getClassificationPolicy operation. */
export type JobRouterAdministrationGetClassificationPolicyResponse = ClassificationPolicy;

/** Optional parameters. */
export interface JobRouterAdministrationDeleteClassificationPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface JobRouterAdministrationListClassificationPoliciesOptionalParams
  extends coreClient.OperationOptions {
  /** Maximum page size */
  maxpagesize?: number;
}

/** Contains response data for the listClassificationPolicies operation. */
export type JobRouterAdministrationListClassificationPoliciesResponse = ClassificationPolicyCollection;

/** Optional parameters. */
export interface JobRouterAdministrationUpsertDistributionPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the upsertDistributionPolicy operation. */
export type JobRouterAdministrationUpsertDistributionPolicyResponse = DistributionPolicy;

/** Optional parameters. */
export interface JobRouterAdministrationGetDistributionPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getDistributionPolicy operation. */
export type JobRouterAdministrationGetDistributionPolicyResponse = DistributionPolicy;

/** Optional parameters. */
export interface JobRouterAdministrationDeleteDistributionPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface JobRouterAdministrationListDistributionPoliciesOptionalParams
  extends coreClient.OperationOptions {
  /** Maximum page size */
  maxpagesize?: number;
}

/** Contains response data for the listDistributionPolicies operation. */
export type JobRouterAdministrationListDistributionPoliciesResponse = DistributionPolicyCollection;

/** Optional parameters. */
export interface JobRouterAdministrationUpsertExceptionPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the upsertExceptionPolicy operation. */
export type JobRouterAdministrationUpsertExceptionPolicyResponse = ExceptionPolicy;

/** Optional parameters. */
export interface JobRouterAdministrationGetExceptionPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getExceptionPolicy operation. */
export type JobRouterAdministrationGetExceptionPolicyResponse = ExceptionPolicy;

/** Optional parameters. */
export interface JobRouterAdministrationDeleteExceptionPolicyOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface JobRouterAdministrationListExceptionPoliciesOptionalParams
  extends coreClient.OperationOptions {
  /** Number of objects to return per page */
  maxpagesize?: number;
}

/** Contains response data for the listExceptionPolicies operation. */
export type JobRouterAdministrationListExceptionPoliciesResponse = ExceptionPolicyCollection;

/** Optional parameters. */
export interface JobRouterAdministrationUpsertQueueOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the upsertQueue operation. */
export type JobRouterAdministrationUpsertQueueResponse = RouterQueue;

/** Optional parameters. */
export interface JobRouterAdministrationGetQueueOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getQueue operation. */
export type JobRouterAdministrationGetQueueResponse = RouterQueue;

/** Optional parameters. */
export interface JobRouterAdministrationDeleteQueueOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface JobRouterAdministrationListQueuesOptionalParams
  extends coreClient.OperationOptions {
  /** Number of objects to return per page */
  maxpagesize?: number;
}

/** Contains response data for the listQueues operation. */
export type JobRouterAdministrationListQueuesResponse = RouterQueueCollection;

/** Optional parameters. */
export interface JobRouterAdministrationListClassificationPoliciesNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listClassificationPoliciesNext operation. */
export type JobRouterAdministrationListClassificationPoliciesNextResponse = ClassificationPolicyCollection;

/** Optional parameters. */
export interface JobRouterAdministrationListDistributionPoliciesNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listDistributionPoliciesNext operation. */
export type JobRouterAdministrationListDistributionPoliciesNextResponse = DistributionPolicyCollection;

/** Optional parameters. */
export interface JobRouterAdministrationListExceptionPoliciesNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listExceptionPoliciesNext operation. */
export type JobRouterAdministrationListExceptionPoliciesNextResponse = ExceptionPolicyCollection;

/** Optional parameters. */
export interface JobRouterAdministrationListQueuesNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listQueuesNext operation. */
export type JobRouterAdministrationListQueuesNextResponse = RouterQueueCollection;

/** Optional parameters. */
export interface JobRouterUpsertJobOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the upsertJob operation. */
export type JobRouterUpsertJobResponse = RouterJob;

/** Optional parameters. */
export interface JobRouterGetJobOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getJob operation. */
export type JobRouterGetJobResponse = RouterJob;

/** Optional parameters. */
export interface JobRouterDeleteJobOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface JobRouterReclassifyJobActionOptionalParams
  extends coreClient.OperationOptions {
  /** Request object for reclassifying a job. */
  reclassifyJobRequest?: any;
}

/** Contains response data for the reclassifyJobAction operation. */
export type JobRouterReclassifyJobActionResponse = {
  /** The parsed response body. */
  body: any;
};

/** Optional parameters. */
export interface JobRouterCancelJobActionOptionalParams
  extends coreClient.OperationOptions {
  /** (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp. */
  note?: string;
  /**
   * Indicates the outcome of the job, populate this field with your own custom values.
   * If not provided, default value of "Cancelled" is set.
   */
  dispositionCode?: string;
}

/** Contains response data for the cancelJobAction operation. */
export type JobRouterCancelJobActionResponse = {
  /** The parsed response body. */
  body: any;
};

/** Optional parameters. */
export interface JobRouterCompleteJobActionOptionalParams
  extends coreClient.OperationOptions {
  /** (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp. */
  note?: string;
}

/** Contains response data for the completeJobAction operation. */
export type JobRouterCompleteJobActionResponse = {
  /** The parsed response body. */
  body: any;
};

/** Optional parameters. */
export interface JobRouterCloseJobActionOptionalParams
  extends coreClient.OperationOptions {
  /** Indicates the outcome of the job, populate this field with your own custom values. */
  dispositionCode?: string;
  /**
   * If not provided, worker capacity is released immediately along with a JobClosedEvent notification.
   * If provided, worker capacity is released along with a JobClosedEvent notification at a future time in UTC.
   */
  closeAt?: Date;
  /** (Optional) A note that will be appended to the jobs' Notes collection with the current timestamp. */
  note?: string;
}

/** Contains response data for the closeJobAction operation. */
export type JobRouterCloseJobActionResponse = {
  /** The parsed response body. */
  body: any;
};

/** Optional parameters. */
export interface JobRouterListJobsOptionalParams
  extends coreClient.OperationOptions {
  /** Number of objects to return per page */
  maxpagesize?: number;
  /** If specified, filter jobs by status. */
  status?: RouterJobStatusSelector;
  /** If specified, filter jobs by queue. */
  queueId?: string;
  /** If specified, filter jobs by channel. */
  channelId?: string;
  /** If specified, filter jobs by classificationPolicy. */
  classificationPolicyId?: string;
  /** If specified, filter on jobs that was scheduled before or at given timestamp. Range: (-Inf, scheduledBefore] */
  scheduledBefore?: Date;
  /** If specified, filter on jobs that was scheduled at or after given value. Range: [scheduledAfter, +Inf). */
  scheduledAfter?: Date;
}

/** Contains response data for the listJobs operation. */
export type JobRouterListJobsResponse = RouterJobCollection;

/** Optional parameters. */
export interface JobRouterGetInQueuePositionOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getInQueuePosition operation. */
export type JobRouterGetInQueuePositionResponse = RouterJobPositionDetails;

/** Optional parameters. */
export interface JobRouterUnassignJobActionOptionalParams
  extends coreClient.OperationOptions {
  /** Request body for unassign route */
  unassignJobRequest?: UnassignJobRequest;
}

/** Contains response data for the unassignJobAction operation. */
export type JobRouterUnassignJobActionResponse = UnassignJobResult;

/** Optional parameters. */
export interface JobRouterAcceptJobActionOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the acceptJobAction operation. */
export type JobRouterAcceptJobActionResponse = AcceptJobOfferResult;

/** Optional parameters. */
export interface JobRouterDeclineJobActionOptionalParams
  extends coreClient.OperationOptions {
  /** Request model for declining offer */
  declineJobOfferRequest?: DeclineJobOfferRequest;
}

/** Contains response data for the declineJobAction operation. */
export type JobRouterDeclineJobActionResponse = {
  /** The parsed response body. */
  body: any;
};

/** Optional parameters. */
export interface JobRouterGetQueueStatisticsOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getQueueStatistics operation. */
export type JobRouterGetQueueStatisticsResponse = RouterQueueStatistics;

/** Optional parameters. */
export interface JobRouterUpsertWorkerOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the upsertWorker operation. */
export type JobRouterUpsertWorkerResponse = RouterWorker;

/** Optional parameters. */
export interface JobRouterGetWorkerOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getWorker operation. */
export type JobRouterGetWorkerResponse = RouterWorker;

/** Optional parameters. */
export interface JobRouterDeleteWorkerOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface JobRouterListWorkersOptionalParams
  extends coreClient.OperationOptions {
  /** Number of objects to return per page */
  maxpagesize?: number;
  /** If specified, select workers who are assigned to this queue */
  queueId?: string;
  /** If specified, select workers who have a channel configuration with this channel */
  channelId?: string;
  /** If specified, select workers by worker state. */
  state?: RouterWorkerStateSelector;
  /**
   * If set to true, select only workers who have capacity for the channel specified by `channelId` or for any channel
   *             if `channelId` not specified. If set to false, then will return all workers including workers without any capacity for jobs. Defaults to false.
   */
  hasCapacity?: boolean;
}

/** Contains response data for the listWorkers operation. */
export type JobRouterListWorkersResponse = RouterWorkerCollection;

/** Optional parameters. */
export interface JobRouterListJobsNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listJobsNext operation. */
export type JobRouterListJobsNextResponse = RouterJobCollection;

/** Optional parameters. */
export interface JobRouterListWorkersNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listWorkersNext operation. */
export type JobRouterListWorkersNextResponse = RouterWorkerCollection;

/** Optional parameters. */
export interface JobRouterApiClientOptionalParams
  extends coreClient.ServiceClientOptions {
  /** Api Version */
  apiVersion?: string;
  /** Overrides client endpoint. */
  endpoint?: string;
}
