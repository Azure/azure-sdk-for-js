/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { tracingClient } from "../tracing";
import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { setContinuationToken } from "../pagingHelper";
import { JobRouterAdministration } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { JobRouterApiClient } from "../jobRouterApiClient";
import {
  ClassificationPolicyItem,
  JobRouterAdministrationListClassificationPoliciesNextOptionalParams,
  JobRouterAdministrationListClassificationPoliciesOptionalParams,
  JobRouterAdministrationListClassificationPoliciesResponse,
  DistributionPolicyItem,
  JobRouterAdministrationListDistributionPoliciesNextOptionalParams,
  JobRouterAdministrationListDistributionPoliciesOptionalParams,
  JobRouterAdministrationListDistributionPoliciesResponse,
  ExceptionPolicyItem,
  JobRouterAdministrationListExceptionPoliciesNextOptionalParams,
  JobRouterAdministrationListExceptionPoliciesOptionalParams,
  JobRouterAdministrationListExceptionPoliciesResponse,
  RouterQueueItem,
  JobRouterAdministrationListQueuesNextOptionalParams,
  JobRouterAdministrationListQueuesOptionalParams,
  JobRouterAdministrationListQueuesResponse,
  ClassificationPolicy,
  JobRouterAdministrationUpsertClassificationPolicyOptionalParams,
  JobRouterAdministrationUpsertClassificationPolicyResponse,
  JobRouterAdministrationGetClassificationPolicyOptionalParams,
  JobRouterAdministrationGetClassificationPolicyResponse,
  JobRouterAdministrationDeleteClassificationPolicyOptionalParams,
  DistributionPolicy,
  JobRouterAdministrationUpsertDistributionPolicyOptionalParams,
  JobRouterAdministrationUpsertDistributionPolicyResponse,
  JobRouterAdministrationGetDistributionPolicyOptionalParams,
  JobRouterAdministrationGetDistributionPolicyResponse,
  JobRouterAdministrationDeleteDistributionPolicyOptionalParams,
  ExceptionPolicy,
  JobRouterAdministrationUpsertExceptionPolicyOptionalParams,
  JobRouterAdministrationUpsertExceptionPolicyResponse,
  JobRouterAdministrationGetExceptionPolicyOptionalParams,
  JobRouterAdministrationGetExceptionPolicyResponse,
  JobRouterAdministrationDeleteExceptionPolicyOptionalParams,
  RouterQueue,
  JobRouterAdministrationUpsertQueueOptionalParams,
  JobRouterAdministrationUpsertQueueResponse,
  JobRouterAdministrationGetQueueOptionalParams,
  JobRouterAdministrationGetQueueResponse,
  JobRouterAdministrationDeleteQueueOptionalParams,
  JobRouterAdministrationListClassificationPoliciesNextResponse,
  JobRouterAdministrationListDistributionPoliciesNextResponse,
  JobRouterAdministrationListExceptionPoliciesNextResponse,
  JobRouterAdministrationListQueuesNextResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing JobRouterAdministration operations. */
export class JobRouterAdministrationImpl implements JobRouterAdministration {
  private readonly client: JobRouterApiClient;

  /**
   * Initialize a new instance of the class JobRouterAdministration class.
   * @param client Reference to the service client
   */
  constructor(client: JobRouterApiClient) {
    this.client = client;
  }

  /**
   * Retrieves existing classification policies
   * @param options The options parameters.
   */
  public listClassificationPolicies(
    options?: JobRouterAdministrationListClassificationPoliciesOptionalParams
  ): PagedAsyncIterableIterator<ClassificationPolicyItem> {
    const iter = this.listClassificationPoliciesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listClassificationPoliciesPagingPage(options, settings);
      }
    };
  }

  private async *listClassificationPoliciesPagingPage(
    options?: JobRouterAdministrationListClassificationPoliciesOptionalParams,
    settings?: PageSettings
  ): AsyncIterableIterator<ClassificationPolicyItem[]> {
    let result: JobRouterAdministrationListClassificationPoliciesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listClassificationPolicies(options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listClassificationPoliciesNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listClassificationPoliciesPagingAll(
    options?: JobRouterAdministrationListClassificationPoliciesOptionalParams
  ): AsyncIterableIterator<ClassificationPolicyItem> {
    for await (const page of this.listClassificationPoliciesPagingPage(
      options
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves existing distribution policies
   * @param options The options parameters.
   */
  public listDistributionPolicies(
    options?: JobRouterAdministrationListDistributionPoliciesOptionalParams
  ): PagedAsyncIterableIterator<DistributionPolicyItem> {
    const iter = this.listDistributionPoliciesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listDistributionPoliciesPagingPage(options, settings);
      }
    };
  }

  private async *listDistributionPoliciesPagingPage(
    options?: JobRouterAdministrationListDistributionPoliciesOptionalParams,
    settings?: PageSettings
  ): AsyncIterableIterator<DistributionPolicyItem[]> {
    let result: JobRouterAdministrationListDistributionPoliciesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listDistributionPolicies(options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listDistributionPoliciesNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listDistributionPoliciesPagingAll(
    options?: JobRouterAdministrationListDistributionPoliciesOptionalParams
  ): AsyncIterableIterator<DistributionPolicyItem> {
    for await (const page of this.listDistributionPoliciesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Retrieves existing exception policies
   * @param options The options parameters.
   */
  public listExceptionPolicies(
    options?: JobRouterAdministrationListExceptionPoliciesOptionalParams
  ): PagedAsyncIterableIterator<ExceptionPolicyItem> {
    const iter = this.listExceptionPoliciesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listExceptionPoliciesPagingPage(options, settings);
      }
    };
  }

  private async *listExceptionPoliciesPagingPage(
    options?: JobRouterAdministrationListExceptionPoliciesOptionalParams,
    settings?: PageSettings
  ): AsyncIterableIterator<ExceptionPolicyItem[]> {
    let result: JobRouterAdministrationListExceptionPoliciesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listExceptionPolicies(options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listExceptionPoliciesNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listExceptionPoliciesPagingAll(
    options?: JobRouterAdministrationListExceptionPoliciesOptionalParams
  ): AsyncIterableIterator<ExceptionPolicyItem> {
    for await (const page of this.listExceptionPoliciesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Retrieves existing queues
   * @param options The options parameters.
   */
  public listQueues(
    options?: JobRouterAdministrationListQueuesOptionalParams
  ): PagedAsyncIterableIterator<RouterQueueItem> {
    const iter = this.listQueuesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listQueuesPagingPage(options, settings);
      }
    };
  }

  private async *listQueuesPagingPage(
    options?: JobRouterAdministrationListQueuesOptionalParams,
    settings?: PageSettings
  ): AsyncIterableIterator<RouterQueueItem[]> {
    let result: JobRouterAdministrationListQueuesResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listQueues(options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listQueuesNext(continuationToken, options);
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listQueuesPagingAll(
    options?: JobRouterAdministrationListQueuesOptionalParams
  ): AsyncIterableIterator<RouterQueueItem> {
    for await (const page of this.listQueuesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Creates or updates a classification policy.
   * @param id Id of the classification policy
   * @param patch Model of classification policy properties to be patched. See also:
   *              https://datatracker.ietf.org/doc/html/rfc7386
   * @param options The options parameters.
   */
  async upsertClassificationPolicy(
    id: string,
    patch: ClassificationPolicy,
    options?: JobRouterAdministrationUpsertClassificationPolicyOptionalParams
  ): Promise<JobRouterAdministrationUpsertClassificationPolicyResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient.upsertClassificationPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, patch, options },
          upsertClassificationPolicyOperationSpec
        ) as Promise<JobRouterAdministrationUpsertClassificationPolicyResponse>;
      }
    );
  }

  /**
   * Retrieves an existing classification policy by Id
   * @param id Id of the classification policy
   * @param options The options parameters.
   */
  async getClassificationPolicy(
    id: string,
    options?: JobRouterAdministrationGetClassificationPolicyOptionalParams
  ): Promise<JobRouterAdministrationGetClassificationPolicyResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient.getClassificationPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, options },
          getClassificationPolicyOperationSpec
        ) as Promise<JobRouterAdministrationGetClassificationPolicyResponse>;
      }
    );
  }

  /**
   * Delete a classification policy by Id
   * @param id Id of the classification policy
   * @param options The options parameters.
   */
  async deleteClassificationPolicy(
    id: string,
    options?: JobRouterAdministrationDeleteClassificationPolicyOptionalParams
  ): Promise<void> {
    return tracingClient.withSpan(
      "JobRouterApiClient.deleteClassificationPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, options },
          deleteClassificationPolicyOperationSpec
        ) as Promise<void>;
      }
    );
  }

  /**
   * Retrieves existing classification policies
   * @param options The options parameters.
   */
  private async _listClassificationPolicies(
    options?: JobRouterAdministrationListClassificationPoliciesOptionalParams
  ): Promise<JobRouterAdministrationListClassificationPoliciesResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient._listClassificationPolicies",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          listClassificationPoliciesOperationSpec
        ) as Promise<JobRouterAdministrationListClassificationPoliciesResponse>;
      }
    );
  }

  /**
   * Creates or updates a distribution policy.
   * @param id Id of the distribution policy
   * @param patch Model of distribution policy properties to be patched. See also:
   *              https://datatracker.ietf.org/doc/html/rfc7386
   * @param options The options parameters.
   */
  async upsertDistributionPolicy(
    id: string,
    patch: DistributionPolicy,
    options?: JobRouterAdministrationUpsertDistributionPolicyOptionalParams
  ): Promise<JobRouterAdministrationUpsertDistributionPolicyResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient.upsertDistributionPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, patch, options },
          upsertDistributionPolicyOperationSpec
        ) as Promise<JobRouterAdministrationUpsertDistributionPolicyResponse>;
      }
    );
  }

  /**
   * Retrieves an existing distribution policy by Id
   * @param id Id of the distribution policy
   * @param options The options parameters.
   */
  async getDistributionPolicy(
    id: string,
    options?: JobRouterAdministrationGetDistributionPolicyOptionalParams
  ): Promise<JobRouterAdministrationGetDistributionPolicyResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient.getDistributionPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, options },
          getDistributionPolicyOperationSpec
        ) as Promise<JobRouterAdministrationGetDistributionPolicyResponse>;
      }
    );
  }

  /**
   * Delete a distribution policy by Id
   * @param id Id of the distribution policy
   * @param options The options parameters.
   */
  async deleteDistributionPolicy(
    id: string,
    options?: JobRouterAdministrationDeleteDistributionPolicyOptionalParams
  ): Promise<void> {
    return tracingClient.withSpan(
      "JobRouterApiClient.deleteDistributionPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, options },
          deleteDistributionPolicyOperationSpec
        ) as Promise<void>;
      }
    );
  }

  /**
   * Retrieves existing distribution policies
   * @param options The options parameters.
   */
  private async _listDistributionPolicies(
    options?: JobRouterAdministrationListDistributionPoliciesOptionalParams
  ): Promise<JobRouterAdministrationListDistributionPoliciesResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient._listDistributionPolicies",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          listDistributionPoliciesOperationSpec
        ) as Promise<JobRouterAdministrationListDistributionPoliciesResponse>;
      }
    );
  }

  /**
   * Creates or updates a exception policy.
   * @param id Id of the exception policy
   * @param patch Model of exception policy properties to be patched. See also:
   *              https://datatracker.ietf.org/doc/html/rfc7386
   * @param options The options parameters.
   */
  async upsertExceptionPolicy(
    id: string,
    patch: ExceptionPolicy,
    options?: JobRouterAdministrationUpsertExceptionPolicyOptionalParams
  ): Promise<JobRouterAdministrationUpsertExceptionPolicyResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient.upsertExceptionPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, patch, options },
          upsertExceptionPolicyOperationSpec
        ) as Promise<JobRouterAdministrationUpsertExceptionPolicyResponse>;
      }
    );
  }

  /**
   * Retrieves an existing exception policy by Id
   * @param id Id of the exception policy to retrieve
   * @param options The options parameters.
   */
  async getExceptionPolicy(
    id: string,
    options?: JobRouterAdministrationGetExceptionPolicyOptionalParams
  ): Promise<JobRouterAdministrationGetExceptionPolicyResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient.getExceptionPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, options },
          getExceptionPolicyOperationSpec
        ) as Promise<JobRouterAdministrationGetExceptionPolicyResponse>;
      }
    );
  }

  /**
   * Deletes a exception policy by Id
   * @param id Id of the exception policy to delete
   * @param options The options parameters.
   */
  async deleteExceptionPolicy(
    id: string,
    options?: JobRouterAdministrationDeleteExceptionPolicyOptionalParams
  ): Promise<void> {
    return tracingClient.withSpan(
      "JobRouterApiClient.deleteExceptionPolicy",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, options },
          deleteExceptionPolicyOperationSpec
        ) as Promise<void>;
      }
    );
  }

  /**
   * Retrieves existing exception policies
   * @param options The options parameters.
   */
  private async _listExceptionPolicies(
    options?: JobRouterAdministrationListExceptionPoliciesOptionalParams
  ): Promise<JobRouterAdministrationListExceptionPoliciesResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient._listExceptionPolicies",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          listExceptionPoliciesOperationSpec
        ) as Promise<JobRouterAdministrationListExceptionPoliciesResponse>;
      }
    );
  }

  /**
   * Creates or updates a queue.
   * @param id Id of the queue
   * @param patch Model of queue properties to be patched. See also:
   *              https://datatracker.ietf.org/doc/html/rfc7386
   * @param options The options parameters.
   */
  async upsertQueue(
    id: string,
    patch: RouterQueue,
    options?: JobRouterAdministrationUpsertQueueOptionalParams
  ): Promise<JobRouterAdministrationUpsertQueueResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient.upsertQueue",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, patch, options },
          upsertQueueOperationSpec
        ) as Promise<JobRouterAdministrationUpsertQueueResponse>;
      }
    );
  }

  /**
   * Retrieves an existing queue by Id
   * @param id Id of the queue to retrieve
   * @param options The options parameters.
   */
  async getQueue(
    id: string,
    options?: JobRouterAdministrationGetQueueOptionalParams
  ): Promise<JobRouterAdministrationGetQueueResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient.getQueue",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, options },
          getQueueOperationSpec
        ) as Promise<JobRouterAdministrationGetQueueResponse>;
      }
    );
  }

  /**
   * Deletes a queue by Id
   * @param id Id of the queue to delete
   * @param options The options parameters.
   */
  async deleteQueue(
    id: string,
    options?: JobRouterAdministrationDeleteQueueOptionalParams
  ): Promise<void> {
    return tracingClient.withSpan(
      "JobRouterApiClient.deleteQueue",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { id, options },
          deleteQueueOperationSpec
        ) as Promise<void>;
      }
    );
  }

  /**
   * Retrieves existing queues
   * @param options The options parameters.
   */
  private async _listQueues(
    options?: JobRouterAdministrationListQueuesOptionalParams
  ): Promise<JobRouterAdministrationListQueuesResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient._listQueues",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { options },
          listQueuesOperationSpec
        ) as Promise<JobRouterAdministrationListQueuesResponse>;
      }
    );
  }

  /**
   * ListClassificationPoliciesNext
   * @param nextLink The nextLink from the previous successful call to the ListClassificationPolicies
   *                 method.
   * @param options The options parameters.
   */
  private async _listClassificationPoliciesNext(
    nextLink: string,
    options?: JobRouterAdministrationListClassificationPoliciesNextOptionalParams
  ): Promise<JobRouterAdministrationListClassificationPoliciesNextResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient._listClassificationPoliciesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          listClassificationPoliciesNextOperationSpec
        ) as Promise<
          JobRouterAdministrationListClassificationPoliciesNextResponse
        >;
      }
    );
  }

  /**
   * ListDistributionPoliciesNext
   * @param nextLink The nextLink from the previous successful call to the ListDistributionPolicies
   *                 method.
   * @param options The options parameters.
   */
  private async _listDistributionPoliciesNext(
    nextLink: string,
    options?: JobRouterAdministrationListDistributionPoliciesNextOptionalParams
  ): Promise<JobRouterAdministrationListDistributionPoliciesNextResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient._listDistributionPoliciesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          listDistributionPoliciesNextOperationSpec
        ) as Promise<
          JobRouterAdministrationListDistributionPoliciesNextResponse
        >;
      }
    );
  }

  /**
   * ListExceptionPoliciesNext
   * @param nextLink The nextLink from the previous successful call to the ListExceptionPolicies method.
   * @param options The options parameters.
   */
  private async _listExceptionPoliciesNext(
    nextLink: string,
    options?: JobRouterAdministrationListExceptionPoliciesNextOptionalParams
  ): Promise<JobRouterAdministrationListExceptionPoliciesNextResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient._listExceptionPoliciesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          listExceptionPoliciesNextOperationSpec
        ) as Promise<JobRouterAdministrationListExceptionPoliciesNextResponse>;
      }
    );
  }

  /**
   * ListQueuesNext
   * @param nextLink The nextLink from the previous successful call to the ListQueues method.
   * @param options The options parameters.
   */
  private async _listQueuesNext(
    nextLink: string,
    options?: JobRouterAdministrationListQueuesNextOptionalParams
  ): Promise<JobRouterAdministrationListQueuesNextResponse> {
    return tracingClient.withSpan(
      "JobRouterApiClient._listQueuesNext",
      options ?? {},
      async (options) => {
        return this.client.sendOperationRequest(
          { nextLink, options },
          listQueuesNextOperationSpec
        ) as Promise<JobRouterAdministrationListQueuesNextResponse>;
      }
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const upsertClassificationPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/classificationPolicies/{id}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.ClassificationPolicy
    },
    201: {
      bodyMapper: Mappers.ClassificationPolicy
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  requestBody: Parameters.patch,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getClassificationPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/classificationPolicies/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClassificationPolicy
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteClassificationPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/classificationPolicies/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const listClassificationPoliciesOperationSpec: coreClient.OperationSpec = {
  path: "/routing/classificationPolicies",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClassificationPolicyCollection
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxpagesize],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const upsertDistributionPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/distributionPolicies/{id}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.DistributionPolicy
    },
    201: {
      bodyMapper: Mappers.DistributionPolicy
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  requestBody: Parameters.patch1,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getDistributionPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/distributionPolicies/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DistributionPolicy
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteDistributionPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/distributionPolicies/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const listDistributionPoliciesOperationSpec: coreClient.OperationSpec = {
  path: "/routing/distributionPolicies",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DistributionPolicyCollection
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxpagesize],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const upsertExceptionPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/exceptionPolicies/{id}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.ExceptionPolicy
    },
    201: {
      bodyMapper: Mappers.ExceptionPolicy
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  requestBody: Parameters.patch2,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getExceptionPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/exceptionPolicies/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ExceptionPolicy
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteExceptionPolicyOperationSpec: coreClient.OperationSpec = {
  path: "/routing/exceptionPolicies/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const listExceptionPoliciesOperationSpec: coreClient.OperationSpec = {
  path: "/routing/exceptionPolicies",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ExceptionPolicyCollection
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxpagesize],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const upsertQueueOperationSpec: coreClient.OperationSpec = {
  path: "/routing/queues/{id}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.RouterQueue
    },
    201: {
      bodyMapper: Mappers.RouterQueue
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  requestBody: Parameters.patch3,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getQueueOperationSpec: coreClient.OperationSpec = {
  path: "/routing/queues/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.RouterQueue
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteQueueOperationSpec: coreClient.OperationSpec = {
  path: "/routing/queues/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const listQueuesOperationSpec: coreClient.OperationSpec = {
  path: "/routing/queues",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.RouterQueueCollection
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxpagesize],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const listClassificationPoliciesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClassificationPolicyCollection
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listDistributionPoliciesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DistributionPolicyCollection
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listExceptionPoliciesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ExceptionPolicyCollection
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listQueuesNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.RouterQueueCollection
    },
    default: {
      bodyMapper: Mappers.CommunicationErrorResponse
    }
  },
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
