/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { createSpan } from "../tracing";
import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { JobRouter } from "../operationsInterfaces";
import * as coreHttp from "@azure/core-http";
import * as coreTracing from "@azure/core-tracing";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { JobRouterApiClientContext } from "../jobRouterApiClientContext";
import {
  RouterChannel,
  JobRouterListChannelsNextOptionalParams,
  JobRouterListChannelsOptionalParams,
  ClassificationPolicy,
  JobRouterListClassificationPoliciesNextOptionalParams,
  JobRouterListClassificationPoliciesOptionalParams,
  DistributionPolicy,
  JobRouterListDistributionPoliciesNextOptionalParams,
  JobRouterListDistributionPoliciesOptionalParams,
  ExceptionPolicy,
  JobRouterListExceptionPoliciesNextOptionalParams,
  JobRouterListExceptionPoliciesOptionalParams,
  RouterJob,
  JobRouterListJobsNextOptionalParams,
  JobRouterListJobsOptionalParams,
  JobRouterListEnqueuedJobsNextOptionalParams,
  JobRouterListEnqueuedJobsOptionalParams,
  JobQueue,
  JobRouterListQueuesNextOptionalParams,
  JobRouterListQueuesOptionalParams,
  RouterWorker,
  JobRouterListWorkersNextOptionalParams,
  JobRouterListWorkersOptionalParams,
  UpsertChannelRequest,
  JobRouterCreateOrUpdateChannelOptionalParams,
  JobRouterCreateOrUpdateChannelResponse,
  JobRouterListChannelsResponse,
  JobRouterGetChannelOptionalParams,
  JobRouterGetChannelResponse,
  JobRouterDeleteChannelOptionalParams,
  UpsertClassificationPolicyRequest,
  JobRouterCreateOrUpdateClassificationPolicyOptionalParams,
  JobRouterCreateOrUpdateClassificationPolicyResponse,
  JobRouterListClassificationPoliciesResponse,
  JobRouterGetClassificationPolicyOptionalParams,
  JobRouterGetClassificationPolicyResponse,
  JobRouterDeleteClassificationPolicyOptionalParams,
  UpsertDistributionPolicyRequest,
  JobRouterCreateOrUpdateDistributionPolicyOptionalParams,
  JobRouterCreateOrUpdateDistributionPolicyResponse,
  JobRouterListDistributionPoliciesResponse,
  JobRouterGetDistributionPolicyOptionalParams,
  JobRouterGetDistributionPolicyResponse,
  JobRouterDeleteDistributionPolicyOptionalParams,
  UpsertExceptionPolicyRequest,
  JobRouterCreateOrUpdateExceptionPolicyOptionalParams,
  JobRouterCreateOrUpdateExceptionPolicyResponse,
  JobRouterListExceptionPoliciesResponse,
  JobRouterGetExceptionPolicyOptionalParams,
  JobRouterGetExceptionPolicyResponse,
  JobRouterDeleteExceptionPolicyOptionalParams,
  CreateJobRequest,
  JobRouterCreateJobOptionalParams,
  JobRouterCreateJobResponse,
  JobRouterListJobsResponse,
  JobRouterGetJobOptionalParams,
  JobRouterGetJobResponse,
  JobRouterListEnqueuedJobsResponse,
  JobRouterUpdateJobLabelsOptionalParams,
  JobRouterUpdateJobLabelsResponse,
  ReclassifyJobRequest,
  JobRouterReclassifyJobOptionalParams,
  JobRouterReclassifyJobResponse,
  JobRouterUpdateJobClassificationOptionalParams,
  JobRouterUpdateJobClassificationResponse,
  JobRouterCancelJobOptionalParams,
  JobRouterCompleteJobOptionalParams,
  JobRouterCloseJobOptionalParams,
  JobRouterGetInQueuePositionOptionalParams,
  JobRouterGetInQueuePositionResponse,
  JobRouterAcceptJobOptionalParams,
  JobRouterAcceptJobResponse,
  JobRouterDeclineJobOptionalParams,
  UpsertQueueRequest,
  JobRouterCreateOrUpdateQueueOptionalParams,
  JobRouterCreateOrUpdateQueueResponse,
  JobRouterListQueuesResponse,
  JobRouterGetQueueOptionalParams,
  JobRouterGetQueueResponse,
  JobRouterDeleteQueueOptionalParams,
  RegisterWorkerRequest,
  JobRouterRegisterWorkerOptionalParams,
  JobRouterRegisterWorkerResponse,
  JobRouterListWorkersResponse,
  JobRouterDeregisterWorkerOptionalParams,
  JobRouterGetWorkerOptionalParams,
  JobRouterGetWorkerResponse,
  JobRouterReleaseAssignmentOptionalParams,
  JobRouterListChannelsNextResponse,
  JobRouterListClassificationPoliciesNextResponse,
  JobRouterListDistributionPoliciesNextResponse,
  JobRouterListExceptionPoliciesNextResponse,
  JobRouterListJobsNextResponse,
  JobRouterListEnqueuedJobsNextResponse,
  JobRouterListQueuesNextResponse,
  JobRouterListWorkersNextResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing JobRouter operations. */
export class JobRouterImpl implements JobRouter {
  private readonly client: JobRouterApiClientContext;

  /**
   * Initialize a new instance of the class JobRouter class.
   * @param client Reference to the service client
   */
  constructor(client: JobRouterApiClientContext) {
    this.client = client;
  }

  /**
   * Retrieves custom channels
   * @param options The options parameters.
   */
  public listChannels(
    options?: JobRouterListChannelsOptionalParams
  ): PagedAsyncIterableIterator<RouterChannel> {
    const iter = this.listChannelsPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listChannelsPagingPage(options);
      }
    };
  }

  private async *listChannelsPagingPage(
    options?: JobRouterListChannelsOptionalParams
  ): AsyncIterableIterator<RouterChannel[]> {
    let result = await this._listChannels(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listChannelsNext(continuationToken, options);
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listChannelsPagingAll(
    options?: JobRouterListChannelsOptionalParams
  ): AsyncIterableIterator<RouterChannel> {
    for await (const page of this.listChannelsPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Retrieves existing classification policies
   * @param options The options parameters.
   */
  public listClassificationPolicies(
    options?: JobRouterListClassificationPoliciesOptionalParams
  ): PagedAsyncIterableIterator<ClassificationPolicy> {
    const iter = this.listClassificationPoliciesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listClassificationPoliciesPagingPage(options);
      }
    };
  }

  private async *listClassificationPoliciesPagingPage(
    options?: JobRouterListClassificationPoliciesOptionalParams
  ): AsyncIterableIterator<ClassificationPolicy[]> {
    let result = await this._listClassificationPolicies(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listClassificationPoliciesNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listClassificationPoliciesPagingAll(
    options?: JobRouterListClassificationPoliciesOptionalParams
  ): AsyncIterableIterator<ClassificationPolicy> {
    for await (const page of this.listClassificationPoliciesPagingPage(
      options
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves existing distribution policies
   * @param options The options parameters.
   */
  public listDistributionPolicies(
    options?: JobRouterListDistributionPoliciesOptionalParams
  ): PagedAsyncIterableIterator<DistributionPolicy> {
    const iter = this.listDistributionPoliciesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listDistributionPoliciesPagingPage(options);
      }
    };
  }

  private async *listDistributionPoliciesPagingPage(
    options?: JobRouterListDistributionPoliciesOptionalParams
  ): AsyncIterableIterator<DistributionPolicy[]> {
    let result = await this._listDistributionPolicies(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listDistributionPoliciesNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listDistributionPoliciesPagingAll(
    options?: JobRouterListDistributionPoliciesOptionalParams
  ): AsyncIterableIterator<DistributionPolicy> {
    for await (const page of this.listDistributionPoliciesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Retrieves existing exception policies
   * @param options The options parameters.
   */
  public listExceptionPolicies(
    options?: JobRouterListExceptionPoliciesOptionalParams
  ): PagedAsyncIterableIterator<ExceptionPolicy> {
    const iter = this.listExceptionPoliciesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listExceptionPoliciesPagingPage(options);
      }
    };
  }

  private async *listExceptionPoliciesPagingPage(
    options?: JobRouterListExceptionPoliciesOptionalParams
  ): AsyncIterableIterator<ExceptionPolicy[]> {
    let result = await this._listExceptionPolicies(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listExceptionPoliciesNext(
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listExceptionPoliciesPagingAll(
    options?: JobRouterListExceptionPoliciesOptionalParams
  ): AsyncIterableIterator<ExceptionPolicy> {
    for await (const page of this.listExceptionPoliciesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Retrieves list of jobs based on filter parameters
   * @param options The options parameters.
   */
  public listJobs(
    options?: JobRouterListJobsOptionalParams
  ): PagedAsyncIterableIterator<RouterJob> {
    const iter = this.listJobsPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listJobsPagingPage(options);
      }
    };
  }

  private async *listJobsPagingPage(
    options?: JobRouterListJobsOptionalParams
  ): AsyncIterableIterator<RouterJob[]> {
    let result = await this._listJobs(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listJobsNext(continuationToken, options);
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listJobsPagingAll(
    options?: JobRouterListJobsOptionalParams
  ): AsyncIterableIterator<RouterJob> {
    for await (const page of this.listJobsPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Retrieves existing jobs by queue
   * @param queueId
   * @param options The options parameters.
   */
  public listEnqueuedJobs(
    queueId: string,
    options?: JobRouterListEnqueuedJobsOptionalParams
  ): PagedAsyncIterableIterator<RouterJob> {
    const iter = this.listEnqueuedJobsPagingAll(queueId, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listEnqueuedJobsPagingPage(queueId, options);
      }
    };
  }

  private async *listEnqueuedJobsPagingPage(
    queueId: string,
    options?: JobRouterListEnqueuedJobsOptionalParams
  ): AsyncIterableIterator<RouterJob[]> {
    let result = await this._listEnqueuedJobs(queueId, options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listEnqueuedJobsNext(
        queueId,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listEnqueuedJobsPagingAll(
    queueId: string,
    options?: JobRouterListEnqueuedJobsOptionalParams
  ): AsyncIterableIterator<RouterJob> {
    for await (const page of this.listEnqueuedJobsPagingPage(
      queueId,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Retrieves existing queues
   * @param options The options parameters.
   */
  public listQueues(
    options?: JobRouterListQueuesOptionalParams
  ): PagedAsyncIterableIterator<JobQueue> {
    const iter = this.listQueuesPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listQueuesPagingPage(options);
      }
    };
  }

  private async *listQueuesPagingPage(
    options?: JobRouterListQueuesOptionalParams
  ): AsyncIterableIterator<JobQueue[]> {
    let result = await this._listQueues(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listQueuesNext(continuationToken, options);
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listQueuesPagingAll(
    options?: JobRouterListQueuesOptionalParams
  ): AsyncIterableIterator<JobQueue> {
    for await (const page of this.listQueuesPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Retrieves existing workers.
   * @param options The options parameters.
   */
  public listWorkers(
    options?: JobRouterListWorkersOptionalParams
  ): PagedAsyncIterableIterator<RouterWorker> {
    const iter = this.listWorkersPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listWorkersPagingPage(options);
      }
    };
  }

  private async *listWorkersPagingPage(
    options?: JobRouterListWorkersOptionalParams
  ): AsyncIterableIterator<RouterWorker[]> {
    let result = await this._listWorkers(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listWorkersNext(continuationToken, options);
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listWorkersPagingAll(
    options?: JobRouterListWorkersOptionalParams
  ): AsyncIterableIterator<RouterWorker> {
    for await (const page of this.listWorkersPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Creates or updates a channel
   * @param body Model of channel to be created or updated
   * @param options The options parameters.
   */
  async createOrUpdateChannel(
    body: UpsertChannelRequest,
    options?: JobRouterCreateOrUpdateChannelOptionalParams
  ): Promise<JobRouterCreateOrUpdateChannelResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-createOrUpdateChannel",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      body,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        createOrUpdateChannelOperationSpec
      );
      return result as JobRouterCreateOrUpdateChannelResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves custom channels
   * @param options The options parameters.
   */
  private async _listChannels(
    options?: JobRouterListChannelsOptionalParams
  ): Promise<JobRouterListChannelsResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listChannels",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listChannelsOperationSpec
      );
      return result as JobRouterListChannelsResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves an existing channel by Id
   * @param id Id of the channel to retrieve
   * @param options The options parameters.
   */
  async getChannel(
    id: string,
    options?: JobRouterGetChannelOptionalParams
  ): Promise<JobRouterGetChannelResponse> {
    const { span } = createSpan("JobRouterApiClient-getChannel", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        getChannelOperationSpec
      );
      return result as JobRouterGetChannelResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Deletes a channel by Id
   * @param id Id of the channel to delete
   * @param options The options parameters.
   */
  async deleteChannel(
    id: string,
    options?: JobRouterDeleteChannelOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-deleteChannel",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        deleteChannelOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Creates a new classification policy.
   * @param body Request payload for creating or updating a Classification Policy
   * @param options The options parameters.
   */
  async createOrUpdateClassificationPolicy(
    body: UpsertClassificationPolicyRequest,
    options?: JobRouterCreateOrUpdateClassificationPolicyOptionalParams
  ): Promise<JobRouterCreateOrUpdateClassificationPolicyResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-createOrUpdateClassificationPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      body,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        createOrUpdateClassificationPolicyOperationSpec
      );
      return result as JobRouterCreateOrUpdateClassificationPolicyResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves existing classification policies
   * @param options The options parameters.
   */
  private async _listClassificationPolicies(
    options?: JobRouterListClassificationPoliciesOptionalParams
  ): Promise<JobRouterListClassificationPoliciesResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listClassificationPolicies",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listClassificationPoliciesOperationSpec
      );
      return result as JobRouterListClassificationPoliciesResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves an existing classification policy by Id
   * @param id
   * @param options The options parameters.
   */
  async getClassificationPolicy(
    id: string,
    options?: JobRouterGetClassificationPolicyOptionalParams
  ): Promise<JobRouterGetClassificationPolicyResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-getClassificationPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        getClassificationPolicyOperationSpec
      );
      return result as JobRouterGetClassificationPolicyResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Delete a classification policy by Id
   * @param id
   * @param options The options parameters.
   */
  async deleteClassificationPolicy(
    id: string,
    options?: JobRouterDeleteClassificationPolicyOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-deleteClassificationPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        deleteClassificationPolicyOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Creates a new distribution policy.
   * @param body Request payload for creating or updating a distribution policy
   * @param options The options parameters.
   */
  async createOrUpdateDistributionPolicy(
    body: UpsertDistributionPolicyRequest,
    options?: JobRouterCreateOrUpdateDistributionPolicyOptionalParams
  ): Promise<JobRouterCreateOrUpdateDistributionPolicyResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-createOrUpdateDistributionPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      body,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        createOrUpdateDistributionPolicyOperationSpec
      );
      return result as JobRouterCreateOrUpdateDistributionPolicyResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves existing distribution policies
   * @param options The options parameters.
   */
  private async _listDistributionPolicies(
    options?: JobRouterListDistributionPoliciesOptionalParams
  ): Promise<JobRouterListDistributionPoliciesResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listDistributionPolicies",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listDistributionPoliciesOperationSpec
      );
      return result as JobRouterListDistributionPoliciesResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves an existing distribution policy by Id
   * @param id
   * @param options The options parameters.
   */
  async getDistributionPolicy(
    id: string,
    options?: JobRouterGetDistributionPolicyOptionalParams
  ): Promise<JobRouterGetDistributionPolicyResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-getDistributionPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        getDistributionPolicyOperationSpec
      );
      return result as JobRouterGetDistributionPolicyResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Delete a distribution policy by Id
   * @param id
   * @param options The options parameters.
   */
  async deleteDistributionPolicy(
    id: string,
    options?: JobRouterDeleteDistributionPolicyOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-deleteDistributionPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        deleteDistributionPolicyOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Creates a new exception policy
   * @param body Model of Exception Policy to be created
   * @param options The options parameters.
   */
  async createOrUpdateExceptionPolicy(
    body: UpsertExceptionPolicyRequest,
    options?: JobRouterCreateOrUpdateExceptionPolicyOptionalParams
  ): Promise<JobRouterCreateOrUpdateExceptionPolicyResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-createOrUpdateExceptionPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      body,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        createOrUpdateExceptionPolicyOperationSpec
      );
      return result as JobRouterCreateOrUpdateExceptionPolicyResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves existing exception policies
   * @param options The options parameters.
   */
  private async _listExceptionPolicies(
    options?: JobRouterListExceptionPoliciesOptionalParams
  ): Promise<JobRouterListExceptionPoliciesResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listExceptionPolicies",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listExceptionPoliciesOperationSpec
      );
      return result as JobRouterListExceptionPoliciesResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves an existing exception policy by Id
   * @param id Id of the exception policy to retrieve
   * @param options The options parameters.
   */
  async getExceptionPolicy(
    id: string,
    options?: JobRouterGetExceptionPolicyOptionalParams
  ): Promise<JobRouterGetExceptionPolicyResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-getExceptionPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        getExceptionPolicyOperationSpec
      );
      return result as JobRouterGetExceptionPolicyResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Deletes a exception policy by Id
   * @param id Id of the exception policy to delete
   * @param options The options parameters.
   */
  async deleteExceptionPolicy(
    id: string,
    options?: JobRouterDeleteExceptionPolicyOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-deleteExceptionPolicy",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        deleteExceptionPolicyOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Creates a new job to be routed.
   * @param body Request payload for creating new jobs
   * @param options The options parameters.
   */
  async createJob(
    body: CreateJobRequest,
    options?: JobRouterCreateJobOptionalParams
  ): Promise<JobRouterCreateJobResponse> {
    const { span } = createSpan("JobRouterApiClient-createJob", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      body,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        createJobOperationSpec
      );
      return result as JobRouterCreateJobResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves list of jobs based on filter parameters
   * @param options The options parameters.
   */
  private async _listJobs(
    options?: JobRouterListJobsOptionalParams
  ): Promise<JobRouterListJobsResponse> {
    const { span } = createSpan("JobRouterApiClient-_listJobs", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listJobsOperationSpec
      );
      return result as JobRouterListJobsResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves an existing job by Id
   * @param jobId
   * @param options The options parameters.
   */
  async getJob(
    jobId: string,
    options?: JobRouterGetJobOptionalParams
  ): Promise<JobRouterGetJobResponse> {
    const { span } = createSpan("JobRouterApiClient-getJob", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      jobId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        getJobOperationSpec
      );
      return result as JobRouterGetJobResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves existing jobs by queue
   * @param queueId
   * @param options The options parameters.
   */
  private async _listEnqueuedJobs(
    queueId: string,
    options?: JobRouterListEnqueuedJobsOptionalParams
  ): Promise<JobRouterListEnqueuedJobsResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listEnqueuedJobs",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      queueId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listEnqueuedJobsOperationSpec
      );
      return result as JobRouterListEnqueuedJobsResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Update or insert labels of a job by Id.
   * @param jobId
   * @param labels A set of key/value pairs used as metadata for a job.
   * @param options The options parameters.
   */
  async updateJobLabels(
    jobId: string,
    labels: { [propertyName: string]: any },
    options?: JobRouterUpdateJobLabelsOptionalParams
  ): Promise<JobRouterUpdateJobLabelsResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-updateJobLabels",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      jobId,
      labels,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        updateJobLabelsOperationSpec
      );
      return result as JobRouterUpdateJobLabelsResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Updates an existing job by Id and forcing it to be reclassified.
   * The following attributes can be updated:
   * 1. ClassificationPolicyId: (Optional) The classification policy that will determine queue, priority
   * and required abilities.
   * 2. LabelsToUpsert: (Optional) Update or insert labels associated to a job.
   * @param jobId
   * @param body Request payload to update existing job and submit for classification
   * @param options The options parameters.
   */
  async reclassifyJob(
    jobId: string,
    body: ReclassifyJobRequest,
    options?: JobRouterReclassifyJobOptionalParams
  ): Promise<JobRouterReclassifyJobResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-reclassifyJob",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      jobId,
      body,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        reclassifyJobOperationSpec
      );
      return result as JobRouterReclassifyJobResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Updates an existing job's queueId, priority, requiredAbilities and labels.
   * The following attributes can be updated:
   * 1. QueuedId: (Optional) Can be used to assign a job to particular queue.
   * 2. Priority: (Optional) Can be used to set job priority.
   * 3. RequiredAbilities: (Optional) Can be used to set required abilities on a job. Note, that all
   * previous abilities will be overridden.
   * @param jobId
   * @param options The options parameters.
   */
  async updateJobClassification(
    jobId: string,
    options?: JobRouterUpdateJobClassificationOptionalParams
  ): Promise<JobRouterUpdateJobClassificationResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-updateJobClassification",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      jobId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        updateJobClassificationOperationSpec
      );
      return result as JobRouterUpdateJobClassificationResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
   * @param jobId
   * @param options The options parameters.
   */
  async cancelJob(
    jobId: string,
    options?: JobRouterCancelJobOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan("JobRouterApiClient-cancelJob", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      jobId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        cancelJobOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Completes an assigned job.
   * @param jobId
   * @param assignmentId The assignment within the job to complete.
   * @param options The options parameters.
   */
  async completeJob(
    jobId: string,
    assignmentId: string,
    options?: JobRouterCompleteJobOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-completeJob",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      jobId,
      assignmentId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        completeJobOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Closes a completed job.
   * @param jobId
   * @param assignmentId The assignment within which the job is to be closed.
   * @param options The options parameters.
   */
  async closeJob(
    jobId: string,
    assignmentId: string,
    options?: JobRouterCloseJobOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan("JobRouterApiClient-closeJob", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      jobId,
      assignmentId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        closeJobOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Gets a job's position details.
   * @param jobId
   * @param options The options parameters.
   */
  async getInQueuePosition(
    jobId: string,
    options?: JobRouterGetInQueuePositionOptionalParams
  ): Promise<JobRouterGetInQueuePositionResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-getInQueuePosition",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      jobId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        getInQueuePositionOperationSpec
      );
      return result as JobRouterGetInQueuePositionResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job
   * already.
   * @param offerId
   * @param workerId
   * @param options The options parameters.
   */
  async acceptJob(
    offerId: string,
    workerId: string,
    options?: JobRouterAcceptJobOptionalParams
  ): Promise<JobRouterAcceptJobResponse> {
    const { span } = createSpan("JobRouterApiClient-acceptJob", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      offerId,
      workerId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        acceptJobOperationSpec
      );
      return result as JobRouterAcceptJobResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Declines an offer to work on a job.
   * @param offerId
   * @param workerId
   * @param options The options parameters.
   */
  async declineJob(
    offerId: string,
    workerId: string,
    options?: JobRouterDeclineJobOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan("JobRouterApiClient-declineJob", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      offerId,
      workerId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        declineJobOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Creates or updates a queue.
   * @param body Model of queue to be created or Updated
   * @param options The options parameters.
   */
  async createOrUpdateQueue(
    body: UpsertQueueRequest,
    options?: JobRouterCreateOrUpdateQueueOptionalParams
  ): Promise<JobRouterCreateOrUpdateQueueResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-createOrUpdateQueue",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      body,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        createOrUpdateQueueOperationSpec
      );
      return result as JobRouterCreateOrUpdateQueueResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves existing queues
   * @param options The options parameters.
   */
  private async _listQueues(
    options?: JobRouterListQueuesOptionalParams
  ): Promise<JobRouterListQueuesResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listQueues",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listQueuesOperationSpec
      );
      return result as JobRouterListQueuesResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves an existing queue by Id
   * @param id Id of the queue to retrieve
   * @param options The options parameters.
   */
  async getQueue(
    id: string,
    options?: JobRouterGetQueueOptionalParams
  ): Promise<JobRouterGetQueueResponse> {
    const { span } = createSpan("JobRouterApiClient-getQueue", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        getQueueOperationSpec
      );
      return result as JobRouterGetQueueResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Deletes a queue by Id
   * @param id Id of the queue to delete
   * @param options The options parameters.
   */
  async deleteQueue(
    id: string,
    options?: JobRouterDeleteQueueOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-deleteQueue",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      id,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        deleteQueueOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Registers a worker to process jobs.
   * @param body Request payload for registering workers.
   * @param options The options parameters.
   */
  async registerWorker(
    body: RegisterWorkerRequest,
    options?: JobRouterRegisterWorkerOptionalParams
  ): Promise<JobRouterRegisterWorkerResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-registerWorker",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      body,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        registerWorkerOperationSpec
      );
      return result as JobRouterRegisterWorkerResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves existing workers.
   * @param options The options parameters.
   */
  private async _listWorkers(
    options?: JobRouterListWorkersOptionalParams
  ): Promise<JobRouterListWorkersResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listWorkers",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listWorkersOperationSpec
      );
      return result as JobRouterListWorkersResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Deregisters a worker from processing jobs.
   * @param workerId
   * @param options The options parameters.
   */
  async deregisterWorker(
    workerId: string,
    options?: JobRouterDeregisterWorkerOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-deregisterWorker",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      workerId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        deregisterWorkerOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Retrieves an existing worker by Id
   * @param workerId
   * @param options The options parameters.
   */
  async getWorker(
    workerId: string,
    options?: JobRouterGetWorkerOptionalParams
  ): Promise<JobRouterGetWorkerResponse> {
    const { span } = createSpan("JobRouterApiClient-getWorker", options || {});
    const operationArguments: coreHttp.OperationArguments = {
      workerId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        getWorkerOperationSpec
      );
      return result as JobRouterGetWorkerResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * Releases capacity consumed by an assignment within a workers socket collection.
   * @param workerId
   * @param assignmentId
   * @param options The options parameters.
   */
  async releaseAssignment(
    workerId: string,
    assignmentId: string,
    options?: JobRouterReleaseAssignmentOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-releaseAssignment",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      workerId,
      assignmentId,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        releaseAssignmentOperationSpec
      );
      return result as coreHttp.RestResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * ListChannelsNext
   * @param nextLink The nextLink from the previous successful call to the ListChannels method.
   * @param options The options parameters.
   */
  private async _listChannelsNext(
    nextLink: string,
    options?: JobRouterListChannelsNextOptionalParams
  ): Promise<JobRouterListChannelsNextResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listChannelsNext",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listChannelsNextOperationSpec
      );
      return result as JobRouterListChannelsNextResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * ListClassificationPoliciesNext
   * @param nextLink The nextLink from the previous successful call to the ListClassificationPolicies
   *                 method.
   * @param options The options parameters.
   */
  private async _listClassificationPoliciesNext(
    nextLink: string,
    options?: JobRouterListClassificationPoliciesNextOptionalParams
  ): Promise<JobRouterListClassificationPoliciesNextResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listClassificationPoliciesNext",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listClassificationPoliciesNextOperationSpec
      );
      return result as JobRouterListClassificationPoliciesNextResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * ListDistributionPoliciesNext
   * @param nextLink The nextLink from the previous successful call to the ListDistributionPolicies
   *                 method.
   * @param options The options parameters.
   */
  private async _listDistributionPoliciesNext(
    nextLink: string,
    options?: JobRouterListDistributionPoliciesNextOptionalParams
  ): Promise<JobRouterListDistributionPoliciesNextResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listDistributionPoliciesNext",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listDistributionPoliciesNextOperationSpec
      );
      return result as JobRouterListDistributionPoliciesNextResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * ListExceptionPoliciesNext
   * @param nextLink The nextLink from the previous successful call to the ListExceptionPolicies method.
   * @param options The options parameters.
   */
  private async _listExceptionPoliciesNext(
    nextLink: string,
    options?: JobRouterListExceptionPoliciesNextOptionalParams
  ): Promise<JobRouterListExceptionPoliciesNextResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listExceptionPoliciesNext",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listExceptionPoliciesNextOperationSpec
      );
      return result as JobRouterListExceptionPoliciesNextResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * ListJobsNext
   * @param nextLink The nextLink from the previous successful call to the ListJobs method.
   * @param options The options parameters.
   */
  private async _listJobsNext(
    nextLink: string,
    options?: JobRouterListJobsNextOptionalParams
  ): Promise<JobRouterListJobsNextResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listJobsNext",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listJobsNextOperationSpec
      );
      return result as JobRouterListJobsNextResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * ListEnqueuedJobsNext
   * @param queueId
   * @param nextLink The nextLink from the previous successful call to the ListEnqueuedJobs method.
   * @param options The options parameters.
   */
  private async _listEnqueuedJobsNext(
    queueId: string,
    nextLink: string,
    options?: JobRouterListEnqueuedJobsNextOptionalParams
  ): Promise<JobRouterListEnqueuedJobsNextResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listEnqueuedJobsNext",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      queueId,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listEnqueuedJobsNextOperationSpec
      );
      return result as JobRouterListEnqueuedJobsNextResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * ListQueuesNext
   * @param nextLink The nextLink from the previous successful call to the ListQueues method.
   * @param options The options parameters.
   */
  private async _listQueuesNext(
    nextLink: string,
    options?: JobRouterListQueuesNextOptionalParams
  ): Promise<JobRouterListQueuesNextResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listQueuesNext",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listQueuesNextOperationSpec
      );
      return result as JobRouterListQueuesNextResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }

  /**
   * ListWorkersNext
   * @param nextLink The nextLink from the previous successful call to the ListWorkers method.
   * @param options The options parameters.
   */
  private async _listWorkersNext(
    nextLink: string,
    options?: JobRouterListWorkersNextOptionalParams
  ): Promise<JobRouterListWorkersNextResponse> {
    const { span } = createSpan(
      "JobRouterApiClient-_listWorkersNext",
      options || {}
    );
    const operationArguments: coreHttp.OperationArguments = {
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    try {
      const result = await this.client.sendOperationRequest(
        operationArguments,
        listWorkersNextOperationSpec
      );
      return result as JobRouterListWorkersNextResponse;
    } catch (error) {
      span.setStatus({
        code: coreTracing.SpanStatusCode.UNSET,
        message: error.message
      });
      throw error;
    } finally {
      span.end();
    }
  }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const createOrUpdateChannelOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/channels",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.UpsertChannelResponse
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [
    Parameters.contentType,
    Parameters.accept,
    Parameters.ifMatch
  ],
  mediaType: "json",
  serializer
};
const listChannelsOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/channels",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ChannelCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.typeParam,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const getChannelOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/channels/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.RouterChannel
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteChannelOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/channels/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept, Parameters.ifMatch],
  serializer
};
const createOrUpdateClassificationPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/classificationpolicies",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.UpsertClassificationPolicyResponse
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body1,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listClassificationPoliciesOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/classificationpolicies",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClassificationPolicyCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const getClassificationPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/classificationpolicies/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClassificationPolicy
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteClassificationPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/classificationpolicies/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept, Parameters.ifMatch],
  serializer
};
const createOrUpdateDistributionPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/distributionpolicies",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.UpsertDistributionPolicyResponse
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body2,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listDistributionPoliciesOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/distributionpolicies",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DistributionPolicyCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const getDistributionPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/distributionpolicies/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DistributionPolicy
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteDistributionPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/distributionpolicies/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept, Parameters.ifMatch],
  serializer
};
const createOrUpdateExceptionPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/exceptionpolicies",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.UpsertExceptionPolicyResponse
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body3,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listExceptionPoliciesOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/exceptionpolicies",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ExceptionPolicyCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const getExceptionPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/exceptionpolicies/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ExceptionPolicy
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteExceptionPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/exceptionpolicies/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept, Parameters.ifMatch],
  serializer
};
const createJobOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs",
  httpMethod: "POST",
  responses: {
    201: {
      bodyMapper: Mappers.CreateJobResponse
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body4,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listJobsOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken,
    Parameters.status
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const getJobOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs/{jobId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.RouterJob
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.jobId],
  headerParameters: [Parameters.accept],
  serializer
};
const listEnqueuedJobsOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/queues/{queueId}/jobs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint, Parameters.queueId],
  headerParameters: [Parameters.accept],
  serializer
};
const updateJobLabelsOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs/{jobId}/updatelabels",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.RouterJob
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: {
    parameterPath: { labels: ["labels"], note: ["options", "note"] },
    mapper: { ...Mappers.UpdateJobLabelsRequest, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.jobId],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const reclassifyJobOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs/{jobId}/reclassify",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.RouterJob
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body6,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.jobId],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const updateJobClassificationOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs/{jobId}/updateclassification",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.RouterJob
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: {
    parameterPath: {
      queueId: ["options", "queueId"],
      priority: ["options", "priority"],
      workerSelectors: ["options", "workerSelectors"],
      note: ["options", "note"]
    },
    mapper: { ...Mappers.UpdateJobClassificationRequest, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.jobId],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const cancelJobOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs/{jobId}/cancel",
  httpMethod: "POST",
  responses: {
    202: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: {
    parameterPath: {
      note: ["options", "note"],
      dispositionCode: ["options", "dispositionCode"]
    },
    mapper: Mappers.CancelJobRequest
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.jobId],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const completeJobOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs/{jobId}/complete",
  httpMethod: "POST",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: {
    parameterPath: {
      assignmentId: ["assignmentId"],
      note: ["options", "note"]
    },
    mapper: { ...Mappers.CompleteJobRequest, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.jobId],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const closeJobOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs/{jobId}/close",
  httpMethod: "POST",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: {
    parameterPath: {
      assignmentId: ["assignmentId"],
      dispositionCode: ["options", "dispositionCode"],
      releaseTime: ["options", "releaseTime"],
      note: ["options", "note"]
    },
    mapper: { ...Mappers.CloseJobRequest, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.jobId],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getInQueuePositionOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/jobs/{jobId}/position",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobPositionDetails
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.jobId],
  headerParameters: [Parameters.accept],
  serializer
};
const acceptJobOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/workers/{workerId}/offers/{offerId}/accept",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.AcceptJobOfferResponse
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.offerId, Parameters.workerId],
  headerParameters: [Parameters.accept],
  serializer
};
const declineJobOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/workers/{workerId}/offers/{offerId}/decline",
  httpMethod: "POST",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.offerId, Parameters.workerId],
  headerParameters: [Parameters.accept],
  serializer
};
const createOrUpdateQueueOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/queues",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.UpsertQueueResponse
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body11,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listQueuesOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/queues",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueueCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const getQueueOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/queues/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobQueue
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept],
  serializer
};
const deleteQueueOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/queues/{id}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.id],
  headerParameters: [Parameters.accept, Parameters.ifMatch],
  serializer
};
const registerWorkerOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/workers",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.RouterWorker
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body12,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listWorkersOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/workers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkerCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken,
    Parameters.status1,
    Parameters.channelId,
    Parameters.queueId2,
    Parameters.hasCapacity
  ],
  urlParameters: [Parameters.endpoint],
  headerParameters: [Parameters.accept],
  serializer
};
const deregisterWorkerOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/workers/{workerId}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.workerId],
  headerParameters: [Parameters.accept],
  serializer
};
const getWorkerOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/workers/{workerId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.RouterWorker
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.endpoint, Parameters.workerId],
  headerParameters: [Parameters.accept],
  serializer
};
const releaseAssignmentOperationSpec: coreHttp.OperationSpec = {
  path: "/routing/workers/{workerId}/assignments/{assignmentId}/release",
  httpMethod: "POST",
  responses: {
    200: {},
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  requestBody: Parameters.body13,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.endpoint,
    Parameters.workerId,
    Parameters.assignmentId2
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const listChannelsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ChannelCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.typeParam,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listClassificationPoliciesNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ClassificationPolicyCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listDistributionPoliciesNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DistributionPolicyCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listExceptionPoliciesNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ExceptionPolicyCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listJobsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken,
    Parameters.status
  ],
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listEnqueuedJobsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.JobCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint, Parameters.queueId, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listQueuesNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.QueueCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken
  ],
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const listWorkersNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.WorkerCollection
    },
    400: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    401: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    403: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    409: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    412: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    429: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    },
    503: {
      bodyMapper: Mappers.CommunicationErrorResponse,
      isError: true
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.maxPageSize,
    Parameters.continuationToken,
    Parameters.status1,
    Parameters.channelId,
    Parameters.queueId2,
    Parameters.hasCapacity
  ],
  urlParameters: [Parameters.endpoint, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
