{"version":3,"file":"callRecording.js","sourceRoot":"","sources":["../../src/callRecording.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { CallRecordingImpl } from \"./generated/src/operations/index.js\";\nimport type {\n  CallAutomationApiClientOptionalParams,\n  StartCallRecordingRequest,\n} from \"./generated/src/models/index.js\";\nimport type { RecordingStateResult } from \"./models/responses.js\";\nimport type {\n  StartRecordingOptions,\n  StopRecordingOptions,\n  PauseRecordingOptions,\n  GetRecordingPropertiesOptions,\n  ResumeRecordingOptions,\n  DeleteRecordingOptions,\n  DownloadRecordingOptions,\n} from \"./models/options.js\";\nimport { communicationIdentifierModelConverter } from \"./utli/converters.js\";\nimport { ContentDownloaderImpl } from \"./contentDownloader.js\";\nimport * as fs from \"node:fs\";\nimport { randomUUID } from \"@azure/core-util\";\nimport type { KeyCredential, TokenCredential } from \"@azure/core-auth\";\nimport type { CallAutomationApiClient } from \"./generated/src/index.js\";\nimport { createCustomCallAutomationApiClient } from \"./credential/callAutomationAuthPolicy.js\";\n\n/**\n * CallRecording class represents call recording related APIs.\n */\nexport class CallRecording {\n  private readonly callRecordingImpl: CallRecordingImpl;\n  private readonly contentDownloader: ContentDownloaderImpl;\n  private readonly callAutomationApiClient: CallAutomationApiClient;\n\n  constructor(\n    endpoint: string,\n    credential: KeyCredential | TokenCredential,\n    options?: CallAutomationApiClientOptionalParams,\n  ) {\n    this.callAutomationApiClient = createCustomCallAutomationApiClient(\n      credential,\n      options,\n      endpoint,\n    );\n\n    this.callRecordingImpl = new CallRecordingImpl(this.callAutomationApiClient);\n    this.contentDownloader = new ContentDownloaderImpl(this.callAutomationApiClient);\n  }\n\n  /**\n   * Starts a call recording with the specified options.\n   * @param startCallRecordingRequest - options to start the call recording\n   * @param options - Operation options.\n   */\n  public async start(options: StartRecordingOptions): Promise<RecordingStateResult> {\n    const startCallRecordingRequest: StartCallRecordingRequest = {\n      callLocator: options.callLocator ? options.callLocator : undefined,\n    };\n\n    startCallRecordingRequest.recordingChannelType = options.recordingChannel;\n    startCallRecordingRequest.recordingContentType = options.recordingContent;\n    startCallRecordingRequest.recordingFormatType = options.recordingFormat;\n    startCallRecordingRequest.recordingStateCallbackUri = options.recordingStateCallbackEndpointUrl;\n    startCallRecordingRequest.pauseOnStart = options.pauseOnStart;\n    startCallRecordingRequest.recordingStorage = options.recordingStorage;\n    startCallRecordingRequest.callConnectionId = options.callConnectionId\n      ? options.callConnectionId\n      : undefined;\n\n    if (options.channelAffinity) {\n      startCallRecordingRequest.channelAffinity = [];\n      options.channelAffinity.forEach((identifier) => {\n        startCallRecordingRequest.channelAffinity?.push({\n          participant: communicationIdentifierModelConverter(identifier.targetParticipant),\n          channel: identifier.channel,\n        });\n      });\n    }\n\n    if (options.audioChannelParticipantOrdering) {\n      startCallRecordingRequest.audioChannelParticipantOrdering = [];\n      options.audioChannelParticipantOrdering.forEach((identifier) => {\n        startCallRecordingRequest.audioChannelParticipantOrdering?.push(\n          communicationIdentifierModelConverter(identifier),\n        );\n      });\n    }\n    if (options.callLocator) {\n      if (options.callLocator.kind === \"groupCallLocator\") {\n        startCallRecordingRequest.callLocator = {\n          groupCallId: options.callLocator.id,\n          kind: \"groupCallLocator\",\n        };\n      } else if (options.callLocator.kind === \"roomCallLocator\") {\n        startCallRecordingRequest.callLocator = {\n          roomId: options.callLocator.id,\n          kind: \"roomCallLocator\",\n        };\n      } else {\n        startCallRecordingRequest.callLocator = {\n          serverCallId: options.callLocator.id,\n          kind: \"serverCallLocator\",\n        };\n      }\n    }\n\n    const optionsInternal = {\n      ...options,\n      repeatabilityFirstSent: new Date(),\n      repeatabilityRequestID: randomUUID(),\n    };\n    const response = await this.callRecordingImpl.startRecording(\n      startCallRecordingRequest,\n      optionsInternal,\n    );\n\n    const result: RecordingStateResult = {\n      recordingId: response.recordingId!,\n      recordingKind: response.recordingKind!,\n      recordingState: response.recordingState!,\n    };\n\n    return result;\n  }\n\n  /**\n   * Returns call recording properties.\n   * @param recordingId - The recordingId associated with the recording.\n   * @param options - Additional request options contains getRecordingProperties api options.\n   */\n  public async getState(\n    recordingId: string,\n    options: GetRecordingPropertiesOptions = {},\n  ): Promise<RecordingStateResult> {\n    const response = await this.callRecordingImpl.getRecordingProperties(recordingId, options);\n\n    const result: RecordingStateResult = {\n      recordingId: response.recordingId!,\n      recordingKind: response.recordingKind!,\n      recordingState: response.recordingState!,\n    };\n\n    return result;\n  }\n\n  /**\n   * Stops a call recording.\n   * @param recordingId - The recordingId associated with the recording.\n   * @param options - Additional request options contains stopRecording api options.\n   */\n  public async stop(recordingId: string, options: StopRecordingOptions = {}): Promise<void> {\n    return this.callRecordingImpl.stopRecording(recordingId, options);\n  }\n\n  /**\n   * Pauses a call recording.\n   * @param recordingId - The recordingId associated with the recording.\n   * @param options - Additional request options contains pauseRecording api options.\n   */\n  public async pause(recordingId: string, options: PauseRecordingOptions = {}): Promise<void> {\n    return this.callRecordingImpl.pauseRecording(recordingId, options);\n  }\n\n  /**\n   * Resumes a call recording.\n   * @param recordingId - The recordingId associated with the recording.\n   * @param options - Additional request options contains resumeRecording api options.\n   */\n  public async resume(recordingId: string, options: ResumeRecordingOptions = {}): Promise<void> {\n    return this.callRecordingImpl.resumeRecording(recordingId, options);\n  }\n\n  /**\n   * Deletes a recording.\n   * @param recordingLocationUrl - The recording location url. Required.\n   * @param options - Additional request options contains deleteRecording api options.\n   */\n  public async delete(\n    recordingLocationUrl: string,\n    options: DeleteRecordingOptions = {},\n  ): Promise<void> {\n    await this.contentDownloader.deleteRecording(recordingLocationUrl, options);\n  }\n\n  /**\n   * Returns a stream with a call recording.\n   * @param sourceLocationUrl - The source location url. Required.\n   * @param options - Additional request options contains downloadRecording api options.\n   */\n  public async downloadStreaming(\n    sourceLocationUrl: string,\n    options: DownloadRecordingOptions = {},\n  ): Promise<NodeJS.ReadableStream> {\n    const result = this.contentDownloader.download(sourceLocationUrl, options);\n    const recordingStream = (await result).readableStreamBody;\n    if (recordingStream) {\n      return recordingStream;\n    } else {\n      throw Error(\"failed to get stream\");\n    }\n  }\n\n  /**\n   * Downloads a call recording file to the specified stream.\n   * @param sourceLocationUrl - The source location url. Required.\n   * @param destinationStream - The destination stream. Required.\n   * @param options - Additional request options contains downloadRecording api options.\n   */\n  public async downloadToStream(\n    sourceLocationUrl: string,\n    destinationStream: NodeJS.WritableStream,\n    options: DownloadRecordingOptions = {},\n  ): Promise<void> {\n    const result = this.contentDownloader.download(sourceLocationUrl, options);\n    const recordingStream = (await result).readableStreamBody;\n    if (recordingStream) {\n      recordingStream.pipe(destinationStream);\n      const finish = new Promise<void>((resolve, reject) => {\n        destinationStream.on(\"finish\", resolve);\n        destinationStream.on(\"error\", reject);\n      });\n      await finish;\n    } else {\n      throw Error(\"failed to get stream\");\n    }\n  }\n\n  /**\n   * Downloads a call recording file to the specified path.\n   * @param sourceLocationUrl - The source location url. Required.\n   * @param destinationPath - The destination path. Required.\n   * @param options - Additional request options contains downloadRecording api options.\n   */\n  public async downloadToPath(\n    sourceLocationUrl: string,\n    destinationPath: string,\n    options: DownloadRecordingOptions = {},\n  ): Promise<void> {\n    const result = this.contentDownloader.download(sourceLocationUrl, options);\n    const recordingStream = (await result).readableStreamBody;\n    if (recordingStream) {\n      const writeFileStream = fs.createWriteStream(destinationPath);\n      recordingStream.pipe(writeFileStream);\n      const finish = new Promise<void>((resolve, reject) => {\n        writeFileStream.on(\"finish\", resolve);\n        writeFileStream.on(\"error\", reject);\n      });\n      await finish;\n    } else {\n      throw Error(\"failed to get stream\");\n    }\n  }\n}\n"]}