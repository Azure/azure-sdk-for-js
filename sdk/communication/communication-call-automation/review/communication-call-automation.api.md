## API Report File for "@azure/communication-call-automation"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import type { CommonClientOptions } from '@azure/core-client';
import type { CommunicationIdentifier } from '@azure/communication-common';
import type { CommunicationUserIdentifier } from '@azure/communication-common';
import * as coreClient from '@azure/core-client';
import type { KeyCredential } from '@azure/core-auth';
import type { MicrosoftTeamsAppIdentifier } from '@azure/communication-common';
import type { MicrosoftTeamsUserIdentifier } from '@azure/communication-common';
import type { OperationOptions } from '@azure/core-client';
import type { PhoneNumberIdentifier } from '@azure/communication-common';
import type { TokenCredential } from '@azure/core-auth';

// @public
export interface AddParticipantEventResult {
    failureResult?: AddParticipantFailed;
    isSuccess: boolean;
    successResult?: AddParticipantSucceeded;
}

// @public
export interface AddParticipantFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "AddParticipantFailed";
    operationContext?: string;
    participant?: CommunicationIdentifier;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface AddParticipantOptions extends OperationOptions {
    invitationTimeoutInSeconds?: number;
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export interface AddParticipantResult {
    invitationId?: string;
    operationContext?: string;
    participant?: CallParticipant;
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<AddParticipantEventResult>;
}

// @public
export interface AddParticipantSucceeded {
    callConnectionId: string;
    correlationId: string;
    kind: "AddParticipantSucceeded";
    operationContext?: string;
    participant?: CommunicationIdentifier;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface AnswerCallEventResult {
    failureResult?: AnswerFailed;
    isSuccess: boolean;
    successResult?: CallConnected;
}

// @public
export interface AnswerCallOptions extends OperationOptions {
    callIntelligenceOptions?: CallIntelligenceOptions;
    customCallingContext?: CustomCallingContext;
    mediaStreamingOptions?: MediaStreamingOptions;
    operationContext?: string;
    transcriptionOptions?: TranscriptionOptions;
}

// @public
export interface AnswerCallResult {
    callConnection: CallConnection;
    callConnectionProperties: CallConnectionProperties;
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<AnswerCallEventResult>;
}

// @public (undocumented)
export interface AnswerFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "AnswerFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
interface AudioData_2 {
    data: string;
    isSilent?: boolean;
    participant?: CommunicationIdentifier | undefined;
    timestamp?: Date;
}
export { AudioData_2 as AudioData }

// @public
export type AudioFormat = string;

// @public
export interface AudioMetadata {
    channels: Channel;
    encoding: string;
    length: number;
    sampleRate: number;
    subscriptionId: string;
}

// @public
export class CallAutomationClient {
    constructor(connectionString: string, options?: CallAutomationClientOptions);
    constructor(endpoint: string, credential: TokenCredential | KeyCredential, options?: CallAutomationClientOptions);
    answerCall(incomingCallContext: string, callbackUrl: string, options?: AnswerCallOptions): Promise<AnswerCallResult>;
    connectCall(callLocator: CallLocator, callbackUrl: string, options?: ConnectCallOptions): Promise<ConnectCallResult>;
    createCall(targetParticipant: CallInvite, callbackUrl: string, options?: CreateCallOptions): Promise<CreateCallResult>;
    createGroupCall(targetParticipants: CommunicationIdentifier[], callbackUrl: string, options?: CreateCallOptions): Promise<CreateCallResult>;
    getCallConnection(callConnectionId: string): CallConnection;
    getCallRecording(): CallRecording;
    getEventProcessor(): CallAutomationEventProcessor;
    getSourceIdentity(): CommunicationUserIdentifier | undefined;
    redirectCall(incomingCallContext: string, targetParticipant: CallInvite, options?: RedirectCallOptions): Promise<void>;
    rejectCall(incomingCallContext: string, options?: RejectCallOptions): Promise<void>;
}

// @public
export interface CallAutomationClientOptions extends CommonClientOptions {
    sourceIdentity?: CommunicationUserIdentifier;
}

// @public
export type CallAutomationEvent = AddParticipantSucceeded | AddParticipantFailed | RemoveParticipantSucceeded | RemoveParticipantFailed | CallConnected | CallDisconnected | CallTransferAccepted | CallTransferFailed | ParticipantsUpdated | RecordingStateChanged | PlayCompleted | PlayFailed | PlayCanceled | RecognizeCompleted | RecognizeCanceled | RecognizeFailed | ContinuousDtmfRecognitionToneReceived | ContinuousDtmfRecognitionToneFailed | ContinuousDtmfRecognitionStopped | SendDtmfTonesCompleted | SendDtmfTonesFailed | CancelAddParticipantSucceeded | CancelAddParticipantFailed | TranscriptionStarted | TranscriptionStopped | TranscriptionUpdated | TranscriptionFailed | CreateCallFailed | AnswerFailed | HoldFailed | ConnectFailed | MediaStreamingStarted | MediaStreamingStopped | MediaStreamingFailed | StartRecordingFailed | PlayStarted | PlayPaused | PlayResumed | HoldAudioStarted | HoldAudioPaused | HoldAudioResumed | HoldAudioCompleted | IncomingCall;

// @public
export class CallAutomationEventProcessor {
    attachOngoingEventProcessor(callConnectionId: string, eventTypeKind: CallAutomationEvent["kind"], eventProcessor: (event: CallAutomationEvent) => Promise<void>): Promise<void>;
    detachOngoingEventProcessor(callConnectionId: string, eventTypeKind: CallAutomationEvent["kind"]): Promise<void>;
    processEvents(event: string | Record<string, unknown> | CallAutomationEvent): void;
    waitForEventProcessor(predicate: (event: CallAutomationEvent) => boolean, abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<CallAutomationEvent>;
}

// @public
export interface CallConnected {
    callConnectionId: string;
    correlationId: string;
    kind: "CallConnected";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export class CallConnection {
    // Warning: (ae-forgotten-export) The symbol "CallAutomationApiClientOptionalParams" needs to be exported by the entry point index.d.ts
    constructor(callConnectionId: string, endpoint: string, credential: KeyCredential | TokenCredential, eventProcessor: CallAutomationEventProcessor, options?: CallAutomationApiClientOptionalParams);
    addParticipant(targetParticipant: CallInvite, options?: AddParticipantOptions): Promise<AddParticipantResult>;
    cancelAddParticipantOperation(invitationId: string, options?: CancelAddParticipantOperationOptions): Promise<CancelAddParticipantOperationResult>;
    getCallConnectionProperties(options?: GetCallConnectionPropertiesOptions): Promise<CallConnectionProperties>;
    getCallMedia(): CallMedia;
    getParticipant(targetParticipant: CommunicationIdentifier, options?: GetParticipantOptions): Promise<CallParticipant>;
    hangUp(isForEveryone: boolean, options?: HangUpOptions): Promise<void>;
    listParticipants(options?: GetParticipantOptions): Promise<ListParticipantsResult>;
    muteParticipant(participant: CommunicationIdentifier, options?: MuteParticipantOption): Promise<MuteParticipantResult>;
    removeParticipant(participant: CommunicationIdentifier, options?: RemoveParticipantsOption): Promise<RemoveParticipantResult>;
    transferCallToParticipant(targetParticipant: CommunicationIdentifier, options?: TransferCallToParticipantOptions): Promise<TransferCallResult>;
}

// @public
export interface CallConnectionProperties {
    answeredby?: CommunicationUserIdentifier;
    answeredFor?: PhoneNumberIdentifier;
    callbackUrl?: string;
    callConnectionId?: string;
    callConnectionState?: CallConnectionStateModel;
    correlationId?: string;
    mediaStreamingSubscription?: MediaStreamingSubscription;
    mediaSubscriptionId?: string;
    serverCallId?: string;
    source?: CommunicationIdentifier;
    sourceCallerIdNumber?: PhoneNumberIdentifier;
    sourceDisplayName?: string;
    targetParticipants?: CommunicationIdentifier[];
    transcriptionSubscription?: TranscriptionSubscription;
}

// @public
export type CallConnectionStateModel = string;

// @public
export interface CallDisconnected {
    callConnectionId: string;
    correlationId: string;
    kind: "CallDisconnected";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface CallIntelligenceOptions {
    cognitiveServicesEndpoint?: string;
}

// @public
export interface CallInvite {
    customCallingContext?: CustomCallingContext;
    readonly sourceCallIdNumber?: PhoneNumberIdentifier;
    // (undocumented)
    sourceDisplayName?: string;
    readonly targetParticipant: PhoneNumberIdentifier | CommunicationUserIdentifier | MicrosoftTeamsUserIdentifier | MicrosoftTeamsAppIdentifier;
}

// @public
export interface CallLocator {
    // (undocumented)
    id: string;
    // (undocumented)
    kind: CallLocatorType;
}

// @public
export type CallLocatorType = "serverCallLocator" | "groupCallLocator" | "roomCallLocator";

// @public
export class CallMedia {
    constructor(callConnectionId: string, endpoint: string, credential: KeyCredential | TokenCredential, eventProcessor: CallAutomationEventProcessor, options?: CallAutomationApiClientOptionalParams);
    cancelAllOperations(): Promise<CancelAllMediaOperationsResult>;
    hold(targetParticipant: CommunicationIdentifier, options?: HoldOptions): Promise<void>;
    interruptAudioAndAnnounce(playSources: (FileSource | TextSource | SsmlSource)[], playTo: CommunicationIdentifier, options?: InterruptAudioAndAnnounceOptions): Promise<void>;
    play(playSources: (FileSource | TextSource | SsmlSource)[], playTo: CommunicationIdentifier[], options?: PlayOptions): Promise<PlayResult>;
    playToAll(playSources: (FileSource | TextSource | SsmlSource)[], options?: PlayToAllOptions): Promise<PlayResult>;
    sendDtmfTones(tones: Tone[] | DtmfTone[], targetParticipant: CommunicationIdentifier, options?: SendDtmfTonesOptions): Promise<SendDtmfTonesResult>;
    startContinuousDtmfRecognition(targetParticipant: CommunicationIdentifier, options?: ContinuousDtmfRecognitionOptions): Promise<void>;
    startMediaStreaming(options?: StartMediaStreamingOptions): Promise<void>;
    // @deprecated
    startRecognizing(targetParticipant: CommunicationIdentifier, maxTonesToCollect: number, options: CallMediaRecognizeDtmfOptions): Promise<StartRecognizingResult>;
    startRecognizing(targetParticipant: CommunicationIdentifier, options: CallMediaRecognizeDtmfOptions | CallMediaRecognizeChoiceOptions | CallMediaRecognizeSpeechOptions | CallMediaRecognizeSpeechOrDtmfOptions): Promise<StartRecognizingResult>;
    startTranscription(options?: StartTranscriptionOptions): Promise<void>;
    stopContinuousDtmfRecognition(targetParticipant: CommunicationIdentifier, options?: ContinuousDtmfRecognitionOptions): Promise<void>;
    stopMediaStreaming(options?: StopMediaStreamingOptions): Promise<void>;
    stopTranscription(options?: StopTranscriptionOptions): Promise<void>;
    unhold(targetParticipant: CommunicationIdentifier, options?: UnholdOptions): Promise<void>;
    updateTranscription(locale: string, options?: UpdateTranscriptionOptions): Promise<void>;
}

// @public
export interface CallMediaRecognizeChoiceOptions extends CallMediaRecognizeOptions {
    choices: RecognitionChoice[];
    // (undocumented)
    readonly kind: "callMediaRecognizeChoiceOptions";
    speechLanguage?: string;
    speechRecognitionModelEndpointId?: string;
}

// @public
export interface CallMediaRecognizeDtmfOptions extends CallMediaRecognizeOptions {
    interToneTimeoutInSeconds?: number;
    // (undocumented)
    readonly kind: "callMediaRecognizeDtmfOptions";
    maxTonesToCollect?: number;
    stopDtmfTones?: DtmfTone[];
}

// @public
export interface CallMediaRecognizeOptions extends OperationOptions {
    initialSilenceTimeoutInSeconds?: number;
    interruptCallMediaOperation?: boolean;
    interruptPrompt?: boolean;
    operationCallbackUrl?: string;
    operationContext?: string;
    playPrompt?: FileSource | TextSource | SsmlSource;
    playPrompts?: (FileSource | TextSource | SsmlSource)[];
    speechModelEndpointId?: string;
    // @deprecated (undocumented)
    stopCurrentOperations?: boolean;
}

// @public
export interface CallMediaRecognizeSpeechOptions extends CallMediaRecognizeOptions {
    endSilenceTimeoutInSeconds?: number;
    // (undocumented)
    readonly kind: "callMediaRecognizeSpeechOptions";
    speechLanguage?: string;
    speechRecognitionModelEndpointId?: string;
}

// @public
export interface CallMediaRecognizeSpeechOrDtmfOptions extends CallMediaRecognizeOptions {
    endSilenceTimeoutInSeconds?: number;
    interToneTimeoutInSeconds?: number;
    // (undocumented)
    readonly kind: "callMediaRecognizeSpeechOrDtmfOptions";
    maxTonesToCollect?: number;
    speechLanguage?: string;
    speechRecognitionModelEndpointId?: string;
    stopDtmfTones?: DtmfTone[];
}

// @public
export interface CallParticipant {
    identifier?: CommunicationIdentifier;
    isMuted?: boolean;
    isOnHold?: boolean;
}

// @public
export class CallRecording {
    constructor(endpoint: string, credential: KeyCredential | TokenCredential, options?: CallAutomationApiClientOptionalParams);
    delete(recordingLocationUrl: string, options?: DeleteRecordingOptions): Promise<void>;
    downloadStreaming(sourceLocationUrl: string, options?: DownloadRecordingOptions): Promise<NodeJS.ReadableStream>;
    downloadToPath(sourceLocationUrl: string, destinationPath: string, options?: DownloadRecordingOptions): Promise<void>;
    downloadToStream(sourceLocationUrl: string, destinationStream: NodeJS.WritableStream, options?: DownloadRecordingOptions): Promise<void>;
    getState(recordingId: string, options?: GetRecordingPropertiesOptions): Promise<RecordingStateResult>;
    pause(recordingId: string, options?: PauseRecordingOptions): Promise<void>;
    resume(recordingId: string, options?: ResumeRecordingOptions): Promise<void>;
    start(options: StartRecordingOptions): Promise<RecordingStateResult>;
    stop(recordingId: string, options?: StopRecordingOptions): Promise<void>;
}

// @public
export type CallRejectReason = string;

// @public
export interface CallTransferAccepted {
    callConnectionId: string;
    correlationId: string;
    kind: "CallTransferAccepted";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
    transferee: CommunicationIdentifier;
    transferTarget: CommunicationIdentifier;
}

// @public
export interface CallTransferFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "CallTransferFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface CancelAddParticipantEventResult {
    failureResult?: CancelAddParticipantFailed;
    isSuccess: boolean;
    successResult?: CancelAddParticipantSucceeded;
}

// @public
export interface CancelAddParticipantFailed {
    callConnectionId: string;
    correlationId: string;
    invitationId: string;
    kind: "CancelAddParticipantFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface CancelAddParticipantOperationOptions extends OperationOptions {
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export interface CancelAddParticipantOperationResult {
    invitationId?: string;
    operationContext?: string;
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<CancelAddParticipantEventResult>;
}

// @public
export interface CancelAddParticipantSucceeded {
    callConnectionId: string;
    correlationId: string;
    invitationId: string;
    kind: "CancelAddParticipantSucceeded";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface CancelAllMediaOperationsEventResult {
    isSuccess: boolean;
    playCanceledSuccessResult?: PlayCanceled;
    recognizeCanceledSuccessResult?: RecognizeCanceled;
}

// @public
export interface CancelAllMediaOperationsResult {
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<CancelAllMediaOperationsEventResult>;
}

// @public (undocumented)
export enum Channel {
    // (undocumented)
    Mono = 1,
    // (undocumented)
    Unknown = 0
}

// @public
export interface ChannelAffinity {
    channel?: number;
    targetParticipant: CommunicationIdentifier;
}

// @public (undocumented)
export interface ChoiceResult {
    label?: string;
    recognizedPhrase?: string;
}

// @public
export type CommunicationCloudEnvironmentModel = string;

// @public
export interface CommunicationIdentifierModel {
    communicationUser?: CommunicationUserIdentifierModel;
    kind?: CommunicationIdentifierModelKind;
    microsoftTeamsApp?: MicrosoftTeamsAppIdentifierModel;
    microsoftTeamsUser?: MicrosoftTeamsUserIdentifierModel;
    phoneNumber?: PhoneNumberIdentifierModel;
    rawId?: string;
}

// @public
export type CommunicationIdentifierModelKind = string;

// @public
export interface CommunicationUserIdentifierModel {
    id: string;
}

// @public
export interface ConnectCallEventResult {
    failureResult?: ConnectFailed;
    isSuccess: boolean;
    successResult?: CallConnected;
}

// @public
export interface ConnectCallOptions extends OperationOptions {
    callIntelligenceOptions?: CallIntelligenceOptions;
    mediaStreamingOptions?: MediaStreamingOptions;
    operationContext?: string;
    transcriptionOptions?: TranscriptionOptions;
}

// @public
export interface ConnectCallResult {
    callConnection: CallConnection;
    callConnectionProperties: CallConnectionProperties;
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<ConnectCallEventResult>;
}

// @public (undocumented)
export interface ConnectFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "ConnectFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface ContinuousDtmfRecognitionOptions extends OperationOptions {
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export interface ContinuousDtmfRecognitionStopped {
    callConnectionId: string;
    correlationId: string;
    kind: "ContinuousDtmfRecognitionStopped";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface ContinuousDtmfRecognitionToneFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "ContinuousDtmfRecognitionToneFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface ContinuousDtmfRecognitionToneReceived {
    callConnectionId: string;
    correlationId: string;
    kind: "ContinuousDtmfRecognitionToneReceived";
    operationContext?: string;
    resultInformation?: ResultInformation;
    sequenceId: number;
    serverCallId: string;
    tone: Tone;
}

// @public
export interface CreateCallEventResult {
    failureResult?: CreateCallFailed;
    isSuccess: boolean;
    successResult?: CallConnected;
}

// @public (undocumented)
export interface CreateCallFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "CreateCallFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface CreateCallOptions extends OperationOptions {
    callIntelligenceOptions?: CallIntelligenceOptions;
    customCallingContext?: CustomCallingContext;
    mediaStreamingOptions?: MediaStreamingOptions;
    operationContext?: string;
    sourceCallIdNumber?: PhoneNumberIdentifier;
    sourceDisplayName?: string;
    teamsAppSource?: MicrosoftTeamsAppIdentifier;
    transcriptionOptions?: TranscriptionOptions;
}

// @public
export interface CreateCallResult {
    callConnection: CallConnection;
    callConnectionProperties: CallConnectionProperties;
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<CreateCallEventResult>;
}

// @public
export type CustomCallingContext = (VoipHeader | SipUserToUserHeader | SipCustomHeader)[];

// @public (undocumented)
export interface CustomCallingContextHeader {
    // (undocumented)
    key: string;
    // (undocumented)
    value: string;
}

// @public
export interface CustomCallingContextInternal {
    sipHeaders?: {
        [propertyName: string]: string;
    };
    voipHeaders?: {
        [propertyName: string]: string;
    };
}

// @public
export type DeleteRecordingOptions = OperationOptions;

// @public
export interface DownloadRecordingOptions extends OperationOptions {
    length?: number;
    offset?: number;
}

// @public (undocumented)
export interface DtmfResult {
    readonly tones?: Tone[];
}

// @public
export enum DtmfTone {
    // (undocumented)
    A = "a",
    Asterisk = "asterisk",
    // (undocumented)
    B = "b",
    // (undocumented)
    C = "c",
    // (undocumented)
    D = "d",
    Eight = "eight",
    Five = "five",
    Four = "four",
    Nine = "nine",
    One = "one",
    Pound = "pound",
    Seven = "seven",
    Six = "six",
    Three = "three",
    Two = "two",
    Zero = "zero"
}

// @public
export interface FileSource extends PlaySource {
    // (undocumented)
    readonly kind: "fileSource";
    // (undocumented)
    url: string;
}

// @public
export type GetCallConnectionPropertiesOptions = OperationOptions;

// @public
export type GetParticipantOptions = OperationOptions;

// @public
export type GetRecordingPropertiesOptions = OperationOptions;

// @public
export type HangUpOptions = OperationOptions;

// @public
export interface HoldAudioCompleted {
    callConnectionId: string;
    correlationId: string;
    kind: "HoldAudioCompleted";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface HoldAudioPaused {
    callConnectionId: string;
    correlationId: string;
    kind: "HoldAudioPaused";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface HoldAudioResumed {
    callConnectionId: string;
    correlationId: string;
    kind: "HoldAudioResumed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface HoldAudioStarted {
    callConnectionId: string;
    correlationId: string;
    kind: "HoldAudioStarted";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public (undocumented)
export interface HoldFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "HoldFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface HoldOptions extends OperationOptions {
    operationCallbackUri?: string;
    operationContext?: string;
    playSource?: FileSource | TextSource | SsmlSource;
}

// @public
export interface IncomingCall {
    callConnectionId: string;
    callerDisplayName?: string;
    correlationId: string;
    customContext?: CustomCallingContextInternal;
    from?: CommunicationIdentifierModel;
    incomingCallContext?: string;
    kind: "IncomingCall";
    onBehalfOfCallee?: CommunicationIdentifierModel;
    resultInformation?: ResultInformation;
    to?: CommunicationIdentifierModel;
}

// @public
export interface InterruptAudioAndAnnounceOptions extends OperationOptions {
    operationContext?: string;
}

// @public
export enum KnownAudioFormat {
    Pcm16KMono = "Pcm16KMono",
    Pcm24KMono = "Pcm24KMono"
}

// @public
export enum KnownCallConnectionStateModel {
    Connected = "connected",
    Connecting = "connecting",
    Disconnected = "disconnected",
    Disconnecting = "disconnecting",
    TransferAccepted = "transferAccepted",
    Transferring = "transferring",
    Unknown = "unknown"
}

// @public
export enum KnownCallRejectReason {
    Busy = "busy",
    Forbidden = "forbidden",
    None = "none"
}

// @public
export enum KnownCommunicationCloudEnvironmentModel {
    Dod = "dod",
    Gcch = "gcch",
    Public = "public"
}

// @public
export enum KnownCommunicationIdentifierModelKind {
    CommunicationUser = "communicationUser",
    MicrosoftTeamsApp = "microsoftTeamsApp",
    MicrosoftTeamsUser = "microsoftTeamsUser",
    PhoneNumber = "phoneNumber",
    Unknown = "unknown"
}

// @public
export enum KnownMediaStreamingAudioChannelType {
    Mixed = "mixed",
    Unmixed = "unmixed"
}

// @public
export enum KnownMediaStreamingContentType {
    Audio = "audio"
}

// @public
export enum KnownMediaStreamingStatus {
    MediaStreamingFailed = "mediaStreamingFailed",
    MediaStreamingStarted = "mediaStreamingStarted",
    MediaStreamingStopped = "mediaStreamingStopped",
    UnspecifiedError = "unspecifiedError"
}

// @public
export enum KnownMediaStreamingStatusDetails {
    AuthenticationFailure = "authenticationFailure",
    BadRequest = "badRequest",
    Forbidden = "forbidden",
    InitialWebSocketConnectionFailed = "initialWebSocketConnectionFailed",
    ServiceShutdown = "serviceShutdown",
    ServiceTimeout = "serviceTimeout",
    SpeechServicesConnectionError = "speechServicesConnectionError",
    StreamConnectionInterrupted = "streamConnectionInterrupted",
    StreamConnectionReestablished = "streamConnectionReestablished",
    StreamConnectionUnsuccessful = "streamConnectionUnsuccessful",
    StreamUrlMissing = "streamUrlMissing",
    SubscriptionStarted = "subscriptionStarted",
    SubscriptionStopped = "subscriptionStopped",
    TooManyRequests = "tooManyRequests",
    UnspecifiedError = "unspecifiedError"
}

// @public
export enum KnownMediaStreamingSubscriptionState {
    Active = "active",
    Disabled = "disabled",
    Inactive = "inactive"
}

// @public
export enum KnownMediaStreamingTransportType {
    Websocket = "websocket"
}

// @public
export enum KnownRecognitionType {
    Choices = "choices",
    Dtmf = "dtmf",
    Speech = "speech"
}

// @public
export enum KnownRecordingKind {
    AzureCommunicationServices = "AzureCommunicationServices",
    Teams = "Teams",
    TeamsCompliance = "TeamsCompliance"
}

// @public
export enum KnownRecordingState {
    Active = "active",
    Inactive = "inactive"
}

// @public
export enum KnownTone {
    // (undocumented)
    A = "a",
    Asterisk = "asterisk",
    // (undocumented)
    B = "b",
    // (undocumented)
    C = "c",
    // (undocumented)
    D = "d",
    Eight = "eight",
    Five = "five",
    Four = "four",
    Nine = "nine",
    One = "one",
    Pound = "pound",
    Seven = "seven",
    Six = "six",
    Three = "three",
    Two = "two",
    Zero = "zero"
}

// @public
export enum KnownTranscriptionResultState {
    Final = "final",
    Intermediate = "intermediate"
}

// @public
export enum KnownTranscriptionStatus {
    TranscriptionFailed = "transcriptionFailed",
    TranscriptionResumed = "transcriptionResumed",
    TranscriptionStarted = "transcriptionStarted",
    TranscriptionStopped = "transcriptionStopped",
    TranscriptionUpdated = "transcriptionUpdated",
    UnspecifiedError = "unspecifiedError"
}

// @public
export enum KnownTranscriptionStatusDetails {
    AuthenticationFailure = "authenticationFailure",
    BadRequest = "badRequest",
    Forbidden = "forbidden",
    ServiceShutdown = "serviceShutdown",
    ServiceTimeout = "serviceTimeout",
    SpeechServicesConnectionError = "speechServicesConnectionError",
    StreamConnectionInterrupted = "streamConnectionInterrupted",
    StreamConnectionReestablished = "streamConnectionReestablished",
    StreamConnectionUnsuccessful = "streamConnectionUnsuccessful",
    StreamUrlMissing = "streamUrlMissing",
    SubscriptionStarted = "subscriptionStarted",
    SubscriptionStopped = "subscriptionStopped",
    TooManyRequests = "tooManyRequests",
    TranscriptionLocaleUpdated = "transcriptionLocaleUpdated",
    UnspecifiedError = "unspecifiedError"
}

// @public
export enum KnownTranscriptionSubscriptionState {
    Active = "active",
    Disabled = "disabled",
    Inactive = "inactive"
}

// @public
export enum KnownTranscriptionTransportType {
    Websocket = "websocket"
}

// @public
export interface ListParticipantsResult {
    nextLink?: string;
    values?: CallParticipant[];
}

// @public (undocumented)
export enum MediaKind {
    AudioData = "audioData",
    StopAudio = "stopAudio"
}

// @public
export type MediaStreamingAudioChannelType = string;

// @public
export type MediaStreamingContentType = string;

// @public (undocumented)
export interface MediaStreamingFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "MediaStreamingFailed";
    mediaStreamingUpdate?: MediaStreamingUpdate;
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface MediaStreamingOptions {
    audioChannelType: MediaStreamingAudioChannelType;
    audioFormat?: AudioFormat;
    contentType: MediaStreamingContentType;
    enableBidirectional?: boolean;
    startMediaStreaming?: boolean;
    transportType: MediaStreamingTransportType;
    transportUrl: string;
}

// @public (undocumented)
export interface MediaStreamingStarted {
    callConnectionId: string;
    correlationId: string;
    kind: "MediaStreamingStarted";
    mediaStreamingUpdate?: MediaStreamingUpdate;
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export type MediaStreamingStatus = string;

// @public
export type MediaStreamingStatusDetails = string;

// @public (undocumented)
export interface MediaStreamingStopped {
    callConnectionId: string;
    correlationId: string;
    kind: "MediaStreamingStopped";
    mediaStreamingUpdate?: MediaStreamingUpdate;
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface MediaStreamingSubscription {
    id?: string;
    state?: MediaStreamingSubscriptionState;
    subscribedContentTypes?: MediaStreamingContentType[];
}

// @public
export type MediaStreamingSubscriptionState = string;

// @public
export type MediaStreamingTransportType = string;

// @public (undocumented)
export interface MediaStreamingUpdate {
    // (undocumented)
    contentType?: string;
    // (undocumented)
    mediaStreamingStatus?: MediaStreamingStatus;
    // (undocumented)
    mediaStreamingStatusDetails?: MediaStreamingStatusDetails;
}

// @public
export interface MicrosoftTeamsAppIdentifierModel {
    appId: string;
    cloud?: CommunicationCloudEnvironmentModel;
}

// @public
export interface MicrosoftTeamsUserIdentifierModel {
    cloud?: CommunicationCloudEnvironmentModel;
    isAnonymous?: boolean;
    userId: string;
}

// @public
export interface MuteParticipantOption extends OperationOptions {
    operationContext?: string;
}

// @public
export interface MuteParticipantResult {
    operationContext?: string;
}

// @public (undocumented)
export class OutStreamingData {
    constructor(kind: MediaKind);
    audioData?: AudioData_2;
    static getStopAudioForOutbound(): string;
    static getStreamingDataForOutbound(data: string): string;
    kind: MediaKind;
    stopAudio?: StopAudio;
}

// @public
export function parseCallAutomationEvent(encodedEvents: string | Record<string, unknown>): CallAutomationEvent;

// @public
export interface ParticipantsUpdated {
    callConnectionId: string;
    correlationId: string;
    kind: "ParticipantsUpdated";
    participants: CallParticipant[];
    resultInformation?: ResultInformation;
    sequenceNumber?: number;
    serverCallId: string;
}

// @public
export type PauseRecordingOptions = OperationOptions;

// @public
export interface PhoneNumberIdentifierModel {
    value: string;
}

// @public
export interface PlayCanceled {
    callConnectionId: string;
    correlationId: string;
    kind: "PlayCanceled";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface PlayCompleted {
    callConnectionId: string;
    correlationId: string;
    kind: "PlayCompleted";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface PlayEventResult {
    failureResult?: PlayFailed;
    isSuccess: boolean;
    successResult?: PlayCompleted;
}

// @public
export interface PlayFailed {
    callConnectionId: string;
    correlationId: string;
    failedPlaySourceIndex?: number;
    kind: "PlayFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface PlayOptions extends OperationOptions {
    interruptHoldAudio?: boolean;
    loop?: boolean;
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export interface PlayPaused {
    callConnectionId: string;
    correlationId: string;
    kind: "PlayPaused";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface PlayResult {
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<PlayEventResult>;
}

// @public
export interface PlayResumed {
    callConnectionId: string;
    correlationId: string;
    kind: "PlayResumed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface PlaySource {
    // @deprecated (undocumented)
    playsourcacheid?: string;
    playSourceCacheId?: string;
}

// @public
export interface PlayStarted {
    callConnectionId: string;
    correlationId: string;
    kind: "PlayStarted";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface PlayToAllOptions extends PlayOptions {
    interruptCallMediaOperation?: boolean;
}

// @public
export interface RecognitionChoice {
    label: string;
    phrases: string[];
    // (undocumented)
    tone?: DtmfTone;
}

// @public
export type RecognitionType = string;

// @public
export interface RecognizeCanceled {
    callConnectionId: string;
    correlationId: string;
    kind: "RecognizeCanceled";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface RecognizeCompleted {
    callConnectionId: string;
    choiceResult?: ChoiceResult;
    correlationId: string;
    dtmfResult?: DtmfResult;
    kind: "RecognizeCompleted";
    operationContext?: string;
    recognitionType?: RecognitionType;
    resultInformation?: ResultInformation;
    serverCallId: string;
    speechResult?: SpeechResult;
}

// @public
export interface RecognizeFailed {
    callConnectionId: string;
    correlationId: string;
    failedPlaySourceIndex?: number;
    kind: "RecognizeFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export enum RecognizeInputType {
    Choices = "choices",
    Dtmf = "dtmf"
}

// @public
export type RecordingChannel = "mixed" | "unmixed";

// @public
export type RecordingContent = "audio" | "audioVideo";

// @public
export type RecordingFormat = "mp3" | "mp4" | "wav";

// @public
export type RecordingKind = string;

// @public
type RecordingState_2 = string;
export { RecordingState_2 as RecordingState }

// @public
export interface RecordingStateChanged {
    callConnectionId: string;
    correlationId: string;
    kind: "RecordingStateChanged";
    recordingId?: string;
    // (undocumented)
    recordingKind?: RecordingKind;
    resultInformation?: ResultInformation;
    serverCallId: string;
    startDateTime?: Date;
    // (undocumented)
    state?: RecordingState_2;
}

// @public
export interface RecordingStateResult {
    // (undocumented)
    recordingId: string;
    // (undocumented)
    recordingKind: string;
    // (undocumented)
    recordingState: RecordingState_2;
}

// @public
export interface RecordingStorage {
    recordingDestinationContainerUrl?: string;
    recordingStorageKind: RecordingStorageKind;
}

// @public
export type RecordingStorageKind = "azureCommunicationServices" | "azureBlobStorage";

// @public
export interface RedirectCallOptions extends OperationOptions {
    customCallingContext?: CustomCallingContext;
}

// @public
export interface RejectCallOptions extends OperationOptions {
    callRejectReason?: CallRejectReason;
}

// @public
export interface RemoveParticipantEventResult {
    failureResult?: RemoveParticipantFailed;
    isSuccess: boolean;
    successResult?: RemoveParticipantSucceeded;
}

// @public
export interface RemoveParticipantFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "RemoveParticipantFailed";
    operationContext?: string;
    participant?: CommunicationIdentifier;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface RemoveParticipantResult {
    operationContext?: string;
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<RemoveParticipantEventResult>;
}

// @public
export interface RemoveParticipantsOption extends OperationOptions {
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export interface RemoveParticipantSucceeded {
    callConnectionId: string;
    correlationId: string;
    kind: "RemoveParticipantSucceeded";
    operationContext?: string;
    participant?: CommunicationIdentifier;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public (undocumented)
export interface ResultInformation {
    code: number;
    message: string;
    subCode: number;
}

// @public
export type ResumeRecordingOptions = OperationOptions;

// @public
export interface SendDtmfEventResult {
    failureResult?: SendDtmfTonesFailed;
    isSuccess: boolean;
    successResult?: SendDtmfTonesCompleted;
}

// @public
export interface SendDtmfTonesCompleted {
    callConnectionId: string;
    correlationId: string;
    kind: "SendDtmfTonesCompleted";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface SendDtmfTonesFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "SendDtmfTonesFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface SendDtmfTonesOptions extends OperationOptions {
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export interface SendDtmfTonesResult {
    operationContext?: string;
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<SendDtmfEventResult>;
}

// @public
export interface SipCustomHeader extends CustomCallingContextHeader {
    // (undocumented)
    kind: "sipx";
    // (undocumented)
    sipHeaderPrefix?: SipHeaderPrefix;
}

// @public
export type SipHeaderPrefix = "X-" | "X-MS-Custom-";

// @public
export interface SipUserToUserHeader extends CustomCallingContextHeader {
    // (undocumented)
    kind: "sipuui";
}

// @public
export interface SpeechResult {
    speech?: string;
}

// @public
export interface SsmlSource extends PlaySource {
    // (undocumented)
    customVoiceEndpointId?: string;
    // (undocumented)
    readonly kind: "ssmlSource";
    // (undocumented)
    ssmlText: string;
}

// @public
export interface StartMediaStreamingOptions extends OperationOptions {
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export interface StartRecognizingEventResult {
    failureResult?: RecognizeFailed;
    isSuccess: boolean;
    successResult?: RecognizeCompleted;
}

// @public
export interface StartRecognizingResult {
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<StartRecognizingEventResult>;
}

// @public (undocumented)
export interface StartRecordingFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "StartRecordingFailed";
    recordingId?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
}

// @public
export interface StartRecordingOptions extends OperationOptions {
    audioChannelParticipantOrdering?: CommunicationIdentifier[];
    callConnectionId?: string;
    callLocator?: CallLocator;
    channelAffinity?: ChannelAffinity[];
    pauseOnStart?: boolean;
    recordingChannel?: RecordingChannel;
    recordingContent?: RecordingContent;
    recordingFormat?: RecordingFormat;
    recordingStateCallbackEndpointUrl?: string;
    recordingStorage?: RecordingStorage;
}

// @public
export interface StartTranscriptionOptions extends OperationOptions {
    locale?: string;
    operationCallbackUrl?: string;
    operationContext?: string;
    speechRecognitionModelEndpointId?: string;
}

// @public (undocumented)
export interface StopAudio {
}

// @public
export interface StopMediaStreamingOptions extends OperationOptions {
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export type StopRecordingOptions = OperationOptions;

// @public
export interface StopTranscriptionOptions extends OperationOptions {
    operationCallbackUrl?: string;
    operationContext?: string;
}

// @public
export class StreamingData {
    // (undocumented)
    static getStreamingKind(): StreamingDataKind;
    static parse(data: string | ArrayBuffer): StreamingDataResult;
}

// @public (undocumented)
export enum StreamingDataKind {
    // (undocumented)
    AudioData = "AudioData",
    // (undocumented)
    AudioMetadata = "AudioMetadata",
    // (undocumented)
    TranscriptionData = "TranscriptionData",
    // (undocumented)
    TranscriptionMetadata = "TranscriptionMetadata"
}

// @public (undocumented)
export type StreamingDataResult = TranscriptionMetadata | TranscriptionData | AudioData_2 | AudioMetadata;

// @public
export enum TextFormat {
    Display = "display"
}

// @public
export interface TextSource extends PlaySource {
    // (undocumented)
    customVoiceEndpointId?: string;
    // (undocumented)
    readonly kind: "textSource";
    // (undocumented)
    sourceLocale?: string;
    // (undocumented)
    text: string;
    // (undocumented)
    voiceKind?: VoiceKind;
    // (undocumented)
    voiceName?: string;
}

// @public
export type Tone = string;

// @public
export interface TranscriptionData {
    confidence: number;
    durationInTicks: number;
    format: TextFormat;
    offsetInTicks: number;
    participant: CommunicationIdentifier;
    resultState: TranscriptionResultState;
    text: string;
    words: WordData[];
}

// @public (undocumented)
export interface TranscriptionFailed {
    callConnectionId: string;
    correlationId: string;
    kind: "TranscriptionFailed";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
    transcriptionUpdate?: TranscriptionUpdate;
}

// @public
export interface TranscriptionMetadata {
    callConnectionId: string;
    correlationId: string;
    locale: string;
    subscriptionId: string;
}

// @public
export interface TranscriptionOptions {
    enableIntermediateResults?: boolean;
    locale: string;
    speechRecognitionModelEndpointId?: string;
    startTranscription: boolean;
    transportType: TranscriptionTransportType;
    transportUrl: string;
}

// @public
export type TranscriptionResultState = string;

// @public (undocumented)
export interface TranscriptionStarted {
    callConnectionId: string;
    correlationId: string;
    kind: "TranscriptionStarted";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
    transcriptionUpdate?: TranscriptionUpdate;
}

// @public
export type TranscriptionStatus = string;

// @public
export type TranscriptionStatusDetails = string;

// @public (undocumented)
export interface TranscriptionStopped {
    callConnectionId: string;
    correlationId: string;
    kind: "TranscriptionStopped";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
    transcriptionUpdate?: TranscriptionUpdate;
}

// @public
export interface TranscriptionSubscription {
    id?: string;
    state?: TranscriptionSubscriptionState;
    subscribedResultStates?: TranscriptionResultState[];
}

// @public
export type TranscriptionSubscriptionState = string;

// @public
export type TranscriptionTransportType = string;

// @public (undocumented)
export interface TranscriptionUpdate {
    // (undocumented)
    transcriptionStatus?: TranscriptionStatus;
    // (undocumented)
    transcriptionStatusDetails?: TranscriptionStatusDetails;
}

// @public (undocumented)
export interface TranscriptionUpdated {
    callConnectionId: string;
    correlationId: string;
    kind: "TranscriptionUpdated";
    operationContext?: string;
    resultInformation?: ResultInformation;
    serverCallId: string;
    transcriptionUpdate?: TranscriptionUpdate;
}

// @public
export interface TransferCallResult {
    operationContext?: string;
    waitForEventProcessor(abortSignal?: AbortSignalLike, timeoutInMs?: number): Promise<TransferCallToParticipantEventResult>;
}

// @public
export interface TransferCallToParticipantEventResult {
    failureResult?: CallTransferFailed;
    isSuccess: boolean;
    successResult?: CallTransferAccepted;
}

// @public
export interface TransferCallToParticipantOptions extends OperationOptions {
    customCallingContext?: CustomCallingContext;
    operationCallbackUrl?: string;
    operationContext?: string;
    sourceCallIdNumber?: PhoneNumberIdentifier;
    transferee?: CommunicationIdentifier;
}

// @public
export interface UnholdOptions extends OperationOptions {
    operationContext?: string;
}

// @public
export interface UpdateTranscriptionOptions extends OperationOptions {
    operationCallbackUrl?: string;
    operationContext?: string;
    speechRecognitionModelEndpointId?: string;
}

// @public
export enum VoiceKind {
    Female = "female",
    Male = "male"
}

// @public
export interface VoipHeader extends CustomCallingContextHeader {
    // (undocumented)
    kind: "voip";
}

// @public
export interface WordData {
    durationInTicks: number;
    offsetInTicks: number;
    text: string;
}

// (No @packageDocumentation comment for this package)

```
