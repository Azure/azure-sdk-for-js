{"version":3,"file":"mappings.js","sourceRoot":"","sources":["../../src/mappings.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { OperationOptions } from \"@azure-rest/core-client\";\nimport type {\n  KeyVaultRoleAssignment,\n  KeyVaultRoleDefinition,\n  KeyVaultRoleScope,\n} from \"./accessControlModels.js\";\nimport type { PagedAsyncIterableIterator, PageSettings } from \"./generated/index.js\";\nimport type { RoleAssignment, RoleDefinition } from \"./generated/models/index.js\";\n\nexport const mappings = {\n  roleAssignment: {\n    generatedToPublic(roleAssignment: RoleAssignment): KeyVaultRoleAssignment {\n      const { id, name, type, properties } = roleAssignment;\n      const { scope, roleDefinitionId, principalId } = properties || {};\n      return {\n        id: id!,\n        name: name!,\n        kind: type!,\n        properties: {\n          scope: scope as KeyVaultRoleScope,\n          roleDefinitionId: roleDefinitionId!,\n          principalId: principalId!,\n        },\n      };\n    },\n  },\n  roleDefinition: {\n    generatedToPublic(roleDefinition: RoleDefinition): KeyVaultRoleDefinition {\n      const { id, name, type } = roleDefinition;\n      const { roleName, description, roleType, permissions, assignableScopes } =\n        roleDefinition.properties || {};\n      return {\n        id: id!,\n        name: name!,\n        kind: type!,\n        roleName: roleName!,\n        description: description!,\n        roleType: roleType!,\n        permissions: permissions!,\n        assignableScopes: assignableScopes!,\n      };\n    },\n  },\n  folderUriParts(folderUri: string): { folderName: string; folderUri: string } {\n    const uriParts = folderUri.split(\"/\");\n    const folderName = uriParts.pop();\n    const storageUri = uriParts.join(\"/\");\n\n    if (!folderName) {\n      throw new Error(\"The provided folder URI is missing the folder name.\");\n    }\n\n    return {\n      folderName,\n      folderUri: storageUri,\n    };\n  },\n};\n\n/**\n * A helper supporting compatibility between modular and legacy paged async iterables.\n *\n * Provides the following compatibility:\n * 1. Maps the values of the paged async iterable using the provided mapper function.\n * 2. Supports `maxPageSize` operation on the paged async iterable.\n *\n * TODO: move this to keyvault-common once everything is merged.\n */\nexport function mapPagedAsyncIterable<\n  TGenerated,\n  TPublic,\n  TOptions extends OperationOptions & { maxresults?: number },\n>(\n  options: TOptions,\n  operation: (options: TOptions) => PagedAsyncIterableIterator<TGenerated>,\n  mapper: (x: TGenerated) => TPublic,\n): PagedAsyncIterableIterator<TPublic> {\n  let iter: ReturnType<typeof operation> | undefined = undefined;\n  return {\n    async next() {\n      iter ??= operation({ ...options, maxresults: undefined });\n      const result = await iter.next();\n\n      return {\n        ...result,\n        value: result.value && mapper(result.value),\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n    async *byPage<TSettings extends PageSettings & { maxPageSize?: number }>(settings?: TSettings) {\n      // Pass the maxPageSize value to the underlying page operation\n      const iteratorByPage = operation({ ...options, maxresults: settings?.maxPageSize }).byPage(\n        settings,\n      );\n      for await (const page of iteratorByPage) {\n        yield page.map(mapper);\n      }\n    },\n  };\n}\n"]}