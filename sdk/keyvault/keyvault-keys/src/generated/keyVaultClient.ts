/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";
import * as Parameters from "./models/parameters";
import * as Mappers from "./models/mappers";
import { KeyVaultClientContext } from "./keyVaultClientContext";
import {
  KeyVaultClientOptionalParams,
  ApiVersion73Preview,
  JsonWebKeyType,
  CreateKeyOptionalParams,
  CreateKeyResponse,
  RotateKeyOptionalParams,
  RotateKeyResponse,
  JsonWebKey,
  ImportKeyOptionalParams,
  ImportKeyResponse,
  DeleteKeyOptionalParams,
  DeleteKeyResponse,
  UpdateKeyOptionalParams,
  UpdateKeyResponse,
  GetKeyOptionalParams,
  GetKeyResponse,
  GetKeyVersionsOptionalParams,
  GetKeyVersionsResponse,
  GetKeysOptionalParams,
  GetKeysResponse,
  BackupKeyOptionalParams,
  BackupKeyResponse,
  RestoreKeyOptionalParams,
  RestoreKeyResponse,
  JsonWebKeyEncryptionAlgorithm,
  EncryptOptionalParams,
  EncryptResponse,
  DecryptOptionalParams,
  DecryptResponse,
  JsonWebKeySignatureAlgorithm,
  SignOptionalParams,
  SignResponse,
  VerifyOptionalParams,
  VerifyResponse,
  WrapKeyOptionalParams,
  WrapKeyResponse,
  UnwrapKeyOptionalParams,
  UnwrapKeyResponse,
  ReleaseOptionalParams,
  ReleaseResponse,
  GetDeletedKeysOptionalParams,
  GetDeletedKeysResponse,
  GetDeletedKeyOptionalParams,
  GetDeletedKeyResponse,
  PurgeDeletedKeyOptionalParams,
  RecoverDeletedKeyOptionalParams,
  RecoverDeletedKeyResponse,
  GetKeyRotationPolicyOptionalParams,
  GetKeyRotationPolicyResponse,
  KeyRotationPolicy,
  UpdateKeyRotationPolicyOptionalParams,
  UpdateKeyRotationPolicyResponse,
  GetRandomBytesOptionalParams,
  GetRandomBytesResponse,
  GetKeyVersionsNextOptionalParams,
  GetKeyVersionsNextResponse,
  GetKeysNextOptionalParams,
  GetKeysNextResponse,
  GetDeletedKeysNextOptionalParams,
  GetDeletedKeysNextResponse
} from "./models";

export class KeyVaultClient extends KeyVaultClientContext {
  /**
   * Initializes a new instance of the KeyVaultClient class.
   * @param apiVersion Api Version
   * @param options The parameter options
   */
  constructor(
    apiVersion: ApiVersion73Preview,
    options?: KeyVaultClientOptionalParams
  ) {
    super(apiVersion, options);
  }

  /**
   * The create key operation can be used to create any key type in Azure Key Vault. If the named key
   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create
   * permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name for the new key. The system will generate the version name for the new key.
   * @param kty The type of key to create. For valid values, see JsonWebKeyType.
   * @param options The options parameters.
   */
  createKey(
    vaultBaseUrl: string,
    keyName: string,
    kty: JsonWebKeyType,
    options?: CreateKeyOptionalParams
  ): Promise<CreateKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      kty,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      createKeyOperationSpec
    ) as Promise<CreateKeyResponse>;
  }

  /**
   * The operation will rotate the key based on the key policy. It requires the keys/rotate permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of key to be rotated. The system will generate a new version in the
   *                specified key.
   * @param options The options parameters.
   */
  rotateKey(
    vaultBaseUrl: string,
    keyName: string,
    options?: RotateKeyOptionalParams
  ): Promise<RotateKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      rotateKeyOperationSpec
    ) as Promise<RotateKeyResponse>;
  }

  /**
   * The import key operation may be used to import any key type into an Azure Key Vault. If the named
   * key already exists, Azure Key Vault creates a new version of the key. This operation requires the
   * keys/import permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName Name for the imported key.
   * @param key The Json web key
   * @param options The options parameters.
   */
  importKey(
    vaultBaseUrl: string,
    keyName: string,
    key: JsonWebKey,
    options?: ImportKeyOptionalParams
  ): Promise<ImportKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      key,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      importKeyOperationSpec
    ) as Promise<ImportKeyResponse>;
  }

  /**
   * The delete key operation cannot be used to remove individual versions of a key. This operation
   * removes the cryptographic material associated with the key, which means the key is not usable for
   * Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the keys/delete
   * permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key to delete.
   * @param options The options parameters.
   */
  deleteKey(
    vaultBaseUrl: string,
    keyName: string,
    options?: DeleteKeyOptionalParams
  ): Promise<DeleteKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      deleteKeyOperationSpec
    ) as Promise<DeleteKeyResponse>;
  }

  /**
   * In order to perform this operation, the key must already exist in the Key Vault. Note: The
   * cryptographic material of a key itself cannot be changed. This operation requires the keys/update
   * permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of key to update.
   * @param keyVersion The version of the key to update.
   * @param options The options parameters.
   */
  updateKey(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    options?: UpdateKeyOptionalParams
  ): Promise<UpdateKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      updateKeyOperationSpec
    ) as Promise<UpdateKeyResponse>;
  }

  /**
   * The get key operation is applicable to all key types. If the requested key is symmetric, then no key
   * material is released in the response. This operation requires the keys/get permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key to get.
   * @param keyVersion Adding the version parameter retrieves a specific version of a key. This URI
   *                   fragment is optional. If not specified, the latest version of the key is returned.
   * @param options The options parameters.
   */
  getKey(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    options?: GetKeyOptionalParams
  ): Promise<GetKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getKeyOperationSpec
    ) as Promise<GetKeyResponse>;
  }

  /**
   * The full key identifier, attributes, and tags are provided in the response. This operation requires
   * the keys/list permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param options The options parameters.
   */
  getKeyVersions(
    vaultBaseUrl: string,
    keyName: string,
    options?: GetKeyVersionsOptionalParams
  ): Promise<GetKeyVersionsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getKeyVersionsOperationSpec
    ) as Promise<GetKeyVersionsResponse>;
  }

  /**
   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public
   * part of a stored key. The LIST operation is applicable to all key types, however only the base key
   * identifier, attributes, and tags are provided in the response. Individual versions of a key are not
   * listed in the response. This operation requires the keys/list permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param options The options parameters.
   */
  getKeys(
    vaultBaseUrl: string,
    options?: GetKeysOptionalParams
  ): Promise<GetKeysResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getKeysOperationSpec
    ) as Promise<GetKeysResponse>;
  }

  /**
   * The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this
   * operation does NOT return key material in a form that can be used outside the Azure Key Vault
   * system, the returned key material is either protected to a Azure Key Vault HSM or to Azure Key Vault
   * itself. The intent of this operation is to allow a client to GENERATE a key in one Azure Key Vault
   * instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP
   * operation may be used to export, in protected form, any key type from Azure Key Vault. Individual
   * versions of a key cannot be backed up. BACKUP / RESTORE can be performed within geographical
   * boundaries only; meaning that a BACKUP from one geographical area cannot be restored to another
   * geographical area. For example, a backup from the US geographical area cannot be restored in an EU
   * geographical area. This operation requires the key/backup permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param options The options parameters.
   */
  backupKey(
    vaultBaseUrl: string,
    keyName: string,
    options?: BackupKeyOptionalParams
  ): Promise<BackupKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      backupKeyOperationSpec
    ) as Promise<BackupKeyResponse>;
  }

  /**
   * Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier,
   * attributes and access control policies. The RESTORE operation may be used to import a previously
   * backed up key. Individual versions of a key cannot be restored. The key is restored in its entirety
   * with the same key name as it had when it was backed up. If the key name is not available in the
   * target Key Vault, the RESTORE operation will be rejected. While the key name is retained during
   * restore, the final key identifier will change if the key is restored to a different vault. Restore
   * will restore all versions and preserve version identifiers. The RESTORE operation is subject to
   * security constraints: The target Key Vault must be owned by the same Microsoft Azure Subscription as
   * the source Key Vault The user must have RESTORE permission in the target Key Vault. This operation
   * requires the keys/restore permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyBundleBackup The backup blob associated with a key bundle.
   * @param options The options parameters.
   */
  restoreKey(
    vaultBaseUrl: string,
    keyBundleBackup: Uint8Array,
    options?: RestoreKeyOptionalParams
  ): Promise<RestoreKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyBundleBackup,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      restoreKeyOperationSpec
    ) as Promise<RestoreKeyResponse>;
  }

  /**
   * The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored
   * in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of data, the size
   * of which is dependent on the target key and the encryption algorithm to be used. The ENCRYPT
   * operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection
   * with an asymmetric key can be performed using public portion of the key. This operation is supported
   * for asymmetric keys as a convenience for callers that have a key-reference but do not have access to
   * the public key material. This operation requires the keys/encrypt permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param keyVersion The version of the key.
   * @param algorithm algorithm identifier
   * @param value
   * @param options The options parameters.
   */
  encrypt(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    algorithm: JsonWebKeyEncryptionAlgorithm,
    value: Uint8Array,
    options?: EncryptOptionalParams
  ): Promise<EncryptResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      algorithm,
      value,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      encryptOperationSpec
    ) as Promise<EncryptResponse>;
  }

  /**
   * The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and
   * specified algorithm. This operation is the reverse of the ENCRYPT operation; only a single block of
   * data may be decrypted, the size of this block is dependent on the target key and the algorithm to be
   * used. The DECRYPT operation applies to asymmetric and symmetric keys stored in Azure Key Vault since
   * it uses the private portion of the key. This operation requires the keys/decrypt permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param keyVersion The version of the key.
   * @param algorithm algorithm identifier
   * @param value
   * @param options The options parameters.
   */
  decrypt(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    algorithm: JsonWebKeyEncryptionAlgorithm,
    value: Uint8Array,
    options?: DecryptOptionalParams
  ): Promise<DecryptResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      algorithm,
      value,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      decryptOperationSpec
    ) as Promise<DecryptResponse>;
  }

  /**
   * The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since
   * this operation uses the private portion of the key. This operation requires the keys/sign
   * permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param keyVersion The version of the key.
   * @param algorithm The signing/verification algorithm identifier. For more information on possible
   *                  algorithm types, see JsonWebKeySignatureAlgorithm.
   * @param value
   * @param options The options parameters.
   */
  sign(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    algorithm: JsonWebKeySignatureAlgorithm,
    value: Uint8Array,
    options?: SignOptionalParams
  ): Promise<SignResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      algorithm,
      value,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      signOperationSpec
    ) as Promise<SignResponse>;
  }

  /**
   * The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not
   * strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification can be
   * performed using the public portion of the key but this operation is supported as a convenience for
   * callers that only have a key-reference and not the public portion of the key. This operation
   * requires the keys/verify permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param keyVersion The version of the key.
   * @param algorithm The signing/verification algorithm. For more information on possible algorithm
   *                  types, see JsonWebKeySignatureAlgorithm.
   * @param digest The digest used for signing.
   * @param signature The signature to be verified.
   * @param options The options parameters.
   */
  verify(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    algorithm: JsonWebKeySignatureAlgorithm,
    digest: Uint8Array,
    signature: Uint8Array,
    options?: VerifyOptionalParams
  ): Promise<VerifyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      algorithm,
      digest,
      signature,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      verifyOperationSpec
    ) as Promise<VerifyResponse>;
  }

  /**
   * The WRAP operation supports encryption of a symmetric key using a key encryption key that has
   * previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for
   * symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be performed
   * using the public portion of the key. This operation is supported for asymmetric keys as a
   * convenience for callers that have a key-reference but do not have access to the public key material.
   * This operation requires the keys/wrapKey permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param keyVersion The version of the key.
   * @param algorithm algorithm identifier
   * @param value
   * @param options The options parameters.
   */
  wrapKey(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    algorithm: JsonWebKeyEncryptionAlgorithm,
    value: Uint8Array,
    options?: WrapKeyOptionalParams
  ): Promise<WrapKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      algorithm,
      value,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      wrapKeyOperationSpec
    ) as Promise<WrapKeyResponse>;
  }

  /**
   * The UNWRAP operation supports decryption of a symmetric key using the target key encryption key.
   * This operation is the reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and
   * symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This
   * operation requires the keys/unwrapKey permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param keyVersion The version of the key.
   * @param algorithm algorithm identifier
   * @param value
   * @param options The options parameters.
   */
  unwrapKey(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    algorithm: JsonWebKeyEncryptionAlgorithm,
    value: Uint8Array,
    options?: UnwrapKeyOptionalParams
  ): Promise<UnwrapKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      algorithm,
      value,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      unwrapKeyOperationSpec
    ) as Promise<UnwrapKeyResponse>;
  }

  /**
   * The release key operation is applicable to all key types. The target key must be marked exportable.
   * This operation requires the keys/release permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key to get.
   * @param keyVersion Adding the version parameter retrieves a specific version of a key.
   * @param targetAttestationToken The attestation assertion for the target of the key release.
   * @param options The options parameters.
   */
  release(
    vaultBaseUrl: string,
    keyName: string,
    keyVersion: string,
    targetAttestationToken: string,
    options?: ReleaseOptionalParams
  ): Promise<ReleaseResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyVersion,
      targetAttestationToken,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      releaseOperationSpec
    ) as Promise<ReleaseResponse>;
  }

  /**
   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public
   * part of a deleted key. This operation includes deletion-specific information. The Get Deleted Keys
   * operation is applicable for vaults enabled for soft-delete. While the operation can be invoked on
   * any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation
   * requires the keys/list permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param options The options parameters.
   */
  getDeletedKeys(
    vaultBaseUrl: string,
    options?: GetDeletedKeysOptionalParams
  ): Promise<GetDeletedKeysResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getDeletedKeysOperationSpec
    ) as Promise<GetDeletedKeysResponse>;
  }

  /**
   * The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can
   * be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This
   * operation requires the keys/get permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param options The options parameters.
   */
  getDeletedKey(
    vaultBaseUrl: string,
    keyName: string,
    options?: GetDeletedKeyOptionalParams
  ): Promise<GetDeletedKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getDeletedKeyOperationSpec
    ) as Promise<GetDeletedKeyResponse>;
  }

  /**
   * The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation
   * can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault.
   * This operation requires the keys/purge permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key
   * @param options The options parameters.
   */
  purgeDeletedKey(
    vaultBaseUrl: string,
    keyName: string,
    options?: PurgeDeletedKeyOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      purgeDeletedKeyOperationSpec
    ) as Promise<coreHttp.RestResponse>;
  }

  /**
   * The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It
   * recovers the deleted key back to its latest version under /keys. An attempt to recover an
   * non-deleted key will return an error. Consider this the inverse of the delete operation on
   * soft-delete enabled vaults. This operation requires the keys/recover permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the deleted key.
   * @param options The options parameters.
   */
  recoverDeletedKey(
    vaultBaseUrl: string,
    keyName: string,
    options?: RecoverDeletedKeyOptionalParams
  ): Promise<RecoverDeletedKeyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      recoverDeletedKeyOperationSpec
    ) as Promise<RecoverDeletedKeyResponse>;
  }

  /**
   * The GetKeyRotationPolicy operation returns the specified key policy resources in the specified key
   * vault. This operation requires the keys/get permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key in a given key vault.
   * @param options The options parameters.
   */
  getKeyRotationPolicy(
    vaultBaseUrl: string,
    keyName: string,
    options?: GetKeyRotationPolicyOptionalParams
  ): Promise<GetKeyRotationPolicyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getKeyRotationPolicyOperationSpec
    ) as Promise<GetKeyRotationPolicyResponse>;
  }

  /**
   * Set specified members in the key policy. Leave others as undefined. This operation requires the
   * keys/update permission.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key in the given vault.
   * @param keyRotationPolicy The policy for the key.
   * @param options The options parameters.
   */
  updateKeyRotationPolicy(
    vaultBaseUrl: string,
    keyName: string,
    keyRotationPolicy: KeyRotationPolicy,
    options?: UpdateKeyRotationPolicyOptionalParams
  ): Promise<UpdateKeyRotationPolicyResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      keyRotationPolicy,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      updateKeyRotationPolicyOperationSpec
    ) as Promise<UpdateKeyRotationPolicyResponse>;
  }

  /**
   * Get the requested number of bytes containing random values from a managed HSM.
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param count The requested number of random bytes.
   * @param options The options parameters.
   */
  getRandomBytes(
    vaultBaseUrl: string,
    count: number,
    options?: GetRandomBytesOptionalParams
  ): Promise<GetRandomBytesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      count,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getRandomBytesOperationSpec
    ) as Promise<GetRandomBytesResponse>;
  }

  /**
   * GetKeyVersionsNext
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param keyName The name of the key.
   * @param nextLink The nextLink from the previous successful call to the GetKeyVersions method.
   * @param options The options parameters.
   */
  getKeyVersionsNext(
    vaultBaseUrl: string,
    keyName: string,
    nextLink: string,
    options?: GetKeyVersionsNextOptionalParams
  ): Promise<GetKeyVersionsNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      keyName,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getKeyVersionsNextOperationSpec
    ) as Promise<GetKeyVersionsNextResponse>;
  }

  /**
   * GetKeysNext
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param nextLink The nextLink from the previous successful call to the GetKeys method.
   * @param options The options parameters.
   */
  getKeysNext(
    vaultBaseUrl: string,
    nextLink: string,
    options?: GetKeysNextOptionalParams
  ): Promise<GetKeysNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getKeysNextOperationSpec
    ) as Promise<GetKeysNextResponse>;
  }

  /**
   * GetDeletedKeysNext
   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.
   * @param nextLink The nextLink from the previous successful call to the GetDeletedKeys method.
   * @param options The options parameters.
   */
  getDeletedKeysNext(
    vaultBaseUrl: string,
    nextLink: string,
    options?: GetDeletedKeysNextOptionalParams
  ): Promise<GetDeletedKeysNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      vaultBaseUrl,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.sendOperationRequest(
      operationArguments,
      getDeletedKeysNextOperationSpec
    ) as Promise<GetDeletedKeysNextResponse>;
  }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const createKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/create",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      kty: ["kty"],
      keySize: ["options", "keySize"],
      publicExponent: ["options", "publicExponent"],
      keyOps: ["options", "keyOps"],
      keyAttributes: ["options", "keyAttributes"],
      tags: ["options", "tags"],
      curve: ["options", "curve"],
      releasePolicy: ["options", "releasePolicy"]
    },
    mapper: { ...Mappers.KeyCreateParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const rotateKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/rotate",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName],
  headerParameters: [Parameters.accept],
  serializer
};
const importKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.KeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      hsm: ["options", "hsm"],
      key: ["key"],
      keyAttributes: ["options", "keyAttributes"],
      tags: ["options", "tags"],
      releasePolicy: ["options", "releasePolicy"]
    },
    mapper: { ...Mappers.KeyImportParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const deleteKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}",
  httpMethod: "DELETE",
  responses: {
    200: {
      bodyMapper: Mappers.DeletedKeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],
  headerParameters: [Parameters.accept],
  serializer
};
const updateKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.KeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      keyOps: ["options", "keyOps"],
      keyAttributes: ["options", "keyAttributes"],
      tags: ["options", "tags"],
      releasePolicy: ["options", "releasePolicy"]
    },
    mapper: { ...Mappers.KeyUpdateParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.KeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getKeyVersionsOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/versions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.KeyListResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxresults],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],
  headerParameters: [Parameters.accept],
  serializer
};
const getKeysOperationSpec: coreHttp.OperationSpec = {
  path: "/keys",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.KeyListResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxresults],
  urlParameters: [Parameters.vaultBaseUrl],
  headerParameters: [Parameters.accept],
  serializer
};
const backupKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/backup",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.BackupKeyResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],
  headerParameters: [Parameters.accept],
  serializer
};
const restoreKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/restore",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: { keyBundleBackup: ["keyBundleBackup"] },
    mapper: { ...Mappers.KeyRestoreParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const encryptOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}/encrypt",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyOperationResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      algorithm: ["algorithm"],
      value: ["value"],
      iv: ["options", "iv"],
      additionalAuthenticatedData: ["options", "additionalAuthenticatedData"],
      authenticationTag: ["options", "authenticationTag"]
    },
    mapper: { ...Mappers.KeyOperationsParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const decryptOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}/decrypt",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyOperationResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      algorithm: ["algorithm"],
      value: ["value"],
      iv: ["options", "iv"],
      additionalAuthenticatedData: ["options", "additionalAuthenticatedData"],
      authenticationTag: ["options", "authenticationTag"]
    },
    mapper: { ...Mappers.KeyOperationsParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const signOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}/sign",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyOperationResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: { algorithm: ["algorithm"], value: ["value"] },
    mapper: { ...Mappers.KeySignParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const verifyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}/verify",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyVerifyResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      algorithm: ["algorithm"],
      digest: ["digest"],
      signature: ["signature"]
    },
    mapper: { ...Mappers.KeyVerifyParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const wrapKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}/wrapkey",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyOperationResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      algorithm: ["algorithm"],
      value: ["value"],
      iv: ["options", "iv"],
      additionalAuthenticatedData: ["options", "additionalAuthenticatedData"],
      authenticationTag: ["options", "authenticationTag"]
    },
    mapper: { ...Mappers.KeyOperationsParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const unwrapKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}/unwrapkey",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyOperationResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      algorithm: ["algorithm"],
      value: ["value"],
      iv: ["options", "iv"],
      additionalAuthenticatedData: ["options", "additionalAuthenticatedData"],
      authenticationTag: ["options", "authenticationTag"]
    },
    mapper: { ...Mappers.KeyOperationsParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const releaseOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/{key-version}/release",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyReleaseResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: {
      targetAttestationToken: ["targetAttestationToken"],
      nonce: ["options", "nonce"],
      enc: ["options", "enc"]
    },
    mapper: { ...Mappers.KeyReleaseParameters, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.keyVersion
  ],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getDeletedKeysOperationSpec: coreHttp.OperationSpec = {
  path: "/deletedkeys",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DeletedKeyListResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxresults],
  urlParameters: [Parameters.vaultBaseUrl],
  headerParameters: [Parameters.accept],
  serializer
};
const getDeletedKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/deletedkeys/{key-name}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DeletedKeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],
  headerParameters: [Parameters.accept],
  serializer
};
const purgeDeletedKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/deletedkeys/{key-name}",
  httpMethod: "DELETE",
  responses: {
    204: {},
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],
  headerParameters: [Parameters.accept],
  serializer
};
const recoverDeletedKeyOperationSpec: coreHttp.OperationSpec = {
  path: "/deletedkeys/{key-name}/recover",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.KeyBundle
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],
  headerParameters: [Parameters.accept],
  serializer
};
const getKeyRotationPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/rotationpolicy",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.KeyRotationPolicy
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],
  headerParameters: [Parameters.accept],
  serializer
};
const updateKeyRotationPolicyOperationSpec: coreHttp.OperationSpec = {
  path: "/keys/{key-name}/rotationpolicy",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.KeyRotationPolicy
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: Parameters.keyRotationPolicy,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getRandomBytesOperationSpec: coreHttp.OperationSpec = {
  path: "/rng",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.RandomBytes
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  requestBody: {
    parameterPath: { count: ["count"] },
    mapper: { ...Mappers.GetRandomBytesRequest, required: true }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [Parameters.vaultBaseUrl],
  headerParameters: [Parameters.contentType, Parameters.accept],
  mediaType: "json",
  serializer
};
const getKeyVersionsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.KeyListResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxresults],
  urlParameters: [
    Parameters.vaultBaseUrl,
    Parameters.keyName1,
    Parameters.nextLink
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getKeysNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.KeyListResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxresults],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const getDeletedKeysNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.DeletedKeyListResult
    },
    default: {
      bodyMapper: Mappers.KeyVaultError
    }
  },
  queryParameters: [Parameters.apiVersion, Parameters.maxresults],
  urlParameters: [Parameters.vaultBaseUrl, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
