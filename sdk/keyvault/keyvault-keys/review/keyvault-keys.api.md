## API Report File for "@azure/keyvault-keys"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference lib="esnext.asynciterable" />

import { AzureLogger } from '@azure/logger';
import * as coreClient from '@azure/core-client';
import { ExtendedCommonClientOptions } from '@azure/core-http-compat';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PageSettings } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AesCbcDecryptParameters {
    algorithm: AesCbcEncryptionAlgorithm;
    ciphertext: Uint8Array;
    iv: Uint8Array;
}

// @public
export type AesCbcEncryptionAlgorithm = "A128CBC" | "A192CBC" | "A256CBC" | "A128CBCPAD" | "A192CBCPAD" | "A256CBCPAD";

// @public
export interface AesCbcEncryptParameters {
    algorithm: AesCbcEncryptionAlgorithm;
    iv?: Uint8Array;
    plaintext: Uint8Array;
}

// @public
export interface AesGcmDecryptParameters {
    additionalAuthenticatedData?: Uint8Array;
    algorithm: AesGcmEncryptionAlgorithm;
    authenticationTag: Uint8Array;
    ciphertext: Uint8Array;
    iv: Uint8Array;
}

// @public
export type AesGcmEncryptionAlgorithm = "A128GCM" | "A192GCM" | "A256GCM";

// @public
export interface AesGcmEncryptParameters {
    additionalAuthenticatedData?: Uint8Array;
    algorithm: AesGcmEncryptionAlgorithm;
    plaintext: Uint8Array;
}

// @public
export interface BackupKeyOptions extends coreClient.OperationOptions {
}

// @public
export interface BeginDeleteKeyOptions extends KeyPollerOptions {
}

// @public
export interface BeginRecoverDeletedKeyOptions extends KeyPollerOptions {
}

// @public
export interface CreateEcKeyOptions extends CreateKeyOptions {
}

// @public
export interface CreateKeyOptions extends coreClient.OperationOptions {
    curve?: KeyCurveName;
    enabled?: boolean;
    readonly expiresOn?: Date;
    exportable?: boolean;
    hsm?: boolean;
    keyOps?: KeyOperation[];
    keySize?: number;
    notBefore?: Date;
    releasePolicy?: KeyReleasePolicy;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface CreateOctKeyOptions extends CreateKeyOptions {
}

// @public
export interface CreateRsaKeyOptions extends CreateKeyOptions {
    publicExponent?: number;
}

// @public
export class CryptographyClient {
    constructor(key: string | KeyVaultKey, credential: TokenCredential, pipelineOptions?: CryptographyClientOptions);
    constructor(key: JsonWebKey_2);
    decrypt(decryptParameters: DecryptParameters, options?: DecryptOptions): Promise<DecryptResult>;
    // @deprecated
    decrypt(algorithm: EncryptionAlgorithm, ciphertext: Uint8Array, options?: DecryptOptions): Promise<DecryptResult>;
    encrypt(encryptParameters: EncryptParameters, options?: EncryptOptions): Promise<EncryptResult>;
    // @deprecated
    encrypt(algorithm: EncryptionAlgorithm, plaintext: Uint8Array, options?: EncryptOptions): Promise<EncryptResult>;
    get keyID(): string | undefined;
    sign(algorithm: SignatureAlgorithm, digest: Uint8Array, options?: SignOptions): Promise<SignResult>;
    signData(algorithm: SignatureAlgorithm, data: Uint8Array, options?: SignOptions): Promise<SignResult>;
    unwrapKey(algorithm: KeyWrapAlgorithm, encryptedKey: Uint8Array, options?: UnwrapKeyOptions): Promise<UnwrapResult>;
    get vaultUrl(): string;
    verify(algorithm: SignatureAlgorithm, digest: Uint8Array, signature: Uint8Array, options?: VerifyOptions): Promise<VerifyResult>;
    verifyData(algorithm: SignatureAlgorithm, data: Uint8Array, signature: Uint8Array, options?: VerifyOptions): Promise<VerifyResult>;
    wrapKey(algorithm: KeyWrapAlgorithm, key: Uint8Array, options?: WrapKeyOptions): Promise<WrapResult>;
}

// @public
export interface CryptographyClientOptions extends KeyClientOptions {
}

// @public
export interface CryptographyOptions extends coreClient.OperationOptions {
}

// @public
export interface DecryptOptions extends CryptographyOptions {
}

// @public
export type DecryptParameters = RsaDecryptParameters | AesGcmDecryptParameters | AesCbcDecryptParameters;

// @public
export interface DecryptResult {
    algorithm: EncryptionAlgorithm;
    keyID?: string;
    result: Uint8Array;
}

// @public
export interface DeletedKey {
    id?: string;
    key?: JsonWebKey_2;
    keyOperations?: KeyOperation[];
    keyType?: KeyType_2;
    name: string;
    properties: KeyProperties & {
        readonly recoveryId?: string;
        readonly scheduledPurgeDate?: Date;
        deletedOn?: Date;
    };
}

// @public
export type DeletionRecoveryLevel = string;

// @public
export type EncryptionAlgorithm = string;

// @public
export interface EncryptOptions extends CryptographyOptions {
}

// @public
export type EncryptParameters = RsaEncryptParameters | AesGcmEncryptParameters | AesCbcEncryptParameters;

// @public
export interface EncryptResult {
    additionalAuthenticatedData?: Uint8Array;
    algorithm: EncryptionAlgorithm;
    authenticationTag?: Uint8Array;
    iv?: Uint8Array;
    keyID?: string;
    result: Uint8Array;
}

// @public
export interface GetCryptographyClientOptions {
    keyVersion?: string;
}

// @public
export interface GetDeletedKeyOptions extends coreClient.OperationOptions {
}

// @public
export interface GetKeyOptions extends coreClient.OperationOptions {
    version?: string;
}

// @public
export interface GetKeyRotationPolicyOptions extends coreClient.OperationOptions {
}

// @public
export interface GetRandomBytesOptions extends coreClient.OperationOptions {
}

// @public
export interface ImportKeyOptions extends coreClient.OperationOptions {
    enabled?: boolean;
    expiresOn?: Date;
    exportable?: boolean;
    hardwareProtected?: boolean;
    notBefore?: Date;
    releasePolicy?: KeyReleasePolicy;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
interface JsonWebKey_2 {
    crv?: KeyCurveName;
    d?: Uint8Array;
    dp?: Uint8Array;
    dq?: Uint8Array;
    e?: Uint8Array;
    k?: Uint8Array;
    keyOps?: KeyOperation[];
    kid?: string;
    kty?: KeyType_2;
    n?: Uint8Array;
    p?: Uint8Array;
    q?: Uint8Array;
    qi?: Uint8Array;
    t?: Uint8Array;
    x?: Uint8Array;
    y?: Uint8Array;
}
export { JsonWebKey_2 as JsonWebKey }

// @public
export class KeyClient {
    constructor(vaultUrl: string, credential: TokenCredential, pipelineOptions?: KeyClientOptions);
    backupKey(name: string, options?: BackupKeyOptions): Promise<Uint8Array | undefined>;
    beginDeleteKey(name: string, options?: BeginDeleteKeyOptions): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>>;
    beginRecoverDeletedKey(name: string, options?: BeginRecoverDeletedKeyOptions): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>>;
    createEcKey(name: string, options?: CreateEcKeyOptions): Promise<KeyVaultKey>;
    createKey(name: string, keyType: KeyType_2, options?: CreateKeyOptions): Promise<KeyVaultKey>;
    createOctKey(name: string, options?: CreateOctKeyOptions): Promise<KeyVaultKey>;
    createRsaKey(name: string, options?: CreateRsaKeyOptions): Promise<KeyVaultKey>;
    getCryptographyClient(keyName: string, options?: GetCryptographyClientOptions): CryptographyClient;
    getDeletedKey(name: string, options?: GetDeletedKeyOptions): Promise<DeletedKey>;
    getKey(name: string, options?: GetKeyOptions): Promise<KeyVaultKey>;
    getKeyRotationPolicy(keyName: string, options?: GetKeyRotationPolicyOptions): Promise<KeyRotationPolicy>;
    getRandomBytes(count: number, options?: GetRandomBytesOptions): Promise<Uint8Array>;
    importKey(name: string, key: JsonWebKey_2, options?: ImportKeyOptions): Promise<KeyVaultKey>;
    listDeletedKeys(options?: ListDeletedKeysOptions): PagedAsyncIterableIterator<DeletedKey>;
    listPropertiesOfKeys(options?: ListPropertiesOfKeysOptions): PagedAsyncIterableIterator<KeyProperties>;
    listPropertiesOfKeyVersions(name: string, options?: ListPropertiesOfKeyVersionsOptions): PagedAsyncIterableIterator<KeyProperties>;
    purgeDeletedKey(name: string, options?: PurgeDeletedKeyOptions): Promise<void>;
    releaseKey(name: string, targetAttestationToken: string, options?: ReleaseKeyOptions): Promise<ReleaseKeyResult>;
    restoreKeyBackup(backup: Uint8Array, options?: RestoreKeyBackupOptions): Promise<KeyVaultKey>;
    rotateKey(name: string, options?: RotateKeyOptions): Promise<KeyVaultKey>;
    updateKeyProperties(name: string, keyVersion: string, options?: UpdateKeyPropertiesOptions): Promise<KeyVaultKey>;
    updateKeyProperties(name: string, options?: UpdateKeyPropertiesOptions): Promise<KeyVaultKey>;
    updateKeyRotationPolicy(keyName: string, policy: KeyRotationPolicyProperties, options?: UpdateKeyRotationPolicyOptions): Promise<KeyRotationPolicy>;
    readonly vaultUrl: string;
}

// @public
export interface KeyClientOptions extends ExtendedCommonClientOptions {
    disableChallengeResourceVerification?: boolean;
    serviceVersion?: string;
}

// @public
export type KeyCurveName = string;

// @public
export type KeyExportEncryptionAlgorithm = string;

// @public
export type KeyOperation = string;

// @public
export interface KeyPollerOptions extends coreClient.OperationOptions {
    intervalInMs?: number;
    resumeFrom?: string;
}

// @public
export interface KeyProperties {
    readonly createdOn?: Date;
    enabled?: boolean;
    expiresOn?: Date;
    exportable?: boolean;
    id?: string;
    readonly managed?: boolean;
    name: string;
    notBefore?: Date;
    recoverableDays?: number;
    readonly recoveryLevel?: DeletionRecoveryLevel;
    releasePolicy?: KeyReleasePolicy;
    tags?: {
        [propertyName: string]: string;
    };
    readonly updatedOn?: Date;
    vaultUrl: string;
    version?: string;
}

// @public
export interface KeyReleasePolicy {
    contentType?: string;
    encodedPolicy?: Uint8Array;
    immutable?: boolean;
}

// @public
export interface KeyRotationLifetimeAction {
    action: KeyRotationPolicyAction;
    timeAfterCreate?: string;
    timeBeforeExpiry?: string;
}

// @public
export interface KeyRotationPolicy extends KeyRotationPolicyProperties {
    readonly createdOn?: Date;
    readonly id?: string;
    readonly updatedOn?: Date;
}

// @public
export type KeyRotationPolicyAction = "Rotate" | "Notify";

// @public
export interface KeyRotationPolicyProperties {
    expiresIn?: string;
    lifetimeActions?: KeyRotationLifetimeAction[];
}

// @public
type KeyType_2 = string;
export { KeyType_2 as KeyType }

// @public
export interface KeyVaultKey {
    id?: string;
    key?: JsonWebKey_2;
    keyOperations?: KeyOperation[];
    keyType?: KeyType_2;
    name: string;
    properties: KeyProperties;
}

// @public
export interface KeyVaultKeyIdentifier {
    name: string;
    sourceId: string;
    vaultUrl: string;
    version?: string;
}

// @public
export type KeyWrapAlgorithm = "A128KW" | "A192KW" | "A256KW" | "RSA-OAEP" | "RSA-OAEP-256" | "RSA1_5";

// @public
export enum KnownDeletionRecoveryLevel {
    CustomizedRecoverable = "CustomizedRecoverable",
    CustomizedRecoverableProtectedSubscription = "CustomizedRecoverable+ProtectedSubscription",
    CustomizedRecoverablePurgeable = "CustomizedRecoverable+Purgeable",
    Purgeable = "Purgeable",
    Recoverable = "Recoverable",
    RecoverableProtectedSubscription = "Recoverable+ProtectedSubscription",
    RecoverablePurgeable = "Recoverable+Purgeable"
}

// @public
export enum KnownEncryptionAlgorithms {
    A128CBC = "A128CBC",
    A128Cbcpad = "A128CBCPAD",
    A128GCM = "A128GCM",
    A128KW = "A128KW",
    A192CBC = "A192CBC",
    A192Cbcpad = "A192CBCPAD",
    A192GCM = "A192GCM",
    A192KW = "A192KW",
    A256CBC = "A256CBC",
    A256Cbcpad = "A256CBCPAD",
    A256GCM = "A256GCM",
    A256KW = "A256KW",
    RSA15 = "RSA1_5",
    RSAOaep = "RSA-OAEP",
    RSAOaep256 = "RSA-OAEP-256"
}

// @public
export enum KnownKeyCurveNames {
    P256 = "P-256",
    P256K = "P-256K",
    P384 = "P-384",
    P521 = "P-521"
}

// @public
export enum KnownKeyExportEncryptionAlgorithm {
    CkmRsaAesKeyWrap = "CKM_RSA_AES_KEY_WRAP",
    RsaAesKeyWrap256 = "RSA_AES_KEY_WRAP_256",
    RsaAesKeyWrap384 = "RSA_AES_KEY_WRAP_384"
}

// @public
export enum KnownKeyOperations {
    Decrypt = "decrypt",
    Encrypt = "encrypt",
    Import = "import",
    Sign = "sign",
    UnwrapKey = "unwrapKey",
    Verify = "verify",
    WrapKey = "wrapKey"
}

// @public
export enum KnownKeyTypes {
    EC = "EC",
    ECHSM = "EC-HSM",
    Oct = "oct",
    OctHSM = "oct-HSM",
    RSA = "RSA",
    RSAHSM = "RSA-HSM"
}

// @public
export enum KnownSignatureAlgorithms {
    ES256 = "ES256",
    ES256K = "ES256K",
    ES384 = "ES384",
    ES512 = "ES512",
    PS256 = "PS256",
    PS384 = "PS384",
    PS512 = "PS512",
    RS256 = "RS256",
    RS384 = "RS384",
    RS512 = "RS512",
    Rsnull = "RSNULL"
}

// @public
export interface ListDeletedKeysOptions extends coreClient.OperationOptions {
}

// @public
export interface ListPropertiesOfKeysOptions extends coreClient.OperationOptions {
}

// @public
export interface ListPropertiesOfKeyVersionsOptions extends coreClient.OperationOptions {
}

// @public
export const logger: AzureLogger;

export { PagedAsyncIterableIterator }

export { PageSettings }

// @public
export function parseKeyVaultKeyIdentifier(id: string): KeyVaultKeyIdentifier;

export { PollerLike }

export { PollOperationState }

// @public
export interface PurgeDeletedKeyOptions extends coreClient.OperationOptions {
}

// @public
export interface ReleaseKeyOptions extends coreClient.OperationOptions {
    algorithm?: KeyExportEncryptionAlgorithm;
    nonce?: string;
    version?: string;
}

// @public
export interface ReleaseKeyResult {
    value: string;
}

// @public
export interface RestoreKeyBackupOptions extends coreClient.OperationOptions {
}

// @public
export interface RotateKeyOptions extends coreClient.OperationOptions {
}

// @public
export interface RsaDecryptParameters {
    algorithm: RsaEncryptionAlgorithm;
    ciphertext: Uint8Array;
}

// @public
export type RsaEncryptionAlgorithm = "RSA1_5" | "RSA-OAEP" | "RSA-OAEP-256";

// @public
export interface RsaEncryptParameters {
    algorithm: RsaEncryptionAlgorithm;
    plaintext: Uint8Array;
}

// @public
export type SignatureAlgorithm = string;

// @public
export interface SignOptions extends CryptographyOptions {
}

// @public
export interface SignResult {
    algorithm: SignatureAlgorithm;
    keyID?: string;
    result: Uint8Array;
}

// @public
export interface UnwrapKeyOptions extends CryptographyOptions {
}

// @public
export interface UnwrapResult {
    algorithm: KeyWrapAlgorithm;
    keyID?: string;
    result: Uint8Array;
}

// @public
export interface UpdateKeyPropertiesOptions extends coreClient.OperationOptions {
    enabled?: boolean;
    expiresOn?: Date;
    keyOps?: KeyOperation[];
    notBefore?: Date;
    releasePolicy?: KeyReleasePolicy;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface UpdateKeyRotationPolicyOptions extends coreClient.OperationOptions {
}

// @public
export interface VerifyDataOptions extends CryptographyOptions {
}

// @public
export interface VerifyOptions extends CryptographyOptions {
}

// @public
export interface VerifyResult {
    keyID?: string;
    result: boolean;
}

// @public
export interface WrapKeyOptions extends CryptographyOptions {
}

// @public
export interface WrapResult {
    algorithm: KeyWrapAlgorithm;
    keyID?: string;
    result: Uint8Array;
}

// (No @packageDocumentation comment for this package)

```
