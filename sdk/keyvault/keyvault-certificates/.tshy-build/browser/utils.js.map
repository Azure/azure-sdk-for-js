{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAGlC,OAAO,EAAE,MAAM,EAAE,MAAM,kBAAkB,CAAC;AAE1C;;;GAGG;AACH,MAAM,UAAU,QAAQ,CAAC,KAAiB;IACxC,IAAI,MAAM,EAAE,CAAC;QACX,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC/C,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,KAAwB,CAAC,CAAC,CAAC;IACzE,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,OAAO,CAAC,KAAiB;IACvC,IAAI,MAAM,EAAE,CAAC;QACX,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IAC9C,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAChD,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,kBAAkB,CAAC,KAAa;IAC9C,IAAI,MAAM,EAAE,CAAC;QACX,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC5B,CAAC;SAAM,CAAC;QACN,OAAO,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACzC,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,kBAAkB,CAAC,KAAa;IAC9C,IAAI,MAAM,EAAE,CAAC;QACX,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IACtC,CAAC;SAAM,CAAC;QACN,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9D,CAAC;AACH,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,qBAAqB,CACnC,gBAA4B,EAC5B,WAAmC;IAEnC,IAAI,WAAW,KAAK,wBAAwB,EAAE,CAAC;QAC7C,iEAAiE;QACjE,OAAO,OAAO,CAAC,gBAAgB,CAAC,CAAC;IACnC,CAAC;SAAM,CAAC;QACN,OAAO,QAAQ,CAAC,gBAAgB,CAAC,CAAC;IACpC,CAAC;AACH,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport type { CertificateContentType } from \"./certificatesModels.js\";\nimport { isNode } from \"@azure/core-util\";\n\n/**\n * Decodes a Uint8Array into a Base64 string.\n * @internal\n */\nexport function toBase64(bytes: Uint8Array): string {\n  if (isNode) {\n    return Buffer.from(bytes).toString(\"base64\");\n  } else {\n    return btoa(String.fromCharCode.apply(null, bytes as any as number[]));\n  }\n}\n\n/**\n * Decodes a Uint8Array into an ASCII string.\n * @internal\n */\nexport function toAscii(bytes: Uint8Array): string {\n  if (isNode) {\n    return Buffer.from(bytes).toString(\"ascii\");\n  } else {\n    return new TextDecoder(\"ascii\").decode(bytes);\n  }\n}\n\n/**\n * Encodes a JavaScript string into a Uint8Array.\n * @internal\n */\nexport function stringToUint8Array(value: string): Uint8Array {\n  if (isNode) {\n    return Buffer.from(value);\n  } else {\n    return new TextEncoder().encode(value);\n  }\n}\n\n/**\n * Encodes a Base64 string into a Uint8Array.\n * @internal\n */\nexport function base64ToUint8Array(value: string): Uint8Array {\n  if (isNode) {\n    return Buffer.from(value, \"base64\");\n  } else {\n    return Uint8Array.from(atob(value), (c) => c.charCodeAt(0));\n  }\n}\n\n/**\n * Parses the PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key\n * into a Base64 encoded string.\n *\n * @internal\n * @param certificateBytes - The PFX or ASCII PEM formatted value of the certificate containing both the X.509 certificates and the private key\n * @param contentType - \"application/x-pem-file\", \"application/x-pkcs12\" or undefined\n */\nexport function parseCertificateBytes(\n  certificateBytes: Uint8Array,\n  contentType: CertificateContentType,\n): string {\n  if (contentType === \"application/x-pem-file\") {\n    // PEM files have the certificate bytes already Base64 formatted.\n    return toAscii(certificateBytes);\n  } else {\n    return toBase64(certificateBytes);\n  }\n}\n"]}