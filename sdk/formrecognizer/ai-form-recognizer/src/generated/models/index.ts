/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */


import * as coreHttp from "@azure/core-http";

/**
 * An object representing a word.
 */
export interface TextWord {
  /**
   * The text content of the word.
   */
  text: string;
  /**
   * Bounding box of an extracted word.
   */
  boundingBox: number[];
  /**
   * Confidence value.
   */
  confidence?: number;
}

/**
 * An object representing an extracted text line.
 */
export interface TextLine {
  /**
   * The text content of the line.
   */
  text: string;
  /**
   * Bounding box of an extracted line.
   */
  boundingBox: number[];
  /**
   * The detected language of this line, if different from the overall page language. Possible
   * values include: 'en', 'es'
   */
  language?: Language;
  /**
   * List of words in the text line.
   */
  words: TextWord[];
}

/**
 * Text extracted from a page in the input document.
 */
export interface ReadResult {
  /**
   * The 1-based page number in the input document.
   */
  page: number;
  /**
   * The general orientation of the text in clockwise direction, measured in degrees between (-180,
   * 180].
   */
  angle: number;
  /**
   * The width of the image/PDF in pixels/inches, respectively.
   */
  width: number;
  /**
   * The height of the image/PDF in pixels/inches, respectively.
   */
  height: number;
  /**
   * The unit used by the width, height and boundingBox properties. For images, the unit is
   * "pixel". For PDF, the unit is "inch". Possible values include: 'pixel', 'inch'
   */
  unit: LengthUnit;
  /**
   * The detected language on the page overall. Possible values include: 'en', 'es'
   */
  language?: Language;
  /**
   * When includeTextDetails is set to true, a list of recognized text lines. The maximum number of
   * lines returned is 300 per page. The lines are sorted top to bottom, left to right, although in
   * certain cases proximity is treated with higher priority. As the sorting order depends on the
   * detected text, it may change across images and OCR version updates. Thus, business logic
   * should be built upon the actual line location instead of order.
   */
  lines?: TextLine[];
}

/**
 * Information about the extracted key or value in a key-value pair.
 */
export interface KeyValueElement {
  /**
   * The text content of the key or value.
   */
  text: string;
  /**
   * Bounding box of the key or value.
   */
  boundingBox?: number[];
  /**
   * When includeTextDetails is set to true, a list of references to the text elements constituting
   * this key or value.
   */
  elements?: string[];
}

/**
 * Information about the extracted key-value pair.
 */
export interface KeyValuePair {
  /**
   * A user defined label for the key/value pair entry.
   */
  label?: string;
  /**
   * Information about the extracted key in a key-value pair.
   */
  key: KeyValueElement;
  /**
   * Information about the extracted value in a key-value pair.
   */
  value: KeyValueElement;
  /**
   * Confidence value.
   */
  confidence: number;
}

/**
 * Information about the extracted cell in a table.
 */
export interface DataTableCell {
  /**
   * Row index of the cell.
   */
  rowIndex: number;
  /**
   * Column index of the cell.
   */
  columnIndex: number;
  /**
   * Number of rows spanned by this cell. Default value: 1.
   */
  rowSpan?: number;
  /**
   * Number of columns spanned by this cell. Default value: 1.
   */
  columnSpan?: number;
  /**
   * Text content of the cell.
   */
  text: string;
  /**
   * Bounding box of the cell.
   */
  boundingBox: number[];
  /**
   * Confidence value.
   */
  confidence: number;
  /**
   * When includeTextDetails is set to true, a list of references to the text elements constituting
   * this table cell.
   */
  elements?: string[];
  /**
   * Is the current cell a header cell?. Default value: false.
   */
  isHeader?: boolean;
  /**
   * Is the current cell a footer cell?. Default value: false.
   */
  isFooter?: boolean;
}

/**
 * Information about the extracted table contained in a page.
 */
export interface DataTable {
  /**
   * Number of rows.
   */
  rows: number;
  /**
   * Number of columns.
   */
  columns: number;
  /**
   * List of cells contained in the table.
   */
  cells: DataTableCell[];
}

/**
 * Extracted information from a single page.
 */
export interface PageResult {
  /**
   * Page number.
   */
  page: number;
  /**
   * Cluster identifier.
   */
  clusterId?: number;
  /**
   * List of key-value pairs extracted from the page.
   */
  keyValuePairs?: KeyValuePair[];
  /**
   * List of data tables extracted from the page.
   */
  tables?: DataTable[];
}

/**
 * Recognized field value.
 */
export interface FieldValue {
  /**
   * Type of field value. Possible values include: 'string', 'date', 'time', 'phoneNumber',
   * 'number', 'integer', 'array', 'object'
   */
  type: FieldValueType;
  /**
   * String value.
   */
  valueString?: string;
  /**
   * Date value.
   */
  valueDate?: Date;
  /**
   * Time value.
   */
  valueTime?: Date;
  /**
   * Phone number value.
   */
  valuePhoneNumber?: string;
  /**
   * Floating point value.
   */
  valueNumber?: number;
  /**
   * Integer value.
   */
  valueInteger?: number;
  /**
   * Array of field values.
   */
  valueArray?: FieldValue[];
  /**
   * Dictionary of named field values.
   */
  valueObject?: { [propertyName: string]: FieldValue };
  /**
   * Text content of the extracted field.
   */
  text?: string;
  /**
   * Bounding box of the field value, if appropriate.
   */
  boundingBox?: number[];
  /**
   * Confidence score.
   */
  confidence?: number;
  /**
   * When includeTextDetails is set to true, a list of references to the text elements constituting
   * this field.
   */
  elements?: string[];
  /**
   * The 1-based page number in the input document.
   */
  page?: number;
}

/**
 * A set of extracted fields corresponding to the input document.
 */
export interface DocumentResult {
  /**
   * Document type.
   */
  docType: string;
  /**
   * First and last page number where the document is found.
   */
  pageRange: number[];
  /**
   * Dictionary of named field values.
   */
  fields: { [propertyName: string]: FieldValue };
}

/**
 * An interface representing ErrorInformation.
 */
export interface ErrorInformation {
  code: string;
  message: string;
}

/**
 * Analyze operation result.
 */
export interface AnalyzeResult {
  /**
   * Version of schema used for this result.
   */
  version: string;
  /**
   * Text extracted from the input.
   */
  readResults: ReadResult[];
  /**
   * Page-level information extracted from the input.
   */
  pageResults?: PageResult[];
  /**
   * Document-level information extracted from the input.
   */
  documentResults?: DocumentResult[];
  /**
   * List of errors reported during the analyze operation.
   */
  errors?: ErrorInformation[];
}

/**
 * Status and result of the queued analyze operation.
 */
export interface AnalyzeOperationResult {
  /**
   * Operation status. Possible values include: 'notStarted', 'running', 'succeeded', 'failed'
   */
  status: OperationStatus;
  /**
   * Date and time (UTC) when the analyze operation was submitted.
   */
  createdDateTime: Date;
  /**
   * Date and time (UTC) when the status was last updated.
   */
  lastUpdatedDateTime: Date;
  /**
   * Results of the analyze operation.
   */
  analyzeResult?: AnalyzeResult;
}

/**
 * Filter to apply to the documents in the source path for training.
 */
export interface TrainSourceFilter {
  /**
   * A case-sensitive prefix string to filter documents in the source path for training. For
   * example, when using a Azure storage blob Uri, use the prefix to restrict sub folders for
   * training.
   */
  prefix?: string;
  /**
   * A flag to indicate if sub folders within the set of prefix folders will also need to be
   * included when searching for content to be preprocessed. Default value: false.
   */
  includeSubFolders?: boolean;
}

/**
 * Request parameter to train a new custom model.
 */
export interface TrainRequest {
  /**
   * Source path containing the training documents.
   */
  source: string;
  /**
   * Filter to apply to the documents in the source path for training.
   */
  sourceFilter?: TrainSourceFilter;
  /**
   * Use label file for training a model. Default value: false.
   */
  useLabelFile?: boolean;
}

/**
 * Report for a custom model training document.
 */
export interface TrainingDocumentInfo {
  /**
   * Training document name.
   */
  documentName: string;
  /**
   * Total number of pages trained.
   */
  pages: number;
  /**
   * List of errors.
   */
  errors: ErrorInformation[];
  /**
   * Status of the training operation. Possible values include: 'succeeded', 'partiallySucceeded',
   * 'failed'
   */
  status: TrainStatus;
}

/**
 * Report for a custom model training field.
 */
export interface FormFieldsReport {
  /**
   * Training field name.
   */
  fieldName: string;
  /**
   * Estimated extraction accuracy for this field.
   */
  accuracy: number;
}

/**
 * Custom model training result.
 */
export interface TrainResult {
  /**
   * List of the documents used to train the model and any errors reported in each document.
   */
  trainingDocuments: TrainingDocumentInfo[];
  /**
   * List of fields used to train the model and the train operation error reported by each.
   */
  fields?: FormFieldsReport[];
  /**
   * Average accuracy.
   */
  averageModelAccuracy?: number;
  /**
   * Errors returned during the training operation.
   */
  errors?: ErrorInformation[];
}

/**
 * Uri or local path to source data.
 */
export interface SourcePath {
  /**
   * File source path.
   */
  source?: string;
}

/**
 * Basic custom model information.
 */
export interface ModelInfo {
  /**
   * Model identifier.
   */
  modelId: string;
  /**
   * Status of the model. Possible values include: 'creating', 'ready', 'invalid'
   */
  status: ModelStatus;
  /**
   * Date and time (UTC) when the model was created.
   */
  createdDateTime: Date;
  /**
   * Date and time (UTC) when the status was last updated.
   */
  lastUpdatedDateTime: Date;
}

/**
 * Summary of all trained custom models.
 */
export interface ModelsSummary {
  /**
   * Current count of trained custom models.
   */
  count: number;
  /**
   * Max number of models that can be trained for this subscription.
   */
  limit: number;
  /**
   * Date and time (UTC) when the summary was last updated.
   */
  lastUpdatedDateTime: Date;
}

/**
 * Response to the list custom models operation.
 */
export interface ModelsModel {
  /**
   * Summary of all trained custom models.
   */
  summary?: ModelsSummary;
  /**
   * Collection of trained custom models.
   */
  modelList?: ModelInfo[];
  /**
   * Link to the next page of custom models.
   */
  nextLink?: string;
}

/**
 * Keys extracted by the custom model.
 */
export interface KeysResult {
  /**
   * Object mapping clusterIds to a list of keys.
   */
  clusters: { [propertyName: string]: string[] };
}

/**
 * Response to the get custom model operation.
 */
export interface Model {
  modelInfo: ModelInfo;
  keys?: KeysResult;
  trainResult?: TrainResult;
}

/**
 * An interface representing ErrorResponse.
 */
export interface ErrorResponse {
  error: ErrorInformation;
}

/**
 * Optional Parameters.
 */
export interface FormRecognizerClientGetCustomModelsOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * Specify whether to return summary or full list of models. Possible values include: 'full',
   * 'summary'. Default value: 'full'.
   */
  op?: Op;
}

/**
 * Optional Parameters.
 */
export interface FormRecognizerClientGetCustomModelOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * Include list of extracted keys in model information. Default value: false.
   */
  includeKeys?: boolean;
}

/**
 * Optional Parameters.
 */
export interface FormRecognizerClientAnalyzeWithCustomModelOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * Include text lines and element references in the result. Default value: false.
   */
  includeTextDetails?: boolean;
  /**
   * .json, .pdf, .jpg, .png or .tiff type file stream.
   */
  fileStream?: any;
}

/**
 * Optional Parameters.
 */
export interface FormRecognizerClientAnalyzeReceiptAsyncOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * Include text lines and element references in the result. Default value: false.
   */
  includeTextDetails?: boolean;
  /**
   * .json, .pdf, .jpg, .png or .tiff type file stream.
   */
  fileStream?: any;
}

/**
 * Optional Parameters.
 */
export interface FormRecognizerClientAnalyzeLayoutAsyncOptionalParams extends coreHttp.RequestOptionsBase {
  /**
   * .json, .pdf, .jpg, .png or .tiff type file stream.
   */
  fileStream?: any;
}

/**
 * Defines headers for TrainCustomModelAsync operation.
 */
export interface TrainCustomModelAsyncHeaders {
  /**
   * Location and ID of the model being trained. The status of model training is specified in the
   * status property at the model location.
   */
  location: string;
}

/**
 * Defines headers for AnalyzeWithCustomModel operation.
 */
export interface AnalyzeWithCustomModelHeaders {
  /**
   * URL containing the resultId used to track the progress and obtain the result of the analyze
   * operation.
   */
  operationLocation: string;
}

/**
 * Defines headers for AnalyzeReceiptAsync operation.
 */
export interface AnalyzeReceiptAsyncHeaders {
  /**
   * URL containing the resultId used to track the progress and obtain the result of the analyze
   * operation.
   */
  operationLocation: string;
}

/**
 * Defines headers for AnalyzeLayoutAsync operation.
 */
export interface AnalyzeLayoutAsyncHeaders {
  /**
   * URL containing the resultId used to track the progress and obtain the result of the analyze
   * operation.
   */
  operationLocation: string;
}

/**
 * Defines values for OperationStatus.
 * Possible values include: 'notStarted', 'running', 'succeeded', 'failed'
 * @readonly
 * @enum {string}
 */
export type OperationStatus = 'notStarted' | 'running' | 'succeeded' | 'failed';

/**
 * Defines values for LengthUnit.
 * Possible values include: 'pixel', 'inch'
 * @readonly
 * @enum {string}
 */
export type LengthUnit = 'pixel' | 'inch';

/**
 * Defines values for Language.
 * Possible values include: 'en', 'es'
 * @readonly
 * @enum {string}
 */
export type Language = 'en' | 'es';

/**
 * Defines values for FieldValueType.
 * Possible values include: 'string', 'date', 'time', 'phoneNumber', 'number', 'integer', 'array',
 * 'object'
 * @readonly
 * @enum {string}
 */
export type FieldValueType = 'string' | 'date' | 'time' | 'phoneNumber' | 'number' | 'integer' | 'array' | 'object';

/**
 * Defines values for TrainStatus.
 * Possible values include: 'succeeded', 'partiallySucceeded', 'failed'
 * @readonly
 * @enum {string}
 */
export type TrainStatus = 'succeeded' | 'partiallySucceeded' | 'failed';

/**
 * Defines values for ModelStatus.
 * Possible values include: 'creating', 'ready', 'invalid'
 * @readonly
 * @enum {string}
 */
export type ModelStatus = 'creating' | 'ready' | 'invalid';

/**
 * Defines values for Op.
 * Possible values include: 'full', 'summary'
 * @readonly
 * @enum {string}
 */
export type Op = 'full' | 'summary';

/**
 * Contains response data for the trainCustomModelAsync operation.
 */
export type TrainCustomModelAsyncResponse = TrainCustomModelAsyncHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: TrainCustomModelAsyncHeaders;
    };
};

/**
 * Contains response data for the getCustomModels operation.
 */
export type GetCustomModelsResponse = ModelsModel & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ModelsModel;
    };
};

/**
 * Contains response data for the getCustomModel operation.
 */
export type GetCustomModelResponse = Model & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Model;
    };
};

/**
 * Contains response data for the analyzeWithCustomModel operation.
 */
export type AnalyzeWithCustomModelResponse = AnalyzeWithCustomModelHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: AnalyzeWithCustomModelHeaders;
    };
};

/**
 * Contains response data for the getAnalyzeFormResult operation.
 */
export type GetAnalyzeFormResultResponse = AnalyzeOperationResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AnalyzeOperationResult;
    };
};

/**
 * Contains response data for the analyzeReceiptAsync operation.
 */
export type AnalyzeReceiptAsyncResponse = AnalyzeReceiptAsyncHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: AnalyzeReceiptAsyncHeaders;
    };
};

/**
 * Contains response data for the getAnalyzeReceiptResult operation.
 */
export type GetAnalyzeReceiptResultResponse = AnalyzeOperationResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AnalyzeOperationResult;
    };
};

/**
 * Contains response data for the analyzeLayoutAsync operation.
 */
export type AnalyzeLayoutAsyncResponse = AnalyzeLayoutAsyncHeaders & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The parsed HTTP response headers.
       */
      parsedHeaders: AnalyzeLayoutAsyncHeaders;
    };
};

/**
 * Contains response data for the getAnalyzeLayoutResult operation.
 */
export type GetAnalyzeLayoutResultResponse = AnalyzeOperationResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;

      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AnalyzeOperationResult;
    };
};
