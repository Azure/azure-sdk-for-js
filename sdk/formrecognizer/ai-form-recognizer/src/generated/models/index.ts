/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreClient from "@azure/core-client";
import * as coreRestPipeline from "@azure/core-rest-pipeline";

/**
 * Details about any of several different types of Form Recognizer management operations.
 */
export type OperationDetailsUnion =
  | OperationDetails
  | DocumentModelBuildOperationDetails
  | DocumentModelComposeOperationDetails
  | DocumentModelCopyToOperationDetails
  | DocumentClassifierBuildOperationDetails;

/** Document analysis parameters. */
export interface AnalyzeDocumentRequest {
  /** Document URL to analyze.  Either urlSource or base64Source must be specified. */
  urlSource?: string;
  /** Base64 encoding of the document to analyze.  Either urlSource or base64Source must be specified. */
  base64Source?: Uint8Array;
}

/** Error response object. */
export interface ErrorResponse {
  /** Error info. */
  error: ErrorModel;
}

/** Error info. */
export interface ErrorModel {
  /** Error code. */
  code: string;
  /** Error message. */
  message: string;
  /** Target of the error. */
  target?: string;
  /** List of detailed errors. */
  details?: ErrorModel[];
  /** Detailed error. */
  innererror?: InnerError;
}

/** Detailed error. */
export interface InnerError {
  /** Error code. */
  code: string;
  /** Error message. */
  message?: string;
  /** Detailed error. */
  innererror?: InnerError;
}

/** Status and result of the analyze operation. */
export interface AnalyzeResultOperation {
  /** Operation status. */
  status: AnalyzeResultOperationStatus;
  /** Date and time (UTC) when the analyze operation was submitted. */
  createdOn: Date;
  /** Date and time (UTC) when the status was last updated. */
  lastUpdatedOn: Date;
  /** Encountered error during document analysis. */
  error?: ErrorModel;
  /** Document analysis result. */
  analyzeResult?: AnalyzeResult;
}

/** Document analysis result. */
export interface AnalyzeResult {
  /** API version used to produce this result. */
  apiVersion: string;
  /** Document model ID used to produce this result. */
  modelId: string;
  /** Method used to compute string offset and length. */
  stringIndexType: StringIndexType;
  /** Concatenate string representation of all textual and visual elements in reading order. */
  content: string;
  /** Analyzed pages. */
  pages: DocumentPage[];
  /** Extracted paragraphs. */
  paragraphs?: DocumentParagraph[];
  /** Extracted tables. */
  tables?: DocumentTable[];
  /** Extracted key-value pairs. */
  keyValuePairs?: DocumentKeyValuePair[];
  /** Extracted font styles. */
  styles?: DocumentStyle[];
  /** Detected languages. */
  languages?: DocumentLanguage[];
  /** Extracted documents. */
  documents?: Document[];
}

/** Content and layout elements extracted from a page from the input. */
export interface DocumentPage {
  /** 1-based page number in the input document. */
  pageNumber: number;
  /** The general orientation of the content in clockwise direction, measured in degrees between (-180, 180]. */
  angle?: number;
  /** The width of the image/PDF in pixels/inches, respectively. */
  width?: number;
  /** The height of the image/PDF in pixels/inches, respectively. */
  height?: number;
  /** The unit used by the width, height, and polygon properties. For images, the unit is "pixel". For PDF, the unit is "inch". */
  unit?: LengthUnit;
  /** Location of the page in the reading order concatenated content. */
  spans: DocumentSpan[];
  /** Extracted words from the page. */
  words?: DocumentWord[];
  /** Extracted selection marks from the page. */
  selectionMarks?: DocumentSelectionMark[];
  /** Extracted lines from the page, potentially containing both textual and visual elements. */
  lines?: DocumentLine[];
  /** Extracted barcodes from the page. */
  barcodes?: DocumentBarcode[];
  /** Extracted formulas from the page. */
  formulas?: DocumentFormula[];
}

/** Contiguous region of the concatenated content property, specified as an offset and length. */
export interface DocumentSpan {
  /** Zero-based index of the content represented by the span. */
  offset: number;
  /** Number of characters in the content represented by the span. */
  length: number;
}

/** A word object consisting of a contiguous sequence of characters.  For non-space delimited languages, such as Chinese, Japanese, and Korean, each character is represented as its own word. */
export interface DocumentWord {
  /** Text content of the word. */
  content: string;
  /** Bounding polygon of the word. */
  polygon?: number[];
  /** Location of the word in the reading order concatenated content. */
  span: DocumentSpan;
  /** Confidence of correctly extracting the word. */
  confidence: number;
}

/** A selection mark object representing check boxes, radio buttons, and other elements indicating a selection. */
export interface DocumentSelectionMark {
  /** State of the selection mark. */
  state: SelectionMarkState;
  /** Bounding polygon of the selection mark. */
  polygon?: number[];
  /** Location of the selection mark in the reading order concatenated content. */
  span: DocumentSpan;
  /** Confidence of correctly extracting the selection mark. */
  confidence: number;
}

/** A content line object consisting of an adjacent sequence of content elements, such as words and selection marks. */
export interface DocumentLine {
  /** Concatenated content of the contained elements in reading order. */
  content: string;
  /** Bounding polygon of the line. */
  polygon?: number[];
  /** Location of the line in the reading order concatenated content. */
  spans: DocumentSpan[];
}

/** A barcode object. */
export interface DocumentBarcode {
  /** Barcode kind. */
  kind: DocumentBarcodeKind;
  /** Barcode value */
  value: string;
  /** Bounding polygon of the barcode. */
  polygon?: number[];
  /** Location of the barcode in the reading order concatenated content. */
  span: DocumentSpan;
  /** Confidence of correctly extracting the barcode. */
  confidence: number;
}

/** A formula object. */
export interface DocumentFormula {
  /** Formula kind. */
  kind: DocumentFormulaKind;
  /** LaTex expression describing the formula. */
  value: string;
  /** Bounding polygon of the formula. */
  polygon?: number[];
  /** Location of the formula in the reading order concatenated content. */
  span: DocumentSpan;
  /** Confidence of correctly extracting the formula. */
  confidence: number;
}

/** A paragraph object consisting with contiguous lines generally with common alignment and spacing. */
export interface DocumentParagraph {
  /** Semantic role of the paragraph. */
  role?: ParagraphRole;
  /** Concatenated content of the paragraph in reading order. */
  content: string;
  /** Bounding regions covering the paragraph. */
  boundingRegions?: BoundingRegion[];
  /** Location of the paragraph in the reading order concatenated content. */
  spans: DocumentSpan[];
}

/** Bounding polygon on a specific page of the input. */
export interface BoundingRegion {
  /** 1-based page number of page containing the bounding region. */
  pageNumber: number;
  /** Bounding polygon on the page, or the entire page if not specified. */
  polygon: number[];
}

/** A table object consisting table cells arranged in a rectangular layout. */
export interface DocumentTable {
  /** Number of rows in the table. */
  rowCount: number;
  /** Number of columns in the table. */
  columnCount: number;
  /** Cells contained within the table. */
  cells: DocumentTableCell[];
  /** Bounding regions covering the table. */
  boundingRegions?: BoundingRegion[];
  /** Location of the table in the reading order concatenated content. */
  spans: DocumentSpan[];
}

/** An object representing the location and content of a table cell. */
export interface DocumentTableCell {
  /** Table cell kind. */
  kind?: DocumentTableCellKind;
  /** Row index of the cell. */
  rowIndex: number;
  /** Column index of the cell. */
  columnIndex: number;
  /** Number of rows spanned by this cell. */
  rowSpan?: number;
  /** Number of columns spanned by this cell. */
  columnSpan?: number;
  /** Concatenated content of the table cell in reading order. */
  content: string;
  /** Bounding regions covering the table cell. */
  boundingRegions?: BoundingRegion[];
  /** Location of the table cell in the reading order concatenated content. */
  spans: DocumentSpan[];
}

/** An object representing a form field with distinct field label (key) and field value (may be empty). */
export interface DocumentKeyValuePair {
  /** Field label of the key-value pair. */
  key: DocumentKeyValueElement;
  /** Field value of the key-value pair. */
  value?: DocumentKeyValueElement;
  /** Confidence of correctly extracting the key-value pair. */
  confidence: number;
}

/** An object representing the field key or value in a key-value pair. */
export interface DocumentKeyValueElement {
  /** Concatenated content of the key-value element in reading order. */
  content: string;
  /** Bounding regions covering the key-value element. */
  boundingRegions?: BoundingRegion[];
  /** Location of the key-value element in the reading order concatenated content. */
  spans: DocumentSpan[];
}

/** An object representing observed text styles. */
export interface DocumentStyle {
  /** Is content handwritten? */
  isHandwritten?: boolean;
  /** Visually most similar font from among the set of supported font families, with fallback fonts following CSS convention (ex. 'Arial, sans-serif'). */
  similarFontFamily?: string;
  /** Font style. */
  fontStyle?: FontStyle;
  /** Font weight. */
  fontWeight?: FontWeight;
  /** Foreground color in #rrggbb hexadecimal format. */
  color?: string;
  /** Background color in #rrggbb hexadecimal format.. */
  backgroundColor?: string;
  /** Location of the text elements in the concatenated content the style applies to. */
  spans: DocumentSpan[];
  /** Confidence of correctly identifying the style. */
  confidence: number;
}

/** An object representing the detected language for a given text span. */
export interface DocumentLanguage {
  /** Detected language.  Value may an ISO 639-1 language code (ex. "en", "fr") or BCP 47 language tag (ex. "zh-Hans"). */
  locale: string;
  /** Location of the text elements in the concatenated content the language applies to. */
  spans: DocumentSpan[];
  /** Confidence of correctly identifying the language. */
  confidence: number;
}

/** An object describing the location and semantic content of a document. */
export interface Document {
  /** Document type. */
  docType: string;
  /** Bounding regions covering the document. */
  boundingRegions?: BoundingRegion[];
  /** Location of the document in the reading order concatenated content. */
  spans: DocumentSpan[];
  /** Dictionary of named field values. */
  fields?: { [propertyName: string]: DocumentField };
  /** Confidence of correctly extracting the document. */
  confidence: number;
}

/** An object representing the content and location of a field value. */
export interface DocumentField {
  /** Data type of the field value. */
  type: DocumentFieldType;
  /** String value. */
  valueString?: string;
  /** Date value in YYYY-MM-DD format (ISO 8601). */
  valueDate?: Date;
  /**
   * Time value in hh:mm:ss format (ISO 8601).
   * This value should be an ISO-8601 formatted string representing time. E.g. "HH:MM:SS" or "HH:MM:SS.mm".
   */
  valueTime?: string;
  /** Phone number value in E.164 format (ex. +19876543210). */
  valuePhoneNumber?: string;
  /** Floating point value. */
  valueNumber?: number;
  /** Integer value. */
  valueInteger?: number;
  /** Selection mark value. */
  valueSelectionMark?: SelectionMarkState;
  /** Presence of signature. */
  valueSignature?: DocumentSignatureType;
  /** 3-letter country code value (ISO 3166-1 alpha-3). */
  valueCountryRegion?: string;
  /** Array of field values. */
  valueArray?: DocumentField[];
  /** Dictionary of named field values. */
  valueObject?: { [propertyName: string]: DocumentField };
  /** Currency value. */
  valueCurrency?: CurrencyValue;
  /** Address value. */
  valueAddress?: AddressValue;
  /** Boolean value. */
  valueBoolean?: boolean;
  /** Field content. */
  content?: string;
  /** Bounding regions covering the field. */
  boundingRegions?: BoundingRegion[];
  /** Location of the field in the reading order concatenated content. */
  spans?: DocumentSpan[];
  /** Confidence of correctly extracting the field. */
  confidence?: number;
}

/** Currency field value. */
export interface CurrencyValue {
  /** Currency amount. */
  amount: number;
  /** Currency symbol label, if any. */
  currencySymbol?: string;
  /** Resolved currency code (ISO 4217), if any. */
  currencyCode?: string;
}

/** Address field value. */
export interface AddressValue {
  /** House or building number. */
  houseNumber?: string;
  /** Post office box number. */
  poBox?: string;
  /** Street name. */
  road?: string;
  /** Name of city, town, village, etc. */
  city?: string;
  /** First-level administrative division. */
  state?: string;
  /** Postal code used for mail sorting. */
  postalCode?: string;
  /** Country/region. */
  countryRegion?: string;
  /** Street-level address, excluding city, state, countryRegion, and postalCode. */
  streetAddress?: string;
  /** Apartment or office number */
  unit?: string;
  /** Districts or boroughs within a city, such as Brooklyn in New York City or City of Westminster in London. */
  cityDistrict?: string;
  /** Second-level administrative division used in certain locales. */
  stateDistrict?: string;
  /** Unofficial neighborhood name, like Chinatown. */
  suburb?: string;
  /** Build name, such as World Trade Center. */
  house?: string;
  /** Floor number, such as 3F. */
  level?: string;
}

/** Request body to build a new custom document model. */
export interface BuildDocumentModelRequest {
  /** Unique document model name. */
  modelId: string;
  /** Document model description. */
  description?: string;
  /** Custom document model build mode. */
  buildMode: DocumentBuildMode;
  /** Azure Blob Storage location containing the training data.  Either azureBlobSource or azureBlobFileListSource must be specified. */
  azureBlobSource?: AzureBlobContentSource;
  /** Azure Blob Storage file list specifying the training data.  Either azureBlobSource or azureBlobFileListSource must be specified. */
  azureBlobFileListSource?: AzureBlobFileListContentSource;
  /** List of key-value tag attributes associated with the document model. */
  tags?: { [propertyName: string]: string };
}

/** Azure Blob Storage content. */
export interface AzureBlobContentSource {
  /** Azure Blob Storage container URL. */
  containerUrl: string;
  /** Blob name prefix. */
  prefix?: string;
}

/** File list in Azure Blob Storage. */
export interface AzureBlobFileListContentSource {
  /** Azure Blob Storage container URL. */
  containerUrl: string;
  /** Path to a JSONL file within the container specifying a subset of documents for training. */
  fileList: string;
}

/** Request body to create a composed document model from component document models. */
export interface ComposeDocumentModelRequest {
  /** Unique document model name. */
  modelId: string;
  /** Document model description. */
  description?: string;
  /** List of component document models to compose. */
  componentModels: ComponentDocumentModelDetails[];
  /** List of key-value tag attributes associated with the document model. */
  tags?: { [propertyName: string]: string };
}

/** A component of a composed document model. */
export interface ComponentDocumentModelDetails {
  /** Unique document model name. */
  modelId: string;
}

/** Request body to authorize document model copy. */
export interface AuthorizeCopyRequest {
  /** Unique document model name. */
  modelId: string;
  /** Document model description. */
  description?: string;
  /** List of key-value tag attributes associated with the document model. */
  tags?: { [propertyName: string]: string };
}

/** Authorization to copy a document model to the specified target resource and modelId. */
export interface CopyAuthorization {
  /** ID of the target Azure resource where the document model should be copied to. */
  targetResourceId: string;
  /** Location of the target Azure resource where the document model should be copied to. */
  targetResourceRegion: string;
  /** Identifier of the target document model. */
  targetModelId: string;
  /** URL of the copied document model in the target account. */
  targetModelLocation: string;
  /** Token used to authorize the request. */
  accessToken: string;
  /** Date/time when the access token expires. */
  expirationDateTime: Date;
}

/** List Operations response object. */
export interface GetOperationsResponse {
  /** List of operations. */
  value: OperationSummary[];
  /** Link to the next page of operations. */
  nextLink?: string;
}

/** Operation info. */
export interface OperationSummary {
  /** Operation ID */
  operationId: string;
  /** Operation status. */
  status: OperationStatus;
  /** Operation progress (0-100). */
  percentCompleted?: number;
  /** Date and time (UTC) when the operation was created. */
  createdOn: Date;
  /** Date and time (UTC) when the status was last updated. */
  lastUpdatedOn: Date;
  /** Type of operation. */
  kind: OperationKind;
  /** URL of the resource targeted by this operation. */
  resourceLocation: string;
  /** API version used to create this operation. */
  apiVersion?: string;
  /** List of key-value tag attributes associated with the document model. */
  tags?: { [propertyName: string]: string };
}

/** Get Operation response object. */
export interface OperationDetails {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind:
    | "documentModelBuild"
    | "documentModelCompose"
    | "documentModelCopyTo"
    | "documentClassifierBuild";
  /** Operation ID */
  operationId: string;
  /** Operation status. */
  status: OperationStatus;
  /** Operation progress (0-100). */
  percentCompleted?: number;
  /** Date and time (UTC) when the operation was created. */
  createdOn: Date;
  /** Date and time (UTC) when the status was last updated. */
  lastUpdatedOn: Date;
  /** URL of the resource targeted by this operation. */
  resourceLocation: string;
  /** API version used to create this operation. */
  apiVersion?: string;
  /** List of key-value tag attributes associated with the document model. */
  tags?: { [propertyName: string]: string };
  /** Encountered error. */
  error?: ErrorModel;
}

/** List document models response object. */
export interface GetDocumentModelsResponse {
  /** List of document models. */
  value: DocumentModelSummary[];
  /** Link to the next page of document models. */
  nextLink?: string;
}

/** Document model summary. */
export interface DocumentModelSummary {
  /** Unique document model name. */
  modelId: string;
  /** Document model description. */
  description?: string;
  /** Date and time (UTC) when the document model was created. */
  createdOn: Date;
  /** Date and time (UTC) when the document model will expire. */
  expiresOn?: Date;
  /** API version used to create this document model. */
  apiVersion?: string;
  /** List of key-value tag attributes associated with the document model. */
  tags?: { [propertyName: string]: string };
}

/** Document model info. */
export interface DocumentModelDetails {
  /** Unique document model name. */
  modelId: string;
  /** Document model description. */
  description?: string;
  /** Date and time (UTC) when the document model was created. */
  createdOn: Date;
  /** Date and time (UTC) when the document model will expire. */
  expiresOn?: Date;
  /** API version used to create this document model. */
  apiVersion?: string;
  /** List of key-value tag attributes associated with the document model. */
  tags?: { [propertyName: string]: string };
  /** Supported document types. */
  docTypes?: { [propertyName: string]: DocumentTypeDetails };
}

/** Document type info. */
export interface DocumentTypeDetails {
  /** Document model description. */
  description?: string;
  /** Custom document model build mode. */
  buildMode?: DocumentBuildMode;
  /** Description of the document semantic schema using a JSON Schema style syntax. */
  fieldSchema: { [propertyName: string]: DocumentFieldSchema };
  /** Estimated confidence for each field. */
  fieldConfidence?: { [propertyName: string]: number };
}

/** Description of the field semantic schema using a JSON Schema style syntax. */
export interface DocumentFieldSchema {
  /** Semantic data type of the field value. */
  type: DocumentFieldType;
  /** Field description. */
  description?: string;
  /** Example field content. */
  example?: string;
  /** Field type schema of each array element. */
  items?: DocumentFieldSchema;
  /** Named sub-fields of the object field. */
  properties?: { [propertyName: string]: DocumentFieldSchema };
}

/** Request body to build a new custom document classifier. */
export interface BuildDocumentClassifierRequest {
  /** Unique document classifier name. */
  classifierId: string;
  /** Document classifier description. */
  description?: string;
  /** List of document types to classify against. */
  docTypes: { [propertyName: string]: ClassifierDocumentTypeDetails };
}

/** Classifier document type info. */
export interface ClassifierDocumentTypeDetails {
  /** Azure Blob Storage location containing the training data for a classifier document type.  Either azureBlobSource or azureBlobFileListSource must be specified. */
  azureBlobSource?: AzureBlobContentSource;
  /** Azure Blob Storage file list specifying the training data for a classifier document type.  Either azureBlobSource or azureBlobFileListSource must be specified. */
  azureBlobFileListSource?: AzureBlobFileListContentSource;
}

/** List document classifiers response object. */
export interface GetDocumentClassifiersResponse {
  /** List of document classifiers. */
  value: DocumentClassifierDetails[];
  /** Link to the next page of document classifiers. */
  nextLink?: string;
}

/** Document classifier info. */
export interface DocumentClassifierDetails {
  /** Unique document classifier name. */
  classifierId: string;
  /** Document classifier description. */
  description?: string;
  /** Date and time (UTC) when the document classifier was created. */
  createdOn: Date;
  /** Date and time (UTC) when the document classifier will expire. */
  expiresOn?: Date;
  /** API version used to create this document classifier. */
  apiVersion: string;
  /** List of document types to classify against. */
  docTypes: { [propertyName: string]: ClassifierDocumentTypeDetails };
}

/** Document classification parameters. */
export interface ClassifyDocumentRequest {
  /** Document URL to classify.  Either urlSource or base64Source must be specified. */
  urlSource?: string;
  /** Base64 encoding of the document to classify.  Either urlSource or base64Source must be specified. */
  base64Source?: Uint8Array;
}

/** General information regarding the current resource. */
export interface ResourceDetails {
  /** Details regarding custom document models. */
  customDocumentModels: CustomDocumentModelsDetails;
  /** Quota used, limit, and next reset date/time. */
  customNeuralDocumentModelBuilds: QuotaDetails;
}

/** Details regarding custom document models. */
export interface CustomDocumentModelsDetails {
  /** Number of custom document models in the current resource. */
  count: number;
  /** Maximum number of custom document models supported in the current resource. */
  limit: number;
}

/** Quota used, limit, and next reset date/time. */
export interface QuotaDetails {
  /** Amount of the resource quota used. */
  used: number;
  /** Resource quota limit. */
  quota: number;
  /** Date/time when the resource quota usage will be reset. */
  quotaResetOn: Date;
}

/** Get Operation response object. */
export interface DocumentModelBuildOperationDetails extends OperationDetails {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "documentModelBuild";
  /** Operation result upon success. */
  result?: DocumentModelDetails;
}

/** Get Operation response object. */
export interface DocumentModelComposeOperationDetails extends OperationDetails {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "documentModelCompose";
  /** Operation result upon success. */
  result?: DocumentModelDetails;
}

/** Get Operation response object. */
export interface DocumentModelCopyToOperationDetails extends OperationDetails {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "documentModelCopyTo";
  /** Operation result upon success. */
  result?: DocumentModelDetails;
}

/** Get Operation response object. */
export interface DocumentClassifierBuildOperationDetails extends OperationDetails {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  kind: "documentClassifierBuild";
  /** Operation result upon success. */
  result?: DocumentClassifierDetails;
}

/** Defines headers for DocumentModels_analyzeDocument operation. */
export interface DocumentModelsAnalyzeDocumentHeaders {
  /** URL used to track the progress and obtain the result of the analyze operation. */
  operationLocation?: string;
}

/** Defines headers for DocumentModels_buildModel operation. */
export interface DocumentModelsBuildModelHeaders {
  /** Operation result URL. */
  operationLocation?: string;
}

/** Defines headers for DocumentModels_composeModel operation. */
export interface DocumentModelsComposeModelHeaders {
  /** Operation result URL. */
  operationLocation?: string;
}

/** Defines headers for DocumentModels_copyModelTo operation. */
export interface DocumentModelsCopyModelToHeaders {
  /** Operation result URL. */
  operationLocation?: string;
}

/** Defines headers for DocumentClassifiers_buildClassifier operation. */
export interface DocumentClassifiersBuildClassifierHeaders {
  /** Operation result URL. */
  operationLocation?: string;
}

/** Defines headers for DocumentClassifiers_classifyDocument operation. */
export interface DocumentClassifiersClassifyDocumentHeaders {
  /** URL used to track the progress and obtain the result of the classification operation. */
  operationLocation?: string;
}

/** Known values of {@link StringIndexType} that the service accepts. */
export enum KnownStringIndexType {
  /** User-perceived display character, or grapheme cluster, as defined by Unicode 8.0.0. */
  TextElements = "textElements",
  /** Character unit represented by a single unicode code point.  Used by Python 3. */
  UnicodeCodePoint = "unicodeCodePoint",
  /** Character unit represented by a 16-bit Unicode code unit.  Used by JavaScript, Java, and .NET. */
  Utf16CodeUnit = "utf16CodeUnit",
}

/**
 * Defines values for StringIndexType. \
 * {@link KnownStringIndexType} can be used interchangeably with StringIndexType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **textElements**: User-perceived display character, or grapheme cluster, as defined by Unicode 8.0.0. \
 * **unicodeCodePoint**: Character unit represented by a single unicode code point.  Used by Python 3. \
 * **utf16CodeUnit**: Character unit represented by a 16-bit Unicode code unit.  Used by JavaScript, Java, and .NET.
 */
export type StringIndexType = string;

/** Known values of {@link DocumentAnalysisFeature} that the service accepts. */
export enum KnownDocumentAnalysisFeature {
  /** Perform OCR at a higher resolution to handle documents with fine print. */
  OcrHighResolution = "ocrHighResolution",
  /** Enable the detection of the text content language. */
  Languages = "languages",
  /** Enable the detection of barcodes in the document. */
  Barcodes = "barcodes",
  /** Enable the detection of mathematical expressions in the document. */
  Formulas = "formulas",
  /** Enable the detection of general key value pairs (form fields) in the document. */
  KeyValuePairs = "keyValuePairs",
  /** Enable the recognition of various font styles. */
  StyleFont = "styleFont",
}

/**
 * Defines values for DocumentAnalysisFeature. \
 * {@link KnownDocumentAnalysisFeature} can be used interchangeably with DocumentAnalysisFeature,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **ocrHighResolution**: Perform OCR at a higher resolution to handle documents with fine print. \
 * **languages**: Enable the detection of the text content language. \
 * **barcodes**: Enable the detection of barcodes in the document. \
 * **formulas**: Enable the detection of mathematical expressions in the document. \
 * **keyValuePairs**: Enable the detection of general key value pairs (form fields) in the document. \
 * **styleFont**: Enable the recognition of various font styles.
 */
export type DocumentAnalysisFeature = string;

/** Known values of {@link LengthUnit} that the service accepts. */
export enum KnownLengthUnit {
  /** Length unit for image files. */
  Pixel = "pixel",
  /** Length unit for PDF files. */
  Inch = "inch",
}

/**
 * Defines values for LengthUnit. \
 * {@link KnownLengthUnit} can be used interchangeably with LengthUnit,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **pixel**: Length unit for image files. \
 * **inch**: Length unit for PDF files.
 */
export type LengthUnit = string;

/** Known values of {@link SelectionMarkState} that the service accepts. */
export enum KnownSelectionMarkState {
  /** The selection mark is selected, often indicated by a check ✓ or cross X inside the selection mark. */
  Selected = "selected",
  /** The selection mark is not selected. */
  Unselected = "unselected",
}

/**
 * Defines values for SelectionMarkState. \
 * {@link KnownSelectionMarkState} can be used interchangeably with SelectionMarkState,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **selected**: The selection mark is selected, often indicated by a check ✓ or cross X inside the selection mark. \
 * **unselected**: The selection mark is not selected.
 */
export type SelectionMarkState = string;

/** Known values of {@link DocumentBarcodeKind} that the service accepts. */
export enum KnownDocumentBarcodeKind {
  /** QR code, as defined in ISO/IEC 18004:2015. */
  QRCode = "QRCode",
  /** PDF417, as defined in ISO 15438. */
  PDF417 = "PDF417",
  /** GS1 12-digit Universal Product Code. */
  Upca = "UPCA",
  /** GS1 6-digit Universal Product Code. */
  Upce = "UPCE",
  /** Code 39 barcode, as defined in ISO/IEC 16388:2007. */
  Code39 = "Code39",
  /** Code 128 barcode, as defined in ISO/IEC 15417:2007. */
  Code128 = "Code128",
  /** GS1 8-digit International Article Number (European Article Number). */
  EAN8 = "EAN8",
  /** GS1 13-digit International Article Number (European Article Number). */
  EAN13 = "EAN13",
  /** GS1 DataBar barcode. */
  DataBar = "DataBar",
  /** Code 93 barcode, as defined in ANSI/AIM BC5-1995. */
  Code93 = "Code93",
  /** Codabar barcode, as defined in ANSI/AIM BC3-1995. */
  Codabar = "Codabar",
  /** GS1 DataBar Expanded barcode. */
  DataBarExpanded = "DataBarExpanded",
  /** Interleaved 2 of 5 barcode, as defined in ANSI/AIM BC2-1995. */
  ITF = "ITF",
  /** Micro QR code, as defined in ISO/IEC 23941:2022. */
  MicroQRCode = "MicroQRCode",
  /** Aztec code, as defined in ISO/IEC 24778:2008. */
  Aztec = "Aztec",
  /** Data matrix code, as defined in ISO/IEC 16022:2006. */
  DataMatrix = "DataMatrix",
  /** MaxiCode, as defined in ISO/IEC 16023:2000. */
  MaxiCode = "MaxiCode",
}

/**
 * Defines values for DocumentBarcodeKind. \
 * {@link KnownDocumentBarcodeKind} can be used interchangeably with DocumentBarcodeKind,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **QRCode**: QR code, as defined in ISO\/IEC 18004:2015. \
 * **PDF417**: PDF417, as defined in ISO 15438. \
 * **UPCA**: GS1 12-digit Universal Product Code. \
 * **UPCE**: GS1 6-digit Universal Product Code. \
 * **Code39**: Code 39 barcode, as defined in ISO\/IEC 16388:2007. \
 * **Code128**: Code 128 barcode, as defined in ISO\/IEC 15417:2007. \
 * **EAN8**: GS1 8-digit International Article Number (European Article Number). \
 * **EAN13**: GS1 13-digit International Article Number (European Article Number). \
 * **DataBar**: GS1 DataBar barcode. \
 * **Code93**: Code 93 barcode, as defined in ANSI\/AIM BC5-1995. \
 * **Codabar**: Codabar barcode, as defined in ANSI\/AIM BC3-1995. \
 * **DataBarExpanded**: GS1 DataBar Expanded barcode. \
 * **ITF**: Interleaved 2 of 5 barcode, as defined in ANSI\/AIM BC2-1995. \
 * **MicroQRCode**: Micro QR code, as defined in ISO\/IEC 23941:2022. \
 * **Aztec**: Aztec code, as defined in ISO\/IEC 24778:2008. \
 * **DataMatrix**: Data matrix code, as defined in ISO\/IEC 16022:2006. \
 * **MaxiCode**: MaxiCode, as defined in ISO\/IEC 16023:2000.
 */
export type DocumentBarcodeKind = string;

/** Known values of {@link DocumentFormulaKind} that the service accepts. */
export enum KnownDocumentFormulaKind {
  /** A formula embedded within the content of a paragraph. */
  Inline = "inline",
  /** A formula in display mode that takes up an entire line. */
  Display = "display",
}

/**
 * Defines values for DocumentFormulaKind. \
 * {@link KnownDocumentFormulaKind} can be used interchangeably with DocumentFormulaKind,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **inline**: A formula embedded within the content of a paragraph. \
 * **display**: A formula in display mode that takes up an entire line.
 */
export type DocumentFormulaKind = string;

/** Known values of {@link ParagraphRole} that the service accepts. */
export enum KnownParagraphRole {
  /** Text near the top edge of the page. */
  PageHeader = "pageHeader",
  /** Text near the bottom edge of the page. */
  PageFooter = "pageFooter",
  /** Page number. */
  PageNumber = "pageNumber",
  /** Top-level title describing the entire document. */
  Title = "title",
  /** Sub heading describing a section of the document. */
  SectionHeading = "sectionHeading",
  /** A note usually placed after the main content on a page. */
  Footnote = "footnote",
  /** A block of formulas, often with shared alignment. */
  FormulaBlock = "formulaBlock",
}

/**
 * Defines values for ParagraphRole. \
 * {@link KnownParagraphRole} can be used interchangeably with ParagraphRole,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **pageHeader**: Text near the top edge of the page. \
 * **pageFooter**: Text near the bottom edge of the page. \
 * **pageNumber**: Page number. \
 * **title**: Top-level title describing the entire document. \
 * **sectionHeading**: Sub heading describing a section of the document. \
 * **footnote**: A note usually placed after the main content on a page. \
 * **formulaBlock**: A block of formulas, often with shared alignment.
 */
export type ParagraphRole = string;

/** Known values of {@link DocumentTableCellKind} that the service accepts. */
export enum KnownDocumentTableCellKind {
  /** Contains the main content/data. */
  Content = "content",
  /** Describes the content of the row. */
  RowHeader = "rowHeader",
  /** Describes the content of the column. */
  ColumnHeader = "columnHeader",
  /** Describes the row headers, usually located at the top left corner of a table. */
  StubHead = "stubHead",
  /** Describes the content in (parts of) the table. */
  Description = "description",
}

/**
 * Defines values for DocumentTableCellKind. \
 * {@link KnownDocumentTableCellKind} can be used interchangeably with DocumentTableCellKind,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **content**: Contains the main content\/data. \
 * **rowHeader**: Describes the content of the row. \
 * **columnHeader**: Describes the content of the column. \
 * **stubHead**: Describes the row headers, usually located at the top left corner of a table. \
 * **description**: Describes the content in (parts of) the table.
 */
export type DocumentTableCellKind = string;

/** Known values of {@link FontStyle} that the service accepts. */
export enum KnownFontStyle {
  /** Characters are represented normally. */
  Normal = "normal",
  /** Characters are visually slanted to the right. */
  Italic = "italic",
}

/**
 * Defines values for FontStyle. \
 * {@link KnownFontStyle} can be used interchangeably with FontStyle,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **normal**: Characters are represented normally. \
 * **italic**: Characters are visually slanted to the right.
 */
export type FontStyle = string;

/** Known values of {@link FontWeight} that the service accepts. */
export enum KnownFontWeight {
  /** Characters are represented normally. */
  Normal = "normal",
  /** Characters are represented with thicker strokes. */
  Bold = "bold",
}

/**
 * Defines values for FontWeight. \
 * {@link KnownFontWeight} can be used interchangeably with FontWeight,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **normal**: Characters are represented normally. \
 * **bold**: Characters are represented with thicker strokes.
 */
export type FontWeight = string;

/** Known values of {@link DocumentFieldType} that the service accepts. */
export enum KnownDocumentFieldType {
  /** Plain text. */
  String = "string",
  /** Date, normalized to ISO 8601 (YYYY-MM-DD) format. */
  Date = "date",
  /** Time, normalized to ISO 8601 (hh:mm:ss) format. */
  Time = "time",
  /** Phone number, normalized to E.164 (+{CountryCode}{SubscriberNumber}) format. */
  PhoneNumber = "phoneNumber",
  /** Floating point number, normalized to double precision floating point. */
  Number = "number",
  /** Integer number, normalized to 64-bit signed integer. */
  Integer = "integer",
  /** Is field selected? */
  SelectionMark = "selectionMark",
  /** Country/region, normalized to ISO 3166-1 alpha-3 format (ex. USA). */
  CountryRegion = "countryRegion",
  /** Is signature present? */
  Signature = "signature",
  /** List of subfields of the same type. */
  Array = "array",
  /** Named list of subfields of potentially different types. */
  Object = "object",
  /** Currency amount with optional currency symbol and unit. */
  Currency = "currency",
  /** Parsed address. */
  Address = "address",
  /** Boolean value, normalized to true or false. */
  Boolean = "boolean",
}

/**
 * Defines values for DocumentFieldType. \
 * {@link KnownDocumentFieldType} can be used interchangeably with DocumentFieldType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **string**: Plain text. \
 * **date**: Date, normalized to ISO 8601 (YYYY-MM-DD) format. \
 * **time**: Time, normalized to ISO 8601 (hh:mm:ss) format. \
 * **phoneNumber**: Phone number, normalized to E.164 (+{CountryCode}{SubscriberNumber}) format. \
 * **number**: Floating point number, normalized to double precision floating point. \
 * **integer**: Integer number, normalized to 64-bit signed integer. \
 * **selectionMark**: Is field selected? \
 * **countryRegion**: Country\/region, normalized to ISO 3166-1 alpha-3 format (ex. USA). \
 * **signature**: Is signature present? \
 * **array**: List of subfields of the same type. \
 * **object**: Named list of subfields of potentially different types. \
 * **currency**: Currency amount with optional currency symbol and unit. \
 * **address**: Parsed address. \
 * **boolean**: Boolean value, normalized to true or false.
 */
export type DocumentFieldType = string;

/** Known values of {@link DocumentSignatureType} that the service accepts. */
export enum KnownDocumentSignatureType {
  /** A signature is detected. */
  Signed = "signed",
  /** No signatures are detected. */
  Unsigned = "unsigned",
}

/**
 * Defines values for DocumentSignatureType. \
 * {@link KnownDocumentSignatureType} can be used interchangeably with DocumentSignatureType,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **signed**: A signature is detected. \
 * **unsigned**: No signatures are detected.
 */
export type DocumentSignatureType = string;

/** Known values of {@link DocumentBuildMode} that the service accepts. */
export enum KnownDocumentBuildMode {
  /** Target documents with similar visual templates. */
  Template = "template",
  /** Support documents with diverse visual templates. */
  Neural = "neural",
}

/**
 * Defines values for DocumentBuildMode. \
 * {@link KnownDocumentBuildMode} can be used interchangeably with DocumentBuildMode,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **template**: Target documents with similar visual templates. \
 * **neural**: Support documents with diverse visual templates.
 */
export type DocumentBuildMode = string;

/** Known values of {@link OperationKind} that the service accepts. */
export enum KnownOperationKind {
  /** Build a new custom document model. */
  DocumentModelBuild = "documentModelBuild",
  /** Compose a new custom document model from existing models. */
  DocumentModelCompose = "documentModelCompose",
  /** Copy an existing document model to potentially a different resource, region, or subscription. */
  DocumentModelCopyTo = "documentModelCopyTo",
  /** Build a new custom classifier model. */
  DocumentClassifierBuild = "documentClassifierBuild",
}

/**
 * Defines values for OperationKind. \
 * {@link KnownOperationKind} can be used interchangeably with OperationKind,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **documentModelBuild**: Build a new custom document model. \
 * **documentModelCompose**: Compose a new custom document model from existing models. \
 * **documentModelCopyTo**: Copy an existing document model to potentially a different resource, region, or subscription. \
 * **documentClassifierBuild**: Build a new custom classifier model.
 */
export type OperationKind = string;
/** Defines values for ContentType. */
export type ContentType =
  | "application/octet-stream"
  | "application/pdf"
  | "application/vnd.openxmlformats-officedocument.presentationml.presentation"
  | "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  | "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
  | "image/bmp"
  | "image/heif"
  | "image/jpeg"
  | "image/png"
  | "image/tiff";
/** Defines values for AnalyzeResultOperationStatus. */
export type AnalyzeResultOperationStatus = "notStarted" | "running" | "failed" | "succeeded";
/** Defines values for OperationStatus. */
export type OperationStatus = "notStarted" | "running" | "failed" | "succeeded" | "canceled";

/** Optional parameters. */
export interface DocumentModelsAnalyzeDocument$binaryOptionalParams
  extends coreClient.OperationOptions {
  /** Analyze request parameters. */
  analyzeRequest?: coreRestPipeline.RequestBodyType;
  /** List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9" */
  pages?: string;
  /** Locale hint for text recognition and document analysis.  Value may contain only the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US"). */
  locale?: string;
  /** List of optional analysis features. */
  features?: DocumentAnalysisFeature[];
}

/** Optional parameters. */
export interface DocumentModelsAnalyzeDocument$textOptionalParams
  extends coreClient.OperationOptions {
  /** Analyze request parameters. */
  analyzeRequest?: string;
  /** List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9" */
  pages?: string;
  /** Locale hint for text recognition and document analysis.  Value may contain only the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US"). */
  locale?: string;
  /** List of optional analysis features. */
  features?: DocumentAnalysisFeature[];
}

/** Optional parameters. */
export interface DocumentModelsAnalyzeDocument$jsonOptionalParams
  extends coreClient.OperationOptions {
  /** Analyze request parameters. */
  analyzeRequest?: AnalyzeDocumentRequest;
  /** List of 1-based page numbers to analyze.  Ex. "1-3,5,7-9" */
  pages?: string;
  /** Locale hint for text recognition and document analysis.  Value may contain only the language code (ex. "en", "fr") or BCP 47 language tag (ex. "en-US"). */
  locale?: string;
  /** List of optional analysis features. */
  features?: DocumentAnalysisFeature[];
}

/** Contains response data for the analyzeDocument operation. */
export type DocumentModelsAnalyzeDocumentResponse = DocumentModelsAnalyzeDocumentHeaders;

/** Optional parameters. */
export interface DocumentModelsGetAnalyzeResultOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the getAnalyzeResult operation. */
export type DocumentModelsGetAnalyzeResultResponse = AnalyzeResultOperation;

/** Optional parameters. */
export interface DocumentModelsBuildModelOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the buildModel operation. */
export type DocumentModelsBuildModelResponse = DocumentModelsBuildModelHeaders;

/** Optional parameters. */
export interface DocumentModelsComposeModelOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the composeModel operation. */
export type DocumentModelsComposeModelResponse = DocumentModelsComposeModelHeaders;

/** Optional parameters. */
export interface DocumentModelsAuthorizeModelCopyOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the authorizeModelCopy operation. */
export type DocumentModelsAuthorizeModelCopyResponse = CopyAuthorization;

/** Optional parameters. */
export interface DocumentModelsCopyModelToOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the copyModelTo operation. */
export type DocumentModelsCopyModelToResponse = DocumentModelsCopyModelToHeaders;

/** Optional parameters. */
export interface DocumentModelsListModelsOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the listModels operation. */
export type DocumentModelsListModelsResponse = GetDocumentModelsResponse;

/** Optional parameters. */
export interface DocumentModelsGetModelOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the getModel operation. */
export type DocumentModelsGetModelResponse = DocumentModelDetails;

/** Optional parameters. */
export interface DocumentModelsDeleteModelOptionalParams extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface DocumentModelsListModelsNextOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the listModelsNext operation. */
export type DocumentModelsListModelsNextResponse = GetDocumentModelsResponse;

/** Optional parameters. */
export interface MiscellaneousListOperationsOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the listOperations operation. */
export type MiscellaneousListOperationsResponse = GetOperationsResponse;

/** Optional parameters. */
export interface MiscellaneousGetOperationOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the getOperation operation. */
export type MiscellaneousGetOperationResponse = OperationDetailsUnion;

/** Optional parameters. */
export interface MiscellaneousGetResourceInfoOptionalParams extends coreClient.OperationOptions {}

/** Contains response data for the getResourceInfo operation. */
export type MiscellaneousGetResourceInfoResponse = ResourceDetails;

/** Optional parameters. */
export interface MiscellaneousListOperationsNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listOperationsNext operation. */
export type MiscellaneousListOperationsNextResponse = GetOperationsResponse;

/** Optional parameters. */
export interface DocumentClassifiersBuildClassifierOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the buildClassifier operation. */
export type DocumentClassifiersBuildClassifierResponse = DocumentClassifiersBuildClassifierHeaders;

/** Optional parameters. */
export interface DocumentClassifiersListClassifiersOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listClassifiers operation. */
export type DocumentClassifiersListClassifiersResponse = GetDocumentClassifiersResponse;

/** Optional parameters. */
export interface DocumentClassifiersGetClassifierOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getClassifier operation. */
export type DocumentClassifiersGetClassifierResponse = DocumentClassifierDetails;

/** Optional parameters. */
export interface DocumentClassifiersDeleteClassifierOptionalParams
  extends coreClient.OperationOptions {}

/** Optional parameters. */
export interface DocumentClassifiersClassifyDocument$binaryOptionalParams
  extends coreClient.OperationOptions {
  /** Classify request parameters. */
  classifyRequest?: coreRestPipeline.RequestBodyType;
}

/** Optional parameters. */
export interface DocumentClassifiersClassifyDocument$textOptionalParams
  extends coreClient.OperationOptions {
  /** Classify request parameters. */
  classifyRequest?: string;
}

/** Optional parameters. */
export interface DocumentClassifiersClassifyDocument$jsonOptionalParams
  extends coreClient.OperationOptions {
  /** Classify request parameters. */
  classifyRequest?: ClassifyDocumentRequest;
}

/** Contains response data for the classifyDocument operation. */
export type DocumentClassifiersClassifyDocumentResponse =
  DocumentClassifiersClassifyDocumentHeaders;

/** Optional parameters. */
export interface DocumentClassifiersGetClassifyResultOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the getClassifyResult operation. */
export type DocumentClassifiersGetClassifyResultResponse = AnalyzeResultOperation;

/** Optional parameters. */
export interface DocumentClassifiersListClassifiersNextOptionalParams
  extends coreClient.OperationOptions {}

/** Contains response data for the listClassifiersNext operation. */
export type DocumentClassifiersListClassifiersNextResponse = GetDocumentClassifiersResponse;

/** Optional parameters. */
export interface GeneratedClientOptionalParams extends coreClient.ServiceClientOptions {
  /** Method used to compute string offset and length. */
  stringIndexType?: StringIndexType;
  /** Api Version */
  apiVersion?: string;
  /** Overrides client endpoint. */
  endpoint?: string;
}
