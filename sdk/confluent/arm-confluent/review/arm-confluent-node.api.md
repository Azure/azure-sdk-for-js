## API Report File for "@azure/arm-confluent"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { ClientOptions } from '@azure-rest/core-client';
import { OperationOptions } from '@azure-rest/core-client';
import { OperationState } from '@azure/core-lro';
import { PathUncheckedResponse } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AccessCreateRoleBindingOptionalParams extends OperationOptions {
}

// @public
export interface AccessCreateRoleBindingRequestModel {
    crnPattern?: string;
    principal?: string;
    roleName?: string;
}

// @public
export interface AccessDeleteRoleBindingOptionalParams extends OperationOptions {
}

// @public
export interface AccessInvitedUserDetails {
    authType?: string;
    invitedEmail?: string;
}

// @public
export interface AccessInviteUserAccountModel {
    email?: string;
    invitedUserDetails?: AccessInvitedUserDetails;
    organizationId?: string;
    upn?: string;
}

// @public
export interface AccessInviteUserOptionalParams extends OperationOptions {
}

// @public
export interface AccessListClustersOptionalParams extends OperationOptions {
}

// @public
export interface AccessListClusterSuccessResponse {
    data?: ClusterRecord[];
    kind?: string;
    metadata?: ConfluentListMetadata;
}

// @public
export interface AccessListEnvironmentsOptionalParams extends OperationOptions {
}

// @public
export interface AccessListEnvironmentsSuccessResponse {
    data?: EnvironmentRecord[];
    kind?: string;
    metadata?: ConfluentListMetadata;
}

// @public
export interface AccessListInvitationsOptionalParams extends OperationOptions {
}

// @public
export interface AccessListInvitationsSuccessResponse {
    data?: InvitationRecord[];
    kind?: string;
    metadata?: ConfluentListMetadata;
}

// @public
export interface AccessListRoleBindingNameListOptionalParams extends OperationOptions {
}

// @public
export interface AccessListRoleBindingsOptionalParams extends OperationOptions {
}

// @public
export interface AccessListRoleBindingsSuccessResponse {
    data?: RoleBindingRecord[];
    kind?: string;
    metadata?: ConfluentListMetadata;
}

// @public
export interface AccessListServiceAccountsOptionalParams extends OperationOptions {
}

// @public
export interface AccessListServiceAccountsSuccessResponse {
    data?: ServiceAccountRecord[];
    kind?: string;
    metadata?: ConfluentListMetadata;
}

// @public
export interface AccessListUsersOptionalParams extends OperationOptions {
}

// @public
export interface AccessListUsersSuccessResponse {
    data?: UserRecord[];
    kind?: string;
    metadata?: ConfluentListMetadata;
}

// @public
export interface AccessOperations {
    createRoleBinding: (resourceGroupName: string, organizationName: string, body: AccessCreateRoleBindingRequestModel, options?: AccessCreateRoleBindingOptionalParams) => Promise<RoleBindingRecord>;
    deleteRoleBinding: (resourceGroupName: string, organizationName: string, roleBindingId: string, options?: AccessDeleteRoleBindingOptionalParams) => Promise<void>;
    inviteUser: (resourceGroupName: string, organizationName: string, body: AccessInviteUserAccountModel, options?: AccessInviteUserOptionalParams) => Promise<InvitationRecord>;
    listClusters: (resourceGroupName: string, organizationName: string, body: ListAccessRequestModel, options?: AccessListClustersOptionalParams) => Promise<AccessListClusterSuccessResponse>;
    listEnvironments: (resourceGroupName: string, organizationName: string, body: ListAccessRequestModel, options?: AccessListEnvironmentsOptionalParams) => Promise<AccessListEnvironmentsSuccessResponse>;
    listInvitations: (resourceGroupName: string, organizationName: string, body: ListAccessRequestModel, options?: AccessListInvitationsOptionalParams) => Promise<AccessListInvitationsSuccessResponse>;
    listRoleBindingNameList: (resourceGroupName: string, organizationName: string, body: ListAccessRequestModel, options?: AccessListRoleBindingNameListOptionalParams) => Promise<AccessRoleBindingNameListSuccessResponse>;
    listRoleBindings: (resourceGroupName: string, organizationName: string, body: ListAccessRequestModel, options?: AccessListRoleBindingsOptionalParams) => Promise<AccessListRoleBindingsSuccessResponse>;
    listServiceAccounts: (resourceGroupName: string, organizationName: string, body: ListAccessRequestModel, options?: AccessListServiceAccountsOptionalParams) => Promise<AccessListServiceAccountsSuccessResponse>;
    listUsers: (resourceGroupName: string, organizationName: string, body: ListAccessRequestModel, options?: AccessListUsersOptionalParams) => Promise<AccessListUsersSuccessResponse>;
}

// @public
export interface AccessRoleBindingNameListSuccessResponse {
    data?: string[];
    kind?: string;
    metadata?: ConfluentListMetadata;
}

// @public
export interface APIKeyOwnerEntity {
    id?: string;
    kind?: string;
    related?: string;
    resourceName?: string;
}

// @public
export interface APIKeyProperties {
    metadata?: SCMetadataEntity;
    spec?: APIKeySpecEntity;
}

// @public
export interface APIKeyRecord {
    id?: string;
    kind?: string;
    properties?: APIKeyProperties;
}

// @public
export interface APIKeyResourceEntity {
    environment?: string;
    id?: string;
    kind?: string;
    related?: string;
    resourceName?: string;
}

// @public
export interface APIKeySpecEntity {
    description?: string;
    name?: string;
    owner?: APIKeyOwnerEntity;
    resource?: APIKeyResourceEntity;
    secret?: string;
}

// @public
export type AuthType = string;

// @public
export interface AzureBlobStorageSinkConnectorServiceInfo extends ConnectorServiceTypeInfoBase {
    connectorServiceType: "AzureBlobStorageSinkConnector";
    storageAccountKey?: string;
    storageAccountName?: string;
    storageContainerName?: string;
}

// @public
export interface AzureBlobStorageSourceConnectorServiceInfo extends ConnectorServiceTypeInfoBase {
    connectorServiceType: "AzureBlobStorageSourceConnector";
    storageAccountKey?: string;
    storageAccountName?: string;
    storageContainerName?: string;
}

// @public
export enum AzureClouds {
    AZURE_CHINA_CLOUD = "AZURE_CHINA_CLOUD",
    AZURE_PUBLIC_CLOUD = "AZURE_PUBLIC_CLOUD",
    AZURE_US_GOVERNMENT = "AZURE_US_GOVERNMENT"
}

// @public
export interface AzureCosmosDBSinkConnectorServiceInfo extends ConnectorServiceTypeInfoBase {
    connectorServiceType: "AzureCosmosDBSinkConnector";
    cosmosConnectionEndpoint?: string;
    cosmosContainersTopicMapping?: string;
    cosmosDatabaseName?: string;
    cosmosIdStrategy?: string;
    cosmosMasterKey?: string;
}

// @public
export interface AzureCosmosDBSourceConnectorServiceInfo extends ConnectorServiceTypeInfoBase {
    connectorServiceType: "AzureCosmosDBSourceConnector";
    cosmosConnectionEndpoint?: string;
    cosmosContainersTopicMapping?: string;
    cosmosDatabaseName?: string;
    cosmosMasterKey?: string;
    cosmosMessageKeyEnabled?: boolean;
    cosmosMessageKeyField?: string;
}

// @public
export type AzureSupportedClouds = `${AzureClouds}`;

// @public
export interface AzureSynapseAnalyticsSinkConnectorServiceInfo extends ConnectorServiceTypeInfoBase {
    connectorServiceType: "AzureSynapseAnalyticsSinkConnector";
    synapseSqlDatabaseName?: string;
    synapseSqlPassword?: string;
    synapseSqlServerName?: string;
    synapseSqlUser?: string;
}

// @public
export interface ClusterByokEntity {
    id?: string;
    related?: string;
    resourceName?: string;
}

// @public
export interface ClusterConfigEntity {
    kind?: string;
}

// @public
export interface ClusterCreateOrUpdateOptionalParams extends OperationOptions {
    body?: SCClusterRecord;
}

// @public
export interface ClusterDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ClusterEnvironmentEntity {
    environment?: string;
    id?: string;
    related?: string;
    resourceName?: string;
}

// @public
export interface ClusterNetworkEntity {
    environment?: string;
    id?: string;
    related?: string;
    resourceName?: string;
}

// @public
export interface ClusterOperations {
    createOrUpdate: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, options?: ClusterCreateOrUpdateOptionalParams) => Promise<SCClusterRecord>;
    delete: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, options?: ClusterDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export interface ClusterProperties {
    metadata?: SCMetadataEntity;
    spec?: SCClusterSpecEntity;
    status?: ClusterStatusEntity;
}

// @public
export interface ClusterRecord {
    displayName?: string;
    id?: string;
    kind?: string;
    metadata?: MetadataEntity;
    spec?: ClusterSpecEntity;
    status?: ClusterStatusEntity;
}

// @public
export interface ClusterSpecEntity {
    apiEndpoint?: string;
    availability?: string;
    byok?: ClusterByokEntity;
    cloud?: string;
    config?: ClusterConfigEntity;
    displayName?: string;
    environment?: ClusterEnvironmentEntity;
    httpEndpoint?: string;
    kafkaBootstrapEndpoint?: string;
    network?: ClusterNetworkEntity;
    region?: string;
    zone?: string;
}

// @public
export interface ClusterStatusEntity {
    cku?: number;
    phase?: string;
}

// @public
export interface ConfluentAgreementProperties {
    accepted?: boolean;
    licenseTextLink?: string;
    plan?: string;
    privacyPolicyLink?: string;
    product?: string;
    publisher?: string;
    retrieveDatetime?: Date;
    signature?: string;
}

// @public
export interface ConfluentAgreementResource {
    readonly id?: string;
    readonly name?: string;
    properties?: ConfluentAgreementProperties;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ConfluentListMetadata {
    first?: string;
    last?: string;
    next?: string;
    prev?: string;
    totalSize?: number;
}

// @public (undocumented)
export class ConfluentManagementClient {
    constructor(credential: TokenCredential, subscriptionId: string, options?: ConfluentManagementClientOptionalParams);
    readonly access: AccessOperations;
    readonly cluster: ClusterOperations;
    readonly connector: ConnectorOperations;
    readonly environment: EnvironmentOperations;
    readonly marketplaceAgreements: MarketplaceAgreementsOperations;
    readonly organization: OrganizationOperations;
    readonly organizationOperations: OrganizationOperationsOperations;
    readonly pipeline: Pipeline;
    readonly topics: TopicsOperations;
    readonly validations: ValidationsOperations;
}

// @public
export interface ConfluentManagementClientOptionalParams extends ClientOptions {
    apiVersion?: string;
    cloudSetting?: AzureSupportedClouds;
}

// @public
export type ConnectorClass = string;

// @public
export interface ConnectorCreateOrUpdateOptionalParams extends OperationOptions {
    body?: ConnectorResource;
}

// @public
export interface ConnectorDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ConnectorGetOptionalParams extends OperationOptions {
}

// @public
export interface ConnectorInfoBase {
    connectorClass?: ConnectorClass;
    connectorId?: string;
    connectorName?: string;
    connectorState?: ConnectorStatus;
    connectorType?: ConnectorType;
}

// @public
export interface ConnectorListOptionalParams extends OperationOptions {
    pageSize?: number;
    pageToken?: string;
}

// @public
export interface ConnectorOperations {
    createOrUpdate: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, connectorName: string, options?: ConnectorCreateOrUpdateOptionalParams) => Promise<ConnectorResource>;
    delete: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, connectorName: string, options?: ConnectorDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, connectorName: string, options?: ConnectorGetOptionalParams) => Promise<ConnectorResource>;
    list: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, options?: ConnectorListOptionalParams) => PagedAsyncIterableIterator<ConnectorResource>;
}

// @public
export interface ConnectorResource extends ProxyResource {
    properties: ConnectorResourceProperties;
}

// @public
export interface ConnectorResourceProperties {
    connectorBasicInfo?: ConnectorInfoBase;
    connectorServiceTypeInfo?: ConnectorServiceTypeInfoBaseUnion;
    partnerConnectorInfo?: PartnerInfoBaseUnion;
}

// @public
export type ConnectorServiceType = string;

// @public
export interface ConnectorServiceTypeInfoBase {
    connectorServiceType: ConnectorServiceType;
}

// @public
export type ConnectorServiceTypeInfoBaseUnion = AzureBlobStorageSinkConnectorServiceInfo | AzureBlobStorageSourceConnectorServiceInfo | AzureCosmosDBSinkConnectorServiceInfo | AzureCosmosDBSourceConnectorServiceInfo | AzureSynapseAnalyticsSinkConnectorServiceInfo | ConnectorServiceTypeInfoBase;

// @public
export type ConnectorStatus = string;

// @public
export type ConnectorType = string;

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CreateAPIKeyModel {
    description?: string;
    name?: string;
}

// @public
export type CreatedByType = string;

// @public
export type DataFormatType = string;

// @public
export interface EnvironmentCreateOrUpdateOptionalParams extends OperationOptions {
    body?: SCEnvironmentRecord;
}

// @public
export interface EnvironmentDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface EnvironmentOperations {
    createOrUpdate: (resourceGroupName: string, organizationName: string, environmentId: string, options?: EnvironmentCreateOrUpdateOptionalParams) => Promise<SCEnvironmentRecord>;
    delete: (resourceGroupName: string, organizationName: string, environmentId: string, options?: EnvironmentDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export interface EnvironmentProperties {
    metadata?: SCMetadataEntity;
    streamGovernanceConfig?: StreamGovernanceConfig;
}

// @public
export interface EnvironmentRecord {
    displayName?: string;
    id?: string;
    kind?: string;
    metadata?: MetadataEntity;
}

// @public
export interface ErrorAdditionalInfo {
    readonly info?: any;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
export interface ErrorResponseBody {
    readonly code?: string;
    readonly details?: ErrorResponseBody[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface InvitationRecord {
    acceptedAt?: string;
    authType?: string;
    email?: string;
    expiresAt?: string;
    id?: string;
    kind?: string;
    metadata?: MetadataEntity;
    status?: string;
}

// @public
export interface KafkaAzureBlobStorageSinkConnectorInfo extends PartnerInfoBase {
    apiKey?: string;
    apiSecret?: string;
    authType?: AuthType;
    flushSize?: string;
    inputFormat?: DataFormatType;
    maxTasks?: string;
    outputFormat?: DataFormatType;
    partnerConnectorType: "KafkaAzureBlobStorageSink";
    serviceAccountId?: string;
    timeInterval?: string;
    topics?: string[];
    topicsDir?: string;
}

// @public
export interface KafkaAzureBlobStorageSourceConnectorInfo extends PartnerInfoBase {
    apiKey?: string;
    apiSecret?: string;
    authType?: AuthType;
    inputFormat?: DataFormatType;
    maxTasks?: string;
    outputFormat?: DataFormatType;
    partnerConnectorType: "KafkaAzureBlobStorageSource";
    serviceAccountId?: string;
    topicRegex?: string;
    topicsDir?: string;
}

// @public
export interface KafkaAzureCosmosDBSinkConnectorInfo extends PartnerInfoBase {
    apiKey?: string;
    apiSecret?: string;
    authType?: AuthType;
    flushSize?: string;
    inputFormat?: DataFormatType;
    maxTasks?: string;
    outputFormat?: DataFormatType;
    partnerConnectorType: "KafkaAzureCosmosDBSink";
    serviceAccountId?: string;
    timeInterval?: string;
    topics?: string[];
    topicsDir?: string;
}

// @public
export interface KafkaAzureCosmosDBSourceConnectorInfo extends PartnerInfoBase {
    apiKey?: string;
    apiSecret?: string;
    authType?: AuthType;
    inputFormat?: DataFormatType;
    maxTasks?: string;
    outputFormat?: DataFormatType;
    partnerConnectorType: "KafkaAzureCosmosDBSource";
    serviceAccountId?: string;
    topicRegex?: string;
    topicsDir?: string;
}

// @public
export interface KafkaAzureSynapseAnalyticsSinkConnectorInfo extends PartnerInfoBase {
    apiKey?: string;
    apiSecret?: string;
    authType?: AuthType;
    flushSize?: string;
    inputFormat?: DataFormatType;
    maxTasks?: string;
    outputFormat?: DataFormatType;
    partnerConnectorType: "KafkaAzureSynapseAnalyticsSink";
    serviceAccountId?: string;
    timeInterval?: string;
    topics?: string[];
    topicsDir?: string;
}

// @public
export enum KnownAuthType {
    // (undocumented)
    KafkaAPIKEY = "KAFKA_API_KEY",
    // (undocumented)
    ServiceAccount = "SERVICE_ACCOUNT"
}

// @public
export enum KnownConnectorClass {
    // (undocumented)
    Azureblobsink = "AZUREBLOBSINK",
    // (undocumented)
    Azureblobsource = "AZUREBLOBSOURCE"
}

// @public
export enum KnownConnectorServiceType {
    // (undocumented)
    AzureBlobStorageSinkConnector = "AzureBlobStorageSinkConnector",
    // (undocumented)
    AzureBlobStorageSourceConnector = "AzureBlobStorageSourceConnector",
    // (undocumented)
    AzureCosmosDBSinkConnector = "AzureCosmosDBSinkConnector",
    // (undocumented)
    AzureCosmosDBSourceConnector = "AzureCosmosDBSourceConnector",
    // (undocumented)
    AzureSynapseAnalyticsSinkConnector = "AzureSynapseAnalyticsSinkConnector"
}

// @public
export enum KnownConnectorStatus {
    // (undocumented)
    Failed = "FAILED",
    // (undocumented)
    Paused = "PAUSED",
    // (undocumented)
    Provisioning = "PROVISIONING",
    // (undocumented)
    Running = "RUNNING"
}

// @public
export enum KnownConnectorType {
    // (undocumented)
    Sink = "SINK",
    // (undocumented)
    Source = "SOURCE"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDataFormatType {
    // (undocumented)
    Avro = "AVRO",
    // (undocumented)
    Bytes = "BYTES",
    // (undocumented)
    Json = "JSON",
    // (undocumented)
    Protobuf = "PROTOBUF",
    // (undocumented)
    String = "STRING"
}

// @public
export enum KnownPackage {
    // (undocumented)
    Advanced = "ADVANCED",
    // (undocumented)
    Essentials = "ESSENTIALS"
}

// @public
export enum KnownPartnerConnectorType {
    // (undocumented)
    KafkaAzureBlobStorageSink = "KafkaAzureBlobStorageSink",
    // (undocumented)
    KafkaAzureBlobStorageSource = "KafkaAzureBlobStorageSource",
    // (undocumented)
    KafkaAzureCosmosDBSink = "KafkaAzureCosmosDBSink",
    // (undocumented)
    KafkaAzureCosmosDBSource = "KafkaAzureCosmosDBSource",
    // (undocumented)
    KafkaAzureSynapseAnalyticsSink = "KafkaAzureSynapseAnalyticsSink"
}

// @public
export enum KnownProvisionState {
    // (undocumented)
    Accepted = "Accepted",
    // (undocumented)
    Canceled = "Canceled",
    // (undocumented)
    Creating = "Creating",
    // (undocumented)
    Deleted = "Deleted",
    // (undocumented)
    Deleting = "Deleting",
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    NotSpecified = "NotSpecified",
    // (undocumented)
    Succeeded = "Succeeded",
    // (undocumented)
    Updating = "Updating"
}

// @public
export enum KnownSaaSOfferStatus {
    // (undocumented)
    Failed = "Failed",
    // (undocumented)
    InProgress = "InProgress",
    // (undocumented)
    PendingFulfillmentStart = "PendingFulfillmentStart",
    // (undocumented)
    Reinstated = "Reinstated",
    // (undocumented)
    Started = "Started",
    // (undocumented)
    Subscribed = "Subscribed",
    // (undocumented)
    Succeeded = "Succeeded",
    // (undocumented)
    Suspended = "Suspended",
    // (undocumented)
    Unsubscribed = "Unsubscribed",
    // (undocumented)
    Updating = "Updating"
}

// @public
export enum KnownVersions {
    V20240701 = "2024-07-01"
}

// @public
export interface LinkOrganization {
    token: string;
}

// @public
export interface ListAccessRequestModel {
    searchFilters?: Record<string, string>;
}

// @public
export interface ListRegionsSuccessResponse {
    data?: RegionRecord[];
}

// @public
export interface MarketplaceAgreementsCreateOptionalParams extends OperationOptions {
    body?: ConfluentAgreementResource;
}

// @public
export interface MarketplaceAgreementsListOptionalParams extends OperationOptions {
}

// @public
export interface MarketplaceAgreementsOperations {
    create: (options?: MarketplaceAgreementsCreateOptionalParams) => Promise<ConfluentAgreementResource>;
    list: (options?: MarketplaceAgreementsListOptionalParams) => PagedAsyncIterableIterator<ConfluentAgreementResource>;
}

// @public
export interface MetadataEntity {
    createdAt?: string;
    deletedAt?: string;
    resourceName?: string;
    self?: string;
    updatedAt?: string;
}

// @public
export interface OfferDetail {
    id: string;
    planId: string;
    planName: string;
    privateOfferId?: string;
    privateOfferIds?: string[];
    publisherId: string;
    status?: SaaSOfferStatus;
    termId?: string;
    termUnit: string;
}

// @public
export interface OperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationResult {
    display?: OperationDisplay;
    isDataAction?: boolean;
    name?: string;
}

// @public
export interface OrganizationCreateApiKeyOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationCreateOptionalParams extends OperationOptions {
    body?: OrganizationResource;
    updateIntervalInMs?: number;
}

// @public
export interface OrganizationDeleteClusterAPIKeyOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface OrganizationGetClusterAPIKeyOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationGetClusterByIdOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationGetEnvironmentByIdOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationGetOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationGetSchemaRegistryClusterByIdOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationListBySubscriptionOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationListClustersOptionalParams extends OperationOptions {
    pageSize?: number;
    pageToken?: string;
}

// @public
export interface OrganizationListEnvironmentsOptionalParams extends OperationOptions {
    pageSize?: number;
    pageToken?: string;
}

// @public
export interface OrganizationListRegionsOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationListSchemaRegistryClustersOptionalParams extends OperationOptions {
    pageSize?: number;
    pageToken?: string;
}

// @public
export interface OrganizationOperations {
    create: (resourceGroupName: string, organizationName: string, options?: OrganizationCreateOptionalParams) => PollerLike<OperationState<OrganizationResource>, OrganizationResource>;
    createApiKey: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, body: CreateAPIKeyModel, options?: OrganizationCreateApiKeyOptionalParams) => Promise<APIKeyRecord>;
    delete: (resourceGroupName: string, organizationName: string, options?: OrganizationDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    deleteClusterAPIKey: (resourceGroupName: string, organizationName: string, apiKeyId: string, options?: OrganizationDeleteClusterAPIKeyOptionalParams) => Promise<void>;
    get: (resourceGroupName: string, organizationName: string, options?: OrganizationGetOptionalParams) => Promise<OrganizationResource>;
    getClusterAPIKey: (resourceGroupName: string, organizationName: string, apiKeyId: string, options?: OrganizationGetClusterAPIKeyOptionalParams) => Promise<APIKeyRecord>;
    getClusterById: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, options?: OrganizationGetClusterByIdOptionalParams) => Promise<SCClusterRecord>;
    getEnvironmentById: (resourceGroupName: string, organizationName: string, environmentId: string, options?: OrganizationGetEnvironmentByIdOptionalParams) => Promise<SCEnvironmentRecord>;
    getSchemaRegistryClusterById: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, options?: OrganizationGetSchemaRegistryClusterByIdOptionalParams) => Promise<SchemaRegistryClusterRecord>;
    listByResourceGroup: (resourceGroupName: string, options?: OrganizationListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<OrganizationResource>;
    listBySubscription: (options?: OrganizationListBySubscriptionOptionalParams) => PagedAsyncIterableIterator<OrganizationResource>;
    listClusters: (resourceGroupName: string, organizationName: string, environmentId: string, options?: OrganizationListClustersOptionalParams) => PagedAsyncIterableIterator<SCClusterRecord>;
    listEnvironments: (resourceGroupName: string, organizationName: string, options?: OrganizationListEnvironmentsOptionalParams) => PagedAsyncIterableIterator<SCEnvironmentRecord>;
    listRegions: (resourceGroupName: string, organizationName: string, body: ListAccessRequestModel, options?: OrganizationListRegionsOptionalParams) => Promise<ListRegionsSuccessResponse>;
    listSchemaRegistryClusters: (resourceGroupName: string, organizationName: string, environmentId: string, options?: OrganizationListSchemaRegistryClustersOptionalParams) => PagedAsyncIterableIterator<SchemaRegistryClusterRecord>;
    update: (resourceGroupName: string, organizationName: string, options?: OrganizationUpdateOptionalParams) => Promise<OrganizationResource>;
}

// @public
export interface OrganizationOperationsListOptionalParams extends OperationOptions {
}

// @public
export interface OrganizationOperationsOperations {
    list: (options?: OrganizationOperationsListOptionalParams) => PagedAsyncIterableIterator<OperationResult>;
}

// @public
export interface OrganizationResource extends TrackedResource {
    properties: OrganizationResourceProperties;
}

// @public
export interface OrganizationResourceProperties {
    readonly createdTime?: Date;
    linkOrganization?: LinkOrganization;
    offerDetail: OfferDetail;
    readonly organizationId?: string;
    readonly provisioningState?: ProvisionState;
    readonly ssoUrl?: string;
    userDetail: UserDetail;
}

// @public
export interface OrganizationResourceUpdate {
    tags?: Record<string, string>;
}

// @public
export interface OrganizationUpdateOptionalParams extends OperationOptions {
    body?: OrganizationResourceUpdate;
}

// @public
export type Package = string;

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export type PartnerConnectorType = string;

// @public
export interface PartnerInfoBase {
    partnerConnectorType: PartnerConnectorType;
}

// @public
export type PartnerInfoBaseUnion = KafkaAzureBlobStorageSinkConnectorInfo | KafkaAzureBlobStorageSourceConnectorInfo | KafkaAzureCosmosDBSinkConnectorInfo | KafkaAzureCosmosDBSourceConnectorInfo | KafkaAzureSynapseAnalyticsSinkConnectorInfo | PartnerInfoBase;

// @public
export type ProvisionState = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export interface RegionProperties {
    metadata?: SCMetadataEntity;
    spec?: RegionSpecEntity;
}

// @public
export interface RegionRecord {
    id?: string;
    kind?: string;
    properties?: RegionProperties;
}

// @public
export interface RegionSpecEntity {
    cloud?: string;
    name?: string;
    // (undocumented)
    packages?: string[];
    regionName?: string;
}

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceProviderDefaultErrorResponse {
    readonly error?: ErrorResponseBody;
}

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: ConfluentManagementClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export interface RoleBindingRecord {
    crnPattern?: string;
    id?: string;
    kind?: string;
    metadata?: MetadataEntity;
    principal?: string;
    roleName?: string;
}

// @public
export type SaaSOfferStatus = string;

// @public
export interface SCClusterByokEntity {
    id?: string;
    related?: string;
    resourceName?: string;
}

// @public
export interface SCClusterNetworkEnvironmentEntity {
    environment?: string;
    id?: string;
    related?: string;
    resourceName?: string;
}

// @public
export interface SCClusterRecord extends ProxyResource {
    kind?: string;
    properties?: ClusterProperties;
}

// @public
export interface SCClusterSpecEntity {
    apiEndpoint?: string;
    availability?: string;
    byok?: SCClusterByokEntity;
    cloud?: string;
    config?: ClusterConfigEntity;
    environment?: SCClusterNetworkEnvironmentEntity;
    httpEndpoint?: string;
    kafkaBootstrapEndpoint?: string;
    name?: string;
    network?: SCClusterNetworkEnvironmentEntity;
    package?: Package;
    region?: string;
    zone?: string;
}

// @public
export interface SCEnvironmentRecord extends ProxyResource {
    kind?: string;
    properties?: EnvironmentProperties;
}

// @public
export interface SchemaRegistryClusterEnvironmentRegionEntity {
    id?: string;
    related?: string;
    resourceName?: string;
}

// @public
export interface SchemaRegistryClusterProperties {
    metadata?: SCMetadataEntity;
    spec?: SchemaRegistryClusterSpecEntity;
    status?: SchemaRegistryClusterStatusEntity;
}

// @public
export interface SchemaRegistryClusterRecord {
    id?: string;
    kind?: string;
    properties?: SchemaRegistryClusterProperties;
}

// @public
export interface SchemaRegistryClusterSpecEntity {
    cloud?: string;
    environment?: SchemaRegistryClusterEnvironmentRegionEntity;
    httpEndpoint?: string;
    name?: string;
    package?: string;
    region?: SchemaRegistryClusterEnvironmentRegionEntity;
}

// @public
export interface SchemaRegistryClusterStatusEntity {
    phase?: string;
}

// @public
export interface SCMetadataEntity {
    createdTimestamp?: string;
    deletedTimestamp?: string;
    resourceName?: string;
    self?: string;
    updatedTimestamp?: string;
}

// @public
export interface ServiceAccountRecord {
    description?: string;
    displayName?: string;
    id?: string;
    kind?: string;
    metadata?: MetadataEntity;
}

// @public
export interface StreamGovernanceConfig {
    package?: Package;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TopicMetadataEntity {
    resourceName?: string;
    self?: string;
}

// @public
export interface TopicProperties {
    configs?: TopicsRelatedLink;
    inputConfigs?: TopicsInputConfig[];
    kind?: string;
    metadata?: TopicMetadataEntity;
    partitions?: TopicsRelatedLink;
    partitionsCount?: string;
    partitionsReassignments?: TopicsRelatedLink;
    replicationFactor?: string;
    topicId?: string;
}

// @public
export interface TopicRecord extends ProxyResource {
    properties?: TopicProperties;
}

// @public
export interface TopicsCreateOptionalParams extends OperationOptions {
    body?: TopicRecord;
}

// @public
export interface TopicsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TopicsGetOptionalParams extends OperationOptions {
}

// @public
export interface TopicsInputConfig {
    name?: string;
    value?: string;
}

// @public
export interface TopicsListOptionalParams extends OperationOptions {
    pageSize?: number;
    pageToken?: string;
}

// @public
export interface TopicsOperations {
    create: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, topicName: string, options?: TopicsCreateOptionalParams) => Promise<TopicRecord>;
    delete: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, topicName: string, options?: TopicsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, topicName: string, options?: TopicsGetOptionalParams) => Promise<TopicRecord>;
    list: (resourceGroupName: string, organizationName: string, environmentId: string, clusterId: string, options?: TopicsListOptionalParams) => PagedAsyncIterableIterator<TopicRecord>;
}

// @public
export interface TopicsRelatedLink {
    related?: string;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export interface UserDetail {
    aadEmail?: string;
    emailAddress: string;
    firstName?: string;
    lastName?: string;
    userPrincipalName?: string;
}

// @public
export interface UserRecord {
    authType?: string;
    email?: string;
    fullName?: string;
    id?: string;
    kind?: string;
    metadata?: MetadataEntity;
}

// @public
export interface ValidationResponse {
    info?: Record<string, string>;
}

// @public
export interface ValidationsOperations {
    validateOrganization: (resourceGroupName: string, organizationName: string, body: OrganizationResource, options?: ValidationsValidateOrganizationOptionalParams) => Promise<OrganizationResource>;
    validateOrganizationV2: (resourceGroupName: string, organizationName: string, body: OrganizationResource, options?: ValidationsValidateOrganizationV2OptionalParams) => Promise<ValidationResponse>;
}

// @public
export interface ValidationsValidateOrganizationOptionalParams extends OperationOptions {
}

// @public
export interface ValidationsValidateOrganizationV2OptionalParams extends OperationOptions {
}

// (No @packageDocumentation comment for this package)

```
