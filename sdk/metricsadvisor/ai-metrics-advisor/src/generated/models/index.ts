/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";

export type DataFeedDetailUnion =
  | DataFeedDetail
  | AzureApplicationInsightsDataFeed
  | AzureBlobDataFeed
  | AzureCosmosDBDataFeed
  | AzureDataExplorerDataFeed
  | AzureDataLakeStorageGen2DataFeed
  | AzureTableDataFeed
  | ElasticsearchDataFeed
  | HttpRequestDataFeed
  | InfluxDBDataFeed
  | MySqlDataFeed
  | PostgreSqlDataFeed
  | SQLServerDataFeed
  | MongoDBDataFeed;
export type DataFeedDetailPatchUnion =
  | DataFeedDetailPatch
  | AzureApplicationInsightsDataFeedPatch
  | AzureBlobDataFeedPatch
  | AzureCosmosDBDataFeedPatch
  | AzureDataExplorerDataFeedPatch
  | AzureDataLakeStorageGen2DataFeedPatch
  | AzureTableDataFeedPatch
  | ElasticsearchDataFeedPatch
  | HttpRequestDataFeedPatch
  | InfluxDBDataFeedPatch
  | MySqlDataFeedPatch
  | PostgreSqlDataFeedPatch
  | SQLServerDataFeedPatch
  | MongoDBDataFeedPatch;
export type MetricFeedbackUnion =
  | MetricFeedback
  | AnomalyFeedback
  | ChangePointFeedback
  | CommentFeedback
  | PeriodFeedback;
export type HookInfoUnion = HookInfo | EmailHookInfo | WebhookHookInfo;
export type HookInfoPatchUnion =
  | HookInfoPatch
  | EmailHookInfoPatch
  | WebhookHookInfoPatch;

export interface UsageStats {
  /**
   * The timestamp of the stats
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly timestamp?: Date;
  /**
   * The active series count
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly activeSeriesCount?: number;
  /**
   * All series count under non deleted data feed
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly allSeriesCount?: number;
  /**
   * The metrics count under non deleted data feed
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly metricsCount?: number;
  /**
   * The count of non deleted data feed
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly datafeedCount?: number;
}

export interface ErrorCode {
  message?: string;
  code?: string;
}

export interface AnomalyAlertingConfiguration {
  /**
   * anomaly alerting configuration unique id
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly anomalyAlertingConfigurationId?: string;
  /** anomaly alerting configuration name */
  name: string;
  /** anomaly alerting configuration description */
  description?: string;
  /**
   * cross metrics operator
   *
   * should be specified when setting up multiple metric alerting configurations
   */
  crossMetricsOperator?: AnomalyAlertingConfigurationCrossMetricsOperator;
  /** hook unique ids */
  hookIds: string[];
  /** Anomaly alerting configurations */
  metricAlertingConfigurations: MetricAlertingConfiguration[];
}

export interface MetricAlertingConfiguration {
  /** Anomaly detection configuration unique id */
  anomalyDetectionConfigurationId: string;
  /** Anomaly scope */
  anomalyScopeType: AnomalyScope;
  /** Negation operation */
  negationOperation?: boolean;
  dimensionAnomalyScope?: DimensionGroupIdentity;
  topNAnomalyScope?: TopNGroupScope;
  severityFilter?: SeverityCondition;
  snoozeFilter?: AlertSnoozeCondition;
  valueFilter?: ValueCondition;
}

export interface DimensionGroupIdentity {
  /** dimension specified for series group */
  dimension: { [propertyName: string]: string };
}

export interface TopNGroupScope {
  /** top N, value range : [1, +∞) */
  top: number;
  /** point count used to look back, value range : [1, +∞) */
  period: number;
  /**
   * min count should be in top N, value range : [1, +∞)
   *
   * should be less than or equal to period
   */
  minTopCount: number;
}

export interface SeverityCondition {
  /** min alert severity */
  minAlertSeverity: Severity;
  /** max alert severity */
  maxAlertSeverity: Severity;
}

export interface AlertSnoozeCondition {
  /** snooze point count, value range : [0, +∞) */
  autoSnooze: number;
  /** snooze scope */
  snoozeScope: SnoozeScope;
  /** only snooze for successive anomalies */
  onlyForSuccessive: boolean;
}

export interface ValueCondition {
  /**
   * lower bound
   *
   * should be specified when direction is Both or Down
   */
  lower?: number;
  /**
   * upper bound
   *
   * should be specified when direction is Both or Up
   */
  upper?: number;
  /** value filter direction */
  direction: Direction;
  /** the other metric unique id used for value filter */
  metricId?: string;
  /**
   * trigger alert when the corresponding point is missing in the other metric
   *
   * should be specified only when using other metric to filter
   */
  triggerForMissing?: boolean;
}

export interface AnomalyAlertingConfigurationPatch {
  /** Anomaly alerting configuration name */
  name?: string;
  /** anomaly alerting configuration description */
  description?: string;
  /** cross metrics operator */
  crossMetricsOperator?: AnomalyAlertingConfigurationPatchCrossMetricsOperator;
  /** hook unique ids */
  hookIds?: string[];
  /** Anomaly alerting configurations */
  metricAlertingConfigurations?: MetricAlertingConfiguration[];
}

export interface AlertingResultQuery {
  /** start time */
  startTime: Date;
  /** end time */
  endTime: Date;
  /** time mode */
  timeMode: TimeMode;
}

export interface AlertResultList {
  nextLink: string;
  value: AlertResult[];
}

export interface AlertResult {
  /**
   * alert id
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly alertId?: string;
  /**
   * anomaly time
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly timestamp?: Date;
  /**
   * created time
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly createdTime?: Date;
  /**
   * modified time
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly modifiedTime?: Date;
}

export interface AnomalyResultList {
  nextLink: string;
  value: AnomalyResult[];
}

export interface AnomalyResult {
  /**
   * metric unique id
   *
   * only return for alerting anomaly result
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly metricId?: string;
  /**
   * anomaly detection configuration unique id
   *
   * only return for alerting anomaly result
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly anomalyDetectionConfigurationId?: string;
  /** anomaly time */
  timestamp: Date;
  /**
   * created time
   *
   * only return for alerting result
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly createdTime?: Date;
  /**
   * modified time
   *
   * only return for alerting result
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly modifiedTime?: Date;
  /** dimension specified for series */
  dimension: { [propertyName: string]: string };
  property: AnomalyProperty;
}

export interface AnomalyProperty {
  /** anomaly severity */
  anomalySeverity: Severity;
  /**
   * anomaly status
   *
   * only return for alerting anomaly result
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly anomalyStatus?: AnomalyPropertyAnomalyStatus;
}

export interface IncidentResultList {
  nextLink: string;
  value: IncidentResult[];
}

export interface IncidentResult {
  /**
   * metric unique id
   *
   * only return for alerting incident result
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly metricId?: string;
  /**
   * anomaly detection configuration unique id
   *
   * only return for alerting incident result
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly anomalyDetectionConfigurationId?: string;
  /** incident id */
  incidentId: string;
  /** incident start time */
  startTime: Date;
  /** incident last time */
  lastTime: Date;
  rootNode: SeriesIdentity;
  property: IncidentProperty;
}

export interface SeriesIdentity {
  /** dimension specified for series */
  dimension: { [propertyName: string]: string };
}

export interface IncidentProperty {
  /** max severity of latest anomalies in the incident */
  maxSeverity: Severity;
  /**
   * incident status
   *
   * only return for alerting incident result
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly incidentStatus?: IncidentPropertyIncidentStatus;
}

export interface AnomalyDetectionConfiguration {
  /**
   * anomaly detection configuration unique id
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly anomalyDetectionConfigurationId?: string;
  /** anomaly detection configuration name */
  name: string;
  /** anomaly detection configuration description */
  description?: string;
  /** metric unique id */
  metricId: string;
  wholeMetricConfiguration: WholeMetricConfiguration;
  /** detection configuration for series group */
  dimensionGroupOverrideConfigurations?: DimensionGroupConfiguration[];
  /** detection configuration for specific series */
  seriesOverrideConfigurations?: SeriesConfiguration[];
}

export interface WholeMetricConfiguration {
  /**
   * condition operator
   *
   * should be specified when combining multiple detection conditions
   */
  conditionOperator?: WholeMetricConfigurationConditionOperator;
  smartDetectionCondition?: SmartDetectionCondition;
  hardThresholdCondition?: HardThresholdCondition;
  changeThresholdCondition?: ChangeThresholdCondition;
}

export interface SmartDetectionCondition {
  /** sensitivity, value range : (0, 100] */
  sensitivity: number;
  /** detection direction */
  anomalyDetectorDirection: AnomalyDetectorDirection;
  suppressCondition: SuppressCondition;
}

export interface SuppressCondition {
  /** min point number, value range : [1, +∞) */
  minNumber: number;
  /** min point ratio, value range : (0, 100] */
  minRatio: number;
}

export interface HardThresholdCondition {
  /**
   * lower bound
   *
   * should be specified when anomalyDetectorDirection is Both or Down
   */
  lowerBound?: number;
  /**
   * upper bound
   *
   * should be specified when anomalyDetectorDirection is Both or Up
   */
  upperBound?: number;
  /** detection direction */
  anomalyDetectorDirection: AnomalyDetectorDirection;
  suppressCondition: SuppressCondition;
}

export interface ChangeThresholdCondition {
  /** change percentage, value range : [0, +∞) */
  changePercentage: number;
  /** shift point, value range : [1, +∞) */
  shiftPoint: number;
  /**
   * if the withinRange = true, detected data is abnormal when the value falls in the range, in this case anomalyDetectorDirection must be Both
   * if the withinRange = false, detected data is abnormal when the value falls out of the range
   */
  withinRange: boolean;
  /** detection direction */
  anomalyDetectorDirection: AnomalyDetectorDirection;
  suppressCondition: SuppressCondition;
}

export interface DimensionGroupConfiguration {
  group: DimensionGroupIdentity;
  /**
   * condition operator
   *
   * should be specified when combining multiple detection conditions
   */
  conditionOperator?: DimensionGroupConfigurationConditionOperator;
  smartDetectionCondition?: SmartDetectionCondition;
  hardThresholdCondition?: HardThresholdCondition;
  changeThresholdCondition?: ChangeThresholdCondition;
}

export interface SeriesConfiguration {
  series: SeriesIdentity;
  /**
   * condition operator
   *
   * should be specified when combining multiple detection conditions
   */
  conditionOperator?: SeriesConfigurationConditionOperator;
  smartDetectionCondition?: SmartDetectionCondition;
  hardThresholdCondition?: HardThresholdCondition;
  changeThresholdCondition?: ChangeThresholdCondition;
}

export interface AnomalyDetectionConfigurationPatch {
  /** anomaly detection configuration name */
  name?: string;
  /** anomaly detection configuration description */
  description?: string;
  wholeMetricConfiguration?: WholeMetricConfiguration;
  /** detection configuration for series group */
  dimensionGroupOverrideConfigurations?: DimensionGroupConfiguration[];
  /** detection configuration for specific series */
  seriesOverrideConfigurations?: SeriesConfiguration[];
}

export interface AnomalyAlertingConfigurationList {
  value: AnomalyAlertingConfiguration[];
}

export interface DetectionSeriesQuery {
  /** start time */
  startTime: Date;
  /** end time */
  endTime: Date;
  /** series */
  series: SeriesIdentity[];
}

export interface SeriesResultList {
  value: SeriesResult[];
}

export interface SeriesResult {
  series: SeriesIdentity;
  /** timestamps of the series */
  timestampList: Date[];
  /** values of the series */
  valueList: number[];
  /** whether points of the series are anomalies */
  isAnomalyList: boolean[];
  /** period calculated on each point of the series */
  periodList: number[];
  /** expected values of the series given by smart detector */
  expectedValueList: number[];
  /** lower boundary list of the series given by smart detector */
  lowerBoundaryList: number[];
  /** upper boundary list of the series given by smart detector */
  upperBoundaryList: number[];
}

export interface DetectionAnomalyResultQuery {
  /** start time */
  startTime: Date;
  /** end time */
  endTime: Date;
  filter?: DetectionAnomalyFilterCondition;
}

export interface DetectionAnomalyFilterCondition {
  /** dimension filter */
  dimensionFilter?: DimensionGroupIdentity[];
  severityFilter?: SeverityFilterCondition;
}

export interface SeverityFilterCondition {
  /** min severity */
  min: Severity;
  /** max severity */
  max: Severity;
}

export interface AnomalyDimensionQuery {
  /** start time */
  startTime: Date;
  /** end time */
  endTime: Date;
  /** dimension to query */
  dimensionName: string;
  dimensionFilter?: DimensionGroupIdentity;
}

export interface AnomalyDimensionList {
  nextLink: string;
  value: string[];
}

export interface DetectionIncidentResultQuery {
  /** start time */
  startTime: Date;
  /** end time */
  endTime: Date;
  filter?: DetectionIncidentFilterCondition;
}

export interface DetectionIncidentFilterCondition {
  /** dimension filter */
  dimensionFilter?: DimensionGroupIdentity[];
}

export interface RootCauseList {
  value: RootCause[];
}

export interface RootCause {
  rootCause: DimensionGroupIdentity;
  /** drilling down path from query anomaly to root cause */
  path: string[];
  /** score */
  score: number;
  /** description */
  description: string;
}

export interface DataFeedList {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly value?: DataFeedDetailUnion[];
}

export interface DataFeedDetail {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType:
    | "AzureApplicationInsights"
    | "AzureBlob"
    | "AzureCosmosDB"
    | "AzureDataExplorer"
    | "AzureDataLakeStorageGen2"
    | "AzureTable"
    | "Elasticsearch"
    | "HttpRequest"
    | "InfluxDB"
    | "MySql"
    | "PostgreSql"
    | "SqlServer"
    | "MongoDB";
  /**
   * data feed unique id
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly dataFeedId?: string;
  /** data feed name */
  dataFeedName: string;
  /** data feed description */
  dataFeedDescription?: string;
  /** granularity of the time series */
  granularityName: Granularity;
  /** if granularity is custom,it is required. */
  granularityAmount?: number;
  /** measure list */
  metrics: Metric[];
  /** dimension list */
  dimension?: Dimension[];
  /** user-defined timestamp column. if timestampColumn is null, start time of every time slice will be used as default value. */
  timestampColumn?: string;
  /** ingestion start time */
  dataStartFrom: Date;
  /** the time that the beginning of data ingestion task will delay for every data slice according to this offset. */
  startOffsetInSeconds?: number;
  /** the max concurrency of data ingestion queries against user data source. 0 means no limitation. */
  maxConcurrency?: number;
  /** the min retry interval for failed data ingestion tasks. */
  minRetryIntervalInSeconds?: number;
  /** stop retry data ingestion after the data slice first schedule time in seconds. */
  stopRetryAfterInSeconds?: number;
  /** mark if the data feed need rollup */
  needRollup?: NeedRollupEnum;
  /** roll up method */
  rollUpMethod?: DataFeedDetailRollUpMethod;
  /** roll up columns */
  rollUpColumns?: string[];
  /** the identification value for the row of calculated all-up value. */
  allUpIdentification?: string;
  /** the type of fill missing point for anomaly detection */
  fillMissingPointType?: FillMissingPointType;
  /** the value of fill missing point for anomaly detection */
  fillMissingPointValue?: number;
  /** data feed access mode, default is Private */
  viewMode?: ViewMode;
  /** data feed administrator */
  admins?: string[];
  /** data feed viewer */
  viewers?: string[];
  /**
   * the query user is one of data feed administrator or not
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly isAdmin?: boolean;
  /**
   * data feed creator
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly creator?: string;
  /**
   * data feed status
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly status?: DataFeedDetailStatus;
  /**
   * data feed created time
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly createdTime?: Date;
  /** action link for alert */
  actionLinkTemplate?: string;
}

/** Represents a metric of an ingested data feed */
export interface Metric {
  /**
   * metric id
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** metric name */
  name: string;
  /** metric display name */
  displayName?: string;
  /** metric description */
  description?: string;
}

/** Represents a dimension of an ingested data feed */
export interface Dimension {
  /** dimension name */
  name: string;
  /** dimension display name */
  displayName?: string;
}

export interface DataFeedDetailPatch {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType:
    | "AzureApplicationInsights"
    | "AzureBlob"
    | "AzureCosmosDB"
    | "AzureDataExplorer"
    | "AzureDataLakeStorageGen2"
    | "AzureTable"
    | "Elasticsearch"
    | "HttpRequest"
    | "InfluxDB"
    | "MySql"
    | "PostgreSql"
    | "SqlServer"
    | "MongoDB";
  /** data feed name */
  dataFeedName?: string;
  /** data feed description */
  dataFeedDescription?: string;
  /** user-defined timestamp column. if timestampColumn is null, start time of every time slice will be used as default value. */
  timestampColumn?: string;
  /** ingestion start time */
  dataStartFrom?: Date;
  /** the time that the beginning of data ingestion task will delay for every data slice according to this offset. */
  startOffsetInSeconds?: number;
  /** the max concurrency of data ingestion queries against user data source. 0 means no limitation. */
  maxConcurrency?: number;
  /** the min retry interval for failed data ingestion tasks. */
  minRetryIntervalInSeconds?: number;
  /** stop retry data ingestion after the data slice first schedule time in seconds. */
  stopRetryAfterInSeconds?: number;
  /** mark if the data feed need rollup */
  needRollup?: DataFeedDetailPatchNeedRollup;
  /** roll up method */
  rollUpMethod?: DataFeedDetailPatchRollUpMethod;
  /** roll up columns */
  rollUpColumns?: string[];
  /** the identification value for the row of calculated all-up value. */
  allUpIdentification?: string;
  /** the type of fill missing point for anomaly detection */
  fillMissingPointType?: DataFeedDetailPatchFillMissingPointType;
  /** the value of fill missing point for anomaly detection */
  fillMissingPointValue?: number;
  /** data feed access mode, default is Private */
  viewMode?: DataFeedDetailPatchViewMode;
  /** data feed administrator */
  admins?: string[];
  /** data feed viewer */
  viewers?: string[];
  /** data feed status */
  status?: DataFeedDetailPatchStatus;
  /** action link for alert */
  actionLinkTemplate?: string;
}

export interface MetricFeedback {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  feedbackType: "Anomaly" | "ChangePoint" | "Comment" | "Period";
  /**
   * feedback unique id
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly feedbackId?: string;
  /**
   * feedback created time
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly createdTime?: Date;
  /**
   * user who gives this feedback
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly userPrincipal?: string;
  /** metric unique id */
  metricId: string;
  dimensionFilter: FeedbackDimensionFilter;
}

export interface FeedbackDimensionFilter {
  /** metric dimension filter */
  dimension: { [propertyName: string]: string };
}

export interface MetricFeedbackFilter {
  /** filter feedbacks by metric id */
  metricId: string;
  dimensionFilter?: FeedbackDimensionFilter;
  /** filter feedbacks by type */
  feedbackType?: FeedbackType;
  /** start time filter under chosen time mode */
  startTime?: Date;
  /** end time filter under chosen time mode */
  endTime?: Date;
  /** time mode to filter feedback */
  timeMode?: FeedbackQueryTimeMode;
}

export interface MetricFeedbackList {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly value?: MetricFeedbackUnion[];
}

export interface HookList {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly value?: HookInfoUnion[];
}

export interface HookInfo {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  hookType: "Email" | "Webhook";
  /**
   * Hook unique id
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly id?: string;
  /** hook unique name */
  name: string;
  /** hook description */
  description?: string;
  /** hook external link */
  externalLink?: string;
  /**
   * hook administrators
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly admins?: string[];
}

export interface HookInfoPatch {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  hookType: "Email" | "Webhook";
  /** hook unique name */
  hookName?: string;
  /** hook description */
  description?: string;
  /** hook external link */
  externalLink?: string;
  /**
   * hook administrators
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly admins?: string[];
}

export interface IngestionStatusQueryOptions {
  /** the start point of time range to query data ingestion status. */
  startTime: Date;
  /** the end point of time range to query data ingestion status. */
  endTime: Date;
}

export interface IngestionStatusList {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly value?: IngestionStatus[];
}

export interface IngestionStatus {
  /**
   * data slice timestamp.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly timestamp?: Date;
  /**
   * latest ingestion task status for this data slice.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly status?: IngestionStatusType;
  /**
   * the trimmed message of last ingestion job.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message?: string;
}

export interface IngestionProgressResetOptions {
  /** the start point of time range to reset data ingestion status. */
  startTime: Date;
  /** the end point of time range to reset data ingestion status. */
  endTime: Date;
}

export interface DataFeedIngestionProgress {
  /**
   * the timestamp of lastest success ingestion job.
   * null indicates not available
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly latestSuccessTimestamp?: Date;
  /**
   * the timestamp of lastest ingestion job with status update.
   * null indicates not available
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly latestActiveTimestamp?: Date;
}

export interface MetricDataQueryOptions {
  /** start time of query a time series data, and format should be yyyy-MM-ddThh:mm:ssZ */
  startTime: Date;
  /** start time of query a time series data, and format should be yyyy-MM-ddThh:mm:ssZ */
  endTime: Date;
  /** query specific series */
  series: { [propertyName: string]: string }[];
}

export interface MetricDataList {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly value?: MetricDataItem[];
}

export interface MetricDataItem {
  id?: MetricSeriesItem;
  /**
   * timestamps of the data related to this time series
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly timestampList?: Date[];
  /**
   * values of the data related to this time series
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly valueList?: number[];
}

export interface MetricSeriesItem {
  /**
   * metric unique id
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly metricId?: string;
  /**
   * dimension name and value pair
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly dimension?: { [propertyName: string]: string };
}

export interface MetricSeriesQueryOptions {
  /** query series ingested after this time, the format should be yyyy-MM-ddTHH:mm:ssZ */
  activeSince: Date;
  /** filter specfic dimension name and values */
  dimensionFilter?: { [propertyName: string]: string[] };
}

export interface MetricSeriesList {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly value?: MetricSeriesItem[];
}

export interface MetricDimensionQueryOptions {
  /** dimension name */
  dimensionName: string;
  /** dimension value to be filtered */
  dimensionValueFilter?: string;
}

export interface MetricDimensionList {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly value?: string[];
}

export interface AnomalyDetectionConfigurationList {
  value: AnomalyDetectionConfiguration[];
}

export interface EnrichmentStatusQueryOption {
  /** the start point of time range to query anomaly detection status. */
  startTime: Date;
  /** the end point of time range to query anomaly detection status. */
  endTime: Date;
}

export interface EnrichmentStatusList {
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly nextLink?: string;
  /** NOTE: This property will not be serialized. It can only be populated by the server. */
  readonly value?: EnrichmentStatus[];
}

export interface EnrichmentStatus {
  /**
   * data slice timestamp.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly timestamp?: Date;
  /**
   * latest enrichment status for this data slice.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly status?: string;
  /**
   * the trimmed message describes details of the enrichment status.
   * NOTE: This property will not be serialized. It can only be populated by the server.
   */
  readonly message?: string;
}

export interface AzureApplicationInsightsParameter {
  /** Azure cloud environment */
  azureCloud: string;
  /** Azure Application Insights ID */
  applicationId: string;
  /** API Key */
  apiKey: string;
  /** Query */
  query: string;
}

export interface AzureBlobParameter {
  /** Azure Blob connection string */
  connectionString: string;
  /** Container */
  container: string;
  /** Blob Template */
  blobTemplate: string;
}

export interface AzureCosmosDBParameter {
  /** Azure CosmosDB connection string */
  connectionString: string;
  /** Query script */
  sqlQuery: string;
  /** Database name */
  database: string;
  /** Collection id */
  collectionId: string;
}

export interface SqlSourceParameter {
  /** Database connection string */
  connectionString: string;
  /** Query script */
  query: string;
}

export interface AzureDataLakeStorageGen2Parameter {
  /** Account name */
  accountName: string;
  /** Account key */
  accountKey: string;
  /** File system name (Container) */
  fileSystemName: string;
  /** Directory template */
  directoryTemplate: string;
  /** File template */
  fileTemplate: string;
}

export interface AzureTableParameter {
  /** Azure Table connection string */
  connectionString: string;
  /** Table name */
  table: string;
  /** Query script */
  query: string;
}

export interface ElasticsearchParameter {
  /** Host */
  host: string;
  /** Port */
  port: string;
  /** Authorization header */
  authHeader: string;
  /** Query */
  query: string;
}

export interface HttpRequestParameter {
  /** HTTP URL */
  url: string;
  /** HTTP header */
  httpHeader: string;
  /** HTTP method */
  httpMethod: string;
  /** HTTP reuqest body */
  payload: string;
}

export interface InfluxDBParameter {
  /** InfluxDB connection string */
  connectionString: string;
  /** Database name */
  database: string;
  /** Database access user */
  userName: string;
  /** Database access password */
  password: string;
  /** Query script */
  query: string;
}

export interface MongoDBParameter {
  /** MongoDB connection string */
  connectionString: string;
  /** Database name */
  database: string;
  /** Query script */
  command: string;
}

export interface AnomalyFeedbackValue {
  anomalyValue: AnomalyValue;
}

export interface ChangePointFeedbackValue {
  changePointValue: ChangePointValue;
}

export interface CommentFeedbackValue {
  /** the comment string */
  commentValue: string;
}

export interface PeriodFeedbackValue {
  /** the type of setting period */
  periodType: PeriodType;
  /** the number of intervals a period contains, when no period set to 0 */
  periodValue: number;
}

export interface EmailHookParameter {
  /** Email TO: list. */
  toList: string[];
}

export interface WebhookHookParameter {
  /** API address, will be called when alert is triggered, only support POST method via SSL */
  endpoint: string;
  /** basic authentication */
  username?: string;
  /** basic authentication */
  password?: string;
  /** custom headers in api call */
  headers?: { [propertyName: string]: string };
  /** client certificate */
  certificateKey?: string;
  /** client certificate password */
  certificatePassword?: string;
}

export type AzureApplicationInsightsDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureApplicationInsights";
  dataSourceParameter: AzureApplicationInsightsParameter;
};

export type AzureBlobDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureBlob";
  dataSourceParameter: AzureBlobParameter;
};

export type AzureCosmosDBDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureCosmosDB";
  dataSourceParameter: AzureCosmosDBParameter;
};

export type AzureDataExplorerDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureDataExplorer";
  dataSourceParameter: SqlSourceParameter;
};

export type AzureDataLakeStorageGen2DataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureDataLakeStorageGen2";
  dataSourceParameter: AzureDataLakeStorageGen2Parameter;
};

export type AzureTableDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureTable";
  dataSourceParameter: AzureTableParameter;
};

export type ElasticsearchDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "Elasticsearch";
  dataSourceParameter: ElasticsearchParameter;
};

export type HttpRequestDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "HttpRequest";
  dataSourceParameter: HttpRequestParameter;
};

export type InfluxDBDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "InfluxDB";
  dataSourceParameter: InfluxDBParameter;
};

export type MySqlDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "MySql";
  dataSourceParameter: SqlSourceParameter;
};

export type PostgreSqlDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "PostgreSql";
  dataSourceParameter: SqlSourceParameter;
};

export type SQLServerDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "SqlServer";
  dataSourceParameter: SqlSourceParameter;
};

export type MongoDBDataFeed = DataFeedDetail & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "MongoDB";
  dataSourceParameter: MongoDBParameter;
};

export type AzureApplicationInsightsDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureApplicationInsights";
  dataSourceParameter?: AzureApplicationInsightsParameter;
};

export type AzureBlobDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureBlob";
  dataSourceParameter?: AzureBlobParameter;
};

export type AzureCosmosDBDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureCosmosDB";
  dataSourceParameter?: AzureCosmosDBParameter;
};

export type AzureDataExplorerDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureDataExplorer";
  dataSourceParameter?: SqlSourceParameter;
};

export type AzureDataLakeStorageGen2DataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureDataLakeStorageGen2";
  dataSourceParameter?: AzureDataLakeStorageGen2Parameter;
};

export type AzureTableDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "AzureTable";
  dataSourceParameter?: AzureTableParameter;
};

export type ElasticsearchDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "Elasticsearch";
  dataSourceParameter?: ElasticsearchParameter;
};

export type HttpRequestDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "HttpRequest";
  dataSourceParameter?: HttpRequestParameter;
};

export type InfluxDBDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "InfluxDB";
  dataSourceParameter?: InfluxDBParameter;
};

export type MySqlDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "MySql";
  dataSourceParameter?: SqlSourceParameter;
};

export type PostgreSqlDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "PostgreSql";
  dataSourceParameter?: SqlSourceParameter;
};

export type SQLServerDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "SqlServer";
  dataSourceParameter?: SqlSourceParameter;
};

export type MongoDBDataFeedPatch = DataFeedDetailPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  dataSourceType: "MongoDB";
  dataSourceParameter?: MongoDBParameter;
};

export type AnomalyFeedback = MetricFeedback & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  feedbackType: "Anomaly";
  /** the start timestamp of feedback timerange */
  startTime: Date;
  /** the end timestamp of feedback timerange, when equals to startTime means only one timestamp */
  endTime: Date;
  value: AnomalyFeedbackValue;
  /** the corresponding anomaly detection configuration of this feedback */
  anomalyDetectionConfigurationId?: string;
  anomalyDetectionConfigurationSnapshot?: AnomalyDetectionConfiguration;
};

export type ChangePointFeedback = MetricFeedback & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  feedbackType: "ChangePoint";
  /** the start timestamp of feedback timerange */
  startTime: Date;
  /** the end timestamp of feedback timerange, when equals to startTime means only one timestamp */
  endTime: Date;
  value: ChangePointFeedbackValue;
};

export type CommentFeedback = MetricFeedback & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  feedbackType: "Comment";
  /** the start timestamp of feedback timerange */
  startTime?: Date;
  /** the end timestamp of feedback timerange, when equals to startTime means only one timestamp */
  endTime?: Date;
  value: CommentFeedbackValue;
};

export type PeriodFeedback = MetricFeedback & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  feedbackType: "Period";
  value: PeriodFeedbackValue;
};

export type EmailHookInfo = HookInfo & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  hookType: "Email";
  hookParameter: EmailHookParameter;
};

export type WebhookHookInfo = HookInfo & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  hookType: "Webhook";
  hookParameter: WebhookHookParameter;
};

export type EmailHookInfoPatch = HookInfoPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  hookType: "Email";
  hookParameter?: EmailHookParameter;
};

export type WebhookHookInfoPatch = HookInfoPatch & {
  /** Polymorphic discriminator, which specifies the different types this object can be */
  hookType: "Webhook";
  hookParameter?: WebhookHookParameter;
};

/** Defines headers for GeneratedClient_createAnomalyAlertingConfiguration operation. */
export interface GeneratedClientCreateAnomalyAlertingConfigurationHeaders {
  /** Location of the newly created resource. */
  location?: string;
}

/** Defines headers for GeneratedClient_createAnomalyDetectionConfiguration operation. */
export interface GeneratedClientCreateAnomalyDetectionConfigurationHeaders {
  /** Location of the newly created resource. */
  location?: string;
}

/** Defines headers for GeneratedClient_createDataFeed operation. */
export interface GeneratedClientCreateDataFeedHeaders {
  /** Location of the newly created resource. */
  location?: string;
}

/** Defines headers for GeneratedClient_createMetricFeedback operation. */
export interface GeneratedClientCreateMetricFeedbackHeaders {
  /** Location of the newly created resource. */
  location?: string;
}

/** Defines headers for GeneratedClient_createHook operation. */
export interface GeneratedClientCreateHookHeaders {
  /** Location of the newly created resource. */
  location?: string;
}

/** Known values of {@link AnomalyAlertingConfigurationCrossMetricsOperator} that the service accepts. */
export const enum KnownAnomalyAlertingConfigurationCrossMetricsOperator {
  AND = "AND",
  OR = "OR",
  XOR = "XOR"
}

/**
 * Defines values for AnomalyAlertingConfigurationCrossMetricsOperator. \
 * {@link KnownAnomalyAlertingConfigurationCrossMetricsOperator} can be used interchangeably with AnomalyAlertingConfigurationCrossMetricsOperator,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AND** \
 * **OR** \
 * **XOR**
 */
export type AnomalyAlertingConfigurationCrossMetricsOperator = string;

/** Known values of {@link AnomalyScope} that the service accepts. */
export const enum KnownAnomalyScope {
  All = "All",
  Dimension = "Dimension",
  TopN = "TopN"
}

/**
 * Defines values for AnomalyScope. \
 * {@link KnownAnomalyScope} can be used interchangeably with AnomalyScope,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **All** \
 * **Dimension** \
 * **TopN**
 */
export type AnomalyScope = string;

/** Known values of {@link Severity} that the service accepts. */
export const enum KnownSeverity {
  Low = "Low",
  Medium = "Medium",
  High = "High"
}

/**
 * Defines values for Severity. \
 * {@link KnownSeverity} can be used interchangeably with Severity,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Low** \
 * **Medium** \
 * **High**
 */
export type Severity = string;

/** Known values of {@link SnoozeScope} that the service accepts. */
export const enum KnownSnoozeScope {
  Metric = "Metric",
  Series = "Series"
}

/**
 * Defines values for SnoozeScope. \
 * {@link KnownSnoozeScope} can be used interchangeably with SnoozeScope,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Metric** \
 * **Series**
 */
export type SnoozeScope = string;

/** Known values of {@link Direction} that the service accepts. */
export const enum KnownDirection {
  Both = "Both",
  Down = "Down",
  Up = "Up"
}

/**
 * Defines values for Direction. \
 * {@link KnownDirection} can be used interchangeably with Direction,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Both** \
 * **Down** \
 * **Up**
 */
export type Direction = string;

/** Known values of {@link AnomalyAlertingConfigurationPatchCrossMetricsOperator} that the service accepts. */
export const enum KnownAnomalyAlertingConfigurationPatchCrossMetricsOperator {
  AND = "AND",
  OR = "OR",
  XOR = "XOR"
}

/**
 * Defines values for AnomalyAlertingConfigurationPatchCrossMetricsOperator. \
 * {@link KnownAnomalyAlertingConfigurationPatchCrossMetricsOperator} can be used interchangeably with AnomalyAlertingConfigurationPatchCrossMetricsOperator,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AND** \
 * **OR** \
 * **XOR**
 */
export type AnomalyAlertingConfigurationPatchCrossMetricsOperator = string;

/** Known values of {@link TimeMode} that the service accepts. */
export const enum KnownTimeMode {
  AnomalyTime = "AnomalyTime",
  CreatedTime = "CreatedTime",
  ModifiedTime = "ModifiedTime"
}

/**
 * Defines values for TimeMode. \
 * {@link KnownTimeMode} can be used interchangeably with TimeMode,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AnomalyTime** \
 * **CreatedTime** \
 * **ModifiedTime**
 */
export type TimeMode = string;

/** Known values of {@link AnomalyPropertyAnomalyStatus} that the service accepts. */
export const enum KnownAnomalyPropertyAnomalyStatus {
  Active = "Active",
  Resolved = "Resolved"
}

/**
 * Defines values for AnomalyPropertyAnomalyStatus. \
 * {@link KnownAnomalyPropertyAnomalyStatus} can be used interchangeably with AnomalyPropertyAnomalyStatus,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Active** \
 * **Resolved**
 */
export type AnomalyPropertyAnomalyStatus = string;

/** Known values of {@link IncidentPropertyIncidentStatus} that the service accepts. */
export const enum KnownIncidentPropertyIncidentStatus {
  Active = "Active",
  Resolved = "Resolved"
}

/**
 * Defines values for IncidentPropertyIncidentStatus. \
 * {@link KnownIncidentPropertyIncidentStatus} can be used interchangeably with IncidentPropertyIncidentStatus,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Active** \
 * **Resolved**
 */
export type IncidentPropertyIncidentStatus = string;

/** Known values of {@link WholeMetricConfigurationConditionOperator} that the service accepts. */
export const enum KnownWholeMetricConfigurationConditionOperator {
  AND = "AND",
  OR = "OR"
}

/**
 * Defines values for WholeMetricConfigurationConditionOperator. \
 * {@link KnownWholeMetricConfigurationConditionOperator} can be used interchangeably with WholeMetricConfigurationConditionOperator,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AND** \
 * **OR**
 */
export type WholeMetricConfigurationConditionOperator = string;

/** Known values of {@link AnomalyDetectorDirection} that the service accepts. */
export const enum KnownAnomalyDetectorDirection {
  Both = "Both",
  Down = "Down",
  Up = "Up"
}

/**
 * Defines values for AnomalyDetectorDirection. \
 * {@link KnownAnomalyDetectorDirection} can be used interchangeably with AnomalyDetectorDirection,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Both** \
 * **Down** \
 * **Up**
 */
export type AnomalyDetectorDirection = string;

/** Known values of {@link DimensionGroupConfigurationConditionOperator} that the service accepts. */
export const enum KnownDimensionGroupConfigurationConditionOperator {
  AND = "AND",
  OR = "OR"
}

/**
 * Defines values for DimensionGroupConfigurationConditionOperator. \
 * {@link KnownDimensionGroupConfigurationConditionOperator} can be used interchangeably with DimensionGroupConfigurationConditionOperator,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AND** \
 * **OR**
 */
export type DimensionGroupConfigurationConditionOperator = string;

/** Known values of {@link SeriesConfigurationConditionOperator} that the service accepts. */
export const enum KnownSeriesConfigurationConditionOperator {
  AND = "AND",
  OR = "OR"
}

/**
 * Defines values for SeriesConfigurationConditionOperator. \
 * {@link KnownSeriesConfigurationConditionOperator} can be used interchangeably with SeriesConfigurationConditionOperator,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AND** \
 * **OR**
 */
export type SeriesConfigurationConditionOperator = string;

/** Known values of {@link DataSourceType} that the service accepts. */
export const enum KnownDataSourceType {
  AzureApplicationInsights = "AzureApplicationInsights",
  AzureBlob = "AzureBlob",
  AzureCosmosDB = "AzureCosmosDB",
  AzureDataExplorer = "AzureDataExplorer",
  AzureDataLakeStorageGen2 = "AzureDataLakeStorageGen2",
  AzureTable = "AzureTable",
  Elasticsearch = "Elasticsearch",
  HttpRequest = "HttpRequest",
  InfluxDB = "InfluxDB",
  MongoDB = "MongoDB",
  MySql = "MySql",
  PostgreSql = "PostgreSql",
  SqlServer = "SqlServer"
}

/**
 * Defines values for DataSourceType. \
 * {@link KnownDataSourceType} can be used interchangeably with DataSourceType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AzureApplicationInsights** \
 * **AzureBlob** \
 * **AzureCosmosDB** \
 * **AzureDataExplorer** \
 * **AzureDataLakeStorageGen2** \
 * **AzureTable** \
 * **Elasticsearch** \
 * **HttpRequest** \
 * **InfluxDB** \
 * **MongoDB** \
 * **MySql** \
 * **PostgreSql** \
 * **SqlServer**
 */
export type DataSourceType = string;

/** Known values of {@link Granularity} that the service accepts. */
export const enum KnownGranularity {
  Yearly = "Yearly",
  Monthly = "Monthly",
  Weekly = "Weekly",
  Daily = "Daily",
  Hourly = "Hourly",
  Minutely = "Minutely",
  Secondly = "Secondly",
  Custom = "Custom"
}

/**
 * Defines values for Granularity. \
 * {@link KnownGranularity} can be used interchangeably with Granularity,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Yearly** \
 * **Monthly** \
 * **Weekly** \
 * **Daily** \
 * **Hourly** \
 * **Minutely** \
 * **Secondly** \
 * **Custom**
 */
export type Granularity = string;

/** Known values of {@link EntityStatus} that the service accepts. */
export const enum KnownEntityStatus {
  Active = "Active",
  Paused = "Paused"
}

/**
 * Defines values for EntityStatus. \
 * {@link KnownEntityStatus} can be used interchangeably with EntityStatus,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Active** \
 * **Paused**
 */
export type EntityStatus = string;

/** Known values of {@link NeedRollupEnum} that the service accepts. */
export const enum KnownNeedRollupEnum {
  NoRollup = "NoRollup",
  NeedRollup = "NeedRollup",
  AlreadyRollup = "AlreadyRollup"
}

/**
 * Defines values for NeedRollupEnum. \
 * {@link KnownNeedRollupEnum} can be used interchangeably with NeedRollupEnum,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **NoRollup** \
 * **NeedRollup** \
 * **AlreadyRollup**
 */
export type NeedRollupEnum = string;

/** Known values of {@link DataFeedDetailRollUpMethod} that the service accepts. */
export const enum KnownDataFeedDetailRollUpMethod {
  None = "None",
  Sum = "Sum",
  Max = "Max",
  Min = "Min",
  Avg = "Avg",
  Count = "Count"
}

/**
 * Defines values for DataFeedDetailRollUpMethod. \
 * {@link KnownDataFeedDetailRollUpMethod} can be used interchangeably with DataFeedDetailRollUpMethod,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **None** \
 * **Sum** \
 * **Max** \
 * **Min** \
 * **Avg** \
 * **Count**
 */
export type DataFeedDetailRollUpMethod = string;

/** Known values of {@link FillMissingPointType} that the service accepts. */
export const enum KnownFillMissingPointType {
  SmartFilling = "SmartFilling",
  PreviousValue = "PreviousValue",
  CustomValue = "CustomValue",
  NoFilling = "NoFilling"
}

/**
 * Defines values for FillMissingPointType. \
 * {@link KnownFillMissingPointType} can be used interchangeably with FillMissingPointType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **SmartFilling** \
 * **PreviousValue** \
 * **CustomValue** \
 * **NoFilling**
 */
export type FillMissingPointType = string;

/** Known values of {@link ViewMode} that the service accepts. */
export const enum KnownViewMode {
  Private = "Private",
  Public = "Public"
}

/**
 * Defines values for ViewMode. \
 * {@link KnownViewMode} can be used interchangeably with ViewMode,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Private** \
 * **Public**
 */
export type ViewMode = string;

/** Known values of {@link DataFeedDetailStatus} that the service accepts. */
export const enum KnownDataFeedDetailStatus {
  Active = "Active",
  Paused = "Paused"
}

/**
 * Defines values for DataFeedDetailStatus. \
 * {@link KnownDataFeedDetailStatus} can be used interchangeably with DataFeedDetailStatus,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Active** \
 * **Paused**
 */
export type DataFeedDetailStatus = string;

/** Known values of {@link DataFeedDetailPatchDataSourceType} that the service accepts. */
export const enum KnownDataFeedDetailPatchDataSourceType {
  AzureApplicationInsights = "AzureApplicationInsights",
  AzureBlob = "AzureBlob",
  AzureCosmosDB = "AzureCosmosDB",
  AzureDataExplorer = "AzureDataExplorer",
  AzureDataLakeStorageGen2 = "AzureDataLakeStorageGen2",
  AzureTable = "AzureTable",
  Elasticsearch = "Elasticsearch",
  HttpRequest = "HttpRequest",
  InfluxDB = "InfluxDB",
  MongoDB = "MongoDB",
  MySql = "MySql",
  PostgreSql = "PostgreSql",
  SqlServer = "SqlServer"
}

/**
 * Defines values for DataFeedDetailPatchDataSourceType. \
 * {@link KnownDataFeedDetailPatchDataSourceType} can be used interchangeably with DataFeedDetailPatchDataSourceType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AzureApplicationInsights** \
 * **AzureBlob** \
 * **AzureCosmosDB** \
 * **AzureDataExplorer** \
 * **AzureDataLakeStorageGen2** \
 * **AzureTable** \
 * **Elasticsearch** \
 * **HttpRequest** \
 * **InfluxDB** \
 * **MongoDB** \
 * **MySql** \
 * **PostgreSql** \
 * **SqlServer**
 */
export type DataFeedDetailPatchDataSourceType = string;

/** Known values of {@link DataFeedDetailPatchNeedRollup} that the service accepts. */
export const enum KnownDataFeedDetailPatchNeedRollup {
  NoRollup = "NoRollup",
  NeedRollup = "NeedRollup",
  AlreadyRollup = "AlreadyRollup"
}

/**
 * Defines values for DataFeedDetailPatchNeedRollup. \
 * {@link KnownDataFeedDetailPatchNeedRollup} can be used interchangeably with DataFeedDetailPatchNeedRollup,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **NoRollup** \
 * **NeedRollup** \
 * **AlreadyRollup**
 */
export type DataFeedDetailPatchNeedRollup = string;

/** Known values of {@link DataFeedDetailPatchRollUpMethod} that the service accepts. */
export const enum KnownDataFeedDetailPatchRollUpMethod {
  None = "None",
  Sum = "Sum",
  Max = "Max",
  Min = "Min",
  Avg = "Avg",
  Count = "Count"
}

/**
 * Defines values for DataFeedDetailPatchRollUpMethod. \
 * {@link KnownDataFeedDetailPatchRollUpMethod} can be used interchangeably with DataFeedDetailPatchRollUpMethod,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **None** \
 * **Sum** \
 * **Max** \
 * **Min** \
 * **Avg** \
 * **Count**
 */
export type DataFeedDetailPatchRollUpMethod = string;

/** Known values of {@link DataFeedDetailPatchFillMissingPointType} that the service accepts. */
export const enum KnownDataFeedDetailPatchFillMissingPointType {
  SmartFilling = "SmartFilling",
  PreviousValue = "PreviousValue",
  CustomValue = "CustomValue",
  NoFilling = "NoFilling"
}

/**
 * Defines values for DataFeedDetailPatchFillMissingPointType. \
 * {@link KnownDataFeedDetailPatchFillMissingPointType} can be used interchangeably with DataFeedDetailPatchFillMissingPointType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **SmartFilling** \
 * **PreviousValue** \
 * **CustomValue** \
 * **NoFilling**
 */
export type DataFeedDetailPatchFillMissingPointType = string;

/** Known values of {@link DataFeedDetailPatchViewMode} that the service accepts. */
export const enum KnownDataFeedDetailPatchViewMode {
  Private = "Private",
  Public = "Public"
}

/**
 * Defines values for DataFeedDetailPatchViewMode. \
 * {@link KnownDataFeedDetailPatchViewMode} can be used interchangeably with DataFeedDetailPatchViewMode,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Private** \
 * **Public**
 */
export type DataFeedDetailPatchViewMode = string;

/** Known values of {@link DataFeedDetailPatchStatus} that the service accepts. */
export const enum KnownDataFeedDetailPatchStatus {
  Active = "Active",
  Paused = "Paused"
}

/**
 * Defines values for DataFeedDetailPatchStatus. \
 * {@link KnownDataFeedDetailPatchStatus} can be used interchangeably with DataFeedDetailPatchStatus,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Active** \
 * **Paused**
 */
export type DataFeedDetailPatchStatus = string;

/** Known values of {@link FeedbackType} that the service accepts. */
export const enum KnownFeedbackType {
  Anomaly = "Anomaly",
  ChangePoint = "ChangePoint",
  Period = "Period",
  Comment = "Comment"
}

/**
 * Defines values for FeedbackType. \
 * {@link KnownFeedbackType} can be used interchangeably with FeedbackType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Anomaly** \
 * **ChangePoint** \
 * **Period** \
 * **Comment**
 */
export type FeedbackType = string;

/** Known values of {@link FeedbackQueryTimeMode} that the service accepts. */
export const enum KnownFeedbackQueryTimeMode {
  MetricTimestamp = "MetricTimestamp",
  FeedbackCreatedTime = "FeedbackCreatedTime"
}

/**
 * Defines values for FeedbackQueryTimeMode. \
 * {@link KnownFeedbackQueryTimeMode} can be used interchangeably with FeedbackQueryTimeMode,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **MetricTimestamp** \
 * **FeedbackCreatedTime**
 */
export type FeedbackQueryTimeMode = string;

/** Known values of {@link HookType} that the service accepts. */
export const enum KnownHookType {
  Webhook = "Webhook",
  Email = "Email"
}

/**
 * Defines values for HookType. \
 * {@link KnownHookType} can be used interchangeably with HookType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Webhook** \
 * **Email**
 */
export type HookType = string;

/** Known values of {@link HookInfoPatchHookType} that the service accepts. */
export const enum KnownHookInfoPatchHookType {
  Webhook = "Webhook",
  Email = "Email"
}

/**
 * Defines values for HookInfoPatchHookType. \
 * {@link KnownHookInfoPatchHookType} can be used interchangeably with HookInfoPatchHookType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **Webhook** \
 * **Email**
 */
export type HookInfoPatchHookType = string;

/** Known values of {@link IngestionStatusType} that the service accepts. */
export const enum KnownIngestionStatusType {
  NotStarted = "NotStarted",
  Scheduled = "Scheduled",
  Running = "Running",
  Succeeded = "Succeeded",
  Failed = "Failed",
  NoData = "NoData",
  Error = "Error",
  Paused = "Paused"
}

/**
 * Defines values for IngestionStatusType. \
 * {@link KnownIngestionStatusType} can be used interchangeably with IngestionStatusType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **NotStarted** \
 * **Scheduled** \
 * **Running** \
 * **Succeeded** \
 * **Failed** \
 * **NoData** \
 * **Error** \
 * **Paused**
 */
export type IngestionStatusType = string;

/** Known values of {@link AnomalyValue} that the service accepts. */
export const enum KnownAnomalyValue {
  AutoDetect = "AutoDetect",
  Anomaly = "Anomaly",
  NotAnomaly = "NotAnomaly"
}

/**
 * Defines values for AnomalyValue. \
 * {@link KnownAnomalyValue} can be used interchangeably with AnomalyValue,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AutoDetect** \
 * **Anomaly** \
 * **NotAnomaly**
 */
export type AnomalyValue = string;

/** Known values of {@link ChangePointValue} that the service accepts. */
export const enum KnownChangePointValue {
  AutoDetect = "AutoDetect",
  ChangePoint = "ChangePoint",
  NotChangePoint = "NotChangePoint"
}

/**
 * Defines values for ChangePointValue. \
 * {@link KnownChangePointValue} can be used interchangeably with ChangePointValue,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AutoDetect** \
 * **ChangePoint** \
 * **NotChangePoint**
 */
export type ChangePointValue = string;

/** Known values of {@link PeriodType} that the service accepts. */
export const enum KnownPeriodType {
  AutoDetect = "AutoDetect",
  AssignValue = "AssignValue"
}

/**
 * Defines values for PeriodType. \
 * {@link KnownPeriodType} can be used interchangeably with PeriodType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **AutoDetect** \
 * **AssignValue**
 */
export type PeriodType = string;

/** Contains response data for the getActiveSeriesCount operation. */
export type GeneratedClientGetActiveSeriesCountResponse = UsageStats & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: UsageStats;
  };
};

/** Contains response data for the getAnomalyAlertingConfiguration operation. */
export type GeneratedClientGetAnomalyAlertingConfigurationResponse = AnomalyAlertingConfiguration & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyAlertingConfiguration;
  };
};

/** Contains response data for the createAnomalyAlertingConfiguration operation. */
export type GeneratedClientCreateAnomalyAlertingConfigurationResponse = GeneratedClientCreateAnomalyAlertingConfigurationHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: GeneratedClientCreateAnomalyAlertingConfigurationHeaders;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetAlertsByAnomalyAlertingConfigurationOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getAlertsByAnomalyAlertingConfiguration operation. */
export type GeneratedClientGetAlertsByAnomalyAlertingConfigurationResponse = AlertResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AlertResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetAnomaliesFromAlertByAnomalyAlertingConfigurationOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getAnomaliesFromAlertByAnomalyAlertingConfiguration operation. */
export type GeneratedClientGetAnomaliesFromAlertByAnomalyAlertingConfigurationResponse = AnomalyResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetIncidentsFromAlertByAnomalyAlertingConfigurationOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getIncidentsFromAlertByAnomalyAlertingConfiguration operation. */
export type GeneratedClientGetIncidentsFromAlertByAnomalyAlertingConfigurationResponse = IncidentResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: IncidentResultList;
  };
};

/** Contains response data for the getAnomalyDetectionConfiguration operation. */
export type GeneratedClientGetAnomalyDetectionConfigurationResponse = AnomalyDetectionConfiguration & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyDetectionConfiguration;
  };
};

/** Contains response data for the createAnomalyDetectionConfiguration operation. */
export type GeneratedClientCreateAnomalyDetectionConfigurationResponse = GeneratedClientCreateAnomalyDetectionConfigurationHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: GeneratedClientCreateAnomalyDetectionConfigurationHeaders;
  };
};

/** Contains response data for the getAnomalyAlertingConfigurationsByAnomalyDetectionConfiguration operation. */
export type GeneratedClientGetAnomalyAlertingConfigurationsByAnomalyDetectionConfigurationResponse = AnomalyAlertingConfigurationList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyAlertingConfigurationList;
  };
};

/** Contains response data for the getSeriesByAnomalyDetectionConfiguration operation. */
export type GeneratedClientGetSeriesByAnomalyDetectionConfigurationResponse = SeriesResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: SeriesResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetAnomaliesByAnomalyDetectionConfigurationOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getAnomaliesByAnomalyDetectionConfiguration operation. */
export type GeneratedClientGetAnomaliesByAnomalyDetectionConfigurationResponse = AnomalyResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetDimensionOfAnomaliesByAnomalyDetectionConfigurationOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getDimensionOfAnomaliesByAnomalyDetectionConfiguration operation. */
export type GeneratedClientGetDimensionOfAnomaliesByAnomalyDetectionConfigurationResponse = AnomalyDimensionList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyDimensionList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetIncidentsByAnomalyDetectionConfigurationOptionalParams
  extends coreHttp.OperationOptions {
  top?: number;
}

/** Contains response data for the getIncidentsByAnomalyDetectionConfiguration operation. */
export type GeneratedClientGetIncidentsByAnomalyDetectionConfigurationResponse = IncidentResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: IncidentResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetIncidentsByAnomalyDetectionConfigurationNextPagesOptionalParams
  extends coreHttp.OperationOptions {
  top?: number;
  token?: string;
}

/** Contains response data for the getIncidentsByAnomalyDetectionConfigurationNextPages operation. */
export type GeneratedClientGetIncidentsByAnomalyDetectionConfigurationNextPagesResponse = IncidentResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: IncidentResultList;
  };
};

/** Contains response data for the getRootCauseOfIncidentByAnomalyDetectionConfiguration operation. */
export type GeneratedClientGetRootCauseOfIncidentByAnomalyDetectionConfigurationResponse = RootCauseList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RootCauseList;
  };
};

/** Optional parameters. */
export interface GeneratedClientListDataFeedsOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
  /** filter data feed by its name */
  dataFeedName?: string;
  /** filter data feed by its source type */
  dataSourceType?: DataSourceType;
  /** filter data feed by its granularity */
  granularityName?: Granularity;
  /** filter data feed by its status */
  status?: EntityStatus;
  /** filter data feed by its creator */
  creator?: string;
}

/** Contains response data for the listDataFeeds operation. */
export type GeneratedClientListDataFeedsResponse = DataFeedList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: DataFeedList;
  };
};

/** Contains response data for the createDataFeed operation. */
export type GeneratedClientCreateDataFeedResponse = GeneratedClientCreateDataFeedHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: GeneratedClientCreateDataFeedHeaders;
  };
};

/** Contains response data for the getDataFeedById operation. */
export type GeneratedClientGetDataFeedByIdResponse = DataFeedDetailUnion & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: DataFeedDetailUnion;
  };
};

/** Contains response data for the getMetricFeedback operation. */
export type GeneratedClientGetMetricFeedbackResponse = MetricFeedbackUnion & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: MetricFeedbackUnion;
  };
};

/** Optional parameters. */
export interface GeneratedClientListMetricFeedbacksOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the listMetricFeedbacks operation. */
export type GeneratedClientListMetricFeedbacksResponse = MetricFeedbackList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: MetricFeedbackList;
  };
};

/** Contains response data for the createMetricFeedback operation. */
export type GeneratedClientCreateMetricFeedbackResponse = GeneratedClientCreateMetricFeedbackHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: GeneratedClientCreateMetricFeedbackHeaders;
  };
};

/** Optional parameters. */
export interface GeneratedClientListHooksOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
  /** filter hook by its name */
  hookName?: string;
}

/** Contains response data for the listHooks operation. */
export type GeneratedClientListHooksResponse = HookList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: HookList;
  };
};

/** Contains response data for the createHook operation. */
export type GeneratedClientCreateHookResponse = GeneratedClientCreateHookHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: GeneratedClientCreateHookHeaders;
  };
};

/** Contains response data for the getHook operation. */
export type GeneratedClientGetHookResponse = HookInfoUnion & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: HookInfoUnion;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetDataFeedIngestionStatusOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getDataFeedIngestionStatus operation. */
export type GeneratedClientGetDataFeedIngestionStatusResponse = IngestionStatusList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: IngestionStatusList;
  };
};

/** Contains response data for the getIngestionProgress operation. */
export type GeneratedClientGetIngestionProgressResponse = DataFeedIngestionProgress & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: DataFeedIngestionProgress;
  };
};

/** Contains response data for the getMetricData operation. */
export type GeneratedClientGetMetricDataResponse = MetricDataList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: MetricDataList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetMetricSeriesOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getMetricSeries operation. */
export type GeneratedClientGetMetricSeriesResponse = MetricSeriesList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: MetricSeriesList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetMetricDimensionOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getMetricDimension operation. */
export type GeneratedClientGetMetricDimensionResponse = MetricDimensionList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: MetricDimensionList;
  };
};

/** Contains response data for the getAnomalyDetectionConfigurationsByMetric operation. */
export type GeneratedClientGetAnomalyDetectionConfigurationsByMetricResponse = AnomalyDetectionConfigurationList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyDetectionConfigurationList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetEnrichmentStatusByMetricOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getEnrichmentStatusByMetric operation. */
export type GeneratedClientGetEnrichmentStatusByMetricResponse = EnrichmentStatusList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: EnrichmentStatusList;
  };
};

/** Contains response data for the getAlertsByAnomalyAlertingConfigurationNext operation. */
export type GeneratedClientGetAlertsByAnomalyAlertingConfigurationNextResponse = AlertResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AlertResultList;
  };
};

/** Contains response data for the getAnomaliesByAnomalyDetectionConfigurationNext operation. */
export type GeneratedClientGetAnomaliesByAnomalyDetectionConfigurationNextResponse = AnomalyResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyResultList;
  };
};

/** Contains response data for the getDimensionOfAnomaliesByAnomalyDetectionConfigurationNext operation. */
export type GeneratedClientGetDimensionOfAnomaliesByAnomalyDetectionConfigurationNextResponse = AnomalyDimensionList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyDimensionList;
  };
};

/** Contains response data for the listMetricFeedbacksNext operation. */
export type GeneratedClientListMetricFeedbacksNextResponse = MetricFeedbackList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: MetricFeedbackList;
  };
};

/** Contains response data for the getDataFeedIngestionStatusNext operation. */
export type GeneratedClientGetDataFeedIngestionStatusNextResponse = IngestionStatusList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: IngestionStatusList;
  };
};

/** Contains response data for the getMetricSeriesNext operation. */
export type GeneratedClientGetMetricSeriesNextResponse = MetricSeriesList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: MetricSeriesList;
  };
};

/** Contains response data for the getMetricDimensionNext operation. */
export type GeneratedClientGetMetricDimensionNextResponse = MetricDimensionList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: MetricDimensionList;
  };
};

/** Contains response data for the getEnrichmentStatusByMetricNext operation. */
export type GeneratedClientGetEnrichmentStatusByMetricNextResponse = EnrichmentStatusList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: EnrichmentStatusList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetAnomaliesFromAlertByAnomalyAlertingConfigurationNextOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getAnomaliesFromAlertByAnomalyAlertingConfigurationNext operation. */
export type GeneratedClientGetAnomaliesFromAlertByAnomalyAlertingConfigurationNextResponse = AnomalyResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AnomalyResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetIncidentsFromAlertByAnomalyAlertingConfigurationNextOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
}

/** Contains response data for the getIncidentsFromAlertByAnomalyAlertingConfigurationNext operation. */
export type GeneratedClientGetIncidentsFromAlertByAnomalyAlertingConfigurationNextResponse = IncidentResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: IncidentResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetIncidentsByAnomalyDetectionConfigurationNextOptionalParams
  extends coreHttp.OperationOptions {
  top?: number;
}

/** Contains response data for the getIncidentsByAnomalyDetectionConfigurationNext operation. */
export type GeneratedClientGetIncidentsByAnomalyDetectionConfigurationNextResponse = IncidentResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: IncidentResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientGetIncidentsByAnomalyDetectionConfigurationNextPagesNextOptionalParams
  extends coreHttp.OperationOptions {
  top?: number;
  token?: string;
}

/** Contains response data for the getIncidentsByAnomalyDetectionConfigurationNextPagesNext operation. */
export type GeneratedClientGetIncidentsByAnomalyDetectionConfigurationNextPagesNextResponse = IncidentResultList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: IncidentResultList;
  };
};

/** Optional parameters. */
export interface GeneratedClientListDataFeedsNextOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
  /** filter data feed by its name */
  dataFeedName?: string;
  /** filter data feed by its source type */
  dataSourceType?: DataSourceType;
  /** filter data feed by its granularity */
  granularityName?: Granularity;
  /** filter data feed by its status */
  status?: EntityStatus;
  /** filter data feed by its creator */
  creator?: string;
}

/** Contains response data for the listDataFeedsNext operation. */
export type GeneratedClientListDataFeedsNextResponse = DataFeedList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: DataFeedList;
  };
};

/** Optional parameters. */
export interface GeneratedClientListHooksNextOptionalParams
  extends coreHttp.OperationOptions {
  skip?: number;
  top?: number;
  /** filter hook by its name */
  hookName?: string;
}

/** Contains response data for the listHooksNext operation. */
export type GeneratedClientListHooksNextResponse = HookList & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: HookList;
  };
};

/** Optional parameters. */
export interface GeneratedClientOptionalParams
  extends coreHttp.ServiceClientOptions {
  /** Overrides client endpoint. */
  endpoint?: string;
}
