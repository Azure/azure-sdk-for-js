## API Report File for "@azure/ai-metrics-advisor"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreHttp from '@azure/core-http';
import { OperationOptions } from '@azure/core-http';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';
import { RestResponse } from '@azure/core-http';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AlertConfigurationsPageResponse extends Array<AnomalyAlertConfiguration> {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type AlertQueryTimeMode = "AnomalyTime" | "CreatedTime" | "ModifiedTime";

// @public (undocumented)
export interface AlertSnoozeCondition {
    autoSnooze: number;
    onlyForSuccessive: boolean;
    snoozeScope: SnoozeScope;
}

// @public
export interface AlertsPageResponse extends Array<AnomalyAlert> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export interface AnomaliesPageResponse extends Array<DataPointAnomaly> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export interface AnomalyAlert {
    alertConfigId: string;
    createdOn?: Date;
    id: string;
    modifiedOn?: Date;
    timestamp?: number;
}

// @public
export interface AnomalyAlertConfiguration {
    crossMetricsOperator?: MetricAnomalyAlertConfigurationsOperator;
    description?: string;
    hookIds: string[];
    id: string;
    metricAlertConfigurations: MetricAlertConfiguration[];
    name: string;
    splitAlertByDimensions?: string[];
}

// @public
export interface AnomalyDetectionConfiguration {
    description?: string;
    id: string;
    metricId: string;
    name: string;
    seriesDetectionConditions?: MetricSingleSeriesDetectionCondition[];
    seriesGroupDetectionConditions?: MetricSeriesGroupDetectionCondition[];
    wholeSeriesDetectionCondition: MetricDetectionCondition;
}

// @public
export type AnomalyDetectorDirection = "Both" | "Down" | "Up";

// @public
export interface AnomalyIncident {
    readonly dataFeedId?: string;
    detectionConfigurationId: string;
    readonly expectedValueOfRootNode?: number;
    id: string;
    lastOccurredTime: Date;
    metricId?: string;
    rootDimensionKey: DimensionKey;
    severity: AnomalySeverity;
    startTime?: Date;
    status?: AnomalyStatus;
    readonly valueOfRootNode?: number;
}

// @public
export type AnomalySeverity = "Low" | "Medium" | "High";

// @public
export type AnomalyStatus = "Active" | "Resolved";

// @public
export type AnomalyValue = "AutoDetect" | "Anomaly" | "NotAnomaly";

// @public
export type AzureApplicationInsightsDataFeedSource = {
    dataSourceType: "AzureApplicationInsights";
    dataSourceParameter: AzureApplicationInsightsParameter;
};

// @public (undocumented)
export interface AzureApplicationInsightsParameter {
    apiKey: string;
    applicationId: string;
    azureCloud: string;
    query: string;
}

// @public
export type AzureBlobDataFeedSource = {
    dataSourceType: "AzureBlob";
    dataSourceParameter: AzureBlobParameter;
};

// @public (undocumented)
export interface AzureBlobParameter {
    blobTemplate: string;
    connectionString: string;
    container: string;
}

// @public
export type AzureCosmosDBDataFeedSource = {
    dataSourceType: "AzureCosmosDB";
    dataSourceParameter: AzureCosmosDBParameter;
};

// @public (undocumented)
export interface AzureCosmosDBParameter {
    collectionId: string;
    connectionString: string;
    database: string;
    sqlQuery: string;
}

// @public
export type AzureDataExplorerDataFeedSource = {
    dataSourceType: "AzureDataExplorer";
    dataSourceParameter: SqlSourceParameter;
};

// @public
export type AzureDataLakeStorageGen2DataFeedSource = {
    dataSourceType: "AzureDataLakeStorageGen2";
    dataSourceParameter: AzureDataLakeStorageGen2Parameter;
};

// @public (undocumented)
export interface AzureDataLakeStorageGen2Parameter {
    accountKey?: string;
    accountName: string;
    directoryTemplate: string;
    fileSystemName: string;
    fileTemplate: string;
}

// @public
export type AzureTableDataFeedSource = {
    dataSourceType: "AzureTable";
    dataSourceParameter: AzureTableParameter;
};

// @public (undocumented)
export interface AzureTableParameter {
    connectionString: string;
    query: string;
    table: string;
}

// @public
export type ChangeThresholdConditionUnion = {
    changePercentage: number;
    shiftPoint: number;
    withinRange: true;
    anomalyDetectorDirection: "Both";
    suppressCondition: SuppressCondition;
} | {
    changePercentage: number;
    shiftPoint: number;
    withinRange: false;
    anomalyDetectorDirection: "Up" | "Down" | "Both";
    suppressCondition: SuppressCondition;
};

// @public
export type CreateDataFeedOptions = DataFeedOptions & OperationOptions;

// @public
export type DataFeed = {
    id: string;
    name: string;
    createdOn: Date;
    status: DataFeedStatus;
    isAdmin: boolean;
    creator: string;
    source: DataFeedSource;
    schema: DataFeedSchema;
    metricIds: Map<string, string>;
    granularity: DataFeedGranularity;
    ingestionSettings: DataFeedIngestionSettings;
} & DataFeedOptions;

// @public
export type DataFeedAccessMode = "Private" | "Public";

// @public
export type DataFeedDescriptor = Omit<DataFeed, "id" | "metricIds" | "isAdmin" | "status" | "creator" | "createdOn">;

// @public
export type DataFeedDetailStatus = "Active" | "Paused";

// @public
export interface DataFeedDimension {
    displayName?: string;
    name: string;
}

// @public
export type DataFeedGranularity = {
    granularityType: "Yearly" | "Monthly" | "Weekly" | "Daily" | "Hourly" | "PerMinute" | "PerSecond";
} | {
    granularityType: "Custom";
    customGranularityValue: number;
};

// @public (undocumented)
export interface DataFeedIngestionProgress {
    readonly latestActiveTimestamp?: Date;
    readonly latestSuccessTimestamp?: Date;
}

// @public
export interface DataFeedIngestionSettings {
    dataSourceRequestConcurrency?: number;
    ingestionRetryDelayInSeconds?: number;
    ingestionStartOffsetInSeconds?: number;
    ingestionStartTime: Date;
    stopRetryAfterInSeconds?: number;
}

// @public
export interface DataFeedMetric {
    description?: string;
    displayName?: string;
    readonly id?: string;
    name: string;
}

// @public
export type DataFeedMissingDataPointFillSettings = {
    fillType: "SmartFilling" | "PreviousValue" | "NoFilling";
} | {
    fillType: "CustomValue";
    customFillValue: number;
};

// @public
export interface DataFeedOptions {
    accessMode?: DataFeedAccessMode;
    actionLinkTemplate?: string;
    adminEmails?: string[];
    description?: string;
    missingDataPointFillSettings?: DataFeedMissingDataPointFillSettings;
    rollupSettings?: DataFeedRollupSettings;
    viewerEmails?: string[];
}

// @public
export type DataFeedPatch = {
    name?: string;
    source: DataFeedSourcePatch;
    schema?: {
        timestampColumn?: string;
    };
    ingestionSettings?: DataFeedIngestionSettings;
} & DataFeedOptions & {
    status?: DataFeedDetailStatus;
};

// @public
export type DataFeedRollupMethod = "None" | "Sum" | "Max" | "Min" | "Avg" | "Count";

// @public
export type DataFeedRollupSettings = {
    rollupType: "NoRollup";
} | {
    rollupType: "AlreadyRollup";
    rollupIdentificationValue?: string;
} | {
    rollupType: "AutoRollup";
    autoRollupGroupByColumnNames?: string[];
    rollupMethod?: DataFeedRollupMethod;
    rollupIdentificationValue?: string;
};

// @public
export interface DataFeedSchema {
    dimensions?: DataFeedDimension[];
    metrics: DataFeedMetric[];
    timestampColumn?: string;
}

// @public
export type DataFeedSource = AzureApplicationInsightsDataFeedSource | AzureBlobDataFeedSource | AzureCosmosDBDataFeedSource | AzureDataExplorerDataFeedSource | AzureDataLakeStorageGen2DataFeedSource | AzureTableDataFeedSource | ElasticsearchDataFeedSource | HttpRequestDataFeedSource | InfluxDBDataFeedSource | MySqlDataFeedSource | PostgreSqlDataFeedSource | SQLServerDataFeedSource | MongoDBDataFeedSource | UnknownDataFeedSource;

// @public
export type DataFeedSourcePatch = Omit<DataFeedSource, "dataSourceParameter"> & {
    [P in "dataSourceParameter"]?: DataFeedSource[P];
};

// @public
export interface DataFeedsPageResponse extends Array<DataFeed> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public (undocumented)
export type DataFeedStatus = "Paused" | "Active";

// @public
export interface DataPointAnomaly {
    createdOn?: Date;
    readonly dataFeedId?: string;
    detectionConfigurationId: string;
    readonly expectedValue?: number;
    metricId?: string;
    modifiedOn?: Date;
    seriesKey: DimensionKey;
    severity: AnomalySeverity;
    status?: AnomalyStatus;
    timestamp: number;
    readonly value?: number;
}

// @public
export type DataSourceType = "AzureApplicationInsights" | "AzureBlob" | "AzureCosmosDB" | "AzureDataExplorer" | "AzureDataLakeStorageGen2" | "AzureEventHubs" | "AzureTable" | "Elasticsearch" | "HttpRequest" | "InfluxDB" | "MongoDB" | "MySql" | "PostgreSql" | "SqlServer";

// @public
export interface DetectionConditionsCommon {
    changeThresholdCondition?: ChangeThresholdConditionUnion;
    conditionOperator?: DetectionConditionsOperator;
    hardThresholdCondition?: HardThresholdConditionUnion;
    smartDetectionCondition?: SmartDetectionCondition;
}

// @public
export type DetectionConditionsOperator = "AND" | "OR";

// @public
export interface DetectionConfigurationsPageResponse extends Array<AnomalyDetectionConfiguration> {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type DimensionKey = Record<string, string>;

// @public
export interface DimensionValuesPageResponse extends Array<string> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type ElasticsearchDataFeedSource = {
    dataSourceType: "Elasticsearch";
    dataSourceParameter: ElasticsearchParameter;
};

// @public (undocumented)
export interface ElasticsearchParameter {
    authHeader: string;
    host: string;
    port: string;
    query: string;
}

// @public (undocumented)
export interface EmailHookParameter {
    toList: string[];
}

// @public
export type EmailNotificationHook = {
    hookType: "Email";
    hookParameter: EmailHookParameter;
} & NotificationHook;

// @public
export type EmailNotificationHookPatch = {
    hookType: "Email";
    hookParameter?: EmailHookParameter;
} & NotificationHookPatch;

// @public (undocumented)
export interface EnrichmentStatus {
    readonly message?: string;
    readonly status?: string;
    readonly timestamp?: number;
}

// @public
export type FeedbackQueryTimeMode = "MetricTimestamp" | "FeedbackCreatedTime";

// @public
export type FeedbackType = "Anomaly" | "ChangePoint" | "Period" | "Comment";

// @public
export type GetAnomalyAlertConfigurationResponse = AnomalyAlertConfiguration & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
};

// @public
export type GetAnomalyDetectionConfigurationResponse = AnomalyDetectionConfiguration & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
};

// @public
export type GetDataFeedResponse = DataFeed & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
};

// @public
export type GetFeedbackResponse = MetricFeedbackUnion & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
};

// @public
export type GetHookResponse = NotificationHookUnion & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
};

// @public
export type GetIncidentRootCauseResponse = {
    rootCauses: IncidentRootCause[];
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
};

// @public
export type GetIngestionProgressResponse = {
    readonly latestSuccessTimestamp?: number;
    readonly latestActiveTimestamp?: number;
} & {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
};

// @public
export type GetMetricEnrichedSeriesDataOptions = OperationOptions;

// @public
export interface GetMetricEnrichedSeriesDataResponse extends Array<MetricEnrichedSeriesData> {
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type GetMetricSeriesDataOptions = OperationOptions;

// @public
export interface GetMetricSeriesDataResponse extends Array<MetricSeriesData> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type HardThresholdConditionUnion = {
    lowerBound: number;
    anomalyDetectorDirection: "Down";
    suppressCondition: SuppressCondition;
} | {
    upperBound: number;
    anomalyDetectorDirection: "Up";
    suppressCondition: SuppressCondition;
} | {
    lowerBound: number;
    upperBound: number;
    anomalyDetectorDirection: "Both";
    suppressCondition: SuppressCondition;
};

// @public
export interface HooksPageResponse extends Array<NotificationHookUnion> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type HttpRequestDataFeedSource = {
    dataSourceType: "HttpRequest";
    dataSourceParameter: HttpRequestParameter;
};

// @public (undocumented)
export interface HttpRequestParameter {
    httpHeader: string;
    httpMethod: string;
    payload: string;
    url: string;
}

// @public
export interface IncidentRootCause {
    description: string;
    path: string[];
    score: number;
    seriesKey: DimensionKey;
}

// @public
export interface IncidentsPageResponse extends Array<AnomalyIncident> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type InfluxDBDataFeedSource = {
    dataSourceType: "InfluxDB";
    dataSourceParameter: InfluxDBParameter;
};

// @public (undocumented)
export interface InfluxDBParameter {
    connectionString: string;
    database: string;
    password: string;
    query: string;
    userName: string;
}

// @public (undocumented)
export interface IngestionStatus {
    readonly message?: string;
    readonly status?: IngestionStatusType;
    readonly timestamp?: number;
}

// @public
export interface IngestionStatusPageResponse extends Array<IngestionStatus> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type IngestionStatusType = "NotStarted" | "Scheduled" | "Running" | "Succeeded" | "Failed" | "NoData" | "Error" | "Paused";

// @public
export type ListAlertsOptions = {
    skip?: number;
} & OperationOptions;

// @public
export type ListAnomaliesForAlertConfigurationOptions = {
    skip?: number;
} & OperationOptions;

// @public
export type ListAnomaliesForDetectionConfigurationOptions = {
    skip?: number;
    dimensionFilter?: DimensionKey[];
    severityFilter?: SeverityFilterCondition;
} & OperationOptions;

// @public
export type ListAnomalyDimensionValuesOptions = {
    skip?: number;
    dimensionFilter?: DimensionKey;
} & OperationOptions;

// @public
export type ListDataFeedIngestionStatusOptions = {
    skip?: number;
} & OperationOptions;

// @public
export type ListDataFeedsOptions = {
    skip?: number;
    filter?: {
        dataFeedName?: string;
        dataSourceType?: DataSourceType;
        granularity?: DataFeedGranularity;
        status?: DataFeedStatus;
        creator?: string;
    };
} & OperationOptions;

// @public
export type ListFeedbackOptions = {
    skip?: number;
    filter?: {
        dimensionFilter?: DimensionKey;
        feedbackType?: FeedbackType;
        startTime?: Date | string;
        endTime?: Date | string;
        timeMode?: FeedbackQueryTimeMode;
    };
} & OperationOptions;

// @public
export type ListHooksOptions = {
    skip?: number;
    hookName?: string;
} & OperationOptions;

// @public
export type ListIncidentsForAlertOptions = {
    skip?: number;
} & OperationOptions;

// @public
export type ListIncidentsForDetectionConfigurationOptions = {
    dimensionFilter?: DimensionKey[];
} & OperationOptions;

// @public
export type ListMetricDimensionValuesOptions = {
    skip?: number;
    dimensionValueFilter?: string;
} & OperationOptions;

// @public
export type ListMetricEnrichmentStatusOptions = {
    skip?: number;
} & OperationOptions;

// @public
export type ListMetricSeriesDefinitionsOptions = {
    skip?: number;
    dimensionFilter?: Record<string, string[]>;
} & OperationOptions;

// @public (undocumented)
export interface MetricAlertConditions {
    metricBoundaryCondition?: MetricBoundaryCondition;
    severityCondition?: SeverityCondition;
}

// @public (undocumented)
export interface MetricAlertConfiguration {
    alertConditions?: MetricAlertConditions;
    alertScope: MetricAnomalyAlertScope;
    detectionConfigurationId: string;
    negationOperation?: boolean;
    snoozeCondition?: AlertSnoozeCondition;
}

// @public
export type MetricAnomalyAlertConfigurationsOperator = "AND" | "OR" | "XOR";

// @public
export type MetricAnomalyAlertScope = {
    scopeType: "All";
} | {
    scopeType: "Dimension";
    dimensionAnomalyScope: DimensionKey;
} | {
    scopeType: "TopN";
    topNAnomalyScope: TopNGroupScope;
};

// @public
export type MetricAnomalyFeedback = {
    feedbackType: "Anomaly";
    startTime: Date;
    endTime: Date;
    value: "AutoDetect" | "Anomaly" | "NotAnomaly";
    readonly anomalyDetectionConfigurationId?: string;
    readonly anomalyDetectionConfigurationSnapshot?: AnomalyDetectionConfiguration;
} & MetricFeedbackCommon;

// @public
export type MetricBoundaryCondition = {
    direction: "Down";
    lower: number;
    metricId?: string;
    triggerForMissing?: boolean;
    type?: "Value" | "Mean";
} | {
    direction: "Up";
    upper: number;
    metricId?: string;
    triggerForMissing?: boolean;
    type?: "Value" | "Mean";
} | {
    lower: number;
    upper: number;
    direction: "Both";
    metricId?: string;
    triggerForMissing?: boolean;
    type?: "Value" | "Mean";
};

// @public
export type MetricChangePointFeedback = {
    feedbackType: "ChangePoint";
    startTime: Date;
    value: "AutoDetect" | "ChangePoint" | "NotChangePoint";
} & MetricFeedbackCommon;

// @public
export type MetricCommentFeedback = {
    feedbackType: "Comment";
    startTime?: Date;
    endTime?: Date;
    comment: string;
} & MetricFeedbackCommon;

// @public
export type MetricDetectionCondition = DetectionConditionsCommon;

// @public
export interface MetricEnrichedSeriesData {
    expectedValues?: number[];
    isAnomaly?: boolean[];
    lowerBounds?: number[];
    periods?: number[];
    series: DimensionKey;
    timestamps?: Date[];
    upperBounds?: number[];
    values?: number[];
}

// @public
export interface MetricEnrichmentStatusPageResponse extends Array<EnrichmentStatus> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export interface MetricFeedbackCommon {
    readonly createdOn?: Date;
    dimensionKey: DimensionKey;
    readonly id?: string;
    metricId: string;
    readonly userPrincipal?: string;
}

// @public
export interface MetricFeedbackPageResponse extends Array<MetricFeedbackUnion> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type MetricFeedbackUnion = MetricAnomalyFeedback | MetricChangePointFeedback | MetricCommentFeedback | MetricPeriodFeedback;

// @public
export type MetricPeriodFeedback = {
    feedbackType: "Period";
    periodType: "AutoDetect" | "AssignValue";
    periodValue: number;
} & MetricFeedbackCommon;

// @public
export class MetricsAdvisorAdministrationClient {
    constructor(endpointUrl: string, credential: TokenCredential | MetricsAdvisorKeyCredential, options?: MetricsAdvisorAdministrationClientOptions);
    createAlertConfig(config: Omit<AnomalyAlertConfiguration, "id">, options?: OperationOptions): Promise<GetAnomalyAlertConfigurationResponse>;
    createDataFeed(feed: DataFeedDescriptor, operationOptions?: OperationOptions): Promise<GetDataFeedResponse>;
    createDetectionConfig(config: Omit<AnomalyDetectionConfiguration, "id">, options?: OperationOptions): Promise<GetAnomalyDetectionConfigurationResponse>;
    createHook(hookInfo: EmailNotificationHook | WebNotificationHook, options?: OperationOptions): Promise<GetHookResponse>;
    deleteAlertConfig(id: string, options?: OperationOptions): Promise<RestResponse>;
    deleteDataFeed(id: string, options?: OperationOptions): Promise<RestResponse>;
    deleteDetectionConfig(id: string, options?: OperationOptions): Promise<RestResponse>;
    deleteHook(id: string, options?: OperationOptions): Promise<RestResponse>;
    readonly endpointUrl: string;
    getAlertConfig(id: string, options?: OperationOptions): Promise<GetAnomalyAlertConfigurationResponse>;
    getDataFeed(id: string, options?: OperationOptions): Promise<GetDataFeedResponse>;
    getDataFeedIngestionProgress(dataFeedId: string, options?: {}): Promise<GetIngestionProgressResponse>;
    getDetectionConfig(id: string, options?: OperationOptions): Promise<GetAnomalyDetectionConfigurationResponse>;
    getHook(id: string, options?: OperationOptions): Promise<GetHookResponse>;
    listAlertConfigs(detectionConfigId: string, options?: OperationOptions): PagedAsyncIterableIterator<AnomalyAlertConfiguration, AlertConfigurationsPageResponse, undefined>;
    listDataFeedIngestionStatus(dataFeedId: string, startTime: Date | string, endTime: Date | string, options?: ListDataFeedIngestionStatusOptions): PagedAsyncIterableIterator<IngestionStatus, IngestionStatusPageResponse>;
    listDataFeeds(options?: ListDataFeedsOptions): PagedAsyncIterableIterator<DataFeed, DataFeedsPageResponse>;
    listDetectionConfigs(metricId: string, options?: OperationOptions): PagedAsyncIterableIterator<AnomalyDetectionConfiguration, DetectionConfigurationsPageResponse, undefined>;
    listHooks(options?: ListHooksOptions): PagedAsyncIterableIterator<NotificationHookUnion, HooksPageResponse>;
    refreshDataFeedIngestion(dataFeedId: string, startTime: Date | string, endTime: Date | string, options?: OperationOptions): Promise<RestResponse>;
    updateAlertConfig(id: string, patch: Partial<Omit<AnomalyAlertConfiguration, "id">>, options?: OperationOptions): Promise<RestResponse>;
    updateDataFeed(dataFeedId: string, patch: DataFeedPatch, options?: OperationOptions): Promise<RestResponse>;
    updateDetectionConfig(id: string, patch: Partial<Omit<AnomalyDetectionConfiguration, "id" | "metricId">>, options?: OperationOptions): Promise<RestResponse>;
    updateHook(id: string, patch: EmailNotificationHookPatch | WebNotificationHookPatch, options?: OperationOptions): Promise<RestResponse>;
}

// @public
export interface MetricsAdvisorAdministrationClientOptions extends PipelineOptions {
}

// @public
export class MetricsAdvisorClient {
    constructor(endpointUrl: string, credential: TokenCredential | MetricsAdvisorKeyCredential, options?: MetricsAdvisorClientOptions);
    createFeedback(feedback: MetricFeedbackUnion, options?: OperationOptions): Promise<GetFeedbackResponse>;
    readonly endpointUrl: string;
    getFeedback(id: string, options?: OperationOptions): Promise<GetFeedbackResponse>;
    getIncidentRootCauses(detectionConfigId: string, incidentId: string, options?: OperationOptions): Promise<GetIncidentRootCauseResponse>;
    getMetricEnrichedSeriesData(detectionConfigId: string, startTime: Date | string, endTime: Date | string, seriesToFilter: DimensionKey[], options?: GetMetricEnrichedSeriesDataOptions): Promise<GetMetricEnrichedSeriesDataResponse>;
    getMetricSeriesData(metricId: string, startTime: Date | string, endTime: Date | string, seriesToFilter: DimensionKey[], options?: GetMetricSeriesDataOptions): Promise<GetMetricSeriesDataResponse>;
    listAlerts(alertConfigId: string, startTime: Date | string, endTime: Date | string, timeMode: AlertQueryTimeMode, options?: ListAlertsOptions): PagedAsyncIterableIterator<AnomalyAlert, AlertsPageResponse>;
    listAnomalies(alert: AnomalyAlert, options?: ListAnomaliesForAlertConfigurationOptions): PagedAsyncIterableIterator<DataPointAnomaly, AnomaliesPageResponse>;
    listAnomalies(detectionConfigId: string, startTime: Date | string, endTime: Date | string, options?: ListAnomaliesForDetectionConfigurationOptions): PagedAsyncIterableIterator<DataPointAnomaly, AnomaliesPageResponse>;
    listAnomalyDimensionValues(detectionConfigId: string, startTime: Date | string, endTime: Date | string, dimensionName: string, options?: ListAnomalyDimensionValuesOptions): PagedAsyncIterableIterator<string, DimensionValuesPageResponse>;
    listFeedback(metricId: string, options?: ListFeedbackOptions): PagedAsyncIterableIterator<MetricFeedbackUnion, MetricFeedbackPageResponse>;
    listIncidents(alert: AnomalyAlert, options?: ListIncidentsForAlertOptions): PagedAsyncIterableIterator<AnomalyIncident, IncidentsPageResponse>;
    listIncidents(detectionConfigId: string, startTime: Date | string, endTime: Date | string, options?: ListIncidentsForDetectionConfigurationOptions): PagedAsyncIterableIterator<AnomalyIncident, IncidentsPageResponse>;
    listMetricDimensionValues(metricId: string, dimensionName: string, options?: ListMetricDimensionValuesOptions): PagedAsyncIterableIterator<string, DimensionValuesPageResponse>;
    listMetricEnrichmentStatus(metricId: string, startTime: Date | string, endTime: Date | string, options?: ListMetricEnrichmentStatusOptions): PagedAsyncIterableIterator<EnrichmentStatus, MetricEnrichmentStatusPageResponse>;
    listMetricSeriesDefinitions(metricId: string, activeSince: Date | string, options?: ListMetricSeriesDefinitionsOptions): PagedAsyncIterableIterator<MetricSeriesDefinition, MetricSeriesPageResponse>;
    }

// @public
export interface MetricsAdvisorClientOptions extends PipelineOptions {
}

// @public
export class MetricsAdvisorKeyCredential {
    constructor(subscriptionKey: string, apiKey: string);
    get apiKey(): string;
    get subscriptionKey(): string;
    updateApiKey(apiKey: string): void;
    updateSubscriptionKey(subscriptionKey: string): void;
}

// @public
export interface MetricSeriesData {
    definition: MetricSeriesDefinition;
    timestamps?: Date[];
    values?: number[];
}

// @public
export interface MetricSeriesDefinition {
    dimension: Record<string, string>;
    metricId: string;
}

// @public
export type MetricSeriesGroupDetectionCondition = DetectionConditionsCommon & {
    group: DimensionKey;
};

// @public
export interface MetricSeriesPageResponse extends Array<MetricSeriesDefinition> {
    continuationToken?: string;
    _response: coreHttp.HttpResponse & {
        bodyAsText: string;
        parsedBody: any;
    };
}

// @public
export type MetricSingleSeriesDetectionCondition = DetectionConditionsCommon & {
    series: DimensionKey;
};

// @public
export type MongoDBDataFeedSource = {
    dataSourceType: "MongoDB";
    dataSourceParameter: MongoDBParameter;
};

// @public (undocumented)
export interface MongoDBParameter {
    command: string;
    connectionString: string;
    database: string;
}

// @public
export type MySqlDataFeedSource = {
    dataSourceType: "MySql";
    dataSourceParameter: SqlSourceParameter;
};

// @public
export interface NotificationHook {
    readonly adminEmails?: string[];
    description?: string;
    externalLink?: string;
    readonly id?: string;
    name: string;
}

// @public
export type NotificationHookPatch = {
    hookName?: string;
    description?: string;
    externalLink?: string;
};

// @public
export type NotificationHookUnion = EmailNotificationHook | WebNotificationHook;

// @public
export type PostgreSqlDataFeedSource = {
    dataSourceType: "PostgreSql";
    dataSourceParameter: SqlSourceParameter;
};

// @public
export type Severity = "Low" | "Medium" | "High";

// @public (undocumented)
export interface SeverityCondition {
    maxAlertSeverity: Severity;
    minAlertSeverity: Severity;
}

// @public (undocumented)
export interface SeverityFilterCondition {
    max: Severity;
    min: Severity;
}

// @public (undocumented)
export interface SmartDetectionCondition {
    anomalyDetectorDirection: AnomalyDetectorDirection;
    sensitivity: number;
    // (undocumented)
    suppressCondition: SuppressCondition;
}

// @public
export type SnoozeScope = "Metric" | "Series";

// @public
export type SQLServerDataFeedSource = {
    dataSourceType: "SqlServer";
    dataSourceParameter: SqlSourceParameter;
};

// @public (undocumented)
export interface SqlSourceParameter {
    connectionString?: string;
    query: string;
}

// @public (undocumented)
export interface SuppressCondition {
    minNumber: number;
    minRatio: number;
}

// @public (undocumented)
export interface TopNGroupScope {
    minTopCount: number;
    period: number;
    top: number;
}

// @public
export type UnknownDataFeedSource = {
    dataSourceType: "Unknown";
    dataSourceParameter: unknown;
};

// @public (undocumented)
export interface WebhookHookParameter {
    certificateKey?: string;
    certificatePassword?: string;
    endpoint: string;
    headers?: {
        [propertyName: string]: string;
    };
    password?: string;
    username?: string;
}

// @public
export type WebNotificationHook = {
    hookType: "Webhook";
    hookParameter: WebhookHookParameter;
} & NotificationHook;

// @public
export type WebNotificationHookPatch = {
    hookType: "Webhook";
    hookParameter?: WebhookHookParameter;
} & NotificationHookPatch;


// (No @packageDocumentation comment for this package)

```
