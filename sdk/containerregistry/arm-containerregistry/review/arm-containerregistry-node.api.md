## API Report File for "@azure/arm-containerregistry"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import type { ClientOptions } from '@azure-rest/core-client';
import type { OperationOptions } from '@azure-rest/core-client';
import type { OperationState } from '@azure/core-lro';
import type { PathUncheckedResponse } from '@azure-rest/core-client';
import type { Pipeline } from '@azure/core-rest-pipeline';
import type { PollerLike } from '@azure/core-lro';
import type { TokenCredential } from '@azure/core-auth';

// @public
export type Action = string;

// @public
export type ActionsRequired = string;

// @public
export interface ActivationProperties {
    readonly status?: ActivationStatus;
}

// @public
export type ActivationStatus = string;

// @public
export interface Actor {
    name?: string;
}

// @public
export interface Archive extends ProxyResource {
    properties?: ArchiveProperties;
}

// @public
export interface ArchivePackageSourceProperties {
    type?: PackageSourceType;
    url?: string;
}

// @public
export interface ArchiveProperties {
    packageSource?: ArchivePackageSourceProperties;
    readonly provisioningState?: ProvisioningState;
    publishedVersion?: string;
    // (undocumented)
    readonly repositoryEndpoint?: string;
    // (undocumented)
    repositoryEndpointPrefix?: string;
}

// @public
export interface ArchivesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ArchivesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ArchivesGetOptionalParams extends OperationOptions {
}

// @public
export interface ArchivesListOptionalParams extends OperationOptions {
}

// @public
export interface ArchivesOperations {
    create: (resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveCreateParameters: Archive, options?: ArchivesCreateOptionalParams) => PollerLike<OperationState<Archive>, Archive>;
    delete: (resourceGroupName: string, registryName: string, packageType: string, archiveName: string, options?: ArchivesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, packageType: string, archiveName: string, options?: ArchivesGetOptionalParams) => Promise<Archive>;
    list: (resourceGroupName: string, registryName: string, packageType: string, options?: ArchivesListOptionalParams) => PagedAsyncIterableIterator<Archive>;
    update: (resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveUpdateParameters: ArchiveUpdateParameters, options?: ArchivesUpdateOptionalParams) => Promise<Archive>;
}

// @public
export interface ArchivesUpdateOptionalParams extends OperationOptions {
}

// @public
export interface ArchiveUpdateParameters {
    properties?: ArchiveUpdateProperties;
}

// @public
export interface ArchiveUpdateProperties {
    publishedVersion?: string;
}

// @public
export interface ArchiveVersion extends ProxyResource {
    properties?: ArchiveVersionProperties;
}

// @public
export interface ArchiveVersionProperties {
    archiveVersionErrorMessage?: string;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface ArchiveVersionsCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ArchiveVersionsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ArchiveVersionsGetOptionalParams extends OperationOptions {
}

// @public
export interface ArchiveVersionsListOptionalParams extends OperationOptions {
}

// @public
export interface ArchiveVersionsOperations {
    create: (resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveVersionName: string, options?: ArchiveVersionsCreateOptionalParams) => PollerLike<OperationState<ArchiveVersion>, ArchiveVersion>;
    delete: (resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveVersionName: string, options?: ArchiveVersionsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveVersionName: string, options?: ArchiveVersionsGetOptionalParams) => Promise<ArchiveVersion>;
    list: (resourceGroupName: string, registryName: string, packageType: string, archiveName: string, options?: ArchiveVersionsListOptionalParams) => PagedAsyncIterableIterator<ArchiveVersion>;
}

// @public
export type AuditLogStatus = string;

// @public
export interface AuthCredential {
    readonly credentialHealth?: CredentialHealth;
    name?: CredentialName;
    passwordSecretIdentifier?: string;
    usernameSecretIdentifier?: string;
}

// @public
export type AutoGeneratedDomainNameLabelScope = string;

// @public
export interface AzureADAuthenticationAsArmPolicy {
    status?: AzureADAuthenticationAsArmPolicyStatus;
}

// @public
export type AzureADAuthenticationAsArmPolicyStatus = string;

// @public
export enum AzureClouds {
    AZURE_CHINA_CLOUD = "AZURE_CHINA_CLOUD",
    AZURE_PUBLIC_CLOUD = "AZURE_PUBLIC_CLOUD",
    AZURE_US_GOVERNMENT = "AZURE_US_GOVERNMENT"
}

// @public
export type AzureSupportedClouds = `${AzureClouds}`;

// @public
export interface CacheRule extends ProxyResource {
    properties?: CacheRuleProperties;
}

// @public
export interface CacheRuleProperties {
    readonly creationDate?: Date;
    credentialSetResourceId?: string;
    readonly provisioningState?: ProvisioningState;
    sourceRepository?: string;
    targetRepository?: string;
}

// @public
export interface CacheRulesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CacheRulesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CacheRulesGetOptionalParams extends OperationOptions {
}

// @public
export interface CacheRulesListOptionalParams extends OperationOptions {
}

// @public
export interface CacheRulesOperations {
    create: (resourceGroupName: string, registryName: string, cacheRuleName: string, cacheRuleCreateParameters: CacheRule, options?: CacheRulesCreateOptionalParams) => PollerLike<OperationState<CacheRule>, CacheRule>;
    delete: (resourceGroupName: string, registryName: string, cacheRuleName: string, options?: CacheRulesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, cacheRuleName: string, options?: CacheRulesGetOptionalParams) => Promise<CacheRule>;
    list: (resourceGroupName: string, registryName: string, options?: CacheRulesListOptionalParams) => PagedAsyncIterableIterator<CacheRule>;
    update: (resourceGroupName: string, registryName: string, cacheRuleName: string, cacheRuleUpdateParameters: CacheRuleUpdateParameters, options?: CacheRulesUpdateOptionalParams) => PollerLike<OperationState<CacheRule>, CacheRule>;
}

// @public
export interface CacheRulesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CacheRuleUpdateParameters {
    properties?: CacheRuleUpdateProperties;
}

// @public
export interface CacheRuleUpdateProperties {
    credentialSetResourceId?: string;
}

// @public
export interface CallbackConfig {
    customHeaders?: Record<string, string>;
    serviceUri: string;
}

// @public
export type CertificateType = string;

// @public
export interface ConnectedRegistriesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ConnectedRegistriesDeactivateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ConnectedRegistriesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ConnectedRegistriesGetOptionalParams extends OperationOptions {
}

// @public
export interface ConnectedRegistriesListOptionalParams extends OperationOptions {
    filter?: string;
}

// @public
export interface ConnectedRegistriesOperations {
    create: (resourceGroupName: string, registryName: string, connectedRegistryName: string, connectedRegistryCreateParameters: ConnectedRegistry, options?: ConnectedRegistriesCreateOptionalParams) => PollerLike<OperationState<ConnectedRegistry>, ConnectedRegistry>;
    deactivate: (resourceGroupName: string, registryName: string, connectedRegistryName: string, options?: ConnectedRegistriesDeactivateOptionalParams) => PollerLike<OperationState<void>, void>;
    delete: (resourceGroupName: string, registryName: string, connectedRegistryName: string, options?: ConnectedRegistriesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, connectedRegistryName: string, options?: ConnectedRegistriesGetOptionalParams) => Promise<ConnectedRegistry>;
    list: (resourceGroupName: string, registryName: string, options?: ConnectedRegistriesListOptionalParams) => PagedAsyncIterableIterator<ConnectedRegistry>;
    update: (resourceGroupName: string, registryName: string, connectedRegistryName: string, connectedRegistryUpdateParameters: ConnectedRegistryUpdateParameters, options?: ConnectedRegistriesUpdateOptionalParams) => PollerLike<OperationState<ConnectedRegistry>, ConnectedRegistry>;
}

// @public
export interface ConnectedRegistriesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ConnectedRegistry extends ProxyResource {
    properties?: ConnectedRegistryProperties;
}

// @public
export type ConnectedRegistryMode = string;

// @public
export interface ConnectedRegistryProperties {
    readonly activation?: ActivationProperties;
    clientTokenIds?: string[];
    readonly connectionState?: ConnectionState;
    garbageCollection?: GarbageCollectionProperties;
    readonly lastActivityTime?: Date;
    logging?: LoggingProperties;
    loginServer?: LoginServerProperties;
    mode: ConnectedRegistryMode;
    notificationsList?: string[];
    parent: ParentProperties;
    readonly provisioningState?: ProvisioningState;
    readonly statusDetails?: StatusDetailProperties[];
    readonly version?: string;
}

// @public
export interface ConnectedRegistryUpdateParameters {
    properties?: ConnectedRegistryUpdateProperties;
}

// @public
export interface ConnectedRegistryUpdateProperties {
    clientTokenIds?: string[];
    garbageCollection?: GarbageCollectionProperties;
    logging?: LoggingProperties;
    notificationsList?: string[];
    syncProperties?: SyncUpdateProperties;
}

// @public
export type ConnectionState = string;

// @public
export type ConnectionStatus = string;

// @public (undocumented)
export class ContainerRegistryManagementClient {
    constructor(credential: TokenCredential, subscriptionId: string, options?: ContainerRegistryManagementClientOptionalParams);
    readonly archives: ArchivesOperations;
    readonly archiveVersions: ArchiveVersionsOperations;
    readonly cacheRules: CacheRulesOperations;
    readonly connectedRegistries: ConnectedRegistriesOperations;
    readonly credentialSets: CredentialSetsOperations;
    readonly exportPipelines: ExportPipelinesOperations;
    readonly importPipelines: ImportPipelinesOperations;
    readonly operations: OperationsOperations;
    readonly pipeline: Pipeline;
    readonly pipelineRuns: PipelineRunsOperations;
    readonly privateEndpointConnections: PrivateEndpointConnectionsOperations;
    readonly registries: RegistriesOperations;
    readonly replications: ReplicationsOperations;
    readonly scopeMaps: ScopeMapsOperations;
    readonly tokens: TokensOperations;
    readonly webhooks: WebhooksOperations;
}

// @public
export interface ContainerRegistryManagementClientOptionalParams extends ClientOptions {
    apiVersion?: string;
    cloudSetting?: AzureSupportedClouds;
}

// @public
export type ContainerRegistryResourceType = "Microsoft.ContainerRegistry/registries";

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export type CreatedByType = string;

// @public
export interface CredentialHealth {
    errorCode?: string;
    errorMessage?: string;
    status?: CredentialHealthStatus;
}

// @public
export type CredentialHealthStatus = string;

// @public
export type CredentialName = string;

// @public
export interface CredentialSet extends ProxyResource {
    identity?: IdentityProperties;
    properties?: CredentialSetProperties;
}

// @public
export interface CredentialSetProperties {
    authCredentials?: AuthCredential[];
    readonly creationDate?: Date;
    loginServer?: string;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface CredentialSetsCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CredentialSetsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CredentialSetsGetOptionalParams extends OperationOptions {
}

// @public
export interface CredentialSetsListOptionalParams extends OperationOptions {
}

// @public
export interface CredentialSetsOperations {
    create: (resourceGroupName: string, registryName: string, credentialSetName: string, credentialSetCreateParameters: CredentialSet, options?: CredentialSetsCreateOptionalParams) => PollerLike<OperationState<CredentialSet>, CredentialSet>;
    delete: (resourceGroupName: string, registryName: string, credentialSetName: string, options?: CredentialSetsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, credentialSetName: string, options?: CredentialSetsGetOptionalParams) => Promise<CredentialSet>;
    list: (resourceGroupName: string, registryName: string, options?: CredentialSetsListOptionalParams) => PagedAsyncIterableIterator<CredentialSet>;
    update: (resourceGroupName: string, registryName: string, credentialSetName: string, credentialSetUpdateParameters: CredentialSetUpdateParameters, options?: CredentialSetsUpdateOptionalParams) => PollerLike<OperationState<CredentialSet>, CredentialSet>;
}

// @public
export interface CredentialSetsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface CredentialSetUpdateParameters {
    identity?: IdentityProperties;
    properties?: CredentialSetUpdateProperties;
}

// @public
export interface CredentialSetUpdateProperties {
    authCredentials?: AuthCredential[];
}

// @public
export type DefaultAction = string;

// @public
export interface EncryptionProperty {
    keyVaultProperties?: KeyVaultProperties;
    status?: EncryptionStatus;
}

// @public
export type EncryptionStatus = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: any;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
interface Event_2 extends EventInfo {
    eventRequestMessage?: EventRequestMessage;
    eventResponseMessage?: EventResponseMessage;
}
export { Event_2 as Event }

// @public
export interface EventContent {
    action?: string;
    actor?: Actor;
    id?: string;
    request?: Request_2;
    source?: Source;
    target?: Target;
    timestamp?: Date;
}

// @public
export interface EventInfo {
    id?: string;
}

// @public
export interface EventRequestMessage {
    content?: EventContent;
    headers?: Record<string, string>;
    method?: string;
    requestUri?: string;
    version?: string;
}

// @public
export interface EventResponseMessage {
    content?: string;
    headers?: Record<string, string>;
    reasonPhrase?: string;
    statusCode?: string;
    version?: string;
}

// @public
export interface ExportPipeline extends ProxyResource {
    identity?: IdentityProperties;
    location?: string;
    properties?: ExportPipelineProperties;
}

// @public
export interface ExportPipelineProperties {
    options?: PipelineOptions[];
    readonly provisioningState?: ProvisioningState;
    target: ExportPipelineTargetProperties;
}

// @public
export interface ExportPipelinesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ExportPipelinesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ExportPipelinesGetOptionalParams extends OperationOptions {
}

// @public
export interface ExportPipelinesListOptionalParams extends OperationOptions {
}

// @public
export interface ExportPipelinesOperations {
    create: (resourceGroupName: string, registryName: string, exportPipelineName: string, exportPipelineCreateParameters: ExportPipeline, options?: ExportPipelinesCreateOptionalParams) => PollerLike<OperationState<ExportPipeline>, ExportPipeline>;
    delete: (resourceGroupName: string, registryName: string, exportPipelineName: string, options?: ExportPipelinesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, exportPipelineName: string, options?: ExportPipelinesGetOptionalParams) => Promise<ExportPipeline>;
    list: (resourceGroupName: string, registryName: string, options?: ExportPipelinesListOptionalParams) => PagedAsyncIterableIterator<ExportPipeline>;
}

// @public
export interface ExportPipelineTargetProperties {
    keyVaultUri?: string;
    storageAccessMode?: StorageAccessMode;
    type?: string;
    uri?: string;
}

// @public
export interface ExportPolicy {
    status?: ExportPolicyStatus;
}

// @public
export type ExportPolicyStatus = string;

// @public
export interface GarbageCollectionProperties {
    enabled?: boolean;
    schedule?: string;
}

// @public
export interface GenerateCredentialsParameters {
    expiry?: Date;
    name?: TokenPasswordName;
    tokenId?: string;
}

// @public
export interface GenerateCredentialsResult {
    passwords?: TokenPassword[];
    username?: string;
}

// @public
export interface IdentityProperties {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ResourceIdentityType;
    userAssignedIdentities?: Record<string, UserIdentityProperties>;
}

// @public
export interface ImportImageParameters {
    mode?: ImportMode;
    source: ImportSource;
    targetTags?: string[];
    untaggedTargetRepositories?: string[];
}

// @public
export type ImportMode = string;

// @public
export interface ImportPipeline extends ProxyResource {
    identity?: IdentityProperties;
    location?: string;
    properties?: ImportPipelineProperties;
}

// @public
export interface ImportPipelineProperties {
    options?: PipelineOptions[];
    readonly provisioningState?: ProvisioningState;
    source: ImportPipelineSourceProperties;
    trigger?: PipelineTriggerProperties;
}

// @public
export interface ImportPipelinesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ImportPipelinesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ImportPipelinesGetOptionalParams extends OperationOptions {
}

// @public
export interface ImportPipelinesListOptionalParams extends OperationOptions {
}

// @public
export interface ImportPipelinesOperations {
    create: (resourceGroupName: string, registryName: string, importPipelineName: string, importPipelineCreateParameters: ImportPipeline, options?: ImportPipelinesCreateOptionalParams) => PollerLike<OperationState<ImportPipeline>, ImportPipeline>;
    delete: (resourceGroupName: string, registryName: string, importPipelineName: string, options?: ImportPipelinesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, importPipelineName: string, options?: ImportPipelinesGetOptionalParams) => Promise<ImportPipeline>;
    list: (resourceGroupName: string, registryName: string, options?: ImportPipelinesListOptionalParams) => PagedAsyncIterableIterator<ImportPipeline>;
}

// @public
export interface ImportPipelineSourceProperties {
    keyVaultUri?: string;
    storageAccessMode?: StorageAccessMode;
    type?: PipelineSourceType;
    uri?: string;
}

// @public
export interface ImportSource {
    credentials?: ImportSourceCredentials;
    registryUri?: string;
    resourceId?: string;
    sourceImage: string;
}

// @public
export interface ImportSourceCredentials {
    password: string;
    username?: string;
}

// @public
export interface IPRule {
    action?: Action;
    ipAddressOrRange: string;
}

// @public
export interface KeyVaultProperties {
    identity?: string;
    keyIdentifier?: string;
    readonly keyRotationEnabled?: boolean;
    readonly lastKeyRotationTimestamp?: Date;
    readonly versionedKeyIdentifier?: string;
}

// @public
export enum KnownAction {
    Allow = "Allow"
}

// @public
export enum KnownActionsRequired {
    None = "None",
    Recreate = "Recreate"
}

// @public
export enum KnownActivationStatus {
    Active = "Active",
    Inactive = "Inactive"
}

// @public
export enum KnownAuditLogStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownAutoGeneratedDomainNameLabelScope {
    NoReuse = "NoReuse",
    ResourceGroupReuse = "ResourceGroupReuse",
    SubscriptionReuse = "SubscriptionReuse",
    TenantReuse = "TenantReuse",
    Unsecure = "Unsecure"
}

// @public
export enum KnownAzureADAuthenticationAsArmPolicyStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownCertificateType {
    LocalDirectory = "LocalDirectory"
}

// @public
export enum KnownConnectedRegistryMode {
    Mirror = "Mirror",
    ReadOnly = "ReadOnly",
    ReadWrite = "ReadWrite",
    Registry = "Registry"
}

// @public
export enum KnownConnectionState {
    Offline = "Offline",
    Online = "Online",
    Syncing = "Syncing",
    Unhealthy = "Unhealthy"
}

// @public
export enum KnownConnectionStatus {
    Approved = "Approved",
    Disconnected = "Disconnected",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownCredentialHealthStatus {
    Healthy = "Healthy",
    Unhealthy = "Unhealthy"
}

// @public
export enum KnownCredentialName {
    Credential1 = "Credential1"
}

// @public
export enum KnownDefaultAction {
    Allow = "Allow",
    Deny = "Deny"
}

// @public
export enum KnownEncryptionStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownExportPolicyStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownImportMode {
    Force = "Force",
    NoForce = "NoForce"
}

// @public
export enum KnownLogLevel {
    Debug = "Debug",
    Error = "Error",
    Information = "Information",
    None = "None",
    Warning = "Warning"
}

// @public
export enum KnownMetadataSearch {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownNetworkRuleBypassOptions {
    AzureServices = "AzureServices",
    None = "None"
}

// @public
export enum KnownPackageSourceType {
    Remote = "remote"
}

// @public
export enum KnownPipelineOptions {
    ContinueOnErrors = "ContinueOnErrors",
    DeleteSourceBlobOnSuccess = "DeleteSourceBlobOnSuccess",
    OverwriteBlobs = "OverwriteBlobs",
    OverwriteTags = "OverwriteTags"
}

// @public
export enum KnownPipelineRunSourceType {
    AzureStorageBlob = "AzureStorageBlob"
}

// @public
export enum KnownPipelineRunTargetType {
    AzureStorageBlob = "AzureStorageBlob"
}

// @public
export enum KnownPipelineSourceType {
    AzureStorageBlobContainer = "AzureStorageBlobContainer"
}

// @public
export enum KnownPolicyStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownPublicNetworkAccess {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownRegistryUsageUnit {
    Bytes = "Bytes",
    Count = "Count"
}

// @public
export enum KnownRoleAssignmentMode {
    AbacRepositoryPermissions = "AbacRepositoryPermissions",
    LegacyRegistryPermissions = "LegacyRegistryPermissions"
}

// @public
export enum KnownSkuName {
    Basic = "Basic",
    Classic = "Classic",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownSkuTier {
    Basic = "Basic",
    Classic = "Classic",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownStorageAccessMode {
    ManagedIdentity = "ManagedIdentity",
    SasToken = "SasToken"
}

// @public
export enum KnownTlsStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownTokenCertificateName {
    Certificate1 = "certificate1",
    Certificate2 = "certificate2"
}

// @public
export enum KnownTokenPasswordName {
    Password1 = "password1",
    Password2 = "password2"
}

// @public
export enum KnownTokenStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownTriggerStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownTrustPolicyType {
    Notary = "Notary"
}

// @public
export enum KnownVersions {
    V20250601Preview = "2025-06-01-preview"
}

// @public
export enum KnownWebhookAction {
    ChartDelete = "chart_delete",
    ChartPush = "chart_push",
    Delete = "delete",
    Push = "push",
    Quarantine = "quarantine"
}

// @public
export enum KnownWebhookStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownZoneRedundancy {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export interface LoggingProperties {
    auditLogStatus?: AuditLogStatus;
    logLevel?: LogLevel;
}

// @public
export interface LoginServerProperties {
    readonly host?: string;
    readonly tls?: TlsProperties;
}

// @public
export type LogLevel = string;

// @public
export type MetadataSearch = string;

// @public
export type NetworkRuleBypassOptions = string;

// @public
export interface NetworkRuleSet {
    defaultAction: DefaultAction;
    ipRules?: IPRule[];
}

// @public
export interface OperationDefinition {
    display?: OperationDisplayDefinition;
    isDataAction?: boolean;
    name?: string;
    origin?: string;
    properties?: OperationPropertiesDefinition;
}

// @public
export interface OperationDisplayDefinition {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationLogSpecificationDefinition {
    blobDuration?: string;
    displayName?: string;
    name?: string;
}

// @public
export interface OperationMetricSpecificationDefinition {
    aggregationType?: string;
    displayDescription?: string;
    displayName?: string;
    internalMetricName?: string;
    name?: string;
    unit?: string;
}

// @public
export interface OperationPropertiesDefinition {
    serviceSpecification?: OperationServiceSpecificationDefinition;
}

// @public
export interface OperationServiceSpecificationDefinition {
    logSpecifications?: OperationLogSpecificationDefinition[];
    metricSpecifications?: OperationMetricSpecificationDefinition[];
}

// @public
export interface OperationsListOptionalParams extends OperationOptions {
}

// @public
export interface OperationsOperations {
    list: (options?: OperationsListOptionalParams) => PagedAsyncIterableIterator<OperationDefinition>;
}

// @public
export type PackageSourceType = string;

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface ParentProperties {
    id?: string;
    syncProperties: SyncProperties;
}

// @public
export type PasswordName = "password" | "password2";

// @public
export type PipelineOptions = string;

// @public
export interface PipelineRun extends ProxyResource {
    properties?: PipelineRunProperties;
}

// @public
export interface PipelineRunProperties {
    forceUpdateTag?: string;
    readonly provisioningState?: ProvisioningState;
    request?: PipelineRunRequest;
    readonly response?: PipelineRunResponse;
}

// @public
export interface PipelineRunRequest {
    artifacts?: string[];
    catalogDigest?: string;
    pipelineResourceId?: string;
    source?: PipelineRunSourceProperties;
    target?: PipelineRunTargetProperties;
}

// @public
export interface PipelineRunResponse {
    catalogDigest?: string;
    finishTime?: Date;
    importedArtifacts?: string[];
    pipelineRunErrorMessage?: string;
    progress?: ProgressProperties;
    source?: ImportPipelineSourceProperties;
    startTime?: Date;
    status?: string;
    target?: ExportPipelineTargetProperties;
    trigger?: PipelineTriggerDescriptor;
}

// @public
export interface PipelineRunsCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface PipelineRunsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface PipelineRunsGetOptionalParams extends OperationOptions {
}

// @public
export interface PipelineRunsListOptionalParams extends OperationOptions {
}

// @public
export interface PipelineRunsOperations {
    create: (resourceGroupName: string, registryName: string, pipelineRunName: string, pipelineRunCreateParameters: PipelineRun, options?: PipelineRunsCreateOptionalParams) => PollerLike<OperationState<PipelineRun>, PipelineRun>;
    delete: (resourceGroupName: string, registryName: string, pipelineRunName: string, options?: PipelineRunsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, pipelineRunName: string, options?: PipelineRunsGetOptionalParams) => Promise<PipelineRun>;
    list: (resourceGroupName: string, registryName: string, options?: PipelineRunsListOptionalParams) => PagedAsyncIterableIterator<PipelineRun>;
}

// @public
export interface PipelineRunSourceProperties {
    name?: string;
    type?: PipelineRunSourceType;
}

// @public
export type PipelineRunSourceType = string;

// @public
export interface PipelineRunTargetProperties {
    name?: string;
    type?: PipelineRunTargetType;
}

// @public
export type PipelineRunTargetType = string;

// @public
export interface PipelineSourceTriggerDescriptor {
    timestamp?: Date;
}

// @public
export interface PipelineSourceTriggerProperties {
    status: TriggerStatus;
}

// @public
export type PipelineSourceType = string;

// @public
export interface PipelineTriggerDescriptor {
    sourceTrigger?: PipelineSourceTriggerDescriptor;
}

// @public
export interface PipelineTriggerProperties {
    sourceTrigger?: PipelineSourceTriggerProperties;
}

// @public
export interface Policies {
    azureADAuthenticationAsArmPolicy?: AzureADAuthenticationAsArmPolicy;
    exportPolicy?: ExportPolicy;
    quarantinePolicy?: QuarantinePolicy;
    retentionPolicy?: RetentionPolicy;
    softDeletePolicy?: SoftDeletePolicy;
    trustPolicy?: TrustPolicy;
}

// @public
export type PolicyStatus = string;

// @public
export interface PrivateEndpoint {
    id?: string;
}

// @public
export interface PrivateEndpointConnection extends ProxyResource {
    properties?: PrivateEndpointConnectionProperties;
}

// @public
export interface PrivateEndpointConnectionProperties {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface PrivateEndpointConnectionsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends OperationOptions {
}

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends OperationOptions {
}

// @public
export interface PrivateEndpointConnectionsOperations {
    createOrUpdate: (resourceGroupName: string, registryName: string, privateEndpointConnectionName: string, privateEndpointConnection: PrivateEndpointConnection, options?: PrivateEndpointConnectionsCreateOrUpdateOptionalParams) => PollerLike<OperationState<PrivateEndpointConnection>, PrivateEndpointConnection>;
    delete: (resourceGroupName: string, registryName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams) => Promise<PrivateEndpointConnection>;
    list: (resourceGroupName: string, registryName: string, options?: PrivateEndpointConnectionsListOptionalParams) => PagedAsyncIterableIterator<PrivateEndpointConnection>;
}

// @public
export interface PrivateLinkResource extends Resource {
    properties?: PrivateLinkResourceProperties;
}

// @public
export interface PrivateLinkResourceProperties {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
}

// @public
export interface PrivateLinkServiceConnectionState {
    actionsRequired?: ActionsRequired;
    description?: string;
    status?: ConnectionStatus;
}

// @public
export interface ProgressProperties {
    percentage?: string;
}

// @public
export type ProvisioningState = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export type PublicNetworkAccess = string;

// @public
export interface QuarantinePolicy {
    status?: PolicyStatus;
}

// @public
export interface RegenerateCredentialParameters {
    name: PasswordName;
}

// @public
export interface RegistriesCheckNameAvailabilityOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface RegistriesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface RegistriesGenerateCredentialsOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface RegistriesGetOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesGetPrivateLinkResourceOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesImportImageOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface RegistriesListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesListCredentialsOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesListOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesListPrivateLinkResourcesOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesListUsagesOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesOperations {
    checkNameAvailability: (registryNameCheckRequest: RegistryNameCheckRequest, options?: RegistriesCheckNameAvailabilityOptionalParams) => Promise<RegistryNameStatus>;
    create: (resourceGroupName: string, registryName: string, registry: Registry, options?: RegistriesCreateOptionalParams) => PollerLike<OperationState<Registry>, Registry>;
    delete: (resourceGroupName: string, registryName: string, options?: RegistriesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    generateCredentials: (resourceGroupName: string, registryName: string, generateCredentialsParameters: GenerateCredentialsParameters, options?: RegistriesGenerateCredentialsOptionalParams) => PollerLike<OperationState<GenerateCredentialsResult>, GenerateCredentialsResult>;
    get: (resourceGroupName: string, registryName: string, options?: RegistriesGetOptionalParams) => Promise<Registry>;
    getPrivateLinkResource: (resourceGroupName: string, registryName: string, groupName: string, options?: RegistriesGetPrivateLinkResourceOptionalParams) => Promise<PrivateLinkResource>;
    importImage: (resourceGroupName: string, registryName: string, parameters: ImportImageParameters, options?: RegistriesImportImageOptionalParams) => PollerLike<OperationState<void>, void>;
    list: (options?: RegistriesListOptionalParams) => PagedAsyncIterableIterator<Registry>;
    listByResourceGroup: (resourceGroupName: string, options?: RegistriesListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<Registry>;
    listCredentials: (resourceGroupName: string, registryName: string, options?: RegistriesListCredentialsOptionalParams) => Promise<RegistryListCredentialsResult>;
    listPrivateLinkResources: (resourceGroupName: string, registryName: string, options?: RegistriesListPrivateLinkResourcesOptionalParams) => PagedAsyncIterableIterator<PrivateLinkResource>;
    listUsages: (resourceGroupName: string, registryName: string, options?: RegistriesListUsagesOptionalParams) => Promise<RegistryUsageListResult>;
    regenerateCredential: (resourceGroupName: string, registryName: string, regenerateCredentialParameters: RegenerateCredentialParameters, options?: RegistriesRegenerateCredentialOptionalParams) => Promise<RegistryListCredentialsResult>;
    update: (resourceGroupName: string, registryName: string, registryUpdateParameters: RegistryUpdateParameters, options?: RegistriesUpdateOptionalParams) => PollerLike<OperationState<Registry>, Registry>;
}

// @public
export interface RegistriesRegenerateCredentialOptionalParams extends OperationOptions {
}

// @public
export interface RegistriesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface Registry extends TrackedResource {
    identity?: IdentityProperties;
    properties?: RegistryProperties;
    sku: Sku;
}

// @public
export interface RegistryListCredentialsResult {
    passwords?: RegistryPassword[];
    username?: string;
}

// @public
export interface RegistryNameCheckRequest {
    autoGeneratedDomainNameLabelScope?: AutoGeneratedDomainNameLabelScope;
    name: string;
    resourceGroupName?: string;
    type: ContainerRegistryResourceType;
}

// @public
export interface RegistryNameStatus {
    availableLoginServerName?: string;
    message?: string;
    nameAvailable?: boolean;
    reason?: string;
}

// @public
export interface RegistryPassword {
    name?: PasswordName;
    value?: string;
}

// @public
export interface RegistryProperties {
    adminUserEnabled?: boolean;
    anonymousPullEnabled?: boolean;
    autoGeneratedDomainNameLabelScope?: AutoGeneratedDomainNameLabelScope;
    readonly creationDate?: Date;
    dataEndpointEnabled?: boolean;
    readonly dataEndpointHostNames?: string[];
    encryption?: EncryptionProperty;
    readonly loginServer?: string;
    metadataSearch?: MetadataSearch;
    networkRuleBypassAllowedForTasks?: boolean;
    networkRuleBypassOptions?: NetworkRuleBypassOptions;
    networkRuleSet?: NetworkRuleSet;
    policies?: Policies;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    readonly provisioningState?: ProvisioningState;
    publicNetworkAccess?: PublicNetworkAccess;
    roleAssignmentMode?: RoleAssignmentMode;
    readonly status?: Status;
    zoneRedundancy?: ZoneRedundancy;
}

// @public
export interface RegistryPropertiesUpdateParameters {
    adminUserEnabled?: boolean;
    anonymousPullEnabled?: boolean;
    dataEndpointEnabled?: boolean;
    encryption?: EncryptionProperty;
    metadataSearch?: MetadataSearch;
    networkRuleBypassAllowedForTasks?: boolean;
    networkRuleBypassOptions?: NetworkRuleBypassOptions;
    networkRuleSet?: NetworkRuleSet;
    policies?: Policies;
    publicNetworkAccess?: PublicNetworkAccess;
    roleAssignmentMode?: RoleAssignmentMode;
}

// @public
export interface RegistryUpdateParameters {
    identity?: IdentityProperties;
    properties?: RegistryPropertiesUpdateParameters;
    sku?: Sku;
    tags?: Record<string, string>;
}

// @public
export interface RegistryUsage {
    currentValue?: number;
    limit?: number;
    name?: string;
    unit?: RegistryUsageUnit;
}

// @public
export interface RegistryUsageListResult {
    value?: RegistryUsage[];
}

// @public
export type RegistryUsageUnit = string;

// @public
export interface Replication extends TrackedResource {
    properties?: ReplicationProperties;
}

// @public
export interface ReplicationProperties {
    readonly provisioningState?: ProvisioningState;
    regionEndpointEnabled?: boolean;
    readonly status?: Status;
    zoneRedundancy?: ZoneRedundancy;
}

// @public
export interface ReplicationsCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ReplicationsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ReplicationsGetOptionalParams extends OperationOptions {
}

// @public
export interface ReplicationsListOptionalParams extends OperationOptions {
}

// @public
export interface ReplicationsOperations {
    create: (resourceGroupName: string, registryName: string, replicationName: string, replication: Replication, options?: ReplicationsCreateOptionalParams) => PollerLike<OperationState<Replication>, Replication>;
    delete: (resourceGroupName: string, registryName: string, replicationName: string, options?: ReplicationsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, replicationName: string, options?: ReplicationsGetOptionalParams) => Promise<Replication>;
    list: (resourceGroupName: string, registryName: string, options?: ReplicationsListOptionalParams) => PagedAsyncIterableIterator<Replication>;
    update: (resourceGroupName: string, registryName: string, replicationName: string, replicationUpdateParameters: ReplicationUpdateParameters, options?: ReplicationsUpdateOptionalParams) => PollerLike<OperationState<Replication>, Replication>;
}

// @public
export interface ReplicationsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ReplicationUpdateParameters {
    properties?: ReplicationUpdateParametersProperties;
    tags?: Record<string, string>;
}

// @public
export interface ReplicationUpdateParametersProperties {
    regionEndpointEnabled?: boolean;
}

// @public
interface Request_2 {
    addr?: string;
    host?: string;
    id?: string;
    method?: string;
    useragent?: string;
}
export { Request_2 as Request }

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export type ResourceIdentityType = "SystemAssigned" | "UserAssigned" | "SystemAssigned, UserAssigned" | "None";

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: ContainerRegistryManagementClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export interface RetentionPolicy {
    days?: number;
    readonly lastUpdatedTime?: Date;
    status?: PolicyStatus;
}

// @public
export type RoleAssignmentMode = string;

// @public
export interface ScopeMap extends ProxyResource {
    properties?: ScopeMapProperties;
}

// @public
export interface ScopeMapProperties {
    actions: string[];
    readonly creationDate?: Date;
    description?: string;
    readonly provisioningState?: ProvisioningState;
    readonly type?: string;
}

// @public
export interface ScopeMapPropertiesUpdateParameters {
    actions?: string[];
    description?: string;
}

// @public
export interface ScopeMapsCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ScopeMapsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ScopeMapsGetOptionalParams extends OperationOptions {
}

// @public
export interface ScopeMapsListOptionalParams extends OperationOptions {
}

// @public
export interface ScopeMapsOperations {
    create: (resourceGroupName: string, registryName: string, scopeMapName: string, scopeMapCreateParameters: ScopeMap, options?: ScopeMapsCreateOptionalParams) => PollerLike<OperationState<ScopeMap>, ScopeMap>;
    delete: (resourceGroupName: string, registryName: string, scopeMapName: string, options?: ScopeMapsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, scopeMapName: string, options?: ScopeMapsGetOptionalParams) => Promise<ScopeMap>;
    list: (resourceGroupName: string, registryName: string, options?: ScopeMapsListOptionalParams) => PagedAsyncIterableIterator<ScopeMap>;
    update: (resourceGroupName: string, registryName: string, scopeMapName: string, scopeMapUpdateParameters: ScopeMapUpdateParameters, options?: ScopeMapsUpdateOptionalParams) => PollerLike<OperationState<ScopeMap>, ScopeMap>;
}

// @public
export interface ScopeMapsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface ScopeMapUpdateParameters {
    properties?: ScopeMapPropertiesUpdateParameters;
}

// @public
export interface Sku {
    name: SkuName;
    readonly tier?: SkuTier;
}

// @public
export type SkuName = string;

// @public
export type SkuTier = string;

// @public
export interface SoftDeletePolicy {
    readonly lastUpdatedTime?: Date;
    retentionDays?: number;
    status?: PolicyStatus;
}

// @public
export interface Source {
    addr?: string;
    instanceID?: string;
}

// @public
export interface Status {
    readonly displayStatus?: string;
    readonly message?: string;
    readonly timestamp?: Date;
}

// @public
export interface StatusDetailProperties {
    readonly code?: string;
    readonly correlationId?: string;
    readonly description?: string;
    readonly timestamp?: Date;
    readonly type?: string;
}

// @public
export type StorageAccessMode = string;

// @public
export interface SyncProperties {
    readonly gatewayEndpoint?: string;
    readonly lastSyncTime?: Date;
    messageTtl: string;
    schedule?: string;
    syncWindow?: string;
    tokenId: string;
}

// @public
export interface SyncUpdateProperties {
    messageTtl?: string;
    schedule?: string;
    syncWindow?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface Target {
    digest?: string;
    length?: number;
    mediaType?: string;
    name?: string;
    repository?: string;
    size?: number;
    tag?: string;
    url?: string;
    version?: string;
}

// @public
export interface TlsCertificateProperties {
    readonly location?: string;
    readonly type?: CertificateType;
}

// @public
export interface TlsProperties {
    readonly certificate?: TlsCertificateProperties;
    readonly status?: TlsStatus;
}

// @public
export type TlsStatus = string;

// @public
export interface Token extends ProxyResource {
    properties?: TokenProperties;
}

// @public
export interface TokenCertificate {
    encodedPemCertificate?: string;
    expiry?: Date;
    // (undocumented)
    name?: TokenCertificateName;
    thumbprint?: string;
}

// @public
export type TokenCertificateName = string;

// @public
export interface TokenCredentialsProperties {
    // (undocumented)
    certificates?: TokenCertificate[];
    // (undocumented)
    passwords?: TokenPassword[];
}

// @public
export interface TokenPassword {
    creationTime?: Date;
    expiry?: Date;
    name?: TokenPasswordName;
    readonly value?: string;
}

// @public
export type TokenPasswordName = string;

// @public
export interface TokenProperties {
    readonly creationDate?: Date;
    credentials?: TokenCredentialsProperties;
    readonly provisioningState?: ProvisioningState;
    scopeMapId?: string;
    status?: TokenStatus;
}

// @public
export interface TokensCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TokensDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TokensGetOptionalParams extends OperationOptions {
}

// @public
export interface TokensListOptionalParams extends OperationOptions {
}

// @public
export interface TokensOperations {
    create: (resourceGroupName: string, registryName: string, tokenName: string, tokenCreateParameters: Token, options?: TokensCreateOptionalParams) => PollerLike<OperationState<Token>, Token>;
    delete: (resourceGroupName: string, registryName: string, tokenName: string, options?: TokensDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, tokenName: string, options?: TokensGetOptionalParams) => Promise<Token>;
    list: (resourceGroupName: string, registryName: string, options?: TokensListOptionalParams) => PagedAsyncIterableIterator<Token>;
    update: (resourceGroupName: string, registryName: string, tokenName: string, tokenUpdateParameters: TokenUpdateParameters, options?: TokensUpdateOptionalParams) => PollerLike<OperationState<Token>, Token>;
}

// @public
export type TokenStatus = string;

// @public
export interface TokensUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface TokenUpdateParameters {
    properties?: TokenUpdateProperties;
}

// @public
export interface TokenUpdateProperties {
    credentials?: TokenCredentialsProperties;
    scopeMapId?: string;
    status?: TokenStatus;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export type TriggerStatus = string;

// @public
export interface TrustPolicy {
    status?: PolicyStatus;
    type?: TrustPolicyType;
}

// @public
export type TrustPolicyType = string;

// @public
export interface UserIdentityProperties {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface Webhook extends TrackedResource {
    properties?: WebhookProperties;
}

// @public
export type WebhookAction = string;

// @public
export interface WebhookCreateParameters {
    location: string;
    properties?: WebhookPropertiesCreateParameters;
    tags?: Record<string, string>;
}

// @public
export interface WebhookProperties {
    actions: WebhookAction[];
    readonly provisioningState?: ProvisioningState;
    scope?: string;
    status?: WebhookStatus;
}

// @public
export interface WebhookPropertiesCreateParameters {
    actions: WebhookAction[];
    customHeaders?: Record<string, string>;
    scope?: string;
    serviceUri: string;
    status?: WebhookStatus;
}

// @public
export interface WebhookPropertiesUpdateParameters {
    actions?: WebhookAction[];
    customHeaders?: Record<string, string>;
    scope?: string;
    serviceUri?: string;
    status?: WebhookStatus;
}

// @public
export interface WebhooksCreateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface WebhooksDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface WebhooksGetCallbackConfigOptionalParams extends OperationOptions {
}

// @public
export interface WebhooksGetOptionalParams extends OperationOptions {
}

// @public
export interface WebhooksListEventsOptionalParams extends OperationOptions {
}

// @public
export interface WebhooksListOptionalParams extends OperationOptions {
}

// @public
export interface WebhooksOperations {
    create: (resourceGroupName: string, registryName: string, webhookName: string, webhookCreateParameters: WebhookCreateParameters, options?: WebhooksCreateOptionalParams) => PollerLike<OperationState<Webhook>, Webhook>;
    delete: (resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksGetOptionalParams) => Promise<Webhook>;
    getCallbackConfig: (resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksGetCallbackConfigOptionalParams) => Promise<CallbackConfig>;
    list: (resourceGroupName: string, registryName: string, options?: WebhooksListOptionalParams) => PagedAsyncIterableIterator<Webhook>;
    listEvents: (resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksListEventsOptionalParams) => PagedAsyncIterableIterator<Event_2>;
    ping: (resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksPingOptionalParams) => Promise<EventInfo>;
    update: (resourceGroupName: string, registryName: string, webhookName: string, webhookUpdateParameters: WebhookUpdateParameters, options?: WebhooksUpdateOptionalParams) => PollerLike<OperationState<Webhook>, Webhook>;
}

// @public
export interface WebhooksPingOptionalParams extends OperationOptions {
}

// @public
export type WebhookStatus = string;

// @public
export interface WebhooksUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface WebhookUpdateParameters {
    properties?: WebhookPropertiesUpdateParameters;
    tags?: Record<string, string>;
}

// @public
export type ZoneRedundancy = string;

// (No @packageDocumentation comment for this package)

```
