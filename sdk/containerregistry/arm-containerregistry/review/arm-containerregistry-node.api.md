## API Report File for "@azure/arm-containerregistry"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { OperationState } from '@azure/core-lro';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { SimplePollerLike } from '@azure/core-lro';

// @public
export type Action = string;

// @public
export type ActionsRequired = string;

// @public
export interface ActivationProperties {
    readonly status?: ActivationStatus;
}

// @public
export type ActivationStatus = string;

// @public
export interface ActiveDirectoryObject {
    objectId?: string;
    tenantId?: string;
}

// @public
export interface Actor {
    name?: string;
}

// @public
export interface Archive extends ProxyResource {
    packageSource?: ArchivePackageSourceProperties;
    readonly provisioningState?: ProvisioningState;
    publishedVersion?: string;
    readonly repositoryEndpoint?: string;
    // (undocumented)
    repositoryEndpointPrefix?: string;
}

// @public
export interface ArchiveListResult {
    nextLink?: string;
    value?: Archive[];
}

// @public
export interface ArchivePackageSourceProperties {
    type?: PackageSourceType;
    url?: string;
}

// @public
export interface ArchiveProperties {
    packageSource?: ArchivePackageSourceProperties;
    readonly provisioningState?: ProvisioningState;
    publishedVersion?: string;
    readonly repositoryEndpoint?: string;
    // (undocumented)
    repositoryEndpointPrefix?: string;
}

// @public
export interface Archives {
    beginCreate(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveCreateParameters: Archive, options?: ArchivesCreateOptionalParams): Promise<SimplePollerLike<OperationState<ArchivesCreateResponse>, ArchivesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveCreateParameters: Archive, options?: ArchivesCreateOptionalParams): Promise<ArchivesCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, options?: ArchivesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<ArchivesDeleteResponse>, ArchivesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, options?: ArchivesDeleteOptionalParams): Promise<ArchivesDeleteResponse>;
    get(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, options?: ArchivesGetOptionalParams): Promise<ArchivesGetResponse>;
    list(resourceGroupName: string, registryName: string, packageType: string, options?: ArchivesListOptionalParams): PagedAsyncIterableIterator<Archive>;
    update(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveUpdateParameters: ArchiveUpdateParameters, options?: ArchivesUpdateOptionalParams): Promise<ArchivesUpdateResponse>;
}

// @public
export interface ArchivesCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ArchivesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ArchivesCreateResponse = Archive;

// @public
export interface ArchivesDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ArchivesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ArchivesDeleteResponse = ArchivesDeleteHeaders;

// @public
export interface ArchivesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ArchivesGetResponse = Archive;

// @public
export interface ArchivesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ArchivesListNextResponse = ArchiveListResult;

// @public
export interface ArchivesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ArchivesListResponse = ArchiveListResult;

// @public
export interface ArchivesUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ArchivesUpdateResponse = Archive;

// @public
export interface ArchiveUpdateParameters {
    publishedVersion?: string;
}

// @public
export interface ArchiveVersion extends ProxyResource {
    archiveVersionErrorMessage?: string;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface ArchiveVersionListResult {
    nextLink?: string;
    value?: ArchiveVersion[];
}

// @public
export interface ArchiveVersions {
    beginCreate(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveVersionName: string, options?: ArchiveVersionsCreateOptionalParams): Promise<SimplePollerLike<OperationState<ArchiveVersionsCreateResponse>, ArchiveVersionsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveVersionName: string, options?: ArchiveVersionsCreateOptionalParams): Promise<ArchiveVersionsCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveVersionName: string, options?: ArchiveVersionsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<ArchiveVersionsDeleteResponse>, ArchiveVersionsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveVersionName: string, options?: ArchiveVersionsDeleteOptionalParams): Promise<ArchiveVersionsDeleteResponse>;
    get(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, archiveVersionName: string, options?: ArchiveVersionsGetOptionalParams): Promise<ArchiveVersionsGetResponse>;
    list(resourceGroupName: string, registryName: string, packageType: string, archiveName: string, options?: ArchiveVersionsListOptionalParams): PagedAsyncIterableIterator<ArchiveVersion>;
}

// @public
export interface ArchiveVersionsCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ArchiveVersionsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ArchiveVersionsCreateResponse = ArchiveVersion;

// @public
export interface ArchiveVersionsDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ArchiveVersionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ArchiveVersionsDeleteResponse = ArchiveVersionsDeleteHeaders;

// @public
export interface ArchiveVersionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ArchiveVersionsGetResponse = ArchiveVersion;

// @public
export interface ArchiveVersionsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ArchiveVersionsListNextResponse = ArchiveVersionListResult;

// @public
export interface ArchiveVersionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ArchiveVersionsListResponse = ArchiveVersionListResult;

// @public
export type AuditLogStatus = string;

// @public
export interface AuthCredential {
    readonly credentialHealth?: CredentialHealth;
    name?: CredentialName;
    passwordSecretIdentifier?: string;
    usernameSecretIdentifier?: string;
}

// @public
export type AutoGeneratedDomainNameLabelScope = string;

// @public
export interface AzureADAuthenticationAsArmPolicy {
    status?: AzureADAuthenticationAsArmPolicyStatus;
}

// @public
export type AzureADAuthenticationAsArmPolicyStatus = string;

// @public
export interface CacheRule extends ProxyResource {
    readonly creationDate?: Date;
    credentialSetResourceId?: string;
    readonly provisioningState?: ProvisioningState;
    sourceRepository?: string;
    targetRepository?: string;
}

// @public
export interface CacheRules {
    beginCreate(resourceGroupName: string, registryName: string, cacheRuleName: string, cacheRuleCreateParameters: CacheRule, options?: CacheRulesCreateOptionalParams): Promise<SimplePollerLike<OperationState<CacheRulesCreateResponse>, CacheRulesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, cacheRuleName: string, cacheRuleCreateParameters: CacheRule, options?: CacheRulesCreateOptionalParams): Promise<CacheRulesCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, cacheRuleName: string, options?: CacheRulesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<CacheRulesDeleteResponse>, CacheRulesDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, cacheRuleName: string, options?: CacheRulesDeleteOptionalParams): Promise<CacheRulesDeleteResponse>;
    beginUpdate(resourceGroupName: string, registryName: string, cacheRuleName: string, cacheRuleUpdateParameters: CacheRuleUpdateParameters, options?: CacheRulesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<CacheRulesUpdateResponse>, CacheRulesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, registryName: string, cacheRuleName: string, cacheRuleUpdateParameters: CacheRuleUpdateParameters, options?: CacheRulesUpdateOptionalParams): Promise<CacheRulesUpdateResponse>;
    get(resourceGroupName: string, registryName: string, cacheRuleName: string, options?: CacheRulesGetOptionalParams): Promise<CacheRulesGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: CacheRulesListOptionalParams): PagedAsyncIterableIterator<CacheRule>;
}

// @public
export interface CacheRulesCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface CacheRulesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CacheRulesCreateResponse = CacheRule;

// @public
export interface CacheRulesDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface CacheRulesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CacheRulesDeleteResponse = CacheRulesDeleteHeaders;

// @public
export interface CacheRulesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CacheRulesGetResponse = CacheRule;

// @public
export interface CacheRulesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CacheRulesListNextResponse = CacheRulesListResult;

// @public
export interface CacheRulesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CacheRulesListResponse = CacheRulesListResult;

// @public
export interface CacheRulesListResult {
    nextLink?: string;
    value?: CacheRule[];
}

// @public
export interface CacheRulesUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface CacheRulesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CacheRulesUpdateResponse = CacheRule;

// @public
export interface CacheRuleUpdateParameters {
    credentialSetResourceId?: string;
}

// @public
export interface CallbackConfig {
    customHeaders?: {
        [propertyName: string]: string;
    };
    serviceUri: string;
}

// @public
export type CertificateType = string;

// @public
export interface ConnectedRegistries {
    beginCreate(resourceGroupName: string, registryName: string, connectedRegistryName: string, connectedRegistryCreateParameters: ConnectedRegistry, options?: ConnectedRegistriesCreateOptionalParams): Promise<SimplePollerLike<OperationState<ConnectedRegistriesCreateResponse>, ConnectedRegistriesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, connectedRegistryName: string, connectedRegistryCreateParameters: ConnectedRegistry, options?: ConnectedRegistriesCreateOptionalParams): Promise<ConnectedRegistriesCreateResponse>;
    beginDeactivate(resourceGroupName: string, registryName: string, connectedRegistryName: string, options?: ConnectedRegistriesDeactivateOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeactivateAndWait(resourceGroupName: string, registryName: string, connectedRegistryName: string, options?: ConnectedRegistriesDeactivateOptionalParams): Promise<void>;
    beginDelete(resourceGroupName: string, registryName: string, connectedRegistryName: string, options?: ConnectedRegistriesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, connectedRegistryName: string, options?: ConnectedRegistriesDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, registryName: string, connectedRegistryName: string, connectedRegistryUpdateParameters: ConnectedRegistryUpdateParameters, options?: ConnectedRegistriesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ConnectedRegistriesUpdateResponse>, ConnectedRegistriesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, registryName: string, connectedRegistryName: string, connectedRegistryUpdateParameters: ConnectedRegistryUpdateParameters, options?: ConnectedRegistriesUpdateOptionalParams): Promise<ConnectedRegistriesUpdateResponse>;
    get(resourceGroupName: string, registryName: string, connectedRegistryName: string, options?: ConnectedRegistriesGetOptionalParams): Promise<ConnectedRegistriesGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: ConnectedRegistriesListOptionalParams): PagedAsyncIterableIterator<ConnectedRegistry>;
}

// @public
export interface ConnectedRegistriesCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ConnectedRegistriesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConnectedRegistriesCreateResponse = ConnectedRegistry;

// @public
export interface ConnectedRegistriesDeactivateHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ConnectedRegistriesDeactivateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ConnectedRegistriesDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ConnectedRegistriesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ConnectedRegistriesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectedRegistriesGetResponse = ConnectedRegistry;

// @public
export interface ConnectedRegistriesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ConnectedRegistriesListNextResponse = ConnectedRegistryListResult;

// @public
export interface ConnectedRegistriesListOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type ConnectedRegistriesListResponse = ConnectedRegistryListResult;

// @public
export interface ConnectedRegistriesUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ConnectedRegistriesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConnectedRegistriesUpdateResponse = ConnectedRegistry;

// @public
export interface ConnectedRegistry extends ProxyResource {
    readonly activation?: ActivationProperties;
    clientTokenIds?: string[];
    readonly connectionState?: ConnectionState;
    garbageCollection?: GarbageCollectionProperties;
    readonly lastActivityTime?: Date;
    logging?: LoggingProperties;
    loginServer?: LoginServerProperties;
    mode?: ConnectedRegistryMode;
    notificationsList?: string[];
    parent?: ParentProperties;
    readonly provisioningState?: ProvisioningState;
    readonly statusDetails?: StatusDetailProperties[];
    readonly version?: string;
}

// @public
export interface ConnectedRegistryListResult {
    nextLink?: string;
    value?: ConnectedRegistry[];
}

// @public
export type ConnectedRegistryMode = string;

// @public
export interface ConnectedRegistryUpdateParameters {
    clientTokenIds?: string[];
    garbageCollection?: GarbageCollectionProperties;
    logging?: LoggingProperties;
    notificationsList?: string[];
    syncProperties?: SyncUpdateProperties;
}

// @public
export type ConnectionState = string;

// @public
export type ConnectionStatus = string;

// @public (undocumented)
export class ContainerRegistryManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: ContainerRegistryManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    archives: Archives;
    // (undocumented)
    archiveVersions: ArchiveVersions;
    // (undocumented)
    cacheRules: CacheRules;
    // (undocumented)
    connectedRegistries: ConnectedRegistries;
    // (undocumented)
    credentialSets: CredentialSets;
    // (undocumented)
    exportPipelines: ExportPipelines;
    // (undocumented)
    importPipelines: ImportPipelines;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    pipelineRuns: PipelineRuns;
    // (undocumented)
    privateEndpointConnections: PrivateEndpointConnections;
    // (undocumented)
    registries: Registries;
    // (undocumented)
    replications: Replications;
    // (undocumented)
    scopeMaps: ScopeMaps;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    tokens: Tokens;
    // (undocumented)
    webhooks: Webhooks;
}

// @public
export interface ContainerRegistryManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export type CreatedByType = string;

// @public
export interface CredentialHealth {
    errorCode?: string;
    errorMessage?: string;
    status?: CredentialHealthStatus;
}

// @public
export type CredentialHealthStatus = string;

// @public
export type CredentialName = string;

// @public
export interface CredentialSet extends ProxyResource {
    authCredentials?: AuthCredential[];
    readonly creationDate?: Date;
    identity?: IdentityProperties;
    loginServer?: string;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface CredentialSetListResult {
    nextLink?: string;
    value?: CredentialSet[];
}

// @public
export interface CredentialSets {
    beginCreate(resourceGroupName: string, registryName: string, credentialSetName: string, credentialSetCreateParameters: CredentialSet, options?: CredentialSetsCreateOptionalParams): Promise<SimplePollerLike<OperationState<CredentialSetsCreateResponse>, CredentialSetsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, credentialSetName: string, credentialSetCreateParameters: CredentialSet, options?: CredentialSetsCreateOptionalParams): Promise<CredentialSetsCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, credentialSetName: string, options?: CredentialSetsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<CredentialSetsDeleteResponse>, CredentialSetsDeleteResponse>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, credentialSetName: string, options?: CredentialSetsDeleteOptionalParams): Promise<CredentialSetsDeleteResponse>;
    beginUpdate(resourceGroupName: string, registryName: string, credentialSetName: string, credentialSetUpdateParameters: CredentialSetUpdateParameters, options?: CredentialSetsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<CredentialSetsUpdateResponse>, CredentialSetsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, registryName: string, credentialSetName: string, credentialSetUpdateParameters: CredentialSetUpdateParameters, options?: CredentialSetsUpdateOptionalParams): Promise<CredentialSetsUpdateResponse>;
    get(resourceGroupName: string, registryName: string, credentialSetName: string, options?: CredentialSetsGetOptionalParams): Promise<CredentialSetsGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: CredentialSetsListOptionalParams): PagedAsyncIterableIterator<CredentialSet>;
}

// @public
export interface CredentialSetsCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface CredentialSetsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CredentialSetsCreateResponse = CredentialSet;

// @public
export interface CredentialSetsDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface CredentialSetsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CredentialSetsDeleteResponse = CredentialSetsDeleteHeaders;

// @public
export interface CredentialSetsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CredentialSetsGetResponse = CredentialSet;

// @public
export interface CredentialSetsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CredentialSetsListNextResponse = CredentialSetListResult;

// @public
export interface CredentialSetsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CredentialSetsListResponse = CredentialSetListResult;

// @public
export interface CredentialSetsUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface CredentialSetsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type CredentialSetsUpdateResponse = CredentialSet;

// @public
export interface CredentialSetUpdateParameters {
    authCredentials?: AuthCredential[];
    identity?: IdentityProperties;
}

// @public
export interface DebianArchivePackageSourceProperties extends ArchivePackageSourceProperties {
    distributionName?: string;
}

// @public
export interface DebianArchiveProperties extends ArchiveProperties {
    distributionName?: string;
}

// @public
export type DefaultAction = string;

// @public (undocumented)
export interface EncryptionProperty {
    keyVaultProperties?: KeyVaultProperties;
    status?: EncryptionStatus;
}

// @public
export type EncryptionStatus = string;

// @public
export interface ErrorAdditionalInfo {
    readonly info?: Record<string, unknown>;
    readonly type?: string;
}

// @public
export interface ErrorDetail {
    readonly additionalInfo?: ErrorAdditionalInfo[];
    readonly code?: string;
    readonly details?: ErrorDetail[];
    readonly message?: string;
    readonly target?: string;
}

// @public
export interface ErrorResponse {
    error?: ErrorDetail;
}

// @public
interface Event_2 extends EventInfo {
    eventRequestMessage?: EventRequestMessage;
    eventResponseMessage?: EventResponseMessage;
}
export { Event_2 as Event }

// @public
export interface EventContent {
    action?: string;
    actor?: Actor;
    id?: string;
    request?: Request_2;
    source?: Source;
    target?: Target;
    timestamp?: Date;
}

// @public
export interface EventInfo {
    id?: string;
}

// @public
export interface EventListResult {
    nextLink?: string;
    value?: Event_2[];
}

// @public
export interface EventRequestMessage {
    content?: EventContent;
    headers?: {
        [propertyName: string]: string;
    };
    method?: string;
    requestUri?: string;
    version?: string;
}

// @public
export interface EventResponseMessage {
    content?: string;
    headers?: {
        [propertyName: string]: string;
    };
    reasonPhrase?: string;
    statusCode?: string;
    version?: string;
}

// @public
export interface ExportPipeline extends ProxyResource {
    identity?: IdentityProperties;
    location?: string;
    options?: PipelineOptions[];
    readonly provisioningState?: ProvisioningState;
    target?: ExportPipelineTargetProperties;
}

// @public
export interface ExportPipelineListResult {
    nextLink?: string;
    value?: ExportPipeline[];
}

// @public
export interface ExportPipelines {
    beginCreate(resourceGroupName: string, registryName: string, exportPipelineName: string, exportPipelineCreateParameters: ExportPipeline, options?: ExportPipelinesCreateOptionalParams): Promise<SimplePollerLike<OperationState<ExportPipelinesCreateResponse>, ExportPipelinesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, exportPipelineName: string, exportPipelineCreateParameters: ExportPipeline, options?: ExportPipelinesCreateOptionalParams): Promise<ExportPipelinesCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, exportPipelineName: string, options?: ExportPipelinesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, exportPipelineName: string, options?: ExportPipelinesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, registryName: string, exportPipelineName: string, options?: ExportPipelinesGetOptionalParams): Promise<ExportPipelinesGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: ExportPipelinesListOptionalParams): PagedAsyncIterableIterator<ExportPipeline>;
}

// @public
export interface ExportPipelinesCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ExportPipelinesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ExportPipelinesCreateResponse = ExportPipeline;

// @public
export interface ExportPipelinesDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ExportPipelinesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ExportPipelinesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ExportPipelinesGetResponse = ExportPipeline;

// @public
export interface ExportPipelinesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ExportPipelinesListNextResponse = ExportPipelineListResult;

// @public
export interface ExportPipelinesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ExportPipelinesListResponse = ExportPipelineListResult;

// @public
export interface ExportPipelineTargetProperties {
    keyVaultUri: string;
    type?: string;
    uri?: string;
}

// @public
export interface ExportPolicy {
    status?: ExportPolicyStatus;
}

// @public
export type ExportPolicyStatus = string;

// @public
export interface GarbageCollectionProperties {
    enabled?: boolean;
    schedule?: string;
}

// @public
export interface GenerateCredentialsParameters {
    expiry?: Date;
    name?: TokenPasswordName;
    tokenId?: string;
}

// @public
export interface GenerateCredentialsResult {
    passwords?: TokenPassword[];
    username?: string;
}

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface IdentityProperties {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: ResourceIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserIdentityProperties;
    };
}

// @public (undocumented)
export interface ImportImageParameters {
    mode?: ImportMode;
    source: ImportSource;
    targetTags?: string[];
    untaggedTargetRepositories?: string[];
}

// @public
export type ImportMode = string;

// @public
export interface ImportPipeline extends ProxyResource {
    identity?: IdentityProperties;
    location?: string;
    options?: PipelineOptions[];
    readonly provisioningState?: ProvisioningState;
    source?: ImportPipelineSourceProperties;
    trigger?: PipelineTriggerProperties;
}

// @public
export interface ImportPipelineListResult {
    nextLink?: string;
    value?: ImportPipeline[];
}

// @public
export interface ImportPipelines {
    beginCreate(resourceGroupName: string, registryName: string, importPipelineName: string, importPipelineCreateParameters: ImportPipeline, options?: ImportPipelinesCreateOptionalParams): Promise<SimplePollerLike<OperationState<ImportPipelinesCreateResponse>, ImportPipelinesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, importPipelineName: string, importPipelineCreateParameters: ImportPipeline, options?: ImportPipelinesCreateOptionalParams): Promise<ImportPipelinesCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, importPipelineName: string, options?: ImportPipelinesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, importPipelineName: string, options?: ImportPipelinesDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, registryName: string, importPipelineName: string, options?: ImportPipelinesGetOptionalParams): Promise<ImportPipelinesGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: ImportPipelinesListOptionalParams): PagedAsyncIterableIterator<ImportPipeline>;
}

// @public
export interface ImportPipelinesCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ImportPipelinesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ImportPipelinesCreateResponse = ImportPipeline;

// @public
export interface ImportPipelinesDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ImportPipelinesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ImportPipelinesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ImportPipelinesGetResponse = ImportPipeline;

// @public
export interface ImportPipelinesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ImportPipelinesListNextResponse = ImportPipelineListResult;

// @public
export interface ImportPipelinesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ImportPipelinesListResponse = ImportPipelineListResult;

// @public
export interface ImportPipelineSourceProperties {
    keyVaultUri: string;
    type?: PipelineSourceType;
    uri?: string;
}

// @public (undocumented)
export interface ImportSource {
    credentials?: ImportSourceCredentials;
    registryUri?: string;
    resourceId?: string;
    sourceImage: string;
}

// @public (undocumented)
export interface ImportSourceCredentials {
    password: string;
    username?: string;
}

// @public
export interface IPRule {
    action?: Action;
    iPAddressOrRange: string;
}

// @public (undocumented)
export interface KeyVaultProperties {
    identity?: string;
    keyIdentifier?: string;
    readonly keyRotationEnabled?: boolean;
    readonly lastKeyRotationTimestamp?: Date;
    readonly versionedKeyIdentifier?: string;
}

// @public
export enum KnownAction {
    Allow = "Allow"
}

// @public
export enum KnownActionsRequired {
    None = "None",
    Recreate = "Recreate"
}

// @public
export enum KnownActivationStatus {
    Active = "Active",
    Inactive = "Inactive"
}

// @public
export enum KnownAuditLogStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownAutoGeneratedDomainNameLabelScope {
    NoReuse = "NoReuse",
    ResourceGroupReuse = "ResourceGroupReuse",
    SubscriptionReuse = "SubscriptionReuse",
    TenantReuse = "TenantReuse",
    Unsecure = "Unsecure"
}

// @public
export enum KnownAzureADAuthenticationAsArmPolicyStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownCertificateType {
    LocalDirectory = "LocalDirectory"
}

// @public
export enum KnownConnectedRegistryMode {
    Mirror = "Mirror",
    ReadOnly = "ReadOnly",
    ReadWrite = "ReadWrite",
    Registry = "Registry"
}

// @public
export enum KnownConnectionState {
    Offline = "Offline",
    Online = "Online",
    Syncing = "Syncing",
    Unhealthy = "Unhealthy"
}

// @public
export enum KnownConnectionStatus {
    Approved = "Approved",
    Disconnected = "Disconnected",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownCredentialHealthStatus {
    Healthy = "Healthy",
    Unhealthy = "Unhealthy"
}

// @public
export enum KnownCredentialName {
    Credential1 = "Credential1"
}

// @public
export enum KnownDefaultAction {
    Allow = "Allow",
    Deny = "Deny"
}

// @public
export enum KnownEncryptionStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownExportPolicyStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownImportMode {
    Force = "Force",
    NoForce = "NoForce"
}

// @public
export enum KnownLastModifiedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownLogLevel {
    Debug = "Debug",
    Error = "Error",
    Information = "Information",
    None = "None",
    Warning = "Warning"
}

// @public
export enum KnownMetadataSearch {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownNetworkRuleBypassOptions {
    AzureServices = "AzureServices",
    None = "None"
}

// @public
export enum KnownPackageSourceType {
    Remote = "remote"
}

// @public
export enum KnownPipelineOptions {
    ContinueOnErrors = "ContinueOnErrors",
    DeleteSourceBlobOnSuccess = "DeleteSourceBlobOnSuccess",
    OverwriteBlobs = "OverwriteBlobs",
    OverwriteTags = "OverwriteTags"
}

// @public
export enum KnownPipelineRunSourceType {
    AzureStorageBlob = "AzureStorageBlob"
}

// @public
export enum KnownPipelineRunTargetType {
    AzureStorageBlob = "AzureStorageBlob"
}

// @public
export enum KnownPipelineSourceType {
    AzureStorageBlobContainer = "AzureStorageBlobContainer"
}

// @public
export enum KnownPolicyStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownProvisioningState {
    Canceled = "Canceled",
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded",
    Updating = "Updating"
}

// @public
export enum KnownPublicNetworkAccess {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownRegistryUsageUnit {
    Bytes = "Bytes",
    Count = "Count"
}

// @public
export enum KnownRoleAssignmentMode {
    AbacRepositoryPermissions = "AbacRepositoryPermissions",
    LegacyRegistryPermissions = "LegacyRegistryPermissions"
}

// @public
export enum KnownSkuName {
    Basic = "Basic",
    Classic = "Classic",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownSkuTier {
    Basic = "Basic",
    Classic = "Classic",
    Premium = "Premium",
    Standard = "Standard"
}

// @public
export enum KnownTlsStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownTokenCertificateName {
    Certificate1 = "certificate1",
    Certificate2 = "certificate2"
}

// @public
export enum KnownTokenPasswordName {
    Password1 = "password1",
    Password2 = "password2"
}

// @public
export enum KnownTokenStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownTriggerStatus {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownTrustPolicyType {
    Notary = "Notary"
}

// @public
export enum KnownWebhookAction {
    ChartDelete = "chart_delete",
    ChartPush = "chart_push",
    Delete = "delete",
    Push = "push",
    Quarantine = "quarantine"
}

// @public
export enum KnownWebhookStatus {
    Disabled = "disabled",
    Enabled = "enabled"
}

// @public
export enum KnownZoneRedundancy {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export type LastModifiedByType = string;

// @public
export interface LoggingProperties {
    auditLogStatus?: AuditLogStatus;
    logLevel?: LogLevel;
}

// @public
export interface LoginServerProperties {
    readonly host?: string;
    readonly tls?: TlsProperties;
}

// @public
export type LogLevel = string;

// @public
export type MetadataSearch = string;

// @public
export type NetworkRuleBypassOptions = string;

// @public
export interface NetworkRuleSet {
    defaultAction: DefaultAction;
    ipRules?: IPRule[];
}

// @public
export interface OperationDefinition {
    display?: OperationDisplayDefinition;
    isDataAction?: boolean;
    name?: string;
    origin?: string;
    serviceSpecification?: OperationServiceSpecificationDefinition;
}

// @public
export interface OperationDisplayDefinition {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface OperationListResult {
    nextLink?: string;
    value?: OperationDefinition[];
}

// @public
export interface OperationLogSpecificationDefinition {
    blobDuration?: string;
    displayName?: string;
    name?: string;
}

// @public
export interface OperationMetricSpecificationDefinition {
    aggregationType?: string;
    displayDescription?: string;
    displayName?: string;
    internalMetricName?: string;
    name?: string;
    unit?: string;
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<OperationDefinition>;
}

// @public
export interface OperationServiceSpecificationDefinition {
    logSpecifications?: OperationLogSpecificationDefinition[];
    metricSpecifications?: OperationMetricSpecificationDefinition[];
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = OperationListResult;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = OperationListResult;

// @public
export type PackageSourceType = string;

// @public
export interface PackageType {
    readonly endpoint?: string;
    name?: string;
}

// @public
export interface ParentProperties {
    id?: string;
    syncProperties: SyncProperties;
}

// @public
export type PasswordName = "password" | "password2";

// @public
export type PipelineOptions = string;

// @public
export interface PipelineRun extends ProxyResource {
    forceUpdateTag?: string;
    readonly provisioningState?: ProvisioningState;
    request?: PipelineRunRequest;
    readonly response?: PipelineRunResponse;
}

// @public
export interface PipelineRunListResult {
    nextLink?: string;
    value?: PipelineRun[];
}

// @public
export interface PipelineRunRequest {
    artifacts?: string[];
    catalogDigest?: string;
    pipelineResourceId?: string;
    source?: PipelineRunSourceProperties;
    target?: PipelineRunTargetProperties;
}

// @public
export interface PipelineRunResponse {
    catalogDigest?: string;
    finishTime?: Date;
    importedArtifacts?: string[];
    pipelineRunErrorMessage?: string;
    progress?: ProgressProperties;
    source?: ImportPipelineSourceProperties;
    startTime?: Date;
    status?: string;
    target?: ExportPipelineTargetProperties;
    trigger?: PipelineTriggerDescriptor;
}

// @public
export interface PipelineRuns {
    beginCreate(resourceGroupName: string, registryName: string, pipelineRunName: string, pipelineRunCreateParameters: PipelineRun, options?: PipelineRunsCreateOptionalParams): Promise<SimplePollerLike<OperationState<PipelineRunsCreateResponse>, PipelineRunsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, pipelineRunName: string, pipelineRunCreateParameters: PipelineRun, options?: PipelineRunsCreateOptionalParams): Promise<PipelineRunsCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, pipelineRunName: string, options?: PipelineRunsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, pipelineRunName: string, options?: PipelineRunsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, registryName: string, pipelineRunName: string, options?: PipelineRunsGetOptionalParams): Promise<PipelineRunsGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: PipelineRunsListOptionalParams): PagedAsyncIterableIterator<PipelineRun>;
}

// @public
export interface PipelineRunsCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface PipelineRunsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PipelineRunsCreateResponse = PipelineRun;

// @public
export interface PipelineRunsDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface PipelineRunsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PipelineRunsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PipelineRunsGetResponse = PipelineRun;

// @public
export interface PipelineRunsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PipelineRunsListNextResponse = PipelineRunListResult;

// @public
export interface PipelineRunsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PipelineRunsListResponse = PipelineRunListResult;

// @public (undocumented)
export interface PipelineRunSourceProperties {
    name?: string;
    type?: PipelineRunSourceType;
}

// @public
export type PipelineRunSourceType = string;

// @public (undocumented)
export interface PipelineRunTargetProperties {
    name?: string;
    type?: PipelineRunTargetType;
}

// @public
export type PipelineRunTargetType = string;

// @public (undocumented)
export interface PipelineSourceTriggerDescriptor {
    timestamp?: Date;
}

// @public (undocumented)
export interface PipelineSourceTriggerProperties {
    status: TriggerStatus;
}

// @public
export type PipelineSourceType = string;

// @public (undocumented)
export interface PipelineTriggerDescriptor {
    sourceTrigger?: PipelineSourceTriggerDescriptor;
}

// @public (undocumented)
export interface PipelineTriggerProperties {
    sourceTrigger?: PipelineSourceTriggerProperties;
}

// @public
export interface Policies {
    azureADAuthenticationAsArmPolicy?: AzureADAuthenticationAsArmPolicy;
    exportPolicy?: ExportPolicy;
    quarantinePolicy?: QuarantinePolicy;
    retentionPolicy?: RetentionPolicy;
    softDeletePolicy?: SoftDeletePolicy;
    trustPolicy?: TrustPolicy;
}

// @public
export type PolicyStatus = string;

// @public
export interface PrivateEndpoint {
    id?: string;
}

// @public
export interface PrivateEndpointConnection extends ProxyResource {
    privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: ProvisioningState;
}

// @public
export interface PrivateEndpointConnectionListResult {
    nextLink?: string;
    value?: PrivateEndpointConnection[];
}

// @public
export interface PrivateEndpointConnections {
    beginCreateOrUpdate(resourceGroupName: string, registryName: string, privateEndpointConnectionName: string, privateEndpointConnection: PrivateEndpointConnection, options?: PrivateEndpointConnectionsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<PrivateEndpointConnectionsCreateOrUpdateResponse>, PrivateEndpointConnectionsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, registryName: string, privateEndpointConnectionName: string, privateEndpointConnection: PrivateEndpointConnection, options?: PrivateEndpointConnectionsCreateOrUpdateOptionalParams): Promise<PrivateEndpointConnectionsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsDeleteOptionalParams): Promise<void>;
    get(resourceGroupName: string, registryName: string, privateEndpointConnectionName: string, options?: PrivateEndpointConnectionsGetOptionalParams): Promise<PrivateEndpointConnectionsGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: PrivateEndpointConnectionsListOptionalParams): PagedAsyncIterableIterator<PrivateEndpointConnection>;
}

// @public
export interface PrivateEndpointConnectionsCreateOrUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface PrivateEndpointConnectionsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type PrivateEndpointConnectionsCreateOrUpdateResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface PrivateEndpointConnectionsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface PrivateEndpointConnectionsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsGetResponse = PrivateEndpointConnection;

// @public
export interface PrivateEndpointConnectionsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListNextResponse = PrivateEndpointConnectionListResult;

// @public
export interface PrivateEndpointConnectionsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type PrivateEndpointConnectionsListResponse = PrivateEndpointConnectionListResult;

// @public
export interface PrivateLinkResource {
    groupId?: string;
    id?: string;
    name?: string;
    requiredMembers?: string[];
    requiredZoneNames?: string[];
    readonly type?: string;
}

// @public
export interface PrivateLinkResourceListResult {
    nextLink?: string;
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkServiceConnectionState {
    actionsRequired?: ActionsRequired;
    description?: string;
    status?: ConnectionStatus;
}

// @public (undocumented)
export interface ProgressProperties {
    percentage?: string;
}

// @public
export type ProvisioningState = string;

// @public
export interface ProxyResource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export type PublicNetworkAccess = string;

// @public
export interface QuarantinePolicy {
    status?: PolicyStatus;
}

// @public
export interface RegenerateCredentialParameters {
    name: PasswordName;
}

// @public
export interface Registries {
    beginCreate(resourceGroupName: string, registryName: string, registry: Registry, options?: RegistriesCreateOptionalParams): Promise<SimplePollerLike<OperationState<RegistriesCreateResponse>, RegistriesCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, registry: Registry, options?: RegistriesCreateOptionalParams): Promise<RegistriesCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, options?: RegistriesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, options?: RegistriesDeleteOptionalParams): Promise<void>;
    beginGenerateCredentials(resourceGroupName: string, registryName: string, generateCredentialsParameters: GenerateCredentialsParameters, options?: RegistriesGenerateCredentialsOptionalParams): Promise<SimplePollerLike<OperationState<RegistriesGenerateCredentialsResponse>, RegistriesGenerateCredentialsResponse>>;
    beginGenerateCredentialsAndWait(resourceGroupName: string, registryName: string, generateCredentialsParameters: GenerateCredentialsParameters, options?: RegistriesGenerateCredentialsOptionalParams): Promise<RegistriesGenerateCredentialsResponse>;
    beginImportImage(resourceGroupName: string, registryName: string, parameters: ImportImageParameters, options?: RegistriesImportImageOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginImportImageAndWait(resourceGroupName: string, registryName: string, parameters: ImportImageParameters, options?: RegistriesImportImageOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, registryName: string, registryUpdateParameters: RegistryUpdateParameters, options?: RegistriesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<RegistriesUpdateResponse>, RegistriesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, registryName: string, registryUpdateParameters: RegistryUpdateParameters, options?: RegistriesUpdateOptionalParams): Promise<RegistriesUpdateResponse>;
    checkNameAvailability(registryNameCheckRequest: RegistryNameCheckRequest, options?: RegistriesCheckNameAvailabilityOptionalParams): Promise<RegistriesCheckNameAvailabilityResponse>;
    get(resourceGroupName: string, registryName: string, options?: RegistriesGetOptionalParams): Promise<RegistriesGetResponse>;
    getPrivateLinkResource(resourceGroupName: string, registryName: string, groupName: string, options?: RegistriesGetPrivateLinkResourceOptionalParams): Promise<RegistriesGetPrivateLinkResourceResponse>;
    list(options?: RegistriesListOptionalParams): PagedAsyncIterableIterator<Registry>;
    listByResourceGroup(resourceGroupName: string, options?: RegistriesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Registry>;
    listCredentials(resourceGroupName: string, registryName: string, options?: RegistriesListCredentialsOptionalParams): Promise<RegistriesListCredentialsResponse>;
    listPrivateLinkResources(resourceGroupName: string, registryName: string, options?: RegistriesListPrivateLinkResourcesOptionalParams): PagedAsyncIterableIterator<PrivateLinkResource>;
    listUsages(resourceGroupName: string, registryName: string, options?: RegistriesListUsagesOptionalParams): Promise<RegistriesListUsagesResponse>;
    regenerateCredential(resourceGroupName: string, registryName: string, regenerateCredentialParameters: RegenerateCredentialParameters, options?: RegistriesRegenerateCredentialOptionalParams): Promise<RegistriesRegenerateCredentialResponse>;
}

// @public
export interface RegistriesCheckNameAvailabilityOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesCheckNameAvailabilityResponse = RegistryNameStatus;

// @public
export interface RegistriesCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface RegistriesCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type RegistriesCreateResponse = Registry;

// @public
export interface RegistriesDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface RegistriesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface RegistriesGenerateCredentialsHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface RegistriesGenerateCredentialsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type RegistriesGenerateCredentialsResponse = GenerateCredentialsResult;

// @public
export interface RegistriesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface RegistriesGetPrivateLinkResourceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesGetPrivateLinkResourceResponse = PrivateLinkResource;

// @public
export type RegistriesGetResponse = Registry;

// @public
export interface RegistriesImportImageHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface RegistriesImportImageOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface RegistriesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesListByResourceGroupNextResponse = RegistryListResult;

// @public
export interface RegistriesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesListByResourceGroupResponse = RegistryListResult;

// @public
export interface RegistriesListCredentialsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesListCredentialsResponse = RegistryListCredentialsResult;

// @public
export interface RegistriesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesListNextResponse = RegistryListResult;

// @public
export interface RegistriesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface RegistriesListPrivateLinkResourcesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesListPrivateLinkResourcesNextResponse = PrivateLinkResourceListResult;

// @public
export interface RegistriesListPrivateLinkResourcesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesListPrivateLinkResourcesResponse = PrivateLinkResourceListResult;

// @public
export type RegistriesListResponse = RegistryListResult;

// @public
export interface RegistriesListUsagesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesListUsagesResponse = RegistryUsageListResult;

// @public
export interface RegistriesRegenerateCredentialOptionalParams extends coreClient.OperationOptions {
}

// @public
export type RegistriesRegenerateCredentialResponse = RegistryListCredentialsResult;

// @public
export interface RegistriesUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface RegistriesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type RegistriesUpdateResponse = Registry;

// @public
export interface Registry extends Resource {
    adminUserEnabled?: boolean;
    anonymousPullEnabled?: boolean;
    autoGeneratedDomainNameLabelScope?: AutoGeneratedDomainNameLabelScope;
    readonly creationDate?: Date;
    dataEndpointEnabled?: boolean;
    readonly dataEndpointHostNames?: string[];
    encryption?: EncryptionProperty;
    identity?: IdentityProperties;
    readonly loginServer?: string;
    metadataSearch?: MetadataSearch;
    networkRuleBypassAllowedForTasks?: boolean;
    networkRuleBypassOptions?: NetworkRuleBypassOptions;
    networkRuleSet?: NetworkRuleSet;
    policies?: Policies;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    readonly provisioningState?: ProvisioningState;
    publicNetworkAccess?: PublicNetworkAccess;
    roleAssignmentMode?: RoleAssignmentMode;
    sku: Sku;
    readonly status?: Status;
    zoneRedundancy?: ZoneRedundancy;
}

// @public
export interface RegistryListCredentialsResult {
    passwords?: RegistryPassword[];
    username?: string;
}

// @public
export interface RegistryListResult {
    nextLink?: string;
    value?: Registry[];
}

// @public
export interface RegistryNameCheckRequest {
    autoGeneratedDomainNameLabelScope?: AutoGeneratedDomainNameLabelScope;
    name: string;
    resourceGroupName?: string;
    type: "Microsoft.ContainerRegistry/registries";
}

// @public
export interface RegistryNameStatus {
    availableLoginServerName?: string;
    message?: string;
    nameAvailable?: boolean;
    reason?: string;
}

// @public
export interface RegistryPassword {
    name?: PasswordName;
    value?: string;
}

// @public
export interface RegistryUpdateParameters {
    adminUserEnabled?: boolean;
    anonymousPullEnabled?: boolean;
    dataEndpointEnabled?: boolean;
    encryption?: EncryptionProperty;
    identity?: IdentityProperties;
    metadataSearch?: MetadataSearch;
    networkRuleBypassAllowedForTasks?: boolean;
    networkRuleBypassOptions?: NetworkRuleBypassOptions;
    networkRuleSet?: NetworkRuleSet;
    policies?: Policies;
    publicNetworkAccess?: PublicNetworkAccess;
    roleAssignmentMode?: RoleAssignmentMode;
    sku?: Sku;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface RegistryUsage {
    currentValue?: number;
    limit?: number;
    name?: string;
    unit?: RegistryUsageUnit;
}

// @public
export interface RegistryUsageListResult {
    value?: RegistryUsage[];
}

// @public
export type RegistryUsageUnit = string;

// @public
export interface Replication extends Resource {
    readonly provisioningState?: ProvisioningState;
    regionEndpointEnabled?: boolean;
    readonly status?: Status;
    zoneRedundancy?: ZoneRedundancy;
}

// @public
export interface ReplicationListResult {
    nextLink?: string;
    value?: Replication[];
}

// @public
export interface Replications {
    beginCreate(resourceGroupName: string, registryName: string, replicationName: string, replication: Replication, options?: ReplicationsCreateOptionalParams): Promise<SimplePollerLike<OperationState<ReplicationsCreateResponse>, ReplicationsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, replicationName: string, replication: Replication, options?: ReplicationsCreateOptionalParams): Promise<ReplicationsCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, replicationName: string, options?: ReplicationsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, replicationName: string, options?: ReplicationsDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, registryName: string, replicationName: string, replicationUpdateParameters: ReplicationUpdateParameters, options?: ReplicationsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ReplicationsUpdateResponse>, ReplicationsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, registryName: string, replicationName: string, replicationUpdateParameters: ReplicationUpdateParameters, options?: ReplicationsUpdateOptionalParams): Promise<ReplicationsUpdateResponse>;
    get(resourceGroupName: string, registryName: string, replicationName: string, options?: ReplicationsGetOptionalParams): Promise<ReplicationsGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: ReplicationsListOptionalParams): PagedAsyncIterableIterator<Replication>;
}

// @public
export interface ReplicationsCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ReplicationsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ReplicationsCreateResponse = Replication;

// @public
export interface ReplicationsDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ReplicationsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ReplicationsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ReplicationsGetResponse = Replication;

// @public
export interface ReplicationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ReplicationsListNextResponse = ReplicationListResult;

// @public
export interface ReplicationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ReplicationsListResponse = ReplicationListResult;

// @public
export interface ReplicationsUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ReplicationsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ReplicationsUpdateResponse = Replication;

// @public
export interface ReplicationUpdateParameters {
    regionEndpointEnabled?: boolean;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
interface Request_2 {
    addr?: string;
    host?: string;
    id?: string;
    method?: string;
    useragent?: string;
}
export { Request_2 as Request }

// @public
export interface Resource {
    readonly id?: string;
    location: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export type ResourceIdentityType = "SystemAssigned" | "UserAssigned" | "SystemAssigned, UserAssigned" | "None";

// @public
export interface RetentionPolicy {
    days?: number;
    readonly lastUpdatedTime?: Date;
    status?: PolicyStatus;
}

// @public
export type RoleAssignmentMode = string;

// @public
export interface ScopeMap extends ProxyResource {
    actions?: string[];
    readonly creationDate?: Date;
    description?: string;
    readonly provisioningState?: ProvisioningState;
    readonly typePropertiesType?: string;
}

// @public
export interface ScopeMapListResult {
    nextLink?: string;
    value?: ScopeMap[];
}

// @public
export interface ScopeMaps {
    beginCreate(resourceGroupName: string, registryName: string, scopeMapName: string, scopeMapCreateParameters: ScopeMap, options?: ScopeMapsCreateOptionalParams): Promise<SimplePollerLike<OperationState<ScopeMapsCreateResponse>, ScopeMapsCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, scopeMapName: string, scopeMapCreateParameters: ScopeMap, options?: ScopeMapsCreateOptionalParams): Promise<ScopeMapsCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, scopeMapName: string, options?: ScopeMapsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, scopeMapName: string, options?: ScopeMapsDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, registryName: string, scopeMapName: string, scopeMapUpdateParameters: ScopeMapUpdateParameters, options?: ScopeMapsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<ScopeMapsUpdateResponse>, ScopeMapsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, registryName: string, scopeMapName: string, scopeMapUpdateParameters: ScopeMapUpdateParameters, options?: ScopeMapsUpdateOptionalParams): Promise<ScopeMapsUpdateResponse>;
    get(resourceGroupName: string, registryName: string, scopeMapName: string, options?: ScopeMapsGetOptionalParams): Promise<ScopeMapsGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: ScopeMapsListOptionalParams): PagedAsyncIterableIterator<ScopeMap>;
}

// @public
export interface ScopeMapsCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ScopeMapsCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ScopeMapsCreateResponse = ScopeMap;

// @public
export interface ScopeMapsDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface ScopeMapsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ScopeMapsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScopeMapsGetResponse = ScopeMap;

// @public
export interface ScopeMapsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScopeMapsListNextResponse = ScopeMapListResult;

// @public
export interface ScopeMapsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ScopeMapsListResponse = ScopeMapListResult;

// @public
export interface ScopeMapsUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface ScopeMapsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ScopeMapsUpdateResponse = ScopeMap;

// @public
export interface ScopeMapUpdateParameters {
    actions?: string[];
    description?: string;
}

// @public
export interface Sku {
    name: SkuName;
    readonly tier?: SkuTier;
}

// @public
export type SkuName = string;

// @public
export type SkuTier = string;

// @public
export interface SoftDeletePolicy {
    readonly lastUpdatedTime?: Date;
    retentionDays?: number;
    status?: PolicyStatus;
}

// @public
export interface Source {
    addr?: string;
    instanceID?: string;
}

// @public
export interface Status {
    readonly displayStatus?: string;
    readonly message?: string;
    readonly timestamp?: Date;
}

// @public
export interface StatusDetailProperties {
    readonly code?: string;
    readonly correlationId?: string;
    readonly description?: string;
    readonly timestamp?: Date;
    readonly type?: string;
}

// @public
export interface StorageAccountProperties {
    id: string;
}

// @public
export interface SyncProperties {
    readonly gatewayEndpoint?: string;
    readonly lastSyncTime?: Date;
    messageTtl: string;
    schedule?: string;
    syncWindow?: string;
    tokenId: string;
}

// @public
export interface SyncUpdateProperties {
    messageTtl?: string;
    schedule?: string;
    syncWindow?: string;
}

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: LastModifiedByType;
}

// @public
export interface Target {
    digest?: string;
    length?: number;
    mediaType?: string;
    name?: string;
    repository?: string;
    size?: number;
    tag?: string;
    url?: string;
    version?: string;
}

// @public
export interface TlsCertificateProperties {
    readonly location?: string;
    readonly type?: CertificateType;
}

// @public
export interface TlsProperties {
    readonly certificate?: TlsCertificateProperties;
    readonly status?: TlsStatus;
}

// @public
export type TlsStatus = string;

// @public
export interface Token extends ProxyResource {
    readonly creationDate?: Date;
    credentials?: TokenCredentialsProperties;
    readonly provisioningState?: ProvisioningState;
    scopeMapId?: string;
    status?: TokenStatus;
}

// @public
export interface TokenCertificate {
    encodedPemCertificate?: string;
    expiry?: Date;
    // (undocumented)
    name?: TokenCertificateName;
    thumbprint?: string;
}

// @public
export type TokenCertificateName = string;

// @public
export interface TokenCredentialsProperties {
    // (undocumented)
    certificates?: TokenCertificate[];
    // (undocumented)
    passwords?: TokenPassword[];
}

// @public
export interface TokenListResult {
    nextLink?: string;
    value?: Token[];
}

// @public
export interface TokenPassword {
    creationTime?: Date;
    expiry?: Date;
    name?: TokenPasswordName;
    readonly value?: string;
}

// @public
export type TokenPasswordName = string;

// @public
export interface Tokens {
    beginCreate(resourceGroupName: string, registryName: string, tokenName: string, tokenCreateParameters: Token, options?: TokensCreateOptionalParams): Promise<SimplePollerLike<OperationState<TokensCreateResponse>, TokensCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, tokenName: string, tokenCreateParameters: Token, options?: TokensCreateOptionalParams): Promise<TokensCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, tokenName: string, options?: TokensDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, tokenName: string, options?: TokensDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, registryName: string, tokenName: string, tokenUpdateParameters: TokenUpdateParameters, options?: TokensUpdateOptionalParams): Promise<SimplePollerLike<OperationState<TokensUpdateResponse>, TokensUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, registryName: string, tokenName: string, tokenUpdateParameters: TokenUpdateParameters, options?: TokensUpdateOptionalParams): Promise<TokensUpdateResponse>;
    get(resourceGroupName: string, registryName: string, tokenName: string, options?: TokensGetOptionalParams): Promise<TokensGetResponse>;
    list(resourceGroupName: string, registryName: string, options?: TokensListOptionalParams): PagedAsyncIterableIterator<Token>;
}

// @public
export interface TokensCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface TokensCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TokensCreateResponse = Token;

// @public
export interface TokensDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface TokensDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface TokensGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TokensGetResponse = Token;

// @public
export interface TokensListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TokensListNextResponse = TokenListResult;

// @public
export interface TokensListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type TokensListResponse = TokenListResult;

// @public
export type TokenStatus = string;

// @public
export interface TokensUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface TokensUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type TokensUpdateResponse = Token;

// @public
export interface TokenUpdateParameters {
    credentials?: TokenCredentialsProperties;
    scopeMapId?: string;
    status?: TokenStatus;
}

// @public
export type TriggerStatus = string;

// @public
export interface TrustPolicy {
    status?: PolicyStatus;
    type?: TrustPolicyType;
}

// @public
export type TrustPolicyType = string;

// @public (undocumented)
export interface UserIdentityProperties {
    readonly clientId?: string;
    readonly principalId?: string;
}

// @public
export interface Webhook extends Resource {
    actions?: WebhookAction[];
    readonly provisioningState?: ProvisioningState;
    scope?: string;
    status?: WebhookStatus;
}

// @public
export type WebhookAction = string;

// @public
export interface WebhookCreateParameters {
    actions?: WebhookAction[];
    customHeaders?: {
        [propertyName: string]: string;
    };
    location: string;
    scope?: string;
    serviceUri?: string;
    status?: WebhookStatus;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface WebhookListResult {
    nextLink?: string;
    value?: Webhook[];
}

// @public
export interface Webhooks {
    beginCreate(resourceGroupName: string, registryName: string, webhookName: string, webhookCreateParameters: WebhookCreateParameters, options?: WebhooksCreateOptionalParams): Promise<SimplePollerLike<OperationState<WebhooksCreateResponse>, WebhooksCreateResponse>>;
    beginCreateAndWait(resourceGroupName: string, registryName: string, webhookName: string, webhookCreateParameters: WebhookCreateParameters, options?: WebhooksCreateOptionalParams): Promise<WebhooksCreateResponse>;
    beginDelete(resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, registryName: string, webhookName: string, webhookUpdateParameters: WebhookUpdateParameters, options?: WebhooksUpdateOptionalParams): Promise<SimplePollerLike<OperationState<WebhooksUpdateResponse>, WebhooksUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, registryName: string, webhookName: string, webhookUpdateParameters: WebhookUpdateParameters, options?: WebhooksUpdateOptionalParams): Promise<WebhooksUpdateResponse>;
    get(resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksGetOptionalParams): Promise<WebhooksGetResponse>;
    getCallbackConfig(resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksGetCallbackConfigOptionalParams): Promise<WebhooksGetCallbackConfigResponse>;
    list(resourceGroupName: string, registryName: string, options?: WebhooksListOptionalParams): PagedAsyncIterableIterator<Webhook>;
    listEvents(resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksListEventsOptionalParams): PagedAsyncIterableIterator<Event_2>;
    ping(resourceGroupName: string, registryName: string, webhookName: string, options?: WebhooksPingOptionalParams): Promise<WebhooksPingResponse>;
}

// @public
export interface WebhooksCreateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface WebhooksCreateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type WebhooksCreateResponse = Webhook;

// @public
export interface WebhooksDeleteHeaders {
    // (undocumented)
    location?: string;
}

// @public
export interface WebhooksDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface WebhooksGetCallbackConfigOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WebhooksGetCallbackConfigResponse = CallbackConfig;

// @public
export interface WebhooksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WebhooksGetResponse = Webhook;

// @public
export interface WebhooksListEventsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WebhooksListEventsNextResponse = EventListResult;

// @public
export interface WebhooksListEventsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WebhooksListEventsResponse = EventListResult;

// @public
export interface WebhooksListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WebhooksListNextResponse = WebhookListResult;

// @public
export interface WebhooksListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WebhooksListResponse = WebhookListResult;

// @public
export interface WebhooksPingOptionalParams extends coreClient.OperationOptions {
}

// @public
export type WebhooksPingResponse = EventInfo;

// @public
export type WebhookStatus = string;

// @public
export interface WebhooksUpdateHeaders {
    // (undocumented)
    azureAsyncOperation?: string;
}

// @public
export interface WebhooksUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type WebhooksUpdateResponse = Webhook;

// @public
export interface WebhookUpdateParameters {
    actions?: WebhookAction[];
    customHeaders?: {
        [propertyName: string]: string;
    };
    scope?: string;
    serviceUri?: string;
    status?: WebhookStatus;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type ZoneRedundancy = string;

// (No @packageDocumentation comment for this package)

```
