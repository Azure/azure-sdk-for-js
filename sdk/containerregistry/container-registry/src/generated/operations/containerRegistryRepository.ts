/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { GeneratedClient } from "../generatedClient";
import {
  ContainerRegistryRepositoryGetManifestOptionalParams,
  ContainerRegistryRepositoryGetManifestResponse,
  Manifest,
  ContainerRegistryRepositoryCreateManifestResponse,
  ContainerRegistryRepositoryGetPropertiesResponse,
  ContainerRegistryRepositorySetPropertiesOptionalParams,
  ContainerRegistryRepositoryGetTagsOptionalParams,
  ContainerRegistryRepositoryGetTagsResponse,
  ContainerRegistryRepositoryGetTagPropertiesResponse,
  ContainerRegistryRepositoryUpdateTagAttributesOptionalParams,
  ContainerRegistryRepositoryGetManifestsOptionalParams,
  ContainerRegistryRepositoryGetManifestsResponse,
  ContainerRegistryRepositoryGetRegistryArtifactPropertiesResponse,
  ContainerRegistryRepositoryUpdateManifestAttributesOptionalParams,
  ContainerRegistryRepositoryGetTagsNextOptionalParams,
  ContainerRegistryRepositoryGetTagsNextResponse,
  ContainerRegistryRepositoryGetManifestsNextOptionalParams,
  ContainerRegistryRepositoryGetManifestsNextResponse
} from "../models";

/** Class representing a ContainerRegistryRepository. */
export class ContainerRegistryRepository {
  private readonly client: GeneratedClient;

  /**
   * Initialize a new instance of the class ContainerRegistryRepository class.
   * @param client Reference to the service client
   */
  constructor(client: GeneratedClient) {
    this.client = client;
  }

  /**
   * Get the manifest identified by `name` and `reference` where `reference` can be a tag or digest.
   * @param name Name of the image (including the namespace)
   * @param reference A tag or a digest, pointing to a specific image
   * @param options The options parameters.
   */
  getManifest(
    name: string,
    reference: string,
    options?: ContainerRegistryRepositoryGetManifestOptionalParams
  ): Promise<ContainerRegistryRepositoryGetManifestResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      reference,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getManifestOperationSpec
    ) as Promise<ContainerRegistryRepositoryGetManifestResponse>;
  }

  /**
   * Put the manifest identified by `name` and `reference` where `reference` can be a tag or digest.
   * @param name Name of the image (including the namespace)
   * @param reference A tag or a digest, pointing to a specific image
   * @param payload Manifest body, can take v1 or v2 values depending on accept header
   * @param options The options parameters.
   */
  createManifest(
    name: string,
    reference: string,
    payload: Manifest,
    options?: coreHttp.OperationOptions
  ): Promise<ContainerRegistryRepositoryCreateManifestResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      reference,
      payload,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      createManifestOperationSpec
    ) as Promise<ContainerRegistryRepositoryCreateManifestResponse>;
  }

  /**
   * Delete the manifest identified by `name` and `reference`. Note that a manifest can _only_ be deleted
   * by `digest`.
   * @param name Name of the image (including the namespace)
   * @param reference Digest of a BLOB
   * @param options The options parameters.
   */
  deleteManifest(
    name: string,
    reference: string,
    options?: coreHttp.OperationOptions
  ): Promise<coreHttp.RestResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      reference,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      deleteManifestOperationSpec
    ) as Promise<coreHttp.RestResponse>;
  }

  /**
   * Get repository attributes
   * @param name Name of the image (including the namespace)
   * @param options The options parameters.
   */
  getProperties(
    name: string,
    options?: coreHttp.OperationOptions
  ): Promise<ContainerRegistryRepositoryGetPropertiesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getPropertiesOperationSpec
    ) as Promise<ContainerRegistryRepositoryGetPropertiesResponse>;
  }

  /**
   * Update the attribute identified by `name` where `reference` is the name of the repository.
   * @param name Name of the image (including the namespace)
   * @param options The options parameters.
   */
  setProperties(
    name: string,
    options?: ContainerRegistryRepositorySetPropertiesOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      setPropertiesOperationSpec
    ) as Promise<coreHttp.RestResponse>;
  }

  /**
   * List tags of a repository
   * @param name Name of the image (including the namespace)
   * @param options The options parameters.
   */
  getTags(
    name: string,
    options?: ContainerRegistryRepositoryGetTagsOptionalParams
  ): Promise<ContainerRegistryRepositoryGetTagsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getTagsOperationSpec
    ) as Promise<ContainerRegistryRepositoryGetTagsResponse>;
  }

  /**
   * Get tag attributes by tag
   * @param name Name of the image (including the namespace)
   * @param reference Tag name
   * @param options The options parameters.
   */
  getTagProperties(
    name: string,
    reference: string,
    options?: coreHttp.OperationOptions
  ): Promise<ContainerRegistryRepositoryGetTagPropertiesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      reference,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getTagPropertiesOperationSpec
    ) as Promise<ContainerRegistryRepositoryGetTagPropertiesResponse>;
  }

  /**
   * Update tag attributes
   * @param name Name of the image (including the namespace)
   * @param reference Tag name
   * @param options The options parameters.
   */
  updateTagAttributes(
    name: string,
    reference: string,
    options?: ContainerRegistryRepositoryUpdateTagAttributesOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      reference,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      updateTagAttributesOperationSpec
    ) as Promise<coreHttp.RestResponse>;
  }

  /**
   * Delete tag
   * @param name Name of the image (including the namespace)
   * @param reference Tag name
   * @param options The options parameters.
   */
  deleteTag(
    name: string,
    reference: string,
    options?: coreHttp.OperationOptions
  ): Promise<coreHttp.RestResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      reference,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      deleteTagOperationSpec
    ) as Promise<coreHttp.RestResponse>;
  }

  /**
   * List manifests of a repository
   * @param name Name of the image (including the namespace)
   * @param options The options parameters.
   */
  getManifests(
    name: string,
    options?: ContainerRegistryRepositoryGetManifestsOptionalParams
  ): Promise<ContainerRegistryRepositoryGetManifestsResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getManifestsOperationSpec
    ) as Promise<ContainerRegistryRepositoryGetManifestsResponse>;
  }

  /**
   * Get manifest attributes
   * @param name Name of the image (including the namespace)
   * @param digest Digest of a BLOB
   * @param options The options parameters.
   */
  getRegistryArtifactProperties(
    name: string,
    digest: string,
    options?: coreHttp.OperationOptions
  ): Promise<ContainerRegistryRepositoryGetRegistryArtifactPropertiesResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      digest,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getRegistryArtifactPropertiesOperationSpec
    ) as Promise<
      ContainerRegistryRepositoryGetRegistryArtifactPropertiesResponse
    >;
  }

  /**
   * Update attributes of a manifest
   * @param name Name of the image (including the namespace)
   * @param digest Digest of a BLOB
   * @param options The options parameters.
   */
  updateManifestAttributes(
    name: string,
    digest: string,
    options?: ContainerRegistryRepositoryUpdateManifestAttributesOptionalParams
  ): Promise<coreHttp.RestResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      digest,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      updateManifestAttributesOperationSpec
    ) as Promise<coreHttp.RestResponse>;
  }

  /**
   * GetTagsNext
   * @param name Name of the image (including the namespace)
   * @param nextLink The nextLink from the previous successful call to the GetTags method.
   * @param options The options parameters.
   */
  getTagsNext(
    name: string,
    nextLink: string,
    options?: ContainerRegistryRepositoryGetTagsNextOptionalParams
  ): Promise<ContainerRegistryRepositoryGetTagsNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getTagsNextOperationSpec
    ) as Promise<ContainerRegistryRepositoryGetTagsNextResponse>;
  }

  /**
   * GetManifestsNext
   * @param name Name of the image (including the namespace)
   * @param nextLink The nextLink from the previous successful call to the GetManifests method.
   * @param options The options parameters.
   */
  getManifestsNext(
    name: string,
    nextLink: string,
    options?: ContainerRegistryRepositoryGetManifestsNextOptionalParams
  ): Promise<ContainerRegistryRepositoryGetManifestsNextResponse> {
    const operationArguments: coreHttp.OperationArguments = {
      name,
      nextLink,
      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
    };
    return this.client.sendOperationRequest(
      operationArguments,
      getManifestsNextOperationSpec
    ) as Promise<ContainerRegistryRepositoryGetManifestsNextResponse>;
  }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);

const getManifestOperationSpec: coreHttp.OperationSpec = {
  path: "/v2/{name}/manifests/{reference}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.Manifest
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  urlParameters: [Parameters.url, Parameters.name, Parameters.reference],
  headerParameters: [Parameters.accept, Parameters.accept1],
  serializer
};
const createManifestOperationSpec: coreHttp.OperationSpec = {
  path: "/v2/{name}/manifests/{reference}",
  httpMethod: "PUT",
  responses: {
    201: {
      bodyMapper: { type: { name: "any" } },
      headersMapper: Mappers.ContainerRegistryRepositoryCreateManifestHeaders
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  requestBody: Parameters.payload,
  urlParameters: [Parameters.url, Parameters.name, Parameters.reference],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteManifestOperationSpec: coreHttp.OperationSpec = {
  path: "/v2/{name}/manifests/{reference}",
  httpMethod: "DELETE",
  responses: {
    202: {},
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  urlParameters: [Parameters.url, Parameters.name, Parameters.reference],
  headerParameters: [Parameters.accept],
  serializer
};
const getPropertiesOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.RepositoryProperties
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  urlParameters: [Parameters.url, Parameters.name],
  headerParameters: [Parameters.accept],
  serializer
};
const setPropertiesOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}",
  httpMethod: "PATCH",
  responses: {
    200: {},
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  requestBody: Parameters.value,
  urlParameters: [Parameters.url, Parameters.name],
  headerParameters: [Parameters.accept, Parameters.contentType1],
  mediaType: "json",
  serializer
};
const getTagsOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}/_tags",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.TagList,
      headersMapper: Mappers.ContainerRegistryRepositoryGetTagsHeaders
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  queryParameters: [
    Parameters.last,
    Parameters.n,
    Parameters.orderby,
    Parameters.digest
  ],
  urlParameters: [Parameters.url, Parameters.name],
  headerParameters: [Parameters.accept],
  serializer
};
const getTagPropertiesOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}/_tags/{reference}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.TagProperties
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  urlParameters: [Parameters.url, Parameters.name, Parameters.reference],
  headerParameters: [Parameters.accept],
  serializer
};
const updateTagAttributesOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}/_tags/{reference}",
  httpMethod: "PATCH",
  responses: {
    200: {},
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  requestBody: Parameters.value,
  urlParameters: [Parameters.url, Parameters.name, Parameters.reference],
  headerParameters: [Parameters.accept, Parameters.contentType1],
  mediaType: "json",
  serializer
};
const deleteTagOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}/_tags/{reference}",
  httpMethod: "DELETE",
  responses: {
    202: {},
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  urlParameters: [Parameters.url, Parameters.name, Parameters.reference],
  headerParameters: [Parameters.accept],
  serializer
};
const getManifestsOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}/_manifests",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.AcrManifests,
      headersMapper: Mappers.ContainerRegistryRepositoryGetManifestsHeaders
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  queryParameters: [Parameters.last, Parameters.n, Parameters.orderby],
  urlParameters: [Parameters.url, Parameters.name],
  headerParameters: [Parameters.accept],
  serializer
};
const getRegistryArtifactPropertiesOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}/_manifests/{digest}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.RegistryArtifactProperties
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  urlParameters: [Parameters.url, Parameters.name, Parameters.digest1],
  headerParameters: [Parameters.accept],
  serializer
};
const updateManifestAttributesOperationSpec: coreHttp.OperationSpec = {
  path: "/acr/v1/{name}/_manifests/{digest}",
  httpMethod: "PATCH",
  responses: {
    200: {},
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  requestBody: Parameters.value,
  urlParameters: [Parameters.url, Parameters.name, Parameters.digest1],
  headerParameters: [Parameters.accept, Parameters.contentType1],
  mediaType: "json",
  serializer
};
const getTagsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.TagList,
      headersMapper: Mappers.ContainerRegistryRepositoryGetTagsNextHeaders
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  queryParameters: [
    Parameters.last,
    Parameters.n,
    Parameters.orderby,
    Parameters.digest
  ],
  urlParameters: [Parameters.url, Parameters.name, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
const getManifestsNextOperationSpec: coreHttp.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.AcrManifests,
      headersMapper: Mappers.ContainerRegistryRepositoryGetManifestsNextHeaders
    },
    default: {
      bodyMapper: Mappers.AcrErrors
    }
  },
  queryParameters: [Parameters.last, Parameters.n, Parameters.orderby],
  urlParameters: [Parameters.url, Parameters.name, Parameters.nextLink],
  headerParameters: [Parameters.accept],
  serializer
};
