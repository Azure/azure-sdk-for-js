/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";

/** Acr error response describing why the operation failed */
export interface AcrErrors {
  /** Array of detailed error */
  errors?: AcrErrorInfo[];
}

/** Error information */
export interface AcrErrorInfo {
  /** Error code */
  code?: string;
  /** Error message */
  message?: string;
  /** Error details */
  detail?: any;
}

/** Returns the requested manifest file */
export interface Manifest {
  /** Schema version */
  schemaVersion?: number;
}

/** List of repositories */
export interface Repositories {
  /** Repository names */
  names?: string[];
}

/** Repository attributes */
export interface RepositoryAttributes {
  /** Registry name */
  registry?: string;
  /** Image name */
  name?: string;
  /** Image created time */
  createdOn?: Date;
  /** Image last update time */
  lastUpdatedOn?: Date;
  /** Number of the manifests */
  registryArtifactCount?: number;
  /** Number of the tags */
  tagCount?: number;
  /** Changeable attributes */
  writeableProperties?: ChangeableAttributes;
}

export interface ChangeableAttributes {
  /** Delete enabled */
  canDelete?: boolean;
  /** Write enabled */
  canWrite?: boolean;
  /** List enabled */
  canList?: boolean;
  /** Read enabled */
  canRead?: boolean;
}

/** Deleted repository */
export interface DeletedRepository {
  /** SHA of the deleted image */
  deletedRegistryArtifactDigests?: string[];
  /** Tag of the deleted image */
  deletedTags?: string[];
}

/** List of tag details */
export interface TagList {
  /** Registry name */
  registry?: string;
  /** Image name */
  imageName?: string;
  /** List of tag attribute details */
  tags?: TagAttributesBase[];
}

/** Tag attribute details */
export interface TagAttributesBase {
  /** Tag name */
  name?: string;
  /** Tag digest */
  digest?: string;
  /** Tag created time */
  createdOn?: Date;
  /** Tag last update time */
  lastUpdatedOn?: Date;
  /** Changeable attributes */
  modifiableProperties?: ChangeableAttributes;
}

/** Tag attributes */
export interface TagAttributes {
  /** Registry name */
  registry?: string;
  /** Image name */
  repository?: string;
  /** Tag name */
  name?: string;
  /** Tag digest */
  digest?: string;
  /** Tag created time */
  createdOn?: Date;
  /** Tag last update time */
  lastUpdatedOn?: Date;
  /** Changeable attributes */
  modifiableProperties?: ChangeableAttributes;
}

/** Manifest attributes */
export interface AcrManifests {
  /** Registry name */
  registry?: string;
  /** Image name */
  imageName?: string;
  /** List of manifests */
  manifestsAttributes?: ManifestAttributesBase[];
}

/** Manifest details */
export interface ManifestAttributesBase {
  /** Manifest */
  digest?: string;
  /** Image size */
  size?: number;
  /** Created time */
  createdOn?: Date;
  /** Last update time */
  lastUpdatedOn?: Date;
  /** CPU architecture */
  cpuArchitecture?: string;
  /** Operating system */
  operatingSystem?: string;
  /** Media type */
  manifestMediaType?: string;
  /** Config blob media type */
  configMediaType?: string;
  /** List of tags */
  tags?: string[];
  /** Changeable attributes */
  manifestProperties?: ChangeableAttributes;
}

/** Manifest attributes details */
export interface ManifestAttributes {
  /** Registry name */
  registry?: string;
  /** Image name */
  repository?: string;
  /** Manifest */
  digest?: string;
  /** Image size */
  size?: number;
  /** Created time */
  createdOn?: Date;
  /** Last update time */
  lastUpdatedOn?: Date;
  /** CPU architecture */
  cpuArchitecture?: string;
  /** Operating system */
  operatingSystem?: string;
  /** Media type */
  manifestMediaType?: string;
  /** Config blob media type */
  configMediaType?: string;
  /** List of tags */
  tags?: string[];
  /** Changeable attributes */
  manifestProperties?: ChangeableAttributes;
}

export interface Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema {
  /** Can take a value of access_token_refresh_token, or access_token, or refresh_token */
  grantType: PostContentSchemaGrantType;
  /** Indicates the name of your Azure container registry. */
  service: string;
  /** AAD tenant associated to the AAD credentials. */
  tenant?: string;
  /** AAD refresh token, mandatory when grant_type is access_token_refresh_token or refresh_token */
  refreshToken?: string;
  /** AAD access token, mandatory when grant_type is access_token_refresh_token or access_token. */
  accessToken?: string;
}

export interface RefreshToken {
  /** The refresh token to be used for generating access tokens */
  refreshToken?: string;
}

export interface PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema {
  /** Grant type is expected to be refresh_token */
  grantType: "refresh_token";
  /** Indicates the name of your Azure container registry. */
  service: string;
  /** Which is expected to be a valid scope, and can be specified more than once for multiple scope requests. You obtained this from the Www-Authenticate response header from the challenge. */
  scope: string;
  /** Must be a valid ACR refresh token */
  refreshToken: string;
}

export interface AccessToken {
  /** The access token for performing authenticated requests */
  accessToken?: string;
}

/** Result of the request to list tags of the image */
export interface RepositoryTags {
  /** Name of the image */
  name?: string;
  /** List of tags */
  tags?: string[];
}

/** Signature of a signed manifest */
export interface ImageSignature {
  /** A JSON web signature */
  header?: Jwk;
  /** A signature for the image manifest, signed by a libtrust private key */
  signature?: string;
  /** The signed protected header */
  protected?: string;
}

/** A JSON web signature */
export interface Jwk {
  /** JSON web key parameter */
  jwk?: JWKHeader;
  /** The algorithm used to sign or encrypt the JWT */
  alg?: string;
}

/** JSON web key parameter */
export interface JWKHeader {
  /** crv value */
  crv?: string;
  /** kid value */
  kid?: string;
  /** kty value */
  kty?: string;
  /** x value */
  x?: string;
  /** y value */
  y?: string;
}

/** A list of unstructured historical data for v1 compatibility */
export interface History {
  /** The raw v1 compatibility information */
  v1Compatibility?: string;
}

/** Image layer information */
export interface FsLayer {
  /** SHA of an image layer */
  blobSum?: string;
}

/** Docker V2 image layer descriptor including config and layers */
export interface Descriptor {
  /** Layer media type */
  mediaType?: string;
  /** Layer size */
  size?: number;
  /** Layer digest */
  digest?: string;
  /** Specifies a list of URIs from which this object may be downloaded. */
  urls?: string[];
  /** Additional information provided through arbitrary metadata. */
  annotations?: Annotations | null;
}

/** Additional information provided through arbitrary metadata. */
export interface Annotations {
  /** Describes unknown properties. The value of an unknown property can be of "any" type. */
  [property: string]: any;
  /** Date and time on which the image was built (string, date-time as defined by https://tools.ietf.org/html/rfc3339#section-5.6) */
  created?: Date;
  /** Contact details of the people or organization responsible for the image. */
  authors?: string;
  /** URL to find more information on the image. */
  url?: string;
  /** URL to get documentation on the image. */
  documentation?: string;
  /** URL to get source code for building the image. */
  source?: string;
  /** Version of the packaged software. The version MAY match a label or tag in the source code repository, may also be Semantic versioning-compatible */
  version?: string;
  /** Source control revision identifier for the packaged software. */
  revision?: string;
  /** Name of the distributing entity, organization or individual. */
  vendor?: string;
  /** License(s) under which contained software is distributed as an SPDX License Expression. */
  licenses?: string;
  /** Name of the reference for a target. */
  name?: string;
  /** Human-readable title of the image */
  title?: string;
  /** Human-readable description of the software packaged in the image */
  description?: string;
}

/** Tag */
export interface TagAttributesTag {
  /** SignatureRecord value */
  signatureRecord?: string;
}

/** Manifest attributes details */
export interface ManifestAttributesManifestReferences {
  /** Manifest digest */
  digest?: string;
  /** CPU architecture */
  architecture?: string;
  /** Operating system */
  os?: string;
}

/** List of manifest attributes */
export interface ManifestAttributesManifest {
  /** List of manifest attributes details */
  references?: ManifestAttributesManifestReferences[];
  /** Quarantine tag name */
  quarantineTag?: string;
}

/** Changeable attributes */
export interface ManifestChangeableAttributes {
  /** Delete enabled */
  deleteEnabled?: boolean;
  /** Write enabled */
  writeEnabled?: boolean;
  /** List enabled */
  listEnabled?: boolean;
  /** Read enabled */
  readEnabled?: boolean;
  /** Quarantine state */
  quarantineState?: string;
  /** Quarantine details */
  quarantineDetails?: string;
}

export interface ManifestListAttributes {
  /** The MIME type of the referenced object. This will generally be application/vnd.docker.image.manifest.v2+json, but it could also be application/vnd.docker.image.manifest.v1+json */
  mediaType?: string;
  /** The size in bytes of the object */
  size?: number;
  /** The digest of the content, as defined by the Registry V2 HTTP API Specification */
  digest?: string;
  /** The platform object describes the platform which the image in the manifest runs on. A full list of valid operating system and architecture values are listed in the Go language documentation for $GOOS and $GOARCH */
  platform?: Platform;
}

/** The platform object describes the platform which the image in the manifest runs on. A full list of valid operating system and architecture values are listed in the Go language documentation for $GOOS and $GOARCH */
export interface Platform {
  /** Specifies the CPU architecture, for example amd64 or ppc64le. */
  architecture?: string;
  /** The os field specifies the operating system, for example linux or windows. */
  os?: string;
  /** The optional os.version field specifies the operating system version, for example 10.0.10586. */
  osVersion?: string;
  /** The optional os.features field specifies an array of strings, each listing a required OS feature (for example on Windows win32k */
  osFeatures?: string[];
  /** The optional variant field specifies a variant of the CPU, for example armv6l to specify a particular CPU variant of the ARM CPU. */
  variant?: string;
  /** The optional features field specifies an array of strings, each listing a required CPU feature (for example sse4 or aes */
  features?: string[];
}

/** Returns the requested manifest file */
export type ManifestWrapper = Manifest & {
  /** Media type for this Manifest */
  mediaType?: string;
  /** (ManifestList, OCIIndex) List of V2 image layer information */
  manifests?: ManifestListAttributes[];
  /** (V2, OCI) Image config descriptor */
  config?: Descriptor;
  /** (V2, OCI) List of V2 image layer information */
  layers?: Descriptor[];
  /** (OCI, OCIIndex) Additional metadata */
  annotations?: Annotations | null;
  /** (V1) CPU architecture */
  architecture?: string;
  /** (V1) Image name */
  name?: string;
  /** (V1) Image tag */
  tag?: string;
  /** (V1) List of layer information */
  fsLayers?: FsLayer[];
  /** (V1) Image history */
  history?: History[];
  /** (V1) Image signature */
  signatures?: ImageSignature[];
};

/** Returns the requested Docker multi-arch-manifest file */
export type ManifestList = Manifest & {
  /** Media type for this Manifest */
  mediaType?: string;
  /** List of V2 image layer information */
  manifests?: ManifestListAttributes[];
};

/** Returns the requested Docker V2 Manifest file */
export type V2Manifest = Manifest & {
  /** Media type for this Manifest */
  mediaType?: string;
  /** V2 image config descriptor */
  config?: Descriptor;
  /** List of V2 image layer information */
  layers?: Descriptor[];
};

/** Returns the requested OCI Manifest file */
export type OCIManifest = Manifest & {
  /** V2 image config descriptor */
  config?: Descriptor;
  /** List of V2 image layer information */
  layers?: Descriptor[];
  /** Additional information provided through arbitrary metadata. */
  annotations?: Annotations | null;
};

/** Returns the requested OCI index file */
export type OCIIndex = Manifest & {
  /** List of OCI image layer information */
  manifests?: ManifestListAttributes[];
  /** Additional information provided through arbitrary metadata. */
  annotations?: Annotations | null;
};

/** Returns the requested V1 manifest file */
export type V1Manifest = Manifest & {
  /** CPU architecture */
  architecture?: string;
  /** Image name */
  name?: string;
  /** Image tag */
  tag?: string;
  /** List of layer information */
  fsLayers?: FsLayer[];
  /** Image history */
  history?: History[];
  /** Image signature */
  signatures?: ImageSignature[];
};

/** Defines headers for ContainerRegistry_getRepositories operation. */
export interface ContainerRegistryGetRepositoriesHeaders {
  /** next paginated result */
  link?: string;
}

/** Defines headers for ContainerRegistry_getRepositoriesNext operation. */
export interface ContainerRegistryGetRepositoriesNextHeaders {
  /** next paginated result */
  link?: string;
}

/** Defines headers for ContainerRegistryRepository_createManifest operation. */
export interface ContainerRegistryRepositoryCreateManifestHeaders {
  /** Identifies the docker upload uuid for the current request. */
  dockerContentDigest?: string;
  /** The canonical location url of the uploaded manifest. */
  location?: string;
  /** The length of the requested blob content. */
  contentLength?: number;
}

/** Defines headers for ContainerRegistryRepository_getTags operation. */
export interface ContainerRegistryRepositoryGetTagsHeaders {
  /** next paginated result */
  link?: string;
}

/** Defines headers for ContainerRegistryRepository_getManifests operation. */
export interface ContainerRegistryRepositoryGetManifestsHeaders {
  /** next paginated result */
  link?: string;
}

/** Defines headers for ContainerRegistryRepository_getTagsNext operation. */
export interface ContainerRegistryRepositoryGetTagsNextHeaders {
  /** next paginated result */
  link?: string;
}

/** Defines headers for ContainerRegistryRepository_getManifestsNext operation. */
export interface ContainerRegistryRepositoryGetManifestsNextHeaders {
  /** next paginated result */
  link?: string;
}

/** Defines headers for ContainerRegistryBlob_getBlob operation. */
export interface ContainerRegistryBlobGetBlobHeaders {
  /** The length of the requested blob content. */
  contentLength?: number;
  /** Digest of the targeted content for the request. */
  dockerContentDigest?: string;
}

/** Defines headers for ContainerRegistryBlob_checkBlobExists operation. */
export interface ContainerRegistryBlobCheckBlobExistsHeaders {
  /** The length of the requested blob content. */
  contentLength?: number;
  /** Digest of the targeted content for the request. */
  dockerContentDigest?: string;
}

/** Defines headers for ContainerRegistryBlob_deleteBlob operation. */
export interface ContainerRegistryBlobDeleteBlobHeaders {
  /** Digest of the targeted content for the request. */
  dockerContentDigest?: string;
}

/** Defines headers for ContainerRegistryBlob_mountBlob operation. */
export interface ContainerRegistryBlobMountBlobHeaders {
  /** Provided location for blob */
  location?: string;
  /** Identifies the docker upload uuid for the current request. */
  dockerUploadUuid?: string;
  /** Digest of the targeted content for the request. */
  dockerContentDigest?: string;
}

/** Defines headers for ContainerRegistryBlob_getUploadStatus operation. */
export interface ContainerRegistryBlobGetUploadStatusHeaders {
  /** Range indicating the current progress of the upload. */
  range?: string;
  /** Identifies the docker upload uuid for the current request. */
  dockerUploadUuid?: string;
}

/** Defines headers for ContainerRegistryBlob_uploadChunk operation. */
export interface ContainerRegistryBlobUploadChunkHeaders {
  /** Provided location for blob */
  location?: string;
  /** Range indicating the current progress of the upload. */
  range?: string;
  /** Identifies the docker upload uuid for the current request. */
  dockerUploadUuid?: string;
}

/** Defines headers for ContainerRegistryBlob_completeUpload operation. */
export interface ContainerRegistryBlobCompleteUploadHeaders {
  /** Provided location for blob */
  location?: string;
  /** Range indicating the current progress of the upload. */
  range?: string;
  /** Digest of the targeted content for the request. */
  dockerContentDigest?: string;
}

/** Defines headers for ContainerRegistryBlob_startUpload operation. */
export interface ContainerRegistryBlobStartUploadHeaders {
  /** Provided location for blob */
  location?: string;
  /** Range indicating the current progress of the upload. */
  range?: string;
  /** Identifies the docker upload uuid for the current request. */
  dockerUploadUuid?: string;
}

/** Defines headers for ContainerRegistryBlob_getChunk operation. */
export interface ContainerRegistryBlobGetChunkHeaders {
  /** The length of the requested blob content. */
  contentLength?: number;
  /** Content range of blob chunk. */
  contentRange?: string;
}

/** Defines headers for ContainerRegistryBlob_checkChunkExists operation. */
export interface ContainerRegistryBlobCheckChunkExistsHeaders {
  /** The length of the requested blob content. */
  contentLength?: number;
  /** Content range of blob chunk. */
  contentRange?: string;
}

/** Known values of {@link PostContentSchemaGrantType} that the service accepts. */
export const enum KnownPostContentSchemaGrantType {
  AccessTokenRefreshToken = "access_token_refresh_token",
  AccessToken = "access_token",
  RefreshToken = "refresh_token"
}

/**
 * Defines values for PostContentSchemaGrantType. \
 * {@link KnownPostContentSchemaGrantType} can be used interchangeably with PostContentSchemaGrantType,
 *  this enum contains the known values that the service supports.
 * ### Know values supported by the service
 * **access_token_refresh_token** \
 * **access_token** \
 * **refresh_token**
 */
export type PostContentSchemaGrantType = string;

/** Optional parameters. */
export interface ContainerRegistryGetRepositoriesOptionalParams
  extends coreHttp.OperationOptions {
  /** Query parameter for the last item in previous query. Result set will include values lexically after last. */
  last?: string;
  /** query parameter for max number of items */
  n?: number;
}

/** Contains response data for the getRepositories operation. */
export type ContainerRegistryGetRepositoriesResponse = ContainerRegistryGetRepositoriesHeaders &
  Repositories & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
      /** The response body as text (string format) */
      bodyAsText: string;

      /** The response body as parsed JSON or XML */
      parsedBody: Repositories;
      /** The parsed HTTP response headers. */
      parsedHeaders: ContainerRegistryGetRepositoriesHeaders;
    };
  };

/** Contains response data for the getRepositoryAttributes operation. */
export type ContainerRegistryGetRepositoryAttributesResponse = RepositoryAttributes & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RepositoryAttributes;
  };
};

/** Contains response data for the deleteRepository operation. */
export type ContainerRegistryDeleteRepositoryResponse = DeletedRepository & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: DeletedRepository;
  };
};

/** Optional parameters. */
export interface ContainerRegistryUpdateRepositoryAttributesOptionalParams
  extends coreHttp.OperationOptions {
  /** Repository attribute value */
  value?: ChangeableAttributes;
}

/** Optional parameters. */
export interface ContainerRegistryGetRepositoriesNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Query parameter for the last item in previous query. Result set will include values lexically after last. */
  last?: string;
  /** query parameter for max number of items */
  n?: number;
}

/** Contains response data for the getRepositoriesNext operation. */
export type ContainerRegistryGetRepositoriesNextResponse = ContainerRegistryGetRepositoriesNextHeaders &
  Repositories & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
      /** The response body as text (string format) */
      bodyAsText: string;

      /** The response body as parsed JSON or XML */
      parsedBody: Repositories;
      /** The parsed HTTP response headers. */
      parsedHeaders: ContainerRegistryGetRepositoriesNextHeaders;
    };
  };

/** Optional parameters. */
export interface ContainerRegistryRepositoryGetManifestOptionalParams
  extends coreHttp.OperationOptions {
  /** Accept header string delimited by comma. For example, application/vnd.docker.distribution.manifest.v2+json */
  accept?: string;
}

/** Contains response data for the getManifest operation. */
export type ContainerRegistryRepositoryGetManifestResponse = Manifest & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: Manifest;
  };
};

/** Contains response data for the createManifest operation. */
export type ContainerRegistryRepositoryCreateManifestResponse = ContainerRegistryRepositoryCreateManifestHeaders & {
  /** The parsed response body. */
  body: any;

  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: any;
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryRepositoryCreateManifestHeaders;
  };
};

/** Optional parameters. */
export interface ContainerRegistryRepositoryGetTagsOptionalParams
  extends coreHttp.OperationOptions {
  /** Query parameter for the last item in previous query. Result set will include values lexically after last. */
  last?: string;
  /** query parameter for max number of items */
  n?: number;
  /** orderby query parameter */
  orderby?: string;
  /** filter by digest */
  digest?: string;
}

/** Contains response data for the getTags operation. */
export type ContainerRegistryRepositoryGetTagsResponse = ContainerRegistryRepositoryGetTagsHeaders &
  TagList & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
      /** The response body as text (string format) */
      bodyAsText: string;

      /** The response body as parsed JSON or XML */
      parsedBody: TagList;
      /** The parsed HTTP response headers. */
      parsedHeaders: ContainerRegistryRepositoryGetTagsHeaders;
    };
  };

/** Contains response data for the getTagAttributes operation. */
export type ContainerRegistryRepositoryGetTagAttributesResponse = TagAttributes & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: TagAttributes;
  };
};

/** Optional parameters. */
export interface ContainerRegistryRepositoryUpdateTagAttributesOptionalParams
  extends coreHttp.OperationOptions {
  /** Repository attribute value */
  value?: ChangeableAttributes;
}

/** Optional parameters. */
export interface ContainerRegistryRepositoryGetManifestsOptionalParams
  extends coreHttp.OperationOptions {
  /** Query parameter for the last item in previous query. Result set will include values lexically after last. */
  last?: string;
  /** query parameter for max number of items */
  n?: number;
  /** orderby query parameter */
  orderby?: string;
}

/** Contains response data for the getManifests operation. */
export type ContainerRegistryRepositoryGetManifestsResponse = ContainerRegistryRepositoryGetManifestsHeaders &
  AcrManifests & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
      /** The response body as text (string format) */
      bodyAsText: string;

      /** The response body as parsed JSON or XML */
      parsedBody: AcrManifests;
      /** The parsed HTTP response headers. */
      parsedHeaders: ContainerRegistryRepositoryGetManifestsHeaders;
    };
  };

/** Contains response data for the getManifestAttributes operation. */
export type ContainerRegistryRepositoryGetManifestAttributesResponse = ManifestAttributes & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: ManifestAttributes;
  };
};

/** Optional parameters. */
export interface ContainerRegistryRepositoryUpdateManifestAttributesOptionalParams
  extends coreHttp.OperationOptions {
  /** Repository attribute value */
  value?: ChangeableAttributes;
}

/** Optional parameters. */
export interface ContainerRegistryRepositoryGetTagsNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Query parameter for the last item in previous query. Result set will include values lexically after last. */
  last?: string;
  /** query parameter for max number of items */
  n?: number;
  /** orderby query parameter */
  orderby?: string;
  /** filter by digest */
  digest?: string;
}

/** Contains response data for the getTagsNext operation. */
export type ContainerRegistryRepositoryGetTagsNextResponse = ContainerRegistryRepositoryGetTagsNextHeaders &
  TagList & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
      /** The response body as text (string format) */
      bodyAsText: string;

      /** The response body as parsed JSON or XML */
      parsedBody: TagList;
      /** The parsed HTTP response headers. */
      parsedHeaders: ContainerRegistryRepositoryGetTagsNextHeaders;
    };
  };

/** Optional parameters. */
export interface ContainerRegistryRepositoryGetManifestsNextOptionalParams
  extends coreHttp.OperationOptions {
  /** Query parameter for the last item in previous query. Result set will include values lexically after last. */
  last?: string;
  /** query parameter for max number of items */
  n?: number;
  /** orderby query parameter */
  orderby?: string;
}

/** Contains response data for the getManifestsNext operation. */
export type ContainerRegistryRepositoryGetManifestsNextResponse = ContainerRegistryRepositoryGetManifestsNextHeaders &
  AcrManifests & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
      /** The response body as text (string format) */
      bodyAsText: string;

      /** The response body as parsed JSON or XML */
      parsedBody: AcrManifests;
      /** The parsed HTTP response headers. */
      parsedHeaders: ContainerRegistryRepositoryGetManifestsNextHeaders;
    };
  };

/** Contains response data for the getBlob operation. */
export type ContainerRegistryBlobGetBlobResponse = ContainerRegistryBlobGetBlobHeaders & {
  /**
   * BROWSER ONLY
   *
   * The response body as a browser Blob.
   * Always `undefined` in node.js.
   */
  blobBody?: Promise<Blob>;
  /**
   * NODEJS ONLY
   *
   * The response body as a node.js Readable stream.
   * Always `undefined` in the browser.
   */
  readableStreamBody?: NodeJS.ReadableStream;

  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobGetBlobHeaders;
  };
};

/** Contains response data for the checkBlobExists operation. */
export type ContainerRegistryBlobCheckBlobExistsResponse = ContainerRegistryBlobCheckBlobExistsHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobCheckBlobExistsHeaders;
  };
};

/** Contains response data for the deleteBlob operation. */
export type ContainerRegistryBlobDeleteBlobResponse = ContainerRegistryBlobDeleteBlobHeaders & {
  /**
   * BROWSER ONLY
   *
   * The response body as a browser Blob.
   * Always `undefined` in node.js.
   */
  blobBody?: Promise<Blob>;
  /**
   * NODEJS ONLY
   *
   * The response body as a node.js Readable stream.
   * Always `undefined` in the browser.
   */
  readableStreamBody?: NodeJS.ReadableStream;

  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobDeleteBlobHeaders;
  };
};

/** Contains response data for the mountBlob operation. */
export type ContainerRegistryBlobMountBlobResponse = ContainerRegistryBlobMountBlobHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobMountBlobHeaders;
  };
};

/** Contains response data for the getUploadStatus operation. */
export type ContainerRegistryBlobGetUploadStatusResponse = ContainerRegistryBlobGetUploadStatusHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobGetUploadStatusHeaders;
  };
};

/** Contains response data for the uploadChunk operation. */
export type ContainerRegistryBlobUploadChunkResponse = ContainerRegistryBlobUploadChunkHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobUploadChunkHeaders;
  };
};

/** Contains response data for the completeUpload operation. */
export type ContainerRegistryBlobCompleteUploadResponse = ContainerRegistryBlobCompleteUploadHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobCompleteUploadHeaders;
  };
};

/** Contains response data for the startUpload operation. */
export type ContainerRegistryBlobStartUploadResponse = ContainerRegistryBlobStartUploadHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobStartUploadHeaders;
  };
};

/** Contains response data for the getChunk operation. */
export type ContainerRegistryBlobGetChunkResponse = ContainerRegistryBlobGetChunkHeaders & {
  /**
   * BROWSER ONLY
   *
   * The response body as a browser Blob.
   * Always `undefined` in node.js.
   */
  blobBody?: Promise<Blob>;
  /**
   * NODEJS ONLY
   *
   * The response body as a node.js Readable stream.
   * Always `undefined` in the browser.
   */
  readableStreamBody?: NodeJS.ReadableStream;

  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobGetChunkHeaders;
  };
};

/** Contains response data for the checkChunkExists operation. */
export type ContainerRegistryBlobCheckChunkExistsResponse = ContainerRegistryBlobCheckChunkExistsHeaders & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The parsed HTTP response headers. */
    parsedHeaders: ContainerRegistryBlobCheckChunkExistsHeaders;
  };
};

/** Optional parameters. */
export interface RefreshTokensGetFromExchangeOptionalParams
  extends coreHttp.OperationOptions {
  accessToken?: Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema;
}

/** Contains response data for the getFromExchange operation. */
export type RefreshTokensGetFromExchangeResponse = RefreshToken & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: RefreshToken;
  };
};

/** Optional parameters. */
export interface AccessTokensGetOptionalParams
  extends coreHttp.OperationOptions {
  refreshToken?: PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema;
}

/** Contains response data for the get operation. */
export type AccessTokensGetResponse = AccessToken & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AccessToken;
  };
};

/** Contains response data for the getFromLogin operation. */
export type AccessTokensGetFromLoginResponse = AccessToken & {
  /** The underlying HTTP response. */
  _response: coreHttp.HttpResponse & {
    /** The response body as text (string format) */
    bodyAsText: string;

    /** The response body as parsed JSON or XML */
    parsedBody: AccessToken;
  };
};

/** Optional parameters. */
export interface GeneratedClientOptionalParams
  extends coreHttp.ServiceClientOptions {
  /** Overrides client endpoint. */
  endpoint?: string;
}
