let nock = require('nock');

module.exports.hash = "e9336727156236ec4d53c87f4ec8e53b";

module.exports.testInfo = {"uniqueName":{},"newDate":{}}

nock('https://identity.confidential-ledger.core.azure.com:443', {"encodedQueryParams":true})
  .get('/ledgerIdentity/emily-java-sdk-tests')
  .reply(200, {"ledgerTlsCertificate":"-----BEGIN CERTIFICATE-----\nMIIBejCCASCgAwIBAgIQMNwF270tS2Ex6jsW6jP46TAKBggqhkjOPQQDAjAWMRQw\nEgYDVQQDDAtDQ0YgTmV0d29yazAeFw0yMjA3MDYyMTA0NDBaFw0yMjEwMDQyMTA0\nMzlaMBYxFDASBgNVBAMMC0NDRiBOZXR3b3JrMFkwEwYHKoZIzj0CAQYIKoZIzj0D\nAQcDQgAEDUWr/JYiEUnNS+4Ndfcci6yGRXhVWSnabgvShqrdxW4RBmsKZ+qsAWJP\nnavsVjf8Zgd8gghMm1y4Zl4PoHzTxKNQME4wDAYDVR0TBAUwAwEB/zAdBgNVHQ4E\nFgQUiIlVb/2YkHp4mXRhBuLaadG82zYwHwYDVR0jBBgwFoAUiIlVb/2YkHp4mXRh\nBuLaadG82zYwCgYIKoZIzj0EAwIDSAAwRQIgfYFw63rQ8RrH0BBs6yWbYbm+OWCq\nwyWR8oAT90gwHtACIQDNJ3eIewMJNDtUSJaRYhOIOu10evuW63wBLP/kftLAmw==\n-----END CERTIFICATE-----\n","ledgerId":"emily-java-sdk-tests"}, [
  'Date',
  'Tue, 13 Sep 2022 15:32:16 GMT',
  'Content-Type',
  'application/json; charset=utf-8',
  'Server',
  'Kestrel',
  'Transfer-Encoding',
  'chunked',
  'x-ms-correlation-request-id',
  '8e5b4513-edb4-4327-94b6-120835bcde86',
  'x-ms-client-request-id',
  'aa14e0e2-04a1-4eed-a4be-bd0ba618265e',
  'x-ms-machineName',
  'identityservice-69c77996fb-x6cqv',
  'x-ms-image-digest',
  'sha256:ff7211ed279924272e3c73dad9a7b9a438c814cee7fca952eed9f38b393580ef',
  'x-ms-image-tag',
  '1.0.02049.29-cb8535e39ba27833da973165c9003a442deb7d8d'
]);

nock('https://login.microsoftonline.com:443', {"encodedQueryParams":true})
  .get('/common/discovery/instance')
  .query(true)
  .reply(200, {"tenant_discovery_endpoint":"https://login.microsoftonline.com/88888888-8888-8888-8888-888888888888/v2.0/.well-known/openid-configuration","api-version":"1.1","metadata":[{"preferred_network":"login.microsoftonline.com","preferred_cache":"login.windows.net","aliases":["login.microsoftonline.com","login.windows.net","login.microsoft.com","sts.windows.net"]},{"preferred_network":"login.partner.microsoftonline.cn","preferred_cache":"login.partner.microsoftonline.cn","aliases":["login.partner.microsoftonline.cn","login.chinacloudapi.cn"]},{"preferred_network":"login.microsoftonline.de","preferred_cache":"login.microsoftonline.de","aliases":["login.microsoftonline.de"]},{"preferred_network":"login.microsoftonline.us","preferred_cache":"login.microsoftonline.us","aliases":["login.microsoftonline.us","login.usgovcloudapi.net"]},{"preferred_network":"login-us.microsoftonline.com","preferred_cache":"login-us.microsoftonline.com","aliases":["login-us.microsoftonline.com"]}]}, [
  'Cache-Control',
  'max-age=86400, private',
  'Content-Type',
  'application/json; charset=utf-8',
  'Strict-Transport-Security',
  'max-age=31536000; includeSubDomains',
  'X-Content-Type-Options',
  'nosniff',
  'Access-Control-Allow-Origin',
  '*',
  'Access-Control-Allow-Methods',
  'GET, OPTIONS',
  'P3P',
  'CP="DSP CUR OTPi IND OTRi ONL FIN"',
  'x-ms-request-id',
  'b9073ab1-7966-4afb-990e-acb824fb2a00',
  'x-ms-ests-server',
  '2.1.13622.7 - SCUS ProdSlices',
  'X-XSS-Protection',
  '0',
  'Set-Cookie',
  'fpc=Asy1lLtMT5BMi1dKWWygAr0; expires=Thu, 13-Oct-2022 15:32:17 GMT; path=/; secure; HttpOnly; SameSite=None',
  'Set-Cookie',
  'esctx=AQABAAAAAAD--DLA3VO7QrddgJg7WevrkdmW7h6WBniiLHGk9pEwfWDoFwzLbjI8oA8EFhEc4Xo3pnIPa12qvTT19eU5tI1L754euqMPD2ot08VA4x2vdRmNzD7Ds3hGCStZ-PVO8hAz3LCAY2kmd6eKAiKRvJ4PT_TcIMatZ_2kXbpDRuXR2uo5uRdcckrCmunTGoDdk3ogAA; domain=.login.microsoftonline.com; path=/; secure; HttpOnly; SameSite=None',
  'Set-Cookie',
  'x-ms-gateway-slice=estsfd; path=/; secure; samesite=none; httponly',
  'Set-Cookie',
  'stsservicecookie=estsfd; path=/; secure; samesite=none; httponly',
  'Date',
  'Tue, 13 Sep 2022 15:32:17 GMT',
  'Content-Length',
  '980'
]);

nock('https://login.microsoftonline.com:443', {"encodedQueryParams":true})
  .get('/88888888-8888-8888-8888-888888888888/v2.0/.well-known/openid-configuration')
  .reply(200, {"token_endpoint":"https://login.microsoftonline.com/88888888-8888-8888-8888-888888888888/oauth2/v2.0/token","token_endpoint_auth_methods_supported":["client_secret_post","private_key_jwt","client_secret_basic"],"jwks_uri":"https://login.microsoftonline.com/88888888-8888-8888-8888-888888888888/discovery/v2.0/keys","response_modes_supported":["query","fragment","form_post"],"subject_types_supported":["pairwise"],"id_token_signing_alg_values_supported":["RS256"],"response_types_supported":["code","id_token","code id_token","id_token token"],"scopes_supported":["openid","profile","email","offline_access"],"issuer":"https://login.microsoftonline.com/88888888-8888-8888-8888-888888888888/v2.0","request_uri_parameter_supported":false,"userinfo_endpoint":"https://graph.microsoft.com/oidc/userinfo","authorization_endpoint":"https://login.microsoftonline.com/88888888-8888-8888-8888-888888888888/oauth2/v2.0/authorize","device_authorization_endpoint":"https://login.microsoftonline.com/88888888-8888-8888-8888-888888888888/oauth2/v2.0/devicecode","http_logout_supported":true,"frontchannel_logout_supported":true,"end_session_endpoint":"https://login.microsoftonline.com/88888888-8888-8888-8888-888888888888/oauth2/v2.0/logout","claims_supported":["sub","iss","cloud_instance_name","cloud_instance_host_name","cloud_graph_host_name","msgraph_host","aud","exp","iat","auth_time","acr","nonce","preferred_username","name","tid","ver","at_hash","c_hash","email"],"kerberos_endpoint":"https://login.microsoftonline.com/88888888-8888-8888-8888-888888888888/kerberos","tenant_region_scope":"WW","cloud_instance_name":"microsoftonline.com","cloud_graph_host_name":"graph.windows.net","msgraph_host":"graph.microsoft.com","rbac_url":"https://pas.windows.net"}, [
  'Cache-Control',
  'max-age=86400, private',
  'Content-Type',
  'application/json; charset=utf-8',
  'Strict-Transport-Security',
  'max-age=31536000; includeSubDomains',
  'X-Content-Type-Options',
  'nosniff',
  'Access-Control-Allow-Origin',
  '*',
  'Access-Control-Allow-Methods',
  'GET, OPTIONS',
  'P3P',
  'CP="DSP CUR OTPi IND OTRi ONL FIN"',
  'x-ms-request-id',
  '2524d9c5-3a79-458d-a1c4-017d5e1e1b00',
  'x-ms-ests-server',
  '2.1.13672.7 - NCUS ProdSlices',
  'X-XSS-Protection',
  '0',
  'Set-Cookie',
  'fpc=ApL5Qf_HSPxCsJnvuPMQxG8; expires=Thu, 13-Oct-2022 15:32:17 GMT; path=/; secure; HttpOnly; SameSite=None',
  'Set-Cookie',
  'esctx=AQABAAAAAAD--DLA3VO7QrddgJg7WevrjIZdfDUTIyXM7_xaKWyhtYQiI3xH9uVNSn53FTD3DczG_pl--53158GtSkkqLlhJNsH6kzLgWF8thPDFyrdfwq3JkWEu4lkY0a-RW1fz7sjKizx7njIc6C5dMtq6gPo6f06whvZmz1_v7R5VcIxcAefxkkZTDc8pHAExRjrwEbcgAA; domain=.login.microsoftonline.com; path=/; secure; HttpOnly; SameSite=None',
  'Set-Cookie',
  'x-ms-gateway-slice=estsfd; path=/; secure; samesite=none; httponly',
  'Set-Cookie',
  'stsservicecookie=estsfd; path=/; secure; samesite=none; httponly',
  'Date',
  'Tue, 13 Sep 2022 15:32:17 GMT',
  'Content-Length',
  '1753'
]);

nock('https://login.microsoftonline.com:443', {"encodedQueryParams":true})
  .post('/88888888-8888-8888-8888-888888888888/oauth2/v2.0/token', "client_id=azure_client_id&scope=https%3A%2F%2Fsanitized%2F&grant_type=client_credentials&x-client-SKU=msal.js.node&x-client-VER=1.12.0&x-client-OS=linux&x-client-CPU=x64&x-ms-lib-capability=retry-after, h429&x-client-current-telemetry=5|771,2,,,|,&x-client-last-telemetry=5|0|||0,0&client-request-id=b1bbde4e-9214-4130-9228-556425037daf&client_secret=azure_client_secret&claims=%7B%22access_token%22%3A%7B%22xms_cc%22%3A%7B%22values%22%3A%5B%22cp1%22%5D%7D%7D%7D")
  .reply(200, {"token_type":"Bearer","expires_in":86399,"ext_expires_in":86399,"access_token":"access_token"}, [
  'Cache-Control',
  'no-store, no-cache',
  'Pragma',
  'no-cache',
  'Content-Type',
  'application/json; charset=utf-8',
  'Expires',
  '-1',
  'Strict-Transport-Security',
  'max-age=31536000; includeSubDomains',
  'X-Content-Type-Options',
  'nosniff',
  'P3P',
  'CP="DSP CUR OTPi IND OTRi ONL FIN"',
  'x-ms-request-id',
  '506a970e-1908-417b-a8f3-5fa597872700',
  'x-ms-ests-server',
  '2.1.13672.7 - SCUS ProdSlices',
  'x-ms-clitelem',
  '1,0,0,,',
  'X-XSS-Protection',
  '0',
  'Set-Cookie',
  'fpc=Ar2d_jFFYP1Ij5zDcpkQUEgsHfw7AQAAAIGZstoOAAAA; expires=Thu, 13-Oct-2022 15:32:17 GMT; path=/; secure; HttpOnly; SameSite=None',
  'Set-Cookie',
  'x-ms-gateway-slice=estsfd; path=/; secure; samesite=none; httponly',
  'Set-Cookie',
  'stsservicecookie=estsfd; path=/; secure; samesite=none; httponly',
  'Date',
  'Tue, 13 Sep 2022 15:32:17 GMT',
  'Content-Length',
  '1334'
]);

nock('https://emily-java-sdk-tests.confidential-ledger.azure.com:443', {"encodedQueryParams":true})
  .get('/app/governance/constitution')
  .query(true)
  .reply(200, {"digest":"441ae241c110f6c29d5dac4e8614d3a35c104c2d0dcd13da940959e56b2dad3e","script":"export function apply(proposal, proposalId) {\n  const proposed_actions = JSON.parse(proposal)[\"actions\"];\n  for (const proposed_action of proposed_actions) {\n    const definition = actions.get(proposed_action.name);\n    definition.apply(proposed_action.args, proposalId);\n  }\n}\nclass Action {\n  constructor(validate, apply) {\n    this.validate = validate;\n    this.apply = apply;\n  }\n}\n\nfunction parseUrl(url) {\n  // From https://tools.ietf.org/html/rfc3986#appendix-B\n  const re = new RegExp(\n    \"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\"\n  );\n  const groups = url.match(re);\n  if (!groups) {\n    throw new TypeError(`${url} is not a valid URL.`);\n  }\n  return {\n    scheme: groups[2],\n    authority: groups[4],\n    path: groups[5],\n    query: groups[7],\n    fragment: groups[9],\n  };\n}\n\nfunction checkType(value, type, field) {\n  const optional = type.endsWith(\"?\");\n  if (optional) {\n    if (value === null || value === undefined) {\n      return;\n    }\n    type = type.slice(0, -1);\n  }\n  if (type === \"array\") {\n    if (!Array.isArray(value)) {\n      throw new Error(`${field} must be an array`);\n    }\n  } else if (type === \"integer\") {\n    if (!Number.isInteger(value)) {\n      throw new Error(`${field} must be an integer`);\n    }\n  } else if (typeof value !== type) {\n    throw new Error(`${field} must be of type ${type} but is ${typeof value}`);\n  }\n}\n\nfunction checkEnum(value, members, field) {\n  if (!members.includes(value)) {\n    throw new Error(`${field} must be one of ${members}`);\n  }\n}\n\nfunction checkBounds(value, low, high, field) {\n  if (low !== null && value < low) {\n    throw new Error(`${field} must be greater than ${low}`);\n  }\n  if (high !== null && value > high) {\n    throw new Error(`${field} must be lower than ${high}`);\n  }\n}\n\nfunction checkLength(value, min, max, field) {\n  if (min !== null && value.length < min) {\n    throw new Error(`${field} must be an array of minimum ${min} elements`);\n  }\n  if (max !== null && value.length > max) {\n    throw new Error(`${field} must be an array of maximum ${max} elements`);\n  }\n}\n\nfunction checkNone(args) {\n  if (args !== null && args !== undefined) {\n    throw new Error(`Proposal does not accept any argument, found \"${args}\"`);\n  }\n}\n\nfunction checkEntityId(value, field) {\n  checkType(value, \"string\", field);\n  // This should be the hex-encoding of a SHA256 digest. This is 32 bytes long, so\n  // produces 64 hex characters.\n  const digestLength = 64;\n  if (value.length !== digestLength) {\n    throw new Error(`${field} must contain exactly ${digestLength} characters`);\n  }\n  const re = new RegExp(\"^[a-fA-F0-9]*$\");\n  if (!re.test(value)) {\n    throw new Error(`${field} contains non-hexadecimal character`);\n  }\n}\n\nfunction getSingletonKvKey() {\n  // When a KV map only contains one value, this is the key at which\n  // the value is recorded\n  return new ArrayBuffer(8);\n}\n\nfunction getActiveRecoveryMembersCount() {\n  let activeRecoveryMembersCount = 0;\n  ccf.kv[\"public:ccf.gov.members.encryption_public_keys\"].forEach((_, k) => {\n    let rawMemberInfo = ccf.kv[\"public:ccf.gov.members.info\"].get(k);\n    if (rawMemberInfo === undefined) {\n      throw new Error(`Recovery member ${ccf.bufToStr(k)} has no information`);\n    }\n\n    const memberInfo = ccf.bufToJsonCompatible(rawMemberInfo);\n    if (memberInfo.status === \"Active\") {\n      activeRecoveryMembersCount++;\n    }\n  });\n  return activeRecoveryMembersCount;\n}\n\nfunction checkJwks(value, field) {\n  checkType(value, \"object\", field);\n  checkType(value.keys, \"array\", `${field}.keys`);\n  for (const [i, jwk] of value.keys.entries()) {\n    checkType(jwk.kid, \"string\", `${field}.keys[${i}].kid`);\n    checkType(jwk.kty, \"string\", `${field}.keys[${i}].kty`);\n    checkType(jwk.x5c, \"array\", `${field}.keys[${i}].x5c`);\n    checkLength(jwk.x5c, 1, null, `${field}.keys[${i}].x5c`);\n    for (const [j, b64der] of jwk.x5c.entries()) {\n      checkType(b64der, \"string\", `${field}.keys[${i}].x5c[${j}]`);\n      const pem =\n        \"-----BEGIN CERTIFICATE-----\\n\" +\n        b64der +\n        \"\\n-----END CERTIFICATE-----\";\n      checkX509CertChain(pem, `${field}.keys[${i}].x5c[${j}]`);\n    }\n  }\n}\n\nfunction checkX509CertChain(value, field) {\n  if (!ccf.isValidX509CertBundle(value)) {\n    throw new Error(\n      `${field} must be a valid X509 certificate (chain) in PEM format`\n    );\n  }\n}\n\nfunction invalidateOtherOpenProposals(proposalIdToRetain) {\n  const proposalsMap = ccf.kv[\"public:ccf.gov.proposals_info\"];\n  proposalsMap.forEach((v, k) => {\n    let proposalId = ccf.bufToStr(k);\n    if (proposalId !== proposalIdToRetain) {\n      let info = ccf.bufToJsonCompatible(v);\n      if (info.state === \"Open\") {\n        info.state = \"Dropped\";\n        proposalsMap.set(k, ccf.jsonCompatibleToBuf(info));\n      }\n    }\n  });\n}\n\nfunction setServiceCertificateValidityPeriod(validFrom, validityPeriodDays) {\n  const rawConfig = ccf.kv[\"public:ccf.gov.service.config\"].get(\n    getSingletonKvKey()\n  );\n  if (rawConfig === undefined) {\n    throw new Error(\"Service configuration could not be found\");\n  }\n  const serviceConfig = ccf.bufToJsonCompatible(rawConfig);\n\n  const default_validity_period_days = 365;\n  const max_allowed_cert_validity_period_days =\n    serviceConfig.maximum_service_certificate_validity_days ??\n    default_validity_period_days;\n\n  if (\n    validityPeriodDays !== undefined &&\n    validityPeriodDays > max_allowed_cert_validity_period_days\n  ) {\n    throw new Error(\n      `Validity period ${validityPeriodDays} (days) is not allowed: service max allowed is ${max_allowed_cert_validity_period_days} (days)`\n    );\n  }\n\n  const renewed_service_certificate = ccf.network.generateNetworkCertificate(\n    validFrom,\n    validityPeriodDays ?? max_allowed_cert_validity_period_days\n  );\n\n  const serviceInfoTable = \"public:ccf.gov.service.info\";\n  const rawServiceInfo = ccf.kv[serviceInfoTable].get(getSingletonKvKey());\n  if (rawServiceInfo === undefined) {\n    throw new Error(\"Service info could not be found\");\n  }\n  const serviceInfo = ccf.bufToJsonCompatible(rawServiceInfo);\n\n  serviceInfo.cert = renewed_service_certificate;\n  ccf.kv[serviceInfoTable].set(\n    getSingletonKvKey(),\n    ccf.jsonCompatibleToBuf(serviceInfo)\n  );\n}\n\nfunction setNodeCertificateValidityPeriod(\n  nodeId,\n  nodeInfo,\n  validFrom,\n  validityPeriodDays\n) {\n  if (nodeInfo.certificate_signing_request === undefined) {\n    throw new Error(`Node ${nodeId} has no certificate signing request`);\n  }\n\n  const rawConfig = ccf.kv[\"public:ccf.gov.service.config\"].get(\n    getSingletonKvKey()\n  );\n  if (rawConfig === undefined) {\n    throw new Error(\"Service configuration could not be found\");\n  }\n  const serviceConfig = ccf.bufToJsonCompatible(rawConfig);\n\n  const default_validity_period_days = 365;\n  const max_allowed_cert_validity_period_days =\n    serviceConfig.maximum_node_certificate_validity_days ??\n    default_validity_period_days;\n\n  if (\n    validityPeriodDays !== undefined &&\n    validityPeriodDays > max_allowed_cert_validity_period_days\n  ) {\n    throw new Error(\n      `Validity period ${validityPeriodDays} (days) is not allowed: service max allowed is ${max_allowed_cert_validity_period_days} (days)`\n    );\n  }\n\n  const endorsed_node_cert = ccf.network.generateEndorsedCertificate(\n    nodeInfo.certificate_signing_request,\n    validFrom,\n    validityPeriodDays ?? max_allowed_cert_validity_period_days\n  );\n  ccf.kv[\"public:ccf.gov.nodes.endorsed_certificates\"].set(\n    ccf.strToBuf(nodeId),\n    ccf.strToBuf(endorsed_node_cert)\n  );\n}\n\nfunction checkRecoveryThreshold(config, new_config) {\n  const from = config.recovery_threshold;\n  const to = new_config.recovery_threshold;\n  if (to === undefined || from === to) {\n    return;\n  }\n\n  const service_info = \"public:ccf.gov.service.info\";\n  const rawService = ccf.kv[service_info].get(getSingletonKvKey());\n  if (rawService === undefined) {\n    throw new Error(\"Service information could not be found\");\n  }\n\n  const service = ccf.bufToJsonCompatible(rawService);\n\n  if (service.status === \"WaitingForRecoveryShares\") {\n    throw new Error(\n      `Cannot set recovery threshold if service is ${service.status}`\n    );\n  } else if (service.status === \"Open\") {\n    let activeRecoveryMembersCount = getActiveRecoveryMembersCount();\n    if (new_config.recovery_threshold > activeRecoveryMembersCount) {\n      throw new Error(\n        `Cannot set recovery threshold to ${new_config.recovery_threshold}: recovery threshold would be greater than the number of recovery members ${activeRecoveryMembersCount}`\n      );\n    }\n  }\n}\n\nfunction checkReconfigurationType(config, new_config) {\n  const from = config.reconfiguration_type;\n  const to = new_config.reconfiguration_type;\n  if (from !== to && to !== undefined) {\n    if (\n      !(\n        (from === undefined || from === \"OneTransaction\") &&\n        to === \"TwoTransaction\"\n      )\n    ) {\n      throw new Error(\n        `Cannot change reconfiguration type from ${from} to ${to}.`\n      );\n    }\n  }\n}\n\nfunction updateServiceConfig(new_config) {\n  const service_config_table = \"public:ccf.gov.service.config\";\n  const rawConfig = ccf.kv[service_config_table].get(getSingletonKvKey());\n  if (rawConfig === undefined) {\n    throw new Error(\"Service configuration could not be found\");\n  }\n  let config = ccf.bufToJsonCompatible(rawConfig);\n\n  // First run all checks\n  checkReconfigurationType(config, new_config);\n  checkRecoveryThreshold(config, new_config);\n\n  // Then all updates\n  if (new_config.reconfiguration_type !== undefined) {\n    config.reconfiguration_type = new_config.reconfiguration_type;\n  }\n\n  let need_recovery_threshold_refresh = false;\n  if (\n    new_config.recovery_threshold !== undefined &&\n    new_config.recovery_threshold !== config.recovery_threshold\n  ) {\n    config.recovery_threshold = new_config.recovery_threshold;\n    need_recovery_threshold_refresh = true;\n  }\n\n  ccf.kv[service_config_table].set(\n    getSingletonKvKey(),\n    ccf.jsonCompatibleToBuf(config)\n  );\n\n  if (need_recovery_threshold_refresh) {\n    ccf.node.triggerRecoverySharesRefresh();\n  }\n}\n\nconst actions = new Map([\n  [\n    \"set_constitution\",\n    new Action(\n      function (args) {\n        checkType(args.constitution, \"string\");\n      },\n      function (args, proposalId) {\n        ccf.kv[\"public:ccf.gov.constitution\"].set(\n          getSingletonKvKey(),\n          ccf.jsonCompatibleToBuf(args.constitution)\n        );\n\n        // Changing the constitution changes the semantics of any other open proposals, so invalidate them to avoid confusion or malicious vote modification\n        invalidateOtherOpenProposals(proposalId);\n      }\n    ),\n  ],\n  [\n    \"set_member\",\n    new Action(\n      function (args) {\n        checkX509CertChain(args.cert, \"cert\");\n        checkType(args.member_data, \"object?\", \"member_data\");\n        // Also check that public encryption key is well formed, if it exists\n      },\n\n      function (args) {\n        const memberId = ccf.pemToId(args.cert);\n        const rawMemberId = ccf.strToBuf(memberId);\n\n        ccf.kv[\"public:ccf.gov.members.certs\"].set(\n          rawMemberId,\n          ccf.strToBuf(args.cert)\n        );\n\n        if (args.encryption_pub_key == null) {\n          ccf.kv[\"public:ccf.gov.members.encryption_public_keys\"].delete(\n            rawMemberId\n          );\n        } else {\n          ccf.kv[\"public:ccf.gov.members.encryption_public_keys\"].set(\n            rawMemberId,\n            ccf.strToBuf(args.encryption_pub_key)\n          );\n        }\n\n        let member_info = {};\n        member_info.member_data = args.member_data;\n        member_info.status = \"Accepted\";\n        ccf.kv[\"public:ccf.gov.members.info\"].set(\n          rawMemberId,\n          ccf.jsonCompatibleToBuf(member_info)\n        );\n\n        const rawSignature = ccf.kv[\"public:ccf.internal.signatures\"].get(\n          getSingletonKvKey()\n        );\n        if (rawSignature === undefined) {\n          ccf.kv[\"public:ccf.gov.members.acks\"].set(rawMemberId);\n        } else {\n          const signature = ccf.bufToJsonCompatible(rawSignature);\n          const ack = {};\n          ack.state_digest = signature.root;\n          ccf.kv[\"public:ccf.gov.members.acks\"].set(\n            rawMemberId,\n            ccf.jsonCompatibleToBuf(ack)\n          );\n        }\n      }\n    ),\n  ],\n  [\n    \"remove_member\",\n    new Action(\n      function (args) {\n        checkX509CertChain(args.cert, \"cert\");\n      },\n      function (args) {\n        const memberId = ccf.pemToId(args.cert);\n        const rawMemberId = ccf.strToBuf(memberId);\n        const rawMemberInfo = ccf.kv[\"public:ccf.gov.members.info\"].get(\n          rawMemberId\n        );\n        if (rawMemberInfo === undefined) {\n          return; // Idempotent\n        }\n\n        const memberInfo = ccf.bufToJsonCompatible(rawMemberInfo);\n        const isActiveMember = memberInfo.status == \"Active\";\n\n        const isRecoveryMember = ccf.kv[\n          \"public:ccf.gov.members.encryption_public_keys\"\n        ].has(rawMemberId)\n          ? true\n          : false;\n\n        // If the member is an active recovery member, check that there\n        // would still be a sufficient number of recovery members left\n        // to recover the service\n        if (isActiveMember && isRecoveryMember) {\n          const rawConfig = ccf.kv[\"public:ccf.gov.service.config\"].get(\n            getSingletonKvKey()\n          );\n          if (rawConfig === undefined) {\n            throw new Error(\"Service configuration could not be found\");\n          }\n\n          const config = ccf.bufToJsonCompatible(rawConfig);\n          const activeRecoveryMembersCountAfter =\n            getActiveRecoveryMembersCount() - 1;\n          if (activeRecoveryMembersCountAfter < config.recovery_threshold) {\n            throw new Error(\n              `Number of active recovery members (${activeRecoveryMembersCountAfter}) would be less than recovery threshold (${config.recovery_threshold})`\n            );\n          }\n        }\n\n        ccf.kv[\"public:ccf.gov.members.info\"].delete(rawMemberId);\n        ccf.kv[\"public:ccf.gov.members.encryption_public_keys\"].delete(\n          rawMemberId\n        );\n        ccf.kv[\"public:ccf.gov.members.certs\"].delete(rawMemberId);\n        ccf.kv[\"public:ccf.gov.members.acks\"].delete(rawMemberId);\n        ccf.kv[\"public:ccf.gov.history\"].delete(rawMemberId);\n\n        if (isActiveMember && isRecoveryMember) {\n          // A retired recovery member should not have access to the private\n          // ledger going forward so rekey the ledger, issuing new shares to\n          // remaining active recovery members\n          ccf.node.triggerLedgerRekey();\n        }\n      }\n    ),\n  ],\n  [\n    \"set_member_data\",\n    new Action(\n      function (args) {\n        checkType(args.member_id, \"string\", \"member_id\");\n        checkType(args.member_data, \"object\", \"member_data\");\n      },\n\n      function (args) {\n        let member_id = ccf.strToBuf(args.member_id);\n        let members_info = ccf.kv[\"public:ccf.gov.members.info\"];\n        let member_info = members_info.get(member_id);\n        if (member_info === undefined) {\n          throw new Error(`Member ${args.member_id} does not exist`);\n        }\n        let mi = ccf.bufToJsonCompatible(member_info);\n        mi.member_data = args.member_data;\n        members_info.set(member_id, ccf.jsonCompatibleToBuf(mi));\n      }\n    ),\n  ],\n  [\n    \"set_user\",\n    new Action(\n      function (args) {\n        checkX509CertChain(args.cert, \"cert\");\n        checkType(args.user_data, \"object?\", \"user_data\");\n      },\n      function (args) {\n        let userId = ccf.pemToId(args.cert);\n        let rawUserId = ccf.strToBuf(userId);\n\n        ccf.kv[\"public:ccf.gov.users.certs\"].set(\n          rawUserId,\n          ccf.strToBuf(args.cert)\n        );\n\n        if (args.user_data !== null && args.user_data !== undefined) {\n          ccf.kv[\"public:ccf.gov.users.info\"].set(\n            rawUserId,\n            ccf.jsonCompatibleToBuf(args.user_data)\n          );\n        } else {\n          ccf.kv[\"public:ccf.gov.users.info\"].delete(rawUserId);\n        }\n      }\n    ),\n  ],\n  [\n    \"remove_user\",\n    new Action(\n      function (args) {\n        checkType(args.user_id, \"string\", \"user_id\");\n      },\n      function (args) {\n        const user_id = ccf.strToBuf(args.user_id);\n        ccf.kv[\"public:ccf.gov.users.certs\"].delete(user_id);\n        ccf.kv[\"public:ccf.gov.users.info\"].delete(user_id);\n      }\n    ),\n  ],\n  [\n    \"remove_user_by_cert\",\n    new Action(\n      function (args) {\n        checkX509CertChain(args.cert, \"cert\");\n      },\n      function (args) {\n        let userId = ccf.pemToId(args.cert);\n        let rawUserId = ccf.strToBuf(userId);\n\n        ccf.kv[\"public:ccf.gov.users.certs\"].delete(\n          rawUserId\n        );\n        ccf.kv[\"public:ccf.gov.users.info\"].delete(rawUserId);\n      }\n    ),\n  ],\n  [\n    \"set_user_data\",\n    new Action(\n      function (args) {\n        checkType(args.user_id, \"string\", \"user_id\");\n        checkType(args.user_data, \"object?\", \"user_data\");\n      },\n      function (args) {\n        const userId = ccf.strToBuf(args.user_id);\n\n        if (args.user_data !== null && args.user_data !== undefined) {\n          let userInfo = {};\n          userInfo.user_data = args.user_data;\n          ccf.kv[\"public:ccf.gov.users.info\"].set(\n            userId,\n            ccf.jsonCompatibleToBuf(userInfo)\n          );\n        } else {\n          ccf.kv[\"public:ccf.gov.users.info\"].delete(userId);\n        }\n      }\n    ),\n  ],\n  [\n    \"set_recovery_threshold\",\n    new Action(\n      function (args) {\n        checkType(args.recovery_threshold, \"integer\", \"threshold\");\n        checkBounds(args.recovery_threshold, 1, 254, \"threshold\");\n      },\n      function (args) {\n        updateServiceConfig(args);\n      }\n    ),\n  ],\n  [\n    \"trigger_recovery_shares_refresh\",\n    new Action(\n      function (args) {\n        checkNone(args);\n      },\n      function (args) {\n        ccf.node.triggerRecoverySharesRefresh();\n      }\n    ),\n  ],\n  [\n    \"trigger_ledger_rekey\",\n    new Action(\n      function (args) {\n        checkNone(args);\n      },\n\n      function (args) {\n        ccf.node.triggerLedgerRekey();\n      }\n    ),\n  ],\n  [\n    \"transition_service_to_open\",\n    new Action(\n      function (args) {\n        checkType(\n          args.next_service_identity,\n          \"string\",\n          \"next service identity (PEM certificate)\"\n        );\n        checkX509CertChain(\n          args.next_service_identity,\n          \"next_service_identity\"\n        );\n\n        checkType(\n          args.previous_service_identity,\n          \"string?\",\n          \"previous service identity (PEM certificate)\"\n        );\n        if (args.previous_service_identity !== undefined) {\n          checkX509CertChain(\n            args.previous_service_identity,\n            \"previous_service_identity\"\n          );\n        }\n      },\n\n      function (args) {\n        const service_info = \"public:ccf.gov.service.info\";\n        const rawService = ccf.kv[service_info].get(getSingletonKvKey());\n        if (rawService === undefined) {\n          throw new Error(\"Service information could not be found\");\n        }\n\n        const service = ccf.bufToJsonCompatible(rawService);\n\n        if (\n          service.status === \"Recovering\" &&\n          (args.previous_service_identity === undefined ||\n            args.next_service_identity === undefined)\n        ) {\n          throw new Error(\n            `Opening a recovering network requires both, the previous and the next service identity`\n          );\n        }\n\n        const previous_identity =\n          args.previous_service_identity !== undefined\n            ? ccf.strToBuf(args.previous_service_identity)\n            : undefined;\n        const next_identity = ccf.strToBuf(args.next_service_identity);\n        ccf.node.transitionServiceToOpen(previous_identity, next_identity);\n      }\n    ),\n  ],\n  [\n    \"set_js_app\",\n    new Action(\n      function (args) {\n        const bundle = args.bundle;\n        checkType(bundle, \"object\", \"bundle\");\n\n        let prefix = \"bundle.modules\";\n        checkType(bundle.modules, \"array\", prefix);\n        for (const [i, module] of bundle.modules.entries()) {\n          checkType(module, \"object\", `${prefix}[${i}]`);\n          checkType(module.name, \"string\", `${prefix}[${i}].name`);\n          checkType(module.module, \"string\", `${prefix}[${i}].module`);\n        }\n\n        prefix = \"bundle.metadata\";\n        checkType(bundle.metadata, \"object\", prefix);\n        checkType(bundle.metadata.endpoints, \"object\", `${prefix}.endpoints`);\n        for (const [url, endpoint] of Object.entries(\n          bundle.metadata.endpoints\n        )) {\n          checkType(endpoint, \"object\", `${prefix}.endpoints[\"${url}\"]`);\n          for (const [method, info] of Object.entries(endpoint)) {\n            const prefix2 = `${prefix}.endpoints[\"${url}\"][\"${method}\"]`;\n            checkType(info, \"object\", prefix2);\n            checkType(info.js_module, \"string\", `${prefix2}.js_module`);\n            checkType(info.js_function, \"string\", `${prefix2}.js_function`);\n            checkEnum(\n              info.mode,\n              [\"readwrite\", \"readonly\", \"historical\"],\n              `${prefix2}.mode`\n            );\n            checkEnum(\n              info.forwarding_required,\n              [\"sometimes\", \"always\", \"never\"],\n              `${prefix2}.forwarding_required`\n            );\n            checkType(info.openapi, \"object?\", `${prefix2}.openapi`);\n            checkType(\n              info.openapi_hidden,\n              \"boolean?\",\n              `${prefix2}.openapi_hidden`\n            );\n            checkType(\n              info.authn_policies,\n              \"array\",\n              `${prefix2}.authn_policies`\n            );\n            for (const [i, policy] of info.authn_policies.entries()) {\n              checkType(policy, \"string\", `${prefix2}.authn_policies[${i}]`);\n            }\n            if (!bundle.modules.some((m) => m.name === info.js_module)) {\n              throw new Error(`module '${info.js_module}' not found in bundle`);\n            }\n          }\n        }\n        \n        checkType(\n          args.disable_bytecode_cache,\n          \"boolean?\",\n          \"disable_bytecode_cache\"\n        );\n      },\n      function (args) {\n        const modulesMap = ccf.kv[\"public:ccf.gov.modules\"];\n        const modulesQuickJsBytecodeMap =\n          ccf.kv[\"public:ccf.gov.modules_quickjs_bytecode\"];\n        const modulesQuickJsVersionVal =\n          ccf.kv[\"public:ccf.gov.modules_quickjs_version\"];\n        const endpointsMap = ccf.kv[\"public:ccf.gov.endpoints\"];\n        modulesMap.clear();\n        endpointsMap.clear();\n\n        const bundle = args.bundle;\n        for (const module of bundle.modules) {\n          const path = \"/\" + module.name;\n          const pathBuf = ccf.strToBuf(path);\n          const moduleBuf = ccf.strToBuf(module.module);\n          modulesMap.set(pathBuf, moduleBuf);\n        }\n\n        if (args.disable_bytecode_cache) {\n          modulesQuickJsBytecodeMap.clear();\n          modulesQuickJsVersionVal.clear();\n        } else {\n          ccf.refreshAppBytecodeCache();\n        }\n\n        for (const [url, endpoint] of Object.entries(\n          bundle.metadata.endpoints\n        )) {\n          for (const [method, info] of Object.entries(endpoint)) {\n            const key = `${method.toUpperCase()} ${url}`;\n            const keyBuf = ccf.strToBuf(key);\n\n            info.js_module = \"/\" + info.js_module;\n            const infoBuf = ccf.jsonCompatibleToBuf(info);\n            endpointsMap.set(keyBuf, infoBuf);\n          }\n        }\n      }\n    ),\n  ],\n  [\n    \"remove_js_app\",\n    new Action(\n      function (args) {},\n      function (args) {\n        const modulesMap = ccf.kv[\"public:ccf.gov.modules\"];\n        const modulesQuickJsBytecodeMap =\n          ccf.kv[\"public:ccf.gov.modules_quickjs_bytecode\"];\n        const modulesQuickJsVersionVal =\n          ccf.kv[\"public:ccf.gov.modules_quickjs_version\"];\n        const endpointsMap = ccf.kv[\"public:ccf.gov.endpoints\"];\n        modulesMap.clear();\n        modulesQuickJsBytecodeMap.clear();\n        modulesQuickJsVersionVal.clear();\n        endpointsMap.clear();\n      }\n    ),\n  ],\n  [\n    \"refresh_js_app_bytecode_cache\",\n    new Action(\n      function (args) {},\n      function (args) {\n        ccf.refreshAppBytecodeCache();\n      }\n    ),\n  ],\n  [\n    \"set_ca_cert_bundle\",\n    new Action(\n      function (args) {\n        checkType(args.name, \"string\", \"name\");\n        checkX509CertChain(args.cert_bundle, \"cert_bundle\");\n      },\n      function (args) {\n        const name = args.name;\n        const bundle = args.cert_bundle;\n        const nameBuf = ccf.strToBuf(name);\n        const bundleBuf = ccf.jsonCompatibleToBuf(bundle);\n        ccf.kv[\"public:ccf.gov.tls.ca_cert_bundles\"].set(nameBuf, bundleBuf);\n      }\n    ),\n  ],\n  [\n    \"remove_ca_cert_bundle\",\n    new Action(\n      function (args) {\n        checkType(args.name, \"string\", \"name\");\n      },\n      function (args) {\n        const name = args.name;\n        const nameBuf = ccf.strToBuf(name);\n        ccf.kv[\"public:ccf.gov.tls.ca_cert_bundles\"].delete(nameBuf);\n      }\n    ),\n  ],\n  [\n    \"set_jwt_issuer\",\n    new Action(\n      function (args) {\n        checkType(args.issuer, \"string\", \"issuer\");\n        checkType(args.auto_refresh, \"boolean?\", \"auto_refresh\");\n        checkType(args.ca_cert_bundle_name, \"string?\", \"ca_cert_bundle_name\");\n        checkEnum(args.key_filter, [\"all\", \"sgx\"], \"key_filter\");\n        checkType(args.key_policy, \"object?\", \"key_policy\");\n        if (args.key_policy) {\n          checkType(\n            args.key_policy.sgx_claims,\n            \"object?\",\n            \"key_policy.sgx_claims\"\n          );\n          if (args.key_policy.sgx_claims) {\n            for (const [name, value] of Object.entries(\n              args.key_policy.sgx_claims\n            )) {\n              checkType(value, \"string\", `key_policy.sgx_claims[\"${name}\"]`);\n            }\n          }\n        }\n        checkType(args.jwks, \"object?\", \"jwks\");\n        if (args.jwks) {\n          checkJwks(args.jwks, \"jwks\");\n        }\n        if (args.auto_refresh) {\n          if (!args.ca_cert_bundle_name) {\n            throw new Error(\n              \"ca_cert_bundle_name is missing but required if auto_refresh is true\"\n            );\n          }\n          let url;\n          try {\n            url = parseUrl(args.issuer);\n          } catch (e) {\n            throw new Error(\"issuer must be a URL if auto_refresh is true\");\n          }\n          if (url.scheme != \"https\") {\n            throw new Error(\n              \"issuer must be a URL starting with https:// if auto_refresh is true\"\n            );\n          }\n          if (url.query || url.fragment) {\n            throw new Error(\n              \"issuer must be a URL without query/fragment if auto_refresh is true\"\n            );\n          }\n        }\n      },\n      function (args) {\n        if (args.auto_refresh) {\n          const caCertBundleName = args.ca_cert_bundle_name;\n          const caCertBundleNameBuf = ccf.strToBuf(args.ca_cert_bundle_name);\n          if (\n            !ccf.kv[\"public:ccf.gov.tls.ca_cert_bundles\"].has(\n              caCertBundleNameBuf\n            )\n          ) {\n            throw new Error(\n              `No CA cert bundle found with name '${caCertBundleName}'`\n            );\n          }\n        }\n        const issuer = args.issuer;\n        const jwks = args.jwks;\n        delete args.jwks;\n        const metadata = args;\n        if (jwks) {\n          ccf.setJwtPublicSigningKeys(issuer, metadata, jwks);\n        }\n        const issuerBuf = ccf.strToBuf(issuer);\n        const metadataBuf = ccf.jsonCompatibleToBuf(metadata);\n        ccf.kv[\"public:ccf.gov.jwt.issuers\"].set(issuerBuf, metadataBuf);\n      }\n    ),\n  ],\n  [\n    \"set_jwt_public_signing_keys\",\n    new Action(\n      function (args) {\n        checkType(args.issuer, \"string\", \"issuer\");\n        checkJwks(args.jwks, \"jwks\");\n      },\n      function (args) {\n        const issuer = args.issuer;\n        const issuerBuf = ccf.strToBuf(issuer);\n        const metadataBuf = ccf.kv[\"public:ccf.gov.jwt.issuers\"].get(issuerBuf);\n        if (metadataBuf === undefined) {\n          throw new Error(`issuer ${issuer} not found`);\n        }\n        const metadata = ccf.bufToJsonCompatible(metadataBuf);\n        const jwks = args.jwks;\n        ccf.setJwtPublicSigningKeys(issuer, metadata, jwks);\n      }\n    ),\n  ],\n  [\n    \"remove_jwt_issuer\",\n    new Action(\n      function (args) {\n        checkType(args.issuer, \"string\", \"issuer\");\n      },\n      function (args) {\n        const issuerBuf = ccf.strToBuf(args.issuer);\n        if (!ccf.kv[\"public:ccf.gov.jwt.issuers\"].delete(issuerBuf)) {\n          return;\n        }\n        ccf.removeJwtPublicSigningKeys(args.issuer);\n      }\n    ),\n  ],\n  [\n     // custom logic specific to ACL\n    \"add_node_code\",\n    new Action(\n      function (args) {\n        checkType(args.new_code_id, \"string\", \"new_code_id\");\n        checkType(args.existing_code_id, \"string\", \"existing_code_id\");\n      },\n      function (args, proposalId) {\n        const existingCode = ccf.kv[\"public:ccf.gov.nodes.code_ids\"].get(\n          ccf.strToBuf(args.existing_code_id)\n        );\n        if (existingCode === undefined) {\n          throw new Error(`Code required to exist is not present: ${args.existing_code_id}`);\n        }\n\n        const newCodeId = ccf.strToBuf(args.new_code_id);\n        const ALLOWED = ccf.jsonCompatibleToBuf(\"AllowedToJoin\");\n        ccf.kv[\"public:ccf.gov.nodes.code_ids\"].set(newCodeId, ALLOWED);\n\n        // Adding a new allowed code ID changes the semantics of any other open proposals, so invalidate them to avoid confusion or malicious vote modification\n        invalidateOtherOpenProposals(proposalId);\n      }\n    ),\n  ],\n  [\n    \"set_node_data\",\n    new Action(\n      function (args) {\n        checkEntityId(args.node_id, \"node_id\");\n      },\n      function (args) {\n        let node_id = ccf.strToBuf(args.node_id);\n        let nodes_info = ccf.kv[\"public:ccf.gov.nodes.info\"];\n        let node_info = nodes_info.get(node_id);\n        if (node_info === undefined) {\n          throw new Error(`Node ${node_id} does not exist`);\n        }\n        let ni = ccf.bufToJsonCompatible(node_info);\n        ni.node_data = args.node_data;\n        nodes_info.set(node_id, ccf.jsonCompatibleToBuf(ni));\n      }\n    ),\n  ],\n  [\n    \"transition_node_to_trusted\",\n    new Action(\n      function (args) {\n        checkEntityId(args.node_id, \"node_id\");\n        checkType(args.valid_from, \"string\", \"valid_from\");\n        if (args.validity_period_days !== undefined) {\n          checkType(\n            args.validity_period_days,\n            \"integer\",\n            \"validity_period_days\"\n          );\n          checkBounds(\n            args.validity_period_days,\n            1,\n            null,\n            \"validity_period_days\"\n          );\n        }\n      },\n      function (args) {\n        const rawConfig = ccf.kv[\"public:ccf.gov.service.config\"].get(\n          getSingletonKvKey()\n        );\n        if (rawConfig === undefined) {\n          throw new Error(\"Service configuration could not be found\");\n        }\n        const serviceConfig = ccf.bufToJsonCompatible(rawConfig);\n        const node = ccf.kv[\"public:ccf.gov.nodes.info\"].get(\n          ccf.strToBuf(args.node_id)\n        );\n        if (node === undefined) {\n          throw new Error(`No such node: ${args.node_id}`);\n        }\n        const nodeInfo = ccf.bufToJsonCompatible(node);\n        if (nodeInfo.status === \"Pending\") {\n          nodeInfo.status =\n            serviceConfig.reconfiguration_type == \"TwoTransaction\"\n              ? \"Learner\"\n              : \"Trusted\";\n          nodeInfo.ledger_secret_seqno =\n            ccf.network.getLatestLedgerSecretSeqno();\n          ccf.kv[\"public:ccf.gov.nodes.info\"].set(\n            ccf.strToBuf(args.node_id),\n            ccf.jsonCompatibleToBuf(nodeInfo)\n          );\n\n          // Also generate and record service-endorsed node certificate from node CSR\n          if (\n            nodeInfo.certificate_signing_request !== undefined &&\n            serviceConfig.consensus !== \"BFT\"\n          ) {\n            // Note: CSR and node certificate validity config are only present from 2.x\n            const default_validity_period_days = 365;\n            const max_allowed_cert_validity_period_days =\n              serviceConfig.maximum_node_certificate_validity_days ??\n              default_validity_period_days;\n            if (\n              args.validity_period_days !== undefined &&\n              args.validity_period_days > max_allowed_cert_validity_period_days\n            ) {\n              throw new Error(\n                `Validity period ${args.validity_period_days} is not allowed: max allowed is ${max_allowed_cert_validity_period_days}`\n              );\n            }\n\n            const endorsed_node_cert = ccf.network.generateEndorsedCertificate(\n              nodeInfo.certificate_signing_request,\n              args.valid_from,\n              args.validity_period_days ?? max_allowed_cert_validity_period_days\n            );\n            ccf.kv[\"public:ccf.gov.nodes.endorsed_certificates\"].set(\n              ccf.strToBuf(args.node_id),\n              ccf.strToBuf(endorsed_node_cert)\n            );\n          }\n        }\n      }\n    ),\n  ],\n  [\n    // custom logic for ACL\n    \"remove_node_code\",\n    new Action(\n      function (args) {\n        checkType(args.code_id_to_remove, \"string\", \"code_id_to_remove\");\n        checkType(args.remaining_code_id, \"string\", \"remaining_code_id\");\n      },\n      function (args) {\n        const remainingCode = ccf.kv[\"public:ccf.gov.nodes.code_ids\"].get(\n          ccf.strToBuf(args.remaining_code_id)\n        );\n        if (remainingCode === undefined) {\n          throw new Error(`Code required to remain is not present: ${args.remaining_code_id}`);\n        }\n\n        const codeIdToRemove = ccf.strToBuf(args.code_id_to_remove);\n        ccf.kv[\"public:ccf.gov.nodes.code_ids\"].delete(codeIdToRemove);\n      }\n    ),\n  ],\n  [\n    \"remove_node\",\n    new Action(\n      function (args) {\n        checkEntityId(args.node_id, \"node_id\");\n      },\n      function (args) {\n        const rawConfig = ccf.kv[\"public:ccf.gov.service.config\"].get(\n          getSingletonKvKey()\n        );\n        if (rawConfig === undefined) {\n          throw new Error(\"Service configuration could not be found\");\n        }\n        const serviceConfig = ccf.bufToJsonCompatible(rawConfig);\n        const node = ccf.kv[\"public:ccf.gov.nodes.info\"].get(\n          ccf.strToBuf(args.node_id)\n        );\n        if (node === undefined) {\n          return;\n        }\n        const node_obj = ccf.bufToJsonCompatible(node);\n        if (node_obj.status === \"Pending\") {\n          ccf.kv[\"public:ccf.gov.nodes.info\"].delete(\n            ccf.strToBuf(args.node_id)\n          );\n        } else {\n          node_obj.status =\n            serviceConfig.reconfiguration_type === \"TwoTransaction\"\n              ? \"Retiring\"\n              : \"Retired\";\n          ccf.kv[\"public:ccf.gov.nodes.info\"].set(\n            ccf.strToBuf(args.node_id),\n            ccf.jsonCompatibleToBuf(node_obj)\n          );\n        }\n      }\n    ),\n  ],\n  [\n    \"set_node_certificate_validity\",\n    new Action(\n      function (args) {\n        checkEntityId(args.node_id, \"node_id\");\n        checkType(args.valid_from, \"string\", \"valid_from\");\n        if (args.validity_period_days !== undefined) {\n          checkType(\n            args.validity_period_days,\n            \"integer\",\n            \"validity_period_days\"\n          );\n          checkBounds(\n            args.validity_period_days,\n            1,\n            null,\n            \"validity_period_days\"\n          );\n        }\n      },\n      function (args) {\n        const node = ccf.kv[\"public:ccf.gov.nodes.info\"].get(\n          ccf.strToBuf(args.node_id)\n        );\n        if (node === undefined) {\n          throw new Error(`No such node: ${args.node_id}`);\n        }\n        const nodeInfo = ccf.bufToJsonCompatible(node);\n        if (nodeInfo.status !== \"Trusted\") {\n          throw new Error(`Node ${args.node_id} is not trusted`);\n        }\n\n        setNodeCertificateValidityPeriod(\n          args.node_id,\n          nodeInfo,\n          args.valid_from,\n          args.validity_period_days\n        );\n      }\n    ),\n  ],\n  [\n    \"set_all_nodes_certificate_validity\",\n    new Action(\n      function (args) {\n        checkType(args.valid_from, \"string\", \"valid_from\");\n        if (args.validity_period_days !== undefined) {\n          checkType(\n            args.validity_period_days,\n            \"integer\",\n            \"validity_period_days\"\n          );\n          checkBounds(\n            args.validity_period_days,\n            1,\n            null,\n            \"validity_period_days\"\n          );\n        }\n      },\n      function (args) {\n        ccf.kv[\"public:ccf.gov.nodes.info\"].forEach((v, k) => {\n          const nodeId = ccf.bufToStr(k);\n          const nodeInfo = ccf.bufToJsonCompatible(v);\n          if (nodeInfo.status === \"Trusted\") {\n            setNodeCertificateValidityPeriod(\n              nodeId,\n              nodeInfo,\n              args.valid_from,\n              args.validity_period_days\n            );\n          }\n        });\n      }\n    ),\n  ],\n  [\n    \"set_service_certificate_validity\",\n    new Action(\n      function (args) {\n        checkType(args.valid_from, \"string\", \"valid_from\");\n        if (args.validity_period_days !== undefined) {\n          checkType(\n            args.validity_period_days,\n            \"integer\",\n            \"validity_period_days\"\n          );\n          checkBounds(\n            args.validity_period_days,\n            1,\n            null,\n            \"validity_period_days\"\n          );\n        }\n      },\n      function (args) {\n        setServiceCertificateValidityPeriod(\n          args.valid_from,\n          args.validity_period_days\n        );\n      }\n    ),\n  ],\n  [\n    \"set_service_configuration\",\n    new Action(\n      function (args) {\n        for (var key in args) {\n          if (key !== \"reconfiguration_type\" && key !== \"recovery_threshold\") {\n            throw new Error(\n              `Cannot change ${key} via set_service_configuration.`\n            );\n          }\n        }\n        checkType(args.reconfiguration_type, \"string?\", \"reconfiguration type\");\n        checkType(args.recovery_threshold, \"integer?\", \"recovery threshold\");\n        checkBounds(args.recovery_threshold, 1, 254, \"recovery threshold\");\n      },\n      function (args) {\n        updateServiceConfig(args);\n      }\n    ),\n  ],\n  [\n    \"trigger_ledger_chunk\",\n    new Action(\n      function (args) {},\n      function (args, proposalId) {\n        ccf.node.triggerLedgerChunk();\n      }\n    ),\n  ],\n  [\n    \"trigger_snapshot\",\n    new Action(\n      function (args) {},\n      function (args, proposalId) {\n        ccf.node.triggerSnapshot();\n      }\n    ),\n  ],\n  [\n    \"set_service_principal\",\n    new Action(\n      function (args) {\n        checkType(args.id, \"string\", \"id\");\n        checkType(args.data, \"object\", \"data\");\n      },\n      function (args) {\n        ccf.kv[\"public:ccf.gov.service_principals\"].set(\n          ccf.strToBuf(args.id),\n          ccf.jsonCompatibleToBuf(args.data)\n        );\n      }\n    ),\n  ],\n  [\n    \"remove_service_principal\",\n    new Action(\n      function (args) {\n        checkType(args.id, \"string\", \"id\");\n      },\n      function (args) {\n        ccf.kv[\"public:ccf.gov.service_principals\"].delete(\n          ccf.strToBuf(args.id)\n        );\n      }\n    ),\n  ],\n]);\nexport function validate(input) {\n  let proposal = JSON.parse(input);\n  let errors = [];\n  let position = 0;\n  for (const action of proposal[\"actions\"]) {\n    const definition = actions.get(action.name);\n    if (definition) {\n      try {\n        definition.validate(action.args);\n      } catch (e) {\n        errors.push(\n          `${action.name} at position ${position} failed validation: ${e}\\n${e.stack}`\n        );\n      }\n    } else {\n      errors.push(`${action.name}: no such action`);\n    }\n    position++;\n  }\n  return { valid: errors.length === 0, description: errors.join(\", \") };\n}\nfunction getMemberInfo(memberId) {\n  const key = ccf.strToBuf(memberId);\n  const value = ccf.kv[\"public:ccf.gov.members.info\"].get(key);\n  const info = ccf.bufToJsonCompatible(value);\n  return info;\n}\n\n// Returns true if the member is a recovery member.\nfunction isRecoveryMember(memberId) {\n  const info = getMemberInfo(memberId);\n  if (info.member_data.encryption_pub_key) {\n    return true;\n  }\n  return false;\n}\n\n// Defines which of the members are operators.\nfunction isOperator(memberId) {\n  // // Operators cannot be recovery members.\n  // if (isRecoveryMember(memberId)) {\n  //   return false;\n  // }\n  const info = getMemberInfo(memberId);\n  return info.member_data.is_operator;\n}\n\n// Defines actions that can be passed with sole operator input.\nfunction canOperatorPass(action) {\n  // To enable code upgrades and disaster recovery for Public Preview, we've given the\n  // operator member some additional privileges.\n  // 1. add/remove node code are required for code upgrades.\n  // 2. set_constitution to replace this constitution with a \"correct\" one easily later on.\n  // 3. set_member to add a new member for privileged operations when we use MHSM keys.\n  const allowedOperatorActions = [\n    \"add_node_code\", // Remove\n    \"remove_ca_cert_bundle\",\n    \"remove_jwt_issuer\",\n    \"remove_node\",\n    \"remove_node_code\", // Remove\n    \"remove_service_principal\",\n    \"remove_user\",\n    \"remove_user_by_cert\",\n    \"set_ca_cert_bundle\",\n    \"set_constitution\", // Remove\n    \"set_js_app\",\n    \"set_jwt_issuer\",\n    \"set_jwt_public_signing_keys\",\n    \"set_member\", // Remove,\n    \"set_node_certificate_validity\",\n    \"set_node_data\",\n    \"set_service_certificate_validity\",\n    \"set_service_configuration\",\n    \"set_service_principal\",\n    \"set_user\",\n    \"set_user_data\",\n    \"transition_node_to_trusted\",\n    \"transition_service_to_open\"\n  ];\n\n  if (allowedOperatorActions.includes(action.name)) {\n    return true;\n  }\n  // Additionally, operators can add or retire other operators.\n  if (action.name === \"set_member\") {\n    const memberData = action.args[\"member_data\"];\n    if (memberData && memberData.is_operator) {\n      return true;\n    }\n  } else if (action.name === \"remove_member\") {\n    const memberId = ccf.pemToId(action.args.cert);\n    if (isOperator(memberId)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function resolve(proposal, proposerId, votes) {\n  const actions = JSON.parse(proposal)[\"actions\"];\n\n  // Count member votes.\n  const memberVoteCount = votes.filter(\n    (v) => v.vote && !isOperator(v.member_id)\n  ).length;\n\n  // Count active members, excluding operators.\n  let activeMemberCount = 0;\n  ccf.kv[\"public:ccf.gov.members.info\"].forEach((value, key) => {\n    const memberId = ccf.bufToStr(key);\n    const info = ccf.bufToJsonCompatible(value);\n    if (info.status === \"Active\" && !isOperator(memberId)) {\n      activeMemberCount++;\n    }\n  });\n\n  // A proposal is an operator change if it's only applying operator actions.\n  const isOperatorChange = actions.every(canOperatorPass);\n\n  // A majority of members can always accept a proposal.\n  if (memberVoteCount > Math.floor(activeMemberCount / 2)) {\n    return \"Accepted\";\n  }\n\n  // Operators proposing operator changes can accept them without a vote.\n  if (isOperatorChange && isOperator(proposerId)) {\n    return \"Accepted\";\n  }\n\n  return \"Open\";\n}"}, [
  'content-length',
  '45692',
  'content-type',
  'application/json',
  'x-ms-ccf-transaction-id',
  '4.41235',
  'x-ms-client-request-id',
  '2ea1010f-d1ae-47e9-a145-f80a71593905',
  'x-ms-request-id',
  '753525143'
]);
