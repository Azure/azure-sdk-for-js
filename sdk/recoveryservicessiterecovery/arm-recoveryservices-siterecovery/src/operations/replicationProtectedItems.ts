/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator } from "@azure/core-paging";
import { ReplicationProtectedItems } from "../operationsInterfaces";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { SiteRecoveryManagementClient } from "../siteRecoveryManagementClient";
import { PollerLike, PollOperationState, LroEngine } from "@azure/core-lro";
import { LroImpl } from "../lroImpl";
import {
  ReplicationProtectedItem,
  ReplicationProtectedItemsListByReplicationProtectionContainersNextOptionalParams,
  ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams,
  ReplicationProtectedItemsListNextOptionalParams,
  ReplicationProtectedItemsListOptionalParams,
  ReplicationProtectedItemsListByReplicationProtectionContainersResponse,
  ReplicationProtectedItemsGetOptionalParams,
  ReplicationProtectedItemsGetResponse,
  EnableProtectionInput,
  ReplicationProtectedItemsCreateOptionalParams,
  ReplicationProtectedItemsCreateResponse,
  ReplicationProtectedItemsPurgeOptionalParams,
  UpdateReplicationProtectedItemInput,
  ReplicationProtectedItemsUpdateOptionalParams,
  ReplicationProtectedItemsUpdateResponse,
  AddDisksInput,
  ReplicationProtectedItemsAddDisksOptionalParams,
  ReplicationProtectedItemsAddDisksResponse,
  ApplyRecoveryPointInput,
  ReplicationProtectedItemsApplyRecoveryPointOptionalParams,
  ReplicationProtectedItemsApplyRecoveryPointResponse,
  ReplicationProtectedItemsFailoverCancelOptionalParams,
  ReplicationProtectedItemsFailoverCancelResponse,
  ReplicationProtectedItemsFailoverCommitOptionalParams,
  ReplicationProtectedItemsFailoverCommitResponse,
  PlannedFailoverInput,
  ReplicationProtectedItemsPlannedFailoverOptionalParams,
  ReplicationProtectedItemsPlannedFailoverResponse,
  DisableProtectionInput,
  ReplicationProtectedItemsDeleteOptionalParams,
  RemoveDisksInput,
  ReplicationProtectedItemsRemoveDisksOptionalParams,
  ReplicationProtectedItemsRemoveDisksResponse,
  ReplicationProtectedItemsRepairReplicationOptionalParams,
  ReplicationProtectedItemsRepairReplicationResponse,
  ReverseReplicationInput,
  ReplicationProtectedItemsReprotectOptionalParams,
  ReplicationProtectedItemsReprotectResponse,
  ResolveHealthInput,
  ReplicationProtectedItemsResolveHealthErrorsOptionalParams,
  ReplicationProtectedItemsResolveHealthErrorsResponse,
  SwitchProviderInput,
  ReplicationProtectedItemsSwitchProviderOptionalParams,
  ReplicationProtectedItemsSwitchProviderResponse,
  TestFailoverInput,
  ReplicationProtectedItemsTestFailoverOptionalParams,
  ReplicationProtectedItemsTestFailoverResponse,
  TestFailoverCleanupInput,
  ReplicationProtectedItemsTestFailoverCleanupOptionalParams,
  ReplicationProtectedItemsTestFailoverCleanupResponse,
  UnplannedFailoverInput,
  ReplicationProtectedItemsUnplannedFailoverOptionalParams,
  ReplicationProtectedItemsUnplannedFailoverResponse,
  UpdateApplianceForReplicationProtectedItemInput,
  ReplicationProtectedItemsUpdateApplianceOptionalParams,
  ReplicationProtectedItemsUpdateApplianceResponse,
  UpdateMobilityServiceRequest,
  ReplicationProtectedItemsUpdateMobilityServiceOptionalParams,
  ReplicationProtectedItemsUpdateMobilityServiceResponse,
  ReplicationProtectedItemsListResponse,
  ReplicationProtectedItemsListByReplicationProtectionContainersNextResponse,
  ReplicationProtectedItemsListNextResponse
} from "../models";

/// <reference lib="esnext.asynciterable" />
/** Class containing ReplicationProtectedItems operations. */
export class ReplicationProtectedItemsImpl
  implements ReplicationProtectedItems {
  private readonly client: SiteRecoveryManagementClient;

  /**
   * Initialize a new instance of the class ReplicationProtectedItems class.
   * @param client Reference to the service client
   */
  constructor(client: SiteRecoveryManagementClient) {
    this.client = client;
  }

  /**
   * Gets the list of ASR replication protected items in the protection container.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param options The options parameters.
   */
  public listByReplicationProtectionContainers(
    fabricName: string,
    protectionContainerName: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams
  ): PagedAsyncIterableIterator<ReplicationProtectedItem> {
    const iter = this.listByReplicationProtectionContainersPagingAll(
      fabricName,
      protectionContainerName,
      options
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listByReplicationProtectionContainersPagingPage(
          fabricName,
          protectionContainerName,
          options
        );
      }
    };
  }

  private async *listByReplicationProtectionContainersPagingPage(
    fabricName: string,
    protectionContainerName: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams
  ): AsyncIterableIterator<ReplicationProtectedItem[]> {
    let result = await this._listByReplicationProtectionContainers(
      fabricName,
      protectionContainerName,
      options
    );
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listByReplicationProtectionContainersNext(
        fabricName,
        protectionContainerName,
        continuationToken,
        options
      );
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listByReplicationProtectionContainersPagingAll(
    fabricName: string,
    protectionContainerName: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams
  ): AsyncIterableIterator<ReplicationProtectedItem> {
    for await (const page of this.listByReplicationProtectionContainersPagingPage(
      fabricName,
      protectionContainerName,
      options
    )) {
      yield* page;
    }
  }

  /**
   * Gets the list of ASR replication protected items in the vault.
   * @param options The options parameters.
   */
  public list(
    options?: ReplicationProtectedItemsListOptionalParams
  ): PagedAsyncIterableIterator<ReplicationProtectedItem> {
    const iter = this.listPagingAll(options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: () => {
        return this.listPagingPage(options);
      }
    };
  }

  private async *listPagingPage(
    options?: ReplicationProtectedItemsListOptionalParams
  ): AsyncIterableIterator<ReplicationProtectedItem[]> {
    let result = await this._list(options);
    yield result.value || [];
    let continuationToken = result.nextLink;
    while (continuationToken) {
      result = await this._listNext(continuationToken, options);
      continuationToken = result.nextLink;
      yield result.value || [];
    }
  }

  private async *listPagingAll(
    options?: ReplicationProtectedItemsListOptionalParams
  ): AsyncIterableIterator<ReplicationProtectedItem> {
    for await (const page of this.listPagingPage(options)) {
      yield* page;
    }
  }

  /**
   * Gets the list of ASR replication protected items in the protection container.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param options The options parameters.
   */
  private _listByReplicationProtectionContainers(
    fabricName: string,
    protectionContainerName: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams
  ): Promise<
    ReplicationProtectedItemsListByReplicationProtectionContainersResponse
  > {
    return this.client.sendOperationRequest(
      { fabricName, protectionContainerName, options },
      listByReplicationProtectionContainersOperationSpec
    );
  }

  /**
   * Gets the details of an ASR replication protected item.
   * @param fabricName Fabric unique name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  get(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsGetOptionalParams
  ): Promise<ReplicationProtectedItemsGetResponse> {
    return this.client.sendOperationRequest(
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options
      },
      getOperationSpec
    );
  }

  /**
   * The operation to create an ASR replication protected item (Enable replication).
   * @param fabricName Name of the fabric.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName A name for the replication protected item.
   * @param input Enable Protection Input.
   * @param options The options parameters.
   */
  async beginCreate(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    input: EnableProtectionInput,
    options?: ReplicationProtectedItemsCreateOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsCreateResponse>,
      ReplicationProtectedItemsCreateResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsCreateResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        input,
        options
      },
      createOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * The operation to create an ASR replication protected item (Enable replication).
   * @param fabricName Name of the fabric.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName A name for the replication protected item.
   * @param input Enable Protection Input.
   * @param options The options parameters.
   */
  async beginCreateAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    input: EnableProtectionInput,
    options?: ReplicationProtectedItemsCreateOptionalParams
  ): Promise<ReplicationProtectedItemsCreateResponse> {
    const poller = await this.beginCreate(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      input,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to delete or purge a replication protected item. This operation will force delete the
   * replication protected item. Use the remove operation on replication protected item to perform a
   * clean disable replication for the item.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginPurge(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsPurgeOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options
      },
      purgeOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * The operation to delete or purge a replication protected item. This operation will force delete the
   * replication protected item. Use the remove operation on replication protected item to perform a
   * clean disable replication for the item.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginPurgeAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsPurgeOptionalParams
  ): Promise<void> {
    const poller = await this.beginPurge(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to update the recovery settings of an ASR replication protected item.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param updateProtectionInput Update protection input.
   * @param options The options parameters.
   */
  async beginUpdate(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    updateProtectionInput: UpdateReplicationProtectedItemInput,
    options?: ReplicationProtectedItemsUpdateOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsUpdateResponse>,
      ReplicationProtectedItemsUpdateResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsUpdateResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        updateProtectionInput,
        options
      },
      updateOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * The operation to update the recovery settings of an ASR replication protected item.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param updateProtectionInput Update protection input.
   * @param options The options parameters.
   */
  async beginUpdateAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    updateProtectionInput: UpdateReplicationProtectedItemInput,
    options?: ReplicationProtectedItemsUpdateOptionalParams
  ): Promise<ReplicationProtectedItemsUpdateResponse> {
    const poller = await this.beginUpdate(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      updateProtectionInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to add disks(s) to the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param addDisksInput Add disks input.
   * @param options The options parameters.
   */
  async beginAddDisks(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    addDisksInput: AddDisksInput,
    options?: ReplicationProtectedItemsAddDisksOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsAddDisksResponse>,
      ReplicationProtectedItemsAddDisksResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsAddDisksResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        addDisksInput,
        options
      },
      addDisksOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to add disks(s) to the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param addDisksInput Add disks input.
   * @param options The options parameters.
   */
  async beginAddDisksAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    addDisksInput: AddDisksInput,
    options?: ReplicationProtectedItemsAddDisksOptionalParams
  ): Promise<ReplicationProtectedItemsAddDisksResponse> {
    const poller = await this.beginAddDisks(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      addDisksInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to change the recovery point of a failed over replication protected item.
   * @param fabricName The ARM fabric name.
   * @param protectionContainerName The protection container name.
   * @param replicatedProtectedItemName The replicated protected item name.
   * @param applyRecoveryPointInput The ApplyRecoveryPointInput.
   * @param options The options parameters.
   */
  async beginApplyRecoveryPoint(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    applyRecoveryPointInput: ApplyRecoveryPointInput,
    options?: ReplicationProtectedItemsApplyRecoveryPointOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsApplyRecoveryPointResponse>,
      ReplicationProtectedItemsApplyRecoveryPointResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsApplyRecoveryPointResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        applyRecoveryPointInput,
        options
      },
      applyRecoveryPointOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * The operation to change the recovery point of a failed over replication protected item.
   * @param fabricName The ARM fabric name.
   * @param protectionContainerName The protection container name.
   * @param replicatedProtectedItemName The replicated protected item name.
   * @param applyRecoveryPointInput The ApplyRecoveryPointInput.
   * @param options The options parameters.
   */
  async beginApplyRecoveryPointAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    applyRecoveryPointInput: ApplyRecoveryPointInput,
    options?: ReplicationProtectedItemsApplyRecoveryPointOptionalParams
  ): Promise<ReplicationProtectedItemsApplyRecoveryPointResponse> {
    const poller = await this.beginApplyRecoveryPoint(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      applyRecoveryPointInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to cancel the failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginFailoverCancel(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsFailoverCancelOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsFailoverCancelResponse>,
      ReplicationProtectedItemsFailoverCancelResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsFailoverCancelResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options
      },
      failoverCancelOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to cancel the failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginFailoverCancelAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsFailoverCancelOptionalParams
  ): Promise<ReplicationProtectedItemsFailoverCancelResponse> {
    const poller = await this.beginFailoverCancel(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to commit the failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginFailoverCommit(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsFailoverCommitOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsFailoverCommitResponse>,
      ReplicationProtectedItemsFailoverCommitResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsFailoverCommitResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options
      },
      failoverCommitOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to commit the failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginFailoverCommitAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsFailoverCommitOptionalParams
  ): Promise<ReplicationProtectedItemsFailoverCommitResponse> {
    const poller = await this.beginFailoverCommit(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to initiate a planned failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param failoverInput Planned failover input.
   * @param options The options parameters.
   */
  async beginPlannedFailover(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    failoverInput: PlannedFailoverInput,
    options?: ReplicationProtectedItemsPlannedFailoverOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsPlannedFailoverResponse>,
      ReplicationProtectedItemsPlannedFailoverResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsPlannedFailoverResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        failoverInput,
        options
      },
      plannedFailoverOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to initiate a planned failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param failoverInput Planned failover input.
   * @param options The options parameters.
   */
  async beginPlannedFailoverAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    failoverInput: PlannedFailoverInput,
    options?: ReplicationProtectedItemsPlannedFailoverOptionalParams
  ): Promise<ReplicationProtectedItemsPlannedFailoverResponse> {
    const poller = await this.beginPlannedFailover(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      failoverInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to disable replication on a replication protected item. This will also remove the
   * item.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param disableProtectionInput Disable protection input.
   * @param options The options parameters.
   */
  async beginDelete(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    disableProtectionInput: DisableProtectionInput,
    options?: ReplicationProtectedItemsDeleteOptionalParams
  ): Promise<PollerLike<PollOperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        disableProtectionInput,
        options
      },
      deleteOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * The operation to disable replication on a replication protected item. This will also remove the
   * item.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param disableProtectionInput Disable protection input.
   * @param options The options parameters.
   */
  async beginDeleteAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    disableProtectionInput: DisableProtectionInput,
    options?: ReplicationProtectedItemsDeleteOptionalParams
  ): Promise<void> {
    const poller = await this.beginDelete(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      disableProtectionInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to remove disk(s) from the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param removeDisksInput Remove disks input.
   * @param options The options parameters.
   */
  async beginRemoveDisks(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    removeDisksInput: RemoveDisksInput,
    options?: ReplicationProtectedItemsRemoveDisksOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsRemoveDisksResponse>,
      ReplicationProtectedItemsRemoveDisksResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsRemoveDisksResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        removeDisksInput,
        options
      },
      removeDisksOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to remove disk(s) from the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param removeDisksInput Remove disks input.
   * @param options The options parameters.
   */
  async beginRemoveDisksAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    removeDisksInput: RemoveDisksInput,
    options?: ReplicationProtectedItemsRemoveDisksOptionalParams
  ): Promise<ReplicationProtectedItemsRemoveDisksResponse> {
    const poller = await this.beginRemoveDisks(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      removeDisksInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to start resynchronize/repair replication for a replication protected item requiring
   * resynchronization.
   * @param fabricName The name of the fabric.
   * @param protectionContainerName The name of the container.
   * @param replicatedProtectedItemName The name of the replication protected item.
   * @param options The options parameters.
   */
  async beginRepairReplication(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsRepairReplicationOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsRepairReplicationResponse>,
      ReplicationProtectedItemsRepairReplicationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsRepairReplicationResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options
      },
      repairReplicationOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * The operation to start resynchronize/repair replication for a replication protected item requiring
   * resynchronization.
   * @param fabricName The name of the fabric.
   * @param protectionContainerName The name of the container.
   * @param replicatedProtectedItemName The name of the replication protected item.
   * @param options The options parameters.
   */
  async beginRepairReplicationAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsRepairReplicationOptionalParams
  ): Promise<ReplicationProtectedItemsRepairReplicationResponse> {
    const poller = await this.beginRepairReplication(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to reprotect or reverse replicate a failed over replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param reprotectInput Reverse replication input.
   * @param options The options parameters.
   */
  async beginReprotect(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    reprotectInput: ReverseReplicationInput,
    options?: ReplicationProtectedItemsReprotectOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsReprotectResponse>,
      ReplicationProtectedItemsReprotectResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsReprotectResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        reprotectInput,
        options
      },
      reprotectOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to reprotect or reverse replicate a failed over replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param reprotectInput Reverse replication input.
   * @param options The options parameters.
   */
  async beginReprotectAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    reprotectInput: ReverseReplicationInput,
    options?: ReplicationProtectedItemsReprotectOptionalParams
  ): Promise<ReplicationProtectedItemsReprotectResponse> {
    const poller = await this.beginReprotect(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      reprotectInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to resolve health issues of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param resolveHealthInput Health issue input object.
   * @param options The options parameters.
   */
  async beginResolveHealthErrors(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    resolveHealthInput: ResolveHealthInput,
    options?: ReplicationProtectedItemsResolveHealthErrorsOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsResolveHealthErrorsResponse>,
      ReplicationProtectedItemsResolveHealthErrorsResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsResolveHealthErrorsResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        resolveHealthInput,
        options
      },
      resolveHealthErrorsOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to resolve health issues of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param resolveHealthInput Health issue input object.
   * @param options The options parameters.
   */
  async beginResolveHealthErrorsAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    resolveHealthInput: ResolveHealthInput,
    options?: ReplicationProtectedItemsResolveHealthErrorsOptionalParams
  ): Promise<ReplicationProtectedItemsResolveHealthErrorsResponse> {
    const poller = await this.beginResolveHealthErrors(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      resolveHealthInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to initiate a switch provider of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param switchProviderInput Switch provider input.
   * @param options The options parameters.
   */
  async beginSwitchProvider(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    switchProviderInput: SwitchProviderInput,
    options?: ReplicationProtectedItemsSwitchProviderOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsSwitchProviderResponse>,
      ReplicationProtectedItemsSwitchProviderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsSwitchProviderResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        switchProviderInput,
        options
      },
      switchProviderOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      lroResourceLocationConfig: "azure-async-operation"
    });
  }

  /**
   * Operation to initiate a switch provider of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param switchProviderInput Switch provider input.
   * @param options The options parameters.
   */
  async beginSwitchProviderAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    switchProviderInput: SwitchProviderInput,
    options?: ReplicationProtectedItemsSwitchProviderOptionalParams
  ): Promise<ReplicationProtectedItemsSwitchProviderResponse> {
    const poller = await this.beginSwitchProvider(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      switchProviderInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to perform a test failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param testfailoverInput Test failover input.
   * @param options The options parameters.
   */
  async beginTestFailover(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    testfailoverInput: TestFailoverInput,
    options?: ReplicationProtectedItemsTestFailoverOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsTestFailoverResponse>,
      ReplicationProtectedItemsTestFailoverResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsTestFailoverResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        testfailoverInput,
        options
      },
      testFailoverOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to perform a test failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param testfailoverInput Test failover input.
   * @param options The options parameters.
   */
  async beginTestFailoverAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    testfailoverInput: TestFailoverInput,
    options?: ReplicationProtectedItemsTestFailoverOptionalParams
  ): Promise<ReplicationProtectedItemsTestFailoverResponse> {
    const poller = await this.beginTestFailover(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      testfailoverInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to clean up the test failover of a replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param cleanupInput Test failover cleanup input.
   * @param options The options parameters.
   */
  async beginTestFailoverCleanup(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    cleanupInput: TestFailoverCleanupInput,
    options?: ReplicationProtectedItemsTestFailoverCleanupOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsTestFailoverCleanupResponse>,
      ReplicationProtectedItemsTestFailoverCleanupResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsTestFailoverCleanupResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        cleanupInput,
        options
      },
      testFailoverCleanupOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to clean up the test failover of a replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param cleanupInput Test failover cleanup input.
   * @param options The options parameters.
   */
  async beginTestFailoverCleanupAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    cleanupInput: TestFailoverCleanupInput,
    options?: ReplicationProtectedItemsTestFailoverCleanupOptionalParams
  ): Promise<ReplicationProtectedItemsTestFailoverCleanupResponse> {
    const poller = await this.beginTestFailoverCleanup(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      cleanupInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to initiate a failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param failoverInput Failover input.
   * @param options The options parameters.
   */
  async beginUnplannedFailover(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    failoverInput: UnplannedFailoverInput,
    options?: ReplicationProtectedItemsUnplannedFailoverOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsUnplannedFailoverResponse>,
      ReplicationProtectedItemsUnplannedFailoverResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsUnplannedFailoverResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        failoverInput,
        options
      },
      unplannedFailoverOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * Operation to initiate a failover of the replication protected item.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param failoverInput Failover input.
   * @param options The options parameters.
   */
  async beginUnplannedFailoverAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    failoverInput: UnplannedFailoverInput,
    options?: ReplicationProtectedItemsUnplannedFailoverOptionalParams
  ): Promise<ReplicationProtectedItemsUnplannedFailoverResponse> {
    const poller = await this.beginUnplannedFailover(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      failoverInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to update appliance of an ASR replication protected item.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param applianceUpdateInput Appliance update protection input.
   * @param options The options parameters.
   */
  async beginUpdateAppliance(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    applianceUpdateInput: UpdateApplianceForReplicationProtectedItemInput,
    options?: ReplicationProtectedItemsUpdateApplianceOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<ReplicationProtectedItemsUpdateApplianceResponse>,
      ReplicationProtectedItemsUpdateApplianceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsUpdateApplianceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        applianceUpdateInput,
        options
      },
      updateApplianceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * The operation to update appliance of an ASR replication protected item.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param applianceUpdateInput Appliance update protection input.
   * @param options The options parameters.
   */
  async beginUpdateApplianceAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    applianceUpdateInput: UpdateApplianceForReplicationProtectedItemInput,
    options?: ReplicationProtectedItemsUpdateApplianceOptionalParams
  ): Promise<ReplicationProtectedItemsUpdateApplianceResponse> {
    const poller = await this.beginUpdateAppliance(
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      applianceUpdateInput,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to update(push update) the installed mobility service software on a replication
   * protected item to the latest available version.
   * @param fabricName The name of the fabric containing the protected item.
   * @param protectionContainerName The name of the container containing the protected item.
   * @param replicationProtectedItemName The name of the protected item on which the agent is to be
   *                                     updated.
   * @param updateMobilityServiceRequest Request to update the mobility service on the protected item.
   * @param options The options parameters.
   */
  async beginUpdateMobilityService(
    fabricName: string,
    protectionContainerName: string,
    replicationProtectedItemName: string,
    updateMobilityServiceRequest: UpdateMobilityServiceRequest,
    options?: ReplicationProtectedItemsUpdateMobilityServiceOptionalParams
  ): Promise<
    PollerLike<
      PollOperationState<
        ReplicationProtectedItemsUpdateMobilityServiceResponse
      >,
      ReplicationProtectedItemsUpdateMobilityServiceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ): Promise<ReplicationProtectedItemsUpdateMobilityServiceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec
    ) => {
      let currentRawResponse:
        | coreClient.FullOperationResponse
        | undefined = undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback
        }
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON()
        }
      };
    };

    const lro = new LroImpl(
      sendOperation,
      {
        fabricName,
        protectionContainerName,
        replicationProtectedItemName,
        updateMobilityServiceRequest,
        options
      },
      updateMobilityServiceOperationSpec
    );
    return new LroEngine(lro, {
      resumeFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs
    });
  }

  /**
   * The operation to update(push update) the installed mobility service software on a replication
   * protected item to the latest available version.
   * @param fabricName The name of the fabric containing the protected item.
   * @param protectionContainerName The name of the container containing the protected item.
   * @param replicationProtectedItemName The name of the protected item on which the agent is to be
   *                                     updated.
   * @param updateMobilityServiceRequest Request to update the mobility service on the protected item.
   * @param options The options parameters.
   */
  async beginUpdateMobilityServiceAndWait(
    fabricName: string,
    protectionContainerName: string,
    replicationProtectedItemName: string,
    updateMobilityServiceRequest: UpdateMobilityServiceRequest,
    options?: ReplicationProtectedItemsUpdateMobilityServiceOptionalParams
  ): Promise<ReplicationProtectedItemsUpdateMobilityServiceResponse> {
    const poller = await this.beginUpdateMobilityService(
      fabricName,
      protectionContainerName,
      replicationProtectedItemName,
      updateMobilityServiceRequest,
      options
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the list of ASR replication protected items in the vault.
   * @param options The options parameters.
   */
  private _list(
    options?: ReplicationProtectedItemsListOptionalParams
  ): Promise<ReplicationProtectedItemsListResponse> {
    return this.client.sendOperationRequest({ options }, listOperationSpec);
  }

  /**
   * ListByReplicationProtectionContainersNext
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListByReplicationProtectionContainers method.
   * @param options The options parameters.
   */
  private _listByReplicationProtectionContainersNext(
    fabricName: string,
    protectionContainerName: string,
    nextLink: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersNextOptionalParams
  ): Promise<
    ReplicationProtectedItemsListByReplicationProtectionContainersNextResponse
  > {
    return this.client.sendOperationRequest(
      { fabricName, protectionContainerName, nextLink, options },
      listByReplicationProtectionContainersNextOperationSpec
    );
  }

  /**
   * ListNext
   * @param nextLink The nextLink from the previous successful call to the List method.
   * @param options The options parameters.
   */
  private _listNext(
    nextLink: string,
    options?: ReplicationProtectedItemsListNextOptionalParams
  ): Promise<ReplicationProtectedItemsListNextResponse> {
    return this.client.sendOperationRequest(
      { nextLink, options },
      listNextOperationSpec
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listByReplicationProtectionContainersOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItemCollection
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const getOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const createOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.input6,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const purgeOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  serializer
};
const updateOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.updateProtectionInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const addDisksOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/addDisks",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.addDisksInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const applyRecoveryPointOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/applyRecoveryPoint",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.applyRecoveryPointInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const failoverCancelOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/failoverCancel",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const failoverCommitOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/failoverCommit",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const plannedFailoverOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/plannedFailover",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.failoverInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const deleteOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/remove",
  httpMethod: "POST",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  requestBody: Parameters.disableProtectionInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer
};
const removeDisksOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/removeDisks",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.removeDisksInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const repairReplicationOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/repairReplication",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const reprotectOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/reProtect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.reprotectInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const resolveHealthErrorsOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/resolveHealthErrors",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.resolveHealthInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const switchProviderOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/switchProvider",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.switchProviderInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const testFailoverOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/testFailover",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.testfailoverInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const testFailoverCleanupOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/testFailoverCleanup",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.cleanupInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const unplannedFailoverOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/unplannedFailover",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.failoverInput1,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const updateApplianceOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/updateAppliance",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.applianceUpdateInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const updateMobilityServiceOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicationProtectedItemName}/updateMobilityService",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem
    }
  },
  requestBody: Parameters.updateMobilityServiceRequest,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicationProtectedItemName
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer
};
const listOperationSpec: coreClient.OperationSpec = {
  path:
    "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationProtectedItems",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItemCollection
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter,
    Parameters.skipToken
  ],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listByReplicationProtectionContainersNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItemCollection
    }
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.nextLink,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
const listNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItemCollection
    }
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter,
    Parameters.skipToken
  ],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.nextLink,
    Parameters.resourceName
  ],
  headerParameters: [Parameters.accept],
  serializer
};
