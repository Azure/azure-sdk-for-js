/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import { PagedAsyncIterableIterator, PageSettings } from "@azure/core-paging";
import { setContinuationToken } from "../pagingHelper.js";
import { ReplicationProtectedItems } from "../operationsInterfaces/index.js";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers.js";
import * as Parameters from "../models/parameters.js";
import { SiteRecoveryManagementClient } from "../siteRecoveryManagementClient.js";
import {
  SimplePollerLike,
  OperationState,
  createHttpPoller,
} from "@azure/core-lro";
import { createLroSpec } from "../lroImpl.js";
import {
  ReplicationProtectedItem,
  ReplicationProtectedItemsListByReplicationProtectionContainersNextOptionalParams,
  ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams,
  ReplicationProtectedItemsListByReplicationProtectionContainersResponse,
  ReplicationProtectedItemsListNextOptionalParams,
  ReplicationProtectedItemsListOptionalParams,
  ReplicationProtectedItemsListResponse,
  ReplicationProtectedItemsGetOptionalParams,
  ReplicationProtectedItemsGetResponse,
  EnableProtectionInput,
  ReplicationProtectedItemsCreateOptionalParams,
  ReplicationProtectedItemsCreateResponse,
  ReplicationProtectedItemsPurgeOptionalParams,
  UpdateReplicationProtectedItemInput,
  ReplicationProtectedItemsUpdateOptionalParams,
  ReplicationProtectedItemsUpdateResponse,
  AddDisksInput,
  ReplicationProtectedItemsAddDisksOptionalParams,
  ReplicationProtectedItemsAddDisksResponse,
  ApplyRecoveryPointInput,
  ReplicationProtectedItemsApplyRecoveryPointOptionalParams,
  ReplicationProtectedItemsApplyRecoveryPointResponse,
  ReplicationProtectedItemsFailoverCancelOptionalParams,
  ReplicationProtectedItemsFailoverCancelResponse,
  ReplicationProtectedItemsFailoverCommitOptionalParams,
  ReplicationProtectedItemsFailoverCommitResponse,
  PlannedFailoverInput,
  ReplicationProtectedItemsPlannedFailoverOptionalParams,
  ReplicationProtectedItemsPlannedFailoverResponse,
  DisableProtectionInput,
  ReplicationProtectedItemsDeleteOptionalParams,
  RemoveDisksInput,
  ReplicationProtectedItemsRemoveDisksOptionalParams,
  ReplicationProtectedItemsRemoveDisksResponse,
  ReplicationProtectedItemsRepairReplicationOptionalParams,
  ReplicationProtectedItemsRepairReplicationResponse,
  ReverseReplicationInput,
  ReplicationProtectedItemsReprotectOptionalParams,
  ReplicationProtectedItemsReprotectResponse,
  ResolveHealthInput,
  ReplicationProtectedItemsResolveHealthErrorsOptionalParams,
  ReplicationProtectedItemsResolveHealthErrorsResponse,
  SwitchProviderInput,
  ReplicationProtectedItemsSwitchProviderOptionalParams,
  ReplicationProtectedItemsSwitchProviderResponse,
  TestFailoverInput,
  ReplicationProtectedItemsTestFailoverOptionalParams,
  ReplicationProtectedItemsTestFailoverResponse,
  TestFailoverCleanupInput,
  ReplicationProtectedItemsTestFailoverCleanupOptionalParams,
  ReplicationProtectedItemsTestFailoverCleanupResponse,
  UnplannedFailoverInput,
  ReplicationProtectedItemsUnplannedFailoverOptionalParams,
  ReplicationProtectedItemsUnplannedFailoverResponse,
  UpdateApplianceForReplicationProtectedItemInput,
  ReplicationProtectedItemsUpdateApplianceOptionalParams,
  ReplicationProtectedItemsUpdateApplianceResponse,
  UpdateMobilityServiceRequest,
  ReplicationProtectedItemsUpdateMobilityServiceOptionalParams,
  ReplicationProtectedItemsUpdateMobilityServiceResponse,
  ReplicationProtectedItemsListByReplicationProtectionContainersNextResponse,
  ReplicationProtectedItemsListNextResponse,
} from "../models/index.js";

/// <reference lib="esnext.asynciterable" />
/** Class containing ReplicationProtectedItems operations. */
export class ReplicationProtectedItemsImpl
  implements ReplicationProtectedItems
{
  private readonly client: SiteRecoveryManagementClient;

  /**
   * Initialize a new instance of the class ReplicationProtectedItems class.
   * @param client Reference to the service client
   */
  constructor(client: SiteRecoveryManagementClient) {
    this.client = client;
  }

  /**
   * Gets the list of ASR replication protected items in the protection container.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param options The options parameters.
   */
  public listByReplicationProtectionContainers(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams,
  ): PagedAsyncIterableIterator<ReplicationProtectedItem> {
    const iter = this.listByReplicationProtectionContainersPagingAll(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      options,
    );
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listByReplicationProtectionContainersPagingPage(
          resourceGroupName,
          resourceName,
          fabricName,
          protectionContainerName,
          options,
          settings,
        );
      },
    };
  }

  private async *listByReplicationProtectionContainersPagingPage(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<ReplicationProtectedItem[]> {
    let result: ReplicationProtectedItemsListByReplicationProtectionContainersResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._listByReplicationProtectionContainers(
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        options,
      );
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listByReplicationProtectionContainersNext(
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listByReplicationProtectionContainersPagingAll(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams,
  ): AsyncIterableIterator<ReplicationProtectedItem> {
    for await (const page of this.listByReplicationProtectionContainersPagingPage(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Gets the list of ASR replication protected items in the vault.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param options The options parameters.
   */
  public list(
    resourceGroupName: string,
    resourceName: string,
    options?: ReplicationProtectedItemsListOptionalParams,
  ): PagedAsyncIterableIterator<ReplicationProtectedItem> {
    const iter = this.listPagingAll(resourceGroupName, resourceName, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings?: PageSettings) => {
        if (settings?.maxPageSize) {
          throw new Error("maxPageSize is not supported by this operation.");
        }
        return this.listPagingPage(
          resourceGroupName,
          resourceName,
          options,
          settings,
        );
      },
    };
  }

  private async *listPagingPage(
    resourceGroupName: string,
    resourceName: string,
    options?: ReplicationProtectedItemsListOptionalParams,
    settings?: PageSettings,
  ): AsyncIterableIterator<ReplicationProtectedItem[]> {
    let result: ReplicationProtectedItemsListResponse;
    let continuationToken = settings?.continuationToken;
    if (!continuationToken) {
      result = await this._list(resourceGroupName, resourceName, options);
      let page = result.value || [];
      continuationToken = result.nextLink;
      setContinuationToken(page, continuationToken);
      yield page;
    }
    while (continuationToken) {
      result = await this._listNext(
        resourceGroupName,
        resourceName,
        continuationToken,
        options,
      );
      continuationToken = result.nextLink;
      let page = result.value || [];
      setContinuationToken(page, continuationToken);
      yield page;
    }
  }

  private async *listPagingAll(
    resourceGroupName: string,
    resourceName: string,
    options?: ReplicationProtectedItemsListOptionalParams,
  ): AsyncIterableIterator<ReplicationProtectedItem> {
    for await (const page of this.listPagingPage(
      resourceGroupName,
      resourceName,
      options,
    )) {
      yield* page;
    }
  }

  /**
   * Gets the list of ASR replication protected items in the protection container.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param options The options parameters.
   */
  private _listByReplicationProtectionContainers(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersOptionalParams,
  ): Promise<ReplicationProtectedItemsListByReplicationProtectionContainersResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        options,
      },
      listByReplicationProtectionContainersOperationSpec,
    );
  }

  /**
   * Gets the details of an ASR replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric unique name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  get(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsGetOptionalParams,
  ): Promise<ReplicationProtectedItemsGetResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options,
      },
      getOperationSpec,
    );
  }

  /**
   * The operation to create an ASR replication protected item (Enable replication).
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Name of the fabric.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName A name for the replication protected item.
   * @param input Enable Protection Input.
   * @param options The options parameters.
   */
  async beginCreate(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    input: EnableProtectionInput,
    options?: ReplicationProtectedItemsCreateOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsCreateResponse>,
      ReplicationProtectedItemsCreateResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsCreateResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        input,
        options,
      },
      spec: createOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsCreateResponse,
      OperationState<ReplicationProtectedItemsCreateResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * The operation to create an ASR replication protected item (Enable replication).
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Name of the fabric.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName A name for the replication protected item.
   * @param input Enable Protection Input.
   * @param options The options parameters.
   */
  async beginCreateAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    input: EnableProtectionInput,
    options?: ReplicationProtectedItemsCreateOptionalParams,
  ): Promise<ReplicationProtectedItemsCreateResponse> {
    const poller = await this.beginCreate(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      input,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to delete or purge a replication protected item. This operation will force delete the
   * replication protected item. Use the remove operation on replication protected item to perform a
   * clean disable replication for the item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginPurge(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsPurgeOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options,
      },
      spec: purgeOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * The operation to delete or purge a replication protected item. This operation will force delete the
   * replication protected item. Use the remove operation on replication protected item to perform a
   * clean disable replication for the item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginPurgeAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsPurgeOptionalParams,
  ): Promise<void> {
    const poller = await this.beginPurge(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to update the recovery settings of an ASR replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param updateProtectionInput Update protection input.
   * @param options The options parameters.
   */
  async beginUpdate(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    updateProtectionInput: UpdateReplicationProtectedItemInput,
    options?: ReplicationProtectedItemsUpdateOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsUpdateResponse>,
      ReplicationProtectedItemsUpdateResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsUpdateResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        updateProtectionInput,
        options,
      },
      spec: updateOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsUpdateResponse,
      OperationState<ReplicationProtectedItemsUpdateResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * The operation to update the recovery settings of an ASR replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param updateProtectionInput Update protection input.
   * @param options The options parameters.
   */
  async beginUpdateAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    updateProtectionInput: UpdateReplicationProtectedItemInput,
    options?: ReplicationProtectedItemsUpdateOptionalParams,
  ): Promise<ReplicationProtectedItemsUpdateResponse> {
    const poller = await this.beginUpdate(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      updateProtectionInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to add disks(s) to the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param addDisksInput Add disks input.
   * @param options The options parameters.
   */
  async beginAddDisks(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    addDisksInput: AddDisksInput,
    options?: ReplicationProtectedItemsAddDisksOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsAddDisksResponse>,
      ReplicationProtectedItemsAddDisksResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsAddDisksResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        addDisksInput,
        options,
      },
      spec: addDisksOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsAddDisksResponse,
      OperationState<ReplicationProtectedItemsAddDisksResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to add disks(s) to the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param addDisksInput Add disks input.
   * @param options The options parameters.
   */
  async beginAddDisksAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    addDisksInput: AddDisksInput,
    options?: ReplicationProtectedItemsAddDisksOptionalParams,
  ): Promise<ReplicationProtectedItemsAddDisksResponse> {
    const poller = await this.beginAddDisks(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      addDisksInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to change the recovery point of a failed over replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName The ARM fabric name.
   * @param protectionContainerName The protection container name.
   * @param replicatedProtectedItemName The replicated protected item name.
   * @param applyRecoveryPointInput The ApplyRecoveryPointInput.
   * @param options The options parameters.
   */
  async beginApplyRecoveryPoint(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    applyRecoveryPointInput: ApplyRecoveryPointInput,
    options?: ReplicationProtectedItemsApplyRecoveryPointOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsApplyRecoveryPointResponse>,
      ReplicationProtectedItemsApplyRecoveryPointResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsApplyRecoveryPointResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        applyRecoveryPointInput,
        options,
      },
      spec: applyRecoveryPointOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsApplyRecoveryPointResponse,
      OperationState<ReplicationProtectedItemsApplyRecoveryPointResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * The operation to change the recovery point of a failed over replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName The ARM fabric name.
   * @param protectionContainerName The protection container name.
   * @param replicatedProtectedItemName The replicated protected item name.
   * @param applyRecoveryPointInput The ApplyRecoveryPointInput.
   * @param options The options parameters.
   */
  async beginApplyRecoveryPointAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    applyRecoveryPointInput: ApplyRecoveryPointInput,
    options?: ReplicationProtectedItemsApplyRecoveryPointOptionalParams,
  ): Promise<ReplicationProtectedItemsApplyRecoveryPointResponse> {
    const poller = await this.beginApplyRecoveryPoint(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      applyRecoveryPointInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to cancel the failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginFailoverCancel(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsFailoverCancelOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsFailoverCancelResponse>,
      ReplicationProtectedItemsFailoverCancelResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsFailoverCancelResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options,
      },
      spec: failoverCancelOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsFailoverCancelResponse,
      OperationState<ReplicationProtectedItemsFailoverCancelResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to cancel the failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginFailoverCancelAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsFailoverCancelOptionalParams,
  ): Promise<ReplicationProtectedItemsFailoverCancelResponse> {
    const poller = await this.beginFailoverCancel(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to commit the failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginFailoverCommit(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsFailoverCommitOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsFailoverCommitResponse>,
      ReplicationProtectedItemsFailoverCommitResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsFailoverCommitResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options,
      },
      spec: failoverCommitOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsFailoverCommitResponse,
      OperationState<ReplicationProtectedItemsFailoverCommitResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to commit the failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param options The options parameters.
   */
  async beginFailoverCommitAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsFailoverCommitOptionalParams,
  ): Promise<ReplicationProtectedItemsFailoverCommitResponse> {
    const poller = await this.beginFailoverCommit(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to initiate a planned failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param failoverInput Planned failover input.
   * @param options The options parameters.
   */
  async beginPlannedFailover(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    failoverInput: PlannedFailoverInput,
    options?: ReplicationProtectedItemsPlannedFailoverOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsPlannedFailoverResponse>,
      ReplicationProtectedItemsPlannedFailoverResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsPlannedFailoverResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        failoverInput,
        options,
      },
      spec: plannedFailoverOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsPlannedFailoverResponse,
      OperationState<ReplicationProtectedItemsPlannedFailoverResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to initiate a planned failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param failoverInput Planned failover input.
   * @param options The options parameters.
   */
  async beginPlannedFailoverAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    failoverInput: PlannedFailoverInput,
    options?: ReplicationProtectedItemsPlannedFailoverOptionalParams,
  ): Promise<ReplicationProtectedItemsPlannedFailoverResponse> {
    const poller = await this.beginPlannedFailover(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      failoverInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to disable replication on a replication protected item. This will also remove the
   * item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param disableProtectionInput Disable protection input.
   * @param options The options parameters.
   */
  async beginDelete(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    disableProtectionInput: DisableProtectionInput,
    options?: ReplicationProtectedItemsDeleteOptionalParams,
  ): Promise<SimplePollerLike<OperationState<void>, void>> {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<void> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        disableProtectionInput,
        options,
      },
      spec: deleteOperationSpec,
    });
    const poller = await createHttpPoller<void, OperationState<void>>(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * The operation to disable replication on a replication protected item. This will also remove the
   * item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param disableProtectionInput Disable protection input.
   * @param options The options parameters.
   */
  async beginDeleteAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    disableProtectionInput: DisableProtectionInput,
    options?: ReplicationProtectedItemsDeleteOptionalParams,
  ): Promise<void> {
    const poller = await this.beginDelete(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      disableProtectionInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to remove disk(s) from the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param removeDisksInput Remove disks input.
   * @param options The options parameters.
   */
  async beginRemoveDisks(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    removeDisksInput: RemoveDisksInput,
    options?: ReplicationProtectedItemsRemoveDisksOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsRemoveDisksResponse>,
      ReplicationProtectedItemsRemoveDisksResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsRemoveDisksResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        removeDisksInput,
        options,
      },
      spec: removeDisksOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsRemoveDisksResponse,
      OperationState<ReplicationProtectedItemsRemoveDisksResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to remove disk(s) from the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param removeDisksInput Remove disks input.
   * @param options The options parameters.
   */
  async beginRemoveDisksAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    removeDisksInput: RemoveDisksInput,
    options?: ReplicationProtectedItemsRemoveDisksOptionalParams,
  ): Promise<ReplicationProtectedItemsRemoveDisksResponse> {
    const poller = await this.beginRemoveDisks(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      removeDisksInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to start resynchronize/repair replication for a replication protected item requiring
   * resynchronization.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName The name of the fabric.
   * @param protectionContainerName The name of the container.
   * @param replicatedProtectedItemName The name of the replication protected item.
   * @param options The options parameters.
   */
  async beginRepairReplication(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsRepairReplicationOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsRepairReplicationResponse>,
      ReplicationProtectedItemsRepairReplicationResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsRepairReplicationResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        options,
      },
      spec: repairReplicationOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsRepairReplicationResponse,
      OperationState<ReplicationProtectedItemsRepairReplicationResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * The operation to start resynchronize/repair replication for a replication protected item requiring
   * resynchronization.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName The name of the fabric.
   * @param protectionContainerName The name of the container.
   * @param replicatedProtectedItemName The name of the replication protected item.
   * @param options The options parameters.
   */
  async beginRepairReplicationAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    options?: ReplicationProtectedItemsRepairReplicationOptionalParams,
  ): Promise<ReplicationProtectedItemsRepairReplicationResponse> {
    const poller = await this.beginRepairReplication(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to reprotect or reverse replicate a failed over replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param reprotectInput Reverse replication input.
   * @param options The options parameters.
   */
  async beginReprotect(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    reprotectInput: ReverseReplicationInput,
    options?: ReplicationProtectedItemsReprotectOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsReprotectResponse>,
      ReplicationProtectedItemsReprotectResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsReprotectResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        reprotectInput,
        options,
      },
      spec: reprotectOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsReprotectResponse,
      OperationState<ReplicationProtectedItemsReprotectResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to reprotect or reverse replicate a failed over replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param reprotectInput Reverse replication input.
   * @param options The options parameters.
   */
  async beginReprotectAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    reprotectInput: ReverseReplicationInput,
    options?: ReplicationProtectedItemsReprotectOptionalParams,
  ): Promise<ReplicationProtectedItemsReprotectResponse> {
    const poller = await this.beginReprotect(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      reprotectInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to resolve health issues of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param resolveHealthInput Health issue input object.
   * @param options The options parameters.
   */
  async beginResolveHealthErrors(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    resolveHealthInput: ResolveHealthInput,
    options?: ReplicationProtectedItemsResolveHealthErrorsOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsResolveHealthErrorsResponse>,
      ReplicationProtectedItemsResolveHealthErrorsResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsResolveHealthErrorsResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        resolveHealthInput,
        options,
      },
      spec: resolveHealthErrorsOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsResolveHealthErrorsResponse,
      OperationState<ReplicationProtectedItemsResolveHealthErrorsResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to resolve health issues of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param resolveHealthInput Health issue input object.
   * @param options The options parameters.
   */
  async beginResolveHealthErrorsAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    resolveHealthInput: ResolveHealthInput,
    options?: ReplicationProtectedItemsResolveHealthErrorsOptionalParams,
  ): Promise<ReplicationProtectedItemsResolveHealthErrorsResponse> {
    const poller = await this.beginResolveHealthErrors(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      resolveHealthInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to initiate a switch provider of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param switchProviderInput Switch provider input.
   * @param options The options parameters.
   */
  async beginSwitchProvider(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    switchProviderInput: SwitchProviderInput,
    options?: ReplicationProtectedItemsSwitchProviderOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsSwitchProviderResponse>,
      ReplicationProtectedItemsSwitchProviderResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsSwitchProviderResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        switchProviderInput,
        options,
      },
      spec: switchProviderOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsSwitchProviderResponse,
      OperationState<ReplicationProtectedItemsSwitchProviderResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "azure-async-operation",
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to initiate a switch provider of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param switchProviderInput Switch provider input.
   * @param options The options parameters.
   */
  async beginSwitchProviderAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    switchProviderInput: SwitchProviderInput,
    options?: ReplicationProtectedItemsSwitchProviderOptionalParams,
  ): Promise<ReplicationProtectedItemsSwitchProviderResponse> {
    const poller = await this.beginSwitchProvider(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      switchProviderInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to perform a test failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param testfailoverInput Test failover input.
   * @param options The options parameters.
   */
  async beginTestFailover(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    testfailoverInput: TestFailoverInput,
    options?: ReplicationProtectedItemsTestFailoverOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsTestFailoverResponse>,
      ReplicationProtectedItemsTestFailoverResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsTestFailoverResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        testfailoverInput,
        options,
      },
      spec: testFailoverOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsTestFailoverResponse,
      OperationState<ReplicationProtectedItemsTestFailoverResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to perform a test failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param testfailoverInput Test failover input.
   * @param options The options parameters.
   */
  async beginTestFailoverAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    testfailoverInput: TestFailoverInput,
    options?: ReplicationProtectedItemsTestFailoverOptionalParams,
  ): Promise<ReplicationProtectedItemsTestFailoverResponse> {
    const poller = await this.beginTestFailover(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      testfailoverInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to clean up the test failover of a replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param cleanupInput Test failover cleanup input.
   * @param options The options parameters.
   */
  async beginTestFailoverCleanup(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    cleanupInput: TestFailoverCleanupInput,
    options?: ReplicationProtectedItemsTestFailoverCleanupOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsTestFailoverCleanupResponse>,
      ReplicationProtectedItemsTestFailoverCleanupResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsTestFailoverCleanupResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        cleanupInput,
        options,
      },
      spec: testFailoverCleanupOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsTestFailoverCleanupResponse,
      OperationState<ReplicationProtectedItemsTestFailoverCleanupResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to clean up the test failover of a replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param cleanupInput Test failover cleanup input.
   * @param options The options parameters.
   */
  async beginTestFailoverCleanupAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    cleanupInput: TestFailoverCleanupInput,
    options?: ReplicationProtectedItemsTestFailoverCleanupOptionalParams,
  ): Promise<ReplicationProtectedItemsTestFailoverCleanupResponse> {
    const poller = await this.beginTestFailoverCleanup(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      cleanupInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Operation to initiate a failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param failoverInput Failover input.
   * @param options The options parameters.
   */
  async beginUnplannedFailover(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    failoverInput: UnplannedFailoverInput,
    options?: ReplicationProtectedItemsUnplannedFailoverOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsUnplannedFailoverResponse>,
      ReplicationProtectedItemsUnplannedFailoverResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsUnplannedFailoverResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        failoverInput,
        options,
      },
      spec: unplannedFailoverOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsUnplannedFailoverResponse,
      OperationState<ReplicationProtectedItemsUnplannedFailoverResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * Operation to initiate a failover of the replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Unique fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param failoverInput Failover input.
   * @param options The options parameters.
   */
  async beginUnplannedFailoverAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    failoverInput: UnplannedFailoverInput,
    options?: ReplicationProtectedItemsUnplannedFailoverOptionalParams,
  ): Promise<ReplicationProtectedItemsUnplannedFailoverResponse> {
    const poller = await this.beginUnplannedFailover(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      failoverInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to update appliance of an ASR replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param applianceUpdateInput Appliance update protection input.
   * @param options The options parameters.
   */
  async beginUpdateAppliance(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    applianceUpdateInput: UpdateApplianceForReplicationProtectedItemInput,
    options?: ReplicationProtectedItemsUpdateApplianceOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsUpdateApplianceResponse>,
      ReplicationProtectedItemsUpdateApplianceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsUpdateApplianceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        applianceUpdateInput,
        options,
      },
      spec: updateApplianceOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsUpdateApplianceResponse,
      OperationState<ReplicationProtectedItemsUpdateApplianceResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
    });
    await poller.poll();
    return poller;
  }

  /**
   * The operation to update appliance of an ASR replication protected item.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param replicatedProtectedItemName Replication protected item name.
   * @param applianceUpdateInput Appliance update protection input.
   * @param options The options parameters.
   */
  async beginUpdateApplianceAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    applianceUpdateInput: UpdateApplianceForReplicationProtectedItemInput,
    options?: ReplicationProtectedItemsUpdateApplianceOptionalParams,
  ): Promise<ReplicationProtectedItemsUpdateApplianceResponse> {
    const poller = await this.beginUpdateAppliance(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      applianceUpdateInput,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * The operation to update(push update) the installed mobility service software on a replication
   * protected item to the latest available version.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName The name of the fabric containing the protected item.
   * @param protectionContainerName The name of the container containing the protected item.
   * @param replicatedProtectedItemName The name of the protected item on which the agent is to be
   *                                    updated.
   * @param updateMobilityServiceRequest Request to update the mobility service on the protected item.
   * @param options The options parameters.
   */
  async beginUpdateMobilityService(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    updateMobilityServiceRequest: UpdateMobilityServiceRequest,
    options?: ReplicationProtectedItemsUpdateMobilityServiceOptionalParams,
  ): Promise<
    SimplePollerLike<
      OperationState<ReplicationProtectedItemsUpdateMobilityServiceResponse>,
      ReplicationProtectedItemsUpdateMobilityServiceResponse
    >
  > {
    const directSendOperation = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ): Promise<ReplicationProtectedItemsUpdateMobilityServiceResponse> => {
      return this.client.sendOperationRequest(args, spec);
    };
    const sendOperationFn = async (
      args: coreClient.OperationArguments,
      spec: coreClient.OperationSpec,
    ) => {
      let currentRawResponse: coreClient.FullOperationResponse | undefined =
        undefined;
      const providedCallback = args.options?.onResponse;
      const callback: coreClient.RawResponseCallback = (
        rawResponse: coreClient.FullOperationResponse,
        flatResponse: unknown,
      ) => {
        currentRawResponse = rawResponse;
        providedCallback?.(rawResponse, flatResponse);
      };
      const updatedArgs = {
        ...args,
        options: {
          ...args.options,
          onResponse: callback,
        },
      };
      const flatResponse = await directSendOperation(updatedArgs, spec);
      return {
        flatResponse,
        rawResponse: {
          statusCode: currentRawResponse!.status,
          body: currentRawResponse!.parsedBody,
          headers: currentRawResponse!.headers.toJSON(),
        },
      };
    };

    const lro = createLroSpec({
      sendOperationFn,
      args: {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        replicatedProtectedItemName,
        updateMobilityServiceRequest,
        options,
      },
      spec: updateMobilityServiceOperationSpec,
    });
    const poller = await createHttpPoller<
      ReplicationProtectedItemsUpdateMobilityServiceResponse,
      OperationState<ReplicationProtectedItemsUpdateMobilityServiceResponse>
    >(lro, {
      restoreFrom: options?.resumeFrom,
      intervalInMs: options?.updateIntervalInMs,
      resourceLocationConfig: "location",
    });
    await poller.poll();
    return poller;
  }

  /**
   * The operation to update(push update) the installed mobility service software on a replication
   * protected item to the latest available version.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName The name of the fabric containing the protected item.
   * @param protectionContainerName The name of the container containing the protected item.
   * @param replicatedProtectedItemName The name of the protected item on which the agent is to be
   *                                    updated.
   * @param updateMobilityServiceRequest Request to update the mobility service on the protected item.
   * @param options The options parameters.
   */
  async beginUpdateMobilityServiceAndWait(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    replicatedProtectedItemName: string,
    updateMobilityServiceRequest: UpdateMobilityServiceRequest,
    options?: ReplicationProtectedItemsUpdateMobilityServiceOptionalParams,
  ): Promise<ReplicationProtectedItemsUpdateMobilityServiceResponse> {
    const poller = await this.beginUpdateMobilityService(
      resourceGroupName,
      resourceName,
      fabricName,
      protectionContainerName,
      replicatedProtectedItemName,
      updateMobilityServiceRequest,
      options,
    );
    return poller.pollUntilDone();
  }

  /**
   * Gets the list of ASR replication protected items in the vault.
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param options The options parameters.
   */
  private _list(
    resourceGroupName: string,
    resourceName: string,
    options?: ReplicationProtectedItemsListOptionalParams,
  ): Promise<ReplicationProtectedItemsListResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, resourceName, options },
      listOperationSpec,
    );
  }

  /**
   * ListByReplicationProtectionContainersNext
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param fabricName Fabric name.
   * @param protectionContainerName Protection container name.
   * @param nextLink The nextLink from the previous successful call to the
   *                 ListByReplicationProtectionContainers method.
   * @param options The options parameters.
   */
  private _listByReplicationProtectionContainersNext(
    resourceGroupName: string,
    resourceName: string,
    fabricName: string,
    protectionContainerName: string,
    nextLink: string,
    options?: ReplicationProtectedItemsListByReplicationProtectionContainersNextOptionalParams,
  ): Promise<ReplicationProtectedItemsListByReplicationProtectionContainersNextResponse> {
    return this.client.sendOperationRequest(
      {
        resourceGroupName,
        resourceName,
        fabricName,
        protectionContainerName,
        nextLink,
        options,
      },
      listByReplicationProtectionContainersNextOperationSpec,
    );
  }

  /**
   * ListNext
   * @param resourceGroupName The name of the resource group where the recovery services vault is
   *                          present.
   * @param resourceName The name of the recovery services vault.
   * @param nextLink The nextLink from the previous successful call to the List method.
   * @param options The options parameters.
   */
  private _listNext(
    resourceGroupName: string,
    resourceName: string,
    nextLink: string,
    options?: ReplicationProtectedItemsListNextOptionalParams,
  ): Promise<ReplicationProtectedItemsListNextResponse> {
    return this.client.sendOperationRequest(
      { resourceGroupName, resourceName, nextLink, options },
      listNextOperationSpec,
    );
  }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);

const listByReplicationProtectionContainersOperationSpec: coreClient.OperationSpec =
  {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ReplicationProtectedItemCollection,
      },
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
      Parameters.$host,
      Parameters.resourceGroupName,
      Parameters.subscriptionId,
      Parameters.resourceName,
      Parameters.fabricName,
      Parameters.protectionContainerName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const getOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const createOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}",
  httpMethod: "PUT",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.input6,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const purgeOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}",
  httpMethod: "DELETE",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  serializer,
};
const updateOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}",
  httpMethod: "PATCH",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.updateProtectionInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const addDisksOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/addDisks",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.addDisksInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const applyRecoveryPointOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/applyRecoveryPoint",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.applyRecoveryPointInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const failoverCancelOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/failoverCancel",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const failoverCommitOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/failoverCommit",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const plannedFailoverOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/plannedFailover",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.failoverInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const deleteOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/remove",
  httpMethod: "POST",
  responses: { 200: {}, 201: {}, 202: {}, 204: {} },
  requestBody: Parameters.disableProtectionInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.contentType],
  mediaType: "json",
  serializer,
};
const removeDisksOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/removeDisks",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.removeDisksInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const repairReplicationOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/repairReplication",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const reprotectOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/reProtect",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.reprotectInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const resolveHealthErrorsOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/resolveHealthErrors",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.resolveHealthInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const switchProviderOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/switchProvider",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.switchProviderInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const testFailoverOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/testFailover",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.testfailoverInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const testFailoverCleanupOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/testFailoverCleanup",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.cleanupInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const unplannedFailoverOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/unplannedFailover",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.failoverInput1,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const updateApplianceOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/updateAppliance",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.applianceUpdateInput,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const updateMobilityServiceOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationFabrics/{fabricName}/replicationProtectionContainers/{protectionContainerName}/replicationProtectedItems/{replicatedProtectedItemName}/updateMobilityService",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    201: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    202: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
    204: {
      bodyMapper: Mappers.ReplicationProtectedItem,
    },
  },
  requestBody: Parameters.updateMobilityServiceRequest,
  queryParameters: [Parameters.apiVersion],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
    Parameters.fabricName,
    Parameters.protectionContainerName,
    Parameters.replicatedProtectedItemName,
  ],
  headerParameters: [Parameters.accept, Parameters.contentType],
  mediaType: "json",
  serializer,
};
const listOperationSpec: coreClient.OperationSpec = {
  path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RecoveryServices/vaults/{resourceName}/replicationProtectedItems",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItemCollection,
    },
  },
  queryParameters: [
    Parameters.apiVersion,
    Parameters.filter,
    Parameters.skipToken,
  ],
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.resourceName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
const listByReplicationProtectionContainersNextOperationSpec: coreClient.OperationSpec =
  {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ReplicationProtectedItemCollection,
      },
    },
    urlParameters: [
      Parameters.$host,
      Parameters.resourceGroupName,
      Parameters.subscriptionId,
      Parameters.nextLink,
      Parameters.resourceName,
      Parameters.fabricName,
      Parameters.protectionContainerName,
    ],
    headerParameters: [Parameters.accept],
    serializer,
  };
const listNextOperationSpec: coreClient.OperationSpec = {
  path: "{nextLink}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Mappers.ReplicationProtectedItemCollection,
    },
  },
  urlParameters: [
    Parameters.$host,
    Parameters.resourceGroupName,
    Parameters.subscriptionId,
    Parameters.nextLink,
    Parameters.resourceName,
  ],
  headerParameters: [Parameters.accept],
  serializer,
};
