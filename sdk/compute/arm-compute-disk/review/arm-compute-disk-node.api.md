## API Report File for "@azure/arm-compute-disk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import type { OperationState } from '@azure/core-lro';
import type { PagedAsyncIterableIterator } from '@azure/core-paging';
import type { SimplePollerLike } from '@azure/core-lro';

// @public
export type AccessLevel = string;

// @public
export interface AccessUri {
    readonly accessSAS?: string;
    readonly securityDataAccessSAS?: string;
    readonly securityMetadataAccessSAS?: string;
}

// @public
export interface ApiError {
    code?: string;
    details?: ApiErrorBase[];
    innererror?: InnerError;
    message?: string;
    target?: string;
}

// @public
export interface ApiErrorBase {
    code?: string;
    message?: string;
    target?: string;
}

// @public
export type Architecture = string;

// @public
export interface AvailabilityPolicy {
    actionOnDiskDelay?: AvailabilityPolicyDiskDelay;
}

// @public
export type AvailabilityPolicyDiskDelay = string;

// @public
export interface CloudError {
    error?: ApiError;
}

// @public (undocumented)
export class ComputeManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: ComputeManagementClientOptionalParams);
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    diskAccesses: DiskAccesses;
    // (undocumented)
    diskEncryptionSets: DiskEncryptionSets;
    // (undocumented)
    diskRestorePointOperations: DiskRestorePointOperations;
    // (undocumented)
    disks: Disks;
    // (undocumented)
    snapshots: Snapshots;
    // (undocumented)
    subscriptionId: string;
}

// @public
export interface ComputeManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface CopyCompletionError {
    errorCode: CopyCompletionErrorReason;
    errorMessage: string;
}

// @public
export type CopyCompletionErrorReason = string;

// @public
export type CreatedByType = string;

// @public
export interface CreationData {
    createOption: DiskCreateOption;
    elasticSanResourceId?: string;
    galleryImageReference?: ImageDiskReference;
    imageReference?: ImageDiskReference;
    instantAccessDurationMinutes?: number;
    logicalSectorSize?: number;
    performancePlus?: boolean;
    provisionedBandwidthCopySpeed?: ProvisionedBandwidthCopyOption;
    securityDataUri?: string;
    securityMetadataUri?: string;
    sourceResourceId?: string;
    readonly sourceUniqueId?: string;
    sourceUri?: string;
    storageAccountId?: string;
    uploadSizeBytes?: number;
}

// @public
export type DataAccessAuthMode = string;

// @public
export interface Disk extends TrackedResource {
    availabilityPolicy?: AvailabilityPolicy;
    burstingEnabled?: boolean;
    readonly burstingEnabledTime?: Date;
    completionPercent?: number;
    creationData?: CreationData;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskIopsReadOnly?: number;
    diskIopsReadWrite?: number;
    diskMBpsReadOnly?: number;
    diskMBpsReadWrite?: number;
    readonly diskSizeBytes?: number;
    diskSizeGB?: number;
    readonly diskState?: DiskState;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    extendedLocation?: ExtendedLocation;
    hyperVGeneration?: HyperVGeneration;
    readonly lastOwnershipUpdateTime?: Date;
    readonly managedBy?: string;
    readonly managedByExtended?: string[];
    maxShares?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    optimizedForFrequentAttach?: boolean;
    osType?: OperatingSystemTypes;
    readonly propertyUpdatesInProgress?: PropertyUpdatesInProgress;
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    securityProfile?: DiskSecurityProfile;
    readonly shareInfo?: ShareInfoElement[];
    sku?: DiskSku;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    tier?: string;
    readonly timeCreated?: Date;
    readonly uniqueId?: string;
    zones?: string[];
}

// @public
export interface DiskAccess extends TrackedResource {
    extendedLocation?: ExtendedLocation;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    readonly provisioningState?: string;
    readonly timeCreated?: Date;
}

// @public
export interface DiskAccesses {
    beginCreateOrUpdate(resourceGroupName: string, diskAccessName: string, diskAccess: DiskAccess, options?: DiskAccessesCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<DiskAccessesCreateOrUpdateResponse>, DiskAccessesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, diskAccessName: string, diskAccess: DiskAccess, options?: DiskAccessesCreateOrUpdateOptionalParams): Promise<DiskAccessesCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, diskAccessName: string, options?: DiskAccessesDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, diskAccessName: string, options?: DiskAccessesDeleteOptionalParams): Promise<void>;
    beginDeleteAPrivateEndpointConnection(resourceGroupName: string, diskAccessName: string, privateEndpointConnectionName: string, options?: DiskAccessesDeleteAPrivateEndpointConnectionOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAPrivateEndpointConnectionAndWait(resourceGroupName: string, diskAccessName: string, privateEndpointConnectionName: string, options?: DiskAccessesDeleteAPrivateEndpointConnectionOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, diskAccessName: string, diskAccess: DiskAccessUpdate, options?: DiskAccessesUpdateOptionalParams): Promise<SimplePollerLike<OperationState<DiskAccessesUpdateResponse>, DiskAccessesUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, diskAccessName: string, diskAccess: DiskAccessUpdate, options?: DiskAccessesUpdateOptionalParams): Promise<DiskAccessesUpdateResponse>;
    beginUpdateAPrivateEndpointConnection(resourceGroupName: string, diskAccessName: string, privateEndpointConnectionName: string, privateEndpointConnection: PrivateEndpointConnection, options?: DiskAccessesUpdateAPrivateEndpointConnectionOptionalParams): Promise<SimplePollerLike<OperationState<DiskAccessesUpdateAPrivateEndpointConnectionResponse>, DiskAccessesUpdateAPrivateEndpointConnectionResponse>>;
    beginUpdateAPrivateEndpointConnectionAndWait(resourceGroupName: string, diskAccessName: string, privateEndpointConnectionName: string, privateEndpointConnection: PrivateEndpointConnection, options?: DiskAccessesUpdateAPrivateEndpointConnectionOptionalParams): Promise<DiskAccessesUpdateAPrivateEndpointConnectionResponse>;
    get(resourceGroupName: string, diskAccessName: string, options?: DiskAccessesGetOptionalParams): Promise<DiskAccessesGetResponse>;
    getAPrivateEndpointConnection(resourceGroupName: string, diskAccessName: string, privateEndpointConnectionName: string, options?: DiskAccessesGetAPrivateEndpointConnectionOptionalParams): Promise<DiskAccessesGetAPrivateEndpointConnectionResponse>;
    getPrivateLinkResources(resourceGroupName: string, diskAccessName: string, options?: DiskAccessesGetPrivateLinkResourcesOptionalParams): Promise<DiskAccessesGetPrivateLinkResourcesResponse>;
    list(options?: DiskAccessesListOptionalParams): PagedAsyncIterableIterator<DiskAccess>;
    listByResourceGroup(resourceGroupName: string, options?: DiskAccessesListByResourceGroupOptionalParams): PagedAsyncIterableIterator<DiskAccess>;
    listPrivateEndpointConnections(resourceGroupName: string, diskAccessName: string, options?: DiskAccessesListPrivateEndpointConnectionsOptionalParams): PagedAsyncIterableIterator<PrivateEndpointConnection>;
}

// @public
export interface DiskAccessesCreateOrUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskAccessesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DiskAccessesCreateOrUpdateResponse = DiskAccess;

// @public
export interface DiskAccessesDeleteAPrivateEndpointConnectionHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskAccessesDeleteAPrivateEndpointConnectionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DiskAccessesDeleteHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskAccessesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DiskAccessesGetAPrivateEndpointConnectionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskAccessesGetAPrivateEndpointConnectionResponse = PrivateEndpointConnection;

// @public
export interface DiskAccessesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DiskAccessesGetPrivateLinkResourcesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskAccessesGetPrivateLinkResourcesResponse = PrivateLinkResourceListResult;

// @public
export type DiskAccessesGetResponse = DiskAccess;

// @public
export interface DiskAccessesListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskAccessesListByResourceGroupNextResponse = DiskAccessList;

// @public
export interface DiskAccessesListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskAccessesListByResourceGroupResponse = DiskAccessList;

// @public
export interface DiskAccessesListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskAccessesListNextResponse = DiskAccessList;

// @public
export interface DiskAccessesListOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DiskAccessesListPrivateEndpointConnectionsNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskAccessesListPrivateEndpointConnectionsNextResponse = PrivateEndpointConnectionListResult;

// @public
export interface DiskAccessesListPrivateEndpointConnectionsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskAccessesListPrivateEndpointConnectionsResponse = PrivateEndpointConnectionListResult;

// @public
export type DiskAccessesListResponse = DiskAccessList;

// @public
export interface DiskAccessesUpdateAPrivateEndpointConnectionHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskAccessesUpdateAPrivateEndpointConnectionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DiskAccessesUpdateAPrivateEndpointConnectionResponse = PrivateEndpointConnection;

// @public
export interface DiskAccessesUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskAccessesUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DiskAccessesUpdateResponse = DiskAccess;

// @public
export interface DiskAccessList {
    nextLink?: string;
    value: DiskAccess[];
}

// @public
export interface DiskAccessUpdate {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export type DiskCreateOption = string;

// @public
export interface DiskEncryptionSet extends TrackedResource {
    activeKey?: KeyForDiskEncryptionSet;
    readonly autoKeyRotationError?: ApiError;
    encryptionType?: DiskEncryptionSetType;
    federatedClientId?: string;
    identity?: EncryptionSetIdentity;
    readonly lastKeyRotationTimestamp?: Date;
    readonly previousKeys?: KeyForDiskEncryptionSet[];
    readonly provisioningState?: string;
    rotationToLatestKeyVersionEnabled?: boolean;
}

// @public
export type DiskEncryptionSetIdentityType = string;

// @public
export interface DiskEncryptionSetList {
    nextLink?: string;
    value: DiskEncryptionSet[];
}

// @public
export interface DiskEncryptionSets {
    beginCreateOrUpdate(resourceGroupName: string, diskEncryptionSetName: string, diskEncryptionSet: DiskEncryptionSet, options?: DiskEncryptionSetsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<DiskEncryptionSetsCreateOrUpdateResponse>, DiskEncryptionSetsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, diskEncryptionSetName: string, diskEncryptionSet: DiskEncryptionSet, options?: DiskEncryptionSetsCreateOrUpdateOptionalParams): Promise<DiskEncryptionSetsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, diskEncryptionSetName: string, options?: DiskEncryptionSetsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, diskEncryptionSetName: string, options?: DiskEncryptionSetsDeleteOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, diskEncryptionSetName: string, diskEncryptionSet: DiskEncryptionSetUpdate, options?: DiskEncryptionSetsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<DiskEncryptionSetsUpdateResponse>, DiskEncryptionSetsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, diskEncryptionSetName: string, diskEncryptionSet: DiskEncryptionSetUpdate, options?: DiskEncryptionSetsUpdateOptionalParams): Promise<DiskEncryptionSetsUpdateResponse>;
    get(resourceGroupName: string, diskEncryptionSetName: string, options?: DiskEncryptionSetsGetOptionalParams): Promise<DiskEncryptionSetsGetResponse>;
    list(options?: DiskEncryptionSetsListOptionalParams): PagedAsyncIterableIterator<DiskEncryptionSet>;
    listAssociatedResources(resourceGroupName: string, diskEncryptionSetName: string, options?: DiskEncryptionSetsListAssociatedResourcesOptionalParams): PagedAsyncIterableIterator<string>;
    listByResourceGroup(resourceGroupName: string, options?: DiskEncryptionSetsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<DiskEncryptionSet>;
}

// @public
export interface DiskEncryptionSetsCreateOrUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskEncryptionSetsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DiskEncryptionSetsCreateOrUpdateResponse = DiskEncryptionSet;

// @public
export interface DiskEncryptionSetsDeleteHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskEncryptionSetsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DiskEncryptionSetsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskEncryptionSetsGetResponse = DiskEncryptionSet;

// @public
export interface DiskEncryptionSetsListAssociatedResourcesNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskEncryptionSetsListAssociatedResourcesNextResponse = ResourceUriList;

// @public
export interface DiskEncryptionSetsListAssociatedResourcesOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskEncryptionSetsListAssociatedResourcesResponse = ResourceUriList;

// @public
export interface DiskEncryptionSetsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskEncryptionSetsListByResourceGroupNextResponse = DiskEncryptionSetList;

// @public
export interface DiskEncryptionSetsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskEncryptionSetsListByResourceGroupResponse = DiskEncryptionSetList;

// @public
export interface DiskEncryptionSetsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskEncryptionSetsListNextResponse = DiskEncryptionSetList;

// @public
export interface DiskEncryptionSetsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskEncryptionSetsListResponse = DiskEncryptionSetList;

// @public
export interface DiskEncryptionSetsUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskEncryptionSetsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DiskEncryptionSetsUpdateResponse = DiskEncryptionSet;

// @public
export type DiskEncryptionSetType = string;

// @public
export interface DiskEncryptionSetUpdate {
    activeKey?: KeyForDiskEncryptionSet;
    encryptionType?: DiskEncryptionSetType;
    federatedClientId?: string;
    identity?: EncryptionSetIdentity;
    rotationToLatestKeyVersionEnabled?: boolean;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface DiskList {
    nextLink?: string;
    value: Disk[];
}

// @public
export interface DiskPurchasePlan {
    name: string;
    product: string;
    promotionCode?: string;
    publisher: string;
}

// @public
export interface DiskRestorePoint extends ProxyResource {
    completionPercent?: number;
    diskAccessId?: string;
    readonly encryption?: Encryption;
    readonly familyId?: string;
    hyperVGeneration?: HyperVGeneration;
    readonly logicalSectorSize?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    readonly osType?: OperatingSystemTypes;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    readonly replicationState?: string;
    securityProfile?: DiskSecurityProfile;
    readonly sourceResourceId?: string;
    readonly sourceResourceLocation?: string;
    readonly sourceUniqueId?: string;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    readonly timeCreated?: Date;
}

// @public
export interface DiskRestorePointGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskRestorePointGetResponse = DiskRestorePoint;

// @public
export interface DiskRestorePointGrantAccessHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskRestorePointGrantAccessOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DiskRestorePointGrantAccessResponse = AccessUri;

// @public
export interface DiskRestorePointList {
    nextLink?: string;
    value: DiskRestorePoint[];
}

// @public
export interface DiskRestorePointListByRestorePointNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskRestorePointListByRestorePointNextResponse = DiskRestorePointList;

// @public
export interface DiskRestorePointListByRestorePointOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DiskRestorePointListByRestorePointResponse = DiskRestorePointList;

// @public
export interface DiskRestorePointOperations {
    beginGrantAccess(resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, diskRestorePointName: string, grantAccessData: GrantAccessData, options?: DiskRestorePointGrantAccessOptionalParams): Promise<SimplePollerLike<OperationState<DiskRestorePointGrantAccessResponse>, DiskRestorePointGrantAccessResponse>>;
    beginGrantAccessAndWait(resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, diskRestorePointName: string, grantAccessData: GrantAccessData, options?: DiskRestorePointGrantAccessOptionalParams): Promise<DiskRestorePointGrantAccessResponse>;
    beginRevokeAccess(resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, diskRestorePointName: string, options?: DiskRestorePointRevokeAccessOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginRevokeAccessAndWait(resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, diskRestorePointName: string, options?: DiskRestorePointRevokeAccessOptionalParams): Promise<void>;
    get(resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, diskRestorePointName: string, options?: DiskRestorePointGetOptionalParams): Promise<DiskRestorePointGetResponse>;
    listByRestorePoint(resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, options?: DiskRestorePointListByRestorePointOptionalParams): PagedAsyncIterableIterator<DiskRestorePoint>;
}

// @public
export interface DiskRestorePointRevokeAccessHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DiskRestorePointRevokeAccessOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface Disks {
    beginCreateOrUpdate(resourceGroupName: string, diskName: string, disk: Disk, options?: DisksCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<DisksCreateOrUpdateResponse>, DisksCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, diskName: string, disk: Disk, options?: DisksCreateOrUpdateOptionalParams): Promise<DisksCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, diskName: string, options?: DisksDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, diskName: string, options?: DisksDeleteOptionalParams): Promise<void>;
    beginGrantAccess(resourceGroupName: string, diskName: string, grantAccessData: GrantAccessData, options?: DisksGrantAccessOptionalParams): Promise<SimplePollerLike<OperationState<DisksGrantAccessResponse>, DisksGrantAccessResponse>>;
    beginGrantAccessAndWait(resourceGroupName: string, diskName: string, grantAccessData: GrantAccessData, options?: DisksGrantAccessOptionalParams): Promise<DisksGrantAccessResponse>;
    beginRevokeAccess(resourceGroupName: string, diskName: string, options?: DisksRevokeAccessOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginRevokeAccessAndWait(resourceGroupName: string, diskName: string, options?: DisksRevokeAccessOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, diskName: string, disk: DiskUpdate, options?: DisksUpdateOptionalParams): Promise<SimplePollerLike<OperationState<DisksUpdateResponse>, DisksUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, diskName: string, disk: DiskUpdate, options?: DisksUpdateOptionalParams): Promise<DisksUpdateResponse>;
    get(resourceGroupName: string, diskName: string, options?: DisksGetOptionalParams): Promise<DisksGetResponse>;
    list(options?: DisksListOptionalParams): PagedAsyncIterableIterator<Disk>;
    listByResourceGroup(resourceGroupName: string, options?: DisksListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Disk>;
}

// @public
export interface DisksCreateOrUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DisksCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DisksCreateOrUpdateResponse = Disk;

// @public
export interface DisksDeleteHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DisksDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DiskSecurityProfile {
    secureVMDiskEncryptionSetId?: string;
    securityType?: DiskSecurityTypes;
}

// @public
export type DiskSecurityTypes = string;

// @public
export interface DisksGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisksGetResponse = Disk;

// @public
export interface DisksGrantAccessHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DisksGrantAccessOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DisksGrantAccessResponse = AccessUri;

// @public
export interface DiskSku {
    name?: DiskStorageAccountTypes;
    readonly tier?: string;
}

// @public
export interface DisksListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisksListByResourceGroupNextResponse = DiskList;

// @public
export interface DisksListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisksListByResourceGroupResponse = DiskList;

// @public
export interface DisksListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisksListNextResponse = DiskList;

// @public
export interface DisksListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DisksListResponse = DiskList;

// @public
export interface DisksRevokeAccessHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DisksRevokeAccessOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DiskState = string;

// @public
export type DiskStorageAccountTypes = string;

// @public
export interface DisksUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface DisksUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DisksUpdateResponse = Disk;

// @public
export interface DiskUpdate {
    availabilityPolicy?: AvailabilityPolicy;
    burstingEnabled?: boolean;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskIopsReadOnly?: number;
    diskIopsReadWrite?: number;
    diskMBpsReadOnly?: number;
    diskMBpsReadWrite?: number;
    diskSizeGB?: number;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    maxShares?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    optimizedForFrequentAttach?: boolean;
    osType?: OperatingSystemTypes;
    readonly propertyUpdatesInProgress?: PropertyUpdatesInProgress;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    sku?: DiskSku;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    tags?: {
        [propertyName: string]: string;
    };
    tier?: string;
}

// @public
export interface Encryption {
    diskEncryptionSetId?: string;
    type?: EncryptionType;
}

// @public
export interface EncryptionSetIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: DiskEncryptionSetIdentityType;
    userAssignedIdentities?: {
        [propertyName: string]: UserAssignedIdentitiesValue;
    };
}

// @public
export interface EncryptionSettingsCollection {
    enabled: boolean;
    encryptionSettings?: EncryptionSettingsElement[];
    encryptionSettingsVersion?: string;
}

// @public
export interface EncryptionSettingsElement {
    diskEncryptionKey?: KeyVaultAndSecretReference;
    keyEncryptionKey?: KeyVaultAndKeyReference;
}

// @public
export type EncryptionType = string;

// @public
export interface ExtendedLocation {
    name?: string;
    type?: ExtendedLocationTypes;
}

// @public
export type ExtendedLocationTypes = string;

// @public
export type FileFormat = string;

// @public
export function getContinuationToken(page: unknown): string | undefined;

// @public
export interface GrantAccessData {
    access: AccessLevel;
    durationInSeconds: number;
    fileFormat?: FileFormat;
    getSecureVMGuestStateSAS?: boolean;
}

// @public
export type HyperVGeneration = string;

// @public
export interface ImageDiskReference {
    communityGalleryImageId?: string;
    id?: string;
    lun?: number;
    sharedGalleryImageId?: string;
}

// @public
export interface InnerError {
    errordetail?: string;
    exceptiontype?: string;
}

// @public
export interface KeyForDiskEncryptionSet {
    keyUrl: string;
    sourceVault?: SourceVault;
}

// @public
export interface KeyVaultAndKeyReference {
    keyUrl: string;
    sourceVault: SourceVault;
}

// @public
export interface KeyVaultAndSecretReference {
    secretUrl: string;
    sourceVault: SourceVault;
}

// @public
export enum KnownAccessLevel {
    None = "None",
    Read = "Read",
    Write = "Write"
}

// @public
export enum KnownArchitecture {
    Arm64 = "Arm64",
    X64 = "x64"
}

// @public
export enum KnownAvailabilityPolicyDiskDelay {
    AutomaticReattach = "AutomaticReattach",
    None = "None"
}

// @public
export enum KnownCopyCompletionErrorReason {
    CopySourceNotFound = "CopySourceNotFound"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDataAccessAuthMode {
    AzureActiveDirectory = "AzureActiveDirectory",
    None = "None"
}

// @public
export enum KnownDiskCreateOption {
    Attach = "Attach",
    Copy = "Copy",
    CopyFromSanSnapshot = "CopyFromSanSnapshot",
    CopyStart = "CopyStart",
    Empty = "Empty",
    FromImage = "FromImage",
    Import = "Import",
    ImportSecure = "ImportSecure",
    Restore = "Restore",
    Upload = "Upload",
    UploadPreparedSecure = "UploadPreparedSecure"
}

// @public
export enum KnownDiskEncryptionSetIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned, UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownDiskEncryptionSetType {
    ConfidentialVmEncryptedWithCustomerKey = "ConfidentialVmEncryptedWithCustomerKey",
    EncryptionAtRestWithCustomerKey = "EncryptionAtRestWithCustomerKey",
    EncryptionAtRestWithPlatformAndCustomerKeys = "EncryptionAtRestWithPlatformAndCustomerKeys"
}

// @public
export enum KnownDiskSecurityTypes {
    ConfidentialVMDiskEncryptedWithCustomerKey = "ConfidentialVM_DiskEncryptedWithCustomerKey",
    ConfidentialVMDiskEncryptedWithPlatformKey = "ConfidentialVM_DiskEncryptedWithPlatformKey",
    ConfidentialVMNonPersistedTPM = "ConfidentialVM_NonPersistedTPM",
    ConfidentialVMVmguestStateOnlyEncryptedWithPlatformKey = "ConfidentialVM_VMGuestStateOnlyEncryptedWithPlatformKey",
    TrustedLaunch = "TrustedLaunch"
}

// @public
export enum KnownDiskState {
    ActiveSAS = "ActiveSAS",
    ActiveSASFrozen = "ActiveSASFrozen",
    ActiveUpload = "ActiveUpload",
    Attached = "Attached",
    Frozen = "Frozen",
    ReadyToUpload = "ReadyToUpload",
    Reserved = "Reserved",
    Unattached = "Unattached"
}

// @public
export enum KnownDiskStorageAccountTypes {
    PremiumLRS = "Premium_LRS",
    PremiumV2LRS = "PremiumV2_LRS",
    PremiumZRS = "Premium_ZRS",
    StandardLRS = "Standard_LRS",
    StandardSSDLRS = "StandardSSD_LRS",
    StandardSSDZRS = "StandardSSD_ZRS",
    UltraSSDLRS = "UltraSSD_LRS"
}

// @public
export enum KnownEncryptionType {
    EncryptionAtRestWithCustomerKey = "EncryptionAtRestWithCustomerKey",
    EncryptionAtRestWithPlatformAndCustomerKeys = "EncryptionAtRestWithPlatformAndCustomerKeys",
    EncryptionAtRestWithPlatformKey = "EncryptionAtRestWithPlatformKey"
}

// @public
export enum KnownExtendedLocationTypes {
    EdgeZone = "EdgeZone"
}

// @public
export enum KnownFileFormat {
    VHD = "VHD",
    Vhdx = "VHDX"
}

// @public
export enum KnownHyperVGeneration {
    V1 = "V1",
    V2 = "V2"
}

// @public
export enum KnownNetworkAccessPolicy {
    AllowAll = "AllowAll",
    AllowPrivate = "AllowPrivate",
    DenyAll = "DenyAll"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownPrivateEndpointServiceConnectionStatus {
    Approved = "Approved",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownProvisionedBandwidthCopyOption {
    Enhanced = "Enhanced",
    None = "None"
}

// @public
export enum KnownPublicNetworkAccess {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownSnapshotAccessState {
    Available = "Available",
    AvailableWithInstantAccess = "AvailableWithInstantAccess",
    InstantAccess = "InstantAccess",
    Pending = "Pending",
    Unknown = "Unknown"
}

// @public
export enum KnownSnapshotStorageAccountTypes {
    PremiumLRS = "Premium_LRS",
    StandardLRS = "Standard_LRS",
    StandardZRS = "Standard_ZRS"
}

// @public
export enum KnownSupportedSecurityOption {
    TrustedLaunchAndConfidentialVMSupported = "TrustedLaunchAndConfidentialVMSupported",
    TrustedLaunchSupported = "TrustedLaunchSupported"
}

// @public
export type NetworkAccessPolicy = string;

// @public
export type OperatingSystemTypes = "Windows" | "Linux";

// @public
export interface PrivateEndpoint {
    readonly id?: string;
}

// @public
export interface PrivateEndpointConnection extends ProxyResource {
    readonly privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState?: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
}

// @public
export interface PrivateEndpointConnectionListResult {
    nextLink?: string;
    value: PrivateEndpointConnection[];
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export type PrivateEndpointServiceConnectionStatus = string;

// @public
export interface PrivateLinkResource {
    readonly groupId?: string;
    readonly id?: string;
    readonly name?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
    readonly type?: string;
}

// @public
export interface PrivateLinkResourceListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkServiceConnectionState {
    actionsRequired?: string;
    description?: string;
    status?: PrivateEndpointServiceConnectionStatus;
}

// @public
export interface PropertyUpdatesInProgress {
    targetTier?: string;
}

// @public
export type ProvisionedBandwidthCopyOption = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export type PublicNetworkAccess = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export interface ResourceUriList {
    nextLink?: string;
    value: string[];
}

// @public (undocumented)
export interface ShareInfoElement {
    readonly vmUri?: string;
}

// @public
export interface Snapshot extends TrackedResource {
    completionPercent?: number;
    copyCompletionError?: CopyCompletionError;
    creationData?: CreationData;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    readonly diskSizeBytes?: number;
    diskSizeGB?: number;
    readonly diskState?: DiskState;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    extendedLocation?: ExtendedLocation;
    hyperVGeneration?: HyperVGeneration;
    incremental?: boolean;
    readonly incrementalSnapshotFamilyId?: string;
    readonly managedBy?: string;
    networkAccessPolicy?: NetworkAccessPolicy;
    osType?: OperatingSystemTypes;
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    securityProfile?: DiskSecurityProfile;
    sku?: SnapshotSku;
    readonly snapshotAccessState?: SnapshotAccessState;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    readonly timeCreated?: Date;
    readonly uniqueId?: string;
}

// @public
export type SnapshotAccessState = string;

// @public
export interface SnapshotList {
    nextLink?: string;
    value: Snapshot[];
}

// @public
export interface Snapshots {
    beginCreateOrUpdate(resourceGroupName: string, snapshotName: string, snapshot: Snapshot, options?: SnapshotsCreateOrUpdateOptionalParams): Promise<SimplePollerLike<OperationState<SnapshotsCreateOrUpdateResponse>, SnapshotsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(resourceGroupName: string, snapshotName: string, snapshot: Snapshot, options?: SnapshotsCreateOrUpdateOptionalParams): Promise<SnapshotsCreateOrUpdateResponse>;
    beginDelete(resourceGroupName: string, snapshotName: string, options?: SnapshotsDeleteOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginDeleteAndWait(resourceGroupName: string, snapshotName: string, options?: SnapshotsDeleteOptionalParams): Promise<void>;
    beginGrantAccess(resourceGroupName: string, snapshotName: string, grantAccessData: GrantAccessData, options?: SnapshotsGrantAccessOptionalParams): Promise<SimplePollerLike<OperationState<SnapshotsGrantAccessResponse>, SnapshotsGrantAccessResponse>>;
    beginGrantAccessAndWait(resourceGroupName: string, snapshotName: string, grantAccessData: GrantAccessData, options?: SnapshotsGrantAccessOptionalParams): Promise<SnapshotsGrantAccessResponse>;
    beginRevokeAccess(resourceGroupName: string, snapshotName: string, options?: SnapshotsRevokeAccessOptionalParams): Promise<SimplePollerLike<OperationState<void>, void>>;
    beginRevokeAccessAndWait(resourceGroupName: string, snapshotName: string, options?: SnapshotsRevokeAccessOptionalParams): Promise<void>;
    beginUpdate(resourceGroupName: string, snapshotName: string, snapshot: SnapshotUpdate, options?: SnapshotsUpdateOptionalParams): Promise<SimplePollerLike<OperationState<SnapshotsUpdateResponse>, SnapshotsUpdateResponse>>;
    beginUpdateAndWait(resourceGroupName: string, snapshotName: string, snapshot: SnapshotUpdate, options?: SnapshotsUpdateOptionalParams): Promise<SnapshotsUpdateResponse>;
    get(resourceGroupName: string, snapshotName: string, options?: SnapshotsGetOptionalParams): Promise<SnapshotsGetResponse>;
    list(options?: SnapshotsListOptionalParams): PagedAsyncIterableIterator<Snapshot>;
    listByResourceGroup(resourceGroupName: string, options?: SnapshotsListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Snapshot>;
}

// @public
export interface SnapshotsCreateOrUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface SnapshotsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SnapshotsCreateOrUpdateResponse = Snapshot;

// @public
export interface SnapshotsDeleteHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface SnapshotsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsGetResponse = Snapshot;

// @public
export interface SnapshotsGrantAccessHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface SnapshotsGrantAccessOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SnapshotsGrantAccessResponse = AccessUri;

// @public
export interface SnapshotSku {
    name?: SnapshotStorageAccountTypes;
    readonly tier?: string;
}

// @public
export interface SnapshotsListByResourceGroupNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListByResourceGroupNextResponse = SnapshotList;

// @public
export interface SnapshotsListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListByResourceGroupResponse = SnapshotList;

// @public
export interface SnapshotsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListNextResponse = SnapshotList;

// @public
export interface SnapshotsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type SnapshotsListResponse = SnapshotList;

// @public
export interface SnapshotsRevokeAccessHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface SnapshotsRevokeAccessOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SnapshotStorageAccountTypes = string;

// @public
export interface SnapshotsUpdateHeaders {
    location?: string;
    retryAfter?: number;
}

// @public
export interface SnapshotsUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type SnapshotsUpdateResponse = Snapshot;

// @public
export interface SnapshotUpdate {
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskSizeGB?: number;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    networkAccessPolicy?: NetworkAccessPolicy;
    osType?: OperatingSystemTypes;
    publicNetworkAccess?: PublicNetworkAccess;
    sku?: SnapshotSku;
    readonly snapshotAccessState?: SnapshotAccessState;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface SourceVault {
    id?: string;
}

// @public
export interface SupportedCapabilities {
    acceleratedNetwork?: boolean;
    architecture?: Architecture;
    diskControllerTypes?: string;
    supportedSecurityOption?: SupportedSecurityOption;
}

// @public
export type SupportedSecurityOption = string;

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: {
        [propertyName: string]: string;
    };
}

// @public (undocumented)
export interface UserAssignedIdentitiesValue {
    readonly clientId?: string;
    readonly principalId?: string;
}

// (No @packageDocumentation comment for this package)

```
