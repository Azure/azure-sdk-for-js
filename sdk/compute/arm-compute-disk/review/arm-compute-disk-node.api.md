## API Report File for "@azure/arm-compute-disk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { AbortSignalLike } from '@azure/abort-controller';
import type { ClientOptions } from '@azure-rest/core-client';
import type { OperationOptions } from '@azure-rest/core-client';
import type { OperationState } from '@azure/core-lro';
import type { PathUncheckedResponse } from '@azure-rest/core-client';
import type { Pipeline } from '@azure/core-rest-pipeline';
import type { PollerLike } from '@azure/core-lro';
import type { TokenCredential } from '@azure/core-auth';

// @public
export type AccessLevel = string;

// @public
export interface AccessUri {
    readonly accessSAS?: string;
    readonly securityDataAccessSAS?: string;
    readonly securityMetadataAccessSAS?: string;
}

// @public
export interface ApiError {
    code?: string;
    details?: ApiErrorBase[];
    innererror?: InnerError;
    message?: string;
    target?: string;
}

// @public
export interface ApiErrorBase {
    code?: string;
    message?: string;
    target?: string;
}

// @public
export type Architecture = string;

// @public
export interface AvailabilityPolicy {
    actionOnDiskDelay?: AvailabilityPolicyDiskDelay;
}

// @public
export type AvailabilityPolicyDiskDelay = string;

// @public
export enum AzureClouds {
    AZURE_CHINA_CLOUD = "AZURE_CHINA_CLOUD",
    AZURE_PUBLIC_CLOUD = "AZURE_PUBLIC_CLOUD",
    AZURE_US_GOVERNMENT = "AZURE_US_GOVERNMENT"
}

// @public
export type AzureSupportedClouds = `${AzureClouds}`;

// @public
export interface CloudError {
    error?: ApiError;
}

// @public (undocumented)
export class ComputeManagementClient {
    constructor(credential: TokenCredential, subscriptionId: string, options?: ComputeManagementClientOptionalParams);
    readonly diskAccesses: DiskAccessesOperations;
    readonly diskEncryptionSets: DiskEncryptionSetsOperations;
    readonly diskRestorePoint: DiskRestorePointOperations;
    readonly disks: DisksOperations;
    readonly pipeline: Pipeline;
    readonly snapshots: SnapshotsOperations;
}

// @public
export interface ComputeManagementClientOptionalParams extends ClientOptions {
    apiVersion?: string;
    cloudSetting?: AzureSupportedClouds;
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CopyCompletionError {
    errorCode: CopyCompletionErrorReason;
    errorMessage: string;
}

// @public
export type CopyCompletionErrorReason = string;

// @public
export type CreatedByType = string;

// @public
export interface CreationData {
    createOption: DiskCreateOption;
    elasticSanResourceId?: string;
    galleryImageReference?: ImageDiskReference;
    imageReference?: ImageDiskReference;
    instantAccessDurationMinutes?: number;
    logicalSectorSize?: number;
    performancePlus?: boolean;
    provisionedBandwidthCopySpeed?: ProvisionedBandwidthCopyOption;
    securityDataUri?: string;
    securityMetadataUri?: string;
    sourceResourceId?: string;
    readonly sourceUniqueId?: string;
    sourceUri?: string;
    storageAccountId?: string;
    uploadSizeBytes?: number;
}

// @public
export type DataAccessAuthMode = string;

// @public
export interface Disk extends TrackedResource {
    availabilityPolicy?: AvailabilityPolicy;
    burstingEnabled?: boolean;
    readonly burstingEnabledTime?: Date;
    completionPercent?: number;
    creationData: CreationData;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskIopsReadOnly?: number;
    diskIopsReadWrite?: number;
    diskMBpsReadOnly?: number;
    diskMBpsReadWrite?: number;
    readonly diskSizeBytes?: number;
    diskSizeGB?: number;
    readonly diskState?: DiskState;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    extendedLocation?: ExtendedLocation;
    hyperVGeneration?: HyperVGeneration;
    readonly lastOwnershipUpdateTime?: Date;
    readonly managedBy?: string;
    readonly managedByExtended?: string[];
    maxShares?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    optimizedForFrequentAttach?: boolean;
    osType?: OperatingSystemTypes;
    readonly propertyUpdatesInProgress?: PropertyUpdatesInProgress;
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    securityProfile?: DiskSecurityProfile;
    readonly shareInfo?: ShareInfoElement[];
    sku?: DiskSku;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    tier?: string;
    readonly timeCreated?: Date;
    readonly uniqueId?: string;
    zones?: string[];
}

// @public
export interface DiskAccess extends TrackedResource {
    extendedLocation?: ExtendedLocation;
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    readonly provisioningState?: string;
    readonly timeCreated?: Date;
}

// @public
export interface DiskAccessesCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskAccessesDeleteAPrivateEndpointConnectionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskAccessesDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskAccessesGetAPrivateEndpointConnectionOptionalParams extends OperationOptions {
}

// @public
export interface DiskAccessesGetOptionalParams extends OperationOptions {
}

// @public
export interface DiskAccessesGetPrivateLinkResourcesOptionalParams extends OperationOptions {
}

// @public
export interface DiskAccessesListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface DiskAccessesListOptionalParams extends OperationOptions {
}

// @public
export interface DiskAccessesListPrivateEndpointConnectionsOptionalParams extends OperationOptions {
}

// @public
export interface DiskAccessesOperations {
    createOrUpdate: (resourceGroupName: string, diskAccessName: string, diskAccess: DiskAccess, options?: DiskAccessesCreateOrUpdateOptionalParams) => PollerLike<OperationState<DiskAccess>, DiskAccess>;
    delete: (resourceGroupName: string, diskAccessName: string, options?: DiskAccessesDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    deleteAPrivateEndpointConnection: (resourceGroupName: string, diskAccessName: string, privateEndpointConnectionName: string, options?: DiskAccessesDeleteAPrivateEndpointConnectionOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, diskAccessName: string, options?: DiskAccessesGetOptionalParams) => Promise<DiskAccess>;
    getAPrivateEndpointConnection: (resourceGroupName: string, diskAccessName: string, privateEndpointConnectionName: string, options?: DiskAccessesGetAPrivateEndpointConnectionOptionalParams) => Promise<PrivateEndpointConnection>;
    getPrivateLinkResources: (resourceGroupName: string, diskAccessName: string, options?: DiskAccessesGetPrivateLinkResourcesOptionalParams) => Promise<PrivateLinkResourceListResult>;
    list: (options?: DiskAccessesListOptionalParams) => PagedAsyncIterableIterator<DiskAccess>;
    listByResourceGroup: (resourceGroupName: string, options?: DiskAccessesListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<DiskAccess>;
    listPrivateEndpointConnections: (resourceGroupName: string, diskAccessName: string, options?: DiskAccessesListPrivateEndpointConnectionsOptionalParams) => PagedAsyncIterableIterator<PrivateEndpointConnection>;
    update: (resourceGroupName: string, diskAccessName: string, diskAccess: DiskAccessUpdate, options?: DiskAccessesUpdateOptionalParams) => PollerLike<OperationState<DiskAccess>, DiskAccess>;
    updateAPrivateEndpointConnection: (resourceGroupName: string, diskAccessName: string, privateEndpointConnectionName: string, privateEndpointConnection: PrivateEndpointConnection, options?: DiskAccessesUpdateAPrivateEndpointConnectionOptionalParams) => PollerLike<OperationState<PrivateEndpointConnection>, PrivateEndpointConnection>;
}

// @public
export interface DiskAccessesUpdateAPrivateEndpointConnectionOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskAccessesUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskAccessProperties {
    readonly privateEndpointConnections?: PrivateEndpointConnection[];
    readonly provisioningState?: string;
    readonly timeCreated?: Date;
}

// @public
export interface DiskAccessUpdate {
    tags?: Record<string, string>;
}

// @public
export type DiskCreateOption = string;

// @public
export interface DiskEncryptionSet extends TrackedResource {
    activeKey?: KeyForDiskEncryptionSet;
    readonly autoKeyRotationError?: ApiError;
    encryptionType?: DiskEncryptionSetType;
    federatedClientId?: string;
    identity?: EncryptionSetIdentity;
    readonly lastKeyRotationTimestamp?: Date;
    readonly previousKeys?: KeyForDiskEncryptionSet[];
    readonly provisioningState?: string;
    rotationToLatestKeyVersionEnabled?: boolean;
}

// @public
export type DiskEncryptionSetIdentityType = string;

// @public
export interface DiskEncryptionSetsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskEncryptionSetsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskEncryptionSetsGetOptionalParams extends OperationOptions {
}

// @public
export interface DiskEncryptionSetsListAssociatedResourcesOptionalParams extends OperationOptions {
}

// @public
export interface DiskEncryptionSetsListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface DiskEncryptionSetsListOptionalParams extends OperationOptions {
}

// @public
export interface DiskEncryptionSetsOperations {
    createOrUpdate: (resourceGroupName: string, diskEncryptionSetName: string, diskEncryptionSet: DiskEncryptionSet, options?: DiskEncryptionSetsCreateOrUpdateOptionalParams) => PollerLike<OperationState<DiskEncryptionSet>, DiskEncryptionSet>;
    delete: (resourceGroupName: string, diskEncryptionSetName: string, options?: DiskEncryptionSetsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, diskEncryptionSetName: string, options?: DiskEncryptionSetsGetOptionalParams) => Promise<DiskEncryptionSet>;
    list: (options?: DiskEncryptionSetsListOptionalParams) => PagedAsyncIterableIterator<DiskEncryptionSet>;
    listAssociatedResources: (resourceGroupName: string, diskEncryptionSetName: string, options?: DiskEncryptionSetsListAssociatedResourcesOptionalParams) => PagedAsyncIterableIterator<string>;
    listByResourceGroup: (resourceGroupName: string, options?: DiskEncryptionSetsListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<DiskEncryptionSet>;
    update: (resourceGroupName: string, diskEncryptionSetName: string, diskEncryptionSet: DiskEncryptionSetUpdate, options?: DiskEncryptionSetsUpdateOptionalParams) => PollerLike<OperationState<DiskEncryptionSet>, DiskEncryptionSet>;
}

// @public
export interface DiskEncryptionSetsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export type DiskEncryptionSetType = string;

// @public
export interface DiskEncryptionSetUpdate {
    activeKey?: KeyForDiskEncryptionSet;
    encryptionType?: DiskEncryptionSetType;
    federatedClientId?: string;
    identity?: EncryptionSetIdentity;
    rotationToLatestKeyVersionEnabled?: boolean;
    tags?: Record<string, string>;
}

// @public
export interface DiskEncryptionSetUpdateProperties {
    activeKey?: KeyForDiskEncryptionSet;
    encryptionType?: DiskEncryptionSetType;
    federatedClientId?: string;
    rotationToLatestKeyVersionEnabled?: boolean;
}

// @public
export interface DiskProperties {
    availabilityPolicy?: AvailabilityPolicy;
    burstingEnabled?: boolean;
    readonly burstingEnabledTime?: Date;
    completionPercent?: number;
    creationData: CreationData;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskIopsReadOnly?: number;
    diskIopsReadWrite?: number;
    diskMBpsReadOnly?: number;
    diskMBpsReadWrite?: number;
    readonly diskSizeBytes?: number;
    diskSizeGB?: number;
    readonly diskState?: DiskState;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    hyperVGeneration?: HyperVGeneration;
    readonly lastOwnershipUpdateTime?: Date;
    maxShares?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    optimizedForFrequentAttach?: boolean;
    osType?: OperatingSystemTypes;
    readonly propertyUpdatesInProgress?: PropertyUpdatesInProgress;
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    securityProfile?: DiskSecurityProfile;
    readonly shareInfo?: ShareInfoElement[];
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    tier?: string;
    readonly timeCreated?: Date;
    readonly uniqueId?: string;
}

// @public
export interface DiskPurchasePlan {
    name: string;
    product: string;
    promotionCode?: string;
    publisher: string;
}

// @public
export interface DiskRestorePoint extends ProxyResource {
    completionPercent?: number;
    diskAccessId?: string;
    readonly encryption?: Encryption;
    readonly familyId?: string;
    hyperVGeneration?: HyperVGeneration;
    readonly logicalSectorSize?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    readonly osType?: OperatingSystemTypes;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    readonly replicationState?: string;
    securityProfile?: DiskSecurityProfile;
    readonly sourceResourceId?: string;
    readonly sourceResourceLocation?: string;
    readonly sourceUniqueId?: string;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    readonly timeCreated?: Date;
}

// @public
export interface DiskRestorePointGetOptionalParams extends OperationOptions {
}

// @public
export interface DiskRestorePointGrantAccessOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskRestorePointListByRestorePointOptionalParams extends OperationOptions {
}

// @public
export interface DiskRestorePointOperations {
    get: (resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, diskRestorePointName: string, options?: DiskRestorePointGetOptionalParams) => Promise<DiskRestorePoint>;
    grantAccess: (resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, diskRestorePointName: string, grantAccessData: GrantAccessData, options?: DiskRestorePointGrantAccessOptionalParams) => PollerLike<OperationState<AccessUri>, AccessUri>;
    listByRestorePoint: (resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, options?: DiskRestorePointListByRestorePointOptionalParams) => PagedAsyncIterableIterator<DiskRestorePoint>;
    revokeAccess: (resourceGroupName: string, restorePointCollectionName: string, vmRestorePointName: string, diskRestorePointName: string, options?: DiskRestorePointRevokeAccessOptionalParams) => PollerLike<OperationState<void>, void>;
}

// @public
export interface DiskRestorePointProperties {
    completionPercent?: number;
    diskAccessId?: string;
    readonly encryption?: Encryption;
    readonly familyId?: string;
    hyperVGeneration?: HyperVGeneration;
    readonly logicalSectorSize?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    readonly osType?: OperatingSystemTypes;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    readonly replicationState?: string;
    securityProfile?: DiskSecurityProfile;
    readonly sourceResourceId?: string;
    readonly sourceResourceLocation?: string;
    readonly sourceUniqueId?: string;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    readonly timeCreated?: Date;
}

// @public
export interface DiskRestorePointRevokeAccessOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DisksCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DisksDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskSecurityProfile {
    secureVMDiskEncryptionSetId?: string;
    securityType?: DiskSecurityTypes;
}

// @public
export type DiskSecurityTypes = string;

// @public
export interface DisksGetOptionalParams extends OperationOptions {
}

// @public
export interface DisksGrantAccessOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskSku {
    name?: DiskStorageAccountTypes;
    readonly tier?: string;
}

// @public
export interface DisksListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface DisksListOptionalParams extends OperationOptions {
}

// @public
export interface DisksOperations {
    createOrUpdate: (resourceGroupName: string, diskName: string, disk: Disk, options?: DisksCreateOrUpdateOptionalParams) => PollerLike<OperationState<Disk>, Disk>;
    delete: (resourceGroupName: string, diskName: string, options?: DisksDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, diskName: string, options?: DisksGetOptionalParams) => Promise<Disk>;
    grantAccess: (resourceGroupName: string, diskName: string, grantAccessData: GrantAccessData, options?: DisksGrantAccessOptionalParams) => PollerLike<OperationState<AccessUri>, AccessUri>;
    list: (options?: DisksListOptionalParams) => PagedAsyncIterableIterator<Disk>;
    listByResourceGroup: (resourceGroupName: string, options?: DisksListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<Disk>;
    revokeAccess: (resourceGroupName: string, diskName: string, options?: DisksRevokeAccessOptionalParams) => PollerLike<OperationState<void>, void>;
    update: (resourceGroupName: string, diskName: string, disk: DiskUpdate, options?: DisksUpdateOptionalParams) => PollerLike<OperationState<Disk>, Disk>;
}

// @public
export interface DisksRevokeAccessOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export type DiskState = string;

// @public
export type DiskStorageAccountTypes = string;

// @public
export interface DisksUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface DiskUpdate {
    availabilityPolicy?: AvailabilityPolicy;
    burstingEnabled?: boolean;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskIopsReadOnly?: number;
    diskIopsReadWrite?: number;
    diskMBpsReadOnly?: number;
    diskMBpsReadWrite?: number;
    diskSizeGB?: number;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    maxShares?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    optimizedForFrequentAttach?: boolean;
    osType?: OperatingSystemTypes;
    readonly propertyUpdatesInProgress?: PropertyUpdatesInProgress;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    sku?: DiskSku;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    tags?: Record<string, string>;
    tier?: string;
}

// @public
export interface DiskUpdateProperties {
    availabilityPolicy?: AvailabilityPolicy;
    burstingEnabled?: boolean;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskIopsReadOnly?: number;
    diskIopsReadWrite?: number;
    diskMBpsReadOnly?: number;
    diskMBpsReadWrite?: number;
    diskSizeGB?: number;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    maxShares?: number;
    networkAccessPolicy?: NetworkAccessPolicy;
    optimizedForFrequentAttach?: boolean;
    osType?: OperatingSystemTypes;
    readonly propertyUpdatesInProgress?: PropertyUpdatesInProgress;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    tier?: string;
}

// @public
export interface Encryption {
    diskEncryptionSetId?: string;
    type?: EncryptionType;
}

// @public
export interface EncryptionSetIdentity {
    readonly principalId?: string;
    readonly tenantId?: string;
    type?: DiskEncryptionSetIdentityType;
    userAssignedIdentities?: Record<string, UserAssignedIdentitiesValue>;
}

// @public
export interface EncryptionSetProperties {
    activeKey?: KeyForDiskEncryptionSet;
    readonly autoKeyRotationError?: ApiError;
    encryptionType?: DiskEncryptionSetType;
    federatedClientId?: string;
    readonly lastKeyRotationTimestamp?: Date;
    readonly previousKeys?: KeyForDiskEncryptionSet[];
    readonly provisioningState?: string;
    rotationToLatestKeyVersionEnabled?: boolean;
}

// @public
export interface EncryptionSettingsCollection {
    enabled: boolean;
    encryptionSettings?: EncryptionSettingsElement[];
    encryptionSettingsVersion?: string;
}

// @public
export interface EncryptionSettingsElement {
    diskEncryptionKey?: KeyVaultAndSecretReference;
    keyEncryptionKey?: KeyVaultAndKeyReference;
}

// @public
export type EncryptionType = string;

// @public
export interface ExtendedLocation {
    name?: string;
    type?: ExtendedLocationTypes;
}

// @public
export type ExtendedLocationTypes = string;

// @public
export type FileFormat = string;

// @public
export interface GrantAccessData {
    access: AccessLevel;
    durationInSeconds: number;
    fileFormat?: FileFormat;
    getSecureVMGuestStateSAS?: boolean;
}

// @public
export type HyperVGeneration = string;

// @public
export interface ImageDiskReference {
    communityGalleryImageId?: string;
    id?: string;
    lun?: number;
    sharedGalleryImageId?: string;
}

// @public
export interface InnerError {
    errordetail?: string;
    exceptiontype?: string;
}

// @public
export interface KeyForDiskEncryptionSet {
    keyUrl: string;
    sourceVault?: SourceVault;
}

// @public
export interface KeyVaultAndKeyReference {
    keyUrl: string;
    sourceVault: SourceVault;
}

// @public
export interface KeyVaultAndSecretReference {
    secretUrl: string;
    sourceVault: SourceVault;
}

// @public
export enum KnownAccessLevel {
    None = "None",
    Read = "Read",
    Write = "Write"
}

// @public
export enum KnownArchitecture {
    Arm64 = "Arm64",
    X64 = "x64"
}

// @public
export enum KnownAvailabilityPolicyDiskDelay {
    AutomaticReattach = "AutomaticReattach",
    None = "None"
}

// @public
export enum KnownCopyCompletionErrorReason {
    CopySourceNotFound = "CopySourceNotFound"
}

// @public
export enum KnownCreatedByType {
    Application = "Application",
    Key = "Key",
    ManagedIdentity = "ManagedIdentity",
    User = "User"
}

// @public
export enum KnownDataAccessAuthMode {
    AzureActiveDirectory = "AzureActiveDirectory",
    None = "None"
}

// @public
export enum KnownDiskCreateOption {
    Attach = "Attach",
    Copy = "Copy",
    CopyFromSanSnapshot = "CopyFromSanSnapshot",
    CopyStart = "CopyStart",
    Empty = "Empty",
    FromImage = "FromImage",
    Import = "Import",
    ImportSecure = "ImportSecure",
    Restore = "Restore",
    Upload = "Upload",
    UploadPreparedSecure = "UploadPreparedSecure"
}

// @public
export enum KnownDiskEncryptionSetIdentityType {
    None = "None",
    SystemAssigned = "SystemAssigned",
    SystemAssignedUserAssigned = "SystemAssigned, UserAssigned",
    UserAssigned = "UserAssigned"
}

// @public
export enum KnownDiskEncryptionSetType {
    ConfidentialVmEncryptedWithCustomerKey = "ConfidentialVmEncryptedWithCustomerKey",
    EncryptionAtRestWithCustomerKey = "EncryptionAtRestWithCustomerKey",
    EncryptionAtRestWithPlatformAndCustomerKeys = "EncryptionAtRestWithPlatformAndCustomerKeys"
}

// @public
export enum KnownDiskSecurityTypes {
    ConfidentialVMDiskEncryptedWithCustomerKey = "ConfidentialVM_DiskEncryptedWithCustomerKey",
    ConfidentialVMDiskEncryptedWithPlatformKey = "ConfidentialVM_DiskEncryptedWithPlatformKey",
    ConfidentialVMNonPersistedTPM = "ConfidentialVM_NonPersistedTPM",
    ConfidentialVMVmguestStateOnlyEncryptedWithPlatformKey = "ConfidentialVM_VMGuestStateOnlyEncryptedWithPlatformKey",
    TrustedLaunch = "TrustedLaunch"
}

// @public
export enum KnownDiskState {
    ActiveSAS = "ActiveSAS",
    ActiveSASFrozen = "ActiveSASFrozen",
    ActiveUpload = "ActiveUpload",
    Attached = "Attached",
    Frozen = "Frozen",
    ReadyToUpload = "ReadyToUpload",
    Reserved = "Reserved",
    Unattached = "Unattached"
}

// @public
export enum KnownDiskStorageAccountTypes {
    PremiumLRS = "Premium_LRS",
    PremiumV2LRS = "PremiumV2_LRS",
    PremiumZRS = "Premium_ZRS",
    StandardLRS = "Standard_LRS",
    StandardSSDLRS = "StandardSSD_LRS",
    StandardSSDZRS = "StandardSSD_ZRS",
    UltraSSDLRS = "UltraSSD_LRS"
}

// @public
export enum KnownEncryptionType {
    EncryptionAtRestWithCustomerKey = "EncryptionAtRestWithCustomerKey",
    EncryptionAtRestWithPlatformAndCustomerKeys = "EncryptionAtRestWithPlatformAndCustomerKeys",
    EncryptionAtRestWithPlatformKey = "EncryptionAtRestWithPlatformKey"
}

// @public
export enum KnownExtendedLocationTypes {
    EdgeZone = "EdgeZone"
}

// @public
export enum KnownFileFormat {
    VHD = "VHD",
    Vhdx = "VHDX"
}

// @public
export enum KnownHyperVGeneration {
    V1 = "V1",
    V2 = "V2"
}

// @public
export enum KnownNetworkAccessPolicy {
    AllowAll = "AllowAll",
    AllowPrivate = "AllowPrivate",
    DenyAll = "DenyAll"
}

// @public
export enum KnownPrivateEndpointConnectionProvisioningState {
    Creating = "Creating",
    Deleting = "Deleting",
    Failed = "Failed",
    Succeeded = "Succeeded"
}

// @public
export enum KnownPrivateEndpointServiceConnectionStatus {
    Approved = "Approved",
    Pending = "Pending",
    Rejected = "Rejected"
}

// @public
export enum KnownProvisionedBandwidthCopyOption {
    Enhanced = "Enhanced",
    None = "None"
}

// @public
export enum KnownPublicNetworkAccess {
    Disabled = "Disabled",
    Enabled = "Enabled"
}

// @public
export enum KnownSnapshotAccessState {
    Available = "Available",
    AvailableWithInstantAccess = "AvailableWithInstantAccess",
    InstantAccess = "InstantAccess",
    Pending = "Pending",
    Unknown = "Unknown"
}

// @public
export enum KnownSnapshotStorageAccountTypes {
    PremiumLRS = "Premium_LRS",
    StandardLRS = "Standard_LRS",
    StandardZRS = "Standard_ZRS"
}

// @public
export enum KnownSupportedSecurityOption {
    TrustedLaunchAndConfidentialVMSupported = "TrustedLaunchAndConfidentialVMSupported",
    TrustedLaunchSupported = "TrustedLaunchSupported"
}

// @public
export enum KnownVersions {
    V20240302 = "2024-03-02",
    V20250102 = "2025-01-02"
}

// @public
export type NetworkAccessPolicy = string;

// @public
export type OperatingSystemTypes = "Windows" | "Linux";

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export interface PrivateEndpoint {
    readonly id?: string;
}

// @public
export interface PrivateEndpointConnection extends ProxyResource {
    readonly privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
}

// @public
export interface PrivateEndpointConnectionProperties {
    readonly privateEndpoint?: PrivateEndpoint;
    privateLinkServiceConnectionState: PrivateLinkServiceConnectionState;
    readonly provisioningState?: PrivateEndpointConnectionProvisioningState;
}

// @public
export type PrivateEndpointConnectionProvisioningState = string;

// @public
export type PrivateEndpointServiceConnectionStatus = string;

// @public
export interface PrivateLinkResource {
    readonly groupId?: string;
    readonly id?: string;
    readonly name?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
    readonly type?: string;
}

// @public
export interface PrivateLinkResourceListResult {
    value?: PrivateLinkResource[];
}

// @public
export interface PrivateLinkResourceProperties {
    readonly groupId?: string;
    readonly requiredMembers?: string[];
    requiredZoneNames?: string[];
}

// @public
export interface PrivateLinkServiceConnectionState {
    actionsRequired?: string;
    description?: string;
    status?: PrivateEndpointServiceConnectionStatus;
}

// @public
export interface PropertyUpdatesInProgress {
    targetTier?: string;
}

// @public
export type ProvisionedBandwidthCopyOption = string;

// @public
export interface ProxyResource extends Resource {
}

// @public
export type PublicNetworkAccess = string;

// @public
export interface Resource {
    readonly id?: string;
    readonly name?: string;
    readonly systemData?: SystemData;
    readonly type?: string;
}

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: ComputeManagementClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export interface ShareInfoElement {
    readonly vmUri?: string;
}

// @public
export interface Snapshot extends TrackedResource {
    completionPercent?: number;
    copyCompletionError?: CopyCompletionError;
    creationData: CreationData;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    readonly diskSizeBytes?: number;
    diskSizeGB?: number;
    readonly diskState?: DiskState;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    extendedLocation?: ExtendedLocation;
    hyperVGeneration?: HyperVGeneration;
    incremental?: boolean;
    readonly incrementalSnapshotFamilyId?: string;
    readonly managedBy?: string;
    networkAccessPolicy?: NetworkAccessPolicy;
    osType?: OperatingSystemTypes;
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    securityProfile?: DiskSecurityProfile;
    sku?: SnapshotSku;
    readonly snapshotAccessState?: SnapshotAccessState;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    readonly timeCreated?: Date;
    readonly uniqueId?: string;
}

// @public
export type SnapshotAccessState = string;

// @public
export interface SnapshotProperties {
    completionPercent?: number;
    copyCompletionError?: CopyCompletionError;
    creationData: CreationData;
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    readonly diskSizeBytes?: number;
    diskSizeGB?: number;
    readonly diskState?: DiskState;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    hyperVGeneration?: HyperVGeneration;
    incremental?: boolean;
    readonly incrementalSnapshotFamilyId?: string;
    networkAccessPolicy?: NetworkAccessPolicy;
    osType?: OperatingSystemTypes;
    readonly provisioningState?: string;
    publicNetworkAccess?: PublicNetworkAccess;
    purchasePlan?: DiskPurchasePlan;
    securityProfile?: DiskSecurityProfile;
    readonly snapshotAccessState?: SnapshotAccessState;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    readonly timeCreated?: Date;
    readonly uniqueId?: string;
}

// @public
export interface SnapshotsCreateOrUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotsDeleteOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotsGetOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsGrantAccessOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotSku {
    name?: SnapshotStorageAccountTypes;
    readonly tier?: string;
}

// @public
export interface SnapshotsListByResourceGroupOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsListOptionalParams extends OperationOptions {
}

// @public
export interface SnapshotsOperations {
    createOrUpdate: (resourceGroupName: string, snapshotName: string, snapshot: Snapshot, options?: SnapshotsCreateOrUpdateOptionalParams) => PollerLike<OperationState<Snapshot>, Snapshot>;
    delete: (resourceGroupName: string, snapshotName: string, options?: SnapshotsDeleteOptionalParams) => PollerLike<OperationState<void>, void>;
    get: (resourceGroupName: string, snapshotName: string, options?: SnapshotsGetOptionalParams) => Promise<Snapshot>;
    grantAccess: (resourceGroupName: string, snapshotName: string, grantAccessData: GrantAccessData, options?: SnapshotsGrantAccessOptionalParams) => PollerLike<OperationState<AccessUri>, AccessUri>;
    list: (options?: SnapshotsListOptionalParams) => PagedAsyncIterableIterator<Snapshot>;
    listByResourceGroup: (resourceGroupName: string, options?: SnapshotsListByResourceGroupOptionalParams) => PagedAsyncIterableIterator<Snapshot>;
    revokeAccess: (resourceGroupName: string, snapshotName: string, options?: SnapshotsRevokeAccessOptionalParams) => PollerLike<OperationState<void>, void>;
    update: (resourceGroupName: string, snapshotName: string, snapshot: SnapshotUpdate, options?: SnapshotsUpdateOptionalParams) => PollerLike<OperationState<Snapshot>, Snapshot>;
}

// @public
export interface SnapshotsRevokeAccessOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export type SnapshotStorageAccountTypes = string;

// @public
export interface SnapshotsUpdateOptionalParams extends OperationOptions {
    updateIntervalInMs?: number;
}

// @public
export interface SnapshotUpdate {
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskSizeGB?: number;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    networkAccessPolicy?: NetworkAccessPolicy;
    osType?: OperatingSystemTypes;
    publicNetworkAccess?: PublicNetworkAccess;
    sku?: SnapshotSku;
    readonly snapshotAccessState?: SnapshotAccessState;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
    tags?: Record<string, string>;
}

// @public
export interface SnapshotUpdateProperties {
    dataAccessAuthMode?: DataAccessAuthMode;
    diskAccessId?: string;
    diskSizeGB?: number;
    encryption?: Encryption;
    encryptionSettingsCollection?: EncryptionSettingsCollection;
    networkAccessPolicy?: NetworkAccessPolicy;
    osType?: OperatingSystemTypes;
    publicNetworkAccess?: PublicNetworkAccess;
    readonly snapshotAccessState?: SnapshotAccessState;
    supportedCapabilities?: SupportedCapabilities;
    supportsHibernation?: boolean;
}

// @public
export interface SourceVault {
    id?: string;
}

// @public
export interface SupportedCapabilities {
    acceleratedNetwork?: boolean;
    architecture?: Architecture;
    diskControllerTypes?: string;
    supportedSecurityOption?: SupportedSecurityOption;
}

// @public
export type SupportedSecurityOption = string;

// @public
export interface SystemData {
    createdAt?: Date;
    createdBy?: string;
    createdByType?: CreatedByType;
    lastModifiedAt?: Date;
    lastModifiedBy?: string;
    lastModifiedByType?: CreatedByType;
}

// @public
export interface TrackedResource extends Resource {
    location: string;
    tags?: Record<string, string>;
}

// @public
export interface UserAssignedIdentitiesValue {
    readonly clientId?: string;
    readonly principalId?: string;
}

// (No @packageDocumentation comment for this package)

```
