## API Report File for "@azure/arm-storsimple8000series"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as coreAuth from '@azure/core-auth';
import * as coreClient from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PollerLike } from '@azure/core-lro';
import { PollOperationState } from '@azure/core-lro';

// @public
export type AccessControlRecord = BaseModel & {
    initiatorName: string;
    readonly volumeCount?: number;
};

// @public
export interface AccessControlRecordList {
    value: AccessControlRecord[];
}

// @public
export interface AccessControlRecords {
    beginCreateOrUpdate(accessControlRecordName: string, resourceGroupName: string, managerName: string, parameters: AccessControlRecord, options?: AccessControlRecordsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<AccessControlRecordsCreateOrUpdateResponse>, AccessControlRecordsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(accessControlRecordName: string, resourceGroupName: string, managerName: string, parameters: AccessControlRecord, options?: AccessControlRecordsCreateOrUpdateOptionalParams): Promise<AccessControlRecordsCreateOrUpdateResponse>;
    beginDelete(accessControlRecordName: string, resourceGroupName: string, managerName: string, options?: AccessControlRecordsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(accessControlRecordName: string, resourceGroupName: string, managerName: string, options?: AccessControlRecordsDeleteOptionalParams): Promise<void>;
    get(accessControlRecordName: string, resourceGroupName: string, managerName: string, options?: AccessControlRecordsGetOptionalParams): Promise<AccessControlRecordsGetResponse>;
    listByManager(resourceGroupName: string, managerName: string, options?: AccessControlRecordsListByManagerOptionalParams): PagedAsyncIterableIterator<AccessControlRecord>;
}

// @public
export interface AccessControlRecordsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type AccessControlRecordsCreateOrUpdateResponse = AccessControlRecord;

// @public
export interface AccessControlRecordsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface AccessControlRecordsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccessControlRecordsGetResponse = AccessControlRecord;

// @public
export interface AccessControlRecordsListByManagerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AccessControlRecordsListByManagerResponse = AccessControlRecordList;

// @public
export interface AcsConfiguration {
    namespace: string;
    realm: string;
    serviceUrl: string;
}

// @public
export type Alert = BaseModel & {
    title: string;
    scope: AlertScope;
    alertType: string;
    appearedAtTime: Date;
    appearedAtSourceTime: Date;
    clearedAtTime?: Date;
    clearedAtSourceTime?: Date;
    source: AlertSource;
    recommendation?: string;
    resolutionReason?: string;
    severity: AlertSeverity;
    status: AlertStatus;
    errorDetails?: AlertErrorDetails;
    detailedInformation?: {
        [propertyName: string]: string;
    };
};

// @public
export type AlertEmailNotificationStatus = "Enabled" | "Disabled";

// @public
export interface AlertErrorDetails {
    errorCode?: string;
    errorMessage?: string;
    occurences?: number;
}

// @public
export interface AlertFilter {
    appearedOnTime?: Date;
    severity?: AlertSeverity;
    sourceName?: string;
    sourceType?: AlertSourceType;
    status?: AlertStatus;
}

// @public
export interface AlertList {
    nextLink?: string;
    value: Alert[];
}

// @public
export interface Alerts {
    clear(resourceGroupName: string, managerName: string, parameters: ClearAlertRequest, options?: AlertsClearOptionalParams): Promise<void>;
    listByManager(resourceGroupName: string, managerName: string, options?: AlertsListByManagerOptionalParams): PagedAsyncIterableIterator<Alert>;
    sendTestEmail(deviceName: string, resourceGroupName: string, managerName: string, parameters: SendTestAlertEmailRequest, options?: AlertsSendTestEmailOptionalParams): Promise<void>;
}

// @public
export interface AlertsClearOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AlertScope = "Resource" | "Device";

// @public
export type AlertSettings = BaseModel & {
    emailNotification: AlertEmailNotificationStatus;
    alertNotificationCulture?: string;
    notificationToServiceOwners?: AlertEmailNotificationStatus;
    additionalRecipientEmailList?: string[];
};

// @public
export type AlertSeverity = "Informational" | "Warning" | "Critical";

// @public
export interface AlertsListByManagerNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type AlertsListByManagerNextResponse = AlertList;

// @public
export interface AlertsListByManagerOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type AlertsListByManagerResponse = AlertList;

// @public
export interface AlertSource {
    alertSourceType?: AlertSourceType;
    name?: string;
    timeZone?: string;
}

// @public
export type AlertSourceType = "Resource" | "Device";

// @public
export interface AlertsSendTestEmailOptionalParams extends coreClient.OperationOptions {
}

// @public
export type AlertStatus = "Active" | "Cleared";

// @public
export interface AsymmetricEncryptedSecret {
    encryptionAlgorithm: EncryptionAlgorithm;
    encryptionCertThumbprint?: string;
    value: string;
}

// @public
export type AuthenticationType = "Invalid" | "None" | "Basic" | "NTLM";

// @public
export type AuthorizationEligibility = "InEligible" | "Eligible";

// @public
export type AuthorizationStatus = "Disabled" | "Enabled";

// @public
export interface AvailableProviderOperation {
    display?: AvailableProviderOperationDisplay;
    name?: string;
    origin?: string;
    properties?: Record<string, unknown>;
}

// @public
export interface AvailableProviderOperationDisplay {
    description?: string;
    operation?: string;
    provider?: string;
    resource?: string;
}

// @public
export interface AvailableProviderOperationList {
    nextLink?: string;
    value: AvailableProviderOperation[];
}

// @public
export type Backup = BaseModel & {
    createdOn: Date;
    sizeInBytes: number;
    backupType?: BackupType;
    backupJobCreationType?: BackupJobCreationType;
    backupPolicyId?: string;
    ssmHostName?: string;
    elements: BackupElement[];
};

// @public
export interface BackupElement {
    elementId: string;
    elementName: string;
    elementType: string;
    sizeInBytes: number;
    volumeContainerId: string;
    volumeName: string;
    volumeType?: VolumeType;
}

// @public
export interface BackupFilter {
    backupPolicyId?: string;
    createdTime?: Date;
    volumeId?: string;
}

// @public
export type BackupJobCreationType = "Adhoc" | "BySchedule" | "BySSM";

// @public
export interface BackupList {
    nextLink?: string;
    value: Backup[];
}

// @public
export interface BackupPolicies {
    beginBackupNow(deviceName: string, backupPolicyName: string, backupType: string, resourceGroupName: string, managerName: string, options?: BackupPoliciesBackupNowOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginBackupNowAndWait(deviceName: string, backupPolicyName: string, backupType: string, resourceGroupName: string, managerName: string, options?: BackupPoliciesBackupNowOptionalParams): Promise<void>;
    beginCreateOrUpdate(deviceName: string, backupPolicyName: string, resourceGroupName: string, managerName: string, parameters: BackupPolicy, options?: BackupPoliciesCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<BackupPoliciesCreateOrUpdateResponse>, BackupPoliciesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, backupPolicyName: string, resourceGroupName: string, managerName: string, parameters: BackupPolicy, options?: BackupPoliciesCreateOrUpdateOptionalParams): Promise<BackupPoliciesCreateOrUpdateResponse>;
    beginDelete(deviceName: string, backupPolicyName: string, resourceGroupName: string, managerName: string, options?: BackupPoliciesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, backupPolicyName: string, resourceGroupName: string, managerName: string, options?: BackupPoliciesDeleteOptionalParams): Promise<void>;
    get(deviceName: string, backupPolicyName: string, resourceGroupName: string, managerName: string, options?: BackupPoliciesGetOptionalParams): Promise<BackupPoliciesGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: BackupPoliciesListByDeviceOptionalParams): PagedAsyncIterableIterator<BackupPolicy>;
}

// @public
export interface BackupPoliciesBackupNowOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupPoliciesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BackupPoliciesCreateOrUpdateResponse = BackupPolicy;

// @public
export interface BackupPoliciesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupPoliciesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupPoliciesGetResponse = BackupPolicy;

// @public
export interface BackupPoliciesListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupPoliciesListByDeviceResponse = BackupPolicyList;

// @public
export type BackupPolicy = BaseModel & {
    volumeIds: string[];
    readonly nextBackupTime?: Date;
    readonly lastBackupTime?: Date;
    readonly schedulesCount?: number;
    readonly scheduledBackupStatus?: ScheduledBackupStatus;
    readonly backupPolicyCreationType?: BackupPolicyCreationType;
    readonly ssmHostName?: string;
};

// @public
export type BackupPolicyCreationType = "BySaaS" | "BySSM";

// @public
export interface BackupPolicyList {
    value: BackupPolicy[];
}

// @public
export interface Backups {
    beginClone(deviceName: string, backupName: string, backupElementName: string, resourceGroupName: string, managerName: string, parameters: CloneRequest, options?: BackupsCloneOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginCloneAndWait(deviceName: string, backupName: string, backupElementName: string, resourceGroupName: string, managerName: string, parameters: CloneRequest, options?: BackupsCloneOptionalParams): Promise<void>;
    beginDelete(deviceName: string, backupName: string, resourceGroupName: string, managerName: string, options?: BackupsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, backupName: string, resourceGroupName: string, managerName: string, options?: BackupsDeleteOptionalParams): Promise<void>;
    beginRestore(deviceName: string, backupName: string, resourceGroupName: string, managerName: string, options?: BackupsRestoreOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginRestoreAndWait(deviceName: string, backupName: string, resourceGroupName: string, managerName: string, options?: BackupsRestoreOptionalParams): Promise<void>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: BackupsListByDeviceOptionalParams): PagedAsyncIterableIterator<Backup>;
}

// @public
export type BackupSchedule = BaseModel & {
    scheduleRecurrence: ScheduleRecurrence;
    backupType: BackupType;
    retentionCount: number;
    startTime: Date;
    scheduleStatus: ScheduleStatus;
    readonly lastSuccessfulRun?: Date;
};

// @public
export interface BackupScheduleList {
    value: BackupSchedule[];
}

// @public
export interface BackupSchedules {
    beginCreateOrUpdate(deviceName: string, backupPolicyName: string, backupScheduleName: string, resourceGroupName: string, managerName: string, parameters: BackupSchedule, options?: BackupSchedulesCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<BackupSchedulesCreateOrUpdateResponse>, BackupSchedulesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, backupPolicyName: string, backupScheduleName: string, resourceGroupName: string, managerName: string, parameters: BackupSchedule, options?: BackupSchedulesCreateOrUpdateOptionalParams): Promise<BackupSchedulesCreateOrUpdateResponse>;
    beginDelete(deviceName: string, backupPolicyName: string, backupScheduleName: string, resourceGroupName: string, managerName: string, options?: BackupSchedulesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, backupPolicyName: string, backupScheduleName: string, resourceGroupName: string, managerName: string, options?: BackupSchedulesDeleteOptionalParams): Promise<void>;
    get(deviceName: string, backupPolicyName: string, backupScheduleName: string, resourceGroupName: string, managerName: string, options?: BackupSchedulesGetOptionalParams): Promise<BackupSchedulesGetResponse>;
    listByBackupPolicy(deviceName: string, backupPolicyName: string, resourceGroupName: string, managerName: string, options?: BackupSchedulesListByBackupPolicyOptionalParams): PagedAsyncIterableIterator<BackupSchedule>;
}

// @public
export interface BackupSchedulesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BackupSchedulesCreateOrUpdateResponse = BackupSchedule;

// @public
export interface BackupSchedulesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupSchedulesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupSchedulesGetResponse = BackupSchedule;

// @public
export interface BackupSchedulesListByBackupPolicyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BackupSchedulesListByBackupPolicyResponse = BackupScheduleList;

// @public
export interface BackupsCloneOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BackupsListByDeviceNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type BackupsListByDeviceNextResponse = BackupList;

// @public
export interface BackupsListByDeviceOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type BackupsListByDeviceResponse = BackupList;

// @public
export interface BackupsRestoreOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BackupStatus = "Enabled" | "Disabled";

// @public
export type BackupType = "LocalSnapshot" | "CloudSnapshot";

// @public
export interface BandwidthSchedule {
    days: DayOfWeek[];
    rateInMbps: number;
    start: Time;
    stop: Time;
}

// @public
export type BandwidthSetting = BaseModel & {
    schedules: BandwidthSchedule[];
    readonly volumeCount?: number;
};

// @public
export interface BandwidthSettingList {
    value: BandwidthSetting[];
}

// @public
export interface BandwidthSettings {
    beginCreateOrUpdate(bandwidthSettingName: string, resourceGroupName: string, managerName: string, parameters: BandwidthSetting, options?: BandwidthSettingsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<BandwidthSettingsCreateOrUpdateResponse>, BandwidthSettingsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(bandwidthSettingName: string, resourceGroupName: string, managerName: string, parameters: BandwidthSetting, options?: BandwidthSettingsCreateOrUpdateOptionalParams): Promise<BandwidthSettingsCreateOrUpdateResponse>;
    beginDelete(bandwidthSettingName: string, resourceGroupName: string, managerName: string, options?: BandwidthSettingsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(bandwidthSettingName: string, resourceGroupName: string, managerName: string, options?: BandwidthSettingsDeleteOptionalParams): Promise<void>;
    get(bandwidthSettingName: string, resourceGroupName: string, managerName: string, options?: BandwidthSettingsGetOptionalParams): Promise<BandwidthSettingsGetResponse>;
    listByManager(resourceGroupName: string, managerName: string, options?: BandwidthSettingsListByManagerOptionalParams): PagedAsyncIterableIterator<BandwidthSetting>;
}

// @public
export interface BandwidthSettingsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type BandwidthSettingsCreateOrUpdateResponse = BandwidthSetting;

// @public
export interface BandwidthSettingsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface BandwidthSettingsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BandwidthSettingsGetResponse = BandwidthSetting;

// @public
export interface BandwidthSettingsListByManagerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type BandwidthSettingsListByManagerResponse = BandwidthSettingList;

// @public
export interface BaseModel {
    readonly id?: string;
    kind?: "Series8000";
    readonly name?: string;
    readonly type?: string;
}

// @public
export interface ChapSettings {
    initiatorSecret?: AsymmetricEncryptedSecret;
    initiatorUser?: string;
    targetSecret?: AsymmetricEncryptedSecret;
    targetUser?: string;
}

// @public
export interface ClearAlertRequest {
    alerts: string[];
    resolutionMessage?: string;
}

// @public
export interface CloneRequest {
    backupElement: BackupElement;
    targetAccessControlRecordIds: string[];
    targetDeviceId: string;
    targetVolumeName: string;
}

// @public
export interface CloudAppliance {
    isVnetDnsConfigured?: boolean;
    isVnetExpressConfigured?: boolean;
    modelNumber?: string;
    name: string;
    storageAccountName?: string;
    storageAccountType?: string;
    subnetName?: string;
    vmImageName?: string;
    vmType?: string;
    vnetName?: string;
    vnetRegion: string;
}

// @public
export type CloudApplianceConfiguration = BaseModel & {
    modelNumber: string;
    cloudPlatform: string;
    acsConfiguration: AcsConfiguration;
    supportedStorageAccountTypes: string[];
    supportedRegions: string[];
    supportedVmTypes: string[];
    supportedVmImages: VmImage[];
};

// @public
export interface CloudApplianceConfigurationList {
    value: CloudApplianceConfiguration[];
}

// @public
export interface CloudAppliances {
    beginProvision(resourceGroupName: string, managerName: string, parameters: CloudAppliance, options?: CloudAppliancesProvisionOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginProvisionAndWait(resourceGroupName: string, managerName: string, parameters: CloudAppliance, options?: CloudAppliancesProvisionOptionalParams): Promise<void>;
    listSupportedConfigurations(resourceGroupName: string, managerName: string, options?: CloudAppliancesListSupportedConfigurationsOptionalParams): PagedAsyncIterableIterator<CloudApplianceConfiguration>;
}

// @public
export interface CloudApplianceSettings {
    channelIntegrityKey?: AsymmetricEncryptedSecret;
    serviceDataEncryptionKey?: AsymmetricEncryptedSecret;
}

// @public
export interface CloudAppliancesListSupportedConfigurationsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type CloudAppliancesListSupportedConfigurationsResponse = CloudApplianceConfigurationList;

// @public
export interface CloudAppliancesProvisionOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type ConfigureDeviceRequest = BaseModel & {
    friendlyName: string;
    currentDeviceName: string;
    timeZone: string;
    dnsSettings?: SecondaryDNSSettings;
    networkInterfaceData0Settings?: NetworkInterfaceData0Settings;
};

// @public
export type ControllerId = "Unknown" | "None" | "Controller0" | "Controller1";

// @public
export type ControllerPowerStateAction = "Start" | "Restart" | "Shutdown";

// @public
export type ControllerPowerStateChangeRequest = BaseModel & {
    action: ControllerPowerStateAction;
    activeController: ControllerId;
    controller0State: ControllerStatus;
    controller1State: ControllerStatus;
};

// @public
export type ControllerStatus = "NotPresent" | "PoweredOff" | "Ok" | "Recovering" | "Warning" | "Failure";

// @public
export interface DataStatistics {
    cloudData?: number;
    processedData?: number;
    throughput?: number;
    totalData?: number;
}

// @public
export type DayOfWeek = "Sunday" | "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday";

// @public
export type Device = BaseModel & {
    friendlyName: string;
    activationTime: Date;
    culture: string;
    deviceDescription: string;
    deviceSoftwareVersion: string;
    friendlySoftwareName?: string;
    deviceConfigurationStatus: DeviceConfigurationStatus;
    targetIqn: string;
    modelDescription: string;
    status: DeviceStatus;
    serialNumber: string;
    deviceType: DeviceType;
    activeController: ControllerId;
    friendlySoftwareVersion: string;
    availableLocalStorageInBytes?: number;
    availableTieredStorageInBytes?: number;
    provisionedTieredStorageInBytes?: number;
    provisionedLocalStorageInBytes?: number;
    provisionedVolumeSizeInBytes?: number;
    usingStorageInBytes?: number;
    totalTieredStorageInBytes?: number;
    agentGroupVersion?: number;
    networkInterfaceCardCount?: number;
    deviceLocation?: string;
    readonly virtualMachineApiType?: VirtualMachineApiType;
    details?: DeviceDetails;
    rolloverDetails?: DeviceRolloverDetails;
};

// @public
export type DeviceConfigurationStatus = "Complete" | "Pending";

// @public
export interface DeviceDetails {
    endpointCount?: number;
    volumeContainerCount?: number;
}

// @public
export interface DeviceList {
    value: Device[];
}

// @public
export interface DevicePatch {
    deviceDescription?: string;
}

// @public
export interface DeviceRolloverDetails {
    authorizationEligibility?: AuthorizationEligibility;
    authorizationStatus?: AuthorizationStatus;
    inEligibilityReason?: InEligibilityCategory;
}

// @public
export interface Devices {
    authorizeForServiceEncryptionKeyRollover(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesAuthorizeForServiceEncryptionKeyRolloverOptionalParams): Promise<void>;
    beginConfigure(resourceGroupName: string, managerName: string, parameters: ConfigureDeviceRequest, options?: DevicesConfigureOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginConfigureAndWait(resourceGroupName: string, managerName: string, parameters: ConfigureDeviceRequest, options?: DevicesConfigureOptionalParams): Promise<void>;
    beginDeactivate(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDeactivateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeactivateAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDeactivateOptionalParams): Promise<void>;
    beginDelete(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesDeleteOptionalParams): Promise<void>;
    beginFailover(sourceDeviceName: string, resourceGroupName: string, managerName: string, parameters: FailoverRequest, options?: DevicesFailoverOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginFailoverAndWait(sourceDeviceName: string, resourceGroupName: string, managerName: string, parameters: FailoverRequest, options?: DevicesFailoverOptionalParams): Promise<void>;
    beginInstallUpdates(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesInstallUpdatesOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginInstallUpdatesAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesInstallUpdatesOptionalParams): Promise<void>;
    beginScanForUpdates(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesScanForUpdatesOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginScanForUpdatesAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesScanForUpdatesOptionalParams): Promise<void>;
    get(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesGetOptionalParams): Promise<DevicesGetResponse>;
    getUpdateSummary(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesGetUpdateSummaryOptionalParams): Promise<DevicesGetUpdateSummaryResponse>;
    listByManager(resourceGroupName: string, managerName: string, options?: DevicesListByManagerOptionalParams): PagedAsyncIterableIterator<Device>;
    listFailoverSets(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesListFailoverSetsOptionalParams): PagedAsyncIterableIterator<FailoverSet>;
    listFailoverTargets(sourceDeviceName: string, resourceGroupName: string, managerName: string, parameters: ListFailoverTargetsRequest, options?: DevicesListFailoverTargetsOptionalParams): PagedAsyncIterableIterator<FailoverTarget>;
    listMetricDefinition(deviceName: string, resourceGroupName: string, managerName: string, options?: DevicesListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(deviceName: string, resourceGroupName: string, managerName: string, filter: string, options?: DevicesListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
    update(deviceName: string, resourceGroupName: string, managerName: string, parameters: DevicePatch, options?: DevicesUpdateOptionalParams): Promise<DevicesUpdateResponse>;
}

// @public
export interface DevicesAuthorizeForServiceEncryptionKeyRolloverOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface DevicesConfigureOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesDeactivateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DeviceSettings {
    beginCreateOrUpdateAlertSettings(deviceName: string, resourceGroupName: string, managerName: string, parameters: AlertSettings, options?: DeviceSettingsCreateOrUpdateAlertSettingsOptionalParams): Promise<PollerLike<PollOperationState<DeviceSettingsCreateOrUpdateAlertSettingsResponse>, DeviceSettingsCreateOrUpdateAlertSettingsResponse>>;
    beginCreateOrUpdateAlertSettingsAndWait(deviceName: string, resourceGroupName: string, managerName: string, parameters: AlertSettings, options?: DeviceSettingsCreateOrUpdateAlertSettingsOptionalParams): Promise<DeviceSettingsCreateOrUpdateAlertSettingsResponse>;
    beginCreateOrUpdateTimeSettings(deviceName: string, resourceGroupName: string, managerName: string, parameters: TimeSettings, options?: DeviceSettingsCreateOrUpdateTimeSettingsOptionalParams): Promise<PollerLike<PollOperationState<DeviceSettingsCreateOrUpdateTimeSettingsResponse>, DeviceSettingsCreateOrUpdateTimeSettingsResponse>>;
    beginCreateOrUpdateTimeSettingsAndWait(deviceName: string, resourceGroupName: string, managerName: string, parameters: TimeSettings, options?: DeviceSettingsCreateOrUpdateTimeSettingsOptionalParams): Promise<DeviceSettingsCreateOrUpdateTimeSettingsResponse>;
    beginSyncRemotemanagementCertificate(deviceName: string, resourceGroupName: string, managerName: string, options?: DeviceSettingsSyncRemotemanagementCertificateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginSyncRemotemanagementCertificateAndWait(deviceName: string, resourceGroupName: string, managerName: string, options?: DeviceSettingsSyncRemotemanagementCertificateOptionalParams): Promise<void>;
    beginUpdateNetworkSettings(deviceName: string, resourceGroupName: string, managerName: string, parameters: NetworkSettingsPatch, options?: DeviceSettingsUpdateNetworkSettingsOptionalParams): Promise<PollerLike<PollOperationState<DeviceSettingsUpdateNetworkSettingsResponse>, DeviceSettingsUpdateNetworkSettingsResponse>>;
    beginUpdateNetworkSettingsAndWait(deviceName: string, resourceGroupName: string, managerName: string, parameters: NetworkSettingsPatch, options?: DeviceSettingsUpdateNetworkSettingsOptionalParams): Promise<DeviceSettingsUpdateNetworkSettingsResponse>;
    beginUpdateSecuritySettings(deviceName: string, resourceGroupName: string, managerName: string, parameters: SecuritySettingsPatch, options?: DeviceSettingsUpdateSecuritySettingsOptionalParams): Promise<PollerLike<PollOperationState<DeviceSettingsUpdateSecuritySettingsResponse>, DeviceSettingsUpdateSecuritySettingsResponse>>;
    beginUpdateSecuritySettingsAndWait(deviceName: string, resourceGroupName: string, managerName: string, parameters: SecuritySettingsPatch, options?: DeviceSettingsUpdateSecuritySettingsOptionalParams): Promise<DeviceSettingsUpdateSecuritySettingsResponse>;
    getAlertSettings(deviceName: string, resourceGroupName: string, managerName: string, options?: DeviceSettingsGetAlertSettingsOptionalParams): Promise<DeviceSettingsGetAlertSettingsResponse>;
    getNetworkSettings(deviceName: string, resourceGroupName: string, managerName: string, options?: DeviceSettingsGetNetworkSettingsOptionalParams): Promise<DeviceSettingsGetNetworkSettingsResponse>;
    getSecuritySettings(deviceName: string, resourceGroupName: string, managerName: string, options?: DeviceSettingsGetSecuritySettingsOptionalParams): Promise<DeviceSettingsGetSecuritySettingsResponse>;
    getTimeSettings(deviceName: string, resourceGroupName: string, managerName: string, options?: DeviceSettingsGetTimeSettingsOptionalParams): Promise<DeviceSettingsGetTimeSettingsResponse>;
}

// @public
export interface DeviceSettingsCreateOrUpdateAlertSettingsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DeviceSettingsCreateOrUpdateAlertSettingsResponse = AlertSettings;

// @public
export interface DeviceSettingsCreateOrUpdateTimeSettingsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DeviceSettingsCreateOrUpdateTimeSettingsResponse = TimeSettings;

// @public
export interface DeviceSettingsGetAlertSettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DeviceSettingsGetAlertSettingsResponse = AlertSettings;

// @public
export interface DeviceSettingsGetNetworkSettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DeviceSettingsGetNetworkSettingsResponse = NetworkSettings;

// @public
export interface DeviceSettingsGetSecuritySettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DeviceSettingsGetSecuritySettingsResponse = SecuritySettings;

// @public
export interface DeviceSettingsGetTimeSettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DeviceSettingsGetTimeSettingsResponse = TimeSettings;

// @public
export interface DeviceSettingsSyncRemotemanagementCertificateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DeviceSettingsUpdateNetworkSettingsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DeviceSettingsUpdateNetworkSettingsResponse = NetworkSettings;

// @public
export interface DeviceSettingsUpdateSecuritySettingsOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DeviceSettingsUpdateSecuritySettingsResponse = SecuritySettings;

// @public
export interface DevicesFailoverOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesGetOptionalParams extends coreClient.OperationOptions {
    expand?: string;
}

// @public
export type DevicesGetResponse = Device;

// @public
export interface DevicesGetUpdateSummaryOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesGetUpdateSummaryResponse = Updates;

// @public
export interface DevicesInstallUpdatesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DevicesListByManagerOptionalParams extends coreClient.OperationOptions {
    expand?: string;
}

// @public
export type DevicesListByManagerResponse = DeviceList;

// @public
export interface DevicesListFailoverSetsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesListFailoverSetsResponse = FailoverSetsList;

// @public
export interface DevicesListFailoverTargetsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesListFailoverTargetsResponse = FailoverTargetsList;

// @public
export interface DevicesListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface DevicesListMetricsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesListMetricsResponse = MetricList;

// @public
export interface DevicesScanForUpdatesOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type DeviceStatus = "Unknown" | "Online" | "Offline" | "Deactivated" | "RequiresAttention" | "MaintenanceMode" | "Creating" | "Provisioning" | "Deactivating" | "Deleted" | "ReadyToSetup";

// @public
export interface DevicesUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type DevicesUpdateResponse = Device;

// @public
export type DeviceType = "Invalid" | "Series8000VirtualAppliance" | "Series8000PhysicalAppliance";

// @public
export interface DimensionFilter {
    name?: string;
    values?: string;
}

// @public
export interface DNSSettings {
    primaryDnsServer?: string;
    primaryIpv6DnsServer?: string;
    secondaryDnsServers?: string[];
    secondaryIpv6DnsServers?: string[];
}

// @public
export type EncryptionAlgorithm = "None" | "AES256" | "RSAES_PKCS1_v_1_5";

// @public
export type EncryptionSettings = BaseModel & {
    encryptionStatus: EncryptionStatus;
    keyRolloverStatus: KeyRolloverStatus;
};

// @public
export type EncryptionStatus = "Enabled" | "Disabled";

// @public
export interface FailoverRequest {
    targetDeviceId?: string;
    volumeContainers?: string[];
}

// @public
export interface FailoverSet {
    eligibilityResult?: FailoverSetEligibilityResult;
    volumeContainers?: VolumeContainerFailoverMetadata[];
}

// @public
export interface FailoverSetEligibilityResult {
    errorMessage?: string;
    isEligibleForFailover?: boolean;
}

// @public
export interface FailoverSetsList {
    value?: FailoverSet[];
}

// @public
export interface FailoverTarget {
    availableLocalStorageInBytes?: number;
    availableTieredStorageInBytes?: number;
    dataContainersCount?: number;
    deviceId?: string;
    deviceLocation?: string;
    deviceSoftwareVersion?: string;
    deviceStatus?: DeviceStatus;
    eligibilityResult?: TargetEligibilityResult;
    friendlyDeviceSoftwareVersion?: string;
    modelDescription?: string;
    volumesCount?: number;
}

// @public
export interface FailoverTargetsList {
    value?: FailoverTarget[];
}

// @public
export interface Feature {
    name: string;
    status: FeatureSupportStatus;
}

// @public
export interface FeatureFilter {
    deviceId?: string;
}

// @public
export interface FeatureList {
    value: Feature[];
}

// @public
export type FeatureSupportStatus = "NotAvailable" | "UnsupportedDeviceVersion" | "Supported";

// @public
export interface HardwareComponent {
    componentId: string;
    displayName: string;
    status: HardwareComponentStatus;
    statusDisplayName: string;
}

// @public
export type HardwareComponentGroup = BaseModel & {
    displayName: string;
    lastUpdatedTime: Date;
    components: HardwareComponent[];
};

// @public
export interface HardwareComponentGroupList {
    value: HardwareComponentGroup[];
}

// @public
export interface HardwareComponentGroups {
    beginChangeControllerPowerState(deviceName: string, hardwareComponentGroupName: string, resourceGroupName: string, managerName: string, parameters: ControllerPowerStateChangeRequest, options?: HardwareComponentGroupsChangeControllerPowerStateOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginChangeControllerPowerStateAndWait(deviceName: string, hardwareComponentGroupName: string, resourceGroupName: string, managerName: string, parameters: ControllerPowerStateChangeRequest, options?: HardwareComponentGroupsChangeControllerPowerStateOptionalParams): Promise<void>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: HardwareComponentGroupsListByDeviceOptionalParams): PagedAsyncIterableIterator<HardwareComponentGroup>;
}

// @public
export interface HardwareComponentGroupsChangeControllerPowerStateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface HardwareComponentGroupsListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type HardwareComponentGroupsListByDeviceResponse = HardwareComponentGroupList;

// @public
export type HardwareComponentStatus = "Unknown" | "NotPresent" | "PoweredOff" | "Ok" | "Recovering" | "Warning" | "Failure";

// @public
export type InEligibilityCategory = "DeviceNotOnline" | "NotSupportedAppliance" | "RolloverPending";

// @public
export type IscsiAndCloudStatus = "Disabled" | "IscsiEnabled" | "CloudEnabled" | "IscsiAndCloudEnabled";

// @public
export type Job = BaseModel & {
    status: JobStatus;
    startTime?: Date;
    endTime?: Date;
    percentComplete: number;
    error?: JobErrorDetails;
    jobType?: JobType;
    dataStats?: DataStatistics;
    entityLabel?: string;
    entityType?: string;
    jobStages?: JobStage[];
    deviceId?: string;
    isCancellable?: boolean;
    backupType?: BackupType;
    sourceDeviceId?: string;
    backupPointInTime?: Date;
};

// @public
export interface JobErrorDetails {
    code: string;
    errorDetails?: JobErrorItem[];
    message: string;
}

// @public
export interface JobErrorItem {
    code: string;
    message: string;
    recommendations?: string[];
}

// @public
export interface JobFilter {
    jobType?: string;
    startTime?: Date;
    status?: string;
}

// @public
export interface JobList {
    nextLink?: string;
    value: Job[];
}

// @public
export interface Jobs {
    beginCancel(deviceName: string, jobName: string, resourceGroupName: string, managerName: string, options?: JobsCancelOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginCancelAndWait(deviceName: string, jobName: string, resourceGroupName: string, managerName: string, options?: JobsCancelOptionalParams): Promise<void>;
    get(deviceName: string, jobName: string, resourceGroupName: string, managerName: string, options?: JobsGetOptionalParams): Promise<JobsGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: JobsListByDeviceOptionalParams): PagedAsyncIterableIterator<Job>;
    listByManager(resourceGroupName: string, managerName: string, options?: JobsListByManagerOptionalParams): PagedAsyncIterableIterator<Job>;
}

// @public
export interface JobsCancelOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface JobsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type JobsGetResponse = Job;

// @public
export interface JobsListByDeviceNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type JobsListByDeviceNextResponse = JobList;

// @public
export interface JobsListByDeviceOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type JobsListByDeviceResponse = JobList;

// @public
export interface JobsListByManagerNextOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type JobsListByManagerNextResponse = JobList;

// @public
export interface JobsListByManagerOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type JobsListByManagerResponse = JobList;

// @public
export interface JobStage {
    detail?: string;
    errorCode?: string;
    message?: string;
    stageStatus: JobStatus;
}

// @public
export type JobStatus = "Running" | "Succeeded" | "Failed" | "Canceled";

// @public
export type JobType = "ScheduledBackup" | "ManualBackup" | "RestoreBackup" | "CloneVolume" | "FailoverVolumeContainers" | "CreateLocallyPinnedVolume" | "ModifyVolume" | "InstallUpdates" | "SupportPackageLogs" | "CreateCloudAppliance";

// @public
export interface Key {
    activationKey: string;
}

// @public
export type KeyRolloverStatus = "Required" | "NotRequired";

// @public
export interface ListFailoverTargetsRequest {
    volumeContainers?: string[];
}

// @public
export type Manager = Resource & {
    etag?: string;
    cisIntrinsicSettings?: ManagerIntrinsicSettings;
    sku?: ManagerSku;
    provisioningState?: string;
};

// @public
export type ManagerExtendedInfo = BaseModel & {
    etag?: string;
    version?: string;
    integrityKey?: string;
    encryptionKey?: string;
    encryptionKeyThumbprint?: string;
    portalCertificateThumbprint?: string;
    algorithm?: string;
};

// @public
export interface ManagerIntrinsicSettings {
    type: ManagerType;
}

// @public
export interface ManagerList {
    value: Manager[];
}

// @public
export interface ManagerPatch {
    tags?: {
        [propertyName: string]: string;
    };
}

// @public
export interface Managers {
    createExtendedInfo(resourceGroupName: string, managerName: string, parameters: ManagerExtendedInfo, options?: ManagersCreateExtendedInfoOptionalParams): Promise<ManagersCreateExtendedInfoResponse>;
    createOrUpdate(resourceGroupName: string, managerName: string, parameters: Manager, options?: ManagersCreateOrUpdateOptionalParams): Promise<ManagersCreateOrUpdateResponse>;
    delete(resourceGroupName: string, managerName: string, options?: ManagersDeleteOptionalParams): Promise<void>;
    deleteExtendedInfo(resourceGroupName: string, managerName: string, options?: ManagersDeleteExtendedInfoOptionalParams): Promise<void>;
    get(resourceGroupName: string, managerName: string, options?: ManagersGetOptionalParams): Promise<ManagersGetResponse>;
    getActivationKey(resourceGroupName: string, managerName: string, options?: ManagersGetActivationKeyOptionalParams): Promise<ManagersGetActivationKeyResponse>;
    getDevicePublicEncryptionKey(deviceName: string, resourceGroupName: string, managerName: string, options?: ManagersGetDevicePublicEncryptionKeyOptionalParams): Promise<ManagersGetDevicePublicEncryptionKeyResponse>;
    getEncryptionSettings(resourceGroupName: string, managerName: string, options?: ManagersGetEncryptionSettingsOptionalParams): Promise<ManagersGetEncryptionSettingsResponse>;
    getExtendedInfo(resourceGroupName: string, managerName: string, options?: ManagersGetExtendedInfoOptionalParams): Promise<ManagersGetExtendedInfoResponse>;
    getPublicEncryptionKey(resourceGroupName: string, managerName: string, options?: ManagersGetPublicEncryptionKeyOptionalParams): Promise<ManagersGetPublicEncryptionKeyResponse>;
    list(options?: ManagersListOptionalParams): PagedAsyncIterableIterator<Manager>;
    listByResourceGroup(resourceGroupName: string, options?: ManagersListByResourceGroupOptionalParams): PagedAsyncIterableIterator<Manager>;
    listFeatureSupportStatus(resourceGroupName: string, managerName: string, options?: ManagersListFeatureSupportStatusOptionalParams): PagedAsyncIterableIterator<Feature>;
    listMetricDefinition(resourceGroupName: string, managerName: string, options?: ManagersListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(resourceGroupName: string, managerName: string, filter: string, options?: ManagersListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
    regenerateActivationKey(resourceGroupName: string, managerName: string, options?: ManagersRegenerateActivationKeyOptionalParams): Promise<ManagersRegenerateActivationKeyResponse>;
    update(resourceGroupName: string, managerName: string, parameters: ManagerPatch, options?: ManagersUpdateOptionalParams): Promise<ManagersUpdateResponse>;
    updateExtendedInfo(resourceGroupName: string, managerName: string, ifMatch: string, parameters: ManagerExtendedInfo, options?: ManagersUpdateExtendedInfoOptionalParams): Promise<ManagersUpdateExtendedInfoResponse>;
}

// @public
export interface ManagersCreateExtendedInfoOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersCreateExtendedInfoResponse = ManagerExtendedInfo;

// @public
export interface ManagersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersCreateOrUpdateResponse = Manager;

// @public
export interface ManagersDeleteExtendedInfoOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagersDeleteOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagersGetActivationKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetActivationKeyResponse = Key;

// @public
export interface ManagersGetDevicePublicEncryptionKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetDevicePublicEncryptionKeyResponse = PublicKey;

// @public
export interface ManagersGetEncryptionSettingsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetEncryptionSettingsResponse = EncryptionSettings;

// @public
export interface ManagersGetExtendedInfoOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetExtendedInfoResponse = ManagerExtendedInfo;

// @public
export interface ManagersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export interface ManagersGetPublicEncryptionKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersGetPublicEncryptionKeyResponse = SymmetricEncryptedSecret;

// @public
export type ManagersGetResponse = Manager;

// @public
export interface ManagerSku {
    name: "Standard";
}

// @public
export interface ManagersListByResourceGroupOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersListByResourceGroupResponse = ManagerList;

// @public
export interface ManagersListFeatureSupportStatusOptionalParams extends coreClient.OperationOptions {
    filter?: string;
}

// @public
export type ManagersListFeatureSupportStatusResponse = FeatureList;

// @public
export interface ManagersListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface ManagersListMetricsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersListMetricsResponse = MetricList;

// @public
export interface ManagersListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersListResponse = ManagerList;

// @public
export interface ManagersRegenerateActivationKeyOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersRegenerateActivationKeyResponse = Key;

// @public
export interface ManagersUpdateExtendedInfoOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersUpdateExtendedInfoResponse = ManagerExtendedInfo;

// @public
export interface ManagersUpdateOptionalParams extends coreClient.OperationOptions {
}

// @public
export type ManagersUpdateResponse = Manager;

// @public
export type ManagerType = "GardaV1" | "HelsinkiV1";

// @public
export type MetricAggregationType = "Average" | "Last" | "Maximum" | "Minimum" | "None" | "Total";

// @public
export interface MetricAvailablity {
    retention?: string;
    timeGrain?: string;
}

// @public
export interface MetricData {
    average?: number;
    count?: number;
    maximum?: number;
    minimum?: number;
    sum?: number;
    timeStamp?: Date;
}

// @public
export interface MetricDefinition {
    category?: string;
    dimensions?: MetricDimension[];
    metricAvailabilities?: MetricAvailablity[];
    name?: MetricName;
    primaryAggregationType?: MetricAggregationType;
    resourceId?: string;
    type?: string;
    unit?: MetricUnit;
}

// @public
export interface MetricDefinitionList {
    value?: MetricDefinition[];
}

// @public
export interface MetricDimension {
    name?: string;
    value?: string;
}

// @public
export interface MetricFilter {
    category: string;
    dimensions?: DimensionFilter;
    endTime?: Date;
    name?: MetricNameFilter;
    startTime?: Date;
    timeGrain?: string;
}

// @public
export interface MetricList {
    value?: Metrics[];
}

// @public
export interface MetricName {
    localizedValue?: string;
    value?: string;
}

// @public
export interface MetricNameFilter {
    value?: string;
}

// @public
export interface Metrics {
    dimensions?: MetricDimension[];
    endTime?: Date;
    name?: MetricName;
    primaryAggregation?: MetricAggregationType;
    resourceId?: string;
    startTime?: Date;
    timeGrain?: string;
    type?: string;
    unit?: MetricUnit;
    values?: MetricData[];
}

// @public
export type MetricUnit = "Bytes" | "BytesPerSecond" | "Count" | "CountPerSecond" | "Percent" | "Seconds";

// @public
export type MonitoringStatus = "Enabled" | "Disabled";

// @public
export type NetInterfaceId = "Invalid" | "Data0" | "Data1" | "Data2" | "Data3" | "Data4" | "Data5";

// @public
export type NetInterfaceStatus = "Enabled" | "Disabled";

// @public
export interface NetworkAdapterList {
    value: NetworkAdapters[];
}

// @public
export interface NetworkAdapters {
    interfaceId: NetInterfaceId;
    iscsiAndCloudStatus: IscsiAndCloudStatus;
    isDefault?: boolean;
    mode: NetworkMode;
    netInterfaceStatus: NetInterfaceStatus;
    nicIpv4Settings?: NicIPv4;
    nicIpv6Settings?: NicIPv6;
    speed?: number;
}

// @public
export interface NetworkInterfaceData0Settings {
    controllerOneIp?: string;
    controllerZeroIp?: string;
}

// @public
export type NetworkMode = "Invalid" | "IPV4" | "IPV6" | "BOTH";

// @public
export type NetworkSettings = BaseModel & {
    dnsSettings: DNSSettings;
    networkAdapters: NetworkAdapterList;
    webproxySettings: WebproxySettings;
};

// @public
export interface NetworkSettingsPatch {
    dnsSettings?: DNSSettings;
    networkAdapters?: NetworkAdapterList;
}

// @public
export interface NicIPv4 {
    controller0Ipv4Address?: string;
    controller1Ipv4Address?: string;
    ipv4Address?: string;
    ipv4Gateway?: string;
    ipv4Netmask?: string;
}

// @public
export interface NicIPv6 {
    controller0Ipv6Address?: string;
    controller1Ipv6Address?: string;
    ipv6Address?: string;
    ipv6Gateway?: string;
    ipv6Prefix?: string;
}

// @public
export interface Operations {
    list(options?: OperationsListOptionalParams): PagedAsyncIterableIterator<AvailableProviderOperation>;
}

// @public
export interface OperationsListNextOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListNextResponse = AvailableProviderOperationList;

// @public
export interface OperationsListOptionalParams extends coreClient.OperationOptions {
}

// @public
export type OperationsListResponse = AvailableProviderOperationList;

// @public
export type OperationStatus = "None" | "Updating" | "Deleting" | "Restoring";

// @public
export type OwnerShipStatus = "Owned" | "NotOwned";

// @public
export interface PublicKey {
    key: string;
}

// @public
export type RecurrenceType = "Minutes" | "Hourly" | "Daily" | "Weekly";

// @public
export type RemoteManagementModeConfiguration = "Unknown" | "Disabled" | "HttpsEnabled" | "HttpsAndHttpEnabled";

// @public
export interface RemoteManagementSettings {
    remoteManagementCertificate?: string;
    remoteManagementMode: RemoteManagementModeConfiguration;
}

// @public
export interface RemoteManagementSettingsPatch {
    remoteManagementMode: RemoteManagementModeConfiguration;
}

// @public
export interface Resource {
    readonly id?: string;
    location: string;
    readonly name?: string;
    tags?: {
        [propertyName: string]: string;
    };
    readonly type?: string;
}

// @public
export type ScheduledBackupStatus = "Disabled" | "Enabled";

// @public
export interface ScheduleRecurrence {
    recurrenceType: RecurrenceType;
    recurrenceValue: number;
    weeklyDaysList?: DayOfWeek[];
}

// @public
export type ScheduleStatus = "Enabled" | "Disabled";

// @public
export interface SecondaryDNSSettings {
    secondaryDnsServers?: string[];
}

// @public
export type SecuritySettings = BaseModel & {
    remoteManagementSettings: RemoteManagementSettings;
    chapSettings: ChapSettings;
};

// @public
export interface SecuritySettingsPatch {
    chapSettings?: ChapSettings;
    cloudApplianceSettings?: CloudApplianceSettings;
    deviceAdminPassword?: AsymmetricEncryptedSecret;
    remoteManagementSettings?: RemoteManagementSettingsPatch;
    snapshotPassword?: AsymmetricEncryptedSecret;
}

// @public
export interface SendTestAlertEmailRequest {
    emailList: string[];
}

// @public
export type SslStatus = "Enabled" | "Disabled";

// @public
export type StorageAccountCredential = BaseModel & {
    endPoint: string;
    sslStatus: SslStatus;
    accessKey?: AsymmetricEncryptedSecret;
    readonly volumesCount?: number;
};

// @public
export interface StorageAccountCredentialList {
    value: StorageAccountCredential[];
}

// @public
export interface StorageAccountCredentials {
    beginCreateOrUpdate(storageAccountCredentialName: string, resourceGroupName: string, managerName: string, parameters: StorageAccountCredential, options?: StorageAccountCredentialsCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<StorageAccountCredentialsCreateOrUpdateResponse>, StorageAccountCredentialsCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(storageAccountCredentialName: string, resourceGroupName: string, managerName: string, parameters: StorageAccountCredential, options?: StorageAccountCredentialsCreateOrUpdateOptionalParams): Promise<StorageAccountCredentialsCreateOrUpdateResponse>;
    beginDelete(storageAccountCredentialName: string, resourceGroupName: string, managerName: string, options?: StorageAccountCredentialsDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(storageAccountCredentialName: string, resourceGroupName: string, managerName: string, options?: StorageAccountCredentialsDeleteOptionalParams): Promise<void>;
    get(storageAccountCredentialName: string, resourceGroupName: string, managerName: string, options?: StorageAccountCredentialsGetOptionalParams): Promise<StorageAccountCredentialsGetResponse>;
    listByManager(resourceGroupName: string, managerName: string, options?: StorageAccountCredentialsListByManagerOptionalParams): PagedAsyncIterableIterator<StorageAccountCredential>;
}

// @public
export interface StorageAccountCredentialsCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type StorageAccountCredentialsCreateOrUpdateResponse = StorageAccountCredential;

// @public
export interface StorageAccountCredentialsDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface StorageAccountCredentialsGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountCredentialsGetResponse = StorageAccountCredential;

// @public
export interface StorageAccountCredentialsListByManagerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type StorageAccountCredentialsListByManagerResponse = StorageAccountCredentialList;

// @public (undocumented)
export class StorSimple8000SeriesManagementClient extends coreClient.ServiceClient {
    // (undocumented)
    $host: string;
    constructor(credentials: coreAuth.TokenCredential, subscriptionId: string, options?: StorSimple8000SeriesManagementClientOptionalParams);
    // (undocumented)
    accessControlRecords: AccessControlRecords;
    // (undocumented)
    alerts: Alerts;
    // (undocumented)
    apiVersion: string;
    // (undocumented)
    backupPolicies: BackupPolicies;
    // (undocumented)
    backups: Backups;
    // (undocumented)
    backupSchedules: BackupSchedules;
    // (undocumented)
    bandwidthSettings: BandwidthSettings;
    // (undocumented)
    cloudAppliances: CloudAppliances;
    // (undocumented)
    devices: Devices;
    // (undocumented)
    deviceSettings: DeviceSettings;
    // (undocumented)
    hardwareComponentGroups: HardwareComponentGroups;
    // (undocumented)
    jobs: Jobs;
    // (undocumented)
    managers: Managers;
    // (undocumented)
    operations: Operations;
    // (undocumented)
    storageAccountCredentials: StorageAccountCredentials;
    // (undocumented)
    subscriptionId: string;
    // (undocumented)
    volumeContainers: VolumeContainers;
    // (undocumented)
    volumes: Volumes;
}

// @public
export interface StorSimple8000SeriesManagementClientOptionalParams extends coreClient.ServiceClientOptions {
    $host?: string;
    apiVersion?: string;
    endpoint?: string;
}

// @public
export interface SymmetricEncryptedSecret {
    encryptionAlgorithm: EncryptionAlgorithm;
    value: string;
    valueCertificateThumbprint?: string;
}

// @public
export interface TargetEligibilityErrorMessage {
    message?: string;
    resolution?: string;
    resultCode?: TargetEligibilityResultCode;
}

// @public
export interface TargetEligibilityResult {
    eligibilityStatus?: TargetEligibilityStatus;
    messages?: TargetEligibilityErrorMessage[];
}

// @public
export type TargetEligibilityResultCode = "TargetAndSourceCannotBeSameError" | "TargetIsNotOnlineError" | "TargetSourceIncompatibleVersionError" | "LocalToTieredVolumesConversionWarning" | "TargetInsufficientCapacityError" | "TargetInsufficientLocalVolumeMemoryError" | "TargetInsufficientTieredVolumeMemoryError";

// @public
export type TargetEligibilityStatus = "NotEligible" | "Eligible";

// @public
export interface Time {
    hours: number;
    minutes: number;
    seconds: number;
}

// @public
export type TimeSettings = BaseModel & {
    timeZone: string;
    primaryTimeServer?: string;
    secondaryTimeServer?: string[];
};

// @public
export type Updates = BaseModel & {
    regularUpdatesAvailable?: boolean;
    maintenanceModeUpdatesAvailable?: boolean;
    isUpdateInProgress?: boolean;
    lastUpdatedTime?: Date;
};

// @public
export type VirtualMachineApiType = "Classic" | "Arm";

// @public
export interface VmImage {
    name: string;
    offer: string;
    publisher: string;
    sku: string;
    version: string;
}

// @public
export type Volume = BaseModel & {
    sizeInBytes: number;
    volumeType: VolumeType;
    readonly volumeContainerId?: string;
    accessControlRecordIds: string[];
    volumeStatus: VolumeStatus;
    readonly operationStatus?: OperationStatus;
    readonly backupStatus?: BackupStatus;
    monitoringStatus: MonitoringStatus;
    readonly backupPolicyIds?: string[];
};

// @public
export type VolumeContainer = BaseModel & {
    encryptionKey?: AsymmetricEncryptedSecret;
    readonly encryptionStatus?: EncryptionStatus;
    readonly volumeCount?: number;
    storageAccountCredentialId: string;
    readonly ownerShipStatus?: OwnerShipStatus;
    bandWidthRateInMbps?: number;
    bandwidthSettingId?: string;
    readonly totalCloudStorageUsageInBytes?: number;
};

// @public
export interface VolumeContainerFailoverMetadata {
    volumeContainerId?: string;
    volumes?: VolumeFailoverMetadata[];
}

// @public
export interface VolumeContainerList {
    value: VolumeContainer[];
}

// @public
export interface VolumeContainers {
    beginCreateOrUpdate(deviceName: string, volumeContainerName: string, resourceGroupName: string, managerName: string, parameters: VolumeContainer, options?: VolumeContainersCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<VolumeContainersCreateOrUpdateResponse>, VolumeContainersCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, volumeContainerName: string, resourceGroupName: string, managerName: string, parameters: VolumeContainer, options?: VolumeContainersCreateOrUpdateOptionalParams): Promise<VolumeContainersCreateOrUpdateResponse>;
    beginDelete(deviceName: string, volumeContainerName: string, resourceGroupName: string, managerName: string, options?: VolumeContainersDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, volumeContainerName: string, resourceGroupName: string, managerName: string, options?: VolumeContainersDeleteOptionalParams): Promise<void>;
    get(deviceName: string, volumeContainerName: string, resourceGroupName: string, managerName: string, options?: VolumeContainersGetOptionalParams): Promise<VolumeContainersGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: VolumeContainersListByDeviceOptionalParams): PagedAsyncIterableIterator<VolumeContainer>;
    listMetricDefinition(deviceName: string, volumeContainerName: string, resourceGroupName: string, managerName: string, options?: VolumeContainersListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(deviceName: string, volumeContainerName: string, resourceGroupName: string, managerName: string, filter: string, options?: VolumeContainersListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
}

// @public
export interface VolumeContainersCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumeContainersCreateOrUpdateResponse = VolumeContainer;

// @public
export interface VolumeContainersDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumeContainersGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumeContainersGetResponse = VolumeContainer;

// @public
export interface VolumeContainersListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumeContainersListByDeviceResponse = VolumeContainerList;

// @public
export interface VolumeContainersListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumeContainersListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface VolumeContainersListMetricsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumeContainersListMetricsResponse = MetricList;

// @public
export interface VolumeFailoverMetadata {
    backupCreatedDate?: Date;
    backupElementId?: string;
    backupId?: string;
    backupPolicyId?: string;
    sizeInBytes?: number;
    volumeId?: string;
    volumeType?: VolumeType;
}

// @public
export interface VolumeList {
    value: Volume[];
}

// @public
export interface Volumes {
    beginCreateOrUpdate(deviceName: string, volumeContainerName: string, volumeName: string, resourceGroupName: string, managerName: string, parameters: Volume, options?: VolumesCreateOrUpdateOptionalParams): Promise<PollerLike<PollOperationState<VolumesCreateOrUpdateResponse>, VolumesCreateOrUpdateResponse>>;
    beginCreateOrUpdateAndWait(deviceName: string, volumeContainerName: string, volumeName: string, resourceGroupName: string, managerName: string, parameters: Volume, options?: VolumesCreateOrUpdateOptionalParams): Promise<VolumesCreateOrUpdateResponse>;
    beginDelete(deviceName: string, volumeContainerName: string, volumeName: string, resourceGroupName: string, managerName: string, options?: VolumesDeleteOptionalParams): Promise<PollerLike<PollOperationState<void>, void>>;
    beginDeleteAndWait(deviceName: string, volumeContainerName: string, volumeName: string, resourceGroupName: string, managerName: string, options?: VolumesDeleteOptionalParams): Promise<void>;
    get(deviceName: string, volumeContainerName: string, volumeName: string, resourceGroupName: string, managerName: string, options?: VolumesGetOptionalParams): Promise<VolumesGetResponse>;
    listByDevice(deviceName: string, resourceGroupName: string, managerName: string, options?: VolumesListByDeviceOptionalParams): PagedAsyncIterableIterator<Volume>;
    listByVolumeContainer(deviceName: string, volumeContainerName: string, resourceGroupName: string, managerName: string, options?: VolumesListByVolumeContainerOptionalParams): PagedAsyncIterableIterator<Volume>;
    listMetricDefinition(deviceName: string, volumeContainerName: string, volumeName: string, resourceGroupName: string, managerName: string, options?: VolumesListMetricDefinitionOptionalParams): PagedAsyncIterableIterator<MetricDefinition>;
    listMetrics(deviceName: string, volumeContainerName: string, volumeName: string, resourceGroupName: string, managerName: string, filter: string, options?: VolumesListMetricsOptionalParams): PagedAsyncIterableIterator<Metrics>;
}

// @public
export interface VolumesCreateOrUpdateOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export type VolumesCreateOrUpdateResponse = Volume;

// @public
export interface VolumesDeleteOptionalParams extends coreClient.OperationOptions {
    resumeFrom?: string;
    updateIntervalInMs?: number;
}

// @public
export interface VolumesGetOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesGetResponse = Volume;

// @public
export interface VolumesListByDeviceOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListByDeviceResponse = VolumeList;

// @public
export interface VolumesListByVolumeContainerOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListByVolumeContainerResponse = VolumeList;

// @public
export interface VolumesListMetricDefinitionOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListMetricDefinitionResponse = MetricDefinitionList;

// @public
export interface VolumesListMetricsOptionalParams extends coreClient.OperationOptions {
}

// @public
export type VolumesListMetricsResponse = MetricList;

// @public
export type VolumeStatus = "Online" | "Offline";

// @public
export type VolumeType = "Tiered" | "Archival" | "LocallyPinned";

// @public
export interface WebproxySettings {
    authentication: AuthenticationType;
    connectionUri?: string;
    username: string;
}

// (No @packageDocumentation comment for this package)

```
