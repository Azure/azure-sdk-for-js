## API Report File for "@azure-rest/ai-content-understanding"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { ClientOptions } from '@azure-rest/core-client';
import { ErrorModel } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure-rest/core-client';
import { OperationState as OperationState_2 } from '@azure/core-lro';
import { PathUncheckedResponse } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AnalyzeBinaryOptionalParams extends OperationOptions {
    clientRequestId?: string;
    inputRange?: string;
    processingLocation?: ProcessingLocation;
    stringEncoding?: string;
    updateIntervalInMs?: number;
}

// @public
export interface AnalyzeInput {
    data?: Uint8Array;
    inputRange?: string;
    mimeType?: string;
    name?: string;
    url?: string;
}

// @public
export interface AnalyzeOptionalParams extends OperationOptions {
    clientRequestId?: string;
    inputs?: AnalyzeInput[];
    modelDeployments?: Record<string, string>;
    processingLocation?: ProcessingLocation;
    stringEncoding?: string;
    updateIntervalInMs?: number;
}

// @public
export interface AnalyzeResult {
    analyzerId?: string;
    apiVersion?: string;
    contents: MediaContentUnion[];
    createdAt?: Date;
    stringEncoding?: string;
    warnings?: ErrorModel[];
}

// @public
export type AnnotationFormat = "none" | "markdown";

// @public
export interface ArrayField extends ContentField {
    fieldType: "array";
    valueArray?: ContentFieldUnion[];
}

// @public
export interface AudioVisualContent extends MediaContent {
    cameraShotTimesMs?: number[];
    endTimeMs: number;
    height?: number;
    keyFrameTimesMs?: number[];
    kind: "audioVisual";
    segments?: AudioVisualContentSegment[];
    startTimeMs: number;
    transcriptPhrases?: TranscriptPhrase[];
    width?: number;
}

// @public
export interface AudioVisualContentSegment {
    category: string;
    endTimeMs: number;
    segmentId: string;
    span: ContentSpan;
    startTimeMs: number;
}

// @public
export interface BooleanField extends ContentField {
    fieldType: "boolean";
    valueBoolean?: boolean;
}

// @public
export type ChartFormat = "chartJs" | "markdown";

// @public
export interface ContentAnalyzer {
    readonly analyzerId: string;
    baseAnalyzerId?: string;
    config?: ContentAnalyzerConfig;
    readonly createdAt: Date;
    description?: string;
    dynamicFieldSchema?: boolean;
    fieldSchema?: ContentFieldSchema;
    knowledgeSources?: KnowledgeSourceUnion[];
    readonly lastModifiedAt: Date;
    models?: Record<string, string>;
    processingLocation?: ProcessingLocation;
    readonly status: ContentAnalyzerStatus;
    readonly supportedModels?: SupportedModels;
    tags?: Record<string, string>;
    readonly warnings?: ErrorModel[];
}

// @public
export interface ContentAnalyzerAnalyzeOperationStatus {
    error?: ErrorModel;
    id: string;
    result?: AnalyzeResult;
    status: OperationState;
    usage?: UsageDetails;
}

// @public
export interface ContentAnalyzerConfig {
    annotationFormat?: AnnotationFormat;
    chartFormat?: ChartFormat;
    contentCategories?: Record<string, ContentCategoryDefinition>;
    disableFaceBlurring?: boolean;
    enableFigureAnalysis?: boolean;
    enableFigureDescription?: boolean;
    enableFormula?: boolean;
    enableLayout?: boolean;
    enableOcr?: boolean;
    enableSegment?: boolean;
    estimateFieldSourceAndConfidence?: boolean;
    locales?: string[];
    omitContent?: boolean;
    returnDetails?: boolean;
    segmentPerPage?: boolean;
    tableFormat?: TableFormat;
}

// @public
export interface ContentAnalyzerOperationStatus {
    error?: ErrorModel;
    id: string;
    result?: ContentAnalyzer;
    status: OperationState;
    usage?: UsageDetails;
}

// @public
export type ContentAnalyzerStatus = "creating" | "ready" | "deleting" | "failed";

// @public
export interface ContentCategoryDefinition {
    analyzer?: ContentAnalyzer;
    analyzerId?: string;
    description?: string;
}

// @public
export interface ContentField {
    confidence?: number;
    source?: string;
    spans?: ContentSpan[];
    type: ContentFieldType;
}

// @public
export interface ContentFieldDefinition {
    description?: string;
    enum?: string[];
    enumDescriptions?: Record<string, string>;
    estimateSourceAndConfidence?: boolean;
    examples?: string[];
    itemDefinition?: ContentFieldDefinition;
    method?: GenerationMethod;
    properties?: Record<string, ContentFieldDefinition>;
    ref?: string;
    type?: ContentFieldType;
}

// @public
export interface ContentFieldSchema {
    definitions?: Record<string, ContentFieldDefinition>;
    description?: string;
    fields: Record<string, ContentFieldDefinition>;
    name?: string;
}

// @public
export type ContentFieldType = "string" | "date" | "time" | "number" | "integer" | "boolean" | "array" | "object" | "json";

// @public
export type ContentFieldUnion = StringField | DateField | TimeField | NumberField | IntegerField | BooleanField | ArrayField | ObjectField | JsonField | ContentField;

// @public
export interface ContentSpan {
    length: number;
    offset: number;
}

// @public (undocumented)
export class ContentUnderstandingClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: ContentUnderstandingClientOptionalParams);
    analyze(analyzerId: string, options?: AnalyzeOptionalParams): PollerLike<OperationState_2<AnalyzeResult>, AnalyzeResult>;
    analyzeBinary(analyzerId: string, contentType: string, binaryInput: Uint8Array, options?: AnalyzeBinaryOptionalParams): PollerLike<OperationState_2<AnalyzeResult>, AnalyzeResult>;
    copyAnalyzer(analyzerId: string, sourceAnalyzerId: string, options?: CopyAnalyzerOptionalParams): PollerLike<OperationState_2<ContentAnalyzer>, ContentAnalyzer>;
    createAnalyzer(analyzerId: string, resource: ContentAnalyzer, options?: CreateAnalyzerOptionalParams): PollerLike<OperationState_2<ContentAnalyzer>, ContentAnalyzer>;
    deleteAnalyzer(analyzerId: string, options?: DeleteAnalyzerOptionalParams): Promise<void>;
    deleteResult(operationId: string, options?: DeleteResultOptionalParams): Promise<void>;
    getAnalyzer(analyzerId: string, options?: GetAnalyzerOptionalParams): Promise<ContentAnalyzer>;
    getDefaults(options?: GetDefaultsOptionalParams): Promise<ContentUnderstandingDefaults>;
    getOperationStatus(analyzerId: string, operationId: string, options?: GetOperationStatusOptionalParams): Promise<ContentAnalyzerOperationStatus>;
    getResult(operationId: string, options?: GetResultOptionalParams): Promise<ContentAnalyzerAnalyzeOperationStatus>;
    getResultFile(operationId: string, path: string, options?: GetResultFileOptionalParams): Promise<Uint8Array>;
    grantCopyAuthorization(analyzerId: string, targetAzureResourceId: string, options?: GrantCopyAuthorizationOptionalParams): Promise<CopyAuthorization>;
    listAnalyzers(options?: ListAnalyzersOptionalParams): PagedAsyncIterableIterator<ContentAnalyzer>;
    readonly pipeline: Pipeline;
    updateAnalyzer(analyzerId: string, resource: ContentAnalyzer, options?: UpdateAnalyzerOptionalParams): Promise<ContentAnalyzer>;
    updateDefaults(options?: UpdateDefaultsOptionalParams): Promise<ContentUnderstandingDefaults>;
}

// @public
export interface ContentUnderstandingClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface ContentUnderstandingDefaults {
    modelDeployments: Record<string, string>;
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CopyAnalyzerOptionalParams extends OperationOptions {
    allowReplace?: boolean;
    clientRequestId?: string;
    sourceAzureResourceId?: string;
    sourceRegion?: string;
    updateIntervalInMs?: number;
}

// @public
export interface CopyAuthorization {
    expiresAt: Date;
    source: string;
    targetAzureResourceId: string;
}

// @public
export interface CreateAnalyzerOptionalParams extends OperationOptions {
    allowReplace?: boolean;
    clientRequestId?: string;
    updateIntervalInMs?: number;
}

// @public
export interface DateField extends ContentField {
    fieldType: "date";
    valueDate?: string;
}

// @public
export interface DeleteAnalyzerOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface DeleteResultOptionalParams extends OperationOptions {
}

// @public
export interface DocumentAnnotation {
    author?: string;
    comments?: DocumentAnnotationComment[];
    createdAt?: Date;
    id: string;
    kind: DocumentAnnotationKind;
    lastModifiedAt?: Date;
    source?: string;
    spans?: ContentSpan[];
    tags?: string[];
}

// @public
export interface DocumentAnnotationComment {
    author?: string;
    createdAt?: Date;
    lastModifiedAt?: Date;
    message: string;
    tags?: string[];
}

// @public
export type DocumentAnnotationKind = "highlight" | "strikethrough" | "underline" | "italic" | "bold" | "circle" | "note";

// @public
export interface DocumentBarcode {
    confidence?: number;
    kind: DocumentBarcodeKind;
    source?: string;
    span?: ContentSpan;
    value: string;
}

// @public
export type DocumentBarcodeKind = "QRCode" | "PDF417" | "UPCA" | "UPCE" | "Code39" | "Code128" | "EAN8" | "EAN13" | "DataBar" | "Code93" | "Codabar" | "DataBarExpanded" | "ITF" | "MicroQRCode" | "Aztec" | "DataMatrix" | "MaxiCode";

// @public
export interface DocumentCaption {
    content: string;
    elements?: string[];
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentChartFigure extends DocumentFigure {
    content: Record<string, any>;
    kind: "chart";
}

// @public
export interface DocumentContent extends MediaContent {
    annotations?: DocumentAnnotation[];
    endPageNumber: number;
    figures?: DocumentFigureUnion[];
    hyperlinks?: DocumentHyperlink[];
    kind: "document";
    pages?: DocumentPage[];
    paragraphs?: DocumentParagraph[];
    sections?: DocumentSection[];
    segments?: DocumentContentSegment[];
    startPageNumber: number;
    tables?: DocumentTable[];
    unit?: LengthUnit;
}

// @public
export interface DocumentContentSegment {
    category: string;
    endPageNumber: number;
    segmentId: string;
    span: ContentSpan;
    startPageNumber: number;
}

// @public
export interface DocumentFigure {
    caption?: DocumentCaption;
    description?: string;
    elements?: string[];
    footnotes?: DocumentFootnote[];
    id: string;
    kind: DocumentFigureKind;
    role?: SemanticRole;
    source?: string;
    span?: ContentSpan;
}

// @public
export type DocumentFigureKind = "unknown" | "chart" | "mermaid";

// @public
export type DocumentFigureUnion = DocumentChartFigure | DocumentMermaidFigure | DocumentFigure;

// @public
export interface DocumentFootnote {
    content: string;
    elements?: string[];
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentFormula {
    confidence?: number;
    kind: DocumentFormulaKind;
    source?: string;
    span?: ContentSpan;
    value: string;
}

// @public
export type DocumentFormulaKind = "inline" | "display";

// @public
export interface DocumentHyperlink {
    content: string;
    source?: string;
    span?: ContentSpan;
    url: string;
}

// @public
export interface DocumentLine {
    content: string;
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentMermaidFigure extends DocumentFigure {
    content: string;
    kind: "mermaid";
}

// @public
export interface DocumentPage {
    angle?: number;
    barcodes?: DocumentBarcode[];
    formulas?: DocumentFormula[];
    height?: number;
    lines?: DocumentLine[];
    pageNumber: number;
    spans?: ContentSpan[];
    width?: number;
    words?: DocumentWord[];
}

// @public
export interface DocumentParagraph {
    content: string;
    role?: SemanticRole;
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentSection {
    elements?: string[];
    span?: ContentSpan;
}

// @public
export interface DocumentTable {
    caption?: DocumentCaption;
    cells: DocumentTableCell[];
    columnCount: number;
    footnotes?: DocumentFootnote[];
    role?: SemanticRole;
    rowCount: number;
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentTableCell {
    columnIndex: number;
    columnSpan?: number;
    content: string;
    elements?: string[];
    kind?: DocumentTableCellKind;
    rowIndex: number;
    rowSpan?: number;
    source?: string;
    span?: ContentSpan;
}

// @public
export type DocumentTableCellKind = "content" | "rowHeader" | "columnHeader" | "stubHead" | "description";

// @public
export interface DocumentWord {
    confidence?: number;
    content: string;
    source?: string;
    span?: ContentSpan;
}

// @public
export type GenerationMethod = "generate" | "extract" | "classify";

// @public
export interface GetAnalyzerOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface GetDefaultsOptionalParams extends OperationOptions {
}

// @public
export interface GetOperationStatusOptionalParams extends OperationOptions {
}

// @public
export interface GetResultFileOptionalParams extends OperationOptions {
}

// @public
export interface GetResultOptionalParams extends OperationOptions {
}

// @public
export interface GrantCopyAuthorizationOptionalParams extends OperationOptions {
    clientRequestId?: string;
    targetRegion?: string;
}

// @public
export interface IntegerField extends ContentField {
    fieldType: "integer";
    valueInteger?: number;
}

// @public
export interface JsonField extends ContentField {
    fieldType: "json";
    valueJson?: any;
}

// @public
export interface KnowledgeSource {
    kind: KnowledgeSourceKind;
}

// @public
export type KnowledgeSourceKind = "labeledData";

// @public
export type KnowledgeSourceUnion = LabeledDataKnowledgeSource | KnowledgeSource;

// @public
export enum KnownVersions {
    V20251101 = "2025-11-01"
}

// @public
export interface LabeledDataKnowledgeSource extends KnowledgeSource {
    containerUrl: string;
    fileListPath: string;
    kind: "labeledData";
    prefix?: string;
}

// @public
export type LengthUnit = "pixel" | "inch";

// @public
export interface ListAnalyzersOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface MediaContent {
    analyzerId?: string;
    category?: string;
    fields?: Record<string, ContentFieldUnion>;
    kind: MediaContentKind;
    markdown?: string;
    mimeType: string;
    path?: string;
}

// @public
export type MediaContentKind = "document" | "audioVisual";

// @public
export type MediaContentUnion = DocumentContent | AudioVisualContent | MediaContent;

// @public
export interface NumberField extends ContentField {
    fieldType: "number";
    valueNumber?: number;
}

// @public
export interface ObjectField extends ContentField {
    fieldType: "object";
    valueObject?: Record<string, ContentFieldUnion>;
}

// @public
export type OperationState = "NotStarted" | "Running" | "Succeeded" | "Failed" | "Canceled";

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export type ProcessingLocation = "geography" | "dataZone" | "global";

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: ContentUnderstandingClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState_2<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState_2<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export type SemanticRole = "pageHeader" | "pageFooter" | "pageNumber" | "title" | "sectionHeading" | "footnote" | "formulaBlock";

// @public
export interface StringField extends ContentField {
    fieldType: "string";
    valueString?: string;
}

// @public
export interface SupportedModels {
    completion: string[];
    embedding: string[];
}

// @public
export type TableFormat = "html" | "markdown";

// @public
export interface TimeField extends ContentField {
    fieldType: "time";
    valueTime?: string;
}

// @public
export interface TranscriptPhrase {
    confidence?: number;
    endTimeMs: number;
    locale?: string;
    span?: ContentSpan;
    speaker?: string;
    startTimeMs: number;
    text: string;
    words: TranscriptWord[];
}

// @public
export interface TranscriptWord {
    endTimeMs: number;
    span?: ContentSpan;
    startTimeMs: number;
    text: string;
}

// @public
export interface UpdateAnalyzerOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface UpdateDefaultsOptionalParams extends OperationOptions {
    modelDeployments?: Record<string, string>;
}

// @public
export interface UsageDetails {
    audioHours?: number;
    contextualizationTokens?: number;
    documentPagesBasic?: number;
    documentPagesMinimal?: number;
    documentPagesStandard?: number;
    tokens?: Record<string, number>;
    videoHours?: number;
}

// (No @packageDocumentation comment for this package)

```
