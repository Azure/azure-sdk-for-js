/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as coreHttp from "@azure/core-http";

/**
 * Contains a set of input documents to be analyzed by the service.
 */
export interface MultiLanguageBatchInput {
  /**
   * The set of documents to process as part of this batch.
   */
  documents: MultiLanguageInput[];
}

/**
 * Contains an input document to be analyzed by the service.
 */
export interface MultiLanguageInput {
  /**
   * A unique, non-empty document identifier.
   */
  id: string;
  /**
   * The input text to process.
   */
  text: string;
  /**
   * (Optional) This is the 2 letter ISO 639-1 representation of a language. For example, use "en" for English; "es" for Spanish etc. If not set, use "en" for English as default.
   */
  language?: string;
}

/**
 * An interface representing EntitiesResult.
 */
export interface EntitiesResult {
  /**
   * Response by document
   */
  documents: DocumentEntities[];
  /**
   * Errors by document id.
   */
  errors: DocumentError[];
  /**
   * if showStats=true was specified in the request this field will contain information about the request payload.
   */
  statistics?: TextDocumentBatchStatistics;
  /**
   * This field indicates which model is used for scoring.
   */
  modelVersion: string;
}

/**
 * An interface representing DocumentEntities.
 */
export interface DocumentEntities {
  /**
   * Unique, non-empty document identifier.
   */
  id: string;
  /**
   * Recognized entities in the document.
   */
  entities: Entity[];
  /**
   * if showStats=true was specified in the request this field will contain information about the document payload.
   */
  statistics?: TextDocumentStatistics;
}

/**
 * An interface representing Entity.
 */
export interface Entity {
  /**
   * Entity text as appears in the request.
   */
  text: string;
  /**
   * Entity type, such as Person/Location/Org/SSN etc
   */
  category: string;
  /**
   * Entity sub type, such as Age/Year/TimeRange etc
   */
  subCategory?: string;
  /**
   * Start position (in Unicode characters) for the entity text.
   */
  offset: number;
  /**
   * Length (in Unicode characters) for the entity text.
   */
  length: number;
  /**
   * Confidence score between 0 and 1 of the extracted entity.
   */
  score: number;
}

/**
 * if showStats=true was specified in the request this field will contain information about the document payload.
 */
export interface TextDocumentStatistics {
  /**
   * Number of text elements recognized in the document.
   */
  characterCount: number;
  /**
   * Number of transactions for the document.
   */
  transactionCount: number;
}

/**
 * An interface representing DocumentError.
 */
export interface DocumentError {
  /**
   * Document Id.
   */
  id: string;
  error: TextAnalyticsError;
}

/**
 * An interface representing TextAnalyticsError.
 */
export interface TextAnalyticsError {
  /**
   * Error code.
   */
  code: ErrorCodeValue;
  /**
   * Error message.
   */
  message: string;
  /**
   * Error target.
   */
  target?: string;
  innerError?: InnerError;
  /**
   * Details about specific errors that led to this reported error.
   */
  details?: TextAnalyticsError[];
}

/**
 * An interface representing InnerError.
 */
export interface InnerError {
  /**
   * Error code.
   */
  code: InnerErrorCodeValue;
  /**
   * Error message.
   */
  message: string;
  /**
   * Error details.
   */
  details?: { [propertyName: string]: string };
  /**
   * Error target.
   */
  target?: string;
  innerError?: InnerError;
}

/**
 * if showStats=true was specified in the request this field will contain information about the request payload.
 */
export interface TextDocumentBatchStatistics {
  /**
   * Number of documents submitted in the request.
   */
  documentCount: number;
  /**
   * Number of valid documents. This excludes empty, over-size limit or non-supported languages documents.
   */
  validDocumentCount: number;
  /**
   * Number of invalid documents. This includes empty, over-size limit or non-supported languages documents.
   */
  erroneousDocumentCount: number;
  /**
   * Number of transactions for the request.
   */
  transactionCount: number;
}

/**
 * An interface representing EntityLinkingResult.
 */
export interface EntityLinkingResult {
  /**
   * Response by document
   */
  documents: DocumentLinkedEntities[];
  /**
   * Errors by document id.
   */
  errors: DocumentError[];
  /**
   * if showStats=true was specified in the request this field will contain information about the request payload.
   */
  statistics?: TextDocumentBatchStatistics;
  /**
   * This field indicates which model is used for scoring.
   */
  modelVersion: string;
}

/**
 * An interface representing DocumentLinkedEntities.
 */
export interface DocumentLinkedEntities {
  /**
   * Unique, non-empty document identifier.
   */
  id: string;
  /**
   * Recognized well-known entities in the document.
   */
  entities: LinkedEntity[];
  /**
   * if showStats=true was specified in the request this field will contain information about the document payload.
   */
  statistics?: TextDocumentStatistics;
}

/**
 * An interface representing LinkedEntity.
 */
export interface LinkedEntity {
  /**
   * Entity Linking formal name.
   */
  name: string;
  /**
   * List of instances this entity appears in the text.
   */
  matches: Match[];
  /**
   * Language used in the data source.
   */
  language: string;
  /**
   * Unique identifier of the recognized entity from the data source.
   */
  id?: string;
  /**
   * URL for the entity's page from the data source.
   */
  url: string;
  /**
   * Data source used to extract entity linking, such as Wiki/Bing etc.
   */
  dataSource: string;
}

/**
 * An interface representing Match.
 */
export interface Match {
  /**
   * If a well-known item is recognized, a decimal number denoting the confidence level between 0 and 1 will be returned.
   */
  score: number;
  /**
   * Entity text as appears in the request.
   */
  text: string;
  /**
   * Start position (in Unicode characters) for the entity match text.
   */
  offset: number;
  /**
   * Length (in Unicode characters) for the entity match text.
   */
  length: number;
}

/**
 * An interface representing KeyPhraseResult.
 */
export interface KeyPhraseResult {
  /**
   * Response by document
   */
  documents: DocumentKeyPhrases[];
  /**
   * Errors by document id.
   */
  errors: DocumentError[];
  /**
   * if showStats=true was specified in the request this field will contain information about the request payload.
   */
  statistics?: TextDocumentBatchStatistics;
  /**
   * This field indicates which model is used for scoring.
   */
  modelVersion: string;
}

/**
 * An interface representing DocumentKeyPhrases.
 */
export interface DocumentKeyPhrases {
  /**
   * Unique, non-empty document identifier.
   */
  id: string;
  /**
   * A list of representative words or phrases. The number of key phrases returned is proportional to the number of words in the input document.
   */
  keyPhrases: string[];
  /**
   * if showStats=true was specified in the request this field will contain information about the document payload.
   */
  statistics?: TextDocumentStatistics;
}

/**
 * An interface representing LanguageBatchInput.
 */
export interface LanguageBatchInput {
  documents: LanguageInput[];
}

/**
 * An interface representing LanguageInput.
 */
export interface LanguageInput {
  /**
   * Unique, non-empty document identifier.
   */
  id: string;
  text: string;
  countryHint?: string;
}

/**
 * An interface representing LanguageResult.
 */
export interface LanguageResult {
  /**
   * Response by document
   */
  documents: DocumentLanguage[];
  /**
   * Errors by document id.
   */
  errors: DocumentError[];
  /**
   * if showStats=true was specified in the request this field will contain information about the request payload.
   */
  statistics?: TextDocumentBatchStatistics;
  /**
   * This field indicates which model is used for scoring.
   */
  modelVersion: string;
}

/**
 * An interface representing DocumentLanguage.
 */
export interface DocumentLanguage {
  /**
   * Unique, non-empty document identifier.
   */
  id: string;
  /**
   * A list of extracted languages.
   */
  detectedLanguages: DetectedLanguage[];
  /**
   * if showStats=true was specified in the request this field will contain information about the document payload.
   */
  statistics?: TextDocumentStatistics;
}

/**
 * An interface representing DetectedLanguage.
 */
export interface DetectedLanguage {
  /**
   * Long name of a detected language (e.g. English, French).
   */
  name: string;
  /**
   * A two letter representation of the detected language according to the ISO 639-1 standard (e.g. en, fr).
   */
  iso6391Name: string;
  /**
   * A confidence score between 0 and 1. Scores close to 1 indicate 100% certainty that the identified language is true.
   */
  score: number;
}

/**
 * An interface representing SentimentResponse.
 */
export interface SentimentResponse {
  /**
   * Sentiment analysis per document.
   */
  documents: DocumentSentiment[];
  /**
   * Errors by document id.
   */
  errors: DocumentError[];
  /**
   * if showStats=true was specified in the request this field will contain information about the request payload.
   */
  statistics?: TextDocumentBatchStatistics;
  /**
   * This field indicates which model is used for scoring.
   */
  modelVersion: string;
}

/**
 * An interface representing DocumentSentiment.
 */
export interface DocumentSentiment {
  /**
   * Unique, non-empty document identifier.
   */
  id: string;
  /**
   * Predicted sentiment for document (Negative, Neutral, Positive, or Mixed).
   */
  sentiment: DocumentSentimentLabel;
  /**
   * if showStats=true was specified in the request this field will contain information about the document payload.
   */
  statistics?: TextDocumentStatistics;
  /**
   * Represents the confidence scores between 0 and 1 across all sentiment classes: positive, neutral, negative.
   */
  documentScores: SentimentConfidenceScorePerLabel;
  /**
   * Sentence level sentiment analysis.
   */
  sentenceSentiments: SentenceSentiment[];
}

/**
 * Represents the confidence scores between 0 and 1 across all sentiment classes: positive, neutral, negative.
 */
export interface SentimentConfidenceScorePerLabel {
  positive: number;
  neutral: number;
  negative: number;
}

/**
 * An interface representing SentenceSentiment.
 */
export interface SentenceSentiment {
  /**
   * The predicted Sentiment for the sentence.
   */
  sentiment: SentenceSentimentLabel;
  /**
   * Represents the confidence scores between 0 and 1 across all sentiment classes: positive, neutral, negative.
   */
  sentimentScores: SentimentConfidenceScorePerLabel;
  /**
   * The sentence offset from the start of the document.
   */
  offset: number;
  /**
   * The length of the sentence by Unicode standard.
   */
  length: number;
  /**
   * The warnings generated for the sentence.
   */
  warnings?: string[];
}

/**
 * Defines values for ErrorCodeValue.
 */
export type ErrorCodeValue =
  | "InvalidRequest"
  | "InvalidArgument"
  | "InternalServerError"
  | "ServiceUnavailable";
/**
 * Defines values for InnerErrorCodeValue.
 */
export type InnerErrorCodeValue =
  | "InvalidParameterValue"
  | "InvalidRequestBodyFormat"
  | "EmptyRequest"
  | "MissingInputRecords"
  | "InvalidDocument"
  | "ModelVersionIncorrect"
  | "InvalidDocumentBatch"
  | "UnsupportedLanguageCode"
  | "InvalidCountryHint";
/**
 * Defines values for DocumentSentimentLabel.
 */
export type DocumentSentimentLabel =
  | "positive"
  | "neutral"
  | "negative"
  | "mixed";
/**
 * Defines values for SentenceSentimentLabel.
 */
export type SentenceSentimentLabel = "positive" | "neutral" | "negative";

/**
 * Contains response data for the entitiesRecognitionGeneral operation.
 */
export type TextAnalyticsClientEntitiesRecognitionGeneralResponse = EntitiesResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: EntitiesResult;
  };
};

/**
 * Contains response data for the entitiesRecognitionPii operation.
 */
export type TextAnalyticsClientEntitiesRecognitionPiiResponse = EntitiesResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: EntitiesResult;
  };
};

/**
 * Contains response data for the entitiesLinking operation.
 */
export type TextAnalyticsClientEntitiesLinkingResponse = EntityLinkingResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: EntityLinkingResult;
  };
};

/**
 * Contains response data for the keyPhrases operation.
 */
export type TextAnalyticsClientKeyPhrasesResponse = KeyPhraseResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: KeyPhraseResult;
  };
};

/**
 * Contains response data for the languages operation.
 */
export type TextAnalyticsClientLanguagesResponse = LanguageResult & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: LanguageResult;
  };
};

/**
 * Contains response data for the sentiment operation.
 */
export type TextAnalyticsClientSentimentResponse = SentimentResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: coreHttp.HttpResponse & {
    /**
     * The response body as text (string format)
     */
    bodyAsText: string;

    /**
     * The response body as parsed JSON or XML
     */
    parsedBody: SentimentResponse;
  };
};

/**
 * Optional parameters.
 */
export interface TextAnalyticsClientOptionalParams
  extends coreHttp.ServiceClientOptions {
  /**
   * Overrides request baseUri.
   */
  baseUri?: string;
}
