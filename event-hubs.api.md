## API Report File for "@azure/event-hubs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { AmqpError } from 'rhea-promise';
import { AwaitableSender } from 'rhea-promise';
import { ConnectionContextBase } from '@azure/core-amqp';
import { DataTransformer } from '@azure/core-amqp';
import { DefaultDataTransformer } from '@azure/core-amqp';
import { Dictionary } from 'rhea-promise';
import { EventHubConnectionConfig } from '@azure/core-amqp';
import { MessagingError } from '@azure/core-amqp';
import { Receiver } from 'rhea-promise';
import { ReceiverOptions } from 'rhea-promise';
import { RetryOptions } from '@azure/core-amqp';
import { SharedKeyCredential } from '@azure/core-amqp';
import { Span } from '@azure/core-tracing';
import { SpanContext } from '@azure/core-tracing';
import { SpanOptions } from '@azure/core-tracing';
import { TokenCredential } from '@azure/core-amqp';
import { TokenType } from '@azure/core-amqp';
import { WebSocketImpl } from 'rhea-promise';

// @public
export interface AbortSignalOptions {
    abortSignal?: AbortSignalLike;
}

// @public
export interface Checkpoint {
    consumerGroupName: string;
    eTag: string;
    eventHubName: string;
    fullyQualifiedNamespace: string;
    offset: number;
    ownerId: string;
    partitionId: string;
    sequenceNumber: number;
}

// @public
export interface CheckpointManager {
    listCheckpoints(fullyQualifiedNamespace: string, eventHubName: string, consumerGroup: string): Promise<Checkpoint[]>;
    updateCheckpoint(checkpoint: Checkpoint): Promise<string>;
}

// @public
export enum CloseReason {
    OwnershipLost = "OwnershipLost",
    Shutdown = "Shutdown"
}

// @public
export interface CreateBatchOptions {
    abortSignal?: AbortSignalLike;
    maxSizeInBytes?: number;
    partitionKey?: string;
}

export { DataTransformer }

export { DefaultDataTransformer }

// @public
export interface EventData {
    body: any;
    properties?: {
        [key: string]: any;
    };
}

// @public
export class EventDataBatch {
    // Warning: (ae-forgotten-export) The symbol "ConnectionContext" needs to be exported by the entry point index.d.ts
    // 
    // @internal
    constructor(context: ConnectionContext, maxSizeInBytes: number, partitionKey?: string);
    readonly batchMessage: Buffer | undefined;
    readonly count: number;
    // @internal
    readonly _messageSpanContexts: SpanContext[];
    readonly partitionKey: string | undefined;
    readonly sizeInBytes: number;
    tryAdd(eventData: EventData, options?: TryAddOptions): boolean;
}

// @public
export interface EventHubClientOptions {
    dataTransformer?: DataTransformer;
    retryOptions?: RetryOptions;
    userAgent?: string;
    webSocket?: WebSocketImpl;
    webSocketConstructorOptions?: any;
}

// @public
export class EventHubConsumerClient {
    constructor(connectionString: string, options?: EventHubClientOptions);
    constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions);
    constructor(host: string, eventHubName: string, credential: TokenCredential, options?: EventHubClientOptions);
    close(): Promise<void>;
    static defaultConsumerGroupName: string;
    getPartitionIds(option?: GetPartitionIdsOptions): Promise<string[]>;
    getPartitionProperties(partitionId: string, options?: GetPartitionPropertiesOptions): Promise<PartitionProperties>;
    getProperties(options?: GetPropertiesOptions): Promise<EventHubProperties>;
    subscribe(consumerGroupName: string, options: SubscriptionOptions): Subscription;
    subscribe(consumerGroupName: string, partitionId: string, options: SubscriptionOptions): Subscription;
    subscribe(consumerGroupName: string, partitionManager: PartitionManager, options: SubscriptionOptions): Subscription;
}

// @public
export class EventHubProducerClient {
    constructor(connectionString: string, options?: EventHubClientOptions);
    constructor(connectionString: string, eventHubName: string, options?: EventHubClientOptions);
    constructor(host: string, eventHubName: string, credential: TokenCredential, options?: EventHubClientOptions);
    close(): Promise<void>;
    createBatch(options?: CreateBatchOptions): Promise<EventDataBatch>;
    readonly eventHubName: string;
    readonly fullyQualifiedNamespace: string;
    getPartitionIds(options?: GetPartitionIdsOptions): Promise<Array<string>>;
    getProperties(options?: GetPropertiesOptions): Promise<EventHubProperties>;
    sendBatch(batch: EventDataBatch, options?: SendBatchOptions): Promise<void>;
    sendBatch(batch: EventDataBatch, partitionId: string, options?: SendBatchOptions): Promise<void>;
}

// @public
export interface EventHubProperties {
    createdAt: Date;
    name: string;
    partitionIds: string[];
}

// @public
export class EventPosition {
    // Warning: (ae-forgotten-export) The symbol "EventPositionOptions" needs to be exported by the entry point index.d.ts
    // 
    // @internal
    constructor(options?: EventPositionOptions);
    static earliest(): EventPosition;
    enqueuedTime?: Date | number;
    static fromEnqueuedTime(enqueuedTime: Date | number): EventPosition;
    static fromOffset(offset: number, isInclusive?: boolean): EventPosition;
    static fromSequenceNumber(sequenceNumber: number, isInclusive?: boolean): EventPosition;
    isInclusive: boolean;
    static latest(): EventPosition;
    offset?: number | "@latest";
    sequenceNumber?: number;
    }

// @public
export function extractSpanContextFromEventData(eventData: EventData): SpanContext | undefined;

// @public
export interface GetPartitionIdsOptions extends AbortSignalOptions, SpanOptions {
}

// @public
export interface GetPartitionPropertiesOptions extends AbortSignalOptions, SpanOptions {
}

// @public
export interface GetPropertiesOptions extends AbortSignalOptions, SpanOptions {
}

// @public
export class InMemoryPartitionManager implements OwnershipManager, CheckpointManager {
    claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;
    // (undocumented)
    listCheckpoints(fullyQualifiedNamespace: string, eventHubName: string, consumerGroup: string): Promise<Checkpoint[]>;
    listOwnership(fullyQualifiedNamespace: string, eventHubName: string, consumerGroupName: string): Promise<PartitionOwnership[]>;
    updateCheckpoint(checkpoint: Checkpoint): Promise<string>;
}

// @public
export interface LastEnqueuedEventInfo {
    enqueuedTime?: Date;
    offset?: string;
    retrievalTime?: Date;
    sequenceNumber?: number;
}

export { MessagingError }

// @public
export interface OwnershipManager {
    claimOwnership(partitionOwnership: PartitionOwnership[]): Promise<PartitionOwnership[]>;
    listOwnership(fullyQualifiedNamespace: string, eventHubName: string, consumerGroupName: string): Promise<PartitionOwnership[]>;
}

// @public
export interface PartitionCheckpointer {
    updateCheckpoint(eventData: ReceivedEventData): Promise<void>;
    updateCheckpoint(sequenceNumber: number, offset: number): Promise<void>;
    // @internal (undocumented)
    updateCheckpoint(eventDataOrSequenceNumber: ReceivedEventData | number, offset?: number): Promise<void>;
}

// @public
export interface PartitionContext {
    consumerGroupName: string;
    eventHubName: string;
    fullyQualifiedNamespace: string;
    partitionId: string;
}

// @public
export type PartitionManager = CheckpointManager & OwnershipManager;

// @public
export interface PartitionOwnership extends PartitionContext {
    eTag?: string;
    lastModifiedTimeInMS?: number;
    offset?: number;
    ownerId: string;
    ownerLevel: number;
    sequenceNumber?: number;
}

// @public
export interface PartitionProperties {
    beginningSequenceNumber: number;
    eventHubName: string;
    lastEnqueuedOffset: number;
    lastEnqueuedSequenceNumber: number;
    lastEnqueuedTimeUtc: Date;
    partitionId: string;
}

// @public
export type ProcessCloseHandler = (reason: CloseReason, context: PartitionContext & PartitionCheckpointer) => Promise<void>;

// @public
export type ProcessErrorHandler = (error: Error, context: PartitionContext) => Promise<void>;

// @public
export type ProcessEvents = (receivedEvent: ReceivedEventData, context: PartitionContext & PartitionCheckpointer) => Promise<void>;

// @public
export type ProcessInitializeHandler = (context: PartitionContext) => Promise<void>;

// @public
export interface ReceivedEventData {
    body: any;
    enqueuedTimeUtc: Date;
    offset: number;
    partitionKey: string | null;
    properties?: {
        [key: string]: any;
    };
    sequenceNumber: number;
    systemProperties?: {
        [key: string]: any;
    };
}

export { RetryOptions }

// @public
export interface SendBatchOptions {
    abortSignal?: AbortSignalLike;
    parentSpan?: Span | SpanContext;
}

// @public
export interface Subscription {
    close(): Promise<void>;
    isRunning(): boolean;
}

// @public
export interface SubscriptionEventHandlers {
    processClose?: ProcessCloseHandler;
    processError?: ProcessErrorHandler;
    processEvent: ProcessEvents;
    processInitialize?: ProcessInitializeHandler;
}

// @public
export interface SubscriptionOptions extends SubscriptionEventHandlers {
    defaultEventPosition?: EventPosition;
    maxBatchSize?: number;
    maxWaitTimeInSeconds?: number;
    trackLastEnqueuedEventInfo?: boolean;
}

export { TokenCredential }

export { TokenType }

// @public
export interface TryAddOptions {
    parentSpan?: Span | SpanContext;
}

export { WebSocketImpl }


// (No @packageDocumentation comment for this package)

```
