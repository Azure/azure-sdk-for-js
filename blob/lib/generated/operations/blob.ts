/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import * as msRest from "ms-rest-js";
import * as Models from "../models";
import * as Mappers from "../models/blobMappers";
import * as Parameters from "../models/parameters";
import { StorageClientContext } from "../storageClientContext";

/** Class representing a Blob. */
export class Blob {
  private readonly client: StorageClientContext;

  /**
   * Create a Blob.
   * @param {StorageClientContext} client Reference to the service client.
   */
  constructor(client: StorageClientContext) {
    this.client = client;
  }

  /**
   * The Download operation reads or downloads a blob from the system, including its metadata and
   * properties. You can also call Download to read a snapshot.
   *
   * @param {BlobDownloadOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  download(): Promise<Models.BlobDownloadResponse>;
  download(options: Models.BlobDownloadOptionalParams): Promise<Models.BlobDownloadResponse>;
  download(callback: msRest.ServiceCallback<void>): void;
  download(options: Models.BlobDownloadOptionalParams, callback: msRest.ServiceCallback<void>): void;
  download(options?: Models.BlobDownloadOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobDownloadResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      downloadOperationSpec,
      callback) as Promise<Models.BlobDownloadResponse>;
  }

  /**
   * The Get Properties operation returns all user-defined metadata, standard HTTP properties, and
   * system properties for the blob. It does not return the content of the blob.
   *
   * @param {BlobGetPropertiesOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  getProperties(): Promise<Models.BlobGetPropertiesResponse>;
  getProperties(options: Models.BlobGetPropertiesOptionalParams): Promise<Models.BlobGetPropertiesResponse>;
  getProperties(callback: msRest.ServiceCallback<void>): void;
  getProperties(options: Models.BlobGetPropertiesOptionalParams, callback: msRest.ServiceCallback<void>): void;
  getProperties(options?: Models.BlobGetPropertiesOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobGetPropertiesResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      getPropertiesOperationSpec,
      callback) as Promise<Models.BlobGetPropertiesResponse>;
  }

  /**
   * If the storage account's soft delete feature is disabled then, when a blob is deleted, it is
   * permanently removed from the storage account. If the storage account's soft delete feature is
   * enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible
   * immediately. However, the blob service retains the blob or snapshot for the number of days
   * specified by the DeleteRetentionPolicy section of [Storage service properties]
   * (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data
   * is permanently removed from the storage account. Note that you continue to be charged for the
   * soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify
   * the "include=deleted" query parameter to discover which blobs and snapshots have been soft
   * deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other
   * operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code
   * of 404 (ResourceNotFound).
   *
   * @param {BlobDeleteMethodOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  deleteMethod(): Promise<Models.BlobDeleteResponse>;
  deleteMethod(options: Models.BlobDeleteMethodOptionalParams): Promise<Models.BlobDeleteResponse>;
  deleteMethod(callback: msRest.ServiceCallback<void>): void;
  deleteMethod(options: Models.BlobDeleteMethodOptionalParams, callback: msRest.ServiceCallback<void>): void;
  deleteMethod(options?: Models.BlobDeleteMethodOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobDeleteResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      deleteMethodOperationSpec,
      callback) as Promise<Models.BlobDeleteResponse>;
  }

  /**
   * Undelete a blob that was previously soft deleted
   *
   * @param {BlobUndeleteOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  undelete(): Promise<Models.BlobUndeleteResponse>;
  undelete(options: Models.BlobUndeleteOptionalParams): Promise<Models.BlobUndeleteResponse>;
  undelete(callback: msRest.ServiceCallback<void>): void;
  undelete(options: Models.BlobUndeleteOptionalParams, callback: msRest.ServiceCallback<void>): void;
  undelete(options?: Models.BlobUndeleteOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobUndeleteResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      undeleteOperationSpec,
      callback) as Promise<Models.BlobUndeleteResponse>;
  }

  /**
   * The Set HTTP Headers operation sets system properties on the blob
   *
   * @param {BlobSetHTTPHeadersOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  setHTTPHeaders(): Promise<Models.BlobSetHTTPHeadersResponse>;
  setHTTPHeaders(options: Models.BlobSetHTTPHeadersOptionalParams): Promise<Models.BlobSetHTTPHeadersResponse>;
  setHTTPHeaders(callback: msRest.ServiceCallback<void>): void;
  setHTTPHeaders(options: Models.BlobSetHTTPHeadersOptionalParams, callback: msRest.ServiceCallback<void>): void;
  setHTTPHeaders(options?: Models.BlobSetHTTPHeadersOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobSetHTTPHeadersResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      setHTTPHeadersOperationSpec,
      callback) as Promise<Models.BlobSetHTTPHeadersResponse>;
  }

  /**
   * The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more
   * name-value pairs
   *
   * @param {BlobSetMetadataOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  setMetadata(): Promise<Models.BlobSetMetadataResponse>;
  setMetadata(options: Models.BlobSetMetadataOptionalParams): Promise<Models.BlobSetMetadataResponse>;
  setMetadata(callback: msRest.ServiceCallback<void>): void;
  setMetadata(options: Models.BlobSetMetadataOptionalParams, callback: msRest.ServiceCallback<void>): void;
  setMetadata(options?: Models.BlobSetMetadataOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobSetMetadataResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      setMetadataOperationSpec,
      callback) as Promise<Models.BlobSetMetadataResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   *
   * @param {BlobAcquireLeaseOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  acquireLease(): Promise<Models.BlobAcquireLeaseResponse>;
  acquireLease(options: Models.BlobAcquireLeaseOptionalParams): Promise<Models.BlobAcquireLeaseResponse>;
  acquireLease(callback: msRest.ServiceCallback<void>): void;
  acquireLease(options: Models.BlobAcquireLeaseOptionalParams, callback: msRest.ServiceCallback<void>): void;
  acquireLease(options?: Models.BlobAcquireLeaseOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobAcquireLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      acquireLeaseOperationSpec,
      callback) as Promise<Models.BlobAcquireLeaseResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   *
   * @param {string} leaseId Specifies the current lease ID on the resource.
   *
   * @param {BlobReleaseLeaseOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  releaseLease(leaseId: string): Promise<Models.BlobReleaseLeaseResponse>;
  releaseLease(leaseId: string, options: Models.BlobReleaseLeaseOptionalParams): Promise<Models.BlobReleaseLeaseResponse>;
  releaseLease(leaseId: string, callback: msRest.ServiceCallback<void>): void;
  releaseLease(leaseId: string, options: Models.BlobReleaseLeaseOptionalParams, callback: msRest.ServiceCallback<void>): void;
  releaseLease(leaseId: string, options?: Models.BlobReleaseLeaseOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobReleaseLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        leaseId,
        options
      },
      releaseLeaseOperationSpec,
      callback) as Promise<Models.BlobReleaseLeaseResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   *
   * @param {string} leaseId Specifies the current lease ID on the resource.
   *
   * @param {BlobRenewLeaseOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  renewLease(leaseId: string): Promise<Models.BlobRenewLeaseResponse>;
  renewLease(leaseId: string, options: Models.BlobRenewLeaseOptionalParams): Promise<Models.BlobRenewLeaseResponse>;
  renewLease(leaseId: string, callback: msRest.ServiceCallback<void>): void;
  renewLease(leaseId: string, options: Models.BlobRenewLeaseOptionalParams, callback: msRest.ServiceCallback<void>): void;
  renewLease(leaseId: string, options?: Models.BlobRenewLeaseOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobRenewLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        leaseId,
        options
      },
      renewLeaseOperationSpec,
      callback) as Promise<Models.BlobRenewLeaseResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   *
   * @param {string} leaseId Specifies the current lease ID on the resource.
   *
   * @param {string} proposedLeaseId Proposed lease ID, in a GUID string format. The Blob service
   * returns 400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid
   * Constructor (String) for a list of valid GUID string formats.
   *
   * @param {BlobChangeLeaseOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  changeLease(leaseId: string, proposedLeaseId: string): Promise<Models.BlobChangeLeaseResponse>;
  changeLease(leaseId: string, proposedLeaseId: string, options: Models.BlobChangeLeaseOptionalParams): Promise<Models.BlobChangeLeaseResponse>;
  changeLease(leaseId: string, proposedLeaseId: string, callback: msRest.ServiceCallback<void>): void;
  changeLease(leaseId: string, proposedLeaseId: string, options: Models.BlobChangeLeaseOptionalParams, callback: msRest.ServiceCallback<void>): void;
  changeLease(leaseId: string, proposedLeaseId: string, options?: Models.BlobChangeLeaseOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobChangeLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        leaseId,
        proposedLeaseId,
        options
      },
      changeLeaseOperationSpec,
      callback) as Promise<Models.BlobChangeLeaseResponse>;
  }

  /**
   * [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete
   * operations
   *
   * @param {BlobBreakLeaseOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  breakLease(): Promise<Models.BlobBreakLeaseResponse>;
  breakLease(options: Models.BlobBreakLeaseOptionalParams): Promise<Models.BlobBreakLeaseResponse>;
  breakLease(callback: msRest.ServiceCallback<void>): void;
  breakLease(options: Models.BlobBreakLeaseOptionalParams, callback: msRest.ServiceCallback<void>): void;
  breakLease(options?: Models.BlobBreakLeaseOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobBreakLeaseResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      breakLeaseOperationSpec,
      callback) as Promise<Models.BlobBreakLeaseResponse>;
  }

  /**
   * The Create Snapshot operation creates a read-only snapshot of a blob
   *
   * @param {BlobCreateSnapshotOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  createSnapshot(): Promise<Models.BlobCreateSnapshotResponse>;
  createSnapshot(options: Models.BlobCreateSnapshotOptionalParams): Promise<Models.BlobCreateSnapshotResponse>;
  createSnapshot(callback: msRest.ServiceCallback<void>): void;
  createSnapshot(options: Models.BlobCreateSnapshotOptionalParams, callback: msRest.ServiceCallback<void>): void;
  createSnapshot(options?: Models.BlobCreateSnapshotOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobCreateSnapshotResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      createSnapshotOperationSpec,
      callback) as Promise<Models.BlobCreateSnapshotResponse>;
  }

  /**
   * The Start Copy From URL operation copies a blob or an internet resource to a new blob.
   *
   * @param {string} copySource Specifies the name of the source page blob snapshot. This value is a
   * URL of up to 2 KB in length that specifies a page blob snapshot. The value should be URL-encoded
   * as it would appear in a request URI. The source blob must either be public or must be
   * authenticated via a shared access signature.
   *
   * @param {BlobStartCopyFromURLOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  startCopyFromURL(copySource: string): Promise<Models.BlobStartCopyFromURLResponse>;
  startCopyFromURL(copySource: string, options: Models.BlobStartCopyFromURLOptionalParams): Promise<Models.BlobStartCopyFromURLResponse>;
  startCopyFromURL(copySource: string, callback: msRest.ServiceCallback<void>): void;
  startCopyFromURL(copySource: string, options: Models.BlobStartCopyFromURLOptionalParams, callback: msRest.ServiceCallback<void>): void;
  startCopyFromURL(copySource: string, options?: Models.BlobStartCopyFromURLOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobStartCopyFromURLResponse> {
    return this.client.sendOperationRequest(
      {
        copySource,
        options
      },
      startCopyFromURLOperationSpec,
      callback) as Promise<Models.BlobStartCopyFromURLResponse>;
  }

  /**
   * The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a
   * destination blob with zero length and full metadata.
   *
   * @param {string} copyId The copy identifier provided in the x-ms-copy-id header of the original
   * Copy Blob operation.
   *
   * @param {BlobAbortCopyFromURLOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  abortCopyFromURL(copyId: string): Promise<Models.BlobAbortCopyFromURLResponse>;
  abortCopyFromURL(copyId: string, options: Models.BlobAbortCopyFromURLOptionalParams): Promise<Models.BlobAbortCopyFromURLResponse>;
  abortCopyFromURL(copyId: string, callback: msRest.ServiceCallback<void>): void;
  abortCopyFromURL(copyId: string, options: Models.BlobAbortCopyFromURLOptionalParams, callback: msRest.ServiceCallback<void>): void;
  abortCopyFromURL(copyId: string, options?: Models.BlobAbortCopyFromURLOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobAbortCopyFromURLResponse> {
    return this.client.sendOperationRequest(
      {
        copyId,
        options
      },
      abortCopyFromURLOperationSpec,
      callback) as Promise<Models.BlobAbortCopyFromURLResponse>;
  }

  /**
   * The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a
   * premium storage account and on a block blob in a blob storage account (locally redundant storage
   * only). A premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob.
   * A block blob's tier determines Hot/Cool/Archive storage type. This operation does not update the
   * blob's ETag.
   *
   * @param {AccessTier} tier Indicates the tier to be set on the blob. Possible values include:
   * 'P4', 'P6', 'P10', 'P20', 'P30', 'P40', 'P50', 'Hot', 'Cool', 'Archive'
   *
   * @param {BlobSetTierOptionalParams} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  setTier(tier: Models.AccessTier): Promise<Models.BlobSetTierResponse>;
  setTier(tier: Models.AccessTier, options: Models.BlobSetTierOptionalParams): Promise<Models.BlobSetTierResponse>;
  setTier(tier: Models.AccessTier, callback: msRest.ServiceCallback<void>): void;
  setTier(tier: Models.AccessTier, options: Models.BlobSetTierOptionalParams, callback: msRest.ServiceCallback<void>): void;
  setTier(tier: Models.AccessTier, options?: Models.BlobSetTierOptionalParams, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobSetTierResponse> {
    return this.client.sendOperationRequest(
      {
        tier,
        options
      },
      setTierOperationSpec,
      callback) as Promise<Models.BlobSetTierResponse>;
  }

  /**
   * Returns the sku name and account kind
   *
   * @param {RequestOptionsBase} [options] Optional Parameters.
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse} The deserialized result object.
   *
   * @reject {Error|ServiceError} The error object.
   */
  getAccountInfo(): Promise<Models.BlobGetAccountInfoResponse>;
  getAccountInfo(options: msRest.RequestOptionsBase): Promise<Models.BlobGetAccountInfoResponse>;
  getAccountInfo(callback: msRest.ServiceCallback<void>): void;
  getAccountInfo(options: msRest.RequestOptionsBase, callback: msRest.ServiceCallback<void>): void;
  getAccountInfo(options?: msRest.RequestOptionsBase, callback?: msRest.ServiceCallback<void>): Promise<Models.BlobGetAccountInfoResponse> {
    return this.client.sendOperationRequest(
      {
        options
      },
      getAccountInfoOperationSpec,
      callback) as Promise<Models.BlobGetAccountInfoResponse>;
  }

}

// Operation Specifications
const serializer = new msRest.Serializer(Mappers, true);
const downloadOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.snapshot,
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.range,
    Parameters.rangeGetContentMD5,
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    200: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: Mappers.BlobDownloadHeaders
    },
    206: {
      bodyMapper: {
        serializedName: "parsedResponse",
        type: {
          name: "Stream"
        }
      },
      headersMapper: Mappers.BlobDownloadHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const getPropertiesOperationSpec: msRest.OperationSpec = {
  httpMethod: "HEAD",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.snapshot,
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobGetPropertiesHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const deleteMethodOperationSpec: msRest.OperationSpec = {
  httpMethod: "DELETE",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.snapshot,
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.deleteSnapshots,
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    202: {
      headersMapper: Mappers.BlobDeleteHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const undeleteOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp6
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobUndeleteHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const setHTTPHeadersOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp0
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.blobCacheControl,
    Parameters.blobContentType,
    Parameters.blobContentMD5,
    Parameters.blobContentEncoding,
    Parameters.blobContentLanguage,
    Parameters.blobContentDisposition,
    Parameters.leaseId0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobSetHTTPHeadersHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const setMetadataOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp3
  ],
  headerParameters: [
    Parameters.metadata,
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobSetMetadataHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const acquireLeaseOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp5
  ],
  headerParameters: [
    Parameters.duration,
    Parameters.proposedLeaseId0,
    Parameters.version,
    Parameters.requestId,
    Parameters.action0,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    201: {
      headersMapper: Mappers.BlobAcquireLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const releaseLeaseOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp5
  ],
  headerParameters: [
    Parameters.leaseId1,
    Parameters.version,
    Parameters.requestId,
    Parameters.action1,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobReleaseLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const renewLeaseOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp5
  ],
  headerParameters: [
    Parameters.leaseId1,
    Parameters.version,
    Parameters.requestId,
    Parameters.action2,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobRenewLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const changeLeaseOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp5
  ],
  headerParameters: [
    Parameters.leaseId1,
    Parameters.proposedLeaseId1,
    Parameters.version,
    Parameters.requestId,
    Parameters.action4,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobChangeLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const breakLeaseOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp5
  ],
  headerParameters: [
    Parameters.breakPeriod,
    Parameters.version,
    Parameters.requestId,
    Parameters.action3,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch
  ],
  responses: {
    202: {
      headersMapper: Mappers.BlobBreakLeaseHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const createSnapshotOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp7
  ],
  headerParameters: [
    Parameters.metadata,
    Parameters.version,
    Parameters.requestId,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.leaseId0
  ],
  responses: {
    201: {
      headersMapper: Mappers.BlobCreateSnapshotHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const startCopyFromURLOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout
  ],
  headerParameters: [
    Parameters.metadata,
    Parameters.copySource,
    Parameters.version,
    Parameters.requestId,
    Parameters.sourceIfModifiedSince,
    Parameters.sourceIfUnmodifiedSince,
    Parameters.sourceIfMatch,
    Parameters.sourceIfNoneMatch,
    Parameters.ifModifiedSince,
    Parameters.ifUnmodifiedSince,
    Parameters.ifMatch,
    Parameters.ifNoneMatch,
    Parameters.leaseId0
  ],
  responses: {
    202: {
      headersMapper: Mappers.BlobStartCopyFromURLHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const abortCopyFromURLOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.copyId,
    Parameters.timeout,
    Parameters.comp8
  ],
  headerParameters: [
    Parameters.version,
    Parameters.requestId,
    Parameters.copyActionAbortConstant,
    Parameters.leaseId0
  ],
  responses: {
    204: {
      headersMapper: Mappers.BlobAbortCopyFromURLHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const setTierOperationSpec: msRest.OperationSpec = {
  httpMethod: "PUT",
  path: "{containerName}/{blob}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.timeout,
    Parameters.comp9
  ],
  headerParameters: [
    Parameters.tier,
    Parameters.version,
    Parameters.requestId,
    Parameters.leaseId0
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobSetTierHeaders
    },
    202: {
      headersMapper: Mappers.BlobSetTierHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};

const getAccountInfoOperationSpec: msRest.OperationSpec = {
  httpMethod: "GET",
  path: "{containerName}/{blobName}",
  urlParameters: [
    Parameters.url
  ],
  queryParameters: [
    Parameters.restype1,
    Parameters.comp0
  ],
  headerParameters: [
    Parameters.version
  ],
  responses: {
    200: {
      headersMapper: Mappers.BlobGetAccountInfoHeaders
    },
    default: {
      bodyMapper: Mappers.StorageError
    }
  },
  isXML: true,
  serializer
};
