/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import { BaseResource, CloudError, AzureServiceClientOptions } from "@azure/ms-rest-azure-js";
import * as msRest from "@azure/ms-rest-js";

export { BaseResource, CloudError };


/**
 * @interface
 * An interface representing PresentationTimeRange.
 * The presentation time range, this is asset related and not recommended for
 * Account Filter.
 *
 */
export interface PresentationTimeRange {
  /**
   * @member {number} [startTimestamp] The absolute start time boundary.
   */
  startTimestamp?: number;
  /**
   * @member {number} [endTimestamp] The absolute end time boundary.
   */
  endTimestamp?: number;
  /**
   * @member {number} [presentationWindowDuration] The relative to end sliding
   * window.
   */
  presentationWindowDuration?: number;
  /**
   * @member {number} [liveBackoffDuration] The relative to end right edge.
   */
  liveBackoffDuration?: number;
  /**
   * @member {number} [timescale] The time scale of time stamps.
   */
  timescale?: number;
  /**
   * @member {boolean} [forceEndTimestamp] The indicator of forcing exsiting of
   * end time stamp.
   */
  forceEndTimestamp?: boolean;
}

/**
 * @interface
 * An interface representing FilterTrackPropertyCondition.
 * The class to specify one track property condition.
 *
 */
export interface FilterTrackPropertyCondition {
  /**
   * @member {FilterTrackPropertyType} property The track property type.
   * Possible values include: 'Unknown', 'Type', 'Name', 'Language', 'FourCC',
   * 'Bitrate'
   */
  property: FilterTrackPropertyType;
  /**
   * @member {string} value The track proprty value.
   */
  value: string;
  /**
   * @member {FilterTrackPropertyCompareOperation} operation The track property
   * condition operation. Possible values include: 'Equal', 'NotEqual'
   */
  operation: FilterTrackPropertyCompareOperation;
}

/**
 * @interface
 * An interface representing FirstQuality.
 * Filter First Quality
 *
 */
export interface FirstQuality {
  /**
   * @member {number} bitrate The first quality bitrate.
   */
  bitrate: number;
}

/**
 * @interface
 * An interface representing FilterTrackSelection.
 * Representing a list of FilterTrackPropertyConditions to select a track.  The
 * filters are combined using a logical AND operation.
 *
 */
export interface FilterTrackSelection {
  /**
   * @member {FilterTrackPropertyCondition[]} trackSelections The track
   * selections.
   */
  trackSelections: FilterTrackPropertyCondition[];
}

/**
 * @interface
 * An interface representing Resource.
 * The core properties of ARM resources.
 *
 * @extends BaseResource
 */
export interface Resource extends BaseResource {
  /**
   * @member {string} [id] Fully qualified resource ID for the resource.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly id?: string;
  /**
   * @member {string} [name] The name of the resource.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly name?: string;
  /**
   * @member {string} [type] The type of the resource.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly type?: string;
}

/**
 * @interface
 * An interface representing ProxyResource.
 * The resource model definition for a ARM proxy resource.
 *
 * @extends Resource
 */
export interface ProxyResource extends Resource {
}

/**
 * @interface
 * An interface representing AccountFilter.
 * An Account Filter.
 *
 * @extends ProxyResource
 */
export interface AccountFilter extends ProxyResource {
  /**
   * @member {PresentationTimeRange} [presentationTimeRange] The presentation
   * time range.
   */
  presentationTimeRange?: PresentationTimeRange;
  /**
   * @member {FirstQuality} [firstQuality] The first quality.
   */
  firstQuality?: FirstQuality;
  /**
   * @member {FilterTrackSelection[]} [tracks] The tracks selection conditions.
   */
  tracks?: FilterTrackSelection[];
}

/**
 * @interface
 * An interface representing ODataError.
 * Information about an error.
 *
 */
export interface ODataError {
  /**
   * @member {string} [code] A language-independent error name.
   */
  code?: string;
  /**
   * @member {string} [message] The error message.
   */
  message?: string;
  /**
   * @member {string} [target] The target of the error (for example, the name
   * of the property in error).
   */
  target?: string;
  /**
   * @member {ODataError[]} [details] The error details.
   */
  details?: ODataError[];
}

/**
 * @interface
 * An interface representing ApiError.
 * The API error.
 *
 */
export interface ApiError {
  /**
   * @member {ODataError} [error] ApiError. The error properties.
   */
  error?: ODataError;
}

/**
 * @interface
 * An interface representing TrackedResource.
 * The resource model definition for a ARM tracked resource.
 *
 * @extends Resource
 */
export interface TrackedResource extends Resource {
  /**
   * @member {{ [propertyName: string]: string }} [tags] Resource tags.
   */
  tags?: { [propertyName: string]: string };
  /**
   * @member {string} [location] The Azure Region of the resource.
   */
  location?: string;
}

/**
 * @interface
 * An interface representing Provider.
 * A resource provider.
 *
 */
export interface Provider {
  /**
   * @member {string} providerName The provider name.
   */
  providerName: string;
}

/**
 * @interface
 * An interface representing OperationDisplay.
 * Operation details.
 *
 */
export interface OperationDisplay {
  /**
   * @member {string} [provider] The service provider.
   */
  provider?: string;
  /**
   * @member {string} [resource] Resource on which the operation is performed.
   */
  resource?: string;
  /**
   * @member {string} [operation] The operation type.
   */
  operation?: string;
  /**
   * @member {string} [description] The operation description.
   */
  description?: string;
}

/**
 * @interface
 * An interface representing MetricDimension.
 * A metric dimension.
 *
 */
export interface MetricDimension {
  /**
   * @member {string} [name] The metric dimension name.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly name?: string;
  /**
   * @member {string} [displayName] The display name for the dimension.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly displayName?: string;
  /**
   * @member {boolean} [toBeExportedForShoebox] Whether to export metric to
   * shoebox.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly toBeExportedForShoebox?: boolean;
}

/**
 * @interface
 * An interface representing Metric.
 * A metric emitted by service.
 *
 */
export interface Metric {
  /**
   * @member {string} [name] The metric name.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly name?: string;
  /**
   * @member {string} [displayName] The metric display name.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly displayName?: string;
  /**
   * @member {string} [displayDescription] The metric display description.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly displayDescription?: string;
  /**
   * @member {MetricUnit} [unit] The metric unit. Possible values include:
   * 'Bytes', 'Count', 'Milliseconds'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly unit?: MetricUnit;
  /**
   * @member {MetricAggregationType} [aggregationType] The metric aggregation
   * type. Possible values include: 'Average', 'Count', 'Total'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly aggregationType?: MetricAggregationType;
  /**
   * @member {MetricDimension[]} [dimensions] The metric dimensions.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly dimensions?: MetricDimension[];
}

/**
 * @interface
 * An interface representing ServiceSpecification.
 * The service metric specifications.
 *
 */
export interface ServiceSpecification {
  /**
   * @member {Metric[]} [metricSpecifications] List of metric specifications.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly metricSpecifications?: Metric[];
}

/**
 * @interface
 * An interface representing MetricProperties.
 * Metric properties.
 *
 */
export interface MetricProperties {
  /**
   * @member {ServiceSpecification} [serviceSpecification] The service
   * specifications.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly serviceSpecification?: ServiceSpecification;
}

/**
 * @interface
 * An interface representing Operation.
 * An operation.
 *
 */
export interface Operation {
  /**
   * @member {string} name The operation name.
   */
  name: string;
  /**
   * @member {OperationDisplay} [display] The operation display name.
   */
  display?: OperationDisplay;
  /**
   * @member {string} [origin] Origin of the operation.
   */
  origin?: string;
  /**
   * @member {MetricProperties} [properties] Operation properties format.
   */
  properties?: MetricProperties;
}

/**
 * @interface
 * An interface representing Location.
 */
export interface Location {
  /**
   * @member {string} name
   */
  name: string;
}

/**
 * @interface
 * An interface representing EntityNameAvailabilityCheckOutput.
 * The response from the check name availability request.
 *
 */
export interface EntityNameAvailabilityCheckOutput {
  /**
   * @member {boolean} nameAvailable Specifies if the name is available.
   */
  nameAvailable: boolean;
  /**
   * @member {string} [reason] Specifies the reason if the name is not
   * available.
   */
  reason?: string;
  /**
   * @member {string} [message] Specifies the detailed reason if the name is
   * not available.
   */
  message?: string;
}

/**
 * @interface
 * An interface representing StorageAccount.
 * The storage account details.
 *
 */
export interface StorageAccount {
  /**
   * @member {string} [id] The ID of the storage account resource. Media
   * Services relies on tables and queues as well as blobs, so the primary
   * storage account must be a Standard Storage account (either
   * Microsoft.ClassicStorage or Microsoft.Storage). Blob only storage accounts
   * can be added as secondary storage accounts.
   */
  id?: string;
  /**
   * @member {StorageAccountType} type The type of the storage account.
   * Possible values include: 'Primary', 'Secondary'
   */
  type: StorageAccountType;
}

/**
 * @interface
 * An interface representing SyncStorageKeysInput.
 * The input to the sync storage keys request.
 *
 */
export interface SyncStorageKeysInput {
  /**
   * @member {string} [id] The ID of the storage account resource.
   */
  id?: string;
}

/**
 * @interface
 * An interface representing MediaService.
 * A Media Services account.
 *
 * @extends TrackedResource
 */
export interface MediaService extends TrackedResource {
  /**
   * @member {string} [mediaServiceId] The Media Services account ID.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly mediaServiceId?: string;
  /**
   * @member {StorageAccount[]} [storageAccounts] The storage accounts for this
   * resource.
   */
  storageAccounts?: StorageAccount[];
}

/**
 * @interface
 * An interface representing SubscriptionMediaService.
 * A Media Services account.
 *
 * @extends TrackedResource
 */
export interface SubscriptionMediaService extends TrackedResource {
  /**
   * @member {string} [mediaServiceId] The Media Services account ID.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly mediaServiceId?: string;
  /**
   * @member {StorageAccount[]} [storageAccounts] The storage accounts for this
   * resource.
   */
  storageAccounts?: StorageAccount[];
}

/**
 * @interface
 * An interface representing CheckNameAvailabilityInput.
 * The input to the check name availability request.
 *
 */
export interface CheckNameAvailabilityInput {
  /**
   * @member {string} [name] The account name.
   */
  name?: string;
  /**
   * @member {string} [type] The account type. For a Media Services account,
   * this should be 'MediaServices'.
   */
  type?: string;
}

/**
 * @interface
 * An interface representing AssetContainerSas.
 * The Asset Storage container SAS URLs.
 *
 */
export interface AssetContainerSas {
  /**
   * @member {string[]} [assetContainerSasUrls] The list of Asset container SAS
   * URLs.
   */
  assetContainerSasUrls?: string[];
}

/**
 * @interface
 * An interface representing AssetFileEncryptionMetadata.
 * The Asset File Storage encryption metadata.
 *
 */
export interface AssetFileEncryptionMetadata {
  /**
   * @member {string} [initializationVector] The Asset File initialization
   * vector.
   */
  initializationVector?: string;
  /**
   * @member {string} [assetFileName] The Asset File name.
   */
  assetFileName?: string;
  /**
   * @member {string} assetFileId The Asset File Id.
   */
  assetFileId: string;
}

/**
 * @interface
 * An interface representing StorageEncryptedAssetDecryptionData.
 * Data needed to decrypt asset files encrypted with legacy storage encryption.
 *
 */
export interface StorageEncryptedAssetDecryptionData {
  /**
   * @member {Uint8Array} [key] The Asset File storage encryption key.
   */
  key?: Uint8Array;
  /**
   * @member {AssetFileEncryptionMetadata[]} [assetFileEncryptionMetadata]
   * Asset File encryption metadata.
   */
  assetFileEncryptionMetadata?: AssetFileEncryptionMetadata[];
}

/**
 * @interface
 * An interface representing AssetStreamingLocator.
 * Properties of the Streaming Locator.
 *
 */
export interface AssetStreamingLocator {
  /**
   * @member {string} [name] Streaming Locator name.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly name?: string;
  /**
   * @member {string} [assetName] Asset Name.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly assetName?: string;
  /**
   * @member {Date} [created] The creation time of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {Date} [startTime] The start time of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly startTime?: Date;
  /**
   * @member {Date} [endTime] The end time of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly endTime?: Date;
  /**
   * @member {string} [streamingLocatorId] StreamingLocatorId of the Streaming
   * Locator.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly streamingLocatorId?: string;
  /**
   * @member {string} [streamingPolicyName] Name of the Streaming Policy used
   * by this Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly streamingPolicyName?: string;
  /**
   * @member {string} [defaultContentKeyPolicyName] Name of the default
   * ContentKeyPolicy used by this Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly defaultContentKeyPolicyName?: string;
}

/**
 * @interface
 * An interface representing ListStreamingLocatorsResponse.
 * The Streaming Locators associated with this Asset.
 *
 */
export interface ListStreamingLocatorsResponse {
  /**
   * @member {AssetStreamingLocator[]} [streamingLocators] The list of
   * Streaming Locators.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly streamingLocators?: AssetStreamingLocator[];
}

/**
 * @interface
 * An interface representing Asset.
 * An Asset.
 *
 * @extends ProxyResource
 */
export interface Asset extends ProxyResource {
  /**
   * @member {string} [assetId] The Asset ID.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly assetId?: string;
  /**
   * @member {Date} [created] The creation date of the Asset.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {Date} [lastModified] The last modified date of the Asset.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly lastModified?: Date;
  /**
   * @member {string} [alternateId] The alternate ID of the Asset.
   */
  alternateId?: string;
  /**
   * @member {string} [description] The Asset description.
   */
  description?: string;
  /**
   * @member {string} [container] The name of the asset blob container.
   */
  container?: string;
  /**
   * @member {string} [storageAccountName] The name of the storage account.
   */
  storageAccountName?: string;
  /**
   * @member {AssetStorageEncryptionFormat} [storageEncryptionFormat] The Asset
   * encryption format. One of None or MediaStorageEncryption. Possible values
   * include: 'None', 'MediaStorageClientEncryption'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly storageEncryptionFormat?: AssetStorageEncryptionFormat;
}

/**
 * @interface
 * An interface representing AssetFilter.
 * An Asset Filter.
 *
 * @extends ProxyResource
 */
export interface AssetFilter extends ProxyResource {
  /**
   * @member {PresentationTimeRange} [presentationTimeRange] The presentation
   * time range.
   */
  presentationTimeRange?: PresentationTimeRange;
  /**
   * @member {FirstQuality} [firstQuality] The first quality.
   */
  firstQuality?: FirstQuality;
  /**
   * @member {FilterTrackSelection[]} [tracks] The tracks selection conditions.
   */
  tracks?: FilterTrackSelection[];
}

/**
 * @interface
 * An interface representing ListContainerSasInput.
 * The parameters to the list SAS request.
 *
 */
export interface ListContainerSasInput {
  /**
   * @member {AssetContainerPermission} [permissions] The permissions to set on
   * the SAS URL. Possible values include: 'Read', 'ReadWrite',
   * 'ReadWriteDelete'
   */
  permissions?: AssetContainerPermission;
  /**
   * @member {Date} [expiryTime] The SAS URL expiration time.  This must be
   * less than 24 hours from the current time.
   */
  expiryTime?: Date;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction.
 * Configures the Explicit Analog Television Output Restriction control bits.
 * For further details see the PlayReady Compliance Rules.
 *
 */
export interface ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction {
  /**
   * @member {boolean} bestEffort Indicates whether this restriction is
   * enforced on a Best Effort basis.
   */
  bestEffort: boolean;
  /**
   * @member {number} configurationData Configures the restriction control
   * bits. Must be between 0 and 3 inclusive.
   */
  configurationData: number;
}

/**
 * Contains the possible cases for ContentKeyPolicyPlayReadyContentKeyLocation.
 */
export type ContentKeyPolicyPlayReadyContentKeyLocationUnion = ContentKeyPolicyPlayReadyContentKeyLocation | ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader | ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier;

/**
 * @interface
 * An interface representing ContentKeyPolicyPlayReadyContentKeyLocation.
 * Base class for content key ID location. A derived class must be used to
 * represent the location.
 *
 */
export interface ContentKeyPolicyPlayReadyContentKeyLocation {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "ContentKeyPolicyPlayReadyContentKeyLocation";
}

/**
 * @interface
 * An interface representing ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader.
 * Specifies that the content key ID is in the PlayReady header.
 *
 */
export interface ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromHeader";
}

/**
 * @interface
 * An interface representing ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier.
 * Specifies that the content key ID is specified in the PlayReady
 * configuration.
 *
 */
export interface ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyPlayReadyContentEncryptionKeyFromKeyIdentifier";
  /**
   * @member {string} keyId The content key ID.
   */
  keyId: string;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyPlayReadyPlayRight.
 * Configures the Play Right in the PlayReady license.
 *
 */
export interface ContentKeyPolicyPlayReadyPlayRight {
  /**
   * @member {string} [firstPlayExpiration] The amount of time that the license
   * is valid after the license is first used to play content.
   */
  firstPlayExpiration?: string;
  /**
   * @member {number} [scmsRestriction] Configures the Serial Copy Management
   * System (SCMS) in the license. Must be between 0 and 3 inclusive.
   */
  scmsRestriction?: number;
  /**
   * @member {number} [agcAndColorStripeRestriction] Configures Automatic Gain
   * Control (AGC) and Color Stripe in the license. Must be between 0 and 3
   * inclusive.
   */
  agcAndColorStripeRestriction?: number;
  /**
   * @member {ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction}
   * [explicitAnalogTelevisionOutputRestriction] Configures the Explicit Analog
   * Television Output Restriction in the license. Configuration data must be
   * between 0 and 3 inclusive.
   */
  explicitAnalogTelevisionOutputRestriction?: ContentKeyPolicyPlayReadyExplicitAnalogTelevisionRestriction;
  /**
   * @member {boolean} digitalVideoOnlyContentRestriction Enables the Image
   * Constraint For Analog Component Video Restriction in the license.
   */
  digitalVideoOnlyContentRestriction: boolean;
  /**
   * @member {boolean} imageConstraintForAnalogComponentVideoRestriction
   * Enables the Image Constraint For Analog Component Video Restriction in the
   * license.
   */
  imageConstraintForAnalogComponentVideoRestriction: boolean;
  /**
   * @member {boolean} imageConstraintForAnalogComputerMonitorRestriction
   * Enables the Image Constraint For Analog Component Video Restriction in the
   * license.
   */
  imageConstraintForAnalogComputerMonitorRestriction: boolean;
  /**
   * @member {ContentKeyPolicyPlayReadyUnknownOutputPassingOption}
   * allowPassingVideoContentToUnknownOutput Configures Unknown output handling
   * settings of the license. Possible values include: 'Unknown', 'NotAllowed',
   * 'Allowed', 'AllowedWithVideoConstriction'
   */
  allowPassingVideoContentToUnknownOutput: ContentKeyPolicyPlayReadyUnknownOutputPassingOption;
  /**
   * @member {number} [uncompressedDigitalVideoOpl] Specifies the output
   * protection level for uncompressed digital video.
   */
  uncompressedDigitalVideoOpl?: number;
  /**
   * @member {number} [compressedDigitalVideoOpl] Specifies the output
   * protection level for compressed digital video.
   */
  compressedDigitalVideoOpl?: number;
  /**
   * @member {number} [analogVideoOpl] Specifies the output protection level
   * for compressed digital audio.
   */
  analogVideoOpl?: number;
  /**
   * @member {number} [compressedDigitalAudioOpl] Specifies the output
   * protection level for compressed digital audio.
   */
  compressedDigitalAudioOpl?: number;
  /**
   * @member {number} [uncompressedDigitalAudioOpl] Specifies the output
   * protection level for uncompressed digital audio.
   */
  uncompressedDigitalAudioOpl?: number;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyTokenClaim.
 * Represents a token claim.
 *
 */
export interface ContentKeyPolicyTokenClaim {
  /**
   * @member {string} [claimType] Token claim type.
   */
  claimType?: string;
  /**
   * @member {string} [claimValue] Token claim value.
   */
  claimValue?: string;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyPlayReadyLicense.
 * The PlayReady license
 *
 */
export interface ContentKeyPolicyPlayReadyLicense {
  /**
   * @member {boolean} allowTestDevices A flag indicating whether test devices
   * can use the license.
   */
  allowTestDevices: boolean;
  /**
   * @member {Date} [beginDate] The begin date of license
   */
  beginDate?: Date;
  /**
   * @member {Date} [expirationDate] The expiration date of license.
   */
  expirationDate?: Date;
  /**
   * @member {string} [relativeBeginDate] The relative begin date of license.
   */
  relativeBeginDate?: string;
  /**
   * @member {string} [relativeExpirationDate] The relative expiration date of
   * license.
   */
  relativeExpirationDate?: string;
  /**
   * @member {string} [gracePeriod] The grace period of license.
   */
  gracePeriod?: string;
  /**
   * @member {ContentKeyPolicyPlayReadyPlayRight} [playRight] The license
   * PlayRight
   */
  playRight?: ContentKeyPolicyPlayReadyPlayRight;
  /**
   * @member {ContentKeyPolicyPlayReadyLicenseType} licenseType The license
   * type. Possible values include: 'Unknown', 'NonPersistent', 'Persistent'
   */
  licenseType: ContentKeyPolicyPlayReadyLicenseType;
  /**
   * @member {ContentKeyPolicyPlayReadyContentKeyLocationUnion}
   * contentKeyLocation The content key location.
   */
  contentKeyLocation: ContentKeyPolicyPlayReadyContentKeyLocationUnion;
  /**
   * @member {ContentKeyPolicyPlayReadyContentType} contentType The PlayReady
   * content type. Possible values include: 'Unknown', 'Unspecified',
   * 'UltraVioletDownload', 'UltraVioletStreaming'
   */
  contentType: ContentKeyPolicyPlayReadyContentType;
}

/**
 * Contains the possible cases for ContentKeyPolicyRestriction.
 */
export type ContentKeyPolicyRestrictionUnion = ContentKeyPolicyRestriction | ContentKeyPolicyOpenRestriction | ContentKeyPolicyUnknownRestriction | ContentKeyPolicyTokenRestriction;

/**
 * @interface
 * An interface representing ContentKeyPolicyRestriction.
 * Base class for Content Key Policy restrictions. A derived class must be used
 * to create a restriction.
 *
 */
export interface ContentKeyPolicyRestriction {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "ContentKeyPolicyRestriction";
}

/**
 * @interface
 * An interface representing ContentKeyPolicyOpenRestriction.
 * Represents an open restriction. License or key will be delivered on every
 * request.
 *
 */
export interface ContentKeyPolicyOpenRestriction {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyOpenRestriction";
}

/**
 * @interface
 * An interface representing ContentKeyPolicyUnknownRestriction.
 * Represents a ContentKeyPolicyRestriction that is unavailable in the current
 * API version.
 *
 */
export interface ContentKeyPolicyUnknownRestriction {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyUnknownRestriction";
}

/**
 * Contains the possible cases for ContentKeyPolicyConfiguration.
 */
export type ContentKeyPolicyConfigurationUnion = ContentKeyPolicyConfiguration | ContentKeyPolicyClearKeyConfiguration | ContentKeyPolicyUnknownConfiguration | ContentKeyPolicyWidevineConfiguration | ContentKeyPolicyPlayReadyConfiguration | ContentKeyPolicyFairPlayConfiguration;

/**
 * @interface
 * An interface representing ContentKeyPolicyConfiguration.
 * Base class for Content Key Policy configuration. A derived class must be
 * used to create a configuration.
 *
 */
export interface ContentKeyPolicyConfiguration {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "ContentKeyPolicyConfiguration";
}

/**
 * Contains the possible cases for ContentKeyPolicyRestrictionTokenKey.
 */
export type ContentKeyPolicyRestrictionTokenKeyUnion = ContentKeyPolicyRestrictionTokenKey | ContentKeyPolicySymmetricTokenKey | ContentKeyPolicyRsaTokenKey | ContentKeyPolicyX509CertificateTokenKey;

/**
 * @interface
 * An interface representing ContentKeyPolicyRestrictionTokenKey.
 * Base class for Content Key Policy key for token validation. A derived class
 * must be used to create a token key.
 *
 */
export interface ContentKeyPolicyRestrictionTokenKey {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "ContentKeyPolicyRestrictionTokenKey";
}

/**
 * @interface
 * An interface representing ContentKeyPolicySymmetricTokenKey.
 * Specifies a symmetric key for token validation.
 *
 */
export interface ContentKeyPolicySymmetricTokenKey {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicySymmetricTokenKey";
  /**
   * @member {Uint8Array} keyValue The key value of the key
   */
  keyValue: Uint8Array;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyRsaTokenKey.
 * Specifies a RSA key for token validation
 *
 */
export interface ContentKeyPolicyRsaTokenKey {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyRsaTokenKey";
  /**
   * @member {Uint8Array} exponent The RSA Parameter exponent
   */
  exponent: Uint8Array;
  /**
   * @member {Uint8Array} modulus The RSA Parameter modulus
   */
  modulus: Uint8Array;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyX509CertificateTokenKey.
 * Specifies a certificate for token validation.
 *
 */
export interface ContentKeyPolicyX509CertificateTokenKey {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyX509CertificateTokenKey";
  /**
   * @member {Uint8Array} rawBody The raw data field of a certificate in PKCS
   * 12 format (X509Certificate2 in .NET)
   */
  rawBody: Uint8Array;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyTokenRestriction.
 * Represents a token restriction. Provided token must match these requirements
 * for successful license or key delivery.
 *
 */
export interface ContentKeyPolicyTokenRestriction {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyTokenRestriction";
  /**
   * @member {string} issuer The token issuer.
   */
  issuer: string;
  /**
   * @member {string} audience The audience for the token.
   */
  audience: string;
  /**
   * @member {ContentKeyPolicyRestrictionTokenKeyUnion} primaryVerificationKey
   * The primary verification key.
   */
  primaryVerificationKey: ContentKeyPolicyRestrictionTokenKeyUnion;
  /**
   * @member {ContentKeyPolicyRestrictionTokenKeyUnion[]}
   * [alternateVerificationKeys] A list of alternative verification keys.
   */
  alternateVerificationKeys?: ContentKeyPolicyRestrictionTokenKeyUnion[];
  /**
   * @member {ContentKeyPolicyTokenClaim[]} [requiredClaims] A list of required
   * token claims.
   */
  requiredClaims?: ContentKeyPolicyTokenClaim[];
  /**
   * @member {ContentKeyPolicyRestrictionTokenType} restrictionTokenType The
   * type of token. Possible values include: 'Unknown', 'Swt', 'Jwt'
   */
  restrictionTokenType: ContentKeyPolicyRestrictionTokenType;
  /**
   * @member {string} [openIdConnectDiscoveryDocument] The OpenID connect
   * discovery document.
   */
  openIdConnectDiscoveryDocument?: string;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyClearKeyConfiguration.
 * Represents a configuration for non-DRM keys.
 *
 */
export interface ContentKeyPolicyClearKeyConfiguration {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyClearKeyConfiguration";
}

/**
 * @interface
 * An interface representing ContentKeyPolicyUnknownConfiguration.
 * Represents a ContentKeyPolicyConfiguration that is unavailable in the
 * current API version.
 *
 */
export interface ContentKeyPolicyUnknownConfiguration {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyUnknownConfiguration";
}

/**
 * @interface
 * An interface representing ContentKeyPolicyWidevineConfiguration.
 * Specifies a configuration for Widevine licenses.
 *
 */
export interface ContentKeyPolicyWidevineConfiguration {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyWidevineConfiguration";
  /**
   * @member {string} widevineTemplate The Widevine template.
   */
  widevineTemplate: string;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyPlayReadyConfiguration.
 * Specifies a configuration for PlayReady licenses.
 *
 */
export interface ContentKeyPolicyPlayReadyConfiguration {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyPlayReadyConfiguration";
  /**
   * @member {ContentKeyPolicyPlayReadyLicense[]} licenses The PlayReady
   * licenses.
   */
  licenses: ContentKeyPolicyPlayReadyLicense[];
  /**
   * @member {string} [responseCustomData] The custom response data.
   */
  responseCustomData?: string;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyFairPlayConfiguration.
 * Specifies a configuration for FairPlay licenses.
 *
 */
export interface ContentKeyPolicyFairPlayConfiguration {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ContentKeyPolicyFairPlayConfiguration";
  /**
   * @member {Uint8Array} ask The key that must be used as FairPlay Application
   * Secret key.
   */
  ask: Uint8Array;
  /**
   * @member {string} fairPlayPfxPassword The password encrypting FairPlay
   * certificate in PKCS 12 (pfx) format.
   */
  fairPlayPfxPassword: string;
  /**
   * @member {string} fairPlayPfx The Base64 representation of FairPlay
   * certificate in PKCS 12 (pfx) format (including private key).
   */
  fairPlayPfx: string;
  /**
   * @member {ContentKeyPolicyFairPlayRentalAndLeaseKeyType}
   * rentalAndLeaseKeyType The rental and lease key type. Possible values
   * include: 'Unknown', 'Undefined', 'PersistentUnlimited',
   * 'PersistentLimited'
   */
  rentalAndLeaseKeyType: ContentKeyPolicyFairPlayRentalAndLeaseKeyType;
  /**
   * @member {number} rentalDuration The rental duration. Must be greater than
   * or equal to 0.
   */
  rentalDuration: number;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyOption.
 * Represents a policy option.
 *
 */
export interface ContentKeyPolicyOption {
  /**
   * @member {string} [policyOptionId] The legacy Policy Option ID.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly policyOptionId?: string;
  /**
   * @member {string} [name] The Policy Option description.
   */
  name?: string;
  /**
   * @member {ContentKeyPolicyConfigurationUnion} configuration The key
   * delivery configuration.
   */
  configuration: ContentKeyPolicyConfigurationUnion;
  /**
   * @member {ContentKeyPolicyRestrictionUnion} restriction The requirements
   * that must be met to deliver keys with this configuration
   */
  restriction: ContentKeyPolicyRestrictionUnion;
}

/**
 * @interface
 * An interface representing ContentKeyPolicyProperties.
 * The properties of the Content Key Policy.
 *
 */
export interface ContentKeyPolicyProperties {
  /**
   * @member {string} [policyId] The legacy Policy ID.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly policyId?: string;
  /**
   * @member {Date} [created] The creation date of the Policy
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {Date} [lastModified] The last modified date of the Policy
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly lastModified?: Date;
  /**
   * @member {string} [description] A description for the Policy.
   */
  description?: string;
  /**
   * @member {ContentKeyPolicyOption[]} options The Key Policy options.
   */
  options: ContentKeyPolicyOption[];
}

/**
 * @interface
 * An interface representing ContentKeyPolicy.
 * A Content Key Policy resource.
 *
 * @extends ProxyResource
 */
export interface ContentKeyPolicy extends ProxyResource {
  /**
   * @member {string} [policyId] The legacy Policy ID.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly policyId?: string;
  /**
   * @member {Date} [created] The creation date of the Policy
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {Date} [lastModified] The last modified date of the Policy
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly lastModified?: Date;
  /**
   * @member {string} [description] A description for the Policy.
   */
  description?: string;
  /**
   * @member {ContentKeyPolicyOption[]} options The Key Policy options.
   */
  options: ContentKeyPolicyOption[];
}

/**
 * Contains the possible cases for Preset.
 */
export type PresetUnion = Preset | AudioAnalyzerPresetUnion | BuiltInStandardEncoderPreset | StandardEncoderPreset;

/**
 * @interface
 * An interface representing Preset.
 * Base type for all Presets, which define the recipe or instructions on how
 * the input media files should be processed.
 *
 */
export interface Preset {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "Preset";
}

/**
 * Contains the possible cases for Codec.
 */
export type CodecUnion = Codec | AudioUnion | CopyVideo | VideoUnion | CopyAudio;

/**
 * @interface
 * An interface representing Codec.
 * Describes the basic properties of all codecs.
 *
 */
export interface Codec {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "Codec";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
}

/**
 * Contains the possible cases for Audio.
 */
export type AudioUnion = Audio | AacAudio;

/**
 * @interface
 * An interface representing Audio.
 * Defines the common properties for all audio codecs.
 *
 */
export interface Audio {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.Audio";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
  /**
   * @member {number} [channels] The number of channels in the audio.
   */
  channels?: number;
  /**
   * @member {number} [samplingRate] The sampling rate to use for encoding in
   * hertz.
   */
  samplingRate?: number;
  /**
   * @member {number} [bitrate] The bitrate, in bits per second, of the output
   * encoded audio.
   */
  bitrate?: number;
}

/**
 * @interface
 * An interface representing AacAudio.
 * Describes Advanced Audio Codec (AAC) audio encoding settings.
 *
 */
export interface AacAudio {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.AacAudio";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
  /**
   * @member {number} [channels] The number of channels in the audio.
   */
  channels?: number;
  /**
   * @member {number} [samplingRate] The sampling rate to use for encoding in
   * hertz.
   */
  samplingRate?: number;
  /**
   * @member {number} [bitrate] The bitrate, in bits per second, of the output
   * encoded audio.
   */
  bitrate?: number;
  /**
   * @member {AacAudioProfile} [profile] The encoding profile to be used when
   * encoding audio with AAC. Possible values include: 'AacLc', 'HeAacV1',
   * 'HeAacV2'
   */
  profile?: AacAudioProfile;
}

/**
 * Contains the possible cases for AudioAnalyzerPreset.
 */
export type AudioAnalyzerPresetUnion = AudioAnalyzerPreset | VideoAnalyzerPreset;

/**
 * @interface
 * An interface representing AudioAnalyzerPreset.
 * The Audio Analyzer preset applies a pre-defined set of AI-based analysis
 * operations, including speech transcription. Currently, the preset supports
 * processing of content with a single audio track.
 *
 */
export interface AudioAnalyzerPreset {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.AudioAnalyzerPreset";
  /**
   * @member {string} [audioLanguage] The language for the audio payload in the
   * input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). The
   * list of supported languages are, 'en-US', 'en-GB', 'es-ES', 'es-MX',
   * 'fr-FR', 'it-IT', 'ja-JP', 'pt-BR', 'zh-CN', 'de-DE', 'ar-EG', 'ru-RU',
   * 'hi-IN'. If not specified, automatic language detection would be employed.
   * This feature currently supports English, Chinese, French, German, Italian,
   * Japanese, Spanish, Russian, and Portuguese. The automatic detection works
   * best with audio recordings with clearly discernable speech. If automatic
   * detection fails to find the language, transcription would fallback to
   * English.
   */
  audioLanguage?: string;
}

/**
 * Contains the possible cases for Overlay.
 */
export type OverlayUnion = Overlay | AudioOverlay | VideoOverlay;

/**
 * @interface
 * An interface representing Overlay.
 * Base type for all overlays - image, audio or video.
 *
 */
export interface Overlay {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "Overlay";
  /**
   * @member {string} [inputLabel] The label of the job input which is to be
   * used as an overlay. The Input must specify exactly one file. You can
   * specify an image file in JPG or PNG formats, or an audio file (such as a
   * WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats
   * for the complete list of supported audio and video file formats.
   */
  inputLabel?: string;
  /**
   * @member {string} [start] The start position, with reference to the input
   * video, at which the overlay starts. The value should be in ISO 8601
   * format. For example, PT05S to start the overlay at 5 seconds in to the
   * input video. If not specified the overlay starts from the beginning of the
   * input video.
   */
  start?: string;
  /**
   * @member {string} [end] The position in the input video at which the
   * overlay ends. The value should be in ISO 8601 duration format. For
   * example, PT30S to end the overlay at 30 seconds in to the input video. If
   * not specified the overlay will be applied until the end of the input video
   * if inputLoop is true. Else, if inputLoop is false, then overlay will last
   * as long as the duration of the overlay media.
   */
  end?: string;
  /**
   * @member {string} [fadeInDuration] The duration over which the overlay
   * fades in onto the input video. The value should be in ISO 8601 duration
   * format. If not specified the default behavior is to have no fade in (same
   * as PT0S).
   */
  fadeInDuration?: string;
  /**
   * @member {string} [fadeOutDuration] The duration over which the overlay
   * fades out of the input video. The value should be in ISO 8601 duration
   * format. If not specified the default behavior is to have no fade out (same
   * as PT0S).
   */
  fadeOutDuration?: string;
  /**
   * @member {number} [audioGainLevel] The gain level of audio in the overlay.
   * The value should be in the range [0, 1.0]. The default is 1.0.
   */
  audioGainLevel?: number;
}

/**
 * @interface
 * An interface representing AudioOverlay.
 * Describes the properties of an audio overlay.
 *
 */
export interface AudioOverlay {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.AudioOverlay";
  /**
   * @member {string} [inputLabel] The label of the job input which is to be
   * used as an overlay. The Input must specify exactly one file. You can
   * specify an image file in JPG or PNG formats, or an audio file (such as a
   * WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats
   * for the complete list of supported audio and video file formats.
   */
  inputLabel?: string;
  /**
   * @member {string} [start] The start position, with reference to the input
   * video, at which the overlay starts. The value should be in ISO 8601
   * format. For example, PT05S to start the overlay at 5 seconds in to the
   * input video. If not specified the overlay starts from the beginning of the
   * input video.
   */
  start?: string;
  /**
   * @member {string} [end] The position in the input video at which the
   * overlay ends. The value should be in ISO 8601 duration format. For
   * example, PT30S to end the overlay at 30 seconds in to the input video. If
   * not specified the overlay will be applied until the end of the input video
   * if inputLoop is true. Else, if inputLoop is false, then overlay will last
   * as long as the duration of the overlay media.
   */
  end?: string;
  /**
   * @member {string} [fadeInDuration] The duration over which the overlay
   * fades in onto the input video. The value should be in ISO 8601 duration
   * format. If not specified the default behavior is to have no fade in (same
   * as PT0S).
   */
  fadeInDuration?: string;
  /**
   * @member {string} [fadeOutDuration] The duration over which the overlay
   * fades out of the input video. The value should be in ISO 8601 duration
   * format. If not specified the default behavior is to have no fade out (same
   * as PT0S).
   */
  fadeOutDuration?: string;
  /**
   * @member {number} [audioGainLevel] The gain level of audio in the overlay.
   * The value should be in the range [0, 1.0]. The default is 1.0.
   */
  audioGainLevel?: number;
}

/**
 * @interface
 * An interface representing CopyVideo.
 * A codec flag, which tells the encoder to copy the input video bitstream
 * without re-encoding.
 *
 */
export interface CopyVideo {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.CopyVideo";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
}

/**
 * Contains the possible cases for Video.
 */
export type VideoUnion = Video | ImageUnion | H264Video;

/**
 * @interface
 * An interface representing Video.
 * Describes the basic properties for encoding the input video.
 *
 */
export interface Video {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.Video";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
  /**
   * @member {string} [keyFrameInterval] The distance between two key frames,
   * thereby defining a group of pictures (GOP). The value should be a non-zero
   * integer in the range [1, 30] seconds, specified in ISO 8601 format. The
   * default is 2 seconds (PT2S).
   */
  keyFrameInterval?: string;
  /**
   * @member {StretchMode} [stretchMode] The resizing mode - how the input
   * video will be resized to fit the desired output resolution(s). Default is
   * AutoSize. Possible values include: 'None', 'AutoSize', 'AutoFit'
   */
  stretchMode?: StretchMode;
}

/**
 * Contains the possible cases for Image.
 */
export type ImageUnion = Image | JpgImage | PngImage;

/**
 * @interface
 * An interface representing Image.
 * Describes the basic properties for generating thumbnails from the input
 * video
 *
 */
export interface Image {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.Image";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
  /**
   * @member {string} [keyFrameInterval] The distance between two key frames,
   * thereby defining a group of pictures (GOP). The value should be a non-zero
   * integer in the range [1, 30] seconds, specified in ISO 8601 format. The
   * default is 2 seconds (PT2S).
   */
  keyFrameInterval?: string;
  /**
   * @member {StretchMode} [stretchMode] The resizing mode - how the input
   * video will be resized to fit the desired output resolution(s). Default is
   * AutoSize. Possible values include: 'None', 'AutoSize', 'AutoFit'
   */
  stretchMode?: StretchMode;
  /**
   * @member {string} [start] The position in the input video from where to
   * start generating thumbnails. The value can be in absolute timestamp (ISO
   * 8601, e.g: PT05S), or a frame count (For example, 10 for the 10th frame),
   * or a relative value (For example, 1%). Also supports a macro {Best}, which
   * tells the encoder to select the best thumbnail from the first few seconds
   * of the video.
   */
  start?: string;
  /**
   * @member {string} [step] The intervals at which thumbnails are generated.
   * The value can be in absolute timestamp (ISO 8601, e.g: PT05S for one image
   * every 5 seconds), or a frame count (For example, 30 for every 30 frames),
   * or a relative value (For example, 1%).
   */
  step?: string;
  /**
   * @member {string} [range] The position in the input video at which to stop
   * generating thumbnails. The value can be in absolute timestamp (ISO 8601,
   * e.g: PT5M30S to stop at 5 minutes and 30 seconds), or a frame count (For
   * example, 300 to stop at the 300th frame), or a relative value (For
   * example, 100%).
   */
  range?: string;
}

/**
 * Contains the possible cases for Format.
 */
export type FormatUnion = Format | ImageFormatUnion | MultiBitrateFormatUnion;

/**
 * @interface
 * An interface representing Format.
 * Base class for output.
 *
 */
export interface Format {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "Format";
  /**
   * @member {string} [filenamePattern] The pattern of the file names for the
   * generated output files. The following macros are supported in the file
   * name: {Basename} - The base name of the input video {Extension} - The
   * appropriate extension for this format. {Label} - The label assigned to the
   * codec/layer. {Index} - A unique index for thumbnails. Only applicable to
   * thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to
   * thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted
   * macros will be collapsed and removed from the filename.
   */
  filenamePattern?: string;
}

/**
 * Contains the possible cases for ImageFormat.
 */
export type ImageFormatUnion = ImageFormat | JpgFormat | PngFormat;

/**
 * @interface
 * An interface representing ImageFormat.
 * Describes the properties for an output image file.
 *
 */
export interface ImageFormat {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.ImageFormat";
  /**
   * @member {string} [filenamePattern] The pattern of the file names for the
   * generated output files. The following macros are supported in the file
   * name: {Basename} - The base name of the input video {Extension} - The
   * appropriate extension for this format. {Label} - The label assigned to the
   * codec/layer. {Index} - A unique index for thumbnails. Only applicable to
   * thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to
   * thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted
   * macros will be collapsed and removed from the filename.
   */
  filenamePattern?: string;
}

/**
 * @interface
 * An interface representing JpgFormat.
 * Describes the settings for producing JPEG thumbnails.
 *
 */
export interface JpgFormat {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.JpgFormat";
  /**
   * @member {string} [filenamePattern] The pattern of the file names for the
   * generated output files. The following macros are supported in the file
   * name: {Basename} - The base name of the input video {Extension} - The
   * appropriate extension for this format. {Label} - The label assigned to the
   * codec/layer. {Index} - A unique index for thumbnails. Only applicable to
   * thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to
   * thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted
   * macros will be collapsed and removed from the filename.
   */
  filenamePattern?: string;
}

/**
 * @interface
 * An interface representing PngFormat.
 * Describes the settings for producing PNG thumbnails.
 *
 */
export interface PngFormat {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.PngFormat";
  /**
   * @member {string} [filenamePattern] The pattern of the file names for the
   * generated output files. The following macros are supported in the file
   * name: {Basename} - The base name of the input video {Extension} - The
   * appropriate extension for this format. {Label} - The label assigned to the
   * codec/layer. {Index} - A unique index for thumbnails. Only applicable to
   * thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to
   * thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted
   * macros will be collapsed and removed from the filename.
   */
  filenamePattern?: string;
}

/**
 * @interface
 * An interface representing CopyAudio.
 * A codec flag, which tells the encoder to copy the input audio bitstream.
 *
 */
export interface CopyAudio {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.CopyAudio";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
}

/**
 * @interface
 * An interface representing Deinterlace.
 * Describes the de-interlacing settings.
 *
 */
export interface Deinterlace {
  /**
   * @member {DeinterlaceParity} [parity] The field parity for de-interlacing,
   * defaults to Auto. Possible values include: 'Auto', 'TopFieldFirst',
   * 'BottomFieldFirst'
   */
  parity?: DeinterlaceParity;
  /**
   * @member {DeinterlaceMode} [mode] The deinterlacing mode. Defaults to
   * AutoPixelAdaptive. Possible values include: 'Off', 'AutoPixelAdaptive'
   */
  mode?: DeinterlaceMode;
}

/**
 * @interface
 * An interface representing Rectangle.
 * Describes the properties of a rectangular window applied to the input media
 * before processing it.
 *
 */
export interface Rectangle {
  /**
   * @member {string} [left] The number of pixels from the left-margin. This
   * can be absolute pixel value (e.g 100), or relative to the size of the
   * video (For example, 50%).
   */
  left?: string;
  /**
   * @member {string} [top] The number of pixels from the top-margin. This can
   * be absolute pixel value (e.g 100), or relative to the size of the video
   * (For example, 50%).
   */
  top?: string;
  /**
   * @member {string} [width] The width of the rectangular region in pixels.
   * This can be absolute pixel value (e.g 100), or relative to the size of the
   * video (For example, 50%).
   */
  width?: string;
  /**
   * @member {string} [height] The height of the rectangular region in pixels.
   * This can be absolute pixel value (e.g 100), or relative to the size of the
   * video (For example, 50%).
   */
  height?: string;
}

/**
 * @interface
 * An interface representing Filters.
 * Describes all the filtering operations, such as de-interlacing, rotation
 * etc. that are to be applied to the input media before encoding.
 *
 */
export interface Filters {
  /**
   * @member {Deinterlace} [deinterlace] The de-interlacing settings.
   */
  deinterlace?: Deinterlace;
  /**
   * @member {Rotation} [rotation] The rotation, if any, to be applied to the
   * input video, before it is encoded. Default is Auto. Possible values
   * include: 'Auto', 'None', 'Rotate0', 'Rotate90', 'Rotate180', 'Rotate270'
   */
  rotation?: Rotation;
  /**
   * @member {Rectangle} [crop] The parameters for the rectangular window with
   * which to crop the input video.
   */
  crop?: Rectangle;
  /**
   * @member {OverlayUnion[]} [overlays] The properties of overlays to be
   * applied to the input video. These could be audio, image or video overlays.
   */
  overlays?: OverlayUnion[];
}

/**
 * Contains the possible cases for Layer.
 */
export type LayerUnion = Layer | VideoLayerUnion | JpgLayer | PngLayer;

/**
 * @interface
 * An interface representing Layer.
 * The encoder can be configured to produce video and/or images (thumbnails) at
 * different resolutions, by specifying a layer for each desired resolution. A
 * layer represents the properties for the video or image at a resolution.
 *
 */
export interface Layer {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "Layer";
  /**
   * @member {string} [width] The width of the output video for this layer. The
   * value can be absolute (in pixels) or relative (in percentage). For example
   * 50% means the output video has half as many pixels in width as the input.
   */
  width?: string;
  /**
   * @member {string} [height] The height of the output video for this layer.
   * The value can be absolute (in pixels) or relative (in percentage). For
   * example 50% means the output video has half as many pixels in height as
   * the input.
   */
  height?: string;
  /**
   * @member {string} [label] The alphanumeric label for this layer, which can
   * be used in multiplexing different video and audio layers, or in naming the
   * output file.
   */
  label?: string;
}

/**
 * Contains the possible cases for VideoLayer.
 */
export type VideoLayerUnion = VideoLayer | H264Layer;

/**
 * @interface
 * An interface representing VideoLayer.
 * Describes the settings to be used when encoding the input video into a
 * desired output bitrate layer.
 *
 */
export interface VideoLayer {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.VideoLayer";
  /**
   * @member {string} [width] The width of the output video for this layer. The
   * value can be absolute (in pixels) or relative (in percentage). For example
   * 50% means the output video has half as many pixels in width as the input.
   */
  width?: string;
  /**
   * @member {string} [height] The height of the output video for this layer.
   * The value can be absolute (in pixels) or relative (in percentage). For
   * example 50% means the output video has half as many pixels in height as
   * the input.
   */
  height?: string;
  /**
   * @member {string} [label] The alphanumeric label for this layer, which can
   * be used in multiplexing different video and audio layers, or in naming the
   * output file.
   */
  label?: string;
  /**
   * @member {number} [bitrate] The average bitrate in bits per second at which
   * to encode the input video when generating this layer. This is a required
   * field.
   */
  bitrate?: number;
  /**
   * @member {number} [maxBitrate] The maximum bitrate (in bits per second), at
   * which the VBV buffer should be assumed to refill. If not specified,
   * defaults to the same value as bitrate.
   */
  maxBitrate?: number;
  /**
   * @member {number} [bFrames] The number of B-frames to be used when encoding
   * this layer.  If not specified, the encoder chooses an appropriate number
   * based on the video profile and level.
   */
  bFrames?: number;
  /**
   * @member {string} [frameRate] The frame rate (in frames per second) at
   * which to encode this layer. The value can be in the form of M/N where M
   * and N are integers (For example, 30000/1001), or in the form of a number
   * (For example, 30, or 29.97). The encoder enforces constraints on allowed
   * frame rates based on the profile and level. If it is not specified, the
   * encoder will use the same frame rate as the input video.
   */
  frameRate?: string;
  /**
   * @member {number} [slices] The number of slices to be used when encoding
   * this layer. If not specified, default is zero, which means that encoder
   * will use a single slice for each frame.
   */
  slices?: number;
  /**
   * @member {boolean} [adaptiveBFrame] Whether or not adaptive B-frames are to
   * be used when encoding this layer. If not specified, the encoder will turn
   * it on whenever the video profile permits its use.
   */
  adaptiveBFrame?: boolean;
}

/**
 * @interface
 * An interface representing H264Layer.
 * Describes the settings to be used when encoding the input video into a
 * desired output bitrate layer with the H.264 video codec.
 *
 */
export interface H264Layer {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.H264Layer";
  /**
   * @member {string} [width] The width of the output video for this layer. The
   * value can be absolute (in pixels) or relative (in percentage). For example
   * 50% means the output video has half as many pixels in width as the input.
   */
  width?: string;
  /**
   * @member {string} [height] The height of the output video for this layer.
   * The value can be absolute (in pixels) or relative (in percentage). For
   * example 50% means the output video has half as many pixels in height as
   * the input.
   */
  height?: string;
  /**
   * @member {string} [label] The alphanumeric label for this layer, which can
   * be used in multiplexing different video and audio layers, or in naming the
   * output file.
   */
  label?: string;
  /**
   * @member {number} [bitrate] The average bitrate in bits per second at which
   * to encode the input video when generating this layer. This is a required
   * field.
   */
  bitrate?: number;
  /**
   * @member {number} [maxBitrate] The maximum bitrate (in bits per second), at
   * which the VBV buffer should be assumed to refill. If not specified,
   * defaults to the same value as bitrate.
   */
  maxBitrate?: number;
  /**
   * @member {number} [bFrames] The number of B-frames to be used when encoding
   * this layer.  If not specified, the encoder chooses an appropriate number
   * based on the video profile and level.
   */
  bFrames?: number;
  /**
   * @member {string} [frameRate] The frame rate (in frames per second) at
   * which to encode this layer. The value can be in the form of M/N where M
   * and N are integers (For example, 30000/1001), or in the form of a number
   * (For example, 30, or 29.97). The encoder enforces constraints on allowed
   * frame rates based on the profile and level. If it is not specified, the
   * encoder will use the same frame rate as the input video.
   */
  frameRate?: string;
  /**
   * @member {number} [slices] The number of slices to be used when encoding
   * this layer. If not specified, default is zero, which means that encoder
   * will use a single slice for each frame.
   */
  slices?: number;
  /**
   * @member {boolean} [adaptiveBFrame] Whether or not adaptive B-frames are to
   * be used when encoding this layer. If not specified, the encoder will turn
   * it on whenever the video profile permits its use.
   */
  adaptiveBFrame?: boolean;
  /**
   * @member {H264VideoProfile} [profile] Which profile of the H.264 standard
   * should be used when encoding this layer. Default is Auto. Possible values
   * include: 'Auto', 'Baseline', 'Main', 'High', 'High422', 'High444'
   */
  profile?: H264VideoProfile;
  /**
   * @member {string} [level] Which level of the H.264 standard should be used
   * when encoding this layer. The value can be Auto, or a number that matches
   * the H.264 profile. If not specified, the default is Auto, which lets the
   * encoder choose the Level that is appropriate for this layer.
   */
  level?: string;
  /**
   * @member {string} [bufferWindow] The VBV buffer window length. The value
   * should be in ISO 8601 format. The value should be in the range [0.1-100]
   * seconds. The default is 5 seconds (for example, PT5S).
   */
  bufferWindow?: string;
  /**
   * @member {number} [referenceFrames] The number of reference frames to be
   * used when encoding this layer. If not specified, the encoder determines an
   * appropriate number based on the encoder complexity setting.
   */
  referenceFrames?: number;
  /**
   * @member {EntropyMode} [entropyMode] The entropy mode to be used for this
   * layer. If not specified, the encoder chooses the mode that is appropriate
   * for the profile and level. Possible values include: 'Cabac', 'Cavlc'
   */
  entropyMode?: EntropyMode;
}

/**
 * @interface
 * An interface representing H264Video.
 * Describes all the properties for encoding a video with the H.264 codec.
 *
 */
export interface H264Video {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.H264Video";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
  /**
   * @member {string} [keyFrameInterval] The distance between two key frames,
   * thereby defining a group of pictures (GOP). The value should be a non-zero
   * integer in the range [1, 30] seconds, specified in ISO 8601 format. The
   * default is 2 seconds (PT2S).
   */
  keyFrameInterval?: string;
  /**
   * @member {StretchMode} [stretchMode] The resizing mode - how the input
   * video will be resized to fit the desired output resolution(s). Default is
   * AutoSize. Possible values include: 'None', 'AutoSize', 'AutoFit'
   */
  stretchMode?: StretchMode;
  /**
   * @member {boolean} [sceneChangeDetection] Whether or not the encoder should
   * insert key frames at scene changes. If not specified, the default is
   * false. This flag should be set to true only when the encoder is being
   * configured to produce a single output video.
   */
  sceneChangeDetection?: boolean;
  /**
   * @member {H264Complexity} [complexity] Tells the encoder how to choose its
   * encoding settings. The default value is Balanced. Possible values include:
   * 'Speed', 'Balanced', 'Quality'
   */
  complexity?: H264Complexity;
  /**
   * @member {H264Layer[]} [layers] The collection of output H.264 layers to be
   * produced by the encoder.
   */
  layers?: H264Layer[];
}

/**
 * @interface
 * An interface representing JpgLayer.
 * Describes the settings to produce a JPEG image from the input video.
 *
 */
export interface JpgLayer {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.JpgLayer";
  /**
   * @member {string} [width] The width of the output video for this layer. The
   * value can be absolute (in pixels) or relative (in percentage). For example
   * 50% means the output video has half as many pixels in width as the input.
   */
  width?: string;
  /**
   * @member {string} [height] The height of the output video for this layer.
   * The value can be absolute (in pixels) or relative (in percentage). For
   * example 50% means the output video has half as many pixels in height as
   * the input.
   */
  height?: string;
  /**
   * @member {string} [label] The alphanumeric label for this layer, which can
   * be used in multiplexing different video and audio layers, or in naming the
   * output file.
   */
  label?: string;
  /**
   * @member {number} [quality] The compression quality of the JPEG output.
   * Range is from 0-100 and the default is 70.
   */
  quality?: number;
}

/**
 * @interface
 * An interface representing JpgImage.
 * Describes the properties for producing a series of JPEG images from the
 * input video.
 *
 */
export interface JpgImage {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.JpgImage";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
  /**
   * @member {string} [keyFrameInterval] The distance between two key frames,
   * thereby defining a group of pictures (GOP). The value should be a non-zero
   * integer in the range [1, 30] seconds, specified in ISO 8601 format. The
   * default is 2 seconds (PT2S).
   */
  keyFrameInterval?: string;
  /**
   * @member {StretchMode} [stretchMode] The resizing mode - how the input
   * video will be resized to fit the desired output resolution(s). Default is
   * AutoSize. Possible values include: 'None', 'AutoSize', 'AutoFit'
   */
  stretchMode?: StretchMode;
  /**
   * @member {string} [start] The position in the input video from where to
   * start generating thumbnails. The value can be in absolute timestamp (ISO
   * 8601, e.g: PT05S), or a frame count (For example, 10 for the 10th frame),
   * or a relative value (For example, 1%). Also supports a macro {Best}, which
   * tells the encoder to select the best thumbnail from the first few seconds
   * of the video.
   */
  start?: string;
  /**
   * @member {string} [step] The intervals at which thumbnails are generated.
   * The value can be in absolute timestamp (ISO 8601, e.g: PT05S for one image
   * every 5 seconds), or a frame count (For example, 30 for every 30 frames),
   * or a relative value (For example, 1%).
   */
  step?: string;
  /**
   * @member {string} [range] The position in the input video at which to stop
   * generating thumbnails. The value can be in absolute timestamp (ISO 8601,
   * e.g: PT5M30S to stop at 5 minutes and 30 seconds), or a frame count (For
   * example, 300 to stop at the 300th frame), or a relative value (For
   * example, 100%).
   */
  range?: string;
  /**
   * @member {JpgLayer[]} [layers] A collection of output JPEG image layers to
   * be produced by the encoder.
   */
  layers?: JpgLayer[];
}

/**
 * @interface
 * An interface representing OutputFile.
 * Represents an output file produced.
 *
 */
export interface OutputFile {
  /**
   * @member {string[]} [labels] The list of labels that describe how the
   * encoder should multiplex video and audio into an output file. For example,
   * if the encoder is producing two video layers with labels v1 and v2, and
   * one audio layer with label a1, then an array like '[v1, a1]' tells the
   * encoder to produce an output file with the video track represented by v1
   * and the audio track represented by a1.
   */
  labels?: string[];
}

/**
 * Contains the possible cases for MultiBitrateFormat.
 */
export type MultiBitrateFormatUnion = MultiBitrateFormat | Mp4Format | TransportStreamFormat;

/**
 * @interface
 * An interface representing MultiBitrateFormat.
 * Describes the properties for producing a collection of GOP aligned
 * multi-bitrate files. The default behavior is to produce one output file for
 * each video layer which is muxed together with all the audios. The exact
 * output files produced can be controlled by specifying the outputFiles
 * collection.
 *
 */
export interface MultiBitrateFormat {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.MultiBitrateFormat";
  /**
   * @member {string} [filenamePattern] The pattern of the file names for the
   * generated output files. The following macros are supported in the file
   * name: {Basename} - The base name of the input video {Extension} - The
   * appropriate extension for this format. {Label} - The label assigned to the
   * codec/layer. {Index} - A unique index for thumbnails. Only applicable to
   * thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to
   * thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted
   * macros will be collapsed and removed from the filename.
   */
  filenamePattern?: string;
  /**
   * @member {OutputFile[]} [outputFiles] The list of output files to produce.
   * Each entry in the list is a set of audio and video layer labels to be
   * muxed together .
   */
  outputFiles?: OutputFile[];
}

/**
 * @interface
 * An interface representing Mp4Format.
 * Describes the properties for an output ISO MP4 file.
 *
 */
export interface Mp4Format {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.Mp4Format";
  /**
   * @member {string} [filenamePattern] The pattern of the file names for the
   * generated output files. The following macros are supported in the file
   * name: {Basename} - The base name of the input video {Extension} - The
   * appropriate extension for this format. {Label} - The label assigned to the
   * codec/layer. {Index} - A unique index for thumbnails. Only applicable to
   * thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to
   * thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted
   * macros will be collapsed and removed from the filename.
   */
  filenamePattern?: string;
  /**
   * @member {OutputFile[]} [outputFiles] The list of output files to produce.
   * Each entry in the list is a set of audio and video layer labels to be
   * muxed together .
   */
  outputFiles?: OutputFile[];
}

/**
 * @interface
 * An interface representing PngLayer.
 * Describes the settings to produce a PNG image from the input video.
 *
 */
export interface PngLayer {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.PngLayer";
  /**
   * @member {string} [width] The width of the output video for this layer. The
   * value can be absolute (in pixels) or relative (in percentage). For example
   * 50% means the output video has half as many pixels in width as the input.
   */
  width?: string;
  /**
   * @member {string} [height] The height of the output video for this layer.
   * The value can be absolute (in pixels) or relative (in percentage). For
   * example 50% means the output video has half as many pixels in height as
   * the input.
   */
  height?: string;
  /**
   * @member {string} [label] The alphanumeric label for this layer, which can
   * be used in multiplexing different video and audio layers, or in naming the
   * output file.
   */
  label?: string;
}

/**
 * @interface
 * An interface representing PngImage.
 * Describes the properties for producing a series of PNG images from the input
 * video.
 *
 */
export interface PngImage {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.PngImage";
  /**
   * @member {string} [label] An optional label for the codec. The label can be
   * used to control muxing behavior.
   */
  label?: string;
  /**
   * @member {string} [keyFrameInterval] The distance between two key frames,
   * thereby defining a group of pictures (GOP). The value should be a non-zero
   * integer in the range [1, 30] seconds, specified in ISO 8601 format. The
   * default is 2 seconds (PT2S).
   */
  keyFrameInterval?: string;
  /**
   * @member {StretchMode} [stretchMode] The resizing mode - how the input
   * video will be resized to fit the desired output resolution(s). Default is
   * AutoSize. Possible values include: 'None', 'AutoSize', 'AutoFit'
   */
  stretchMode?: StretchMode;
  /**
   * @member {string} [start] The position in the input video from where to
   * start generating thumbnails. The value can be in absolute timestamp (ISO
   * 8601, e.g: PT05S), or a frame count (For example, 10 for the 10th frame),
   * or a relative value (For example, 1%). Also supports a macro {Best}, which
   * tells the encoder to select the best thumbnail from the first few seconds
   * of the video.
   */
  start?: string;
  /**
   * @member {string} [step] The intervals at which thumbnails are generated.
   * The value can be in absolute timestamp (ISO 8601, e.g: PT05S for one image
   * every 5 seconds), or a frame count (For example, 30 for every 30 frames),
   * or a relative value (For example, 1%).
   */
  step?: string;
  /**
   * @member {string} [range] The position in the input video at which to stop
   * generating thumbnails. The value can be in absolute timestamp (ISO 8601,
   * e.g: PT5M30S to stop at 5 minutes and 30 seconds), or a frame count (For
   * example, 300 to stop at the 300th frame), or a relative value (For
   * example, 100%).
   */
  range?: string;
  /**
   * @member {PngLayer[]} [layers] A collection of output PNG image layers to
   * be produced by the encoder.
   */
  layers?: PngLayer[];
}

/**
 * @interface
 * An interface representing BuiltInStandardEncoderPreset.
 * Describes a built-in preset for encoding the input video with the Standard
 * Encoder.
 *
 */
export interface BuiltInStandardEncoderPreset {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.BuiltInStandardEncoderPreset";
  /**
   * @member {EncoderNamedPreset} presetName The built-in preset to be used for
   * encoding videos. Possible values include: 'H264SingleBitrateSD',
   * 'H264SingleBitrate720p', 'H264SingleBitrate1080p', 'AdaptiveStreaming',
   * 'AACGoodQualityAudio', 'H264MultipleBitrate1080p',
   * 'H264MultipleBitrate720p', 'H264MultipleBitrateSD'
   */
  presetName: EncoderNamedPreset;
}

/**
 * @interface
 * An interface representing StandardEncoderPreset.
 * Describes all the settings to be used when encoding the input video with the
 * Standard Encoder.
 *
 */
export interface StandardEncoderPreset {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.StandardEncoderPreset";
  /**
   * @member {Filters} [filters] One or more filtering operations that are
   * applied to the input media before encoding.
   */
  filters?: Filters;
  /**
   * @member {CodecUnion[]} [codecs] The list of codecs to be used when
   * encoding the input video.
   */
  codecs?: CodecUnion[];
  /**
   * @member {FormatUnion[]} [formats] The list of outputs to be produced by
   * the encoder.
   */
  formats?: FormatUnion[];
}

/**
 * @interface
 * An interface representing VideoAnalyzerPreset.
 * A video analyzer preset that extracts insights (rich metadata) from both
 * audio and video, and outputs a JSON format file.
 *
 */
export interface VideoAnalyzerPreset {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.VideoAnalyzerPreset";
  /**
   * @member {string} [audioLanguage] The language for the audio payload in the
   * input using the BCP-47 format of 'language tag-region' (e.g: 'en-US'). The
   * list of supported languages are, 'en-US', 'en-GB', 'es-ES', 'es-MX',
   * 'fr-FR', 'it-IT', 'ja-JP', 'pt-BR', 'zh-CN', 'de-DE', 'ar-EG', 'ru-RU',
   * 'hi-IN'. If not specified, automatic language detection would be employed.
   * This feature currently supports English, Chinese, French, German, Italian,
   * Japanese, Spanish, Russian, and Portuguese. The automatic detection works
   * best with audio recordings with clearly discernable speech. If automatic
   * detection fails to find the language, transcription would fallback to
   * English.
   */
  audioLanguage?: string;
  /**
   * @member {InsightsType} [insightsToExtract] The type of insights to be
   * extracted. If not set then based on the content the type will selected.
   * If the content is audio only then only audio insights are extracted and if
   * it is video only. Possible values include: 'AudioInsightsOnly',
   * 'VideoInsightsOnly', 'AllInsights'
   */
  insightsToExtract?: InsightsType;
}

/**
 * @interface
 * An interface representing TransportStreamFormat.
 * Describes the properties for generating an MPEG-2 Transport Stream (ISO/IEC
 * 13818-1) output video file(s).
 *
 */
export interface TransportStreamFormat {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.TransportStreamFormat";
  /**
   * @member {string} [filenamePattern] The pattern of the file names for the
   * generated output files. The following macros are supported in the file
   * name: {Basename} - The base name of the input video {Extension} - The
   * appropriate extension for this format. {Label} - The label assigned to the
   * codec/layer. {Index} - A unique index for thumbnails. Only applicable to
   * thumbnails. {Bitrate} - The audio/video bitrate. Not applicable to
   * thumbnails. {Codec} - The type of the audio/video codec. Any unsubstituted
   * macros will be collapsed and removed from the filename.
   */
  filenamePattern?: string;
  /**
   * @member {OutputFile[]} [outputFiles] The list of output files to produce.
   * Each entry in the list is a set of audio and video layer labels to be
   * muxed together .
   */
  outputFiles?: OutputFile[];
}

/**
 * @interface
 * An interface representing VideoOverlay.
 * Describes the properties of a video overlay.
 *
 */
export interface VideoOverlay {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.VideoOverlay";
  /**
   * @member {string} [inputLabel] The label of the job input which is to be
   * used as an overlay. The Input must specify exactly one file. You can
   * specify an image file in JPG or PNG formats, or an audio file (such as a
   * WAV, MP3, WMA or M4A file), or a video file. See https://aka.ms/mesformats
   * for the complete list of supported audio and video file formats.
   */
  inputLabel?: string;
  /**
   * @member {string} [start] The start position, with reference to the input
   * video, at which the overlay starts. The value should be in ISO 8601
   * format. For example, PT05S to start the overlay at 5 seconds in to the
   * input video. If not specified the overlay starts from the beginning of the
   * input video.
   */
  start?: string;
  /**
   * @member {string} [end] The position in the input video at which the
   * overlay ends. The value should be in ISO 8601 duration format. For
   * example, PT30S to end the overlay at 30 seconds in to the input video. If
   * not specified the overlay will be applied until the end of the input video
   * if inputLoop is true. Else, if inputLoop is false, then overlay will last
   * as long as the duration of the overlay media.
   */
  end?: string;
  /**
   * @member {string} [fadeInDuration] The duration over which the overlay
   * fades in onto the input video. The value should be in ISO 8601 duration
   * format. If not specified the default behavior is to have no fade in (same
   * as PT0S).
   */
  fadeInDuration?: string;
  /**
   * @member {string} [fadeOutDuration] The duration over which the overlay
   * fades out of the input video. The value should be in ISO 8601 duration
   * format. If not specified the default behavior is to have no fade out (same
   * as PT0S).
   */
  fadeOutDuration?: string;
  /**
   * @member {number} [audioGainLevel] The gain level of audio in the overlay.
   * The value should be in the range [0, 1.0]. The default is 1.0.
   */
  audioGainLevel?: number;
  /**
   * @member {Rectangle} [position] The location in the input video where the
   * overlay is applied.
   */
  position?: Rectangle;
  /**
   * @member {number} [opacity] The opacity of the overlay. This is a value in
   * the range [0 - 1.0]. Default is 1.0 which mean the overlay is opaque.
   */
  opacity?: number;
  /**
   * @member {Rectangle} [cropRectangle] An optional rectangular window used to
   * crop the overlay image or video.
   */
  cropRectangle?: Rectangle;
}

/**
 * @interface
 * An interface representing TransformOutput.
 * Describes the properties of a TransformOutput, which are the rules to be
 * applied while generating the desired output.
 *
 */
export interface TransformOutput {
  /**
   * @member {OnErrorType} [onError] A Transform can define more than one
   * outputs. This property defines what the service should do when one output
   * fails - either continue to produce other outputs, or, stop the other
   * outputs. The overall Job state will not reflect failures of outputs that
   * are specified with 'ContinueJob'. The default is 'StopProcessingJob'.
   * Possible values include: 'StopProcessingJob', 'ContinueJob'
   */
  onError?: OnErrorType;
  /**
   * @member {Priority} [relativePriority] Sets the relative priority of the
   * TransformOutputs within a Transform. This sets the priority that the
   * service uses for processing TransformOutputs. The default priority is
   * Normal. Possible values include: 'Low', 'Normal', 'High'
   */
  relativePriority?: Priority;
  /**
   * @member {PresetUnion} preset Preset that describes the operations that
   * will be used to modify, transcode, or extract insights from the source
   * file to generate the output.
   */
  preset: PresetUnion;
}

/**
 * @interface
 * An interface representing Transform.
 * A Transform encapsulates the rules or instructions for generating desired
 * outputs from input media, such as by transcoding or by extracting insights.
 * After the Transform is created, it can be applied to input media by creating
 * Jobs.
 *
 * @extends ProxyResource
 */
export interface Transform extends ProxyResource {
  /**
   * @member {Date} [created] The UTC date and time when the Transform was
   * created, in 'YYYY-MM-DDThh:mm:ssZ' format.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {string} [description] An optional verbose description of the
   * Transform.
   */
  description?: string;
  /**
   * @member {Date} [lastModified] The UTC date and time when the Transform was
   * last updated, in 'YYYY-MM-DDThh:mm:ssZ' format.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly lastModified?: Date;
  /**
   * @member {TransformOutput[]} outputs An array of one or more
   * TransformOutputs that the Transform should generate.
   */
  outputs: TransformOutput[];
}

/**
 * Contains the possible cases for JobInput.
 */
export type JobInputUnion = JobInput | JobInputClipUnion | JobInputs;

/**
 * @interface
 * An interface representing JobInput.
 * Base class for inputs to a Job.
 *
 */
export interface JobInput {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "JobInput";
}

/**
 * Contains the possible cases for JobInputClip.
 */
export type JobInputClipUnion = JobInputClip | JobInputAsset | JobInputHttp;

/**
 * @interface
 * An interface representing JobInputClip.
 * Represents input files for a Job.
 *
 */
export interface JobInputClip {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.JobInputClip";
  /**
   * @member {string[]} [files] List of files. Required for JobInputHttp.
   */
  files?: string[];
  /**
   * @member {string} [label] A label that is assigned to a JobInputClip, that
   * is used to satisfy a reference used in the Transform. For example, a
   * Transform can be authored so as to take an image file with the label 'xyz'
   * and apply it as an overlay onto the input video before it is encoded. When
   * submitting a Job, exactly one of the JobInputs should be the image file,
   * and it should have the label 'xyz'.
   */
  label?: string;
}

/**
 * @interface
 * An interface representing JobInputs.
 * Describes a list of inputs to a Job.
 *
 */
export interface JobInputs {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.JobInputs";
  /**
   * @member {JobInputUnion[]} [inputs] List of inputs to a Job.
   */
  inputs?: JobInputUnion[];
}

/**
 * @interface
 * An interface representing JobInputAsset.
 * Represents an Asset for input into a Job.
 *
 */
export interface JobInputAsset {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.JobInputAsset";
  /**
   * @member {string[]} [files] List of files. Required for JobInputHttp.
   */
  files?: string[];
  /**
   * @member {string} [label] A label that is assigned to a JobInputClip, that
   * is used to satisfy a reference used in the Transform. For example, a
   * Transform can be authored so as to take an image file with the label 'xyz'
   * and apply it as an overlay onto the input video before it is encoded. When
   * submitting a Job, exactly one of the JobInputs should be the image file,
   * and it should have the label 'xyz'.
   */
  label?: string;
  /**
   * @member {string} assetName The name of the input Asset.
   */
  assetName: string;
}

/**
 * @interface
 * An interface representing JobInputHttp.
 * Represents HTTPS job input.
 *
 */
export interface JobInputHttp {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.JobInputHttp";
  /**
   * @member {string[]} [files] List of files. Required for JobInputHttp.
   */
  files?: string[];
  /**
   * @member {string} [label] A label that is assigned to a JobInputClip, that
   * is used to satisfy a reference used in the Transform. For example, a
   * Transform can be authored so as to take an image file with the label 'xyz'
   * and apply it as an overlay onto the input video before it is encoded. When
   * submitting a Job, exactly one of the JobInputs should be the image file,
   * and it should have the label 'xyz'.
   */
  label?: string;
  /**
   * @member {string} [baseUri] Base URI for HTTPS job input. It will be
   * concatenated with provided file names.   If no base uri is given, then the
   * provided file list is assumed to be fully qualified uris.
   */
  baseUri?: string;
}

/**
 * @interface
 * An interface representing JobErrorDetail.
 * Details of JobOutput errors.
 *
 */
export interface JobErrorDetail {
  /**
   * @member {string} [code] Code describing the error detail.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly code?: string;
  /**
   * @member {string} [message] A human-readable representation of the error.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly message?: string;
}

/**
 * @interface
 * An interface representing JobError.
 * Details of JobOutput errors.
 *
 */
export interface JobError {
  /**
   * @member {JobErrorCode} [code] Error code describing the error. Possible
   * values include: 'ServiceError', 'ServiceTransientError',
   * 'DownloadNotAccessible', 'DownloadTransientError', 'UploadNotAccessible',
   * 'UploadTransientError', 'ConfigurationUnsupported', 'ContentMalformed',
   * 'ContentUnsupported'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly code?: JobErrorCode;
  /**
   * @member {string} [message] A human-readable language-dependent
   * representation of the error.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly message?: string;
  /**
   * @member {JobErrorCategory} [category] Helps with categorization of errors.
   * Possible values include: 'Service', 'Download', 'Upload', 'Configuration',
   * 'Content'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly category?: JobErrorCategory;
  /**
   * @member {JobRetry} [retry] Indicates that it may be possible to retry the
   * Job. If retry is unsuccessful, please contact Azure support via Azure
   * Portal. Possible values include: 'DoNotRetry', 'MayRetry'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly retry?: JobRetry;
  /**
   * @member {JobErrorDetail[]} [details] An array of details about specific
   * errors that led to this reported error.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly details?: JobErrorDetail[];
}

/**
 * Contains the possible cases for JobOutput.
 */
export type JobOutputUnion = JobOutput | JobOutputAsset;

/**
 * @interface
 * An interface representing JobOutput.
 * Describes all the properties of a JobOutput.
 *
 */
export interface JobOutput {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "JobOutput";
  /**
   * @member {JobError} [error] If the JobOutput is in the Error state, it
   * contains the details of the error.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly error?: JobError;
  /**
   * @member {JobState} [state] Describes the state of the JobOutput. Possible
   * values include: 'Canceled', 'Canceling', 'Error', 'Finished',
   * 'Processing', 'Queued', 'Scheduled'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly state?: JobState;
  /**
   * @member {number} [progress] If the JobOutput is in a Processing state,
   * this contains the Job completion percentage. The value is an estimate and
   * not intended to be used to predict Job completion times. To determine if
   * the JobOutput is complete, use the State property.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly progress?: number;
  /**
   * @member {string} [label] A label that is assigned to a JobOutput in order
   * to help uniquely identify it. This is useful when your Transform has more
   * than one TransformOutput, whereby your Job has more than one JobOutput. In
   * such cases, when you submit the Job, you will add two or more JobOutputs,
   * in the same order as TransformOutputs in the Transform. Subsequently, when
   * you retrieve the Job, either through events or on a GET request, you can
   * use the label to easily identify the JobOutput. If a label is not
   * provided, a default value of '{presetName}_{outputIndex}' will be used,
   * where the preset name is the name of the preset in the corresponding
   * TransformOutput and the output index is the relative index of the this
   * JobOutput within the Job. Note that this index is the same as the relative
   * index of the corresponding TransformOutput within its Transform.
   */
  label?: string;
}

/**
 * @interface
 * An interface representing JobOutputAsset.
 * Represents an Asset used as a JobOutput.
 *
 */
export interface JobOutputAsset {
  /**
   * @member {string} odatatype Polymorphic Discriminator
   */
  odatatype: "#Microsoft.Media.JobOutputAsset";
  /**
   * @member {JobError} [error] If the JobOutput is in the Error state, it
   * contains the details of the error.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly error?: JobError;
  /**
   * @member {JobState} [state] Describes the state of the JobOutput. Possible
   * values include: 'Canceled', 'Canceling', 'Error', 'Finished',
   * 'Processing', 'Queued', 'Scheduled'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly state?: JobState;
  /**
   * @member {number} [progress] If the JobOutput is in a Processing state,
   * this contains the Job completion percentage. The value is an estimate and
   * not intended to be used to predict Job completion times. To determine if
   * the JobOutput is complete, use the State property.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly progress?: number;
  /**
   * @member {string} [label] A label that is assigned to a JobOutput in order
   * to help uniquely identify it. This is useful when your Transform has more
   * than one TransformOutput, whereby your Job has more than one JobOutput. In
   * such cases, when you submit the Job, you will add two or more JobOutputs,
   * in the same order as TransformOutputs in the Transform. Subsequently, when
   * you retrieve the Job, either through events or on a GET request, you can
   * use the label to easily identify the JobOutput. If a label is not
   * provided, a default value of '{presetName}_{outputIndex}' will be used,
   * where the preset name is the name of the preset in the corresponding
   * TransformOutput and the output index is the relative index of the this
   * JobOutput within the Job. Note that this index is the same as the relative
   * index of the corresponding TransformOutput within its Transform.
   */
  label?: string;
  /**
   * @member {string} assetName The name of the output Asset.
   */
  assetName: string;
}

/**
 * @interface
 * An interface representing Job.
 * A Job resource type. The progress and state can be obtained by polling a Job
 * or subscribing to events using EventGrid.
 *
 * @extends ProxyResource
 */
export interface Job extends ProxyResource {
  /**
   * @member {Date} [created] The UTC date and time when the Job was created,
   * in 'YYYY-MM-DDThh:mm:ssZ' format.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {JobState} [state] The current state of the job. Possible values
   * include: 'Canceled', 'Canceling', 'Error', 'Finished', 'Processing',
   * 'Queued', 'Scheduled'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly state?: JobState;
  /**
   * @member {string} [description] Optional customer supplied description of
   * the Job.
   */
  description?: string;
  /**
   * @member {JobInputUnion} input The inputs for the Job.
   */
  input: JobInputUnion;
  /**
   * @member {Date} [lastModified] The UTC date and time when the Job was last
   * updated, in 'YYYY-MM-DDThh:mm:ssZ' format.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly lastModified?: Date;
  /**
   * @member {JobOutputUnion[]} outputs The outputs for the Job.
   */
  outputs: JobOutputUnion[];
  /**
   * @member {Priority} [priority] Priority with which the job should be
   * processed. Higher priority jobs are processed before lower priority jobs.
   * If not set, the default is normal. Possible values include: 'Low',
   * 'Normal', 'High'
   */
  priority?: Priority;
  /**
   * @member {{ [propertyName: string]: string }} [correlationData] Customer
   * provided correlation data that will be returned in Job and JobOutput state
   * events.
   */
  correlationData?: { [propertyName: string]: string };
}

/**
 * @interface
 * An interface representing TrackPropertyCondition.
 * Class to specify one track property condition
 *
 */
export interface TrackPropertyCondition {
  /**
   * @member {TrackPropertyType} property Track property type. Possible values
   * include: 'Unknown', 'FourCC'
   */
  property: TrackPropertyType;
  /**
   * @member {TrackPropertyCompareOperation} operation Track property condition
   * operation. Possible values include: 'Unknown', 'Equal'
   */
  operation: TrackPropertyCompareOperation;
  /**
   * @member {string} [value] Track property value
   */
  value?: string;
}

/**
 * @interface
 * An interface representing TrackSelection.
 * Class to select a track
 *
 */
export interface TrackSelection {
  /**
   * @member {TrackPropertyCondition[]} [trackSelections] TrackSelections is a
   * track property condition list which can specify track(s)
   */
  trackSelections?: TrackPropertyCondition[];
}

/**
 * @interface
 * An interface representing DefaultKey.
 * Class to specify properties of default content key for each encryption
 * scheme
 *
 */
export interface DefaultKey {
  /**
   * @member {string} [label] Label can be used to specify Content Key when
   * creating a Streaming Locator
   */
  label?: string;
  /**
   * @member {string} [policyName] Policy used by Default Key
   */
  policyName?: string;
}

/**
 * @interface
 * An interface representing StreamingPolicyContentKey.
 * Class to specify properties of content key
 *
 */
export interface StreamingPolicyContentKey {
  /**
   * @member {string} [label] Label can be used to specify Content Key when
   * creating a Streaming Locator
   */
  label?: string;
  /**
   * @member {string} [policyName] Policy used by Content Key
   */
  policyName?: string;
  /**
   * @member {TrackSelection[]} [tracks] Tracks which use this content key
   */
  tracks?: TrackSelection[];
}

/**
 * @interface
 * An interface representing StreamingPolicyContentKeys.
 * Class to specify properties of all content keys in Streaming Policy
 *
 */
export interface StreamingPolicyContentKeys {
  /**
   * @member {DefaultKey} [defaultKey] Default content key for an encryption
   * scheme
   */
  defaultKey?: DefaultKey;
  /**
   * @member {StreamingPolicyContentKey[]} [keyToTrackMappings] Representing
   * tracks needs separate content key
   */
  keyToTrackMappings?: StreamingPolicyContentKey[];
}

/**
 * @interface
 * An interface representing StreamingPolicyPlayReadyConfiguration.
 * Class to specify configurations of PlayReady in Streaming Policy
 *
 */
export interface StreamingPolicyPlayReadyConfiguration {
  /**
   * @member {string} [customLicenseAcquisitionUrlTemplate] The template for a
   * customer service to deliver keys to end users.  Not needed when using
   * Azure Media Services for issuing keys.
   */
  customLicenseAcquisitionUrlTemplate?: string;
  /**
   * @member {string} [playReadyCustomAttributes] Custom attributes for
   * PlayReady
   */
  playReadyCustomAttributes?: string;
}

/**
 * @interface
 * An interface representing StreamingPolicyWidevineConfiguration.
 * Class to specify configurations of Widevine in Streaming Policy
 *
 */
export interface StreamingPolicyWidevineConfiguration {
  /**
   * @member {string} [customLicenseAcquisitionUrlTemplate] The template for a
   * customer service to deliver keys to end users.  Not needed when using
   * Azure Media Services for issuing keys.
   */
  customLicenseAcquisitionUrlTemplate?: string;
}

/**
 * @interface
 * An interface representing StreamingPolicyFairPlayConfiguration.
 * Class to specify configurations of FairPlay in Streaming Policy
 *
 */
export interface StreamingPolicyFairPlayConfiguration {
  /**
   * @member {string} [customLicenseAcquisitionUrlTemplate] The template for a
   * customer service to deliver keys to end users.  Not needed when using
   * Azure Media Services for issuing keys.
   */
  customLicenseAcquisitionUrlTemplate?: string;
  /**
   * @member {boolean} allowPersistentLicense All license to be persistent or
   * not
   */
  allowPersistentLicense: boolean;
}

/**
 * @interface
 * An interface representing CbcsDrmConfiguration.
 * Class to specify DRM configurations of CommonEncryptionCbcs scheme in
 * Streaming Policy
 *
 */
export interface CbcsDrmConfiguration {
  /**
   * @member {StreamingPolicyFairPlayConfiguration} [fairPlay] FairPlay
   * configurations
   */
  fairPlay?: StreamingPolicyFairPlayConfiguration;
  /**
   * @member {StreamingPolicyPlayReadyConfiguration} [playReady] PlayReady
   * configurations
   */
  playReady?: StreamingPolicyPlayReadyConfiguration;
  /**
   * @member {StreamingPolicyWidevineConfiguration} [widevine] Widevine
   * configurations
   */
  widevine?: StreamingPolicyWidevineConfiguration;
}

/**
 * @interface
 * An interface representing CencDrmConfiguration.
 * Class to specify DRM configurations of CommonEncryptionCenc scheme in
 * Streaming Policy
 *
 */
export interface CencDrmConfiguration {
  /**
   * @member {StreamingPolicyPlayReadyConfiguration} [playReady] PlayReady
   * configurations
   */
  playReady?: StreamingPolicyPlayReadyConfiguration;
  /**
   * @member {StreamingPolicyWidevineConfiguration} [widevine] Widevine
   * configurations
   */
  widevine?: StreamingPolicyWidevineConfiguration;
}

/**
 * @interface
 * An interface representing EnabledProtocols.
 * Class to specify which protocols are enabled
 *
 */
export interface EnabledProtocols {
  /**
   * @member {boolean} download Enable Download protocol or not
   */
  download: boolean;
  /**
   * @member {boolean} dash Enable DASH protocol or not
   */
  dash: boolean;
  /**
   * @member {boolean} hls Enable HLS protocol or not
   */
  hls: boolean;
  /**
   * @member {boolean} smoothStreaming Enable SmoothStreaming protocol or not
   */
  smoothStreaming: boolean;
}

/**
 * @interface
 * An interface representing NoEncryption.
 * Class for NoEncryption scheme
 *
 */
export interface NoEncryption {
  /**
   * @member {EnabledProtocols} [enabledProtocols] Representing supported
   * protocols
   */
  enabledProtocols?: EnabledProtocols;
}

/**
 * @interface
 * An interface representing EnvelopeEncryption.
 * Class for EnvelopeEncryption encryption scheme
 *
 */
export interface EnvelopeEncryption {
  /**
   * @member {EnabledProtocols} [enabledProtocols] Representing supported
   * protocols
   */
  enabledProtocols?: EnabledProtocols;
  /**
   * @member {TrackSelection[]} [clearTracks] Representing which tracks should
   * not be encrypted
   */
  clearTracks?: TrackSelection[];
  /**
   * @member {StreamingPolicyContentKeys} [contentKeys] Representing default
   * content key for each encryption scheme and separate content keys for
   * specific tracks
   */
  contentKeys?: StreamingPolicyContentKeys;
  /**
   * @member {string} [customKeyAcquisitionUrlTemplate]
   * KeyAcquisitionUrlTemplate is used to point to user specified service to
   * delivery content keys
   */
  customKeyAcquisitionUrlTemplate?: string;
}

/**
 * @interface
 * An interface representing CommonEncryptionCenc.
 * Class for envelope encryption scheme
 *
 */
export interface CommonEncryptionCenc {
  /**
   * @member {EnabledProtocols} [enabledProtocols] Representing supported
   * protocols
   */
  enabledProtocols?: EnabledProtocols;
  /**
   * @member {TrackSelection[]} [clearTracks] Representing which tracks should
   * not be encrypted
   */
  clearTracks?: TrackSelection[];
  /**
   * @member {StreamingPolicyContentKeys} [contentKeys] Representing default
   * content key for each encryption scheme and separate content keys for
   * specific tracks
   */
  contentKeys?: StreamingPolicyContentKeys;
  /**
   * @member {CencDrmConfiguration} [drm] Configuration of DRMs for
   * CommonEncryptionCenc encryption scheme
   */
  drm?: CencDrmConfiguration;
}

/**
 * @interface
 * An interface representing CommonEncryptionCbcs.
 * Class for CommonEncryptionCbcs encryption scheme
 *
 */
export interface CommonEncryptionCbcs {
  /**
   * @member {EnabledProtocols} [enabledProtocols] Representing supported
   * protocols
   */
  enabledProtocols?: EnabledProtocols;
  /**
   * @member {TrackSelection[]} [clearTracks] Representing which tracks should
   * not be encrypted
   */
  clearTracks?: TrackSelection[];
  /**
   * @member {StreamingPolicyContentKeys} [contentKeys] Representing default
   * content key for each encryption scheme and separate content keys for
   * specific tracks
   */
  contentKeys?: StreamingPolicyContentKeys;
  /**
   * @member {CbcsDrmConfiguration} [drm] Configuration of DRMs for current
   * encryption scheme
   */
  drm?: CbcsDrmConfiguration;
}

/**
 * @interface
 * An interface representing StreamingPolicy.
 * A Streaming Policy resource
 *
 * @extends ProxyResource
 */
export interface StreamingPolicy extends ProxyResource {
  /**
   * @member {Date} [created] Creation time of Streaming Policy
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {string} [defaultContentKeyPolicyName] Default ContentKey used by
   * current Streaming Policy
   */
  defaultContentKeyPolicyName?: string;
  /**
   * @member {EnvelopeEncryption} [envelopeEncryption] Configuration of
   * EnvelopeEncryption
   */
  envelopeEncryption?: EnvelopeEncryption;
  /**
   * @member {CommonEncryptionCenc} [commonEncryptionCenc] Configuration of
   * CommonEncryptionCenc
   */
  commonEncryptionCenc?: CommonEncryptionCenc;
  /**
   * @member {CommonEncryptionCbcs} [commonEncryptionCbcs] Configuration of
   * CommonEncryptionCbcs
   */
  commonEncryptionCbcs?: CommonEncryptionCbcs;
  /**
   * @member {NoEncryption} [noEncryption] Configurations of NoEncryption
   */
  noEncryption?: NoEncryption;
}

/**
 * @interface
 * An interface representing StreamingLocatorContentKey.
 * Class for content key in Streaming Locator
 *
 */
export interface StreamingLocatorContentKey {
  /**
   * @member {string} id ID of Content Key
   */
  id: string;
  /**
   * @member {StreamingLocatorContentKeyType} [type] Encryption type of Content
   * Key. Possible values include: 'CommonEncryptionCenc',
   * 'CommonEncryptionCbcs', 'EnvelopeEncryption'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly type?: StreamingLocatorContentKeyType;
  /**
   * @member {string} [labelReferenceInStreamingPolicy] Label of Content Key as
   * specified in the Streaming Policy
   */
  labelReferenceInStreamingPolicy?: string;
  /**
   * @member {string} [value] Value of Content Key
   */
  value?: string;
  /**
   * @member {string} [policyName] ContentKeyPolicy used by Content Key
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly policyName?: string;
  /**
   * @member {TrackSelection[]} [tracks] Tracks which use this Content Key
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly tracks?: TrackSelection[];
}

/**
 * @interface
 * An interface representing StreamingPath.
 * Class of paths for streaming
 *
 */
export interface StreamingPath {
  /**
   * @member {StreamingPolicyStreamingProtocol} streamingProtocol Streaming
   * protocol. Possible values include: 'Hls', 'Dash', 'SmoothStreaming',
   * 'Download'
   */
  streamingProtocol: StreamingPolicyStreamingProtocol;
  /**
   * @member {EncryptionScheme} encryptionScheme Encryption scheme. Possible
   * values include: 'NoEncryption', 'EnvelopeEncryption',
   * 'CommonEncryptionCenc', 'CommonEncryptionCbcs'
   */
  encryptionScheme: EncryptionScheme;
  /**
   * @member {string[]} [paths] Streaming paths for each protocol and
   * encryptionScheme pair
   */
  paths?: string[];
}

/**
 * @interface
 * An interface representing ListContentKeysResponse.
 * Class of response for listContentKeys action
 *
 */
export interface ListContentKeysResponse {
  /**
   * @member {StreamingLocatorContentKey[]} [contentKeys] ContentKeys used by
   * current Streaming Locator
   */
  contentKeys?: StreamingLocatorContentKey[];
}

/**
 * @interface
 * An interface representing ListPathsResponse.
 * Class of response for listPaths action
 *
 */
export interface ListPathsResponse {
  /**
   * @member {StreamingPath[]} [streamingPaths] Streaming Paths supported by
   * current Streaming Locator
   */
  streamingPaths?: StreamingPath[];
  /**
   * @member {string[]} [downloadPaths] Download Paths supported by current
   * Streaming Locator
   */
  downloadPaths?: string[];
}

/**
 * @interface
 * An interface representing StreamingLocator.
 * A Streaming Locator resource
 *
 * @extends ProxyResource
 */
export interface StreamingLocator extends ProxyResource {
  /**
   * @member {string} assetName Asset Name
   */
  assetName: string;
  /**
   * @member {Date} [created] The creation time of the Streaming Locator.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {Date} [startTime] The start time of the Streaming Locator.
   */
  startTime?: Date;
  /**
   * @member {Date} [endTime] The end time of the Streaming Locator.
   */
  endTime?: Date;
  /**
   * @member {string} [streamingLocatorId] The StreamingLocatorId of the
   * Streaming Locator.
   */
  streamingLocatorId?: string;
  /**
   * @member {string} streamingPolicyName Name of the Streaming Policy used by
   * this Streaming Locator. Either specify the name of Streaming Policy you
   * created or use one of the predefined Streaming Policies. The predefined
   * Streaming Policies available are: 'Predefined_DownloadOnly',
   * 'Predefined_ClearStreamingOnly', 'Predefined_DownloadAndClearStreaming',
   * 'Predefined_ClearKey', 'Predefined_MultiDrmCencStreaming' and
   * 'Predefined_MultiDrmStreaming'
   */
  streamingPolicyName: string;
  /**
   * @member {string} [defaultContentKeyPolicyName] Name of the default
   * ContentKeyPolicy used by this Streaming Locator.
   */
  defaultContentKeyPolicyName?: string;
  /**
   * @member {StreamingLocatorContentKey[]} [contentKeys] The ContentKeys used
   * by this Streaming Locator.
   */
  contentKeys?: StreamingLocatorContentKey[];
  /**
   * @member {string} [alternativeMediaId] Alternative Media ID of this
   * Streaming Locator
   */
  alternativeMediaId?: string;
}

/**
 * @interface
 * An interface representing Hls.
 * The HLS configuration.
 *
 */
export interface Hls {
  /**
   * @member {number} [fragmentsPerTsSegment] The amount of fragments per HTTP
   * Live Streaming (HLS) segment.
   */
  fragmentsPerTsSegment?: number;
}

/**
 * @interface
 * An interface representing LiveOutput.
 * The Live Output.
 *
 * @extends ProxyResource
 */
export interface LiveOutput extends ProxyResource {
  /**
   * @member {string} [description] The description of the Live Output.
   */
  description?: string;
  /**
   * @member {string} assetName The asset name.
   */
  assetName: string;
  /**
   * @member {string} archiveWindowLength ISO 8601 timespan duration of the
   * archive window length. This is duration that customer want to retain the
   * recorded content.
   */
  archiveWindowLength: string;
  /**
   * @member {string} [manifestName] The manifest file name.  If not provided,
   * the service will generate one automatically.
   */
  manifestName?: string;
  /**
   * @member {Hls} [hls] The HLS configuration.
   */
  hls?: Hls;
  /**
   * @member {number} [outputSnapTime] The output snapshot time.
   */
  outputSnapTime?: number;
  /**
   * @member {Date} [created] The exact time the Live Output was created.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {Date} [lastModified] The exact time the Live Output was last
   * modified.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly lastModified?: Date;
  /**
   * @member {string} [provisioningState] The provisioning state of the Live
   * Output.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly provisioningState?: string;
  /**
   * @member {LiveOutputResourceState} [resourceState] The resource state of
   * the Live Output. Possible values include: 'Creating', 'Running',
   * 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly resourceState?: LiveOutputResourceState;
}

/**
 * @interface
 * An interface representing LiveEventEndpoint.
 * The Live Event endpoint.
 *
 */
export interface LiveEventEndpoint {
  /**
   * @member {string} [protocol] The endpoint protocol.
   */
  protocol?: string;
  /**
   * @member {string} [url] The endpoint URL.
   */
  url?: string;
}

/**
 * @interface
 * An interface representing IPRange.
 * The IP address range in the CIDR scheme.
 *
 */
export interface IPRange {
  /**
   * @member {string} [name] The friendly name for the IP address range.
   */
  name?: string;
  /**
   * @member {string} [address] The IP address.
   */
  address?: string;
  /**
   * @member {number} [subnetPrefixLength] The subnet mask prefix length (see
   * CIDR notation).
   */
  subnetPrefixLength?: number;
}

/**
 * @interface
 * An interface representing IPAccessControl.
 * The IP access control.
 *
 */
export interface IPAccessControl {
  /**
   * @member {IPRange[]} [allow] The IP allow list.
   */
  allow?: IPRange[];
}

/**
 * @interface
 * An interface representing LiveEventInputAccessControl.
 * The IP access control for Live Event Input.
 *
 */
export interface LiveEventInputAccessControl {
  /**
   * @member {IPAccessControl} [ip] The IP access control properties.
   */
  ip?: IPAccessControl;
}

/**
 * @interface
 * An interface representing LiveEventInput.
 * The Live Event input.
 *
 */
export interface LiveEventInput {
  /**
   * @member {LiveEventInputProtocol} streamingProtocol The streaming protocol
   * for the Live Event.  This is specified at creation time and cannot be
   * updated. Possible values include: 'FragmentedMP4', 'RTMP'
   */
  streamingProtocol: LiveEventInputProtocol;
  /**
   * @member {LiveEventInputAccessControl} [accessControl] The access control
   * for LiveEvent Input.
   */
  accessControl?: LiveEventInputAccessControl;
  /**
   * @member {string} [keyFrameIntervalDuration] ISO 8601 timespan duration of
   * the key frame interval duration.
   */
  keyFrameIntervalDuration?: string;
  /**
   * @member {string} [accessToken] A unique identifier for a stream.  This can
   * be specified at creation time but cannot be updated.  If omitted, the
   * service will generate a unique value.
   */
  accessToken?: string;
  /**
   * @member {LiveEventEndpoint[]} [endpoints] The input endpoints for the Live
   * Event.
   */
  endpoints?: LiveEventEndpoint[];
}

/**
 * @interface
 * An interface representing LiveEventPreviewAccessControl.
 * The IP access control for Live Event preview.
 *
 */
export interface LiveEventPreviewAccessControl {
  /**
   * @member {IPAccessControl} [ip] The IP access control properties.
   */
  ip?: IPAccessControl;
}

/**
 * @interface
 * An interface representing LiveEventPreview.
 * The Live Event preview.
 *
 */
export interface LiveEventPreview {
  /**
   * @member {LiveEventEndpoint[]} [endpoints] The endpoints for preview.
   */
  endpoints?: LiveEventEndpoint[];
  /**
   * @member {LiveEventPreviewAccessControl} [accessControl] The access control
   * for LiveEvent preview.
   */
  accessControl?: LiveEventPreviewAccessControl;
  /**
   * @member {string} [previewLocator] The identifier of the preview locator in
   * Guid format.  Specifying this at creation time allows the caller to know
   * the preview locator url before the event is created.  If omitted, the
   * service will generate a random identifier.  This value cannot be updated
   * once the live event is created.
   */
  previewLocator?: string;
  /**
   * @member {string} [streamingPolicyName] The name of streaming policy used
   * for the LiveEvent preview.  This value is specified at creation time and
   * cannot be updated.
   */
  streamingPolicyName?: string;
  /**
   * @member {string} [alternativeMediaId] An Alternative Media Identifier
   * associated with the StreamingLocator created for the preview.  This value
   * is specified at creation time and cannot be updated.  The identifier can
   * be used in the CustomLicenseAcquisitionUrlTemplate or the
   * CustomKeyAcquisitionUrlTemplate of the StreamingPolicy specified in the
   * StreamingPolicyName field.
   */
  alternativeMediaId?: string;
}

/**
 * @interface
 * An interface representing LiveEventEncoding.
 * The Live Event encoding.
 *
 */
export interface LiveEventEncoding {
  /**
   * @member {LiveEventEncodingType} [encodingType] The encoding type for Live
   * Event.  This value is specified at creation time and cannot be updated.
   * Possible values include: 'None', 'Basic', 'Standard'
   */
  encodingType?: LiveEventEncodingType;
  /**
   * @member {string} [presetName] The encoding preset name.  This value is
   * specified at creation time and cannot be updated.
   */
  presetName?: string;
}

/**
 * @interface
 * An interface representing CrossSiteAccessPolicies.
 * The client access policy.
 *
 */
export interface CrossSiteAccessPolicies {
  /**
   * @member {string} [clientAccessPolicy] The content of
   * clientaccesspolicy.xml used by Silverlight.
   */
  clientAccessPolicy?: string;
  /**
   * @member {string} [crossDomainPolicy] The content of crossdomain.xml used
   * by Silverlight.
   */
  crossDomainPolicy?: string;
}

/**
 * @interface
 * An interface representing LiveEventActionInput.
 * The LiveEvent action input parameter definition.
 *
 */
export interface LiveEventActionInput {
  /**
   * @member {boolean} [removeOutputsOnStop] The flag indicates if remove
   * LiveOutputs on Stop.
   */
  removeOutputsOnStop?: boolean;
}

/**
 * @interface
 * An interface representing LiveEvent.
 * The Live Event.
 *
 * @extends TrackedResource
 */
export interface LiveEvent extends TrackedResource {
  /**
   * @member {string} [description] The Live Event description.
   */
  description?: string;
  /**
   * @member {LiveEventInput} input The Live Event input.
   */
  input: LiveEventInput;
  /**
   * @member {LiveEventPreview} [preview] The Live Event preview.
   */
  preview?: LiveEventPreview;
  /**
   * @member {LiveEventEncoding} [encoding] The Live Event encoding.
   */
  encoding?: LiveEventEncoding;
  /**
   * @member {string} [provisioningState] The provisioning state of the Live
   * Event.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly provisioningState?: string;
  /**
   * @member {LiveEventResourceState} [resourceState] The resource state of the
   * Live Event. Possible values include: 'Stopped', 'Starting', 'Running',
   * 'Stopping', 'Deleting'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly resourceState?: LiveEventResourceState;
  /**
   * @member {CrossSiteAccessPolicies} [crossSiteAccessPolicies] The Live Event
   * access policies.
   */
  crossSiteAccessPolicies?: CrossSiteAccessPolicies;
  /**
   * @member {boolean} [vanityUrl] Specifies whether to use a vanity url with
   * the Live Event.  This value is specified at creation time and cannot be
   * updated.
   */
  vanityUrl?: boolean;
  /**
   * @member {StreamOptionsFlag[]} [streamOptions] The options to use for the
   * LiveEvent.  This value is specified at creation time and cannot be
   * updated.
   */
  streamOptions?: StreamOptionsFlag[];
  /**
   * @member {Date} [created] The exact time the Live Event was created.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {Date} [lastModified] The exact time the Live Event was last
   * modified.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly lastModified?: Date;
}

/**
 * @interface
 * An interface representing AkamaiSignatureHeaderAuthenticationKey.
 * Akamai Signature Header authentication key.
 *
 */
export interface AkamaiSignatureHeaderAuthenticationKey {
  /**
   * @member {string} [identifier] identifier of the key
   */
  identifier?: string;
  /**
   * @member {string} [base64Key] authentication key
   */
  base64Key?: string;
  /**
   * @member {Date} [expiration] The expiration time of the authentication key.
   */
  expiration?: Date;
}

/**
 * @interface
 * An interface representing AkamaiAccessControl.
 * Akamai access control
 *
 */
export interface AkamaiAccessControl {
  /**
   * @member {AkamaiSignatureHeaderAuthenticationKey[]}
   * [akamaiSignatureHeaderAuthenticationKeyList] authentication key list
   */
  akamaiSignatureHeaderAuthenticationKeyList?: AkamaiSignatureHeaderAuthenticationKey[];
}

/**
 * @interface
 * An interface representing StreamingEndpointAccessControl.
 * StreamingEndpoint access control definition.
 *
 */
export interface StreamingEndpointAccessControl {
  /**
   * @member {AkamaiAccessControl} [akamai] The access control of Akamai
   */
  akamai?: AkamaiAccessControl;
  /**
   * @member {IPAccessControl} [ip] The IP access control of the
   * StreamingEndpoint.
   */
  ip?: IPAccessControl;
}

/**
 * @interface
 * An interface representing StreamingEntityScaleUnit.
 * scale units definition
 *
 */
export interface StreamingEntityScaleUnit {
  /**
   * @member {number} [scaleUnit] The scale unit number of the
   * StreamingEndpoint.
   */
  scaleUnit?: number;
}

/**
 * @interface
 * An interface representing StreamingEndpoint.
 * The StreamingEndpoint.
 *
 * @extends TrackedResource
 */
export interface StreamingEndpoint extends TrackedResource {
  /**
   * @member {string} [description] The StreamingEndpoint description.
   */
  description?: string;
  /**
   * @member {number} scaleUnits The number of scale units.  Use the Scale
   * operation to adjust this value.
   */
  scaleUnits: number;
  /**
   * @member {string} [availabilitySetName] The name of the AvailabilitySet
   * used with this StreamingEndpoint for high availability streaming.  This
   * value can only be set at creation time.
   */
  availabilitySetName?: string;
  /**
   * @member {StreamingEndpointAccessControl} [accessControl] The access
   * control definition of the StreamingEndpoint.
   */
  accessControl?: StreamingEndpointAccessControl;
  /**
   * @member {number} [maxCacheAge] Max cache age
   */
  maxCacheAge?: number;
  /**
   * @member {string[]} [customHostNames] The custom host names of the
   * StreamingEndpoint
   */
  customHostNames?: string[];
  /**
   * @member {string} [hostName] The StreamingEndpoint host name.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly hostName?: string;
  /**
   * @member {boolean} [cdnEnabled] The CDN enabled flag.
   */
  cdnEnabled?: boolean;
  /**
   * @member {string} [cdnProvider] The CDN provider name.
   */
  cdnProvider?: string;
  /**
   * @member {string} [cdnProfile] The CDN profile name.
   */
  cdnProfile?: string;
  /**
   * @member {string} [provisioningState] The provisioning state of the
   * StreamingEndpoint.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly provisioningState?: string;
  /**
   * @member {StreamingEndpointResourceState} [resourceState] The resource
   * state of the StreamingEndpoint. Possible values include: 'Stopped',
   * 'Starting', 'Running', 'Stopping', 'Deleting', 'Scaling'
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly resourceState?: StreamingEndpointResourceState;
  /**
   * @member {CrossSiteAccessPolicies} [crossSiteAccessPolicies] The
   * StreamingEndpoint access policies.
   */
  crossSiteAccessPolicies?: CrossSiteAccessPolicies;
  /**
   * @member {Date} [freeTrialEndTime] The free trial expiration time.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly freeTrialEndTime?: Date;
  /**
   * @member {Date} [created] The exact time the StreamingEndpoint was created.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly created?: Date;
  /**
   * @member {Date} [lastModified] The exact time the StreamingEndpoint was
   * last modified.
   * **NOTE: This property will not be serialized. It can only be populated by
   * the server.**
   */
  readonly lastModified?: Date;
}

/**
 * @interface
 * An interface representing AssetsListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface AssetsListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [filter] Restricts the set of items returned.
   */
  filter?: string;
  /**
   * @member {number} [top] Specifies a non-negative integer n that limits the
   * number of items returned from a collection. The service returns the number
   * of available items up to but not greater than the specified value n.
   */
  top?: number;
  /**
   * @member {string} [orderby] Specifies the the key by which the result
   * collection should be ordered.
   */
  orderby?: string;
}

/**
 * @interface
 * An interface representing ContentKeyPoliciesListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface ContentKeyPoliciesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [filter] Restricts the set of items returned.
   */
  filter?: string;
  /**
   * @member {number} [top] Specifies a non-negative integer n that limits the
   * number of items returned from a collection. The service returns the number
   * of available items up to but not greater than the specified value n.
   */
  top?: number;
  /**
   * @member {string} [orderby] Specifies the the key by which the result
   * collection should be ordered.
   */
  orderby?: string;
}

/**
 * @interface
 * An interface representing TransformsListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface TransformsListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [filter] Restricts the set of items returned.
   */
  filter?: string;
  /**
   * @member {string} [orderby] Specifies the the key by which the result
   * collection should be ordered.
   */
  orderby?: string;
}

/**
 * @interface
 * An interface representing JobsListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface JobsListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [filter] Restricts the set of items returned.
   */
  filter?: string;
  /**
   * @member {string} [orderby] Specifies the the key by which the result
   * collection should be ordered.
   */
  orderby?: string;
}

/**
 * @interface
 * An interface representing StreamingPoliciesListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface StreamingPoliciesListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [filter] Restricts the set of items returned.
   */
  filter?: string;
  /**
   * @member {number} [top] Specifies a non-negative integer n that limits the
   * number of items returned from a collection. The service returns the number
   * of available items up to but not greater than the specified value n.
   */
  top?: number;
  /**
   * @member {string} [orderby] Specifies the key by which the result
   * collection should be ordered.
   */
  orderby?: string;
}

/**
 * @interface
 * An interface representing StreamingLocatorsListOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface StreamingLocatorsListOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {string} [filter] Restricts the set of items returned.
   */
  filter?: string;
  /**
   * @member {number} [top] Specifies a non-negative integer n that limits the
   * number of items returned from a collection. The service returns the number
   * of available items up to but not greater than the specified value n.
   */
  top?: number;
  /**
   * @member {string} [orderby] Specifies the key by which the result
   * collection should be ordered.
   */
  orderby?: string;
}

/**
 * @interface
 * An interface representing LiveEventsCreateOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface LiveEventsCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [autoStart] The flag indicates if the resource should be
   * automatically started on creation.
   */
  autoStart?: boolean;
}

/**
 * @interface
 * An interface representing LiveEventsBeginCreateOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface LiveEventsBeginCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [autoStart] The flag indicates if the resource should be
   * automatically started on creation.
   */
  autoStart?: boolean;
}

/**
 * @interface
 * An interface representing StreamingEndpointsCreateOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface StreamingEndpointsCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [autoStart] The flag indicates if the resource should be
   * automatically started on creation.
   */
  autoStart?: boolean;
}

/**
 * @interface
 * An interface representing StreamingEndpointsBeginCreateOptionalParams.
 * Optional Parameters.
 *
 * @extends RequestOptionsBase
 */
export interface StreamingEndpointsBeginCreateOptionalParams extends msRest.RequestOptionsBase {
  /**
   * @member {boolean} [autoStart] The flag indicates if the resource should be
   * automatically started on creation.
   */
  autoStart?: boolean;
}

/**
 * @interface
 * An interface representing AzureMediaServicesOptions.
 * @extends AzureServiceClientOptions
 */
export interface AzureMediaServicesOptions extends AzureServiceClientOptions {
  /**
   * @member {string} [baseUri]
   */
  baseUri?: string;
}


/**
 * @interface
 * An interface representing the AccountFilterCollection.
 * A collection of AccountFilter items.
 *
 * @extends Array<AccountFilter>
 */
export interface AccountFilterCollection extends Array<AccountFilter> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the OperationCollection.
 * A collection of Operation items.
 *
 * @extends Array<Operation>
 */
export interface OperationCollection extends Array<Operation> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the MediaServiceCollection.
 * A collection of MediaService items.
 *
 * @extends Array<MediaService>
 */
export interface MediaServiceCollection extends Array<MediaService> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the SubscriptionMediaServiceCollection.
 * A collection of SubscriptionMediaService items.
 *
 * @extends Array<SubscriptionMediaService>
 */
export interface SubscriptionMediaServiceCollection extends Array<SubscriptionMediaService> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the AssetCollection.
 * A collection of Asset items.
 *
 * @extends Array<Asset>
 */
export interface AssetCollection extends Array<Asset> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the AssetFilterCollection.
 * A collection of AssetFilter items.
 *
 * @extends Array<AssetFilter>
 */
export interface AssetFilterCollection extends Array<AssetFilter> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the ContentKeyPolicyCollection.
 * A collection of ContentKeyPolicy items.
 *
 * @extends Array<ContentKeyPolicy>
 */
export interface ContentKeyPolicyCollection extends Array<ContentKeyPolicy> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the TransformCollection.
 * A collection of Transform items.
 *
 * @extends Array<Transform>
 */
export interface TransformCollection extends Array<Transform> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the JobCollection.
 * A collection of Job items.
 *
 * @extends Array<Job>
 */
export interface JobCollection extends Array<Job> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the StreamingPolicyCollection.
 * A collection of StreamingPolicy items.
 *
 * @extends Array<StreamingPolicy>
 */
export interface StreamingPolicyCollection extends Array<StreamingPolicy> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the StreamingLocatorCollection.
 * A collection of StreamingLocator items.
 *
 * @extends Array<StreamingLocator>
 */
export interface StreamingLocatorCollection extends Array<StreamingLocator> {
  /**
   * @member {string} [odatanextLink] A link to the next page of the collection
   * (when the collection contains too many results to return in one response).
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the LiveEventListResult.
 * @summary LiveEventListResult
 *
 * The LiveEvent list result.
 *
 * @extends Array<LiveEvent>
 */
export interface LiveEventListResult extends Array<LiveEvent> {
  /**
   * @member {number} [odatacount] The number of result.
   */
  odatacount?: number;
  /**
   * @member {string} [odatanextLink] Th link to the next set of results. Not
   * empty if value contains incomplete list of Live Outputs.
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the LiveOutputListResult.
 * @summary LiveOutputListResult
 *
 * The LiveOutput list result.
 *
 * @extends Array<LiveOutput>
 */
export interface LiveOutputListResult extends Array<LiveOutput> {
  /**
   * @member {number} [odatacount] The number of result.
   */
  odatacount?: number;
  /**
   * @member {string} [odatanextLink] Th link to the next set of results. Not
   * empty if value contains incomplete list of Live Outputs.
   */
  odatanextLink?: string;
}

/**
 * @interface
 * An interface representing the StreamingEndpointListResult.
 * @summary StreamingEndpointListResult
 *
 * The StreamingEndpoint list result.
 *
 * @extends Array<StreamingEndpoint>
 */
export interface StreamingEndpointListResult extends Array<StreamingEndpoint> {
  /**
   * @member {number} [odatacount] The number of result.
   */
  odatacount?: number;
  /**
   * @member {string} [odatanextLink] Th link to the next set of results. Not
   * empty if value contains incomplete list of StreamingEndpoints.
   */
  odatanextLink?: string;
}

/**
 * Defines values for FilterTrackPropertyType.
 * Possible values include: 'Unknown', 'Type', 'Name', 'Language', 'FourCC', 'Bitrate'
 * @readonly
 * @enum {string}
 */
export type FilterTrackPropertyType = 'Unknown' | 'Type' | 'Name' | 'Language' | 'FourCC' | 'Bitrate';

/**
 * Defines values for FilterTrackPropertyCompareOperation.
 * Possible values include: 'Equal', 'NotEqual'
 * @readonly
 * @enum {string}
 */
export type FilterTrackPropertyCompareOperation = 'Equal' | 'NotEqual';

/**
 * Defines values for MetricUnit.
 * Possible values include: 'Bytes', 'Count', 'Milliseconds'
 * @readonly
 * @enum {string}
 */
export type MetricUnit = 'Bytes' | 'Count' | 'Milliseconds';

/**
 * Defines values for MetricAggregationType.
 * Possible values include: 'Average', 'Count', 'Total'
 * @readonly
 * @enum {string}
 */
export type MetricAggregationType = 'Average' | 'Count' | 'Total';

/**
 * Defines values for StorageAccountType.
 * Possible values include: 'Primary', 'Secondary'
 * @readonly
 * @enum {string}
 */
export type StorageAccountType = 'Primary' | 'Secondary';

/**
 * Defines values for AssetStorageEncryptionFormat.
 * Possible values include: 'None', 'MediaStorageClientEncryption'
 * @readonly
 * @enum {string}
 */
export type AssetStorageEncryptionFormat = 'None' | 'MediaStorageClientEncryption';

/**
 * Defines values for AssetContainerPermission.
 * Possible values include: 'Read', 'ReadWrite', 'ReadWriteDelete'
 * @readonly
 * @enum {string}
 */
export type AssetContainerPermission = 'Read' | 'ReadWrite' | 'ReadWriteDelete';

/**
 * Defines values for ContentKeyPolicyPlayReadyUnknownOutputPassingOption.
 * Possible values include: 'Unknown', 'NotAllowed', 'Allowed', 'AllowedWithVideoConstriction'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyPlayReadyUnknownOutputPassingOption = 'Unknown' | 'NotAllowed' | 'Allowed' | 'AllowedWithVideoConstriction';

/**
 * Defines values for ContentKeyPolicyPlayReadyLicenseType.
 * Possible values include: 'Unknown', 'NonPersistent', 'Persistent'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyPlayReadyLicenseType = 'Unknown' | 'NonPersistent' | 'Persistent';

/**
 * Defines values for ContentKeyPolicyPlayReadyContentType.
 * Possible values include: 'Unknown', 'Unspecified', 'UltraVioletDownload', 'UltraVioletStreaming'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyPlayReadyContentType = 'Unknown' | 'Unspecified' | 'UltraVioletDownload' | 'UltraVioletStreaming';

/**
 * Defines values for ContentKeyPolicyRestrictionTokenType.
 * Possible values include: 'Unknown', 'Swt', 'Jwt'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyRestrictionTokenType = 'Unknown' | 'Swt' | 'Jwt';

/**
 * Defines values for ContentKeyPolicyFairPlayRentalAndLeaseKeyType.
 * Possible values include: 'Unknown', 'Undefined', 'PersistentUnlimited', 'PersistentLimited'
 * @readonly
 * @enum {string}
 */
export type ContentKeyPolicyFairPlayRentalAndLeaseKeyType = 'Unknown' | 'Undefined' | 'PersistentUnlimited' | 'PersistentLimited';

/**
 * Defines values for AacAudioProfile.
 * Possible values include: 'AacLc', 'HeAacV1', 'HeAacV2'
 * @readonly
 * @enum {string}
 */
export type AacAudioProfile = 'AacLc' | 'HeAacV1' | 'HeAacV2';

/**
 * Defines values for StretchMode.
 * Possible values include: 'None', 'AutoSize', 'AutoFit'
 * @readonly
 * @enum {string}
 */
export type StretchMode = 'None' | 'AutoSize' | 'AutoFit';

/**
 * Defines values for DeinterlaceParity.
 * Possible values include: 'Auto', 'TopFieldFirst', 'BottomFieldFirst'
 * @readonly
 * @enum {string}
 */
export type DeinterlaceParity = 'Auto' | 'TopFieldFirst' | 'BottomFieldFirst';

/**
 * Defines values for DeinterlaceMode.
 * Possible values include: 'Off', 'AutoPixelAdaptive'
 * @readonly
 * @enum {string}
 */
export type DeinterlaceMode = 'Off' | 'AutoPixelAdaptive';

/**
 * Defines values for Rotation.
 * Possible values include: 'Auto', 'None', 'Rotate0', 'Rotate90', 'Rotate180', 'Rotate270'
 * @readonly
 * @enum {string}
 */
export type Rotation = 'Auto' | 'None' | 'Rotate0' | 'Rotate90' | 'Rotate180' | 'Rotate270';

/**
 * Defines values for H264VideoProfile.
 * Possible values include: 'Auto', 'Baseline', 'Main', 'High', 'High422', 'High444'
 * @readonly
 * @enum {string}
 */
export type H264VideoProfile = 'Auto' | 'Baseline' | 'Main' | 'High' | 'High422' | 'High444';

/**
 * Defines values for EntropyMode.
 * Possible values include: 'Cabac', 'Cavlc'
 * @readonly
 * @enum {string}
 */
export type EntropyMode = 'Cabac' | 'Cavlc';

/**
 * Defines values for H264Complexity.
 * Possible values include: 'Speed', 'Balanced', 'Quality'
 * @readonly
 * @enum {string}
 */
export type H264Complexity = 'Speed' | 'Balanced' | 'Quality';

/**
 * Defines values for EncoderNamedPreset.
 * Possible values include: 'H264SingleBitrateSD', 'H264SingleBitrate720p',
 * 'H264SingleBitrate1080p', 'AdaptiveStreaming', 'AACGoodQualityAudio',
 * 'H264MultipleBitrate1080p', 'H264MultipleBitrate720p', 'H264MultipleBitrateSD'
 * @readonly
 * @enum {string}
 */
export type EncoderNamedPreset = 'H264SingleBitrateSD' | 'H264SingleBitrate720p' | 'H264SingleBitrate1080p' | 'AdaptiveStreaming' | 'AACGoodQualityAudio' | 'H264MultipleBitrate1080p' | 'H264MultipleBitrate720p' | 'H264MultipleBitrateSD';

/**
 * Defines values for InsightsType.
 * Possible values include: 'AudioInsightsOnly', 'VideoInsightsOnly', 'AllInsights'
 * @readonly
 * @enum {string}
 */
export type InsightsType = 'AudioInsightsOnly' | 'VideoInsightsOnly' | 'AllInsights';

/**
 * Defines values for OnErrorType.
 * Possible values include: 'StopProcessingJob', 'ContinueJob'
 * @readonly
 * @enum {string}
 */
export type OnErrorType = 'StopProcessingJob' | 'ContinueJob';

/**
 * Defines values for Priority.
 * Possible values include: 'Low', 'Normal', 'High'
 * @readonly
 * @enum {string}
 */
export type Priority = 'Low' | 'Normal' | 'High';

/**
 * Defines values for JobErrorCode.
 * Possible values include: 'ServiceError', 'ServiceTransientError', 'DownloadNotAccessible',
 * 'DownloadTransientError', 'UploadNotAccessible', 'UploadTransientError',
 * 'ConfigurationUnsupported', 'ContentMalformed', 'ContentUnsupported'
 * @readonly
 * @enum {string}
 */
export type JobErrorCode = 'ServiceError' | 'ServiceTransientError' | 'DownloadNotAccessible' | 'DownloadTransientError' | 'UploadNotAccessible' | 'UploadTransientError' | 'ConfigurationUnsupported' | 'ContentMalformed' | 'ContentUnsupported';

/**
 * Defines values for JobErrorCategory.
 * Possible values include: 'Service', 'Download', 'Upload', 'Configuration', 'Content'
 * @readonly
 * @enum {string}
 */
export type JobErrorCategory = 'Service' | 'Download' | 'Upload' | 'Configuration' | 'Content';

/**
 * Defines values for JobRetry.
 * Possible values include: 'DoNotRetry', 'MayRetry'
 * @readonly
 * @enum {string}
 */
export type JobRetry = 'DoNotRetry' | 'MayRetry';

/**
 * Defines values for JobState.
 * Possible values include: 'Canceled', 'Canceling', 'Error', 'Finished', 'Processing', 'Queued',
 * 'Scheduled'
 * @readonly
 * @enum {string}
 */
export type JobState = 'Canceled' | 'Canceling' | 'Error' | 'Finished' | 'Processing' | 'Queued' | 'Scheduled';

/**
 * Defines values for TrackPropertyType.
 * Possible values include: 'Unknown', 'FourCC'
 * @readonly
 * @enum {string}
 */
export type TrackPropertyType = 'Unknown' | 'FourCC';

/**
 * Defines values for TrackPropertyCompareOperation.
 * Possible values include: 'Unknown', 'Equal'
 * @readonly
 * @enum {string}
 */
export type TrackPropertyCompareOperation = 'Unknown' | 'Equal';

/**
 * Defines values for StreamingLocatorContentKeyType.
 * Possible values include: 'CommonEncryptionCenc', 'CommonEncryptionCbcs', 'EnvelopeEncryption'
 * @readonly
 * @enum {string}
 */
export type StreamingLocatorContentKeyType = 'CommonEncryptionCenc' | 'CommonEncryptionCbcs' | 'EnvelopeEncryption';

/**
 * Defines values for StreamingPolicyStreamingProtocol.
 * Possible values include: 'Hls', 'Dash', 'SmoothStreaming', 'Download'
 * @readonly
 * @enum {string}
 */
export type StreamingPolicyStreamingProtocol = 'Hls' | 'Dash' | 'SmoothStreaming' | 'Download';

/**
 * Defines values for EncryptionScheme.
 * Possible values include: 'NoEncryption', 'EnvelopeEncryption', 'CommonEncryptionCenc',
 * 'CommonEncryptionCbcs'
 * @readonly
 * @enum {string}
 */
export type EncryptionScheme = 'NoEncryption' | 'EnvelopeEncryption' | 'CommonEncryptionCenc' | 'CommonEncryptionCbcs';

/**
 * Defines values for LiveOutputResourceState.
 * Possible values include: 'Creating', 'Running', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type LiveOutputResourceState = 'Creating' | 'Running' | 'Deleting';

/**
 * Defines values for LiveEventInputProtocol.
 * Possible values include: 'FragmentedMP4', 'RTMP'
 * @readonly
 * @enum {string}
 */
export type LiveEventInputProtocol = 'FragmentedMP4' | 'RTMP';

/**
 * Defines values for LiveEventEncodingType.
 * Possible values include: 'None', 'Basic', 'Standard'
 * @readonly
 * @enum {string}
 */
export type LiveEventEncodingType = 'None' | 'Basic' | 'Standard';

/**
 * Defines values for LiveEventResourceState.
 * Possible values include: 'Stopped', 'Starting', 'Running', 'Stopping', 'Deleting'
 * @readonly
 * @enum {string}
 */
export type LiveEventResourceState = 'Stopped' | 'Starting' | 'Running' | 'Stopping' | 'Deleting';

/**
 * Defines values for StreamOptionsFlag.
 * Possible values include: 'Default', 'LowLatency'
 * @readonly
 * @enum {string}
 */
export type StreamOptionsFlag = 'Default' | 'LowLatency';

/**
 * Defines values for StreamingEndpointResourceState.
 * Possible values include: 'Stopped', 'Starting', 'Running', 'Stopping', 'Deleting', 'Scaling'
 * @readonly
 * @enum {string}
 */
export type StreamingEndpointResourceState = 'Stopped' | 'Starting' | 'Running' | 'Stopping' | 'Deleting' | 'Scaling';

/**
 * Contains response data for the list operation.
 */
export type AccountFiltersListResponse = AccountFilterCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilterCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AccountFiltersGetResponse = AccountFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilter;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type AccountFiltersCreateOrUpdateResponse = AccountFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilter;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AccountFiltersUpdateResponse = AccountFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilter;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type AccountFiltersListNextResponse = AccountFilterCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AccountFilterCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type OperationsListResponse = OperationCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationCollection;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type OperationsListNextResponse = OperationCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: OperationCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type MediaservicesListResponse = MediaServiceCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaServiceCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type MediaservicesGetResponse = MediaService & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaService;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type MediaservicesCreateOrUpdateResponse = MediaService & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaService;
    };
};

/**
 * Contains response data for the update operation.
 */
export type MediaservicesUpdateResponse = MediaService & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaService;
    };
};

/**
 * Contains response data for the listBySubscription operation.
 */
export type MediaservicesListBySubscriptionResponse = SubscriptionMediaServiceCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SubscriptionMediaServiceCollection;
    };
};

/**
 * Contains response data for the getBySubscription operation.
 */
export type MediaservicesGetBySubscriptionResponse = SubscriptionMediaService & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SubscriptionMediaService;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type MediaservicesListNextResponse = MediaServiceCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: MediaServiceCollection;
    };
};

/**
 * Contains response data for the listBySubscriptionNext operation.
 */
export type MediaservicesListBySubscriptionNextResponse = SubscriptionMediaServiceCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: SubscriptionMediaServiceCollection;
    };
};

/**
 * Contains response data for the checkNameAvailability operation.
 */
export type LocationsCheckNameAvailabilityResponse = EntityNameAvailabilityCheckOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: EntityNameAvailabilityCheckOutput;
    };
};

/**
 * Contains response data for the list operation.
 */
export type AssetsListResponse = AssetCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AssetsGetResponse = Asset & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Asset;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type AssetsCreateOrUpdateResponse = Asset & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Asset;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AssetsUpdateResponse = Asset & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Asset;
    };
};

/**
 * Contains response data for the listContainerSas operation.
 */
export type AssetsListContainerSasResponse = AssetContainerSas & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetContainerSas;
    };
};

/**
 * Contains response data for the getEncryptionKey operation.
 */
export type AssetsGetEncryptionKeyResponse = StorageEncryptedAssetDecryptionData & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StorageEncryptedAssetDecryptionData;
    };
};

/**
 * Contains response data for the listStreamingLocators operation.
 */
export type AssetsListStreamingLocatorsResponse = ListStreamingLocatorsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ListStreamingLocatorsResponse;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type AssetsListNextResponse = AssetCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type AssetFiltersListResponse = AssetFilterCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilterCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type AssetFiltersGetResponse = AssetFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilter;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type AssetFiltersCreateOrUpdateResponse = AssetFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilter;
    };
};

/**
 * Contains response data for the update operation.
 */
export type AssetFiltersUpdateResponse = AssetFilter & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilter;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type AssetFiltersListNextResponse = AssetFilterCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: AssetFilterCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type ContentKeyPoliciesListResponse = ContentKeyPolicyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicyCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type ContentKeyPoliciesGetResponse = ContentKeyPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicy;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type ContentKeyPoliciesCreateOrUpdateResponse = ContentKeyPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicy;
    };
};

/**
 * Contains response data for the update operation.
 */
export type ContentKeyPoliciesUpdateResponse = ContentKeyPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicy;
    };
};

/**
 * Contains response data for the getPolicyPropertiesWithSecrets operation.
 */
export type ContentKeyPoliciesGetPolicyPropertiesWithSecretsResponse = ContentKeyPolicyProperties & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicyProperties;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type ContentKeyPoliciesListNextResponse = ContentKeyPolicyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ContentKeyPolicyCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type TransformsListResponse = TransformCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TransformCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type TransformsGetResponse = Transform & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Transform;
    };
};

/**
 * Contains response data for the createOrUpdate operation.
 */
export type TransformsCreateOrUpdateResponse = Transform & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Transform;
    };
};

/**
 * Contains response data for the update operation.
 */
export type TransformsUpdateResponse = Transform & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Transform;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type TransformsListNextResponse = TransformCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: TransformCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type JobsListResponse = JobCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: JobCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type JobsGetResponse = Job & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Job;
    };
};

/**
 * Contains response data for the create operation.
 */
export type JobsCreateResponse = Job & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Job;
    };
};

/**
 * Contains response data for the update operation.
 */
export type JobsUpdateResponse = Job & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: Job;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type JobsListNextResponse = JobCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: JobCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type StreamingPoliciesListResponse = StreamingPolicyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingPolicyCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type StreamingPoliciesGetResponse = StreamingPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingPolicy;
    };
};

/**
 * Contains response data for the create operation.
 */
export type StreamingPoliciesCreateResponse = StreamingPolicy & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingPolicy;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type StreamingPoliciesListNextResponse = StreamingPolicyCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingPolicyCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type StreamingLocatorsListResponse = StreamingLocatorCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingLocatorCollection;
    };
};

/**
 * Contains response data for the get operation.
 */
export type StreamingLocatorsGetResponse = StreamingLocator & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingLocator;
    };
};

/**
 * Contains response data for the create operation.
 */
export type StreamingLocatorsCreateResponse = StreamingLocator & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingLocator;
    };
};

/**
 * Contains response data for the listContentKeys operation.
 */
export type StreamingLocatorsListContentKeysResponse = ListContentKeysResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ListContentKeysResponse;
    };
};

/**
 * Contains response data for the listPaths operation.
 */
export type StreamingLocatorsListPathsResponse = ListPathsResponse & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: ListPathsResponse;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type StreamingLocatorsListNextResponse = StreamingLocatorCollection & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingLocatorCollection;
    };
};

/**
 * Contains response data for the list operation.
 */
export type LiveEventsListResponse = LiveEventListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEventListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type LiveEventsGetResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the create operation.
 */
export type LiveEventsCreateResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the update operation.
 */
export type LiveEventsUpdateResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type LiveEventsBeginCreateResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type LiveEventsBeginUpdateResponse = LiveEvent & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEvent;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type LiveEventsListNextResponse = LiveEventListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveEventListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type LiveOutputsListResponse = LiveOutputListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutputListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type LiveOutputsGetResponse = LiveOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutput;
    };
};

/**
 * Contains response data for the create operation.
 */
export type LiveOutputsCreateResponse = LiveOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutput;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type LiveOutputsBeginCreateResponse = LiveOutput & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutput;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type LiveOutputsListNextResponse = LiveOutputListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: LiveOutputListResult;
    };
};

/**
 * Contains response data for the list operation.
 */
export type StreamingEndpointsListResponse = StreamingEndpointListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpointListResult;
    };
};

/**
 * Contains response data for the get operation.
 */
export type StreamingEndpointsGetResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the create operation.
 */
export type StreamingEndpointsCreateResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the update operation.
 */
export type StreamingEndpointsUpdateResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the beginCreate operation.
 */
export type StreamingEndpointsBeginCreateResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the beginUpdate operation.
 */
export type StreamingEndpointsBeginUpdateResponse = StreamingEndpoint & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpoint;
    };
};

/**
 * Contains response data for the listNext operation.
 */
export type StreamingEndpointsListNextResponse = StreamingEndpointListResult & {
  /**
   * The underlying HTTP response.
   */
  _response: msRest.HttpResponse & {
      /**
       * The response body as text (string format)
       */
      bodyAsText: string;
      /**
       * The response body as parsed JSON or XML
       */
      parsedBody: StreamingEndpointListResult;
    };
};
